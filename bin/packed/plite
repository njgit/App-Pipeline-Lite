#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Pipeline/Lite4.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4';
  use strict;
  use warnings;
  package App::Pipeline::Lite4;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  extends 'App::Pipeline::Lite4::Base';
  use App::Pipeline::Lite4::Util;
  use App::Pipeline::Lite4::Parser; 
  use App::Pipeline::Lite4::Resolver;
  use App::Pipeline::Lite4::Grapher;
  use File::Copy;
  use Data::Dumper;
  has smoke_test => ( isa => 'Bool', is => 'rw', default => sub {0} ); 
  has external_dispatcher => ( isa => 'Path::Tiny|Undef', is => 'rw', 
                                lazy_build => 1 );
  
  sub _build_external_dispatcher {
      my $self = shift;  
        
      my $dispatcher = $self->config->{_}->{dispatcher}; #check local config 
      
      # if does not exist, check system config    
      $dispatcher = $self->system_config->{_}->{dispatcher} 
                                 unless defined( $dispatcher);
      
      defined($dispatcher) ?  path($dispatcher) : undef;    
  }
  
  sub util {
      my $self = shift;
      # give back object with utilities
      return App::Pipeline::Lite4::Util->new(  pipeline_dir => $self->pipeline_dir);
  }
  
  sub run_pipeline {
      my $self = shift;   
      my $pipeline_file = shift; 
  
     # RESOLVE DATASOURCE HERE
  
      my $parser = App::Pipeline::Lite4::Parser->new(
          pipeline_dir => $self->pipeline_dir,
       );
      
      $parser->preparse(  $self->pipeline_file, 
                          $self->pipeline_preparse_file ); 
      
      $parser->parse(  $self->pipeline_preparse_file, 
                       $self->pipeline_parse_file  );
      #warn "WORKING WITH DATASOURCE: " .    $self->datasource_file;
        
      my $resolver = App::Pipeline::Lite4::Resolver->new (                      
                         pipeline_dir         => $self->pipeline_dir,
                         #datasource_file      => $self->datasource_resolved_file,
                         datasource_file      => $self->datasource_file,
                         current_run_num      => defined( $self->run_num ) ? $self->run_num : undef,
                         step_filter_str      => defined( $self->step_filter_str) ? $self->step_filter_str : undef,
                         job_filter_str       => defined( $self->job_filter_str) ? $self->job_filter_str : undef,
                         #run_num_dep          => defined( $self->run_num_dep ) ? $self->run_num_dep : undef
                         );   
                         
     #warn Dumper $resolver->pipeline_datasource;                                       
     
     $resolver->resolve($self->pipeline_parse_file,$self->pipeline_resolved_file); 
     
     
      my $grapher = App::Pipeline::Lite4::Grapher->new ( 
                         pipeline_dir    => $self->pipeline_dir,
                         datasource_file => $self->datasource_file,
                         );     
                                           
      $grapher->add_dependents(  $self->pipeline_resolved_file, 
                                 $self->pipeline_graph_file );                
       
      # copy stuff over to settings directory
      my $run_num = $resolver->current_run_num;
      $self->copy_pipeline_files_to_run_settings_dir($run_num); 
       
      if ( ! $self->smoke_test ) { 
     
        if( defined( $self->external_dispatcher ) ) {       
           $self->external_dispatch( $self->external_dispatcher );            
        } else {
            print "\n*** dispatcher not defined - see config file ***\n";
            # warn using local dispatch option
            #print "\n***\n\nUsing built in dispatcher\n\n***\n";
            #my $dispatcher = App::Pipeline::Lite4::Dispatcher->new( 
            #             pipeline_graph_file => $self->pipeline_graph_file,
            #             logfile => $self->logfile );                                      
            #$dispatcher->dispatch;    
       }
     }else{      
       $self->logger->debug("Smoke Test!");    
     }
     
  
  }
  
  sub external_dispatch {
     # TYPE  Path::Tiny :$dispatcher_exe )  {
      my $self=shift;
      my $dispatcher_exe=shift;
      
      my $pipeline_dir = $self->pipeline_dir->absolute->stringify;
      ouch 'App_Pipeline_Lite4_Error', "Dispatcher does not exist at $dispatcher_exe" 
       unless $dispatcher_exe->exists;
      
       my $dispatcher_path_str = $dispatcher_exe->absolute->stringify;     
      ouch  'App_Pipeline_Lite4_Error', "Dispatcher app is not executable" 
        unless ( -x $dispatcher_path_str);  
        
      my $dispatcher_cmd =  qq{ $dispatcher_path_str  $pipeline_dir };
      system( $dispatcher_cmd );    
  }
  
  
  sub copy_pipeline_files_to_run_settings_dir  {
     
     my $self = shift;
     my $run_num = shift;
     $self->new_run_settings_dir($run_num)->mkpath unless $self->new_run_settings_dir($run_num)->exists;  
     
     copy( $self->pipeline_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy pipeline file to run settings directory";
     
     copy( $self->pipeline_graph_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy graph file to run settings directory";
      
     copy( $self->datasource_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy datasource file to run settings directory"; 
       
     #make a standardised version to the pipeline name 
     copy( $self->datasource_file->stringify , path( $self->run_settings_dir($run_num), $self->pipeline_name . ".datasource" )->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy datasource file to run settings directory"; 
      
     #copy( $self->datasource_resolved_file->stringify , $self->run_settings_dir($run_num)->stringify )
     #  or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy resolved datasource file to run settings directory"; 
       
     if( $self->software_ini_file->exists){ 
         copy( $self->software_ini_file->stringify , $self->run_settings_dir($run_num)->stringify )
           or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy software ini file to run settings directory";
     }
  }
  
  
  
  1;
APP_PIPELINE_LITE4

$fatpacked{"App/Pipeline/Lite4/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_BASE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Base;
  use Moo;
  use MooX::late;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  use Config::Tiny;
  use Ouch;
  use File::HomeDir; 
  use Data::Table;
  use App::Pipeline::Lite4::Logger; 
  use List::Util qw(max);
  
  has pipeline_dir  => ( isa => Path,  is => 'rw', coerce => 1, trigger  => \&_pipeline_dir_trigger);
  has use_relative_paths  => (isa => 'Bool', is => 'rw', default => sub {0});
  has pipeline_name    => ( isa => 'Str', is => 'rw', lazy_build => 1);
  has pipeline_file    => ( isa => Path, is => 'rw',  lazy_build => 1);
  has logfile          => ( isa => Path, is => 'rw', lazy_build => 1);
  has logconf          => ( isa => 'HashRef|Undef', is => 'rw', lazy_build => 1);
  has logconffile      => ( isa => Path, is => 'rw',  lazy_build => 1);
  has logger           => ( isa => 'App::Pipeline::Lite4::Logger', lazy_build=>1);
  has system_logfile   => ( isa => Path, is => 'rw',  lazy_build => 1);
  has system_logger    => ( isa => 'App::Pipeline::Lite4::Logger', lazy_build=>1);
  # config locations
  
  has config           => ( isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has config_file      => ( isa => Path, is => 'rw', coerce => 1, lazy_build => 1);
  has system_config      => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 ); 
  has system_config_file => ( isa => Path, is => 'rw', coerce => 1, lazy_build => 1);
  
  =cut
  has logconffile      => ( isa => Path, is => 'rw',  lazy_build => 1);
  =cut
  
  has output_dir       => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build => 1 );
  has input_dir        => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has software_dir     => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has software_ini      => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has software_ini_file => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has test_data_file   => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
  has datasource_file  => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
  has datasource_resolved_file  => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
   
  has pipeline_preparse_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_parse_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_resolved_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_graph_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 );
  has pipeline_submission_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 );
  has pipeline_datasource  => ( isa => 'Data::Table', is => 'rw', lazy_build =>1 ); #used in util.
  
  has symlink_dir => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build => 1 );
  has output_run_name => (  isa => 'Str', is => 'rw', default => sub {return 'run'} );
  has output_job_name => (  isa => 'Str', is => 'rw', default => sub {return 'job'} );
  has run_settings_name => ( isa => 'Str', is => 'rw', default => sub {return 'settings'});
  
  has run_num => ( isa => 'Str', is => 'rw'); 
  has job_filter_str  => ( isa => 'Str|Undef', is => 'rw');
  has step_filter_str => ( isa => 'Str|Undef', is => 'rw');
  has argument_str    => ( isa => 'Str|Undef', is => 'rw'  );
  
  
  sub _pipeline_dir_trigger {
      my $self = shift;
      return if $self->pipeline_dir->is_absolute;
      if ($self->use_relative_paths){
          warn "USING RELATIVE PATHS";
          warn "The pipeline_dir is relative " if $self->pipeline_dir->is_relative;
          warn "But the pipeline_dir is absolute" if $self->pipeline_dir->is_absolute;
      } else {
         $self->pipeline_dir( $self->pipeline_dir->absolute );
      }
  }
  
  sub _build_pipeline_name {
      my $self = shift;
      return $self->pipeline_dir->basename; 
  }
  
  sub _build_pipeline_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.pipeline' ); 
  }
  
  sub _build_pipeline_preparse_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.preparse.yaml') ; 
  }
  
  sub _build_pipeline_parse_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.parse.yaml') ; 
  }
  
  sub _build_pipeline_resolved_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.resolved.yaml') ; 
  }
  
  sub _build_pipeline_graph_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.graph.yaml') ; 
  }
  
  sub _build_pipeline_submission_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.submissions.txt') ; 
  }
  
  sub _build_pipeline_datasource {
      my $self = shift;
      my $datasourcefile = path( $self->datasource_file )->absolute;  
      ouch 'badfile', "Need to provide datasource file location\n" unless defined( $datasourcefile);
      #my $t =  App::Pipeline::Lite2::Datasource->new( datasource_file => $datasourcefile );         
      my $t = Data::Table::fromTSV( $datasourcefile->stringify );
  }
  
  sub _build_logfile {
      my $self = shift;
      #return file($self->pipeline_dir, $self->pipeline_name .".log")->stringify;
      #this should be able to be set system/user wide
      my $tmp_dir = "/tmp/";
      return path($tmp_dir, $self->pipeline_name .".log") #->stringify;
  }
  
  sub _build_system_logfile {
      my $self = shift;
      #return file($self->pipeline_dir, $self->pipeline_name .".log")->stringify;
      #this should be able to be set system/user wide
      my $sys_log_dir = File::HomeDir->my_data;
      return path($sys_log_dir, "plite.log"); #->stringify;
  }
  
  sub _build_software_ini_file {
     my $self = shift;  
     my $file = path($self->software_dir, 'software.ini');
     return $file;
  }
  
  sub _build_software_ini {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->software_ini_file->exists;
      my $conf = $cf->read( $self->software_ini_file->absolute->stringify ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_logger {
      my $self = shift;   
      my $logger = App::Pipeline::Lite4::Logger->new( logfile => $self->logfile) ;    
      return $logger; 
  }
  
  sub _build_system_logger {
      my $self = shift;
      my $logger = App::Pipeline::Lite4::Logger->new( logfile => $self->system_logfile) ;    
      return $logger;
  }
  
  sub _build_logconf {
      my $self = shift;
      # open YAML config file
       my $logconf_yaml =  $self->logconffile->stat
        ? $self->logconffile->slurp
        : return undef;
      my $logconfig = Load($logconf_yaml);
      return $logconfig;
  }
  
  sub _build_logconffile {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.log.conf' );
  }
  
  sub _build_config_file {
     my $self = shift;  
     my $file = path($self->pipeline_dir, $self->pipeline_name.'.ini');
     #print "config file is $file\n";
     #$file->touch;
     return $file;
  }
  
  sub _build_config {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->config_file->exists;
      my $conf = $cf->read( $self->config_file ) 
         or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_system_config {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->system_config_file->exists;
      my $conf = $cf->read( $self->system_config_file ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_system_config_file {
     my $self = shift;  
     my $system_config_dir = File::HomeDir->my_dist_config('App-Pipeline-Lite4', { create => 1 });
     my $system_config_file = path($system_config_dir, 'config.ini');
     #print "config file is $file\n";
     #$file->touch;
     return $system_config_file;
  }
  
  sub _build_output_dir {
      my $self = shift;
      my $output_dir = $self->config->{_}->{output_dir}; 
      return path($output_dir) if(defined( $output_dir)) ;
      return path( $self->pipeline_dir, 'output'  ); 
  }
  
  sub _build_input_dir {
      my $self = shift;
      my $input_dir = $self->config->{_}->{input_dir}; 
      return path($input_dir) if(defined( $input_dir)) ;
      return path( $self->pipeline_dir, 'input'  ); 
  }
  
  
  sub _build_symlink_dir {
      my $self = shift;
      my $symlink_dir = $self->config->{_}->{symlink_dir}; 
      return path($symlink_dir) if(defined( $symlink_dir)) ;
      return path( $self->pipeline_dir, 'symlink'  ); 
  }
  
  
  sub _build_software_dir {
      my $self = shift;
      my $software_dir = $self->config->{_}->{software_dir}; 
      return path($software_dir) if(defined( $software_dir)) ;
      return path( $self->pipeline_dir, 'software'  ); 
  }
  
  sub _build_datasource_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.datasource');
  }
  
  sub _build_datasource_resolved_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.resolved.datasource');
  }
  
  sub _build_test_data_file {
      my $self = shift;
      return path( $self->pipeline_dir, 'test_data', 'test.txt'  ); 
  }
  
  sub run_dir  {
      my $self = shift;
      ## Num $run_num
      my $run_num = shift;
      return path( $self->output_dir, $self->output_run_name . $run_num );
  }
  
  sub run_settings_dir   {
     my $self = shift;
     #Num $run_num
     my $run_num = shift;   
     my $settings_dir = path($self->run_dir($run_num), $self->run_settings_name );
     if( $settings_dir->exists){
        my $num_runs = scalar $settings_dir->children; 
        return path($settings_dir, $num_runs);
     }else{
        return path($settings_dir, 1);
     }
  }
  
  sub last_run_num {
      my $self=shift;
      #read in files in data directory
      #order by run number
      # - if none then run number is 1.
      my $run_num = max map { if( $_ =~ /run([0-9]+)/){$1}else{} } $self->output_dir->children;
      $run_num = 0 unless (defined $run_num);    
      return $run_num;   
  }
  
  sub new_run_settings_dir { 
     my $self = shift;
     #(Num $run_num){
     # this should generate a new settings 
     #dir taking into account reruns
     my $run_num = shift;   
     my $settings_dir = path($self->run_dir($run_num), $self->run_settings_name );
     
     if( $settings_dir->exists){
        my $num_runs = scalar $settings_dir->children + 1; 
        return path($settings_dir, $num_runs);
     }else{
        return path($settings_dir, 1);
     }  
  }
  
  sub datasource_from_run {
      my $self = shift;
      my $run_num = shift;
      my $settings_path = $self->run_settings_dir($run_num);   
      my $datasource_path = path($settings_path, $self->datasource_file->basename );
      return $datasource_path;
  }
  
  
  
  
  1;
APP_PIPELINE_LITE4_BASE

$fatpacked{"App/Pipeline/Lite4/Command/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_FILE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::file;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  use Number::Bytes::Human qw(format_bytes);
  use Time::Piece;
  use Data::Table;
  sub execute {
      my ($self, $opt, $args) = @_;
   
      
      eval {
         
         # set show steps if stats
         $opt->{step_name} = 1 if $opt->{stats};
          
         # Default is to get the latest run and the latest datasource
     
        my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
        my $run_num = $resolver->_last_run_number;           
         if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
         }
        
        #get datasource from settings directory and set to datasource file
        $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
        my $datasource = $resolver->pipeline_datasource;
        #print $datasource->tsv;
         
        # Go through each job  
            # create a hash based on steps 
            #  $steps{step}{filename}{jobnum}
            #  then  at the end  
        my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
   
        my $iter = $output_run_dir->iterator( { recurse => 1 } );
        my %step_hash;
        my %jobs;
        while( my $path = $iter->() ){        
          next unless $path->is_file;
          next if(  $path->basename =~ m{/?(out|err)$} ); 
          next unless $path =~ /job/; #removes setting directory and other things that are not jobs
          
          #print $path . "\n";
          my ($job, $step,$name)  = $path->stringify =~ m{(job[0-9]+)/(.+)/(.+)$};
          #my ($step) = $path->stringify =~ m{job[0-9]+/(.+)/} ;
          #print join " ", $job, $step, $name .  "\n";
          if( $opt->{stats} ){
             my $time = localtime($path->stat->mtime)->datetime;
             $step_hash{$step}{$name}{$job} = format_bytes( $path->stat->size) . "," . "[$time]";
          }else{
            $step_hash{$step}{$name}{$job} = $path;
          } 
          $jobs{$job} =1;
        }  
       
        #print header
        
        my @row;
        my $header;
        foreach my $step (nsort keys %step_hash){
          my $names = $step_hash{$step};
          foreach my $name (nsort keys %$names){
             if( $opt->{step_name} ){
               push @row,  $step."-".$name;
             }else{
               push @row,  $name;
             }
          }
        }
        
        #print join "\t", @row; print "\n";
        $header = [@row];
        
        my @table_data;
        foreach my $job (nsort keys %jobs){  
            @row = ();
            # go through each step and if the name doesn't have this job then put in some null character          
            foreach my $step (nsort keys %step_hash){
                my $names = $step_hash{$step};
                foreach my $name (nsort keys %$names){
                    if( exists $names->{$name}->{$job} ){                  
                     push @row,  $names->{$name}->{$job} 
                  }else{
                    push @row,"-";
                  }
                                   
                }
            }
            #print join "\t", @row; print "\n";
            push @table_data, [@row];
         }
         
        my $t = Data::Table->new(\@table_data, $header, 0);
        $datasource->colMerge($t, {renameCol => 1 } );
        print $datasource->tsv;
         
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( kiss 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER' ){
         print "\n*** There is something to fix before this pipeline can dispatch ***\n";
         print "\n", bleep(), "\n\n"; 
         print "This might be fixed by:\n
               - giving the placeholder a value (e.g. treating as an argument) via --args
               - fixing an error in the placeholder name
               - creating values for this placeholder in the datasource
          \n";
      }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  
  1;
APP_PIPELINE_LITE4_COMMAND_FILE

$fatpacked{"App/Pipeline/Lite4/Command/new.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_NEW';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::new;
  use Moo;
  use MooX::late;
  use Ouch;
  use App::Pipeline::Lite4::SetupPipeline;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      # get pipeline directory
      # get pipelite object    
      eval {        
          my $App_Pipeline_Lite_Setup = App::Pipeline::Lite4::SetupPipeline->new( pipeline_dir => $args->[0]); 
          $App_Pipeline_Lite_Setup->output_dir( dir( $opt->{output_dir} ) ) if defined($opt->{output_dir});      
          if( defined $opt->{based_on}){
               $App_Pipeline_Lite_Setup->create_pipeline_directory( based_on => $opt->{based_on} ); # this needs to be written in setup            
          }else{
               $App_Pipeline_Lite_Setup->create_pipeline_directory();
          }        
      };
      
      if( kiss 'App_Pipeline_Lite2_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_NEW

$fatpacked{"App/Pipeline/Lite4/Command/run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_RUN';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::run;
  use Moo;
  use Ouch;
  use Path::Tiny;
  use App::Pipeline::Lite4;
  sub execute {
      my ($self, $opt, $args) = @_;
   
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
           
          $App_Pipeline_Lite->smoke_test(1) if defined($opt->{smoke_test});    
          
          if( defined $opt->{steps} ) {
            $App_Pipeline_Lite->step_filter_str($opt->{steps});     
          }
          
          if(defined $opt->{jobs}){
             $App_Pipeline_Lite->job_filter_str( $opt->{jobs} );
          }
          
          if(defined $opt->{run}){
                 
           $App_Pipeline_Lite->run_num($opt->{run});
           my $datasource_path = $App_Pipeline_Lite->datasource_from_run($opt->{run});
           $App_Pipeline_Lite->datasource_file($datasource_path);
           
           # $App_Pipeline_Lite->datasource_file
           # or do we set the $App_Pipeline_Lite->datasource_resolve_file
           # do we need a switch to say this is the resolved file 
           # and don't do any further datasource resolving?
          }
          
          if( defined $opt->{datasource} ) {
             # pre check that file exists
             my $datasource_path = $opt->{datasource}; 
             ouch 'App_Pipeline_Lite4_Error', "The datasource path ($datasource_path) is not a file" unless path( $datasource_path)->is_file ;         
             $App_Pipeline_Lite->datasource_file( $datasource_path )  ;       
          }  
         
          my $desc ="smoke-test";  
         $desc = $App_Pipeline_Lite->util->ask_for_description
                        unless defined $opt->{smoke_test};
        my $step_filter = $opt->{steps} // "*";
        my $job_filter  = $opt->{jobs} // "*"; 
        my $run_num =  $App_Pipeline_Lite->last_run_num + 1; 
        $run_num = $opt->{run} if defined($opt->{run});    
        my $run_info = join " ", "run" . "[ $run_num ]", "[ step-filter: " . $step_filter  . " ]", "[ job-filter: " . $job_filter . " ]";
                  
        $App_Pipeline_Lite->util->append_description( $run_info, $desc );   
          
        $App_Pipeline_Lite->run_pipeline;
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( kiss 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER' ){
         print "\n*** There is something to fix before this pipeline can dispatch ***\n";
         print "\n", bleep(), "\n\n"; 
         print "This might be fixed by:\n
               - giving the placeholder a value (e.g. treating as an argument) via --args
               - fixing an error in the placeholder name
               - creating values for this placeholder in the datasource
          \n";
     }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_RUN

$fatpacked{"App/Pipeline/Lite4/Command/symdir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMDIR';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symdir;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
   sub execute {
      my ($self, $opt, $args) = @_;
      
       # get pipeline directory
       # get pipelite object 
      
       eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
     
          my ($step,$filename) = split '#', $opt->{step_and_fname} ;
          
          # get the datasource  
          my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
          my $run_num = $resolver->_last_run_number;           
          if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
           }
        
          #get datasource from settings directory and set to datasource file
          $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
          my $datasource = $resolver->pipeline_datasource;
          
          
          
          my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
          my @jobs =  grep { /job/ } $output_run_dir->children
          print "@jobs\n"; 
          #my $iter = $output_run_dir->iterator( { recurse => 1 } );
          #my %step_hash;
          #my %jobs;
          #while( my $path = $iter->() ){        
          #  next unless $path->is_file;
          #  next if(  $path->basename =~ m{/?(out|err)$} ); 
          #  next unless $path =~ /job/; #removes setting directory and other things that are not jobs
          #}
          
          
          # parse the step name and filename
          # check that the field exists
          # go through each job directory and make the link
          # if a file doesn't exist warn. 
          # make a datasource for the symlink files
              
       };
      
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_SYMDIR

$fatpacked{"App/Pipeline/Lite4/Command/symlink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMLINK';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symlink;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
       eval {
          my $id_field = $opt->{id_field};
          my $pipeline_dir =       path($args->[0]);
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Requires step_and_filename argument"
             unless ( defined( $opt->{step_and_fname} ) );
          my ($step,$filename) = split '#', $opt->{step_and_fname} ;
          
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Something went wrong specifying the step and filename" 
             unless ( defined($step) and defined($filename));
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Something went wrong specifying the step and filename" 
             if( $step eq '' or $filename eq '');
          
          # get the datasource  
          my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
          my $run_num = $resolver->_last_run_number;           
          if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
          }
        
          #get datasource from settings directory and set to datasource file
          $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
          my $datasource = $resolver->pipeline_datasource;
           
          my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
          my @jobs = nsort grep { /job/ } $output_run_dir->children;
  
          my @job_ids = map {$_->basename} @jobs;
          if( ! defined( $id_field) ){
             warn "No ID field defined. Prepending job numbers " 
          }elsif( $datasource->hasCol($id_field) ){
             @job_ids = $datasource->col($id_field);
          }else{
             warn "No matching ID field in datasource. Prepending job numbers"
          }
          
          #default path
          my $symlink_dir = path($resolver->symlink_dir, $step, $run_num);
          $symlink_dir = $opt->{path} if defined($opt->{path});
          $symlink_dir->mkpath;
          my @table_data;
          foreach my $job (@jobs){
            my $path = path($job,$step,$filename);
            my $id = shift @job_ids;
            if( $path->exists){
               my $new_basename = "$id-".$path->basename;
               if( defined( $opt->{name} )){
                  my $name = $opt->{name};
                  $new_basename = "$id$name" ;                                
               }             
               my $new_path = path($symlink_dir,$new_basename);
               symlink $path, $new_path->absolute;  
               print "symlinked $path to $new_path\n";
               push @table_data, [$new_path];
            }else{
               warn "path $path does not exist";
               push @table_data, ["-"];
            }
          }
          
          my $t = Data::Table->new(\@table_data, [$filename], 0);
          $datasource->colMerge($t);
          my $datasource_tsv = $datasource->tsv;
          my $datasource_path = path($symlink_dir,$pipeline_dir->basename . ".datasource");
          $datasource_path->spew($datasource_tsv);
          # parse the step name and filename
          # check that the field exists
          # go through each job directory and make the link
          # if a file doesn't exist warn. 
          # make a datasource for the symlink files            
       };
      
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( kiss  'App_Pipeline_Lite_CMD_ERROR') {
         print bleep(), "\n";       
       }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_SYMLINK

$fatpacked{"App/Pipeline/Lite4/Command/viewconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWCONFIG';
  # use strict;
  # use warnings;
  # package App::Pipeline::Lite4::Command::viewconfig;
  # use Moo;
  # use Ouch;
  # use App::Pipeline::Lite4;
  
  # # sub execute {
      # my ($self, $opt, $args) = @_;
      
  # #     # get pipeline directory
      # # get pipelite object 
      
  # #     eval {
          # my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
  # #         if(defined $opt->{editor}){
                  # $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          # }                             
          # $App_Pipeline_Lite->util->view_file_with_editor( 
                                # $App_Pipeline_Lite->pipeline_file->absolute->stringify);
          
  # #     };
      
  # #     if( kiss 'App_Pipeline_Lite4_Error') {
         # print bleep(), "\n"; 
      # } elsif ( hug ) {
         # print 'An error occurred, check logs: ', $@ ;
      # }
  # }
  #1;
APP_PIPELINE_LITE4_COMMAND_VIEWCONFIG

$fatpacked{"App/Pipeline/Lite4/Command/viewgraph.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWGRAPH';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewgraph;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      
      # get pipeline directory
      # get pipelite object 
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          if(defined $opt->{editor}){
                  $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          }                             
          $App_Pipeline_Lite->util->view_file_with_editor( 
                                $App_Pipeline_Lite->pipeline_graph_file->absolute->stringify);
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWGRAPH

$fatpacked{"App/Pipeline/Lite4/Command/viewpipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWPIPELINE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewpipeline;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      
      # get pipeline directory
      # get pipelite object 
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          if(defined $opt->{editor}){
                  $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          }                             
          $App_Pipeline_Lite->util->view_file_with_editor( 
                                $App_Pipeline_Lite->pipeline_file->absolute->stringify);
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWPIPELINE

$fatpacked{"App/Pipeline/Lite4/Command/viewsystemconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWSYSTEMCONFIG';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewsystemconfig;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
        
      
      eval {       
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new;
          my $App_Pipeline_Lite_Util = App::Pipeline::Lite4::Util->new; 
          if(defined $opt->{editor}){               
                  $App_Pipeline_Lite_Util->set_editor( $opt->{editor});
          }                             
          $App_Pipeline_Lite_Util->view_file_with_editor( $App_Pipeline_Lite->system_config_file );
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWSYSTEMCONFIG

$fatpacked{"App/Pipeline/Lite4/Grapher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_GRAPHER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Grapher;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  #use List::AllUtils qw(min any); can't use as get kick ups about requiring versions > 1.32
  use List::Util qw(min reduce);
  use Array::Compare;
  use Data::Dumper;
  use App::Pipeline::Lite4::Util;
  extends 'App::Pipeline::Lite4::Base';
  has pipeline_step_struct_with_dependents => ( isa => 'HashRef', is => 'rw' );
  
  sub add_dependents {
     my $self=shift;
     # Path::Tiny :$yaml_infile,
     my $yaml_infile = shift;  
     # Path::Tiny :$yaml_outfile
     my $yaml_outfile = shift;
     $self->pipeline_resolved_file($yaml_infile);
     $self->_add_dependents;
     $yaml_outfile->spew( Dump( $self->pipeline_step_struct_with_dependents ) );
  }
  
  #method _add_dependents {    
  sub _add_dependents {
      my $self = shift;
      my $resolved_file_yaml = $self->pipeline_resolved_file->slurp;
      my $resolved_pipeline = Load($resolved_file_yaml); 
      
      my $lowest_job_num = min keys $resolved_pipeline;
      my $num_of_jobs    = scalar keys $resolved_pipeline;
      
     # my $valid_steps = $self->valid_steps( $resolved_pipeline);
      my $valid_steps = $self->valid_steps_hash( $resolved_pipeline);
      
      foreach my $job_num (keys %$resolved_pipeline){
          my $job = $resolved_pipeline->{$job_num};
          foreach my $step (keys %$job) {
             $job->{$step}->{dependents} = [];
             if( defined($job->{$step}->{placeholders})) {
                $self->_add_dependents_for_step_via_placeholder( 
                          $job->{$step}, #step
                          $step, #step_name 
                          $job_num,
                          $lowest_job_num,  
                          $num_of_jobs, 
                          $valid_steps 
                          );
             }
             
             if( defined( $job->{$step}->{after}) ) {
                 $self->_add_dependents_for_step_via_after_condition( 
                          $job->{$step}, #step
                          $step,   #sep_name
                          $job_num, 
                          $lowest_job_num, 
                          $num_of_jobs, 
                          $valid_steps );  
             }           
          }
      }
      $self->pipeline_step_struct_with_dependents($resolved_pipeline);
  }
  
  sub _add_dependents_for_step_via_placeholder {
  # TYPE (  HashRef :$step, Str :$step_name, Num :$job_num, Num :$lowest_job_num, 
  # TYPE Num :$num_of_jobs, ArrayRef :$valid_steps ) {
       my ($self,$step,$step_name,$job_num, $lowest_job_num, 
           $num_of_jobs,$valid_steps_hash  ) = @_;
       
       $self->logger->debug( "Valid Steps: " . Dumper $valid_steps_hash );
       my $rgx1 = qr{^([\w\-]+)\.{0,1}};
       my $rgx2 = qr{^jobs\.([\w\-]+)\.{0,1}};      
       my $rgx3 = qr{groupbyebyebye}; # should not match anything
       if( defined( $step->{condition} ) ){         
         if(  $step->{condition} eq 'groupby'){
           my $params = $step->{condition_params};     
           my $params_str = join '\.', @$params;
           my $rgx3_str = '^groupby\.' . $params_str . '\.' . '([\w\-]+)\.{0,1}';
           $rgx3 = qr{$rgx3_str};
         }
       } 
       #warn "REGEX3 $rgx3";     
       my $placeholders = $step->{placeholders};
       my $dependents   = $step->{dependents};
       
       my @valid_steps = keys %$valid_steps_hash;
       foreach my $placeholder (@$placeholders){                                    
           my ($placeholder_step_name) = $placeholder =~ $rgx2;#/^(\w+)\.{0,1}/; # =~ /step([0-9]+)/;
           ($placeholder_step_name) = $placeholder =~ $rgx3 unless defined($placeholder_step_name);
           ($placeholder_step_name) = $placeholder =~ $rgx1 unless defined($placeholder_step_name);
            
           # warn "GOT STEP NAME: $placeholder_step_name from $placeholder";
           $self->logger->debug("step $step_name: placeholder step name - $placeholder_step_name (from $placeholder)");  
           next unless defined($placeholder_step_name);
           
           ### I want 'any' unfortunately any isn't in recent version of List::Util and List::MoreUtils is XS and not core
           my $code = sub { my $k = shift; return 1 if( $placeholder_step_name eq $k ); return 0;   };
           my $next = reduce { $a || $code->(local $_ = $b)  } 0,  @valid_steps;
           next unless $next;
           
           # DO THIS WHEN List::Util qw(any) works for most Perls  
           #next unless any { $placeholder_step_name eq $_ } @$valid_steps; # if we have filtered steps this is important, and also takes care of the 0 datasource step
           ########################################################
           
                  
               my ($existing_dependents, $this_step_name) = (0,0);
               
               ## Actually want List::Util qw(any)
               my $codeA = sub { my $k = shift; return 1 if( "$job_num.$placeholder_step_name"  eq $k ); return 0;   };
               $existing_dependents = reduce { $a || $codeA->(local $_ = $b)  } 0,  @$dependents;
               
               # DO THIS WHEN List::Util qw(any) works for most Perls  
               #$existing_dependents =  any { $_ eq "$job_num.$placeholder_step_name"  }  @$dependents;
               ##############################################################################
               $this_step_name = 1 if( $placeholder_step_name eq $step_name);                                   
               if ( defined $step->{condition} ) {
                   # only defined condition is 'once' so far
                   # the 'any' code above will skip adding the same dependent jobs if a placeholder with the same step name occurs multiple times. 
                   # it works because it sets $existing_dependents true if any of the job numbers is present                
                   #---
                   if( $step->{condition} eq 'once'){ 
                       # now a once condition referencing another step with a once condition only needs to put down the minimal job number
                       # remember we are looking at the placeholder and trying to determine dependencies,
                       # the valid steps hash, tells us what condition the step of that placeholder is, so we can 
                       # adjust for once or groupby steps
                       if( defined $valid_steps_hash->{$placeholder_step_name}->{condition} ){             
                           if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'once' ){
                             push(@$dependents, "$lowest_job_num.$placeholder_step_name") unless ( $this_step_name or $existing_dependents) ; 
                           }
                       }else {
                           for my $i ( $lowest_job_num .. ( $num_of_jobs -1 )){
                              push(@$dependents, "$i.$placeholder_step_name") unless ( $this_step_name or $existing_dependents) ;                                               
                           }
                    
                       }
                     }
                     if ( $step->{condition} eq 'groupby'  ){
                         
                         #we take the job number and get the group we need
                         my $util = App::Pipeline::Lite4::Util->new;
                         my $params = $step->{condition_params};
                         #warn "PARAMS: ", Dumper $params;
                         my $groupby_hash = $util->datasource_groupby2( $self->pipeline_datasource, @$params );
                         my @groupby_ids = sort keys %$groupby_hash;
                         #warn "GRAPHER JOBNUM: $job_num";
                         #warn "GRAPHER GROUPID: @groupby_ids";
                         #warn "gRAPHER CMD", $step->{cmd};
                         #warn "STEP",  Dumper $step;
                         my $group_id = $groupby_ids[$job_num]; 
                         #warn "GRAPHER GROUPID: $group_id";
                         my $job_ids = $groupby_hash->{$group_id};
                         
                         
                         # if we are referring to a step that is a groupby step, then we only need to 
                         # put int dependencies that refer to the jobs generated by that step - i.e. only up to job 4 rather
                         # than job 10 for example, as it won't exist 
                         
                         if( defined $valid_steps_hash->{$placeholder_step_name}->{condition} ){             
                           if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'groupby' ){
                               # different conditions will have different numbers, 
                               # we can only refer to a groupby with the same condition  
                               # and then we only put in the job number, 
                               my $placeholder_step_params = $valid_steps_hash->{$placeholder_step_name}->{condition_params};
                               my $comp = Array::Compare->new; 
                               if( ! $comp->compare( $placeholder_step_params, $params  ) ){
                                  ouch 'App_Pipeline4_Error', "One groupby statement depends on another groupby statement with a different groupby field(s)";
                               }else{
                                  
                                  push(@$dependents, "$job_num.$placeholder_step_name") 
                                     unless ( $this_step_name or $existing_dependents or ($job_num >= scalar(@groupby_ids)) ); 
                               } 
                           }
                           #do something for once here
                          }else{
                         
                             foreach my $job_id (@$job_ids){  
                                push( @$dependents, "$job_id.$placeholder_step_name" ) unless ( $this_step_name or $existing_dependents) ;
                             }
                         }
                     } 
                   
               }else{                 
                   #$existing_dependents =  any { $_ eq "$job_num.$placeholder_step_name"  }  @$dependents;
                   #$this_step_name = 1 if( $placeholder_step_name eq $step_name);                 
                   push( @$dependents, "$job_num.$placeholder_step_name")
                     unless ($this_step_name or $existing_dependents) ;
               }       
           #}         
       }
  }
  =cut To implement
  sub _add_dependents_for_step_via_after_condition {
      #TYPE: HashRef :$step, Str :$step_name, Num :$job_num, 
      #TYPE: Num :$lowest_job_num, Num :$num_of_jobs, ArrayRef :$valid_steps )
        my ($self,$step,$step_name,$job_num, $lowest_job_num, 
           $num_of_jobs,$valid_steps_hash  ) = @_;
        foreach my $after_step_name ($step->{after}->flatten){
          # if($after_step_num > $step) {
             # ouch 'steperror', "Need to ensure that a step does not define steps to run after that are future steps"; 
          # } 
          
         # if ( $after_step_num < $step_num ) { 
              my $dependents = $step->{dependents};  
               $self->logger->debug("step $step_name: placeholder step num - $after_step_name");                         
               if ( defined $step->{condition} ) { # only 'once' is the only thing that can occur from the condition key                
                   for my $i ( $lowest_job_num .. ( $num_of_jobs -1 )){
                       push( @$dependents, "$i.$after_step_name");                                               
                   }
               }else{
                   ouch 'App_Pipeline4_Error', "The after condition of step $step_name refers to its own step"
                     if( $after_step_name eq $step_name );
                  
                   push(@$dependents, "$job_num.$after_step_name")
                     unless any { $_ eq "$job_num.$after_step_name"  }  @$dependents ;
               }       
         #  }                    
                     
      }
  }
  =cut
  
  ####DEPRECATED## REMOVE
  sub valid_steps {
    #TYPE: ( HashRef :$resolved_pipeline ) {
    my $self = shift;    
    my $resolved_pipeline = shift;  
    # run through the first job.  
    my ($a_job);
    my @jobs = keys %$resolved_pipeline;
    my ($min_job_num) = sort {$a <=> $b} @jobs;
    $a_job =  $resolved_pipeline->{$min_job_num}; 
    my @step_names =  keys %$a_job;
    warn "@step_names";
    return \@step_names;    
  } 
  ############
  
  
  sub valid_steps_hash {
    #TYPE: ( HashRef :$resolved_pipeline ) {
    my $self = shift;    
    my $resolved_pipeline = shift;  
    # run through the first job.  
    my ($a_job);
    my @jobs = keys %$resolved_pipeline;
    my ($min_job_num) = sort {$a <=> $b} @jobs;
    $a_job =  $resolved_pipeline->{$min_job_num}; 
    my @step_names =  keys %$a_job;
    my %valid_step_hash;
    foreach my $step (keys %$a_job){
       $valid_step_hash{$step}->{condition} = $a_job->{$step}->{condition};
       $valid_step_hash{$step}->{condition_params} = $a_job->{$step}->{condition_params};   
    }
    
    return \%valid_step_hash;
  } 
  
  1;
APP_PIPELINE_LITE4_GRAPHER

$fatpacked{"App/Pipeline/Lite4/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_LOGGER';
  package App::Pipeline::Lite4::Logger;
  use Moo;
  use MooX::late;
  use Path::Tiny;
  use Time::Piece;
  use Devel::StackTrace;
  has logfile => ( isa => 'Path::Tiny|Undef', is => 'rw' );
  has system_logfile => ( isa => 'Path::Tiny|Undef', is => 'rw' );
  sub log {
      my $self  = shift;
      my $level = shift;
      my $msg   = shift; 
      
      my $t = localtime;  
      my $trace = Devel::StackTrace->new();
      
      my $frame = $trace->frame(1);
      my $package = $frame->package;
      my $app_caller = "unknown";
      
      while ( my $frame = $trace->prev_frame() ) {
         if ( $frame->package =~ /Command\:\:(.+)/ ) {
            $app_caller = $1;
            last;
         }
      }
      
      my $log_msg = "[" . $level . "] " . "[ $app_caller -> $package ] " . " [ " . $t->strftime . " ] " . $msg;         
      my $append_log = $self->logfile->opena; #( $level =~ /sys/ ) ? $self->system_logfile->opena : $self->logfile->opena;
      print $append_log $log_msg, "\n";
  }
  
  sub debug {
     my $self = shift;
     my $msg  = shift;
     $self->log("debug",$msg) ;
  }
  
  sub info {
     my $self = shift;
     my $msg  = shift;
     $self->log("info",$msg) ;
  }
  
  
  1;
APP_PIPELINE_LITE4_LOGGER

$fatpacked{"App/Pipeline/Lite4/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_PACKER';
  package App::Pipeline::Lite4::Packer;
  use Moo;
  use App::FatPacker;
  use Path::Tiny;
  # thieve from Carton fatpacking (MIYAGAWA)
  
  sub fatpack_plite {
      my $self = shift;
      my $dir = path(shift);
      my $file = $dir->child('plite');
      
      my $fatpacked = $self->do_fatpack($file);     
      my $executable = path($dir,'packed')->child('plite');
      warn "... Bundling $executable\n";   
      $executable->spew($fatpacked);
      chmod 0755, $executable;
  }
  
  sub do_fatpack {
      my ($self, $file) = @_;
      my $packer = App::FatPacker->new;
   
      my @modules = split /\r?\n/, $packer->trace(args => [$file]); #, use => $self->required_modules);
      @modules = grep { !/main.pm/ } @modules;
      @modules = grep { !/XS.pm/ } @modules;
      print join "\n", @modules, "\n"; 
      my @packlists = $packer->packlists_containing(\@modules);
      $packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute, \@packlists);
   
      my $fatpacked = do {
          local $SIG{__WARN__} = sub {};
          $packer->fatpack_file($file);
      };
   
      # HACK: File::Spec bundled into arch in < 5.16, but is loadable as pure-perl
      #use Config;
      #$fatpacked =~ s/\$fatpacked{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;
      $fatpacked;
  }
  1;
APP_PIPELINE_LITE4_PACKER

$fatpacked{"App/Pipeline/Lite4/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_PARSER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Parser ;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  use SHARYANTO::String::Util qw(trim rtrim);
  
  extends 'App::Pipeline::Lite4::Base';
  
  has append_err_str => ( isa => 'Bool' , is => 'rw', default => sub { 1;} );
  has prepend_cwd_str => ( isa => 'Bool' , is => 'rw', default => sub { 1;} );
  
  #has append => (isa => 'Str', is =>'rw', default=> sub {''} );
  #has prepend =>  (isa => 'Str', is =>'rw', default=> sub {''} );
  
  has append => (isa => 'Str|Undef', is =>'rw', lazy_build => 1 );
  has prepend =>  (isa => 'Str|Undef', is =>'rw', lazy_build =>1  );
  
  sub get_step_name { 
      #TYPE( :$str) 
     my $str = shift;
     my ($name) = $str =~ /^([\w\-]+)\./;
     return $name;
  }
  
  sub get_step_condition {
      my $str = shift;
     #TYPE: :$str 
    
     my ($condition) = $str =~ /^[\w\-]+\.([\w\-]+)\.*/;
     return $condition;
  }
  
  sub _build_append {
      my $self = shift;
      my $append_str = $self->config->{_}->{append}; #check local config 
      
      # if does not exist, check system config    
      $append_str = $self->system_config->{_}->{append} 
                                 unless defined( $append_str);
      $append_str = " " . $append_str . " "; #make sure there is a space between commands
      defined($append_str) ?  $append_str : undef;  
  }
  
   sub _build_prepend {
      my $self = shift;
      my $prepend_str = $self->config->{_}->{prepend}; #check local config 
      
      # if does not exist, check system config    
      $prepend_str = $self->system_config->{_}->{prepend} 
                                 unless defined( $prepend_str);
      $prepend_str = " " . $prepend_str . " " if defined($prepend_str); #make sure there is a space between commands
      defined($prepend_str) ?  $prepend_str : undef;  
  }
  
  
  sub preparse {
      my $self = shift;       
      my $pipeline_file = shift // $self->pipeline_file; # TYPE: Path::Class::File :$pipeline_file = $self->pipeline_file,   
      my $yaml_outfile = shift // $self->pipeline_preparse_file;     # TYPE: Path::Class::File :$yaml_outfile = $self->pipeline_preparse_file 
      # parse the current steps in the pipeline 
      my $step_hash = parse_pipeline_to_step_hash( $pipeline_file );       
      # append other stuff here first, and then err string
      # <---     
      $self->append_err_str_to_cmd( $step_hash  )
        if  ( $self->append_err_str );      
       # prepend other stuff here first, and then cwd string
       # <---   
      $self->prepend_str_to_cmd($step_hash, $self->prepend ) 
        if  ( defined $self->prepend);  
      $self->prepend_cwd_str_to_cmd($step_hash ) 
        if  ( $self->prepend_cwd_str);        
      $yaml_outfile->spew( Dump($step_hash) );
  };
  
  sub parse {
      # TYPE: Path::Class::File :$yaml_infile, 
      # TYPE: Path::Class::File :$yaml_outfile  
    my $self= shift;
    my $yaml_infile  =shift;
    my $yaml_outfile =shift;  
    my $step_hash_yaml = $yaml_infile->slurp;
    my $step_hash    = Load($step_hash_yaml); 
    my $step_struct  = pipeline_step_hash_to_step_struct( $step_hash );
    $yaml_outfile->spew( Dump($step_struct) );  
  };
  
  sub append_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $str = shift;
    my $append_str_func   = sub { my $step_name = shift // 'default'; return $str};
    # concat_to_cmd knows to provide step name to the coderef
    my $appended_step_hash = $self->concat_to_cmd($step_hash, $append_str_func, 'APPEND');
  }
  
  # yes this is a specific case of above - look to refactor
  sub append_err_str_to_cmd {  
      my $self = shift;
      #TYPE: HashRef $step_hash 
      my $step_hash = shift;  
      my $append_str_func   =  sub { my $step_name = shift // 'default'; return " 2>[% $step_name.err %]" };
      # concat_to_cmd knows to provide step name to this coderef
      my $appended_step_hash = $self->concat_to_cmd($step_hash, $append_str_func, 'APPEND');  
  }
  
  sub prepend_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $str = shift;
    my $prepend_str_func   = sub { my $step_name = shift // 'default'; return $str};
    # concat_to_cmd knows to provide step name to the coderef
    my $prepended_step_hash = $self->concat_to_cmd($step_hash, $prepend_str_func, 'PREPEND');
  }
  
  # yes this is a specific case of above - look to refactor
  sub prepend_cwd_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $prepend_str_func   = sub { my $step_name = shift // 'default'; return "cd [% $step_name %]; "};
    # concat_to_cmd knows to provide step name to the coderef
    my $prepended_step_hash = $self->concat_to_cmd($step_hash, $prepend_str_func, 'PREPEND');
  }
  
  # requires a coderef that returns a string, which can be used to 
  # parameterise a step name
  sub concat_to_cmd {
      my $self = shift;
      #TYPE: HashRef $step_hash 
      my $step_hash = shift;
      my $concat_string_code = shift;
      my $type_of_concat = shift; #APPEND or PREPEND
      foreach my $step ( keys %$step_hash) {
         my $step_name =  get_step_name( $step);
         $step_name = trim( $step_name ) ;
         $step_hash->{$step} = rtrim( $step_hash->{$step} );           
         my $concat_str = $concat_string_code->($step_name);
         my $step_cond = get_step_condition( $step);
         if( defined($step_cond) ){
             if($step_cond eq 'once'){              
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step}  = $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;                             
             }
             
              if($step_cond eq 'groupby'){              
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step}  = $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;                             
             }
             
         } else {
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step} =  $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;
         }
     } 
     return $step_hash;
  }
  
  =func parse_pipeline_file_to_step_hash
    A step hash has a key such as "1." and value "some_cmd -h MOREOPTIONS ARGS ..."
  =cut
  sub parse_pipeline_to_step_hash   {
      # TYPE:  Path::Tiny $file
      my $file = shift;
      # Each Step Starts with X. or X.output and then a space, where X is the step number
      # Can be multiline but cannot start with X. on a line
      my @pipeline_file_contents = $file->lines;
      my %stephash;
      my $stepname;
      foreach my $line (@pipeline_file_contents) {  
         
         if ( $line =~ /^#/){ next; }  
         my $C = qr{^[\w\-]+\.};
         my $D = qr{^[\w\-]+\.output};
         my $E = qr{^[\w\-]+\.once};
         my $F = qr{^[\w\-]+\.mem};       
         my $G = qr{^[\w\-]+\.after};
         my $H = qr{^[\w\-]+\.queue};
         my $I = qr{^[\w\-]+\.cores};
         my $J = qr{^[\w\-]+\.groupby\.[\w\-]+};
         my $K = qr{^[\w\-]+\.groupby\.[\w\-]+\.[\w\-]+};
         #my $L = qr{^[\w\-]+\.grouptransby\.[\w\-]};
         #my $M = qr{^[\w\-]+\.grouptransby\.[\w\-]\.[\w\-]};
  
         # #my $G = qr{^[0-9]+\.skip_if_exists}
         # #my $E = qr{^[0-9]+\.no_err};
         
         my $N = qr{\s(.+)};
         my $rg = qr{        
             ($C|$D|$E|$F|$G|$H|$I|$J|$K)$N      
         }x;
         
          if( $line =~ $rg) {          
              $stepname = $1;            
              my $steptext = $2;
              $stephash{$stepname} = $steptext;
          }else{
              $stephash{$stepname} .= $line; 
          }    
      }
      return {%stephash};  
  }
  
  #takes step hash and parses it to more processed structure
  sub pipeline_step_hash_to_step_struct {
      #   TYPE: Path::Tiny :$yamlfile ) {
      my $step_hash = shift;
      my %step_struct;
      foreach my $step ( keys %$step_hash ){  
              
             my $step_name = get_step_name( $step);
             my $step_condition = get_step_condition( $step);
             
             if( !defined($step_condition) ) {
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = undef; # change to 'none'?
             } 
                        
             elsif( $step_condition eq 'output' ) {
                 my @files = $step_hash->{$step} =~ /(\[\%.+?\%\]\S+|\S+)/g; #my @files = split(/\s/, $step_hash->{$step}); 
                 $step_struct{$step_name}->{outputfiles} = \@files; #$step_hash->{$step};
             }
                        
             elsif( $step_condition eq 'once' ) {
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = 'once';
             }
             
             elsif ( $step_condition eq 'mem' ) { 
               $step_struct{$step_name}->{mem} = trim( $step_hash->{$step} );
             }
                    
             elsif ( $step_condition eq 'after' ) { 
               my @after = split(/\s/, $step_hash->{$step}); 
               $step_struct{$step_name}->{after} = \@after ;
             }
             
             elsif ( $step_condition eq 'queue' ) { 
               $step_struct{$step_name}->{queue} =trim( $step_hash->{$step} );
             }
             
             elsif ( $step_condition eq 'cores' ) { 
               $step_struct{$step_name}->{cores} =trim( $step_hash->{$step} );
             }
             elsif( $step_condition eq 'groupby' ) {         
               my @condition_params = split( /\./,$step);            
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = $step_condition;
               my @params = @condition_params[2 .. $#condition_params];
               $step_struct{$step_name}->{condition_params} = \@params;
             }
             
             # get placeholders
             if( ! exists( $step_struct{$step_name}->{placeholders} ) ){$step_struct{$step_name}->{placeholders} = undef;}#initialise to undef
             if( ( ! defined $step_condition) or ($step_condition eq 'once') or ($step_condition eq 'output') or ($step_condition eq 'groupby') ){
               #my (@placeholders) = ( $step_hash->{$step} =~ /\[\%\s+([a-z0-9\.]+)\s\%\]/g );
               my (@placeholders) = ( $step_hash->{$step} =~ /\[\%\s+([\w\-\.]+)\s+\%\]/g ); #\w is alphanumeric plus _, added more spaces at end. Consider /\[\%\s+([a-z0-9_][\w\.]+)\s+\%\]/g enforcing lower case start.
               if ( @placeholders >= 1){ 
                  $step_struct{$step_name}->{placeholders} = \@placeholders;
               }; 
             }   
  
      }
      return \%step_struct;
  }
  
  1;
APP_PIPELINE_LITE4_PARSER

$fatpacked{"App/Pipeline/Lite4/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_RESOLVER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Resolver ;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  use YAML::Any;
  use List::Util qw(max reduce);
  use Data::Table;
  use Data::Dumper;
  use App::Pipeline::Lite4::Template::TinyMod; 
  use App::Pipeline::Lite4::Util;
  use Storable qw(dclone);
  extends 'App::Pipeline::Lite4::Base';
  
  #has pipeline_datasource  => ( isa => 'Data::Table', is => 'rw', lazy_build =>1 );
  has placeholder_hash     => ( isa =>'HashRef', is => 'rw', default => sub {return {}});
  has current_run_num => ( isa => 'Num|Undef', is => 'rw');
  has current_run_dir => (isa => Path, is =>'rw', lazy_build => 1);
  has pipeline_step_struct => ( isa => 'HashRef' , is => 'rw', lazy_build => 1 );
  has pipeline_step_struct_resolved => ( isa => 'HashRef' , is => 'rw', default => sub {{}}  );
  has run_num_dep  => ( isa => 'Num|Undef', is => 'rw');
  has tot_jobs => ( isa => 'Num', is => 'ro', lazy_build => 1);
  #has job_filter_str  => ( isa => 'Str|Undef', is =>'rw');
  has job_filter => ( isa  => 'ArrayRef|Undef', is =>'rw', lazy_build => 1 );
  
  #has step_filter_str => ( isa => 'Str|Undef', is => 'rw'); in base
  has step_filter => ( isa => 'ArrayRef|Undef' , is => 'rw', lazy_build =>1 );
  
  
  #sub _build_pipeline_datasource {
  #    my $self = shift;
  #    my $datasourcefile = path( $self->datasource_file )->absolute;    
  #    ouch 'badfile', "Need to provide datasource file location\n" unless defined( $datasourcefile);
  #    #my $t =  App::Pipeline::Lite2::Datasource->new( datasource_file => $datasourcefile );         
  #    my $t = Data::Table::fromTSV( $datasourcefile->stringify );
  #}
  
  sub _build_pipeline_step_struct {
       my $self = shift;
       my $yaml = $self->pipeline_parse_file->slurp;
       return Load($yaml);   
  }
  
  sub _build_current_run_dir {
      my $self = shift;
      return  path( $self->output_dir, $self->output_run_name . ($self->current_run_num) );
  }
  
  sub _build_tot_jobs {
      my $self = shift;
      return $self->pipeline_datasource->lastRow + 1; 
  }
  
  sub _build_job_filter  {
      my $self= shift;
      if( defined $self->job_filter_str ) {
          #my @jobs_to_keep = $self->job_filter_str->split('\s+');
          #return \@jobs_to_keep;
          return $self->_parse_job_filter_str($self->job_filter_str);
      } else {
          return undef;    
      }   
  }
  
  sub _parse_job_filter_str {
      my $self = shift;
      my $job_filter_str = shift;
      my @job_filters = split ',', $job_filter_str;
      my @jobs;
      foreach my $job_filter (@job_filters){
          if($job_filter =~ '-'){
             my @pair = split '-', $job_filter;
             push @jobs, $pair[0] .. $pair[1]; 
          }else{
             push @jobs, $job_filter; 
          }
          
      } 
      return [ App::Pipeline::Lite4::Util::uniq( @jobs ) ];
  }
  
  
  sub _build_step_filter {
      my $self = shift;
      if( defined $self->step_filter_str ) {
          #my ($start_step, $end_step) = $self->step_filter_str =~ /([0-9]+)\-([0-9]+)/;
          my @steps;
          #if(defined($start_step) and defined($end_step)){
          #   @steps = $start_step .. $end_step;
          #   return \@steps;
          #} else {
             @steps = split '\s+', $self->step_filter_str;       
             return \@steps;
          #} 
      } else {
          return undef;    
      }
  }
  
  #does this only need to be done on a per job basis.
  sub _step_filter_on_resolved_step_struct  { 
          my $self = shift;
          my $steps = $self->step_filter;
          #warn "@$steps";
          my $resolved_step_struct = $self->pipeline_step_struct_resolved;
          $self->logger->debug( "Steps to keep: @$steps\n");        
          foreach my $step_struct (values %$resolved_step_struct) {
              foreach my $step_name ( keys %$step_struct) {               
                 $self->logger->debug( "Checking $step_name against filter\n" );
                 
                 #### WE WANT ANY####
                 my $code = sub { my $k = shift; return 1 if( $step_name eq $k ); return 0;   };
                 my $dont_delete = reduce { $a || $code->(local $_ = $b)  } 0,  @$steps;
                 
                 #delete $step_struct->{$step_name} unless any{ ($step_name eq $_) } any{ ($step_name eq $_) } @$steps; 
                 #######
                 
                 delete $step_struct->{$step_name} unless $dont_delete; #any{ ($step_name eq $_) } @$steps;          
              }
          }       
          #the run number must be set to the last run. otherwise we could end up with dependency issues.
          #this might not be good enough, e.g. we may have run a smoke_test - this creates output directories
          #my $last_run_num = App::Pipeline::Lite1::Resolver->new( output_dir => $self->output_dir)->_last_run_number;    
          #$self->run_num($last_run_num) unless defined($self->run_num); #the user has already assigned a run number we use this
          #$self->logger->debug("Set run number to " . $self->run_num);
  } 
  
  sub _job_filter_on_resolved_step_struct   { 
       my $self=shift;
       my $jobs_to_keep= $self->job_filter;
        
       my $resolved_step_struct = $self->pipeline_step_struct_resolved;
       $self->logger->debug( "Jobs to keep: @$jobs_to_keep\n");
       foreach my $job_num (keys %$resolved_step_struct) {
           
            #### WE WANT ANY####
                 my $code = sub { my $k = shift; return 1 if( $job_num eq $k ); return 0;   };
                 my $dont_delete = reduce { $a || $code->(local $_ = $b)  } 0,  @$jobs_to_keep;               
            #delete $resolved_step_struct->{$job_num} unless any { ($job_num == $_) } @$jobs_to_keep;
            #######
                   
           delete $resolved_step_struct->{$job_num} unless $dont_delete;
       }
  }
  
  sub resolve {
     my $self = shift;
     # TYPE: ( Path::Class::File :$yaml_infile,  Path::Class::File :$yaml_outfile )  
     my $yaml_infile  = shift;
     my $yaml_outfile = shift;
     $self->pipeline_parse_file($yaml_infile); #sets the path to yaml file produced by parser step
     $self->_resolve;
     $yaml_outfile->spew( Dump( $self->pipeline_step_struct_resolved ) );
  }
  
  sub _resolve {
      my $self = shift;
      #$self->clear_pipeline_step_struct_resolved;    
      $self->current_run_num( $self->_last_run_number + 1 ) unless defined( $self->current_run_num);
      
      foreach my $row ( 0 .. $self->pipeline_datasource->lastRow ) {
           $self->logger->log("debug", "=== Job $row  ==="); 
           $self->_add_data_source_to_placeholder_hash( $row);
            #add input file directory to placeholder hash
           $self->_add_input_files_to_placeholder_hash;
           #add software to placeholder hash
           $self->_add_software_to_placeholder_hash;
           # add globals to placeholder hash      
           ##$self->_add_dir_to_placeholder_hash ( dir_name => 'global', dir_path => dir( $self->output_dir , 'run' . ($self->current_run_num) )); 
           # add data dir to placeholder hash 
           ##$self->_add_dir_to_placeholder_hash ( dir_name => 'data', dir_path => dir( $self->output_dir->parent ) );
           
           # add in the output files expected for each step to the placeholder hash       
           $self->_add_steps_in_step_struct_to_placeholder_hash($row);
           $self->_create_directory_structure_from_placeholder_hash;         
           
           # add in the output files expected for each step to the placeholder hash       
           $self->_add_expected_output_files_to_placeholder_hash( $row);
           $self->_add_expected_output_files_to_jobs_in_placeholder_hash;
        #   warn Dumper $self->placeholder_hash;
  
           # validate placeholders against placeholder hash
           $self->_validate_placeholder_hash_with_placeholders;
           # interpolate the cmds in each step and add to new resolved_step_struct
           $self->_interpolate_cmd_in_step_struct_to_resolved_step_struct( $row);
           $self->_step_filter_on_resolved_step_struct if defined $self->step_filter_str; 
           $self->_job_filter_on_resolved_step_struct if defined $self->job_filter_str;
           $self->_once_condition_filter_on_resolved_step_struct;
           $self->_groupby_condition_filter_on_resolved_step_struct;
           $self->placeholder_hash({});
      }    
      #$self->logger->log( "info", "Final Resolved Step Struct: \n" . Dumper $self->pipeline_step_struct_resolved );
  }
  
  
  =method _add_data_source_to_placeholder_hash
     Reads the data source as specified in $self->pipeline_datasource and 
     parses a specified row of the datasource to the placeholder_hash  
  =cut
  sub _add_data_source_to_placeholder_hash{ 
        #TYPE:  Num :$datasource_row 
        my $self = shift;
        my $datasource_row = shift;
        my $t = $self->pipeline_datasource;
        my @header = $t->header;
        for my $i (0 .. $t->lastCol ) {
           #print $header[$i], " ", $t->col($i), "\n";      
           my @datasource_rows = $t->col($i);
           $self->logger->log( "debug", "Datasource col $i : ".$header[$i] . " =>  $datasource_rows[$datasource_row]");
           #adds in the datasource reference here, so that we can deal specially with datasource stuff later in create_directory_structure
           $self->_placeholder_hash_add_item( "datasource." . $header[$i],  $datasource_rows[$datasource_row]  );
  
      }   
  }
  
  
  sub _add_software_to_placeholder_hash {
      my $self = shift;
      return unless defined $self->software_dir; 
      my $dir = $self->software_dir;    
      return unless $dir->exists;
      my @software = $dir->children;
  
      #add to placeholder;   
      for my $i (0 .. $#software) {
         $self->_placeholder_hash_add_item( "software.".$software[$i]->basename, $software[$i]->stringify )
          unless $software[$i]->stringify eq $self->software_ini_file->stringify;       
      }  
      
      # we then need to add the software in in the software.ini file
      return unless defined $self->software_ini;
      return unless $self->software_ini_file->exists;
      foreach my $software_name ( keys %{ $self->software_ini->{_} }  ) {
          $self->_placeholder_hash_add_item(  "software.$software_name", $self->software_ini->{_}->{$software_name} );
      }
      
  }
  
  
  sub _add_input_files_to_placeholder_hash {
     my $self = shift;  
     # read folder called input add to the placeholder hash
     # can add folders to input directory and it will pick the names  
     return unless defined $self->input_dir; 
     my $dir = $self->input_dir;
     return unless $dir->stat;
     
     ouch 'App_Pipeline_Lite4_ERROR', "The input directory $dir does not exist" unless $dir->stat;
     
     my @files;
  
     my $iter = $dir->iterator( { recurse => 1 } );  
     while( my $path = $iter->() ){        
          next unless $path->is_file;
          push( @files, $path);
     }
      #add to placeholder;   
      for my $i (0 .. $#files) {
         $self->_placeholder_hash_add_item( "input.".$files[$i]->basename,  
                                             $files[$i]->stringify );
      }
  }
  
  # placeholder hash is where we have {step0}{file1} = value
  # currently we leave it for the groupby case, so that we just have a long key that still matched fine
  # probably we should have the step and its field names as one key 
  # {groupby}{cmp.hmr}{file.name} = /outputdir/job../hmr/file.name
  sub _placeholder_hash_add_item{
     #TYPE: ( Str :$keystr, Str :$value) 
     my $self   = shift;
     my $keystr = shift;
     my $value  = shift; 
     my @keystr = split('\.', $keystr);   
     if( $keystr[0] eq 'jobs'){
  	  @keystr = ( $keystr[0], $keystr[1], join('.', @keystr[2 .. $#keystr]  ) ); 
  	}else {
        @keystr = ( $keystr[0], join('.', @keystr[1 .. $#keystr]  ) );
  	} 
     if (@keystr == 2){
      $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] } = $value ;  
      $self->logger->log("debug", " _placeholder_hash_add_item:  Adding @keystr and $value. Value from hash: " . $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] });
      
     }
      if (@keystr == 3){
         $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] }{ $keystr[2] } = $value;             
     }
  } 
  
  # this method could be broken down into
  # _add_steps_to_placeholder_hash
  # _add_all_job_steps_to_placeholder_hash
  # or leave it like this, except call it _add_steps_to_placeholder_hash
  # as we are using the same mechanism to generate the file locations.
  #
  # this is a horrible function and needs to be fixed and refactored in someway
  # the reason we loop over all jobs is because any job can still refer tot_jobs
  # groupby and jobs placeholders if they wish... not entirely true for groupby 
  # we would have to bring in the syntax to allow a specific group to be instantiated using 
  # groupby.type=A.file.txt or something like that. 
  # at the moment if this is done, then one group is given (the one where the group values are top of an ascending perl sort  
  
  sub _add_steps_in_step_struct_to_placeholder_hash {
     #TYPES: ( Num :$job_num ){
     my $self = shift;
     my $JOB_NUM = shift;
     my $step_struct = $self->pipeline_step_struct; # we have placeholders parsed for each step
     #warn "JOB_NUM $JOB_NUM";
     foreach my $step_name (keys %$step_struct ){
        $self->logger->log( "debug", "Processing Pipeline to placeholder hash step " . $step_name);
        my $placeholders = $step_struct->{$step_name}->{placeholders}; 
        next unless defined($placeholders);      
        foreach my $placeholder ( @$placeholders ) {
              
              #           
              # A placeholder that references a step, should be mentioned in that step. 
              # I.e We do not need to worry about it if it appears in other steps.
              # Thus we only process the placeholders in step X that mention this step X.
              # -----
              
              my $output_files;
              my @output_run_dir;
              # case 1. stepX.fileY
              $self->logger->debug("step $step_name. Processing $placeholder"); 
              #my $placeholder_rgx = qr/(step$step_num)(\.(.+))*/; 
              my $placeholder_rgx = qr/^($step_name)(\.(.+))*$/; 
              if( @output_run_dir = $placeholder =~ $placeholder_rgx ){
                 $self->logger->debug("step $step_name. Got " . Dumper(@output_run_dir) . " from $placeholder");               
                 @output_run_dir = @output_run_dir[0,2]; # we don't want [1], so @output_run_dir is 2 length array
                 if( defined $output_run_dir[1] ){ # if the 2nd element is defined e.g. normally a filename like note.txt
                     # specific case for steps that are once - they can only refer to a single job directory
                    
                     # 2/07/2014
                     # because this is being done for every row in the datasource then we will be making a once step
                     # for each job/row and then later pruning those steps that we dont need - i.e. we only want to have the 
                     # job0 step for a once condition. It should also mean that for row0/job0, any placeholder would get job0 path names 
                     # so this really shouldn't be needed, I'm not sure I understand why it's there.
                     if ( defined (   $step_struct->{$step_name}->{condition} )){
                        
                        if( $step_struct->{$step_name}->{condition} eq 'once' ){ 
                            my $min_job = 0;
                            my $jobs = $self->job_filter;
                            ($min_job) = sort {$a <=> $b} @$jobs if defined($jobs);
                            $output_files = $self->_generate_file_output_location($min_job, \@output_run_dir)->stringify;
                        }else {
                            # we may have to deal with a case here for groupby
                            $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;  
                        }
                     }else{
                            $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;               
                     }
                    
                     #the below condition is just weird - by defn $output_run_dir[1] is !defined, 
                     #and $output_run_dir[2] should not exist. 
                     # anyway this below is just the case where the step name exists.
                 }elsif ( ( ! defined $output_run_dir[1] ) and ( ! defined $output_run_dir[2] ) and ( defined $output_run_dir[0] ) ) {
                    pop @output_run_dir; #remove last entry because it def can't be undefined I guess, no, remove last entry because we only want the step dir
                    $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;
                    #warn "PLACEHOLDER", $placeholder;
                    #warn "OUTPUT RUN DIR (NORMAL PLCHOLDER) ". Dumper @output_run_dir;
                    #warn "OUTPUTFILES(NORMAL PLCHOLDER) ".$output_files;
                 }
                 $self->logger->debug("step $step_name. Extracted a run dir from: @output_run_dir. Full path is $output_files ");  
              }
              
              # case 2.  jobs.stepX.fileY
              # note that because we don't check for conditions in this function
              # then having "jobs...." allows us to identify placeholders that are
              # from once conditions. 
              # I think we should have conditions here instead, jobs only exists in a once step.
              # although it does give some clarity about what is going on in the summary steps.            
              my $jobs_placeholder_rgx = qr/jobs\.([\w\-]+)\.(.+)$/;
              if(@output_run_dir = $placeholder =~ $jobs_placeholder_rgx){
                 # get all the files from a step for all jobs
                 my @stepfiles;
                 my $num_of_jobs = $self->tot_jobs;
                 for my $job_num ( 0 .. $num_of_jobs -1 ) {
                     if( $output_run_dir[0] eq 'datasource' ) {                      
                        my $t = $self->pipeline_datasource;
                        my @datasource_rows = $t->col( $output_run_dir[1] );
                        push( @stepfiles,$datasource_rows[$job_num] ); 
                     }else{    
                        push( @stepfiles, 
                              $self->_generate_file_output_location(
                                  $job_num, \@output_run_dir)->stringify );                   
                     }
                 }
                 # JOB FILTER
                 my $job_filter = $self->job_filter;
                 @stepfiles = @stepfiles[@$job_filter] if defined ( $job_filter );
                 $output_files = join ' ', @stepfiles;
                 $self->logger->debug("step $step_name. Extracted a run dir from: @output_run_dir. Full path is $output_files ");
              }
              
              
              # case 3. groupby
              # to get the run directory we need to make a regex that takes into account
              # the condition_params - we are parsing [% groupby.type.file.txt %]
              # we have to infer the group by fields from the placeholder regex and not the 
              # step condition, because these can occurr in a stp without a groupby condition 
              # the only way to do that is to get the header from the datasource and see if there
              # are any matching fields.
  
              if( $placeholder =~ /groupby/ ){ #don't get in the door unless groupby 
                 my $groupby_placeholder_rgx;
                 # get the datasource
                 
                 my $col_names = $self->pipeline_datasource->{header};
                 #warn "WORKING WITH DATASOURCE: " . $self->datasource_file;
                 #warn "DATASOURCE: " . Dumper $self->pipeline_datasource;
                 
                 my $col_names_rgx_str = join "|", @$col_names;               
                 my $groupby_placeholder_rgx_str = 'groupby\.('.$col_names_rgx_str . ')\.(' . $col_names_rgx_str . ')*\.*([\w\-]+)\.(.+)$';  
                 #warn "PLACEHOLDER $placeholder";
                 #warn "PLACEHOLDER RGX:", $groupby_placeholder_rgx_str;
                 $groupby_placeholder_rgx = qr/$groupby_placeholder_rgx_str/;
                 my @output_run_dir = $placeholder =~  $groupby_placeholder_rgx;
                 #warn "PLACEHOLDER PARTS:", Dumper @output_run_dir;
                
                 # check if the second argument is present
                 my @group_names;
                 if ( defined $output_run_dir[1] ){
  
                     @group_names = @output_run_dir[0,1];
                     @output_run_dir = @output_run_dir[2 .. $#output_run_dir];
                      
                 }else{
  
                     @group_names = $output_run_dir[0 ];
                     @output_run_dir = @output_run_dir[2 .. $#output_run_dir];
                 }
                  # warn "OUTPUTDIR @output_run_dir";
                 if ( ! defined $output_run_dir[0] ){
                     ouch 'App_Pipeline_Lite4_ERROR', "The groupby placeholder has a group name that does not exist in the datasource";
                 }
                       
                 # now get the mapping of job ids
                 #warn "OUTPUTDIR", "@output_run_dir";
                 my $util = App::Pipeline::Lite4::Util->new;
                 #warn "GROUP NAMES: @group_names";
                 my $job_map_hash = $util->datasource_groupby2( $self->pipeline_datasource, @group_names );
                 #warn Dumper $job_map_hash;
                 
                 # So now run through the jobids and make strings of the files
                 # we only do the jobs that we need to do, i.e. since we have grouped into 4 groups, 
                 # we only want to do the four jobs and these will be done on each iteration of _resolve looop 
                 my @grouped_jobs = sort keys %$job_map_hash; 
                 my $grouped_job_idx;
                 $grouped_job_idx = ($JOB_NUM <= $#grouped_jobs) ? $JOB_NUM : 0; 
                 # for job numbers higher, then you get the first group 
                 # this will be implemented later so that you can chose 
                 # which group thought someihtng like
                 # [% groupby.type=A.file.txt %]
                 my $grouped_jobs_id = $grouped_jobs[ $grouped_job_idx ];
                 my @stepfiles;
                 my $jobs = $job_map_hash->{$grouped_jobs_id};
                 for my $job_num ( @$jobs){
                     
                     if( $output_run_dir[0] eq 'datasource' ) {                      
                        my $t = $self->pipeline_datasource;
                        my @datasource_rows = $t->col( $output_run_dir[1] );
                        push( @stepfiles,$datasource_rows[$job_num] ); 
                    }else{
                     
                     
                     push( @stepfiles, $self->_generate_file_output_location($job_num, \@output_run_dir)->stringify);                  
                    }
                 
                 }
                 my $job_filter = $self->job_filter;
                 @stepfiles = @stepfiles[@$job_filter] if defined ( $job_filter );
                 $output_files = join ' ', @stepfiles;
                 #warn "STEPFILES: $output_files";
                 
              } 
              
              # add to placeholder hash - if there is something to add
              if( defined( $output_files ) ){               
                  $self->_placeholder_hash_add_item( $placeholder, $output_files); #in order key,value
                  $self->logger->debug("step $step_name. Generated file location for placeholder $placeholder as $output_files");
              }
           }  
     }
     #warn Dumper $self->placeholder_hash;
  }
  
  =method _create_directory_structure_from_placeholder_hash  
    At the moment we  allow directory with 'dir' in the name
    to be created as a directory - e.g. for this scenario 
    e.g. 1. some_app --output-dir [ step1.dir ]
    Where some_app requires a pre-existing directory for storing it's output
    We could resolve this issue without using this.
    By doing:
    1. mkdir [% step1.outputdir %]; some_app --output-dir [% step1.outputdir %]
    So it's debatable whether we want automatic creation of directories with 'dir' in the name, 
    but will leave for backwards compatability
    THE DIR BEHAVIOUR SHOULD BE DEPRECATED
  =cut
  
  sub _create_directory_structure_from_placeholder_hash {
      my $self = shift;
      $self->logger->debug("Creating directory structure from placeholder hash...");
      # run over hash    
      my $placeholder_hash = $self->placeholder_hash;
      $self->logger->debug(Dumper($placeholder_hash));
      foreach my $step (keys %$placeholder_hash ){
         next if( ($step eq 'step0') or ($step eq 'datasource')); # we don't create any directories from the source step values. (which could be filenames)
         foreach my $param (keys $placeholder_hash->{$step} ){
             if ($param =~ /dir/) {
                 my $dir = path( $placeholder_hash->{$step}->{$param} );
                 #make_path($dir->stringify);
                 $dir->mkpath;
                 $self->logger->debug("Making directory: $dir" );
             } else {
                my $file = path( $placeholder_hash->{$step}->{$param} );
                #make_path($file->parent->stringify);
                $file->parent->mkpath;
                $self->logger->debug("Making directory: " . $file->parent->stringify );
             }
         }      
      }
  } 
  
  # processing the "X.output file1 file2 .."  lines 
  sub _add_expected_output_files_to_placeholder_hash {
       # TYPE: ( Num :$job_num ) 
       my $self = shift;
       my $job_num = shift;
       my $step_struct = $self->pipeline_step_struct; # we have outputfiles parsed for each step     
       foreach my $step_name (keys %$step_struct ){
          $self->logger->debug( "Processing expected output file for Step: " . $step_name); 
          $self->logger->debug("Make filepaths and placeholder hash entry for stated outputs of step $step_name");
          my $file_num = 1;
          $self->logger->debug("So far there are " . ($file_num - 1) . " file(s) registered as outputs for this step");
          my $outputfiles = $step_struct->{$step_name}->{outputfiles};
          if( defined( $outputfiles) ) {
              foreach my $outputfile ( @$outputfiles ) {  
                    #output_path_in_run_dir should be output_path_in_job_dir
                    #check whether the file_path is absolute, if its absolute then we don't generate anything for it  
                   # if($step_name =~ /^[1-9][0-9]*[a-z]*$/){
                   #   my $file_path = $self->_generate_file_output_location( $job_num, ['step'. $step_name , $outputfile] ); 
                   #   $self->placeholder_hash->{"step$step_name"}{"output$file_num"}=$file_path->stringify; 
                   #   $self->logger->debug( "Made step$step_name output$file_num : " . $file_path->stringify);
                   #   $file_num++;
                   # }else{
                      my $file_path = $self->_generate_file_output_location( $job_num, [ $step_name , $outputfile] ); 
                      $self->placeholder_hash->{"$step_name"}{"output$file_num"}=$file_path->stringify; 
                      $self->logger->debug( "Made $step_name output$file_num : " . $file_path->stringify);
                      $file_num++;
                   # }    
              }
          }
       }
  }
  
  sub _add_expected_output_files_to_jobs_in_placeholder_hash {
      my $self = shift;
      #get the expected output files
      my $step_struct = $self->pipeline_step_struct;   
      my $placeholder_hash = $self->placeholder_hash;    
      return if( ! exists $placeholder_hash->{jobs} );    
      my $jobs = $placeholder_hash->{jobs};    
      foreach my $step (keys %$jobs){
         next if $step eq 'datasource';
         my $filenames_and_paths = $jobs->{$step};
         my @filenames = keys %$filenames_and_paths;
         foreach my $filename (@filenames){
           my ($output_num) = $filename =~ /output([0-9]+)/;   
           next unless defined( $output_num);      
           my $outputfiles = $step_struct->{$step}->{outputfiles};
           my $name_of_output_file  = $outputfiles->[$output_num-1];
           $filenames_and_paths->{$filename}  =~ s/output$output_num/$name_of_output_file/g;
         }
      }
  }
  
  =method _validate_placeholder_with_placeholders
     
     What happens if you add a non existant placeholder e.g. [% step0.fil %] ?
     The parser has parsed out this placeholder - so it is part of the step_struct placeholders for each step
     But, it won't have a corresponding value in the placeholder hash, since it not of the right form.
     Not having a value, might be desired behaviour for somethings (this could be warned), 
     But not existing in the hash is an error.
     
  =cut
  
  sub _validate_placeholder_hash_with_placeholders {
     my $self = shift;   
     #foreach step check that we have the right stuff in the placeholder hash
      my $step_struct = $self->pipeline_step_struct;
      my %problem_placeholders;
      foreach my $step_name ( keys %$step_struct) {
         my $placeholders = $step_struct->{$step_name}->{placeholders}; 
         $self->logger->debug( "Validating Step: " . $step_name);
          foreach my $placeholder (@$placeholders) {
             #if($placeholder =~ /^datasource\./){
             #   ($placeholder ) = $placeholder =~ /datasource\.(.+)$/; 
             #}
             #ouch 'App_Pipeline_Lite2_Error', "Check the placeholder $placeholder - it is incorrectly named." 
             #  . Dumper ($self->placeholder_hash)
             #  unless $self->_placeholder_hash_check_item_exists( keystr => $placeholder );
             $problem_placeholders{ $placeholder } = 1  unless $self->_placeholder_hash_check_item_exists(  $placeholder );;  
          }
      }
      my @problem_placeholders = keys %problem_placeholders;
      my $problem_placeholders = join "\n", @problem_placeholders ;
      ouch 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER', "Check the placeholders:\n$problem_placeholders\n" 
               if @problem_placeholders > 0;
      
  }
  
  sub _interpolate_cmd_in_step_struct_to_resolved_step_struct {
      # ( Num :$job_num ) {
      my $self = shift;   
      my $job_num = shift;   
      my $step_struct = $self->pipeline_step_struct;
      $self->logger->debug("Step struct has : " . Dumper( $step_struct ));
      $self->logger->debug("Placeholder hash has : " . Dumper ( $self->placeholder_hash ) );
      my %output_hash;
      my $interpolated_cmd;
      my $interpolated_output;
      my $new_step_struct = dclone($step_struct);
      my $tt = App::Pipeline::Lite4::Template::TinyMod->new;
      foreach my $step ( keys %$step_struct) {
         my $cmd = $step_struct->{$step}->{cmd}; 
         $interpolated_cmd = $tt->_process($self->placeholder_hash, $cmd);
         $new_step_struct->{$step}->{cmd} =$interpolated_cmd;
         $interpolated_cmd = '';
         
         #also do for output line
        
         if( exists $step_struct->{$step}->{outputfiles} ){ 
             my $output_files = $step_struct->{$step}->{outputfiles}; 
              $new_step_struct->{$step}->{outputfiles} = [];
             foreach my $output (@$output_files){
                 $interpolated_output = $tt->_process($self->placeholder_hash, $output);
                 my $outputfiles = $new_step_struct->{$step}->{outputfiles}; 
                 push(@$outputfiles, $interpolated_output); #CHECK THIS IN TEST
                 $interpolated_output = '';
             }
         } 
      }
      $self->pipeline_step_struct_resolved->{$job_num} = $new_step_struct;    
  }
  
  
  sub _placeholder_hash_check_item_exists{
      # TYPE: Str :$keystr
      my $self = shift;
      my $keystr = shift;
      my @keystr = ();
      @keystr = split('\.', $keystr) if ($keystr =~ /\./);
      return exists $self->placeholder_hash->{ $keystr } if( @keystr == 0);
        
      if( $keystr[0] eq 'jobs'){
  	  @keystr = ( $keystr[0], $keystr[1], join('.', @keystr[2 .. $#keystr]  ) ); 
  	}else {
        @keystr = ( $keystr[0], join('.', @keystr[1 .. $#keystr]  ) );
  	} 
  	
      return exists $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] } if @keystr == 2;  
      return exists $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] }{ $keystr[2] } if @keystr == 3;   
  }
  
  sub _once_condition_filter_on_resolved_step_struct {
     my $self = shift;
     my $resolved_step_struct = $self->pipeline_step_struct_resolved;
     my @keys = sort {$a <=> $b } keys %$resolved_step_struct;
     shift @keys; #remove the lowest job
     $self->logger->debug("Deleting once steps in these steps: @keys");
     foreach my $job_num (@keys){  
         my $job = $resolved_step_struct->{$job_num}; 
         foreach my $step (keys %$job) { 
            next unless ( exists  $job->{$step}->{condition}  ); 
            next unless ( defined $job->{$step}->{condition}  );   
            if ( $job->{$step}->{condition} eq 'once') {
                  $self->logger->debug("Deleting once step in $job_num");
                  delete $job->{$step};
            }
         }
     }         
  } 
  
  sub _groupby_condition_filter_on_resolved_step_struct {
      my $self = shift;
      my $resolved_step_struct = $self->pipeline_step_struct_resolved;
      my @keys = sort {$a <=> $b } keys %$resolved_step_struct;
      # need to get the number of jobs to shift off.
      my $util = App::Pipeline::Lite4::Util->new;
     
      #shift @keys for 0 .. $num_grouped_jobs - 1; #remove the X lowest jobs depending on the step groupby clause
      $self->logger->debug("Consider deleting groupby steps in these steps: @keys");
      foreach my $job_num (@keys){  
         my $job = $resolved_step_struct->{$job_num}; 
         foreach my $step (keys %$job) { 
            next unless ( exists  $job->{$step}->{condition}  ); 
            next unless ( defined $job->{$step}->{condition}  );   
            if ( $job->{$step}->{condition} eq 'groupby') {                
                  my $params = $job->{$step}->{condition_params};
                  my $num_grouped_jobs = $util->datasource_groupby2_num_groups($self->pipeline_datasource, @$params);
                  if( $job_num >= $num_grouped_jobs){
                      $self->logger->debug("Deleting groupby step $step in $job_num");
                      delete $job->{$step};
                  }
            }
         }
     }           
  }
  
  
  
  sub _generate_file_output_location { 
     # TYPE:( :$job_num, :$output_path_in_run_dir )  
     my ($self, $job_num, $output_path_in_run_dir) = @_;
     if ( defined $self->run_num_dep ) { 
        my $steps = $self->step_filter;
        
        #### WE WANT ANY####
        my $code = sub { my $k = shift; return 1 if( $output_path_in_run_dir->[0] eq $k ); return 0;   };
        my $valid_step = reduce { $a || $code->(local $_ = $b)  } 0,  @$steps;
        # my $valid_step = any{ ($output_path_in_run_dir->[0] =~ $_) } @$steps;
        ###############
              
        if ( !$valid_step ) { 
         my $alt_run_dir = path( $self->output_dir, $self->output_run_name . ($self->run_num_dep) );
         return path( $alt_run_dir , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
        }
     }
     return path( $self->current_run_dir , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
     # return file( $self->output_dir, 'run' . ($self->current_run_num) , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
  }
  
  =method _run_number 
     Provides the last run number by looking at previous run directory numbers
  =cut
  ## THIS IS IN BASE NOW - REMOVE
  sub _last_run_number {
      my $self=shift;
      #read in files in data directory
      #order by run number
      # - if none then run number is 1.
      my $run_num = max map { if( $_ =~ /run([0-9]+)/){$1}else{} } $self->output_dir->children;
      $run_num = 0 unless (defined $run_num);    
      return $run_num;   
  }
  
  1;
APP_PIPELINE_LITE4_RESOLVER

$fatpacked{"App/Pipeline/Lite4/SetupPipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_SETUPPIPELINE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::SetupPipeline ;
  use Moo;
  use MooX::late;
  
  extends 'App::Pipeline::Lite4::Base';
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
   
  sub create_pipeline_directory {
      my $self=shift;
      my $based_on = shift; # PARAMETER TYPE: ( Path::Tiny $based_on? ) i.e. optional 
      
      my $dir             = $self->pipeline_dir;
      my $output_dir      = $self->output_dir;
      my $input_dir       = $self->input_dir;
      my $pipeline_file   = $self->pipeline_file;
      my $test_data_file  = $self->test_data_file;
      my $datasource_file = $self->datasource_file;
      my $software_dir    = $self->software_dir;
      ouch 'App_Pipeline_Lite4_Error', "That pipeline already exists."  if $dir->exists;
      $dir->mkpath();  
      $output_dir->mkpath();
      $input_dir->mkpath();
      $software_dir->mkpath();
      
      #set output file and read to config file
      $self->config->{_}->{output_dir} = $output_dir->absolute->stringify;
      $self->config->{_}->{input_dir}  = $input_dir->absolute->stringify;
  
      $self->config->write($self->config_file->absolute->stringify); 
      
      #create a small pipeline file and a dummy test data directory
      $pipeline_file->spew("1. wc -l [% step0.file1 %] > [% step1.file1 %]");
      $test_data_file->parent->mkpath();
      $test_data_file->spew("line1\nline2\nline3");
      
      #create a small datasource file
      my $datasource = "step0.file1\n" . $test_data_file->absolute->stringify;
      $datasource_file->spew($datasource);
      $self->create_logfile_config;
  }
  
  
  sub create_logfile_config {
     my $self = shift; 
     my $default = 
     { 
       file => {
                filename => defined($self->logfile) ? $self->logfile : "/tmp/".__PACKAGE__.".log",
                maxlevel => "debug",
                minlevel => "warning",
                message_layout => "%T [%L] [%p] line %l: %m",
              }
     };
     my $conf_yaml  = Dump($default);
     $self->logconffile->spew($conf_yaml);  
  }
  1;
APP_PIPELINE_LITE4_SETUPPIPELINE

$fatpacked{"App/Pipeline/Lite4/Template/TinyMod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_TEMPLATE_TINYMOD';
  package App::Pipeline::Lite4::Template::TinyMod;
  
  # Load overhead: 40k
  
  #use 5.00503;
  use strict;
  
  $Template::Tiny::VERSION = '1.12';
  
  # Evaluatable expression
  my $EXPR = qr/ [a-z_\-][\-\w.]* /xs;
  
  # Opening [% tag including whitespace chomping rules
  my $LEFT = qr/
  	(?:
  		(?: (?:^|\n) [ \t]* )? \[\%\-
  		|
  		\[\% \+?
  	) \s*
  /xs;
  
  # Closing %] tag including whitespace chomping rules
  my $RIGHT  = qr/
  	\s* (?:
  		\+? \%\]
  		|
  		\-\%\] (?: [ \t]* \n )?
  	)
  /xs;
  
  sub new {
  	bless { @_[1..$#_] }, $_[0];
  }
  
  sub _process {
  	my ($self, $stash, $text) = @_;
      # Resolve expressions
  
  	$text =~ s/
  		$LEFT ( $EXPR ) $RIGHT
  	/
  		eval {
  			$self->_expression($stash, $1)
  			. '' # Force stringification
  		}
  	/gsex;
  	return $text;
  }
  
  
  sub _expression {
  	my $cursor = $_[1];
  	
  	my @path   = split /\./, $_[2];
  	if( $path[0] eq 'jobs'){
  	  @path = ( $path[0], $path[1], join('.', @path[2 .. $#path]  ) ); 
  	}else {
        @path = ( $path[0], join('.', @path[1 .. $#path]  ) );
  	}
  	
  	foreach ( @path ) {
  		# Support for private keys
  		return undef if substr($_, 0, 1) eq '_';
  
  		# Split by data type
  		my $type = ref $cursor;
  		
  		#if ( $type eq 'ARRAY' ) {
  		#	return '' unless /^(?:0|[0-9]\d*)\z/;
  		#	$cursor = $cursor->[$_];
  		#} elsif ( $type eq 'HASH' ) {
  		#	$cursor = $cursor->{$_};
  		#} elsif ( $type ) {
  		#	$cursor = $cursor->$_();
  		#} else {
  		#	return '';
  		#}
  		if ( $type eq 'HASH' ) {
  			$cursor = $cursor->{$_};
  	    }else {
  		  return '';	
          }
  		
  	}
  	return $cursor;
  }
APP_PIPELINE_LITE4_TEMPLATE_TINYMOD

$fatpacked{"App/Pipeline/Lite4/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_UTIL';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Util ;
  use Moo;
  use Term::UI;
  use Term::ReadLine; 
  use Path::Tiny;
  use Time::Piece;
  use Data::Dumper;
  extends 'App::Pipeline::Lite4::Base';
   
  use Ouch;
  
  sub view_file_with_editor {
      my $self = shift; 
      my $filename = shift; # PARAMETER TYPE: ( Path::Tiny $filename ) 
      
      my $editor = $self->system_config->{_}->{editor} ; #check system config first     
      ouch 'App_Pipeline_Lite4_Error', "No pipeline editor set, try --editor EDITOR.  (e.g. --editor vim)" unless defined($editor);    
      my $cmd = qq{$editor $filename};
      
      eval {
        system($cmd);
      };
      
      if ( hug ) {
        ouch 'App_Pipeline_Lite4_Error', "Viewing the file with the editor '$editor' did not work. Perhaps set something different in system config.";    
      }
  }
  
  sub set_editor  {
      my $self = shift;
      my $editor = shift; # TYPE: ( Str $editor  )
      $self->system_config->{_}->{editor}  = $editor;
      $self->system_config->write($self->system_config_file);
      $self->system_logger->log( "info", "Set $editor as default editor");
  }
  
  sub ask_for_description {
    #( Num $run_num ) {
    my $self = shift;  
    my $term = Term::ReadLine->new('describe-run');
      
    my $print_me = <<PRINTME;
       
       *************
        Description
       -------------    
  PRINTME
      
      my $bool = $term->ask_yn(
              prompt => "Do you want to describe this run?"            
              );
            
     if($bool) {
       my $desc = $term->get_reply(
              print_me => $print_me,
              prompt => "Enter description: ",
       ); 
     }  
  }
  
  sub append_description {
    my $self         = shift;  
    my $run_info     = shift // "";
    my $message      = shift // "";
    my $append_file  = $self->pipeline_submission_file;
    my $t = localtime;
    my $run_desc = join "\t", $t->datetime, $run_info, $message;
    $run_desc .= "\n";
    my $path = path($append_file)->append($run_desc); 
  }
  
  sub uniq {
    my %seen;
    return grep { !$seen{$_}++ } @_;
  }
  
  sub datasource_groupby {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    while( my $row = $next->() ){ 
      #warn Dumper $row;   
      push( @{ $group_hash{ $row->{$groupby_field} } }, $i );  
      $i++;
    }
    return \%group_hash; 
  }
  #the idea is to only offer a groupby one attribute, if more than one
  #is required then the datasource should be given an extra column and
  # the two column mergedin to a specific column
  # the exception is for grouptransby which will work with two columns in general I think.
  # for testing purposes we have this here.
  sub datasource_groupby2 {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    while( my $row = $next->() ){ 
      #warn Dumper $row;
      
      if( defined($groupby_field1) and defined( $groupby_field2 )){    
          push( @{ $group_hash{$row->{$groupby_field1} .'-' . $row->{$groupby_field2} } } , $i );  
      }elsif( defined($groupby_field1 ) ){
          push( @{ $group_hash{ $row->{$groupby_field1} } }, $i );   
      }else{
          ouch "App_Pipeline_Lite4_Error","No groupby fields to group by";
      }
        
      $i++;
    }
    return \%group_hash; 
  }
  
  sub datasource_groupby2_num_groups {
    my $self = shift;
    my @args = @_;
    #warn "DATASOURC ARGS ," , Dumper @args;
    my $groupby_hash = $self->datasource_groupby2(@args);
    return scalar keys %$groupby_hash;  
  }
  
  sub groupby_placeholder_regex_get_step {
    my $self       = shift;
    my $datasource = shift;
    my $groupby_fields  = shift;
  
    my $col_names = $datasource->{header};
    my $col_names_rgx_str = join "|", @$col_names;               
    my $groupby_placeholder_rgx_str = 'groupby\.('.$col_names_rgx_str . ')\.(' . $col_names_rgx_str . ')*\.*(.+)$';
    
  }
  
  1;
APP_PIPELINE_LITE4_UTIL

$fatpacked{"App/Rad.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD';
  package App::Rad;
  use 5.006;
  use App::Rad::Help;
  use Carp                ();
  use warnings;
  use strict;
  
  our $VERSION = '1.05';
  {
  
  #========================#
  #   INTERNAL FUNCTIONS   #
  #========================#
  
  my @OPTIONS = ();
  
  sub _init {
      my $c = shift;
  
      # instantiate references for the first time
      $c->{'_ARGV'    } = [];
      $c->{'_options'} = {};
      $c->{'_stash'  } = {};
      $c->{'_config' } = {};
      $c->{'_plugins'} = [];
  
      # this internal variable holds
      # references to all special
      # pre-defined control functions
      $c->{'_functions'} = {
          'setup'        => \&setup,
          'pre_process'  => \&pre_process,
          'post_process' => \&post_process,
          'default'      => \&default,
          'invalid'      => \&invalid,
          'teardown'     => \&teardown,
      };
      
      #load extensions
      App::Rad::Help->load($c);
      foreach (@OPTIONS) {
          if ($_ eq 'include') {
              eval 'use App::Rad::Include; App::Rad::Include->load($c)';
              Carp::croak 'error loading "include" extension.' if ($@);
          }
          elsif ($_ eq 'exclude') {
              eval 'use App::Rad::Exclude; App::Rad::Exclude->load($c)';
              Carp::croak 'error loading "exclude" extension.' if ($@);
          }
          elsif ($_ eq 'debug') {
              $c->{'debug'} = 1;
          }
          else {
          	$c->load_plugin($_);
          }
  	}
  	
      # tiny cheat to avoid doing a lot of processing
      # when not in debug mode. If needed, I'll create
      # an actual is_debugging() method or something
      if ($c->{'debug'}) {
          $c->debug('initializing: default commands are: '
              . join ( ', ', $c->commands() )
          );
      }
  }
  
  sub import {
      my $class = shift;
      @OPTIONS  = @_;
  }
  
  sub load_plugin {
      my $c      = shift;
      my $plugin = shift;
  	my $class  = ref $c;
  
      my $plugin_fullname = '';    
  	if ($plugin =~ s{^\+}{} ) {
  		$plugin_fullname = $plugin;
  	}
      else {
          $plugin_fullname = "App::Rad::Plugin::$plugin";
      }
  	eval "use $plugin_fullname ()";
      Carp::croak "error loading plugin '$plugin_fullname': $@\n"
          if $@;
      my %methods = _get_subs_from($plugin_fullname);
  
      Carp::croak "No methods found for plugin '$plugin_fullname'\n"
  		unless keys %methods > 0;
  
  	no strict 'refs';
  	foreach my $method (keys %methods) {
          # don't add plugin's internal methods
          next if substr ($method, 0, 1) eq '_';
  
  		*{"$class\::$method"} = $methods{$method};
  		$c->debug("-- method '$method' added [$plugin_fullname]");
  
          # fill $c->plugins()
          push @{ $c->{'_plugins'} }, $plugin;
  	}
  }
  
  # this function browses a file's
  # symbol table (usually 'main') and maps
  # each function to a hash
  #
  # FIXME: if I create a sub here (Rad.pm) and
  # there is a global variable with that same name
  # inside the user's program (e.g.: sub ARGV {}),
  # the name will appear here as a command. It really 
  # shouldn't...
  sub _get_subs_from {
      my $package = shift || 'main';
      $package .= '::';
      
      my %subs = ();
  
      no strict 'refs';
      while (my ($key, $value) = ( each %{*{$package}} )) {
          local (*SYMBOL) = $value;
          if ( defined $value && defined *SYMBOL{CODE} ) {
              $subs{$key} = $value;
          }
      }
      return %subs;
  }
  
  
  # overrides our pre-defined control
  # functions with any available
  # user-defined ones
  sub _register_functions {
      my $c = shift;
      my %subs = _get_subs_from('main');
  
      # replaces only if the function is
      # in 'default', 'pre_process' or 'post_process'
      foreach ( keys %{$c->{'_functions'}} ) {
          if ( defined $subs{$_} ) {
              $c->debug("overriding $_ with user-defined function.");
              $c->{'_functions'}->{$_} = $subs{$_};
          }
      }
  }
  
  # retrieves command line arguments
  # to be executed by the main program
  sub _get_input {
      my $c = shift;
  
      my $cmd = (defined ($ARGV[0]) and substr($ARGV[0], 0, 1) ne '-')
              ? shift @ARGV
              : ''
              ;
  
      @{$c->argv} = @ARGV;
      $c->{'cmd'} = $cmd;
  
      $c->debug('received command: ' . $c->{'cmd'});
      $c->debug('received parameters: ' . join (' ', @{$c->argv} ));
  
      $c->_tinygetopt();
  }
  
  # stores arguments passed to a
  # command via --param[=value] or -p
  sub _tinygetopt {
      my $c = shift;
  
      my @argv = ();
      foreach ( @{$c->argv} ) {
  
          # single option (could be grouped)
          if ( m/^\-([^\-\=]+)$/o) {
              my @args = split //, $1;
              foreach (@args) {
  				if ($c->options->{$_}) {
  					$c->options->{$_}++;
  				}
  				else {
  					$c->options->{$_} = 1;
  				}
              }
          }
          # long option: --name or --name=value
          elsif (m/^\-\-([^\-\=]+)(?:\=(.+))?$/o) {
              $c->options->{$1} = defined $2 ? $2 
  			                  : 1
                                ;
          }
          else {
              push @argv, $_;
          }
      }
      @{$c->argv} = @argv;
  }
  
  
  #========================#
  #     PUBLIC METHODS     #
  #========================#
  
  sub load_config {
      require App::Rad::Config;
      App::Rad::Config::load_config(@_);
  }
  
  
  #TODO: this code probably could use some optimization
  sub register_commands {
      my $c = shift;
      my %help_for_sub = ();
      my %rules = ();
  
      # process parameters
      foreach my $item (@_) {
          if ( ref ($item) ) {
              Carp::croak '"register_commands" may receive only HASH references'
                  unless ref ($item) eq 'HASH';
              foreach my $params (keys %{$item}) {
                  if ($params eq '-ignore_prefix'
                   or $params eq '-ignore_suffix'
                   or $params eq '-ignore_regexp'
                  ) {
                      $rules{$params} = $item->{$params};
                  }
                  else {
                      $help_for_sub{$params} = $item->{$params};
                  }
              }
          }
          else {
              $help_for_sub{$item} = undef; # no help text
          }
      }
  
      my %subs = _get_subs_from('main');
  
      foreach (keys %help_for_sub) {
  
          # we only add the sub to the commands
          # list if it's *not* a control function
          if ( not defined $c->{'_functions'}->{$_} ) {
  
              # user want to register a valid (existant) sub
              if ( exists $subs{$_} ) {
                  $c->debug("registering $_ as a command.");
                  $c->{'_commands'}->{$_}->{'code'} = $subs{$_};
                  App::Rad::Help->register_help($c, $_, $help_for_sub{$_});
              }
              else {
                  Carp::croak "'$_' does not appear to be a valid sub. Registering seems impossible.\n";
              }
          }
      }
  
      # no parameters, or params+rules: try to register everything
      if ((!%help_for_sub) or %rules) {
          foreach my $subname (keys %subs) {
  
              # we only add the sub to the commands
              # list if it's *not* a control function
              if ( not defined $c->{'_functions'}->{$subname} ) {
  
                  if ( $rules{'-ignore_prefix'} ) {  
                      next if ( substr ($subname, 0, length($rules{'-ignore_prefix'}))
                             eq $rules{'-ignore_prefix'}
                              );
                  }
                  if ( $rules{'-ignore_suffix'} ) {
                      next if ( substr ($subname, 
                                        length($subname) - length($rules{'-ignore_suffix'}),
                                        length($rules{'-ignore_suffix'})
                                       )
                                eq $rules{'-ignore_suffix'}
                              );
                  }
                  if ( $rules{'-ignore_regexp'} ) {
                      my $re = $rules{'-ignore_regexp'};
                      next if $subname =~ m/$re/o;
                  }
  
                  # avoid duplicate registration
                  if ( !exists $help_for_sub{$subname} ) {
                      $c->{'_commands'}->{$subname}->{'code'} = $subs{$subname};
                      App::Rad::Help->register_help($c, $subname, undef);
                  }
              }
          }
      }
  }
  
  
  sub register_command { return register(@_) }
  sub register {
      my ($c, $command_name, $coderef, $helptext) = @_;
      $c->debug("got: " . ref $coderef);
      return undef
          unless ( (ref $coderef) eq 'CODE' );
  
      $c->debug("registering $command_name as a command.");
      $c->{'_commands'}->{$command_name}->{'code'} = $coderef;
      App::Rad::Help->register_help($c, $command_name, $helptext);
      return $command_name;
  }
  
  sub unregister_command { return unregister(@_) }
  sub unregister {
      my ($c, $command_name) = @_;
  
      if ( $c->{'_commands'}->{$command_name} ) {
          delete $c->{'_commands'}->{$command_name};
      }
      else {
          return undef;
      }
  }
  
  
  sub create_command_name {
      my $id = 0;
      foreach (commands()) {
          if ( m/^cmd(\d+)$/ ) {
              $id = $1 if ($1 > $id);
          }
      }
      return 'cmd' . ($id + 1);
  }
  
  
  sub commands {
      return ( keys %{$_[0]->{'_commands'}} );
  }
  
  
  sub is_command {
      my ($c, $cmd) = @_;
      return (defined $c->{'_commands'}->{$cmd}
              ? 1
              : 0
             );
  }
  
  sub command :lvalue { cmd(@_) }
  sub cmd :lvalue {
      $_[0]->{'cmd'};
  }
  
  
  sub run {
      my $class = shift;
      my $c = {};
      bless $c, $class;
  
      $c->_init();
  
      # first we update the control functions
      # with any overriden value
      $c->_register_functions();
  
      # then we run the setup to register
      # some commands
      $c->{'_functions'}->{'setup'}->($c);
  
      # now we get the actual input from
      # the command line (someone using the app!)
      $c->_get_input();
  
      # run the specified command
      $c->execute();
  
      # that's it. Tear down everything and go home :)
      $c->{'_functions'}->{'teardown'}->($c);
  
      return 0;
  }
  
  # run operations 
  # in a shell-like environment
  #sub shell {
  #    my $class = shift;
  #    App::Rad::Shell::shell($class);
  #}
  
  sub execute {
      my ($c, $cmd) = @_;
  
      # given command has precedence
      if ($cmd) {
          $c->{'cmd'} = $cmd;
      }
      else {
          $cmd = $c->{'cmd'};  # now $cmd always has the called cmd
      }
  
      $c->debug('calling pre_process function...');
      $c->{'_functions'}->{'pre_process'}->($c);
  
      $c->debug("executing '$cmd'...");
  
      # valid command, run it
      if ($c->is_command($c->{'cmd'}) ) {
          $c->{'output'} = $c->{'_commands'}->{$cmd}->{'code'}->($c);
      }
      # no command, run default()
      elsif ( $cmd eq '' ) {
          $c->debug('no command detected. Falling to default');
          $c->{'output'} = $c->{'_functions'}->{'default'}->($c);
      }
      # invalid command, run invalid()
      else {
          $c->debug("'$cmd' is not a valid command. Falling to invalid.");
          $c->{'output'} = $c->{'_functions'}->{'invalid'}->($c);
      }
  
      # 3: post-process the result
      # from the command
      $c->debug('calling post_process function...');
      $c->{'_functions'}->{'post_process'}->($c);
  
      $c->debug('reseting output');
      $c->{'output'} = undef;
  }
  
  sub argv    { return $_[0]->{'_ARGV'}     }
  sub options { return $_[0]->{'_options'} }
  sub stash   { return $_[0]->{'_stash'}   }   
  sub config  { return $_[0]->{'_config'}  }
  
  # $c->plugins is sort of "read-only" externally
  sub plugins { 
      my @plugins = @{$_[0]->{'_plugins'}};
      return @plugins;
  }
  
  
  sub getopt {
      require Getopt::Long;
      Carp::croak "Getopt::Long needs to be version 2.36 or above"
          unless $Getopt::Long::VERSION >= 2.36;
  
      my ($c, @options) = @_;
  
      # reset values from tinygetopt
      $c->{'_options'} = {};
  
      my $parser = new Getopt::Long::Parser;
      $parser->configure( qw(bundling) );
  
      my @tARGV = @ARGV; # we gotta stick to our API
      my $ret = $parser->getoptions($c->{'_options'}, @options);
      @{$c->argv} = @ARGV;
      @ARGV = @tARGV;
  
      return $ret;
  }
  
  sub debug {
      if (shift->{'debug'}) {
          print "[debug]   @_\n";
      }
  }
  
  # gets/sets the output (returned value)
  # of a command, to be post processed
  sub output {
      my ($c, @msg) = @_;
      if (@msg) {
          $c->{'output'} = join(' ', @msg);
      }
      else {
          return $c->{'output'};
      }
  }
  
  
  #=========================#
  #     CONTROL FUNCTIONS   #
  #=========================#
  
  sub setup { $_[0]->register_commands( {-ignore_prefix => '_'} ) }
  
  sub teardown {}
  
  sub pre_process {}
  
  sub post_process {
      my $c = shift;
  
      if ($c->output()) {
          print $c->output() . $/;
      }
  }
  
  
  sub default {
      my $c = shift;
      return $c->{'_commands'}->{'help'}->{'code'}->($c);
  }
  
  
  sub invalid {
      my $c = shift;
      return $c->{'_functions'}->{'default'}->($c);
  }
  
  
  }
  42; # ...and thus ends thy module  ;)
  __END__
  
  =head1 NAME
  
  App::Rad - Rapid (and easy!) creation of command line applications
  
  =head1 VERSION
  
  Version 1.04
  
  =head1 SYNOPSIS
  
  This is your smallest working application (let's call it I<myapp.pl>)
  
      use App::Rad;
      App::Rad->run();
  
  That's it, your program already works and you can use it directly via the command line (try it!)
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          help    show syntax and available commands
  
  Next, start creating your own functions (e.g.) inside I<myapp.pl>:
  
      sub hello {
          return "Hello, World!";
      }
  
  And now your simple command line program I<myapp.pl> has a 'hello' command!
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          hello
          help    show syntax and available commands
  
  
     [user@host]$ ./myapp.pl hello
     Hello, World!
  
  You could easily add a customized help message for your command through the 'Help()' attribute:
  
      sub hello 
      :Help(give a nice compliment)
      {
          return "Hello, World!";
      }
  
  And then, as expected:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          hello   give a nice compliment
          help    show syntax and available commands
  
  
  App::Rad also lets you expand your applications, providing a lot of flexibility for every command, with embedded help, argument and options parsing, configuration file, default behavior, and much more:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup {
          my $c = shift;
  
          $c->register_commands( {
                  foo => 'expand your foo!',
                  bar => 'have a drink! arguments: --drink=DRINK',
              });
      }
  
      sub foo {
          my $c = shift;
          $c->load_config('myapp.conf');
  
          return 'foo expanded to ' . baz() * $c->config->{'myfoo'};
      }
  
      # note that 'baz' was not registered as a command,
      # so it can't be called from the outside.
      sub baz { rand(10) }
  
      sub bar {
          my $c = shift;
          if ( $c->options->{'drink'} ) {
              return 'you asked for a ' . $c->options->{'drink'};
          }
          else {
              return 'you need to ask for a drink';
          }
      }
  
          
  
  You can try on the command line:
  
     [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          bar 	have a drink! arguments: --drink=DRINK
          foo 	expand your foo!
          help	show syntax and available commands
  
  
     [user@host]$ ./myapp.pl bar --drink=martini
      you asked for a martini
  
  
  =head1 WARNING
  
  This module is very young, likely to change in strange ways and to have some bugs (please report if you find any!). I will try to keep the API stable, but even that is subject to change (let me know if you find anything annoying or have a wishlist). You have been warned!
  
  
  =head1 DESCRIPTION
  
  App::Rad aims to be a simple yet powerful framework for developing your command-line applications. It can easily transform your Perl I<one-liners> into reusable subroutines than can be called directly by the user of your program.
  
  It also tries to provide a handy interface for your common command-line tasks. B<If you have a feature request to easen out your tasks even more, please drop me an email or a RT feature request.>
  
  =head2 Extending App::Rad - Plugins!
  
  App::Rad plugins can be loaded by naming them as arguments to the C<< use App::Rad >> statement. Just ommit the C<< App::Rad::Plugin >> prefix from the plugin name. For example:
  
     use App::Rad  qw(My::Module);
  
  will load the C<< App::Rad::Plugin::My::Module >> plugin for you!
  
  Developers are B<strongly> encouraged to publish their App::Rad plugins under the C<< App::Rad::Plugin >> namespace. But, if your plugin start with a name other than that, you can fully qualify the name by using an unary plus sign:
  
    use App::Rad  qw(
            My::Module
            +Fully::Qualified::Plugin::Name
    );
  
  Note that plugins are loaded in the order in which they appear.
  
  B<Please refer to the actual plugin documentation for specific usage>. And check out L<< App::Rad::Plugin >> if you want to create your own plugins.
  
  
  =head1 INSTANTIATION
  
  These are the main execution calls for the application. In your App::Rad programs, the B<*ONLY*> thing your script needs to actually (and actively) call is one of the instantiation (or dispatcher) methods. Leave all the rest to your subs. Currently, the only available dispatcher is run():
  
  =head2 run()
  
  You'll be able to access all of your program's commands directly through the command line, as shown in the synopsis.
  
  
  =head1 BUILT-IN COMMANDS
  
  This module comes with the following default commands. You are free to override them as you see fit.
  
  
  =head2 help
  
  Shows help information for your program. This built-in function displays the program name and all available commands (including the ones you added yourself) if a user types the 'help' command, or no command at all, or any command that does not exist (as they'd fall into the 'default' control function which (by default) calls 'help').
  
  You can also display specific embedded help for your commands, either explicitly registering them with C<< $c->register() >> or C<< $c->register_commands() >> inside C<< $c->setup() >> (see respective sections below) or with the Help() attribute:
  
      use App::Rad;
      App::Rad->run();
      
      sub mycmd 
      :Help(display a nice welcome message) 
      {
          return "Welcome!";
      }
  
  the associated help text would go like this:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
  
      Available Commands:
          help 	show syntax and available commands
          mycmd	display a nice welcome message
      
  
  =head1 OTHER BUILT IN COMMANDS (OPT-IN)
  
  The 'include' and 'exclude' commands below let the user include and exclude commands to your program and, as this might be dangerous when the user is not yourself, you have to opt-in on them:
  
     use App::Rad qw(include);  # add the 'include' command
     use App::Rad qw(exclude);  # add the 'exclude' command
  
  though you'll probably want to set them both:
  
     use App::Rad qw(include exclude);
  
  
  =head2 include I<[command_name]> I<-perl_params> I<'your subroutine code'>
  
  Includes the given subroutine into your program on-the-fly, just as you would writing it directly into your program.
  
  Let's say you have your simple I<'myapp.pl'> program that uses App::Rad sitting on your system quietly. One day, perhaps during your sysadmin's tasks, you create a really amazing one-liner to solve a really hairy problem, and want to keep it for posterity (reusability is always a good thing!). 
  
  For instance, to change a CSV file in place, adding a column on position #2 containing the line number, you might do something like this (this is merely illustrative, it's not actually the best way to do it):
  
      $ perl -i -paF, -le 'splice @F,1,0,$.; $_=join ",",@F' somesheet.csv
  
  And you just found out that you might use this other times. What do you do? App::Rad to the rescue!
  
  In the one-liner above, just switch I<'perl'> to I<'myapp.pl include SUBNAME'> and remove the trailing parameters (I<somesheet.csv>):
  
      $ myapp.pl include addcsvcol -i -paF, -le 'splice @F,1,0,$.; $_=join ",",@F'
  
  That's it! Now myapp.pl has the 'addcsvcol' command (granted, not the best name) and you can call it directly whenever you want:
  
      $ myapp.pl addcsvcol somesheet.csv
  
  App::Rad not only transforms and adjusts your one-liner so it can be used inside your program, but also automatically formats it with Perl::Tidy (if you have it). This is what the one-liner above would look like inside your program:
  
      sub addcsvcol {
          my $c = shift;
      
          local ($^I) = "";
          local ($/)  = "\n";
          local ($\)  = "\n";
        LINE: while ( defined( $_ = <ARGV> ) ) {
              chomp $_;
              our (@F) = split( /,/, $_, 0 );
              splice @F, 1, 0, $.;
              $_ = join( ',', @F );
          }
          continue {
              die "-p destination: $!\n" unless print $_;
          }
      }
  
  With so many arguments (-i, -p, -a -F,, -l -e), this is about as bad as it gets. And still one might find this way easier to document and mantain than a crude one-liner stored in your ~/.bash_history or similar.
  
  B<Note:> If you don't supply a name for your command, App::Rad will make one up for you (cmd1, cmd2, ...). But don't do that, as you'll have a hard time figuring out what that specific command does.
  
  B<Another Note: App::Rad tries to adjust the command to its interface, but please keep in mind this module is still in its early stages so it's not guaranteed to work every time. *PLEASE* let me know via email or RT bug request if your one-liner was not correctly translated into an App::Rad command. Thanks!>
  
  
  =head2 exclude I<command_name>
  
  Removes the requested function from your program. Note that this will delete the actual code from your program, so be *extra* careful. It is strongly recommended that you do not use this command and either remove the subroutine yourself or add the function to your excluded list inside I<setup()>.
  
  Note that built-in commands such as 'help' cannot be removed via I<exclude>. They have to be added to your excluded list inside I<setup()>.
  
  
  
  =head1 ROLLING YOUR OWN COMMANDS
  
  Creating a new command is as easy as writing any sub inside your program. Some names ("setup", "default", "invalid", "pre_process", "post_process" and "teardown") are reserved for special purposes (see the I<Control Functions> section of this document). App::Rad provides a nice interface for reading command line input and writing formatted output:
  
  
  =head2 The Controller
  
  Every command (sub) you create receives the controller object "C<< $c >>" (sometimes referred as "C<< $self >>" in other projects) as an argument. The controller is the main interface to App::Rad and has several methods to easen your command manipulation and execution tasks.
  
  
  =head2 Reading arguments
  
  When someone types in a command, she may pass some arguments to it. Those arguments can be accessed in four different ways, depending on what you want. This way it's up to you to control which and how many arguments (if at all) you want to receive and/or use. They are:
  
  =head3 @ARGV
  
  Perl's @ARGV array has all the arguments passed to your command, without the command name (use C<< $c->cmd >> for this) and without any processing (even if you explicitly use C<< $c->getopt >>, which will change $c->argv instead, see below). Since the command itself won't be in the @ARGV parameters, you can use it in each command as if they were stand-alone programs.
  
  =head3 $c->options
  
  App::Rad lets you automatically retrieve any POSIX syntax command line options (I<getopt-style>) passed to your command via the $c->options method. This method returns a hash reference with keys as given parameters and values as... well... values. The 'options' method automatically supports two simple argument structures:
  
  Extended (long) option. Translates C<< --parameter or --parameter=value >> into C<< $c->options->{parameter} >>. If no value is supplied, it will be set to 1.
  
  Single-letter option. Translates C<< -p >> into C<< $c->options->{p} >>.
  
  Single-letter options can be nested together, so C<-abc> will be parsed into C<< $c->options->{a} >>, C<< $c->options->{b} >> and C<< $c->options{c} >>, while C<--abc> will be parsed into C<< $c->options->{abc} >>. We could, for instance, create a dice-rolling command like this:
  
      sub roll {
          my $c = shift;
  
          my $value = 0;
          for ( 1..$c->options->{'times'} ) {
              $value += ( int(rand ($c->options->{'faces'}) + 1));
          }
          return $value;
      }
  
  And now you can call your 'roll' command like:
  
      [user@host]$ ./myapp.pl roll --faces=6 --times=2
  
  Note that App::Rad does not control which arguments can or cannot be passed: they are all parsed into C<< $c->options >> and it's up to you to use whichever you want. For a more advanced use and control, see the C<< $c->getopt >> method below.
  
  Also note that single-letter options will be set to 1. However, if a user types them more than once, the value will be incremented accordingly. For example, if a user calls your program like so:
  
     [user@host]$ ./myapp.pl some_command -vvv
  
  or
  
     [user@host]$ ./myapp.pl some_command -v -v -v
  
  then, in both cases, C<< $c->options->{v} >> will be set to 3. This will let you easily keep track of how many times any given option was chosen, and still let you just check for definedness if you don't care about that. 
  
  
  =head3 $c->argv
  
  The array reference C<< $c->argv >> contains every argument passed to your command that have B<not> been parsed into C<< $c->options >>. This is usually a list of every provided argument that didn't start with a dash (-), unless you've called C<< $c->getopt >> and used something like 'param=s' (again, see below).
  
  =head3 $c->getopt (Advanced Getopt usage)
  
  App::Rad is also smoothly integrated with Getopt::Long, so you can have even more flexibility and power while parsing your command's arguments, such as aliases and types. Call the C<< $c->getopt() >> method anytime inside your commands (or just once in your "pre_process" function to always have the same interface) passing a simple array with your options, and refer back to $c->options to see them. For instance: 
  
      sub roll {
          my $c = shift;
  
          $c->getopt( 'faces|f=i', 'times|t=i' )
              or $c->execute('usage') and return undef;
  
          # and now you have $c->options->{'faces'} 
          # and $c->options->{'times'} just like above.
      }
  
  This becomes very handy for complex or feature-rich commands. Please refer to the Getopt::Long module for more usage examples.
  
  
  B<< So, in order to manipulate and use any arguments, remember: >>
  
  =over 6
  
  =item * The given command name does not appear in the argument list;
  
  =item * All given arguments are in C<< @ARGV >>
  
  =item * Automatically processed arguments are in C<< $c->options >>
  
  =item * Non-processed arguments (the ones C<< $c->options >> didn't catch) are in $c->argv
  
  =item * You can use C<< $c->getopt >> to have C<< Getopt::Long >> parse your arguments (it will B<not> change C<< @ARGV >>)
  
  =back
  
  
  =head2 Sharing Data: C<< $c->stash >>
  
  The "stash" is a universal hash for storing data among your Commands:
  
      $c->stash->{foo} = 'bar';
      $c->stash->{herculoids} = [ qw(igoo tundro zok gloop gleep) ];
      $c->stash->{application} = { name => 'My Application' };
  
  You can use it for more granularity and control over your program. For instance, you can email the output of a command if (and only if) something happened:
  
      sub command {
          my $c = shift;
          my $ret = do_something();
  
          if ( $ret =~ /critical error/ ) {
              $c->stash->{mail} = 1;
          }
          return $ret;
      }
  
      sub post_process {
          my $c = shift;
  
          if ( $c->stash->{mail} ) {
              # send email alert...
          }
          else {
              print $c->output . "\n";
          }
      }
  
  
  
  =head2 Returning output
  
  Once you're through, return whatever you want to give as output for your command:
  
      my $ret = "Here's the list: ";
      $ret .= join ', ', 1..5;
      return $ret;
      
      # this prints "Here's the list: 1, 2, 3, 4, 5"
  
  App::Rad lets you post-process the returned value of every command, so refrain from printing to STDOUT directly whenever possible as it will give much more power to your programs. See the I<post_process()> control function further below in this document.
  
  
  =head1 HELPER METHODS
  
  App::Rad's controller comes with several methods to help you manage your application easily. B<If you can think of any other useful command that is not here, please drop me a line or RT request>.
  
  
  =head2 $c->execute( I<COMMAND_NAME> )
  
  Runs the given command. If no command is given, runs the one stored in C<< $c->cmd >>. If the command does not exist, the 'default' command is ran instead. Each I<execute()> call also invokes pre_process and post_process, so you can easily manipulate income and outcome of every command.
  
  
  =head2 $c->cmd
  
  Returns a string containing the name of the command (that is, the first argument of your program), that will be called right after pre_process.
  
  
  =head3 $c->command
  
  Alias for C<< $c->cmd >>. This longer form is discouraged and may be removed in future versions, as one may confuse it with the C<< $c->commands() >> method, explained below. You have been warned.
  
  
  =head2 $c->commands()
  
  Returns a list of available commands (I<functions>) inside your program
  
  
  =head2 $c->is_command ( I<COMMAND_NAME> )
  
  Returns 1 (true) if the given I<COMMAND_NAME> is available, 0 (false) otherwise.
  
  
  =head2 $c->create_command_name()
  
  Returns a valid name for a command (i.e. a name slot that's not been used by your program). This goes in the form of 'cmd1', 'cmd2', etc., so don't use unless you absolutely have to. App::Rad, for instance, uses this whenever you try to I<include> (see below) a new command but do not supply a name for it.
  
  
  =head2 $c->load_config( I<< FILE (FILE2, FILE3, ...) >> )
  
  This method lets you easily load into your program one or more configuration files written like this:
  
      # comments and blank lines are discarded
      key1 value1
      key2:value2
      key3=value3
      key5           # stand-alone attribute (and inline-comment)
  
  
  =head2 $c->config
  
  Returns a hash reference with any loaded config values (see C<< $c->load_config() >> above).
  
  
  =head2 $c->register ( I<NAME>, I<CODEREF> [, I<INLINE_HELP> ])
  
  Registers a coderef as a callable command. Note that you don't have to call this in order to register a sub inside your program as a command, run() will already do this for you - and if you don't want some subroutines to be issued as commands you can always use C<< $c->register_commands() >> (note the plural) inside setup(). This is just an interface to dinamically include commands in your programs. The function returns the command name in case of success, undef otherwise.
  
  It is also very useful for creating aliases for your commands:
  
      sub setup {
          my $c = shift;
          $c->register_commands();
  
          $c->register('myalias', \&command);
      }
  
      sub command { return "Hi!" }
  
  and, on the command line:
  
      [user@host]$ ./myapp.pl command
      Hi!
  
      [user@host]@ ./myapp.pl myalias
      Hi!
  
  The last parameter is optional and lets you add inline help to your command:
  
      $c->register('cmd_name', \&cmd_func, 'display secret of life');
  
  =head3 $c->register_command ( I<NAME>, I<CODEREF> [, I<INLINE_HELP> ] )
  
  Longer alias for C<< $c->register() >>. It's use is disencouraged as one may confuse it with C<register_commands> (note the plural) below. Plus you type more :)
  As such, this method may be removed in future versions. You have been warned!
  
  =head2 $c->register_commands()
  
  This method, usually called during setup(), tells App::Rad to register subroutines as valid commands. If called without any parameters, it will register B<all> subroutines in your main program as valid commands (note that the default behavior of App::Rad is to ignore subroutines starting with an underscore '_'). You can easily change this behavior using some of the options below:
  
  =head3 Adding single commands
  
      $c->register_commands( qw/foo bar baz/ );
  
  The code above will register B<only> the subs C<foo>, C<bar> and C<baz> as commands. Other subroutines will B<not> be valid commands, so they can be used as internal subs for your program. You can change this behavior with the bundled options - see 'Adding several commands' and 'Putting it all together' below.
  
  =head3 Adding single commands (with inline help)
  
      $c->register_commands(
              {
                  dos2unix => 'convert text files from DOS to Unix format',
                  unix2dos => 'convert text files from Unix to DOS format',
              }
      );
  
  You can pass a hash reference containing commands as keys and a small help string as their values. The code above will register B<only> the subs C<dos2unix> and C<unix2dos>, and the default help for your program will become something like this:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          dos2unix    convert text files from DOS to Unix format
          help        show syntax and available commands
          unix2dos    convert text files from Unix to DOS format
  
  
  =head3 Adding several commands
  
  You can pass a hash reference as an argument, letting you choose which subroutines to add as commands. The following keys may be used (note the dash preceding each key):
  
  =over 4
  
  =item * C<< -ignore_prefix >>: subroutine names starting with the given string won't be added as commands
  
  =item * C<< -ignore_suffix >>: subroutine names ending with the given string won't be added as commands
  
  =item * C<< -ignore_regexp >>: subroutine names matching the given regular expression (as a string) won't be added as commands
  
  =back
  
  For example:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup { 
          my $c = shift; 
          $c->register_commands( { -ignore_prefix => '_' } );
      }
  
      sub foo  {}  # will become a command
      sub bar  {}  # will become a command
      sub _baz {}  # will *NOT* become a command
  
  This way you can easily segregate between commands and helper functions, making your code even more reusable without jeopardizing the command line interface (As of version 1.04, ignoring commands with underscore '_' prefixes is also the default App::Rad behavior).
  
  
  =head3 Putting it all together
  
  You can combine some of the options above to have even more flexibility:
  
      $c->register_commands(
              'foo',
              { -ignore_suffix => 'foo' },
              { bar => 'all your command line are belong to us' },
      );
  
  The code above will register as commands all subs with names B<not> ending in 'foo', but it B<will> register the 'foo' sub as well. It will also give the 'bar' command the help string. This behavior is handy for registering several commands and having a few exceptions, or to add your commands and only have inline help for a few of them (as you see fit).
  
  You don't have to worry about the order of your elements passed, App::Rad will figure them out for you in a DWIM fashion.
  
      # this does the same as the code above
      $c->register_commands(
              { bar => 'all your command line are belong to us' },
              'foo',
              { -ignore_suffix => 'foo' },
      );
  
  You can even bundle the hash reference to include your C<< cmd => help >> and special keys:
  
      # this behaves the same way as the code above:
      $c->register_commands(
          'foo',
          { 
              -ignore_suffix => 'foo',
              bar => 'all your command line are belong to us',
          }
      );
  
  
  =head2 $c->unregister_command ( I<NAME> )
  
  Longer alias for C<< $c->unregister() >>. The use of the shorter form is encouraged, and this alias may be removed in future versions. You have been warned.
  
  
  =head3 $c->unregister ( I<NAME> )
  
  Unregisters a given command name so it's not available anymore. Note that the subroutine will still be there to be called from inside your program - it just won't be accessible via command line anymore.
  
  
  =head2 $c->debug( I<MESSAGE> )
  
  Will print the given message on screen only if the debug flag is enabled:
  
      use App::Rad  qw( debug );
  
  Note that, if debug is enabled, App::Rad itself will print several debug messages stating its current flow, so you can easily find out where everything is happening.
  
  
  =head2 $c->plugins()
  
  Returns a list of all loaded plugins, in the order in which they were loaded.
  
  
  =head2 $c->load_plugin( I<PLUGIN NAME> )
  
  This method will dinamically load the given plugin. The plugin needs to be under the C<< App::Rad::Plugin >> namespace, and the name should be relative to this path (i.e. $c->load_plugin('MyPlugin') will try to load 'App::Rad::Plugin::MyPlugin'). If you want to load a plugin by its fully qualified name, you need to prepend a plus sign to the name ('+Fully::Qualified::Plugin::Name'). B<This is an internal method> and you really should refrain from using it. Instead, plugins should be loaded as parameters to the C<< use App::Rad >> statement, as explained above.
  
  
  =head1 CONTROL FUNCTIONS (to possibly override)
  
  App::Rad implements some control functions which are expected to be overridden by implementing them in your program. They are as follows:
  
  =head2 setup()
  
  This function is responsible for setting up what your program can and cannot do, plus everything you need to set before actually running any command (connecting to a database or host, check and validate things, download a document, whatever). Note that, if you override setup(), you B<< *must* >> call C<< $c->register_commands() >> or at least C<< $c->register() >> so your subs are classified as valid commands (check $c->register_commands() above for more information).
  
  Another interesting thing you can do with setup is to manipulate the command list. For instance, you may want to be able to use the C<include> and C<exclude> commands, but not let them available for all users. So instead of writing:
  
      use App::Rad qw(include exclude);
      App::Rad->run();
  
  you can write something like this:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup {
          my $c = shift;
          $c->register_commands();
  
          # EUID is 'root'
          if ( $> == 0 ) {
              $c->register('include', \&App::Rad::include);
              $c->register('exclude', \&App::Rad::exclude);
          }
      }
  
  to get something like this:
  
      [user@host]$ myapp.pl help
      Usage: myapp.pl command [arguments]
  
      Available Commands:
         help
  
      [user@host]$ sudo myapp.pl help
      Usage: myapp.pl command [arguments]
  
      Available Commands:
         exclude
         help
         include
  
  
  
  =head2 default()
  
  If no command is given to your application, it will fall in here. Please note that invalid (non-existant) command will fall here too, but you can change this behavior with the invalid() function below (although usually you don't want to).
  
  Default's default (grin) is just an alias for the help command.
  
      sub default {
          my $c = shift;
  
          # will fall here if the given
          # command isn't valid.
      }
  
  You are free (and encouraged) to change the default behavior to whatever you want. This is rather useful for when your program will only do one thing, and as such it receives only parameters instead of command names. In those cases, use the "C<< default() >>" sub as your main program's sub and parse the parameters with C<< $c->argv >> and C<< $c->getopt >> as you would in any other command.
  
  =head2 invalid()
  
  This is a special function to provide even more flexibility while creating your command line applications. This is called when the user requests a command that does not exist. The built-in C<< invalid() >> will simply redirect itself to C<< default() >> (see above), so usually you just have to worry about this when you want to differentiate between "no command given" (with or without getopt-like arguments) and "invalid command given" (with or without getopt-like arguments).
  
  =head2 teardown()
  
  If implemented, this function is called automatically after your application runs. It can be used to clean up after your operations, removing temporary files, disconnecting a database connection established in the setup function, logging, sending data over a network, or even storing state information via Storable or whatever.
  
  
  =head2 pre_process()
  
  If implemented, this function is called automatically right before the actual wanted command is called. This way you have an optional pre-run hook, which permits functionality to be added, such as preventing some commands to be run from a specific uid (e.g. I<root>): 
  
      sub pre_process {
          my $c = shift;
  
          if ( $c->cmd eq 'some_command' and $> != 0 ) {
              $c->cmd = 'default'; # or some standard error message
          }
      }
      
  
  =head2 post_process()
  
  If implemented, this function is called automatically right after the requested function returned. It receives the Controller object right after a given command has been executed (and hopefully with some output returned), so you can manipulate it at will. In fact, the default "post_process" function is as goes:
  
      sub post_process {
          my $c = shift;
  
          if ( $c->output() ) {
              print $c->output() . "\n";
          }
      }
  
  You can override this function to include a default header/footer for your programs (either a label or perhaps a "Content-type: " string), parse the output in any ways you see fit (CPAN is your friend, as usual), etc.
  
  
  
  =head1 IMPORTANT NOTE ON PRINTING INSIDE YOUR COMMANDS
  
  B<The post_process() function above is why your application should *NEVER* print to STDOUT>. Using I<print> (or I<say>, in 5.10) to send output to STDOUT is exclusively the domain of the post_process() function. Breaking this rule is a common source of errors. If you want your functions to be interactive (for instance) and print everything themselves, you should disable post-processing in setup(), or create an empty post_process function or make your functions return I<undef> (so I<post_process()> will only add a blank line to the output).
  
  
  =head1 DIAGNOSTICS
  
  If you see a '1' printed on the screen after a command is issued, it's probably because that command is returning a "true" value instead of an output string. If you don't want to return the command output for post processing(you'll loose some nice features, though) you can return undef or make post_process() empty.
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  App::Rad requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  App::Rad depends only on 5.8 core modules (Carp for errors, Getopt::Long for "$c->getopt", Attribute::Handlers for "help" and O/B::Deparse for the "include" command).
  
  If you have Perl::Tidy installed, the "include" command will tidy up your code before inclusion.
  
  The test suite depends on Test::More, FindBin and File::Temp, also core modules.
  
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  
  =head1 BUGS AND LIMITATIONS
  
  Please report any bugs or feature requests to 
  C<bug-app-easy at rt.cpan.org>, or through the web interface at 
  L<http://rt.cpan.org/garu/ReportBug.html?Queue=App-Rad>.  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
  
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc App::Rad
  
  Although this Module comes without any warraties whatsoever (see DISCLAIMER below), I try really hard to provide some quality assurance for the users. This means I not only try to close all reported bugs in the minimum amount of time but I also try to find some on my own.
  
  This version of App::Rad comes with 183 tests and I keep my eye constantly on CPAN Testers L<http://www.cpantesters.org/show/App-Rad.html> to ensure it passes all of them, in all platforms. You can send me your own App::Rad tests if you feel I'm missing something and I'll hapilly add them to the distribution.
  
  Since I take user's feedback very seriously, I really hope you send me any wishlist/TODO you'd like App::Rad to have (please try to send them via RT so other people can give their own suggestions).
  
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/garu/Bugs.html?Dist=App-Rad>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/App-Rad>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/App-Rad>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/App-Rad>
  
  =back
  
  =head2 IRC
  
     #app-rad  on irc.perl.org
  
  
  =head1 TODO
  
  This is a small list of features I plan to add in the near future (in no particular order). Feel free to contribute with your wishlist and comentaries!
  
  =over 4
  
  =item * Shell-like environment
  
  =item * Loadable commands (in an external container file)
  
  =item * Modularized commands (similar to App::Cmd::Commands ?)
  
  =item * app-starter
  
  =item * command inclusion by prefix, suffix and regexp (feature request by fco)
  
  =item * command inclusion and exclusion also by attributes
  
  =item * some extra integration, maybe IPC::Cmd and IO::Prompt
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 CONTRIBUTORS
  
  (in alphabetical order)
  
  Ben Hengst
  
  Fernando Correa
  
  Flavio Glock
  
  Thanks to everyone for contributing! Please let me know if I've skipped your name by accident.
  
  
  =head1 ACKNOWLEDGEMENTS
  
  This module was inspired by Kenichi Ishigaki's presentation I<"Web is not the only one that requires frameworks"> during YAPC::Asia::2008 and the modules it exposed (mainly App::Cmd and App::CLI).
  
  Also, many thanks to CGI::App(now Titanium)'s Mark Stosberg and all the Catalyst developers, as some of App::Rad's functionality was taken from those (web) frameworks.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD

$fatpacked{"App/Rad/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_CONFIG';
  package App::Rad::Config;
  
  sub load_config {
      my ($c, @files) = (@_);
  
      foreach my $filename (@files) {
  
          $c->debug("loading configuration from $filename");
          open my $CONFIG, '<', $filename
              or Carp::croak "error opening $filename: $!\n";
  
          while (<$CONFIG>) {
              chomp;
              s/#.*//;
              s/^\s+//;
              s/\s+$//;
              next unless length;
  
              if ( m/^([^\=\:\s]+)        # key
                  (?:                     # (value is optional)
                     (?:\s*[\=\:]\s*|\s+) # separator ('=', ':' or whitespace)
                     (.+)                 # value
                  )?
                  /x
              ) {
                  $c->config->{$1} = $2;
              }
          }
          close $CONFIG;
      }
  }
  
  42;
APP_RAD_CONFIG

$fatpacked{"App/Rad/Exclude.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_EXCLUDE';
  package App::Rad::Exclude;
  use Carp qw/carp croak/;
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('exclude', \&exclude, 'completely erase command from your program');
  }
  
  # removes given sub from the
  # main program
  sub _remove_code_from_file {
      my $sub = shift;
  
      #TODO: I really should be using PPI
      #if the user has it installed...
      open my $fh, '+<', $0
          or croak "error updating file $0: $!\n";
  
  #    flock($fh, LOCK_EX) or carp "could not lock file $0: $!\n";
  
      my @file = <$fh>;
      my $ret = _remove_code_from_array(\@file, $sub);
  
      # TODO: only change the file if it's eval'd without errors
      seek ($fh, 0, 0) or croak "error seeking file $0: $!\n";
      print $fh @file or croak "error writing to file $0: $!\n";
      truncate($fh, tell($fh)) or croak "error truncating file $0: $!\n";
  
      close $fh;
  
      return $ret;
  }
  
  sub _remove_code_from_array {
      my $file_array_ref = shift;
      my $sub = shift;
  
      my $index = 0;
      my $open_braces = 0;
      my $close_braces = 0;
      my $sub_start = 0;
      while ( $file_array_ref->[$index] ) {
          if ($file_array_ref->[$index] =~ m/\s*sub\s+$sub(\s+|\s*\{)/) {
              $sub_start = $index;
          }
          if ($sub_start) {
              # in order to see where the sub ends, we'll
              # try to count the number of '{' against
              # the number of '}' available
  
              #TODO:I should use an actual LR parser or
              #something. This would be greatly enhanced
              #and much less error-prone, specially for
              #nested symbols in the same line.
              $open_braces++ while $file_array_ref->[$index] =~ m/\{/g;
              $close_braces++ while $file_array_ref->[$index] =~ m/\}/g;
              if ( $open_braces > 0 ) {
                  if ( $close_braces > $open_braces ) {
                      croak "Error removing $sub: could not parse $0 correctly.";
                  }
                  elsif ( $open_braces == $close_braces ) {
                      # remove lines from array
                      splice (@{$file_array_ref}, $sub_start, ($index + 1 - $sub_start));
                      last;
                  }
              }
          }
      }
      continue {
          $index++;
      }
  
      if ($sub_start == 0) {
          return "Error finding '$sub' command. Built-in?";
      }
      else {
          return "Command '$sub' successfuly removed.";
      }
  }
  
  sub exclude {
      my $c = shift;
      if ( $c->argv->[0] ) {
          if ( $c->is_command( $c->argv->[0] ) ) {
              return _remove_code_from_file($c->argv->[0]);
          }
          else {
              return $c->argv->[0] . ' is not an available command';
          }
      }
      else {
          return "Sintax: $0 exclude command_name"
      }
  }
  
  42;
  __END__
  =head1 NAME
  
  App::Rad::Exclude - 'exclude' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.01
  
  =head1 SYNOPSIS
  
  'exclude' is an opt-in command for you App::Rad programs (myapp.pl):
  
      use App::Rad qw(exclude);  # add the 'exclude' command
      App::Rad->run();
      
      sub mycmd {
          print "hello, world\n";
      }
      
  and now you can permanently remove a command from your application
  
      [user@host]$ myapp.pl exclude mycmd
      
  Note that this B<*will*> edit the program's source code and try to remove the command (subroutine) automatically, so use it with extreme caution.
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately. Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 exclude
  
  Removes given command (subroutine) from your App::Rad program.
  
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * Carp, which is core in Perl 5.8.
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_EXCLUDE

$fatpacked{"App/Rad/Help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_HELP';
  package App::Rad::Help;
  use Attribute::Handlers;
  use strict;
  use warnings;
  
  our $VERSION = '0.03';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('help', \&help, 'show syntax and available commands');
  }
  
  # shows specific help commands
  # TODO: context specific help, 
  # such as "myapp.pl help command"
  sub help {
      my $c = shift;
      return usage() . "\n\n" . helpstr($c);
  }
  
  sub usage {
      return "Usage: $0 command [arguments]";
  }
  
  sub helpstr {
      my $c = shift;
      
      my $string = "Available Commands:\n";
  
      # get length of largest command name
      my $len = 0;
      foreach ( sort $c->commands() ) {
          $len = length($_) if (length($_) > $len);
      }
  
      # format help string
      foreach ( sort $c->commands() ) {
          $string .= sprintf "    %-*s\t%s\n", $len, $_, 
                             defined ($c->{'_commands'}->{$_}->{'help'})
                             ? $c->{'_commands'}->{$_}->{'help'}
                             : ''
                             ;
                  ;
      }
      return $string;
  }
      
  
  {
  my %help_attr = ();
  sub UNIVERSAL::Help :ATTR(CODE) {
       my ($package, $symbol, $ref, $attr, $data, $phase, $filename, $linenum) = @_;
  
      if ($package eq 'main') {
          # If data is a single word, it is received as an array ref. Don't ask.
          $data = join(' ', @$data) if ref($data) eq 'ARRAY';
          $help_attr{ *{$symbol}{NAME} } = $data;
      }
  }
  
  sub register_help {
      my ($self, $c, $cmd, $helptext) = @_;
  
      if ((not defined $helptext) && (defined $help_attr{$cmd})) {
          $helptext = $help_attr{$cmd};
      }
  
      # we do $helptext // undef as it would issue a warning otherwise
      $c->{'_commands'}->{$cmd}->{'help'} = defined $helptext
                                          ? $helptext
                                          : undef
                                          ;
  }
  
  }
  42;
  __END__
  
  =head1 NAME
  
  App::Rad::Help - 'help' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.02
  
  =head1 SYNOPSIS
  
  you can add inline help for your App::Rad commands via C<< $c->register() >> or C<< $c->register_commands() >>:
  
      use App::Rad;
      App::Rad->run();
      
      sub setup {
          my $c = shift;
          
          $c->register_commands( {
                  foo => 'expand your foo!',
                  bar => 'have a drink! arguments: --drink=DRINK',
              });
              
          $c->register('baz', \&baz, 'do your thing');
      }
      
  you can also do it with the attribute 'Help' in your subs
  
      sub my_command :Help(this is my command) {
          ...
      }
      
      sub another_cmd
      :Help(yet another command)
      {
          ...
      }
      
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately (unless, perhaps, you want to use one of its methods to customize your own 'help' command). Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 help
  
  Show help text
  
  =head2 register_help
  
  Associates help text with command
  
  =head2 usage
  
  Prints usage string. Default is "Usage: $0 command [arguments]", where $0 is your program's name.
  
  =head2 helpstr
  
  Prints a help string with all available commands and their help description.
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * Attribute::Handlers, which is core as of Perl 5.8.
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 ACKNOWLEDGEMENTS
  
  The attribute handling was *much* easened because of the nice C<< Attribute::Handlers >> module. So many thanks to Damian Conway, Rafael Garcia-Suarez and Steffen Mueller.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_HELP

$fatpacked{"App/Rad/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_INCLUDE';
  package App::Rad::Include;
  use Carp qw/carp croak/;
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('include', \&include, 'include one-liner as a command');
  }
  
  # translates one-liner into
  # a complete, readable code
  sub _get_oneliner_code {
      return _sanitize( _deparse($_[0]) );
  }
  
  
  #TODO: option to do it saving a backup file
  # (behavior probably set via 'setup')
  # inserts the string received
  # (hopefully code) inside the
  # user's program file as a 'sub'
  sub _insert_code_in_file {
      my ($command_name, $code_text) = @_;
  
      my $sub =<<"EOSUB";
  sub $command_name {
  $code_text
  }
  EOSUB
  
      # tidy up the code, if Perl::Tidy is available
      eval "use Perl::Tidy ()";
      if (! $@) {
          my $new_code = '';
          Perl::Tidy::perltidy( argv => '', source => \$sub, destination => \$new_code );
          $sub = $new_code;
      }
  
  #TODO: flock
  #    eval {
  #        use 'Fcntl qw(:flock)';
  #    }
  #    if ($@) {
  #        carp 'Could not load file locking module';
  #    }
  
      #TODO: I really should be using PPI
      #if the user has it installed...
      #or at least a decent parser
      open my $fh, '+<', $0
          or croak "error updating file $0: $!\n";
  
  #    flock($fh, LOCK_EX) or carp "could not lock file $0: $!\n";
  
      my @file = <$fh>;
      _insert_code_into_array(\@file, $sub);
  
      # TODO: only change the file if
      # it's eval'd without errors
      seek ($fh, 0, 0) or croak "error seeking file $0: $!\n";
      print $fh @file or croak "error writing to file $0: $!\n";
      truncate($fh, tell($fh)) or croak "error truncating file $0: $!\n";
  
      close $fh;
  }
  
  
  sub _insert_code_into_array {
      my ($file_array_ref, $sub) = @_;
      my $changed = 0;
  
      $sub = "\n\n" . $sub . "\n\n";
  
      my $line_id = 0;
      while ( $file_array_ref->[$line_id] ) {
  
          # this is a very rudimentary parser. It assumes a simple
          # vanilla application as shown in the main example, and
          # tries to include the given subroutine just after the
          # App::Rad->run(); call.
          next unless $file_array_ref->[$line_id] =~ /App::Rad->run/;
  
          # now we add the sub (hopefully in the right place)
          splice (@{$file_array_ref}, $line_id + 1, 0, $sub);
          $changed = 1;
          last;
      }
      continue {
          $line_id++;
      }
      if ( not $changed ) {
          croak "error finding 'App::Rad->run' call. $0 does not seem a valid App::Rad application.\n";
      }
  }
  
  
  # deparses one-liner into a working subroutine code
  sub _deparse {
  
      my $arg_ref = shift;
  
      # create array of perl command-line 
      # parameters passed to this one-liner
      my @perl_args = ();
      while ( $arg_ref->[0] =~ m/^-/o ) {
          push @perl_args, (shift @{$arg_ref});
      }
  
      #TODO: I don't know if "O" and
      # "B::Deparse" can actually run the same way as
      # a module as it does via -MO=Deparse.
      # and while I can't figure out how to use B::Deparse
      # to do exactly what it does via 'compile', I should
      # at least catch the stderr buffer from qx via 
      # IPC::Cmd's run(), but that's another TODO
      my $deparse = join ' ', @perl_args;
      my $code = $arg_ref->[0];
      my $body = qx{perl -MO=Deparse $deparse '$code'};
      return $body;
  }
  
  
  # tries to adjust a subroutine into
  # App::Rad's API for commands
  sub _sanitize {
      my $code = shift;
  
      # turns BEGIN variables into local() ones
      $code =~ s{(?:local\s*\(?\s*)?(\$\^I|\$/|\$\\)}
                {local ($1)}g;
  
      # and then we just strip any BEGIN blocks
      $code =~ s{BEGIN\s*\{\s*(.+)\s*\}\s*$}
                {$1}mg;
  
      my $codeprefix =<<'EOCODE';
  my $c = shift;
  
  EOCODE
      $code = $codeprefix . $code;
  
      return $code;
  }
  
  
  # includes a one-liner as a command.
  # TODO: don't let the user include
  # a control function!!!!
  sub include {
      my $c = shift;
  
      my @args = @ARGV;
  
      if( @args < 3 ) {
          return "Sintax: $0 include [name] -perl_params 'code'.\n";
      }
  
      # figure out the name of
      # the command to insert.
      # Either the user chose it already
      # or we choose it for the user
      my $command_name = '';
      if ( $args[0] !~ m/^-/o ) {
          $command_name = shift @args;
  
          # don't let the user add a command
          # that already exists
          if ( $c->is_command($command_name) ) {
              return "Command '$command_name' already exists. Please remove it first with '$0 exclude $command_name";
          }
      }
      else {
          $command_name = $c->create_command_name();
      }
      $c->debug("including command '$command_name'...");
  
      my $code_text = _get_oneliner_code(\@args);
  
      _insert_code_in_file($command_name, $code_text);
  
      # turns code string into coderef so we
      # can register it (just in case the user
      # needs to run it right away)
      my $code_ref = sub { eval $code_text};
      $c->register($command_name, $code_ref);
  
      return; 
  }
  
  42;
  __END__
  =head1 NAME
  
  App::Rad::Include - 'include' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.01
  
  =head1 SYNOPSIS
  
  'include' is an opt-in command for you App::Rad programs (myapp.pl):
  
      use App::Rad qw(include);  # add the 'include' command
      App::Rad->run();
      
  and now you can turn your one-liners (e.g:)
  
      [user@host]$ perl -i -pe 's/\r//' file.txt
  
  into nice scalable commands, simply replacing 'perl' for 'yourapp include <NAME>'
  
      [user@host]$ myapp.pl include dos2unix -i -pe 's/\r//'
      
  and there you go, a brand new 'dos2unix' command:
  
      [user@host]$ myapp.pl dos2unix file.txt
  
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately. Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 include
  
  Translates perl one-liner into self-contained command (subroutine) and adds it to your App::Rad program.
  
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * O, which is core in Perl 5.8.
  
  =item * B::Deparse, also core in 5.8.
  
  =item * Perl::Tidy (optional)
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 ACKNOWLEDGEMENTS
  
  The one-liner conversion and beautification was *much* easened because of the nice C<< O >> , C<< B::Deparse >> and C<< Perl::Tidy >> modules. So many thanks to Malcolm Beattie, Nicholas Clark, Stephen McCamant, Steve Hancock, and everyone that helped those projects.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_INCLUDE

$fatpacked{"App/Rad/Plugin/MoreHelp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_PLUGIN_MOREHELP';
  package App::Rad::Plugin::MoreHelp;
  use strict;
  use warnings;
  
  our $VERSION = '0.0001'; # VERSION
  
  sub more_help {
      my ($c, $msg) = @_;
      $c->register(help => sub { App::Rad::Help::help($c) . "\n$msg" },
          'show syntax and available commands');
  }
  
  # ABSTRACT: App::Rad plugin for providing extra help info.
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Rad::Plugin::MoreHelp - App::Rad plugin for providing extra help info.
  
  =head1 VERSION
  
  version 0.0001
  
  =head1 SYNOPSIS
  
      use App::Rad qw(MoreHelp);
  
      sub setup {
          my $c = shift;
          $c->more_help('This string gets appended to the main help message.');
      }
  
      App::Rad->run();
  
  =head1 DESCRIPTION
  
  This is an L<App::Rad> plugin for providing extra help info.
  It provides a C<more_help> method which can be used to provide extra info
  that will be appended to to bottom of the help message.
  
  =head1 METHODS
  
  =head2 more_help
  
      $c->more_help('This string gets appended to the help message.');
  
  =head1 AUTHOR
  
  Naveed Massjouni <naveedm9@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Naveed Massjouni.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_RAD_PLUGIN_MOREHELP

$fatpacked{"Array/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_COMPARE';
  #
  # $Id$
  #
  
  =head1 NAME
  
  Array::Compare - Perl extension for comparing arrays.
  
  =head1 SYNOPSIS
  
    use Array::Compare;
  
    my $comp1 = Array::Compare->new;
    $comp->Sep('|');
    $comp->Skip({3 => 1, 4 => 1});
    $comp->WhiteSpace(0);
    $comp->Case(1);
  
    my $comp2 = Array::Compare->new(Sep => '|',
                                    WhiteSpace => 0,
                                    Case => 1,
                                    Skip => {3 => 1, 4 => 1});
  
    my @arr1 = 0 .. 10;
    my @arr2 = 0 .. 10;
  
    $comp1->compare(\@arr1, \@arr2);
    $comp2->compare(\@arr1, \@arr2);
  
  =head1 DESCRIPTION
  
  If you have two arrays and you want to know if they are the same or
  different, then Array::Compare will be useful to you.
  
  All comparisons are carried out via a comparator object. In the
  simplest usage, you can create and use a comparator object like
  this:
  
    my @arr1 = 0 .. 10;
    my @arr2 = 0 .. 10;
  
    my $comp = Array::Compare->new;
  
    if ($comp->compare(\@arr1, \@arr2)) {
      print "Arrays are the same\n";
    } else {
      print "Arrays are different\n";
    }
  
  Notice that you pass references to the two arrays to the comparison
  method.
  
  Internally the comparator compares the two arrays by using C<join>
  to turn both arrays into strings and comparing the strings using
  C<eq>. In the joined strings, the elements of the original arrays
  are separated with the C<^G> character. This can cause problems if
  your array data contains C<^G> characters as it is possible that
  two different arrays can be converted to the same string.
  
  To avoid this, it is possible to override the default separator
  character, either by passing and alternative to the C<new> function
  
    my $comp = Array::Compare->new(Sep => '|');
  
  or by changing the seperator for an existing comparator object
  
    $comp->Sep('|');
  
  In general you should choose a separator character that won't appear
  in your data.
  
  You can also control whether or not whitespace within the elements of
  the arrays should be considered significant when making the comparison.
  The default is that all whitespace is significant. The alternative is
  for all consecutive white space characters to be converted to a single
  space for the pruposes of the comparison. Again, this can be turned on
  when creating a comparator object:
  
    my $comp = Array::Compare->new(WhiteSpace => 0);
  
  or by altering an existing object:
  
    $comp->WhiteSpace(0);
  
  You can also control whether or not the case of the data is significant 
  in the comparison. The default is that the case of data is taken into 
  account. This can be changed in the standard ways when creating a new 
  comparator object:
  
    my $comp = Array::Compare->new(Case => 0);
  
  or by altering an existing object:
  
    $comp->Case(0);
  
  In addition to the simple comparison described above (which returns true
  if the arrays are the same and false if they're different) there is also
  a full comparison which returns a list containing the indexes of elements
  which differ between the two arrays. If the arrays are the same it returns
  an empty list. In scalar context the full comparison returns the length of
  this list (i.e. the number of elements that differ). You can access the full
  comparision in two ways. Firstly, there is a C<DefFull> attribute. If this
  is C<true> then a full comparison if carried out whenever the C<compare>
  method is called.
  
    my $comp = Array::Compare->new(DefFull => 1);
    $comp->compare(\@arr1, \@arr2); # Full comparison
  
    $comp->DefFull(0);
    $comp->compare(\@arr1, \@arr2); # Simple comparison
  
    $comp->DefFull(1);
    $comp->compare(\@arr1, \@arr2); # Full comparison again
  
  
  Secondly, you can access the full comparison method directly
  
    $comp->full_compare(\@arr1, \@arr2);
  
  For symmetry, there is also a direct method to use to call the simple
  comparison.
  
    $comp->simple_compare(\@arr1, \@arr2);
  
  The final complication is the ability to skip elements in the comparison.
  If you know that two arrays will always differ in a particular element
  but want to compare the arrays I<ignoring> this element, you can do it
  with Array::Compare without taking array slices. To do this, a
  comparator object has an optional attribute called C<Skip> which is a
  reference to a hash. The keys in this hash are the indexes of the array
  elements and the values should be any true value for elements that should
  be skipped.
  
  For example, if you want to compare two arrays, ignoring the values in
  elements two and four, you can do something like this:
  
    my %skip = (2 => 1, 4 => 1);
    my @a = (0, 1, 2, 3, 4, 5);
    my @b = (0, 1, X, 3, X, 5);
  
    my $comp = Array::Compare->new(Skip => \%skip);
  
    $comp->compare(\@a, \@b);
  
  This should return I<true>, as we are explicitly ignoring the columns
  which differ.
  
  Of course, having created a comparator object with no skip hash, it is
  possible to add one later:
  
    $comp->Skip({1 => 1, 2 => 1});
  
  or:
  
    my %skip = (1 => 1, 2 => 2);
    $comp->Skip(\%skip);
  
  To reset the comparator so that no longer skips elements, set the skip
  hash to an empty hash.
  
    $comp->Skip({});
  
  You can also check to see if one array is a permutation of another, i.e.
  they contain the same elements but in a different order.
  
    if ($comp->perm(\@a, \@b) {
      print "Arrays are perms\n";
    else {
      print "Nope. Arrays are completely different\n";
    }
  
  In this case the values of C<WhiteSpace> and C<Case> are still used, 
  but C<Skip> is ignored for, hopefully, obvious reasons.
  
  =head1 METHODS
  
  =cut 
  
  package Array::Compare;
  
  require 5.006_000;
  use strict;
  use warnings;
  our ($VERSION, $AUTOLOAD);
  
  use Moose;
  use Carp;
  
  $VERSION = '2.02';
  
  has Sep        => ( is => 'rw', isa => 'Str',     default => '^G' );
  has WhiteSpace => ( is => 'rw', isa => 'Bool',    default => 1 );
  has Case       => ( is => 'rw', isa => 'Bool',    default => 1 );
  has DefFull    => ( is => 'rw', isa => 'Bool',    default => 0 );
  has Skip       => ( is => 'rw', isa => 'HashRef', default => sub { {} } );
  
  =head2 new [ %OPTIONS ]
  
  Constructs a new comparison object.
  
  Takes an optional hash containing various options that control how
  comparisons are carried out. Any omitted options take useful defaults.
  
  =over 4
  
  =item Sep
  
  This is the value that is used to separate fields when the array is joined
  into a string. It should be a value which doesn't appear in your data.
  Default is '^G'.
  
  =item WhiteSpace
  
  Flag that indicates whether or not whitespace is significant in the
  comparison. If this value is false then all multiple whitespace characters
  are changed into a single space before the comparison takes place. Default
  is 1 (whitespace is significant).
  
  =item Case
  
  Flag that indicates whther or not the case of the data should be significant
  in the comparison. Default is 1 (case is significant).
  
  =item Skip
  
  a reference to a hash which contains the numbers of any columns that should
  be skipped in the comparison. Default is an empty hash (all columns are
  significant).
  
  =item DefFull
  
  Flag which indicates whether the default comparison is simple (just returns
  true if the arrays are the same or false if they're not) or full (returns an
  array containing the indexes of the columns that differ). Default is 0 (simple
  comparison).
  
  =back
  
  =cut
  
  #
  # Utility function to check the arguments to any of the comparison
  # function. Ensures that there are two arguments and that they are
  # both arrays.
  #
  sub _check_args {
    my $self = shift;
    croak('Must compare two arrays.') unless @_ == 2;
    croak('Argument 1 is not an array') unless ref($_[0]) eq 'ARRAY';
    croak('Argument 2 is not an array') unless ref($_[1]) eq 'ARRAY';
  
    return;
  }
  
  =head2 compare_len \@ARR1, \@ARR2
  
  Very simple comparison. Just checks the lengths of the arrays are
  the same.
  
  =cut
  
  sub compare_len {
    my $self = shift;
  
    $self->_check_args(@_);
  
    return @{$_[0]} == @{$_[1]};
  }
  
  =head2 compare \@ARR1, \@ARR2
  
  Compare the values in two arrays and return a data indicating whether
  the arrays are the same. The exact return values differ depending on
  the comparison method used. See the descriptions of L<simple_compare>
  and L<full_compare> for details.
  
  Uses the value of DefFull to determine which comparison routine
  to use.
  
  =cut
  
  sub compare {
    my $self = shift;
  
    if ($self->DefFull) {
      return $self->full_compare(@_);
    } else {
      return $self->simple_compare(@_);
    }
  }
  
  =head2 simple_compare \@ARR1, \@ARR2
  
  Compare the values in two arrays and return a flag indicating whether or
  not the arrays are the same.
  
  Returns true if the arrays are the same or false if they differ.
  
  Uses the values of 'Sep', 'WhiteSpace' and 'Skip' to influence
  the comparison.
  
  =cut
  
  sub simple_compare {
    my $self = shift;
  
    $self->_check_args(@_);
  
    my ($row1, $row2) = @_;
  
    # No point in continuing if the number of elements is different.
    return unless $self->compare_len(@_);
  
    # @check contains the indexes into the two arrays, i.e. the numbers
    # from 0 to one less than the number of elements.
    my @check = 0 .. $#$row1;
  
    my ($pkg, $caller) = (caller(1))[0, 3];
    $caller = '' unless defined $caller;
    my $perm = $caller eq __PACKAGE__ . "::perm";
  
    # Filter @check so it only contains indexes that should be compared.
    # N.B. Makes no sense to do this if we are called from 'perm'.
    unless ($perm) {
      @check = grep {!(exists $self->Skip->{$_}
  		     && $self->Skip->{$_}) } @check
  		       if keys %{$self->Skip};
    }
  
    # Build two strings by taking array slices containing only the columns
    # that we shouldn't skip and joining those array slices using the Sep
    # character. Hopefully we can then just do a string comparison.
    # Note: this makes the function liable to errors if your arrays
    # contain the separator character.
    my $str1 = join($self->Sep, map { defined $_ ? $_ : '' } @{$row1}[@check]);
    my $str2 = join($self->Sep, map { defined $_ ? $_ : '' } @{$row2}[@check]);
  
    # If whitespace isn't significant, collapse it
    unless ($self->WhiteSpace) {
      $str1 =~ s/\s+/ /g;
      $str2 =~ s/\s+/ /g;
    }
  
    # If case isn't significant, change to lower case
    unless ($self->Case) {
      $str1 = lc $str1;
      $str2 = lc $str2;
    }
  
    return $str1 eq $str2;
  }
  
  =head2 full_compare \@ARR1, \@ARR2
  
  Do a full comparison between two arrays.
  
  Checks each individual column. In scalar context returns the number
  of columns that differ (zero if the arrays are the same). In list
  context returns an list containing the indexes of the columns that
  differ (an empty list if the arrays are the same).
  
  Uses the values of 'Sep' and 'WhiteSpace' to influence the comparison.
  
  B<Note:> If the two arrays are of different lengths then this method
  just returns the indexes of the elements that appear in one array but
  not the other (i.e. the indexes from the longer array that are beyond
  the end of the shorter array). This might be a little
  counter-intuitive.
  
  =cut
  
  sub full_compare {
    my $self = shift;
  
    $self->_check_args(@_);
  
    my ($row1, $row2) = @_;
  
    # No point in continuing if the number of elements is different.
    # Because of the expected return value from this function we can't
    # just say 'the arrays are different'. We need to do some work to
    # calculate a meaningful return value.
    # If we've been called in array context we return a list containing
    # the number of the columns that appear in the longer list and aren't
    # in the shorter list. If we've been called in scalar context we
    # return the difference in the lengths of the two lists.
    unless ($self->compare_len(@_)) {
      if (wantarray) {
        my ($max, $min);
        if ($#{$row1} > $#{$row2}) {
  	($max, $min) = ($#{$row1}, $#{$row2} + 1);
        } else {
  	($max, $min) = ($#{$row2}, $#{$row1} + 1);
        }
        return ($min .. $max);
      } else {
        return abs(@{$row1} - @{$row2});
      }
    }
  
    my ($arr1, $arr2) = @_;
  
    my @diffs = ();
  
    foreach (0 .. $#{$arr1}) {
      next if keys %{$self->Skip} && $self->Skip->{$_};
  
      my ($val1, $val2) = ($arr1->[$_], $arr2->[$_]);
  
      next unless defined $val1 or defined $val2;
  
      if ((defined $val1 and not defined $val2)
        or (defined $val2 and not defined $val1)) {
        push @diffs, $_;
        next;
      }
  
      unless ($self->WhiteSpace) {
        $val1 =~ s/\s+/ /g;
        $val2 =~ s/\s+/ /g;
      }
  
      unless ($self->Case) {
        $val1 = lc $val1;
        $val2 = lc $val2;
      }
  
      push @diffs, $_ unless $val1 eq $val2;
    }
  
    return wantarray ? @diffs : scalar @diffs;
  }
  
  =head2 perm \@ARR1, \@ARR2
  
  Check to see if one array is a permutation of the other (i.e. contains
  the same set of elements, but in a different order).
  
  We do this by sorting the arrays and passing references to the assorted
  versions to simple_compare. There are also some small changes to
  simple_compare as it should ignore the Skip hash if we are called from
  perm.
  
  =cut
  
  sub perm {
    my $self = shift;
  
    return $self->simple_compare([sort @{$_[0]}], [sort @{$_[1]}]);
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  __END__
  
  =head1 AUTHOR
  
  Dave Cross <dave@mag-sol.com>
  
  =head1 SEE ALSO
  
  perl(1).
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2000-2005, Magnum Solutions Ltd.  All Rights Reserved.
  
  This script is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. 
  
  =cut
ARRAY_COMPARE

$fatpacked{"Class/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD';
  package Class::Load;
  BEGIN {
    $Class::Load::AUTHORITY = 'cpan:SARTAK';
  }
  # git description: v0.20-8-gc4c6e08
  $Class::Load::VERSION = '0.21';
  use strict;
  use warnings;
  use base 'Exporter';
  use Data::OptList 'mkopt';
  use Module::Implementation 0.04;
  use Module::Runtime 0.012 qw(
      check_module_name
      module_notional_filename
      require_module
      use_module
  );
  use Try::Tiny;
  
  {
      my $loader = Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => ['is_class_loaded'],
      );
  
      $loader->();
  }
  
  our @EXPORT_OK = qw/load_class load_optional_class try_load_class is_class_loaded load_first_existing_class/;
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  our $ERROR;
  
  sub load_class {
      my $class   = shift;
      my $options = shift;
  
      my ($res, $e) = try_load_class($class, $options);
      return $class if $res;
  
      _croak($e);
  }
  
  sub load_first_existing_class {
      my $classes = Data::OptList::mkopt(\@_)
          or return;
  
      foreach my $class (@{$classes}) {
          check_module_name($class->[0]);
      }
  
      for my $class (@{$classes}) {
          my ($name, $options) = @{$class};
  
          # We need to be careful not to pass an undef $options to this sub,
          # since the XS version will blow up if that happens.
          return $name if is_class_loaded($name, ($options ? $options : ()));
  
          my ($res, $e) = try_load_class($name, $options);
  
          return $name if $res;
  
          my $file = module_notional_filename($name);
  
          next if $e =~ /^Can't locate \Q$file\E in \@INC/;
          next
              if $options
                  && defined $options->{-version}
                  && $e =~ _version_fail_re($name, $options->{-version});
  
          _croak("Couldn't load class ($name) because: $e");
      }
  
      my @list = map {
          $_->[0]
              . ( $_->[1] && defined $_->[1]{-version}
              ? " (version >= $_->[1]{-version})"
              : q{} )
      } @{$classes};
  
      my $err
          .= q{Can't locate }
          . _or_list(@list)
          . " in \@INC (\@INC contains: @INC).";
      _croak($err);
  }
  
  sub _version_fail_re {
      my $name = shift;
      my $vers = shift;
  
      return qr/\Q$name\E version \Q$vers\E required--this is only version/;
  }
  
  sub _nonexistent_fail_re {
      my $name = shift;
  
      my $file = module_notional_filename($name);
      return qr/Can't locate \Q$file\E in \@INC/;
  }
  
  sub _or_list {
      return $_[0] if @_ == 1;
  
      return join ' or ', @_ if @_ ==2;
  
      my $last = pop;
  
      my $list = join ', ', @_;
      $list .= ', or ' . $last;
  
      return $list;
  }
  
  sub load_optional_class {
      my $class   = shift;
      my $options = shift;
  
      check_module_name($class);
  
      my ($res, $e) = try_load_class($class, $options);
      return 1 if $res;
  
      return 0
          if $options
              && defined $options->{-version}
              && $e =~ _version_fail_re($class, $options->{-version});
  
      return 0
          if $e =~ _nonexistent_fail_re($class);
  
      _croak($e);
  }
  
  sub try_load_class {
      my $class   = shift;
      my $options = shift;
  
      check_module_name($class);
  
      local $@;
      undef $ERROR;
  
      if (is_class_loaded($class)) {
          # We need to check this here rather than in is_class_loaded() because
          # we want to return the error message for a failed version check, but
          # is_class_loaded just returns true/false.
          return 1 unless $options && defined $options->{-version};
          return try {
              $class->VERSION($options->{-version});
              1;
          }
          catch {
              _error($_);
          };
      }
  
      my $file = module_notional_filename($class);
      # This says "our diagnostics of the package
      # say perl's INC status about the file being loaded are
      # wrong", so we delete it from %INC, so when we call require(),
      # perl will *actually* try reloading the file.
      #
      # If the file is already in %INC, it won't retry,
      # And on 5.8, it won't fail either!
      #
      # The extra benefit of this trick, is it helps even on
      # 5.10, as instead of dying with "Compilation failed",
      # it will die with the actual error, and that's a win-win.
      delete $INC{$file};
      return try {
          local $SIG{__DIE__} = 'DEFAULT';
          if ($options && defined $options->{-version}) {
              use_module($class, $options->{-version});
          }
          else {
              require_module($class);
          }
          1;
      }
      catch {
          _error($_);
      };
  }
  
  sub _error {
      my $e = shift;
  
      $e =~ s/ at .+?Runtime\.pm line [0-9]+\.$//;
      chomp $e;
  
      $ERROR = $e;
      return 0 unless wantarray;
      return 0, $ERROR;
  }
  
  sub _croak {
      require Carp;
      local $Carp::CarpLevel = $Carp::CarpLevel + 2;
      Carp::croak(shift);
  }
  
  1;
  
  # ABSTRACT: a working (require "Class::Name") and more
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Load - a working (require "Class::Name") and more
  
  =head1 VERSION
  
  version 0.21
  
  =head1 SYNOPSIS
  
      use Class::Load ':all';
  
      try_load_class('Class::Name')
          or plan skip_all => "Class::Name required to run these tests";
  
      load_class('Class::Name');
  
      is_class_loaded('Class::Name');
  
      my $baseclass = load_optional_class('Class::Name::MightExist')
          ? 'Class::Name::MightExist'
          : 'Class::Name::Default';
  
  =head1 DESCRIPTION
  
  C<require EXPR> only accepts C<Class/Name.pm> style module names, not
  C<Class::Name>. How frustrating! For that, we provide
  C<load_class 'Class::Name'>.
  
  It's often useful to test whether a module can be loaded, instead of throwing
  an error when it's not available. For that, we provide
  C<try_load_class 'Class::Name'>.
  
  Finally, sometimes we need to know whether a particular class has been loaded.
  Asking C<%INC> is an option, but that will miss inner packages and any class
  for which the filename does not correspond to the package name. For that, we
  provide C<is_class_loaded 'Class::Name'>.
  
  =head1 FUNCTIONS
  
  =head2 load_class Class::Name, \%options
  
  C<load_class> will load C<Class::Name> or throw an error, much like C<require>.
  
  If C<Class::Name> is already loaded (checked with C<is_class_loaded>) then it
  will not try to load the class. This is useful when you have inner packages
  which C<require> does not check.
  
  The C<%options> hash currently accepts one key, C<-version>. If you specify a
  version, then this subroutine will call C<< Class::Name->VERSION(
  $options{-version} ) >> internally, which will throw an error if the class's
  version is not equal to or greater than the version you requested.
  
  This method will return the name of the class on success.
  
  =head2 try_load_class Class::Name, \%options -> (0|1, error message)
  
  Returns 1 if the class was loaded, 0 if it was not. If the class was not
  loaded, the error will be returned as a second return value in list context.
  
  Again, if C<Class::Name> is already loaded (checked with C<is_class_loaded>)
  then it will not try to load the class. This is useful when you have inner
  packages which C<require> does not check.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 is_class_loaded Class::Name, \%options -> 0|1
  
  This uses a number of heuristics to determine if the class C<Class::Name> is
  loaded. There heuristics were taken from L<Class::MOP>'s old pure-perl
  implementation.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 load_first_existing_class Class::Name, \%options, ...
  
  This attempts to load the first loadable class in the list of classes
  given. Each class name can be followed by an options hash reference.
  
  If any one of the classes loads and passes the optional version check, that
  class name will be returned. If I<none> of the classes can be loaded (or none
  pass their version check), then an error will be thrown.
  
  If, when attempting to load a class, it fails to load because of a syntax
  error, then an error will be thrown immediately.
  
  =head2 load_optional_class Class::Name, \%options -> 0|1
  
  C<load_optional_class> is a lot like C<try_load_class>, but also a lot like
  C<load_class>.
  
  If the class exists, and it works, then it will return 1. If you specify a
  version in C<%options>, then the version check must succeed or it will return
  0.
  
  If the class doesn't exist, and it appears to not exist on disk either, it
  will return 0.
  
  If the class exists on disk, but loading from disk results in an error
  (e.g.: a syntax error), then it will C<croak> with that error.
  
  This is useful for using if you want a fallback module system, i.e.:
  
      my $class = load_optional_class($foo) ? $foo : $default;
  
  That way, if $foo does exist, but can't be loaded due to error, you won't
  get the behaviour of it simply not existing.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://blog.fox.geek.nz/2010/11/searching-design-spec-for-ultimate.html>
  
  This blog post is a good overview of the current state of the existing modules
  for loading other modules in various ways.
  
  =item L<http://blog.fox.geek.nz/2010/11/handling-optional-requirements-with.html>
  
  This blog post describes how to handle optional modules with L<Class::Load>.
  
  =item L<http://d.hatena.ne.jp/tokuhirom/20110202/1296598578>
  
  This Japanese blog post describes why L<DBIx::Skinny> now uses L<Class::Load>
  over its competitors.
  
  =item L<Moose>, L<Jifty>, L<Prophet>, etc
  
  This module was designed to be used anywhere you have
  C<if (eval "require $module"; 1)>, which occurs in many large projects.
  
  =back
  
  =head1 AUTHOR
  
  Shawn M Moore <sartak at bestpractical.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2008 by Shawn M Moore.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CLASS_LOAD

$fatpacked{"Class/Load/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD_PP';
  package Class::Load::PP;
  BEGIN {
    $Class::Load::PP::AUTHORITY = 'cpan:SARTAK';
  }
  $Class::Load::PP::VERSION = '0.21';
  use strict;
  use warnings;
  use Module::Runtime 'is_module_name';
  use Package::Stash 0.14;
  use Scalar::Util 'blessed', 'reftype';
  use Try::Tiny;
  
  sub is_class_loaded {
      my $class   = shift;
      my $options = shift;
  
      my $loaded = _is_class_loaded($class);
  
      return $loaded if ! $loaded;
      return $loaded unless $options && $options->{-version};
  
      return try {
          $class->VERSION($options->{-version});
          1;
      }
      catch {
          0;
      };
  }
  
  sub _is_class_loaded {
      my $class = shift;
  
      return 0 unless is_module_name($class);
  
      my $stash = Package::Stash->new($class);
  
      if ($stash->has_symbol('$VERSION')) {
          my $version = ${ $stash->get_symbol('$VERSION') };
          if (defined $version) {
              return 1 if ! ref $version;
              # Sometimes $VERSION ends up as a reference to undef (weird)
              return 1 if ref $version && reftype $version eq 'SCALAR' && defined ${$version};
              # a version object
              return 1 if blessed $version;
          }
      }
  
      if ($stash->has_symbol('@ISA')) {
          return 1 if @{ $stash->get_symbol('@ISA') };
      }
  
      # check for any method
      return 1 if $stash->list_all_symbols('CODE');
  
      # fail
      return 0;
  }
  
  1;
  
  =for Pod::Coverage is_class_loaded
  
  =cut
CLASS_LOAD_PP

$fatpacked{"Config/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_TINY';
  package Config::Tiny;
  
  # If you thought Config::Simple was small...
  
  use strict;
  our $VERSION = '2.20'; # Also change version # in t/02.main.t.
  BEGIN {
  	require 5.008001;
  	$Config::Tiny::errstr  = '';
  }
  
  # Create an empty object
  sub new { bless {}, shift }
  
  # Create an object from a file
  sub read {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $file  = shift or return $class->_error('No file name provided');
  
  	# Slurp in the file.
  
  	my $encoding = shift;
  	$encoding    = $encoding ? "<:$encoding" : '<';
  	local $/     = undef;
  
  	open( CFG, $encoding, $file ) or return $class->_error( "Failed to open file '$file' for reading: $!" );
  	my $contents = <CFG>;
  	close( CFG );
  
  	return $class -> _error("Reading from '$file' returned undef") if (! defined $contents);
  
  	return $class->read_string( $contents );
  }
  
  # Create an object from a string
  sub read_string {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $self  = bless {}, $class;
  	return undef unless defined $_[0];
  
  	# Parse the file
  	my $ns      = '_';
  	my $counter = 0;
  	foreach ( split /(?:\015{1,2}\012|\015|\012)/, shift ) {
  		$counter++;
  
  		# Skip comments and empty lines
  		next if /^\s*(?:\#|\;|$)/;
  
  		# Remove inline comments
  		s/\s\;\s.+$//g;
  
  		# Handle section headers
  		if ( /^\s*\[\s*(.+?)\s*\]\s*$/ ) {
  			# Create the sub-hash if it doesn't exist.
  			# Without this sections without keys will not
  			# appear at all in the completed struct.
  			$self->{$ns = $1} ||= {};
  			next;
  		}
  
  		# Handle properties
  		if ( /^\s*([^=]+?)\s*=\s*(.*?)\s*$/ ) {
  			$self->{$ns}->{$1} = $2;
  			next;
  		}
  
  		return $self->_error( "Syntax error at line $counter: '$_'" );
  	}
  
  	$self;
  }
  
  # Save an object to a file
  sub write {
  	my $self     = shift;
  	my $file     = shift or return $self->_error('No file name provided');
  	my $encoding = shift;
  	$encoding    = $encoding ? ">:$encoding" : '>';
  
  	# Write it to the file
  	my $string = $self->write_string;
  	return undef unless defined $string;
  	open( CFG, $encoding, $file ) or return $self->_error(
  		"Failed to open file '$file' for writing: $!"
  		);
  	print CFG $string;
  	close CFG;
  
  	return 1;
  }
  
  # Save an object to a string
  sub write_string {
  	my $self = shift;
  
  	my $contents = '';
  	foreach my $section ( sort { (($b eq '_') <=> ($a eq '_')) || ($a cmp $b) } keys %$self ) {
  		# Check for several known-bad situations with the section
  		# 1. Leading whitespace
  		# 2. Trailing whitespace
  		# 3. Newlines in section name
  		return $self->_error(
  			"Illegal whitespace in section name '$section'"
  		) if $section =~ /(?:^\s|\n|\s$)/s;
  		my $block = $self->{$section};
  		$contents .= "\n" if length $contents;
  		$contents .= "[$section]\n" unless $section eq '_';
  		foreach my $property ( sort keys %$block ) {
  			return $self->_error(
  				"Illegal newlines in property '$section.$property'"
  			) if $block->{$property} =~ /(?:\012|\015)/s;
  			$contents .= "$property=$block->{$property}\n";
  		}
  	}
  
  	$contents;
  }
  
  # Error handling
  sub errstr { $Config::Tiny::errstr }
  sub _error { $Config::Tiny::errstr = $_[1]; undef }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Config::Tiny - Read/Write .ini style files with as little code as possible
  
  =head1 SYNOPSIS
  
  	# In your configuration file
  	rootproperty=blah
  
  	[section]
  	one=twp
  	three= four
  	Foo =Bar
  	empty=
  
  	# In your program
  	use Config::Tiny;
  
  	# Create a config
  	my $Config = Config::Tiny->new;
  
  	# Open the config
  	$Config = Config::Tiny->read( 'file.conf' );
  	$Config = Config::Tiny->read( 'file.conf', 'utf8' ); # Neither ':' nor '<:' prefix!
  	$Config = Config::Tiny->read( 'file.conf', 'encoding(iso-8859-1)');
  
  	# Reading properties
  	my $rootproperty = $Config->{_}->{rootproperty};
  	my $one = $Config->{section}->{one};
  	my $Foo = $Config->{section}->{Foo};
  
  	# Changing data
  	$Config->{newsection} = { this => 'that' }; # Add a section
  	$Config->{section}->{Foo} = 'Not Bar!';     # Change a value
  	delete $Config->{_};                        # Delete a value or section
  
  	# Save a config
  	$Config->write( 'file.conf' );
  	$Config->write( 'file.conf', 'utf8' ); # Neither ':' nor '>:' prefix!
  
  	# Shortcuts
  	my($rootproperty) = $$Config{_}{rootproperty};
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  	my($config) = Config::Tiny -> read_string("[init]\nalpha=bet");
  	my($value)  = $$config{init}{alpha}; # $value is 'bet'.
  
  =head1 DESCRIPTION
  
  C<Config::Tiny> is a Perl class to read and write .ini style configuration
  files with as little code as possible, reducing load time and memory
  overhead.
  
  Most of the time it is accepted that Perl applications use a lot
  of memory and modules.
  
  The C<*::Tiny> family of modules is specifically intended to provide an ultralight alternative to the
  standard modules.
  
  This module is primarily for reading human written files, and anything we write shouldn't need to have
  documentation/comments. If you need something with more power move up to L<Config::Simple>, L<Config::General>
  or one of the many other C<Config::*> modules.
  
  Lastly, L<Config::Tiny> does B<not> preserve your comments, whitespace, or the order of your config file.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 CONFIGURATION FILE SYNTAX
  
  Files are the same format as for MS Windows C<*.ini> files. For example:
  
  	[section]
  	var1=value1
  	var2=value2
  
  If a property is outside of a section at the beginning of a file, it will
  be assigned to the C<"root section">, available at C<$Config-E<gt>{_}>.
  
  Lines starting with C<'#'> or C<';'> are considered comments and ignored,
  as are blank lines.
  
  When writing back to the config file, all comments, custom whitespace,
  and the ordering of your config file elements is discarded. If you need
  to keep the human elements of a config when writing back, upgrade to
  something better, this module is not for you.
  
  =head1 METHODS
  
  =head2 errstr()
  
  Returns a string representing the most recent error, or the empty string.
  
  You can also retrieve the error message from the C<$Config::Tiny::errstr> variable.
  
  =head2 new()
  
  The constructor C<new> creates and returns an empty C<Config::Tiny> object.
  
  =head2 read($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<read> constructor reads a config file, $filename, and returns a new
  C<Config::Tiny> object containing the properties in the file.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '<' or '<:'.
  
  Returns the object on success, or C<undef> on error.
  
  When C<read> fails, C<Config::Tiny> sets an error message internally
  you can recover via C<Config::Tiny-E<gt>errstr>. Although in B<some>
  cases a failed C<read> will also set the operating system error
  variable C<$!>, not all errors do and you should not rely on using
  the C<$!> variable.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 read_string($string)
  
  The C<read_string> method takes as argument the contents of a config file
  as a string and returns the C<Config::Tiny> object for it.
  
  =head2 write($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<write> method generates the file content for the properties, and
  writes it to disk to the filename specified.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '>' or '>:'.
  
  Returns true on success or C<undef> on error.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 write_string()
  
  Generates the file content for the object and returns it as a string.
  
  =head1 FAQ
  
  =head2 Why can't I put comments at the ends of lines?
  
  Because a line like:
  
  	key=value # A comment
  
  Sets key to 'value # A comment' :-(.
  
  This conforms to the syntax discussed in L</CONFIGURATION FILE SYNTAX>.
  
  =head2 Why can't I omit the '=' signs?
  
  E.g.:
  
  	[Things]
  	my =
  	list =
  	of =
  	things =
  
  Instead of:
  
  	[Things]
  	my
  	list
  	of
  	things
  
  Because the use of '=' signs is a type of mandatory documentation. It indicates that that section contains 4 items,
  and not 1 odd item split over 4 lines.
  
  =head2 Why do I have to assign the result of a method call to a variable?
  
  This question comes from RT#85386.
  
  Yes, the syntax may seem odd, but you don't have to call both new() and read_string().
  
  Try:
  
  	perl -MData::Dumper -MConfig::Tiny -E 'my $c=Config::Tiny->read_string("one=s"); say Dumper $c'
  
  Or:
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  Or even, a bit ridiculously:
  
  	my($value) = ${Config::Tiny -> read_string('alpha=bet')}{_}{alpha}; # $value is 'bet'.
  
  =head1 CAVEATS
  
  =head2 Unsupported Section Headers
  
  Some edge cases in section headers are not supported, and additionally may not
  be detected when writing the config file.
  
  Specifically, section headers with leading whitespace, trailing whitespace,
  or newlines anywhere in the section header, will not be written correctly
  to the file and may cause file corruption.
  
  =head2 Setting an option more than once
  
  C<Config::Tiny> will only recognize the first time an option is set in a
  config file. Any further attempts to set the same option later in the config
  file are ignored.
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Maintanence from V 2.15: Ron Savage L<http://savage.net.au/>.
  
  =head1 ACKNOWLEGEMENTS
  
  Thanks to Sherzod Ruzmetov E<lt>sherzodr@cpan.orgE<gt> for
  L<Config::Simple>, which inspired this module by being not quite
  "simple" enough for me :).
  
  =head1 SEE ALSO
  
  See, amongst many: L<Config::Simple> and L<Config::General>.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 COPYRIGHT
  
  Copyright 2002 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
CONFIG_TINY

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  {
    $Data::OptList::VERSION = '0.109';
  }
  # ABSTRACT: parse and validate simple name/value option pairs
  
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub __is_a {
    my ($got, $expected) = @_;
  
    return List::Util::first { __is_a($got, $_) } @$expected if ref $expected;
  
    return defined (
      exists($test_for{$expected})
      ? $test_for{$expected}->($got)
      : Params::Util::_INSTANCE($got, $expected) ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my $name_test;
  
    if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
      my $arg = $_[0];
      ($moniker, $require_unique, $must_be, $name_test)
        = @$arg{ qw(moniker require_unique must_be name_test) };
    } else {
      ($moniker, $require_unique, $must_be) = @_;
    }
  
    $moniker = 'unnamed' unless defined $moniker;
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
      my $value;
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      if    ($i == $#$opt_list)               { $value = undef;            }
      elsif (not defined $opt_list->[$i+1])   { $value = undef; $i++       }
      elsif ($name_test->($opt_list->[$i+1])) { $value = undef;            }
      else                                    { $value = $opt_list->[++$i] }
  
      if ($must_be and defined $value) {
        unless (__is_a($value, $must_be)) {
          my $ref = ref $value;
          Carp::croak "$ref-ref values are not valid in $moniker opt list";
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.109
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"Data/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_TABLE';
  package Data::Table;
  BEGIN { die "Your perl version is old, see README for instructions" if $] < 5.005; }
  
  use strict;
  use vars qw($VERSION %DEFAULTS);
  use Carp;
  use Data::Dumper;
  
  $VERSION = '1.70';
  %DEFAULTS = (
    "CSV_DELIMITER"=>',', # controls how to read/write CSV file
    "CSV_QUALIFIER"=>'"',
    "OS"=>0,
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    # this controls how to read and write CSV/TSV file
    "ENCODING"=>'UTF-8'
    # default encoding for fromFile, fromCSV, fromTSV
  );
  %Data::Table::TSV_ESC = ( '0'=>"\0", 'n'=>"\n", 't'=>"\t", 'r'=>"\r", 'b'=>"\b",
                "'"=>"'", '"'=>"\"", '\\'=>"\\" );
  %Data::Table::TSV_ENC = ( "\0"=>'0', "\n"=>'n', "\t"=>'t', "\r"=>'r', "\b"=>'b',
                "'"=>"'", "\""=>'"', "\\"=>'\\' );
  use constant ROW_BASED => 0;
  use constant COL_BASED => 1;
  use constant NUMBER => 0;
  use constant STRING => 1;
  use constant ASC => 0;
  use constant DESC => 1;
  use constant INNER_JOIN => 0;
  use constant LEFT_JOIN => 1;
  use constant RIGHT_JOIN => 2;
  use constant FULL_JOIN => 3;
  use constant OS_UNIX => 0;
  use constant OS_PC => 1;
  use constant OS_MAC => 2;
  
  sub new {
    my ($pkg, $data, $header, $type, $enforceCheck) = @_;
    my $class = ref($pkg) || $pkg;
    $type = 0 unless defined($type); 
    $header=[] unless defined($header);
    $data=[] unless defined($data);
    $enforceCheck = 1 unless defined($enforceCheck);
    confess "new Data::Table: Size of data does not match header\n"
      if (($type && (scalar @$data) && $#{$data} != $#{$header}) ||
          (!$type && (scalar @$data) && $#{$data->[0]} != $#{$header}));
    my $colHash = checkHeader($header);
    if ($enforceCheck && scalar @$data > 0) {
      my $size=scalar @{$data->[0]};
      for (my $j =1; $j<scalar @$data; $j++) {
        confess "Inconsistent array size at data[$j]" unless (scalar @{$data->[$j]} == $size);
      }
    } elsif (scalar @$data == 0) {
      $type = 0;
    }
    my $self={ data=>$data, header=>$header, type=>$type, colHash=>$colHash, OK=>[], MATCH=>[]};
    return bless $self, $class;
  }
  
  sub checkHeader {
    my $header = shift;
    my $colHash = {};
    for (my $i = 0; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      #warn "Column name: $elm at column ".($i+1)." is an integer, using an integer column name will mask the corresponding column index!" if ($elm =~ /^\d+$/);
      confess "Undefined column name (empty or all space) at column ".($i+1) unless $elm;
      #confess "Header name ".$colHash->{$elm}." appears more than once" if defined($colHash->{$elm});
      if (defined($colHash->{$elm})) {
        confess "Header name ($elm) appears more than once: in column ".($colHash->{$elm}+1)." and column ".($i+1).".";
      }
      $colHash->{$elm} = $i;
    }
    return $colHash;
  }
  
  # translate a column name into its position in the header
  # (also in column-based table)
  sub colIndex {
    my ($self, $colID) = @_;
    return $self->{colHash}->{$colID} if exists $self->{colHash}->{$colID};
    return $colID if $colID =~ /^\d+$/;
    return -1;
    #if ($colID =~ /\D/) {
    #  my $i = $self->{colHash}->{$colID};
    #  return -1 unless defined($i);
    #  return $i;
    #}
    #return $colID; # assume an index already
  }
  
  sub hasCol {
    my ($self, $col) = @_;
    return $self->colIndex($col) >= 0;
  }
  
  sub nofCol {
    my $self = shift;
    return scalar @{$self->{header}};
  }
  
  sub isEmpty {
    my $self  = shift;
    return $self->nofCol == 0;
  }
  
  sub nofRow {
    my $self = shift;
    return 0 if (scalar @{$self->{data}} == 0);
    return ($self->{type})?
      scalar @{$self->{data}->[0]} : scalar @{$self->{data}};
  }
  
  sub lastRow {
    my $self = shift;
    return $self->nofRow - 1;
  }
  
  sub lastCol {
    my $self = shift;
    return $self->nofCol - 1;
  }
  
  sub colName {
    my ($self, $colNumericIndex) = @_;
    return ($self->header())[$colNumericIndex];
  }
  
  sub iterator {
    my ($self, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{reverse} = 0 unless exists $arg{reverse};
    my $current_row = $arg{reverse} ? $self->lastRow : 0;
  
    return sub {
      my $rowIdx = shift;
      if (defined $rowIdx) { # return row index for previously returned record
        my $prevRow = $arg{reverse} ? $current_row+1 : $current_row-1;
        return ($prevRow<0 or $prevRow > $self->nofRow-1)? undef: $prevRow;
      }
      return undef if $current_row < 0 or $current_row > $self->nofRow - 1;
      my $oldRow = $current_row;
      $arg{reverse} ? $current_row-- : $current_row++;
      return $self->rowHashRef($oldRow);
    }
  }
  
  # still need to consider quotes and comma in string
  # need to get csv specification
  sub csvEscape {
    my ($s, $arg_ref) = @_;
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    $delimiter = $arg_ref->{'delimiter'} if (defined($arg_ref) && defined($arg_ref->{'delimiter'}));
    $qualifier = $arg_ref->{'qualifier'} if (defined($arg_ref) && defined($arg_ref->{'qualifier'}));
    return '' unless defined($s);
    my $qualifier2 = $qualifier;
    $qualifier2 = substr($qualifier, 1, 1) if length($qualifier)>1; # in case qualifier is a special symbol for regular expression
    $s =~ s/$qualifier/$qualifier2$qualifier2/g;
    if ($s =~ /[$qualifier$delimiter\r\n]/) { return "$qualifier2$s$qualifier2"; }
    return $s;
  }
  
  sub tsvEscape {
    my $s = shift;
    #my %ESC = ( "\0"=>'0', "\n"=>'n', "\t"=>'t', "\r"=>'r', "\b"=>'b',
    #            "'"=>"'", "\""=>'"', "\\"=>'\\' );
    ## what about \f? MySQL treats \f as f.
    return "\\N" unless defined($s);
    $s =~ s/([\0\\\b\r\n\t"'])/\\$Data::Table::TSV_ENC{$1}/g;
    return $s;
  }
  
  # output table in CSV format
  sub csv {
    my ($self, $header, $arg_ref)=@_;
    my ($status, @t);
    my $s = '';
    my ($OS, $fileName_or_handler) = ($Data::Table::DEFAULTS{OS}, undef);
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    if (defined($arg_ref)) {
      $delimiter = $arg_ref->{'delimiter'} if defined($arg_ref->{'delimiter'});
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $fileName_or_handler = $arg_ref->{'file'} if defined($arg_ref->{'file'});
    }
    my $delimiter2 = $delimiter; $delimiter2 = substr($delimiter, 1, 1) if length($delimiter)>1;
    my $endl = ($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    $header=1 unless defined($header);
    $s=join($delimiter2, map {csvEscape($_, {delimiter=>$delimiter, qualifier=>$qualifier})} @{$self->{header}}) . $endl if $header;
  ######  $self->rotate if $self->{type};
    if ($self->{data}) {
      $self->rotate() if ($self->{type});
      my $data=$self->{data};
      for (my $i=0; $i<=$#{$data}; $i++) {
        $s .= join($delimiter2, map {csvEscape($_, {delimiter=>$delimiter, qualifier=>$qualifier})} @{$data->[$i]}) . $endl;
      }
    }
    if (defined($fileName_or_handler)) {
      my $OUT;
      my $isFileHandler = ref($fileName_or_handler) ne '';
      if ($isFileHandler) {
        $OUT = $fileName_or_handler;
      } else {
        open($OUT, "> $fileName_or_handler") or confess "Cannot open $fileName_or_handler to write.\n";
        binmode $OUT;
      }
      print $OUT $s;
      close($OUT) unless $isFileHandler;
    }
    return $s;
  }
  
  # output table in TSV format
  sub tsv {
    my ($self, $header, $arg_ref)=@_;
    my ($status, @t);
    my $s = '';
    my ($OS, $fileName_or_handler, $transform_element) = ($Data::Table::DEFAULTS{OS}, undef, 1);
    if (defined($arg_ref)) {
      $OS = $arg_ref->{'OS'} if (defined($arg_ref->{'OS'}));
      $fileName_or_handler = $arg_ref->{'file'} if (defined($arg_ref->{'file'}));
      $transform_element = $arg_ref->{'transform_element'} if (defined($arg_ref->{'transform_element'}));
    }
    my $endl = ($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    $header=1 unless defined($header);
    if ($header) {
      if ($transform_element) {
        $s=join("\t", map {tsvEscape($_)} @{$self->{header}}) . $endl;
      } else {
        $s=join("\t",@{$self->{header}}) . $endl;
      }
    }
  ######  $self->rotate if $self->{type};
    if ($self->{data}) {
      $self->rotate() if ($self->{type});
      my $data=$self->{data};
      for (my $i=0; $i<=$#{$data}; $i++) {
        if ($transform_element) {
          $s .= join("\t", map {tsvEscape($_)} @{$data->[$i]}) . $endl;
        } else {
          $s .= join("\t", @{$data->[$i]}) . $endl;
        }
      }
    }
    if (defined($fileName_or_handler)) {
      my $OUT;
      my $isFileHandler = ref($fileName_or_handler) ne '';
      if ($isFileHandler) {
        $OUT = $fileName_or_handler;
      } else {
        open($OUT, "> $fileName_or_handler") or confess "Cannot open $fileName_or_handler to write.\n";
        binmode $OUT;
      }
      print $OUT $s;
      close($OUT) unless $isFileHandler;;
    }
    return $s;
  }
  
  # output table in HTML format
  sub html {
    my ($self, $colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td, $portrait) = @_;
    my ($s, $s_tr, $s_td, $s_th) = ("", "tr", "", "th");
    my $key;
    $tag_tbl = { class => "data_table" } unless (ref $tag_tbl eq 'HASH');
    $tag_tr = {} unless (ref $tag_tr eq 'HASH');
    $tag_th = {} unless (ref $tag_th eq 'HASH');
    $tag_td = {} unless (ref $tag_td eq 'HASH');
    $portrait = 1 unless defined($portrait);
  
    $s = "<table";
    foreach $key (keys %$tag_tbl) {
      $s .= " $key=\"$tag_tbl->{$key}\"";
    }
    $s .= ">\n";
    $s .= "<thead>\n" if ($portrait);
    my $header=$self->{header};
    my $l_colorByClass = 0;
    my @BG_COLOR=("#D4D4BF","#ECECE4","#CCCC99");
    my @CELL_CLASSES=("data_table_odd","data_table_even","data_table_header");
    if (ref($colorArrayRef_or_classHashRef) eq "HASH") {
      $l_colorByClass = 1;
      $CELL_CLASSES[1]=$colorArrayRef_or_classHashRef->{even} if defined($colorArrayRef_or_classHashRef->{even});
      $CELL_CLASSES[0]=$colorArrayRef_or_classHashRef->{odd} if defined($colorArrayRef_or_classHashRef->{odd});
      $CELL_CLASSES[2]=$colorArrayRef_or_classHashRef->{header} if defined($colorArrayRef_or_classHashRef->{header});
    } elsif ((ref($colorArrayRef_or_classHashRef) eq "ARRAY") && (scalar @$colorArrayRef_or_classHashRef==3)) {
      @BG_COLOR=@$colorArrayRef_or_classHashRef;
    }
    foreach $key (keys %$tag_tr) {
      $s_tr .= " $key=\"$tag_tr->{$key}\"";
    }
    foreach $key (keys %$tag_th) {
      $s_th .= " $key=\"$tag_th->{$key}\"";
    }
    if ($portrait) {
      $s .= "<$s_tr ".($l_colorByClass? ("class=\"".$CELL_CLASSES[2]."\""):("bgcolor=\"".$BG_COLOR[2]."\""))."><$s_th>".
        join("</th><$s_th>", @$header) . "</th></tr>\n";
      $s .= "</thead>\n";
      $self->rotate() if $self->{type};
      my $data=$self->{data};
      $s .= "<tbody>\n";
      for (my $i=0; $i<=$#{$data}; $i++) {
        $s .= "<$s_tr ".($l_colorByClass? ("class=\"".$CELL_CLASSES[$i%2]."\""):("bgcolor=\"".$BG_COLOR[$i%2]."\"")).">";
        for (my $j=0; $j<=$#{$header}; $j++) {
          my $s_td = $tag_td->{$j} || $tag_td->{$header->[$j]};
          $s .= defined($s_td)? "<td $s_td>":"<td>";
          $s .= (defined($data->[$i][$j]) && $data->[$i][$j] ne '')?$data->[$i][$j]:"&nbsp;";
          $s .= "</td>";
        }
        $s .= "</tr>\n";
      }
      $s .= "</tbody>\n";
    } else {
      $self->rotate() unless $self->{type};
      my $data=$self->{data};
      for (my $i = 0; $i <= $#{$header}; $i++) {
        $s .= "<$s_tr><$s_th ".($l_colorByClass? ("class=\"".$CELL_CLASSES[2]."\""):("bgcolor=\"".$BG_COLOR[2]."\"")).">".
              $header->[$i] . "</th>";
        my $s_td = $tag_td->{$i} || $tag_td->{$header->[$i]};
        for (my $j=0; $j<=$#{$data->[0]}; $j++) {
          $s .= defined($s_td)? "<td $s_td":"<td";
          $s .= ($l_colorByClass?(" class=\"".$CELL_CLASSES[$j%2]."\""):(" bgcolor=\"".$BG_COLOR[$j%2]."\"")).">";
          $s .= (defined($data->[$i][$j]) && $data->[$i][$j] ne '')?$data->[$i][$j]:'&nbsp;';
          $s .= "</td>";
        }
        $s .= "</tr>\n";
      }
    }
    $s .= "</table>\n";
    return $s;
  }
  
  # output table in HTML format, with table orientation rotated,
  # so that each HTML table row is a column in the table
  # This is useful for a slim table (few columns but many rows)
  sub html2 {
    my ($self, $colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td) = @_;
    return $self->html($colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td, 0);
  }
  
  # apply a $fun to each elm in a col 
  # function only has access to one element per row
  sub colMap {
    my ($self, $colID, $fun) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    my $ref = $self->{data}->[$c];
    my @tmp = map {scalar $fun->($_)} @$ref;
    $self->{data}->[$c] = \@tmp;
    return 1;
  } 
  
  # apply a $fun to each row in the table
  # function has access to all elements in that row
  sub colsMap {
    my ($self, $fun) = @_;
    $self->rotate() if $self->{type};
    map {&$fun} @{$self->{data}};
    return 1;
  }
  
  sub addRow {
    my ($self, $rowRef, $rowIdx, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{addNewCol} = 0 unless exists $arg{addNewCol};
  
    my $numRow=$self->nofRow();
    my @t;
    my $myRowRef = $rowRef;
  
    if ($arg{addNewCol}) {
      if (ref $myRowRef eq 'HASH') {
        foreach my $key (keys %$myRowRef) {
          next if $self->colIndex($key) >= 0;
          my @col = (undef) x $self->nofRow;
          $self->addCol(\@col, $key);
        }
      } elsif (ref $myRowRef eq 'ARRAY') {
        for (my $i=$self->nofCol; $i< scalar @$myRowRef; $i++) {
          my @col = (undef) x $self->nofRow;
          $self->addCol(\@col, "col".($i+1));
        }
      }
    }
  
    if (ref $myRowRef eq 'HASH') {
      if ($self->isEmpty) {
        my $i = 0;
        foreach my $s (keys %$myRowRef) {
          push @{$self->{header}}, $s;
          $self->{colHash}->{$s} = $i++;
        }
      }
      my @one = ();
      my @header = $self->header;
      for (my $i=0; $i< scalar @header; $i++) {
        $one[$i] = $myRowRef->{$header[$i]};
      }
      $myRowRef = \@one;
    } elsif (ref $myRowRef eq 'ARRAY') {
      confess "addRow: size of added row does not match those in the table\n"
  	if scalar @$myRowRef != $self->nofCol();
    } else {
      confess "addRow: parameter rowRef has to be either an array_ref or a hash_ref\n";
    }
    $rowIdx=$numRow unless defined($rowIdx);
    return undef unless defined $self->checkNewRow($rowIdx);
    $self->rotate() if $self->{type};
    my $data=$self->{data};
    if ($rowIdx == 0) {
      unshift @$data, $myRowRef;
    } elsif ($rowIdx == $numRow) {
      push @$data, $myRowRef;
     } else {
      @t = splice @$data, $rowIdx;
      push @$data, $myRowRef, @t;
    }
    return 1;
  }
  
  sub delRow {
    my ($self, $rowIdx ) = @_;
    return undef unless defined $self->checkOldRow($rowIdx);
    $self->rotate() if $self->{type};
    my $data=$self->{data};
    my @dels=splice(@$data, $rowIdx, 1);
    return shift @dels;
  }                                                                               
  
  sub delRows {
    my ($self, $rowIdcsRef) = @_;
    my $rowIdx;
    $self->rotate() if $self->{type};
    my @dels = @{$self->{data}}[@$rowIdcsRef];
    my @indices = sort { $b <=> $a } @$rowIdcsRef;
    #my @dels=();
    foreach $rowIdx (@indices) {
      #push @dels, $self->delRow($rowIdx);
      $self->delRow($rowIdx);
    }
    return @dels;
  }   
  
  # append a column to the table, input is a referenceof_array
  
  sub addCol {
    my ($self, $colRef, $colName, $colIdx) = @_;
    my $numCol=$self->nofCol();
    my @t;
    if (!defined($colRef) || ref($colRef) eq '') {
      # fill the new column with $colRef as the default value
      my @col = ($colRef) x $self->nofRow;
      $colRef = \@col;
    } else {
      confess "addCol: size of added col does not match rows in the table\n" 
      if @$colRef != $self->nofRow() and $numCol > 0; 
    }
    $colIdx=$numCol unless defined($colIdx);
    return undef unless defined $self->checkNewCol($colIdx, $colName);
    $self->rotate() unless $self->{type};
    my $data=$self->{data};
    my $header=$self->{header};
    if ($colIdx == 0) {
      unshift @$header, $colName;
    } elsif ($colIdx == $numCol) {
      push @$header, $colName;
    } else {
      @t = splice @$header, $colIdx;
      push @$header, $colName, @t;
    }
  
    if ($colIdx == 0) {
      unshift @$data, $colRef;
    } elsif ($colIdx == $numCol) {
      push @$data, $colRef;
    } else {
      @t = splice @$data, $colIdx;
      push @$data, $colRef, @t;
    }
  
    for (my $i = 0; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      $self->{colHash}->{$elm} = $i;
    }
    return 1;
  }
  
  sub delCol {
    my ($self, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    my $header=$self->{header};
    my $name=$self->{header}->[$c];
    splice @$header, $c, 1;
    my $data=$self->{data};
    my @dels=splice @$data, $c, 1;
    delete $self->{colHash}->{$name};
    for (my $i = $c; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      $self->{colHash}->{$elm} = $i;
    }
    return shift @dels;
  }                                                                               
  
  sub delCols {
    my ($self, $colIDsRef) = @_;
    my $idx;
    my @indices = map { $self->colIndex($_) } @$colIDsRef;
    $self->rotate() unless $self->{type};
    my @dels = @{$self->{data}}[@indices];
    @indices = sort { $b <=> $a } @indices;
    #my @dels=();
    foreach my $colIdx (@indices) {
      $self->delCol($colIdx);
    }
    return @dels;
  }  
  
  
  sub rowRef {
    my ($self, $rowIdx) = @_;
    return undef unless defined $self->checkOldRow($rowIdx);
    $self->rotate if $self->{type};
    return $self->{data}->[$rowIdx];
  }
  
  sub rowRefs {
    my ($self, $rowIdcsRef) = @_;
    $self->rotate if $self->{type};
    return $self->{data} unless defined $rowIdcsRef;
    my @ones = ();
    my $rowIdx;
    foreach $rowIdx (@$rowIdcsRef) {
      push @ones, $self->rowRef($rowIdx);
    }
    return \@ones;
  }
  
  sub row {
    my ($self, $rowIdx) = @_;
    my $data = $self->{data};
    return undef unless defined $self->checkOldRow($rowIdx);
    if ($self->{type}) {
      my @one=(); 
      for (my $i = 0; $i < scalar @$data; $i++) {
        push @one, $data->[$i]->[$rowIdx];
      }
      return @one;
    } else {
      return @{$data->[$rowIdx]};
    }
  }
  
  sub rowHashRef {
    my ($self, $rowIdx) = @_;
    my $data = $self->{data};
    return undef unless defined $self->checkOldRow($rowIdx);
    my $header=$self->{header};
    my $one = {};
    for (my $i = 0; $i < scalar @$header; $i++) {
      $one->{$header->[$i]} = ($self->{type})?
        $self->{data}->[$i]->[$rowIdx]:$self->{data}->[$rowIdx]->[$i];
    }
    return $one;
  }
  
  sub colRef {
    my ($self, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    return $self->{data}->[$c];
  }
  
  sub colRefs {
    my ($self, $colIDsRef) = @_;
    $self->rotate unless $self->{type};
    return $self->{data} unless defined $colIDsRef;
    my @ones = ();
    my $colID;
    foreach $colID (@$colIDsRef) {
      push @ones, $self->colRef($colID);
    }
    return \@ones;
  }
  
  sub col {
    my ($self, $colID) = @_;
    my $data = $self->{data};
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    if (!$self->{type}) {
      my @one=();
      for (my $i = 0; $i < scalar @$data; $i++) {
        push @one, $data->[$i]->[$c];
      }
      return @one;
    } else {
      return () unless ref($data->[$c]) eq "ARRAY";
      return @{$data->[$c]};
    }
  }
  
  sub rename {
    my ($self, $colID, $name) = @_;
    my $oldName;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $oldName=$self->{header}->[$c];
    return if ($oldName eq $name);
    return undef unless defined $self->checkNewCol($c, $name);
    $self->{header}->[$c]=$name;
    $self->{colHash}->{$oldName}=undef;
    $self->{colHash}->{$name}=$c;
    return 1;
  }
  
  sub replace{
    my ($self, $oldColID, $newColRef, $newName) = @_;
    my $oldName;
    my $c=$self->checkOldCol($oldColID);
    return undef unless defined $c;
    $oldName=$self->{header}->[$c];
    $newName=$oldName unless defined($newName);
    unless ($oldName eq $newName) {
    	return undef unless defined $self->checkNewCol($c, $newName);
    }
    confess "New column size ".(scalar @$newColRef)." must be ".$self->nofRow() unless (scalar @$newColRef==$self->nofRow());
    $self->rename($c, $newName);
    $self->rotate() unless $self->{type};
    my $old=$self->{data}->[$c];
    $self->{data}->[$c]=$newColRef;
    return $old;
  }
  
  sub swap{
    my ($self, $colID1, $colID2) = @_;
    my $c1=$self->checkOldCol($colID1);
    return undef unless defined $c1;
    my $c2=$self->checkOldCol($colID2);
    return undef unless defined $c2;
    my $name1=$self->{header}->[$c1];
    my $name2=$self->{header}->[$c2];
  
    $self->{header}->[$c1]=$name2;
    $self->{header}->[$c2]=$name1;
    $self->{colHash}->{$name1}=$c2;
    $self->{colHash}->{$name2}=$c1;
    $self->rotate() unless $self->{type};
    my $data1=$self->{data}->[$c1];
    my $data2=$self->{data}->[$c2];
    $self->{data}->[$c1]=$data2;
    $self->{data}->[$c2]=$data1;
    return 1;
  }
  
  sub moveCol {
    my ($self, $colID, $colIdx, $newColName) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    confess "New column location out of bound!" unless ($colIdx >= 0 && $colIdx < $self->nofCol);
    return if $c == $colIdx;
    my $colName = $self->{header}->[$c];
    my $col = $self->delCol($colID);
    $self->addCol($col, $colName, $colIdx);
    $self->rename($colIdx, $newColName) if defined $newColName;
    return 1;
  }
  
  sub checkOldRow {
    my ($self, $rowIdx) = @_;
    my $maxIdx=$self->nofRow()-1;
    unless (defined $rowIdx) {
  	print STDERR " Invalid row index\n";
  	return undef;
    }
    if ($rowIdx<0 || $rowIdx>$maxIdx) {
  	print STDERR  "Row index out of range [0..$maxIdx]" ;
  	return undef;
    }
    return $rowIdx;
  }
  
  sub checkNewRow {
    my ($self, $rowIdx) = @_;
    my $maxIdx=$self->nofRow()-1;
    unless (defined $rowIdx) {
  	print STDERR "Invalid row index: $rowIdx \n";
  	return undef;
    } 
    $maxIdx+=1;
    if ($rowIdx<0 || $rowIdx>$maxIdx) {
    	print STDERR  "Row index out of range [0..$maxIdx]" ;
  	return undef;
    }
    return $rowIdx;
  }
  
  sub checkOldCol {
    my ($self, $colID) = @_;
    my $c=$self->colIndex($colID);
    if ($c < 0) {
    	print STDERR "Invalid column $colID";
  	return undef;
    } 
    return $c;
  }
  
  sub checkNewCol {
    my ($self, $colIdx, $colName) = @_;
    my $numCol=$self->nofCol();
    unless (defined $colIdx) { 
        	print STDERR "Invalid column index $colIdx";
        	return undef;
    }	
    if ($colIdx<0 || $colIdx>$numCol) {
        	print STDERR "Column index $colIdx out of range [0..$numCol]";
    	return undef;
    }	
    if (defined $self->{colHash}->{$colName} ) {
  	print STDERR "Column name $colName already exists" ;
  	return undef;
    }
    unless ($colName =~ /\D/) { 
      	print STDERR "Invalid column name $colName" ;
  	return undef;
    }
    return $colIdx;
  }
  
  sub elm {
    my ($self, $rowIdx, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    return undef unless defined $self->checkOldRow($rowIdx);
    return ($self->{type})?
      $self->{data}->[$c]->[$rowIdx]:
      $self->{data}->[$rowIdx]->[$c];
  }
  
  sub elmRef {
    my ($self, $rowIdx, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    return undef unless defined $self->checkOldRow($rowIdx);
    return ($self->{type})?
      \$self->{data}->[$c]->[$rowIdx]:
      \$self->{data}->[$rowIdx]->[$c];
  }
  
  sub setElm {
    my ($self, $rowIdx, $colID, $val) = @_;
    $rowIdx = [$rowIdx] if ref($rowIdx) eq '';
    $colID = [$colID] if ref($colID) eq '';
    foreach my $col (@$colID) {
      my $c=$self->checkOldCol($col);
      return undef unless defined $c;
      foreach my $row (@$rowIdx) {
        return undef unless defined $self->checkOldRow($row);
        if ($self->{type}) {
          $self->{data}->[$c]->[$row]=$val;
        } else {
          $self->{data}->[$row]->[$c]=$val;
        }
      }
    }
    return 1;
  }
  
  # convert the internal structure of a table between row-based and column-based
  sub rotate {
    my $self=shift;
    my $newdata=[];
    my $data=$self->{data};
    $self->{type} = ($self->{type})?0:1;
    if ($self->{type} && scalar @$data == 0) {
      for (my $i=0; $i < $self->nofCol; $i++) {
        $newdata->[$i] = [];
      }
    } else {
      for (my $i=$#{$data->[0]}; $i>=0; $i--) {
        for (my $j=$#{$data}; $j>=0;  $j--) {
          $newdata->[$i][$j]=$data->[$j][$i];
        }
      }
    }
    $self->{data}=$newdata;
    return 1;
  }
  
  sub header {
    my ($self, $header) = @_;
    unless (defined($header)) {
      return @{$self->{header}};
    } else {
      if (scalar @$header != scalar @{$self->{header}}) {
        confess "Header array should have size ".(scalar @{$self->{header}});
      } else {
        my $colHash = checkHeader($header);
        $self->{header} = $header;
        $self->{colHash} = $colHash;
      }
    }
  }
  
  sub type {
    my $self=shift;
    return $self->{type};
  }
  
  sub data {
    my $self=shift;
    return $self->{data};
  }
  
  #  $t->sort(colID1, type1, order1, colID2, type2, order2, ... );
  #  where
  #    colID is a column index (integer) or name (string),
  #    type is 0 for numerical and 1 for others
  #    order is 0 for ascending and 1 for descending
  #    Sorting is done with priority of colname1, colname2, ...
  
  sub sort_v0 {
    my $self = shift;
    my ($str, $i) = ("", 0);
    my @cols = ();
    while (scalar @_) {
      my $c = shift;
      my $col = $self->checkOldCol($c);
      return undef unless defined $col;
      push @cols, $col;
      my $op = '<=>';
      $op = 'cmp' if shift;  				# string 
      $str .=(shift)?  "(\$b->[$i] $op \$a->[$i]) || " :
        "(\$a->[$i] $op \$b->[$i]) || " ;
      $i++;
    }
    substr($str, -3) = "";  	# removes ||  from the end of $str
    $self->rotate() if $self->{type};
    # construct a pre-ordered array
    my $fun = sub { my ($cols, $data) = @_;
    		  my @ext;
    		  @ext = map {$data->[$_]} @$cols;
    		  push @ext, $data;
    		  return \@ext;
  		};
    my @preordered = map {&$fun(\@cols, $_)} @{$self->{data}};
    $self->{data} = [ map {$_->[$i]} eval "sort {$str} \@preordered;" ];
    return 1;
  } 
    
  sub sort {
      my $self = shift;
      my @cols = @_;
      confess "Parameters be in groups of three!\n" if ($#cols % 3 != 2);
      foreach (0 .. ($#cols/3)) {
        my $col = $self->checkOldCol($cols[$_*3]);
        return undef unless defined $col;
        $cols[$_*3]=$col;
      }
      my @subs=();
      for (my $i=0; $i<=$#cols; $i+=3) {
        my $mysub;
        if ($cols[$i+1] == 0) {
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $_[1] <=> $_[0]:1):(defined($_[0])?-1:0)} : sub {defined($_[1])?(defined($_[0])? $_[0] <=> $_[1]:-1):(defined($_[0])?1:0)});
        } elsif ($cols[$i+1] == 1) {
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $_[1] cmp $_[0]:1):(defined($_[0])?-1:0)} : sub {defined($_[1])?(defined($_[0])? $_[0] cmp $_[1]:-1):(defined($_[0])?1:0)});
        } elsif (ref $cols[$i+1] eq 'CODE') {
          my $predicate=$cols[$i+1];
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $predicate->($_[1],$_[0]) : 1): (defined($_[0])?-1:0)} : 
                                 sub {defined($_[1])?(defined($_[0])? $predicate->($_[0],$_[1]) : -1): (defined($_[0])?1:0)} );
        } else {
          confess "Sort method should be 0 (numerical), 1 (other type), or a subroutine reference!\n";
        }
        push @subs, $mysub;
      }
      my $func = sub {
        my $res = 0;
        foreach (0 .. ($#cols/3)) {
          $res ||= $subs[$_]->($a->[$cols[$_*3]], $b->[$cols[$_*3]]);
          return $res unless $res==0;
        }
        return $res;
      };
      $self->rotate() if $self->{type};
      $self->{data} = [sort $func @{$self->{data}}];
      return 1;
  }
  
  # return rows as sub table in which
  # a pattern $pattern is matched 
  sub match_pattern {
    my ($self, $pattern, $countOnly) = @_;
    my @data=();
    $countOnly=0 unless defined($countOnly);
    my $cnt=0;
    $self->rotate() if $self->{type};
    @Data::Table::OK= eval "map { $pattern?1:0; } \@{\$self->{data}};";
    my @ok = @Data::Table::OK;
  	$self->{OK} = \@ok;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($self->{OK}->[$i]) {
        push @data, $self->{data}->[$i] unless $countOnly;
        $cnt++;
        $self->{OK}->[$i] = 1;
        $Data::Table::OK[$i] = 1;
      } else {
        # in case sometimes eval results is '' instead of 0
        $self->{OK}->[$i] = 0;
        $Data::Table::OK[$i] = 0;
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#ok;
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  # return rows as sub table in which
  # a pattern $pattern is matched
  # each row is passed to the patern as a hash, where column names are keys
  sub match_pattern_hash {
    my ($self, $pattern, $countOnly) = @_;
    my @data=();
    $countOnly=0 unless defined($countOnly);
    my $cnt=0;
    $self->rotate() if $self->{type};
    @Data::Table::OK = ();
    for (my $i=0; $i<$self->nofRow(); $i++) {
      local %_ = %{$self->rowHashRef($i)};
      $Data::Table::OK[$i] = eval "$pattern?1:0";
    }
    #@Data::Table::OK= eval "map { $pattern?1:0; } \@{\$self->{data}};";
    my @ok = @Data::Table::OK;
    $self->{OK} = \@ok;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($self->{OK}->[$i]) {
        push @data, $self->{data}->[$i] unless $countOnly;
        $cnt++;
        $self->{OK}->[$i] = 1;
        $Data::Table::OK[$i] = 1;
      } else {
        # in case sometimes eval results is '' instead of 0
        $self->{OK}->[$i] = 0;
        $Data::Table::OK[$i] = 0;
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#ok;
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  # return rows as sub table in which 
  # a string elm in an array @$s is matched 
  sub match_string {
    my ($self, $s, $caseIgn, $countOnly) = @_;
    confess unless defined($s);
    $countOnly=0 unless defined($countOnly);
    my @data=();
    my $r;
    $self->rotate() if $self->{type};
    @Data::Table::OK=();
    $self->{OK} = [];
    $caseIgn=0 unless defined($caseIgn);
  
    ### comment out next line if your perl version < 5.005 ###
    $r = ($caseIgn)?qr/$s/i : qr/$s/;
    my $cnt=0;
  
    foreach my $row_ref (@{$self->data}) {
      push @Data::Table::OK, 0;
      push @{$self->{OK}}, 0;
      foreach my $elm (@$row_ref) {
        next unless defined($elm);
          
          ### comment out the next line if your perl version < 5.005
        if ($elm =~ /$r/) {
          ### uncomment the next line if your perl version < 5.005
  	# if ($elm =~ /$s/ || ($elm=~ /$s/i && $caseIgn)) {
  
          push @data, $row_ref unless $countOnly;
          $Data::Table::OK[$#Data::Table::OK]=1;
          $self->{OK}->[$#{$self->{OK}}]=1;
          $cnt++;
          last;
        }
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#{$self->{OK}};
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  	
  sub rowMask {
    my ($self, $OK, $c) = @_;
    confess unless defined($OK);
    $c = 0 unless defined ($c);
    my @data=();
    $self->rotate() if $self->{type};
    my $data0=$self->data;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($c) {
        push @data, $data0->[$i] unless $OK->[$i];
      } else {
        push @data, $data0->[$i] if $OK->[$i];
      }
    }
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  sub rowMerge {
    my ($self, $tbl, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{byName} =0 unless exists $arg{byName};
    $arg{addNewCol} = 0 unless exists $arg{addNewCol};
    if ($self->isEmpty && !$tbl->isEmpty) {
      my @header = $tbl->header;
      my $i = 0;
      foreach my $s (@header) {
        push @{$self->{header}}, $s;
        $self->{colHash}->{$s} = $i++;
      }
    }
    if ($arg{byName} == 0 && $arg{addNewCol} == 0) {
      confess "Tables must have the same number of columns" unless ($self->nofCol()==$tbl->nofCol());
    } else {
      if ($arg{addNewCol}) {
        unless ($arg{byName}) { # add extra column by index
          if ($self->nofCol < $tbl->nofCol) {
            my @header = $tbl->header;
            my $nCols = $self->nofCol();
            my $nRows = $self->nofRow();
            for (my $i = $nCols; $i<@header; $i++) {
              my @one = (undef) x $nRows;
              $self->addCol(\@one, $header[$i]);
            }
          } elsif ($self->nofCol > $tbl->nofCol) {
            my @header = $self->header;
            my %h = ();
            my @header2 = $tbl->header;
            map {$h{$_} = 1} @header2;
            my $nCols = $tbl->nofCol();
            my $nRows = $tbl->nofRow();
            for (my $i = $nCols; $i<$self->nofCol; $i++) {
              my @one = (undef) x $nRows;
              # make sure new col name is unique
              my $s = $header[$i];
              my $cnt = 2;
              while (exists $h{$s}) {
                $s = $header[$i]."_".$cnt ++;
              }
              $tbl->addCol(\@one, $s);
              $h{$s} = 1;
            }
          }
        } else {
          my @header = $tbl->header;
          my $nRows = $self->nofRow();
          foreach my $col (@header) {
            if ($self->colIndex($col) < 0) {
              my @one = (undef) x $nRows;
              $self->addCol(\@one, $col);
            }
          }
        }
      }
    }
    $self->rotate() if $self->{type};
    $tbl->rotate() if $tbl->{type};
    my $data=$self->{data};
    if ($arg{byName} == 0) {
      push @$data, @{$tbl->{data}};
    } else {
      my @header = $self->header;
      my $nCols = scalar @header;
      my @colIndex = map { $tbl->colIndex($_) } @header;
      foreach my $rowRef (@{$tbl->{data}}) {
        my @one = ();
        for (my $j=0; $j< $nCols; $j++) {
          $one[$j] = $colIndex[$j]>=0 ? $rowRef->[$colIndex[$j]]:undef;
        }
        push @$data, \@one;
      }
    }
    return 1;
  }
  
  sub colMerge {
    my ($self, $tbl, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{renameCol} =0 unless exists $arg{renameCol};
    confess "Tables must have the same number of rows" unless ($self->isEmpty || $self->nofRow()==$tbl->nofRow());
    my $col;
    my %h = ();
  	map {$h{$_} = 1} @{$self->{header}};
    my @header2 = ();
    foreach $col ($tbl->header) {
      my $s = $col;
      if (exists $h{$s}) {
        confess "Duplicate column $col in two tables" unless $arg{renameCol};
        my $cnt = 2;
        while (exists $h{$s}) {
          $s = $col ."_". $cnt++;
        }
      }
      $h{$s} = 1;
      push @header2, $s;
    }
    $self->rotate() unless $self->{type};
    $tbl->rotate() unless $tbl->{type};
    my $i = $self->nofCol();
    for my $s (@header2) {
      push @{$self->{header}}, $s;
      $self->{colHash}->{$s} = $i++;
    }
    my $data=$self->{data};
    for ($i=0; $i<$tbl->nofCol(); $i++) {
      push @$data, $tbl->{data}->[$i];
    }
    return 1;
  }
  
  sub subTable {
    my ($self, $rowIdcsRef, $colIDsRef, $arg_ref) = @_;
    my @newdata=();
    my @newheader=();
    # to avoid the side effect of modifying $colIDsRef, 4/30/2012
    my $useRowMask = 0;
    $useRowMask = $arg_ref->{useRowMask} if defined $arg_ref->{useRowMask};
    my @rowIdcs = ();
    @rowIdcs = defined $rowIdcsRef ? @$rowIdcsRef : 0..($self->nofRow()-1) unless $useRowMask;
    my @colIDs = defined $colIDsRef ? @$colIDsRef : 0..($self->nofCol()-1);
    ##$rowIdcsRef = [0..($self->nofRow()-1)] unless defined $rowIdcsRef;
    #$colIDsRef = [0..($self->nofCol()-1)] unless defined $colIDsRef; 
    for (my $i = 0; $i < scalar @colIDs; $i++) {
      $colIDs[$i]=$self->checkOldCol($colIDs[$i]);
      #return undef unless defined $colIDsRef;
      push @newheader, $self->{header}->[$colIDs[$i]];
    }
    if ($useRowMask) {
      my @OK = @$rowIdcsRef;
      my $n = $self->nofRow;
      for (my $i = 0; $i < $n; $i++) {
        push @rowIdcs, $i if $OK[$i];
      }
    }
    if ($self->{type}) {
      for (my $i = 0; $i < scalar @colIDs; $i++) {
        my @one=();
        for (my $j = 0; $j < scalar @rowIdcs; $j++) {
  	      return undef unless defined $self->checkOldRow($rowIdcs[$j]);
          push @one, $self->{data}->[$colIDs[$i]]->[$rowIdcs[$j]];
        }
        push @newdata, \@one;
      }
    } else {
      for (my $i = 0; $i < scalar @rowIdcs; $i++) {
        return undef unless defined $self->checkOldRow($rowIdcs[$i]);	
        my @one=();
        for (my $j = 0; $j < scalar @colIDs; $j++) {
          push @one, $self->{data}->[$rowIdcs[$i]]->[$colIDs[$j]];
        }
        push @newdata, \@one;
      }
    }
    return new Data::Table(\@newdata, \@newheader, $self->{type});
  }
  
  sub reorder {
    my ($self, $colIDsRef, $arg_ref) = @_;
    return unless defined $colIDsRef;
    $arg_ref = {keepRest => 1} unless defined $arg_ref;
    my @newdata=();
    my @newheader=();
    my @colIDs = ();
    my %inNew = ();
    for (my $i = 0; $i < scalar @$colIDsRef; $i++) {
      my $idx = $self->checkOldCol($colIDsRef->[$i]);
      confess "Invalide column $colIDsRef->[$i]" unless defined $idx;
      $colIDs[$i] = $idx;
      $inNew{$idx} = 1;
      #return undef unless defined $colIDsRef;
      push @newheader, $self->{header}->[$idx];
    }
    if ($arg_ref->{keepRest}) {
      for (my $i = 0; $i<$self->nofCol; $i++) {
        unless (exists $inNew{$i}) {
          push @colIDs, $i;
          push @newheader, $self->{header}->[$i];
        }
      }
    }
    
    if ($self->{type}) {
      for (my $i = 0; $i < scalar @colIDs; $i++) {
        push @newdata, $self->{data}->[$colIDs[$i]];
      }
    } else {
      my $n = $self->nofRow;
      for (my $i = 0; $i < $n; $i++) {
        my @one=();
        for (my $j = 0; $j < scalar @colIDs; $j++) {
          push @one, $self->{data}->[$i]->[$colIDs[$j]];
        }
        push @newdata, \@one;
      }
    }
    $self->{header} = \@newheader;
    $self->{colHash} = ();
    for (my $i = 0; $i < scalar @colIDs; $i++) {
      $self->{colHash}->{$newheader[$i]} = $i;
    }
    $self->{data} = \@newdata;
  }
  
  sub clone {
    my $self = shift;
    my $data = $self->{data};
    my @newheader = @{$self->{header}};
    my @newdata = ();
    for (my $i = 0; $i < scalar @{$data}; $i++) {
      my @one=();
      for (my $j = 0; $j < scalar @{$data->[$i]}; $j++) {
        push @one, $data->[$i]->[$j];
      }
      push @newdata, \@one;
    }
    return new Data::Table(\@newdata, \@newheader, $self->{type});
  }
  
  sub fromCSVi {
    my $self = shift;
    return fromCSV(@_);
  }
  
  sub getOneLine {
    my ($fh, $linebreak, $qualifier) = @_;
    my $s = '';
    $qualifier = '' unless defined $qualifier;
    local($/) = $linebreak;
    return <$fh> unless $qualifier;
    while (my $s2 = <$fh>) {
      $s .= $s2;
      my @S = ($s =~ /$qualifier/g);
      return $s if (scalar @S % 2 == 0);
    }
    return $s;
  }
  
  sub fromCSV {
    my ($name_or_handler, $includeHeader, $header, $arg_ref) = @_;
    $includeHeader = 1 unless defined($includeHeader);
    my ($OS, $delimiter, $qualifier, $skip_lines, $skip_pattern, $encoding) = ($Data::Table::DEFAULTS{OS}, $Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER}, 0, undef, $Data::Table::DEFAULTS{ENCODING});
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    # OS: 0 for UNIX (\n as linebreak), 1 for Windows (\r\n as linebreak)
    ###   2 for MAC  (\r as linebreak)
    if (defined($arg_ref)) {
      $delimiter = $arg_ref->{'delimiter'} if defined($arg_ref->{'delimiter'});
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $skip_lines = $arg_ref->{'skip_lines'} if (defined($arg_ref->{'skip_lines'}) && $arg_ref->{'skip_lines'}>0);
      $skip_pattern = $arg_ref->{'skip_pattern'} if defined($arg_ref->{'skip_pattern'});
      $encoding = $arg_ref->{'encoding'} if defined($arg_ref->{'encoding'});
    }
    my @header;
    my $givenHeader = 0;
    if (defined($header) && ref($header) eq 'ARRAY') {
      $givenHeader = 1;
      @header= @$header;
    }
    my $SRC=openFileWithEncoding($name_or_handler, $encoding);
    my @data = ();
    my $oldRowDelimiter=$/;
    my $newRowDelimiter=($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    my $n_endl = length($newRowDelimiter);
    $/=$newRowDelimiter;
    my $s;
    for (my $i=0; $i<$skip_lines; $i++) {
      #$s=<$SRC>;
      $s = getOneLine($SRC, $newRowDelimiter, $qualifier);
    }
    #$s=<$SRC>;
    $s = getOneLine($SRC, $newRowDelimiter, $qualifier);
    if (defined($skip_pattern)) { while (defined($s) && $s =~ /$skip_pattern/) { $s = getOneLine($SRC, $newRowDelimiter, $qualifier); }}
    #{ $s = <$SRC> }; }
    if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
    # $_=~ s/$newRowDelimiter$//;
    unless ($s) {
      #confess "Empty data file" unless $givenHeader;
      return undef unless $givenHeader;
      $/=$oldRowDelimiter;
      return new Data::Table(\@data, \@header, 0);
    }
    my $one;
    if ($s =~ /$delimiter$/) { # if the line ends by ',', the size of @one will be incorrect
                # due to the tailing of split function in perl
      $s .= ' '; # e.g., split $s="a," will only return a list of size 1.
      $one = parseCSV($s, undef, {delimiter=>$delimiter, qualifier=>$qualifier});
      $one->[$#{@$one}]=undef;
    } else {
      $one = parseCSV($s, undef, {delimiter=>$delimiter, qualifier=>$qualifier});
    }
    #print join("|", @$one), scalar @$one, "\n";
    my $size = scalar @$one;
    unless ($givenHeader) {
      if ($includeHeader) {
        @header = @$one;
      } else {
        @header = map {"col$_"} (1..$size); # name each column as col1, col2, .. etc
      }
    }
    push @data, $one unless ($includeHeader);
  
    #while($s = <$SRC>) {
    while($s = getOneLine($SRC, $newRowDelimiter, $qualifier)) {
      next if (defined($skip_pattern) && $s =~ /$skip_pattern/);
      if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
      # $_=~ s/$newDelimiter$//;
      my $one = parseCSV($s, $size, {delimiter=>$delimiter, qualifier=>$qualifier});
      confess "Inconsistent column number at data entry: ".($#data+1) unless ($size==scalar @$one);
      push @data, $one;
    }
    close($SRC);
    $/=$oldRowDelimiter;
    return new Data::Table(\@data, \@header, 0);
  }
  
  # Idea: use \ as the escape char to encode a CSV string,
  # replace \ by \\ and comma inside a field by \c.
  # A comma inside a field must have odd number of " in front of it,
  # therefore it can be distinguished from comma used as the deliminator.
  # After escape, and split by comma, we unescape each field string.
  #
  # This parser will never be crashed by any illegal CSV format,
  # it always return an array!
  sub parseCSV {
    my ($s, $size, $arg_ref)=@_;
    $size = 0 unless defined $size;
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    $delimiter = $arg_ref->{'delimiter'} if (defined($arg_ref) && defined($arg_ref->{'delimiter'}));
    $qualifier = $arg_ref->{'qualifier'} if (defined($arg_ref) && defined($arg_ref->{'qualifier'}));
    my $delimiter2 = $delimiter; $delimiter2 = substr($delimiter, 1, 1) if length($delimiter)>1;
    my $qualifier2 = $qualifier; $qualifier2 = substr($qualifier, 1, 1) if length($qualifier)>1;
    # $s =~ s/\n$//; # chop" # assume extra characters has been cleaned before
    if (-1==index $s, $qualifier) {
      if ($size == 0) {
        my $s2 = $s;
        $s2 =~ s/$delimiter//g;
        $size = length($s)-length($s2)+1;
      }
      return [split /$delimiter/, $s , $size];
    }
    $s =~ s/\\/\\\\/g; # escape \ => \\
    my $n = length($s);
    my ($q, $i)=(0, 0);
    while ($i < $n) {
      my $ch=substr($s, $i, 1);
      $i++;
      if ($ch eq $delimiter2 && ($q%2)) {
        substr($s, $i-1, 1)='\\c'; # escape , => \c if it's not a deliminator
        $i++;
        $n++;
      } elsif ($ch eq $qualifier2) {
        $q++;
      }
    }
    $s =~ s/(^$qualifier)|($qualifier\s*$)//g; # get rid of boundary ", then restore "" => "
    $s =~ s/$qualifier\s*$delimiter/$delimiter2/g;
    $s =~ s/$delimiter\s*$qualifier/$delimiter2/g;
    $s =~ s/$qualifier$qualifier/$qualifier2/g;
    if ($size == 0) {
      my $s2 = $s;
      $s2 =~ s/$delimiter//g;
      $size = length($s)-length($s2)+1;
    }
    my @parts=split(/$delimiter/, $s, $size);
    @parts = map {$_ =~ s/(\\c|\\\\)/$1 eq '\c'?$delimiter2:'\\'/eg; $_ } @parts;
  #  my @parts2=();
  #  foreach $s2 (@parts) {
  #    $s2 =~ s/\\c/,/g;   # restore \c => ,
  #    $s2 =~ s/\\\\/\\/g; # restore \\ => \
  #    push @parts2, $s2;
  #  }
    return \@parts;
  }
  
  sub transformElement {
    my $one = shift;
    for (my $i=0; $i < scalar @$one; $i++) {
      next unless defined($one->[$i]);
      if ($one->[$i] eq "\\N") {
        $one->[$i]=undef;
      } else {
        $one->[$i] =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g;
      }
    }
    return $one;
  }
  
  sub fromTSVi {
    my $self = shift;
    return fromTSV(@_);
  }
  
  sub fromTSV {
    my ($name_or_handler, $includeHeader, $header, $arg_ref) = @_;
    my ($OS, $skip_lines, $skip_pattern, $transform_element, $encoding) = ($Data::Table::DEFAULTS{OS}, 0, undef, 1, $Data::Table::DEFAULTS{ENCODING});
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    # OS: 0 for UNIX (\n as linebreak), 1 for Windows (\r\n as linebreak)
    ###   2 for MAC  (\r as linebreak)
    $skip_lines = $arg_ref->{'skip_lines'} if (defined($arg_ref) && defined($arg_ref->{'skip_lines'}) && $arg_ref->{'skip_lines'}>0);
    $skip_pattern = $arg_ref->{'skip_pattern'} if defined($arg_ref->{'skip_pattern'});
    $transform_element = $arg_ref->{'transform_element'} if (defined($arg_ref->{'transform_element'}));
    $encoding = $arg_ref->{'encoding'} if (defined($arg_ref->{'encoding'}));
    #my %ESC = ( '0'=>"\0", 'n'=>"\n", 't'=>"\t", 'r'=>"\r", 'b'=>"\b",
    #            "'"=>"'", '"'=>"\"", '\\'=>"\\" );
    ## what about \f? MySQL treats \f as f.
  
    $includeHeader = 1 unless defined($includeHeader);
    $OS=0 unless defined($OS);
   
    my @header;
    my $givenHeader = 0;
    if (defined($header) && ref($header) eq 'ARRAY') {
      $givenHeader = 1;
      @header= @$header;
    }
    my $SRC=openFileWithEncoding($name_or_handler, $encoding);
    my @data = ();
    my $oldRowDelimiter=$/;
    my $newRowDelimiter=($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    my $n_endl = length($newRowDelimiter);
    $/=$newRowDelimiter;
    my $s;
    for (my $i=0; $i<$skip_lines; $i++) {
      $s=<$SRC>;
    }
    $s=<$SRC>;
    if (defined($skip_pattern)) { while (defined($s) && $s =~ /$skip_pattern/) { $s = <$SRC> }; }
    if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
    # $_=~ s/$newRowDelimiter$//;
    unless ($s) {
      confess "Empty data file" unless $givenHeader;
      $/=$oldRowDelimiter;
      return new Data::Table(\@data, \@header, 0);
    }
    #chop;
    my $one;
    if ($s =~ /\t$/) { # if the line ends by ',', the size of @$one will be incorrect
                # due to the tailing of split function in perl
      $s .= ' '; # e.g., split $s="a," will only return a list of size 1.
      @$one = split(/\t/, $s);
      $one->[$#{@$one}]='';
    } else {
      @$one = split(/\t/, $s);
    }
    # print join("|", @$one), scalar @$one, "\n";
    my $size = scalar @$one;
    unless ($givenHeader) {
      if ($includeHeader) {
        if ($transform_element) {
          @header = map { $_ =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g; $_ } @$one;
        } else {
          @header = @$one;
        }
      } else {
        @header = map {"col$_"} (1..$size); # name each column as col1, col2, .. etc
      }
    }
    unless ($includeHeader) {
      transformElement($one) if $transform_element;
      push @data, $one;
    }
    while($s = <$SRC>) {
      #chop;
      # $_=~ s/$newRowDelimiter$//;
      next if (defined($skip_pattern) && $s =~ /$skip_pattern/);
      if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
      my @one = split(/\t/, $s, $size);
      transformElement(\@one) if $transform_element;
      #for (my $i=0; $i < $size; $i++) {
      #  next unless defined($one[$i]);
      #  if ($one[$i] eq "\\N") {
      #    $one[$i]=undef;
      #  } else {
      #    $one[$i] =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g;
      #  }
      #}
      confess "Inconsistent column number at data entry: ".($#data+1) unless ($size==scalar @one);
      push @data, \@one;
    }
    close($SRC);
    $/=$oldRowDelimiter;
    return new Data::Table(\@data, \@header, 0);
  }
  
  sub fromSQLi {
    my $self = shift;
    return fromSQL(@_);
  }
  
  sub fromSQL {
    my ($dbh, $sql, $vars) = @_;
    my ($sth, $header, $t);
    if (ref $sql eq 'DBI::st') {
      $sth = $sql;
    } else {
      $sth = $dbh->prepare($sql) or confess "Preparing: , ".$dbh->errstr;
    }
    my @vars=() unless defined $vars;
    $sth->execute(@$vars) or confess "Executing: ".$dbh->errstr;
  #  $Data::Table::ID = undef;
  #  $Data::Table::ID = $sth->{'mysql_insertid'};
    if ($sth->{NUM_OF_FIELDS}) {
      $header=$sth->{'NAME'};
      $t = new Data::Table($sth->fetchall_arrayref(), $header, 0);
    } else {
      $t = undef;
    }
    $sth->finish;
    return $t;
  }
  
  sub join {
    my ($self, $tbl, $type, $cols1, $cols2, $arg_ref) = @_;
    my $n1 = scalar @$cols1;
    my %arg= ( renameCol => 0, matchNULL => 0, NULLasEmpty => 0);
    $arg{renameCol} = $arg_ref->{renameCol} if exists $arg_ref->{renameCol};
    $arg{matchNULL} = $arg_ref->{matchNULL} if exists $arg_ref->{matchNULL};
    $arg{NULLasEmpty} = $arg_ref->{NULLasEmpty} if exists $arg_ref->{NULLasEmpty};
    #%arg = %$arg_ref if defined $arg_ref;
    # default cols2 to cols1 if not specified
    if (!defined($cols2) && $n1>0) {
      $cols2 = [];
      foreach my $c (@$cols1) {
        push @$cols2, $c;
      }
    }
    my $n2 = scalar @$cols2;
    confess "The number of join columns must be the same: $n1 != $n2" unless $n1==$n2;
    confess "At least one join column must be specified" unless $n1;
    my ($i, $j, $k);
    my @cols3 = ();
    for ($i = 0; $i < $n1; $i++) {
      $cols1->[$i]=$self->checkOldCol($cols1->[$i]);
      confess "Unknown column ". $cols1->[$i] unless defined($cols1->[$i]);
      $cols2->[$i]=$tbl->checkOldCol($cols2->[$i]);
      confess "Unknown column ". $cols2->[$i] unless defined($cols2->[$i]);
      $cols3[$cols2->[$i]]=1;
    }
    my @cols4 = (); # the list of remaining columns
    my @header2 = ();
    for ($i = 0; $i < $tbl->nofCol; $i++) {
      unless (defined($cols3[$i])) {
        push @cols4, $i;
        push @header2, $tbl->{header}->[$i];
      }
    }
  
    $self->rotate() if $self->{type};
    $tbl->rotate() if $tbl->{type};
    my $data1 = $self->{data};
    my $data2 = $tbl->{data};
    my %H=();
    my $key;
    my @subRow;
    for ($i = 0; $i < $self->nofRow; $i++) {
      @subRow = @{$data1->[$i]}[@$cols1];
      my @S = map {tsvEscape($_)} @subRow;
      map { $_ = '' if $_ eq '\\N' } @S if $arg{NULLasEmpty};
      $key = join("\t", @S);
      unless (defined($H{$key})) {
        $H{$key} = [[$i], []];
      } else {
        push @{$H{$key}->[0]}, $i;
      }
    }
    for ($i = 0; $i < $tbl->nofRow; $i++) {
      @subRow = @{$data2->[$i]}[@$cols2];
      # we intentionally make the second table undef keys to be '\\N\\N',
      # so that they are different from the first table undef keys
      # avoid NULL == NULL in the join
      my @S = map {tsvEscape($_)} @subRow;
      map { $_ = ($arg{NULLasEmpty})? '':($arg{matchNULL} ? $_ : '\\N\\N') if $_ eq '\\N' } @S;
      #if ($j>= @S) {
      $key = join("\t", @S);
      #} else {
      #  $key = $arg{matchNULL} ? '\\N' : '\\N\\N';
      #}
      unless (defined($H{$key})) {
        $H{$key} = [[], [$i]];
      } else {
        push @{$H{$key}->[1]}, $i;
      }
    }
  # $type
  # 0: inner join
  # 1: left outer join
  # 2: right outer join
  # 3: full outer join
    my @ones = ();
    my @null1 = ();
    my @null2 = ();
    my @null3 = ();
    $null1[$self->nofCol-1]=undef;
    $null3[$self->nofCol-1]=undef;
    if ($#cols4>=0) { $null2[$#cols4]=undef; }
    foreach $key (keys %H) {
      my ($rows1, $rows2) = @{$H{$key}};
      my $nr1 = scalar @$rows1;
      my $nr2 = scalar @$rows2;
      next if ($nr1 == 0 && ($type == 0 || $type == 1));
      next if ($nr2 == 0 && ($type == 0 || $type == 2));
      if ($nr2 == 0 && ($type == 1 || $type == 3)) {
        for ($i = 0; $i < $nr1; $i++) {
          push @ones, [$self->row($rows1->[$i]), @null2];
        }
        next;
      }
      if ($nr1 == 0 && ($type == 2 || $type == 3)) {
        for ($j = 0; $j < $nr2; $j++) {
          my @row2 = $tbl->row($rows2->[$j]);
          for ($k = 0; $k< scalar @$cols1; $k++) {
            $null3[$cols1->[$k]] = $row2[$cols2->[$k]];
          }
          if ($#cols4>=0) {
            push @ones, [@null3, @row2[@cols4]];
          } else {
            push @ones, [@null3];
          } 
        }
        next;
      }
      for ($i = 0; $i < $nr1; $i++) {
        for ($j = 0; $j < $nr2; $j++) {
          my @row2 = $tbl->row($rows2->[$j]);
          push @ones, [$self->row($rows1->[$i]), @row2[@cols4]];
        }
      }
    }
    if ($arg{renameCol}) {
      my %h = ();
      map {$h{$_} = 1} @{$self->{header}};
      for (my $i=0; $i<@header2; $i++) {
        my $s = $header2[$i];
        my $cnt = 2;
        while (exists $h{$s}) {
          $s = $header2[$i] ."_". $cnt++;
        }
        $header2[$i] = $s;
        $h{$s} = 1;
      }
    }
    my $header = [@{$self->{header}}, @header2];
    return new Data::Table(\@ones, $header, 0);
  }
  
  sub melt {
    my ($self, $keyCols, $variableCols, $arg_ref) = @_;
    confess "key columns have to be specified!" unless defined($keyCols) && ref($keyCols) eq "ARRAY";
    my $variableColName = 'variable';
    my $valueColName = 'value';
    my $skip_NULL = 1;
    my $skip_empty = 0;
    $variableColName = $arg_ref->{'variableColName'} if (defined($arg_ref) && defined($arg_ref->{'variableColName'}));
    $valueColName = $arg_ref->{'valueColName'} if (defined($arg_ref) && defined($arg_ref->{'valueColName'}));
    $skip_NULL = $arg_ref->{'skip_NULL'} if (defined($arg_ref) && defined($arg_ref->{'skip_NULL'}));
    $skip_empty= $arg_ref->{'skip_empty'} if (defined($arg_ref) && defined($arg_ref->{'skip_empty'}));
    my @X = ();
    my %X = ();
    foreach my $x (@$keyCols) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $X{$x_idx} = 1;
    }
    my @Y = ();
    my %Y = ();
    unless (defined($variableCols)) {
      $variableCols = [];
      foreach my $x (0 .. $self->nofCol-1) {
        next if $X{$x};
        push @$variableCols, $x;
      }
    }
    unless (scalar @$variableCols) {
      confess "Variable columns have to be specified!";
    }
    foreach my $y (@$variableCols) {
      my $y_idx = $self->checkOldCol($y);
      confess "Unknown column ". $y unless defined($y_idx);
      push @Y, $y_idx;
      $Y{$y_idx} = 1;
    }
  
    my @newHeader = ();
    my @header = $self->header;
    for (my $i=0; $i<= $#X; $i++) {
      push @newHeader, $header[$X[$i]];
    }
    push @newHeader, $variableColName;
    push @newHeader, $valueColName;
    my @newRows = ();
    for (my $i=0; $i<$self->nofRow; $i++) {
      my $row = $self->rowRef($i);
      my @key = @$row[@X];
      foreach my $y (@Y) {
        next if (!defined($row->[$y]) && $skip_NULL);
        next if ($row->[$y] eq '' && $skip_empty);
        my @one = @key;
        push @one, $header[$y], $row->[$y];
        push @newRows, \@one;
      }
    }
    return new Data::Table(\@newRows, \@newHeader, 0);
  }
  
  sub cast {
    my ($self, $colsToGroupBy, $colToSplit, $colToSplitIsStringOrNumeric, $colToCalculate, $funToApply) = @_;
    #$colToSplit = 'variable' unless defined $colToSplit;
    #$colToCalculate = 'value' unless defined $colToCalculate;
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    my $tmpColName = '_calcColumn';
    my $cnt = 2;
    my $s = $tmpColName;
    while ($self->hasCol($s)) {
      $s = $tmpColName."_".$cnt++;
    }
    $tmpColName = $s;
    my %grpBy = ();
    map {$grpBy{$_} = 1} @$colsToGroupBy;
    my @grpBy = @$colsToGroupBy;
    confess "colToSplit cannot be contained in the list of colsToGroupBy!" if defined $colToSplit and $grpBy{$colToSplit};
    push @grpBy, $colToSplit if defined $colToSplit;
    my $t = $self->group(\@grpBy, [$colToCalculate], [$funToApply], [$tmpColName], 0);
    $t = $t->pivot($colToSplit, $colToSplitIsStringOrNumeric, $tmpColName, $colsToGroupBy);
    return $t;
  }
  
  sub each_group {
    my ($self, $colsToGroupBy, $funToApply) = @_;
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    confess "colsToGroupBy has to be specified!" unless defined($colsToGroupBy) && ref($colsToGroupBy) eq "ARRAY";
    confess "funToApply has to be a reference to CODE!" unless ref($funToApply) eq "CODE";
    unless (scalar @$colsToGroupBy) { # all rows are treated as one group
      $funToApply->($self->clone, 0 .. $self->nofRow - 1);
      return;
    }
    my @X = ();
    my %grpBy = ();
    foreach my $x (@$colsToGroupBy) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $grpBy{$x_idx} = 1;
    }
    my %X = ();
    for (my $i=0; $i<$self->nofRow; $i++) {
      my $myRow = $self->rowRef($i);
      #my @val = ();
      #foreach my $x (@X) {
      #  push @val, defined($myRow->[$x])?$myRow->[$x]:"";
      #}
      my @val = map {tsvEscape($_)} @{$myRow}[@X];
      my $myKey = CORE::join("\t", @val);
      push @{$X{$myKey}}, $i;
    }
    foreach my $myKey ( sort {$a cmp $b} keys %X) {
      $funToApply->($self->subTable($X{$myKey}, undef), $X{$myKey});
    }
  }
  
  sub group {
    my ($self, $colsToGroupBy, $colsToCalculate, $funsToApply, $newColNames, $keepRestCols) = @_;
    $keepRestCols = 1 unless defined($keepRestCols);
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    confess "colsToGroupBy has to be specified!" unless defined($colsToGroupBy) && ref($colsToGroupBy) eq "ARRAY";
    my @X = ();
    my %grpBy = ();
    foreach my $x (@$colsToGroupBy) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $grpBy{$x_idx} = 1;
    }
    my @Y = ();
    my %Y= ();
    if (defined($colsToCalculate)) {
      foreach my $y (@$colsToCalculate) {
        my $y_idx = $self->checkOldCol($y);
        confess "Unknown column ". $y unless defined($y_idx);
        push @Y, $y_idx;
        $Y{$y_idx} = 1;
      }
    }
    if (scalar @Y) {
      confess "The size of colsToCalculate, funcsToApply and newColNames should be the same!\n"
        unless (scalar @Y == scalar @$funsToApply && scalar @Y == scalar @$newColNames);
    }
  
    my @header = ();
    my @X_name = ();
    my $cnt = 0;
    my $i;
    for ($i=0; $i<$self->nofCol; $i++) {
      if ($grpBy{$i} || ($keepRestCols && !defined($Y{$i}))) {
        push @X_name, $i;
        push @header, $self->{header}->[$i];
        $cnt += 1;
      }
    }
    if (defined($newColNames)) {
      foreach my $y (@$newColNames) {
        push @header, $y;
        $cnt += 1;
      }
    }
    my @ones = ();
    my %X = ();
    my %val = ();
    my %rowIdx = ();
    my $idx = 0;
    for ($i=0; $i<$self->nofRow; $i++) {
      my @row = ();
      my $myRow = $self->rowRef($i);
      my $myKey = '(all)';
      if (@X) {
        # if colsToGroupBy is not specified, all rows has myKey = '(all)', therefore treated as one group
        my @val = map {tsvEscape($_)} @{$myRow}[@X];
        #foreach my $x (@X) {
        #  push @val, defined($myRow->[$x])?$myRow->[$x]:"";
        #}
        $myKey = CORE::join("\t", @val);
      }
      if (scalar @Y) {
        my %Y = ();
        foreach my $y (@Y) {
          next if defined($Y{$y});
          $Y{$y} = 1;
          if (defined($val{$y}->{$myKey})) {
            push @{$val{$y}->{$myKey}}, $myRow->[$y];
          } else {
            $val{$y}->{$myKey} = [$myRow->[$y]];
          }
        }
      }
      next if defined($X{$myKey});
      $X{$myKey} = 1;
      foreach my $j (@X_name) {
        push @row, $myRow->[$j];
      }
      $row[$cnt-1] = undef if (scalar @row < $cnt);
      push @ones, \@row;
      $rowIdx{$myKey} = $idx++;
    }
  
    if (scalar @Y) {
      $cnt -= scalar @Y;
      for($i=0; $i<scalar @Y; $i++) {
        foreach my $s (keys %X) {
          if (ref($funsToApply->[$i]) eq "CODE") {
            $ones[$rowIdx{$s}]->[$cnt+$i] = $funsToApply->[$i]->(@{$val{$Y[$i]}->{$s}});
          } else {
            $ones[$rowIdx{$s}]->[$cnt+$i] = scalar @{$val{$Y[$i]}->{$s}};
            #confess "The ${i}th element in the function array is not a valid reference!\n";
          }
        }
      }
    }
  
    return new Data::Table(\@ones, \@header, 0);
  }
  
  sub pivot {
    my ($self, $colToSplit, $colToSplitIsStringOrNumeric, $colToFill, $colsToGroupBy, $keepRestCols) = @_;
    $keepRestCols = 0 unless defined($keepRestCols);
    $colToSplitIsStringOrNumeric = 0 unless defined($colToSplitIsStringOrNumeric);
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    my $y = undef;
    $y = $self->checkOldCol($colToSplit) if defined $colToSplit;
    my $y_name = defined($y)?$self->{header}->[$y]:undef;
    confess "Unknown column ". $colToSplit if (!defined($y) && defined($colToSplit));
    my $z = undef;
    $z = $self->checkOldCol($colToFill) if defined($colToFill);
    my $z_name = defined($z)?$self->{header}->[$z]:undef;
    confess "Unknown column ". $colToFill if (!defined($z) && defined($colToFill));
    #confess "Cannot take colToFill, if colToSplit is 'undef'" if (defined($z) && !defined($y));
    my @X = ();
    if (defined($colsToGroupBy)) {
      foreach my $x (@$colsToGroupBy) {
        my $x_idx = $self->checkOldCol($x);
        confess "Unknown column ". $x unless defined($x_idx);
        push @X, $self->{header}->[$x_idx];
      }
    }
    my (@Y, %Y);
  
    if (defined($colToSplit)) {
      @Y = $self->col($y);
      %Y = ();
      foreach my $val (@Y) {
        $val = "NULL" unless defined($val);
        $Y{$val} = 1;
      }
    } else {
      @Y = ('(all)') x $self->nofCol;
      %Y = ('(all)' => 1);
      $colToSplitIsStringOrNumeric = 1;
    }
    if ($colToSplitIsStringOrNumeric == 0) {
      foreach my $y (keys %Y) {
        if ($y =~ /\D/) {
          $colToSplitIsStringOrNumeric = 1;
          last;
        }
      }
    }
    if ($colToSplitIsStringOrNumeric) {
      @Y = sort { $a cmp $b } (keys %Y);
    } else {
      @Y = sort { $a <=> $b } (keys %Y);
    }
  
    my @header = ();
    my $i;
    my @X_name = ();
  
    if (!$keepRestCols) {
      foreach my $x (@X) {
        push @X_name, $x;
      }
    } else {
      for ($i=0; $i<$self->nofCol; $i++) {
        next if ((defined($y) && $i==$y) || (defined($z) && $i==$z));
        push @X_name, $self->{header}->[$i];
      }
    }
    my $cnt = 0;
    for ($i=0; $i < @X_name; $i++) {
      my $s = $X_name[$i];
      while (defined($Y{$s})) {
        $s = "_".$s;
      }
      push @header, $s;
      $Y{$s} = $cnt++;
    }
  
    #if (defined($y)) {
      foreach my $val (@Y) {
        push @header, ($colToSplitIsStringOrNumeric?"":"$y_name=") . $val;
        $Y{$val} = $cnt++;
      }
    #}
  
    my @ones = ();
    my %X = ();
    my $rowIdx = 0;
    for ($i=0; $i<$self->nofRow; $i++) {
      my @row = ();
      my $myRow = $self->rowHashRef($i);
      my $myKey = '(all)'; # set to '' to work with total agreegation (group all rows into one)
      if (scalar @X) {
        my @val = ();
        foreach my $x (@X) {
          push @val, tsvEscape($myRow->{$x});
        }
        $myKey = CORE::join("\t", @val);
      }
      unless (defined($X{$myKey})) {
        foreach my $s (@X_name) {
          push @row, $myRow->{$s};
        }
        for (my $j = scalar @row; $j<$cnt; $j++) {
          $row[$j] = undef;
        }
        #$row[$cnt-1] = undef if (scalar @row < $cnt);
      }
      #if (defined($y)) {
        my $val = defined($y) ? $myRow->{$y_name} : "(all)";
        $val = "NULL" unless defined($val);
        if (!defined($X{$myKey})) {
          $row[$Y{$val}] = defined($z)?$myRow->{$z_name}: $row[$Y{$val}]+1;
        } else {
          $ones[$X{$myKey}][$Y{$val}] = defined($z)?$myRow->{$z_name}: $ones[$X{$myKey}][$Y{$val}]+1;
        }
      #}
      unless (defined($X{$myKey})) {
        push @ones, \@row;
        $X{$myKey} = $rowIdx++;
      }
    }
    return new Data::Table(\@ones, \@header, 0);
  }
  
  sub fromFileGuessOS {
    my ($name, $arg_ref) = @_;
    my @OS=("\n", "\r\n", "\r");
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    my $qualifier = '';
    my $encoding = $Data::Table::DEFAULTS{ENCODING};
    $qualifier = $arg_ref->{qualifier} if (defined($arg_ref) && exists $arg_ref->{qualifier});
    $encoding = $arg_ref->{encoding} if (defined($arg_ref) && exists $arg_ref->{encoding});
    my ($len, $os)=(-1, -1);
    my $SRC=openFileWithEncoding($name, $encoding);
    #local($/)="\n";
    my $s = getOneLine($SRC, "\n", $qualifier); #<$SRC>;
    close($SRC);
    #$s =~ s/\n$//;
    #my $myLen=length($s);
    #$s =~ s/\r$//;
    if ($s =~ /\r\n$/) {
      return 1;
    } elsif ($s =~ /\n$/) {
      return 0;
    } elsif ($s =~ /\r/) {
      return 2;
    }
    return 0;
    #if (length($s) == $myLen) {
    #  return 0;
    #} elsif (length($s) == $myLen - 1) {
    #  return 1;
    #} else {
    #  return 2;
    #}
  #  for (my $i=0; $i<@OS; $i++) {
  #    open($SRC, $name) or confess "Cannot open $name to read";
  #    binmode $SRC;
  #    local($/)=$OS[$i];
  #    my $s = <$SRC>;
  #    #print ">> $i => ". (length($s)-length($OS[$i]))."\n";
  #    my $myLen=length($s)-length($OS[$i]);
  #    if ($len<0 || ($myLen>0 && $myLen<$len)) {
  #      $len=length($s)-length($OS[$i]);
  #      $os=$i;
  #    }
  #    close($SRC);
  #  }
  #  # find the OS linebreak that gives the shortest first line
  #  return $os;
  }
  
  sub openFileWithEncoding {
    my ($name_or_handler, $encoding) = @_;
    my $isFileHandler=ref($name_or_handler) ne "";
    my $SRC;
    if ($isFileHandler) {
      $SRC = $name_or_handler; # a file handler
    } else {
      open($SRC, $name_or_handler) or confess "Cannot open $name_or_handler to read";
    }
    # check if Perl version is recent enough to support encoding
    $encoding ='' if (!$^V or $^V lt v5.8.1);
    if ($encoding) {
      $encoding='UTF-8' if ($encoding =~ /^utf-?8$/i);
      binmode($SRC, ":encoding($encoding)");
    } else {
      binmode $SRC;
    }
    return $SRC;
  }
  
  sub fromFileGetTopLines {
    my ($name, $os, $numLines, $arg_ref) = @_;
    $os = fromFileGuessOS($name) unless defined($os);
    $numLines = 2 unless defined($numLines);
    my @OS=("\n", "\r\n", "\r"); 
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    my $encoding = $Data::Table::DEFAULTS{ENCODING};
    $encoding = $arg_ref->{encoding} if (defined($arg_ref) && exists $arg_ref->{encoding});
    my @lines=();
    my $SRC = openFileWithEncoding($name, $encoding);
    local($/)=$OS[$os];
    my $n_endl = length($OS[$os]);
    my $cnt=0;
    while(my $line = <$SRC>) {
      $cnt++;
      for (1..$n_endl) { chop($line); }
      push @lines, $line;
      last if ($numLines>0 && $cnt>=$numLines);
    }
    close($SRC);
    return @lines;
  }
  
  sub fromFileIsHeader {
    my ($s, $delimiter, $allowNumericHeader) = @_;
    $delimiter=$Data::Table::DEFAULTS{'CSV_DELIMITER'} unless defined($delimiter);
    return 0 if (!defined($s) || $s eq "" || $s=~ /$delimiter$/);
    my $fields=parseCSV($s, 0, {delimiter=>$delimiter});
    my $allNumbers = 1;
    foreach my $name (@$fields) {
      return 0 unless $name;
      #next if $name=~/[^0-9.eE\-+]/;
      return 0 if $name=~/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/ && !$allowNumericHeader;
      # modified, so that we allow some columns to be numeric, but not all columns
      $allNumbers = 0 unless $name =~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/;
    }
    #return 0 if $allNumbers;
    return 1;
  }
  
  sub fromFileGuessDelimiter {
    my $s_line= shift;
    my @DELIMITER=(",","\t",":");
    my $numCol=-1; my $i=-1;
    return $Data::Table::DEFAULTS{CSV_DELIMITER} unless @$s_line;
    for (my $d=0; $d<@DELIMITER; $d++) {
      my $colFound=-1;
      foreach my $line (@$s_line) {
        unless (defined($line)) {
          return $Data::Table::DEFAULTS{CSV_DELIMITER};
        } else {
          my $header = parseCSV($line, 0, {delimiter=>$DELIMITER[$d]});
          if ($colFound<0) {
            $colFound = scalar @$header;
          } elsif ($colFound != scalar @$header) {
            $colFound = -1;
            last;
          }
        }
      }
      next if $colFound<0;
      if ($colFound>$numCol) {
        $numCol=$colFound; $i=$d;
      }
    }
    return ($i<0)?$Data::Table::DEFAULTS{CSV_DELIMITER}:$DELIMITER[$i];
  }
  
  sub fromFile {
    my ($name, $arg_ref) = @_;
    my $linesChecked = 2;
    my $os = undef;
    my $hasHeader = undef;
    my $delimiter = undef;
    my $format = undef;
    my $qualifier = $Data::Table::DEFAULTS{CSV_QUALIFIER};
    my $allowNumericHeader = 0;
    my $encoding=$Data::Table::DEFAULTS{ENCODING};
  
    if (defined($arg_ref)) {
      $linesChecked = $arg_ref->{'linesChecked'} if defined($arg_ref->{'linesChecked'});
      $os = $arg_ref->{'OS'};
      $hasHeader = $arg_ref->{'has_header'};
      $delimiter = $arg_ref->{'delimiter'};
      $format = $arg_ref->{'format'};
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $allowNumericHeader = $arg_ref->{'allowNumericHeader'};
      $encoding = $arg_ref->{'encoding'};
    }
  
    $qualifier = '' if ($format and uc($format) eq 'TSV');
    unless (defined($os)) {
      $os = fromFileGuessOS($name, {qualifier=>$qualifier, encoding=>$encoding});
      $arg_ref->{'OS'}=$os;
    }
    my @S = fromFileGetTopLines($name, $os, $linesChecked, {encoding=>$encoding});
    return undef unless scalar @S;
    unless (defined($delimiter)) {
      $delimiter = fromFileGuessDelimiter(\@S);
      $arg_ref->{'delimiter'} = $delimiter;
    }
    unless (defined($hasHeader)) {
      $hasHeader = fromFileIsHeader($S[0], $delimiter, $allowNumericHeader);
    }
    my $t = undef;
    #print ">>>". join("\n", @S)."\n";
    #print "OS=$os, hasHeader=$hasHeader, delimiter=$delimiter\n";
    if ($delimiter eq "\t") {
      $t=fromTSV($name, $hasHeader, undef, $arg_ref);
    } else {
      $t=fromCSV($name, $hasHeader, undef, $arg_ref);
    }
    return $t;
  }
  
  ## interface to GD::Graph
  # use GD::Graph::points;
  # $graph = GD::Graph::points->new(400, 300);
  # $graph->plot([$t->colRef(1), $t->colRef(2)]);
   
  1;
  
  __END__
  
  
  =head1 NAME
  
  Data::Table - Data type related to database tables, spreadsheets, CSV/TSV files, HTML table displays, etc.
  
  =head1 SYNOPSIS
  
    News: The package now includes "Perl Data::Table Cookbook" (PDF), which may serve as a better learning material.
    To download the free Cookbook, visit https://sites.google.com/site/easydatabase/
    
    # some cool ways to use Table.pm
    use Data::Table;
    
    $header = ["name", "age"];
    $data = [
      ["John", 20],
      ["Kate", 18],
      ["Mike", 23]
    ];
    $t = new Data::Table($data, $header, 0);	# Construct a table object with
  					# $data, $header, $type=0 (consider 
  					# $data as the rows of the table).
    print $t->csv;                        # Print out the table as a csv file.
  
    $t = Data::Table::fromCSV("aaa.csv");       # Read a csv file into a table object
    ### Since version 1.51, a new method fromFile can automatically guess the correct file format
    # either CSV or TSV file, file with or without a column header line
    # e.g.
    #   $t = Data::Table::fromFile("aaa.csv");
    # is equivalent.
    print $t->html;                       # Display a 'portrait' HTML TABLE on web. 
  
    use DBI;
    $dbh= DBI->connect("DBI:mysql:test", "test", "") or die $DBI::errstr;
    my $minAge = 10;
    $t = Data::Table::fromSQL($dbh, "select * from mytable where age >= ?", [$minAge]);
  					# Construct a table form an SQL 
  					# database query.
  
    $t->sort("age", 0, 0);                # Sort by col 'age',numerical,ascending
    print $t->html2;                      # Print out a 'landscape' HTML Table.  
  
    $row = $t->delRow(2);			# Delete the third row (index=2).
    $t->addRow($row, 4);			# Add the deleted row back as fifth row. 
    @rows = $t->delRows([0..2]);		# Delete three rows (row 0 to 2).
    $col = $t->delCol("age");		# Delete column 'age'.
    $t->addCol($col, "age",2);		# Add column 'age' as the third column
    @cols = $t->delCols(["name","phone","ssn"]); 
  					# Delete 3 columns at the same time. 
  
    $name =  $t->elm(2,"name");	        # Element access
    $t2=$t->subTable([1, 3..4],['age', 'name']);	
  					# Extract a sub-table 
  
    $t->rename("Entry", "New Entry");	# Rename column 'Entry' by 'New Entry'
    $t->replace("Entry", [1..$t->nofRow()], "New Entry");	
  					# Replace column 'Entry' by an array of
  					# numbers and rename it as 'New Entry'
    $t->swap("age","ssn");		# Swap the positions of column 'age' 
  					# with column 'ssn' in the table.
  
    $t->colMap('name', sub {return uc});  # Map a function to a column 
    $t->sort('age',0,0,'name',1,0);	# Sort table first by the numerical 
  					# column 'age' and then by the 
  					# string column 'name' in ascending
  					# order
    $t2=$t->match_pattern('$_->[0] =~ /^L/ && $_->[3]<0.2'); 
  					# Select the rows that matched the 
  					# pattern specified 
    $t2=$t->match_pattern_hash('$_{"Amino acid"} =~ /^L-a/ && $_{"Grams \"(a.a.)\""}<0.2'));
            # use column name in the pattern, method added in 1.62
    $t2=$t->match_string('John');		# Select the rows that matches 'John'   
  					# in any column
  
    $t2=$t->clone();			# Make a copy of the table.
    $t->rowMerge($t2);			# Merge two tables
    $t->colMerge($t2);
  
    $t = new Data::Table(                 # create an employ salary table
      [
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Peter', 'male', 'HR', 85000],
        ['Mary', 'female', 'HR', 80000],
        ['Nancy', 'female', 'IT', 55000],
        ['Jack', 'male', 'IT', 88000],
        ['Susan', 'female', 'HR', 92000]
      ],
      ['Name', 'Sex', 'Department', 'Salary'], 0);
    
    sub average {  # this is an subroutine calculate mathematical average, ignore NULL
      my @data = @_;
      my ($sum, $n) = (0, 0);
      foreach $x (@data) {
        next unless $x;
        $sum += $x; $n++;
      }
      return ($n>0)?$sum/$n:undef;
    }
    
    $t2 = $t->group(["Department","Sex"],["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"]);
    # For each (Department,Sex) pair, calculate the number of employees and average salary
    $t2 = $t2->pivot("Sex", 0, "Average Salary", ["Department"]);
    # Show average salary information in a Department by Sex spreadsheet
  
  =head1 ABSTRACT
  
  This perl package uses perl5 objects to make it easy for
  manipulating spreadsheet data among disk files, database, and Web
  publishing.
  
  A table object contains a header and a two-dimensional array of scalars.
  Four class methods Data::fromFile, Data::Table::fromCSV, Data::Table::fromTSV, and Data::Table::fromSQL allow users
  to create a table object from a CSV/TSV file or a database SQL selection in a snap.
  
  Table methods provide basic access, add, delete row(s) or column(s) operations, as well as more advanced sub-table extraction, table sorting,
  record matching via keywords or patterns, table merging, and web publishing.   
  Data::Table class also provides a straightforward interface to other
  popular Perl modules such as DBI and GD::Graph.
  
  The most updated version of the Perl Data::Table Cookbook is available at
   https://sites.google.com/site/easydatabase/
  
  We use Data::Table instead of Table, because Table.pm has already been used inside PerlQt module in CPAN.
  
  =head1 INTRODUCTION
  
  =over 4
  
  A table object has three data members:
  
  =item 1. $data:
  
  a reference to an array of array-references.
  It's basically a reference to a two-dimensional array.
  
  =item 2. $header:
  
  a reference to a string array. The array contains all the column names.
  
  =item 3. $type = 1 or 0.
  
  1 means that @$data is an array of table columns (fields) (column-based);
  0 means that @$data is an array of table rows (records) (row-based);
  
  =back
  
  Row-based/Column-based are two internal implementations for a table object.
  E.g., if a spreadsheet consists of two columns lastname and age.
  In a row-based table, $data = [ ['Smith', 29], ['Dole', 32] ].
  In a column-based table, $data = [ ['Smith', 'Dole'], [29, 32] ].
  
  Two implementations have their pros and cons for different operations.
  Row-based implementation is better for sorting and pattern matching,
  while column-based one is better for adding/deleting/swapping columns.
  
  Users only need to specify the implementation type of the table upon its
  creation via Data::Table::new, and can forget about it afterwards.
  Implementation type of a table should be considered volatile, because
  methods switch table objects from one type into another internally.
  Be advised that row/column/element references gained via table::rowRef,
  table::rowRefs, table::colRef, table::colRefs, or table::elmRef may
  become stale after other method calls afterwards.
  
  For those who want to inherit from the Data::Table class, internal method
  table::rotate is used to switch from one implementation type into another.
  There is an additional internal assistant data structure called
  colHash in our current implementation. This hash
  table stores all column names and their corresponding column index number as
  key-value pairs for fast conversion. This gives users an option to use
  column name wherever a column ID is expected, so that user don't have to use
  table::colIndex all the time. E.g., you may say
  $t->rename('oldColName', 'newColName')
  instead of $t->rename($t->colIndex('oldColName'), 'newColIdx').
  
  =head1 DESCRIPTION
  
  =head2 Field Summary
  
  =over 4
  
  =item data refto_arrayof_refto_array
  
  contains a two-dimensional spreadsheet data.
  
  =item header refto_array
  
  contains all column names.
  
  =item type 0/1
  
  0 is row-based, 1 is column-based, describe the orientation of @$data.
  
  =back
  
  =head2 Package Variables
  
  =over 4
  
  =item $Data::Table::VERSION
  
  =item @Data::Table::OK
  
  see table::match_string, table::match_pattern, and table::match_pattern_hash
  Since 1.62, we recommend you to use $table->{OK} instead, which is a local array reference.
  
  =item @Data::Table::MATCH
  
  see table::match_string, table::match_pattern, and table::match_pattern_hash
  Since 1.67, we return the matched row indices in an array.  Data::Table::MATCH is this array reference.
  Here is an example of setting a max price of 20 to all items with UnitPrice > 20.
  
      $t_product->match_pattern_hash('$_{UnitPrice} > 20');
      $t_product->setElm($t_product->{MATCH}, 'UnitPrice', 20);
  
  =item %Data::Table::DEFAULTS
  
  Store default settings, currently it contains CSV_DELIMITER (set to ','), CSV_QUALIFER (set to '"'), and OS (set to 0).
  see table::fromCSV, table::csv, table::fromTSV, table::tsv for details.
  
  =back
  
  =head2 Class Methods
  
  Syntax: return_type method_name ( [ parameter [ = default_value ]] [, parameter [ = default_value ]] )
  
  If method_name starts with table::, this is an instance method, it can be used as $t->method( parameters ), where $t is a table reference.
  
  If method_name starts with Data::Table::, this is a class method, it should be called as
    Data::Table::method, e.g., $t = Data::Table::fromCSV("filename.csv").
  
  Conventions for local variables:
  
    colID: either a numerical column index or a column name;
    rowIdx: numerical row index;
    rowIDsRef: reference to an array of column IDs;
    rowIdcsRef: reference to an array of row indices;
    rowRef, colRef: reference to an array of scalars;
    data: ref_to_array_of_ref_to_array of data values;
    header: ref to array of column headers;
    table: a table object, a blessed reference.
  
  =head2 Table Creation
  
  =over 4
  
  =item table Data::Table::new ( $data = [], $header = [], $type = 0, $enforceCheck = 1)
  
  create a new table.
  It returns a table object upon success, undef otherwise.
  $data: points to the spreadsheet data.
  $header: points to an array of column names. Before version 1.69, a column name must have at least one non-digit character. Since verison 1.69, this is relaxed. Although integer and numeric column names can now be accepted, when accessing a column by integer, it is first interpreted as a column name.
  $type: 0 or 1 for row-based/column-based spreadsheet. 
  $enforceCheck: 1/0 to turn on/off initial checking on the size of each row/column to make sure the data arguement indeed points to a valid structure.
  In 1.63, we introduce constants Data::Table::ROW_BASED and Data::Table::COL_BASED as synonyms for $type.  To create an empty Data::Table, use new Data::Table([], [], Data::Table::ROW_BASED);
  
  =item table table::subTable ($rowIdcsRef, $colIDsRef, $arg_ref)
  
  create a new table, which is a subset of the original.
  It returns a table object.
  $rowIdcsRef: points to an array of row indices (or a true/false row mask array).
  $colIDsRef: points to an array of column IDs.
  The function make a copy of selected elements from the original table. 
  Undefined $rowIdcsRef or $colIDsRef is interpreted as all rows or all columns.
  The elements in $colIDsRef may be modified as a side effect before version 1.62, fixed in 1.62.
  If $arg_ref->{useRowMask} is set to 1, $rowIdcsRef is a true/false row mask array, where rows marked as TRUE will be returned.  Row mask array is typically the Data::Table::OK set by match_string/match_pattern/match_pattern_hash methods.
  
  =item table table::clone
  
  make a clone of the original.
  It return a table object, equivalent to table::subTable(undef,undef).
  
  =item table Data::Table::fromCSV ($name_or_handler, $includeHeader = 1, $header = ["col1", ... ], {OS=>$Data::Table::DEFAULTS{'OS'}, delimiter=>$Data::Table::DEFAULTS{'CSV_DELIMITER'}, qualifier=>$Data::Table::DEFAULTS{'CSV_QUALIFIER'}, skip_lines=>0, skip_pattern=>undef, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a CSV file.
  return a table object.
  $name_or_handler: the CSV file name or an already opened file handler. If a handler is used, it's not closed upon return. To read from STDIN, use Data::Table::fromCSV(\*STDIN, 1).
  $includeHeader: 0 or 1 to ignore/interpret the first line in the file as column names,
  If it is set to 0, the array in $header is used. If $header is not supplied, the default column names are "col1", "col2", ...
  optional named argument OS specifies under which operating system the CSV file was generated. 0 for UNIX, 1 for PC and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used, which defaults to UNIX. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  
  optional name argument delimiter and qualifier let user replace comma and double-quote by other meaningful single characters. <b>Exception</b>: if the delimiter or the qualifier is a special symbol in regular expression, you must escape it by '\'. For example, in order to use pipe symbol as the delimiter, you must specify the delimiter as '\|'.
  
  optional name argument skip_lines let you specify how many lines in the csv file should be skipped, before the data are interpretted.
  
  optional name argument skip_pattern let you specify a regular expression. Lines that match the regular expression will be skipped.
  
  optional name argument encoding let you specify an encoding method of the csv file.  This option is added to fromCSV, fromTSV, fromFile since version 1.69.
  
  The following example reads a DOS format CSV file and writes a MAC format:
  
    $t = Data::Table:fromCSV('A_DOS_CSV_FILE.csv', 1, undef, {OS=>1});
    $t->csv(1, {OS=>2, file=>'A_MAC_CSV_FILE.csv'});
    open(SRC, 'A_DOS_CSV_FILE.csv') or die "Cannot open A_DOS_CSV_FILE.csv to read!";
    $t = Data::Table::fromCSV(\*SRC, 1);
    close(SRC);
  
  The following example reads a non-standard CSV file with : as the delimiter, ' as the qaulifier
  
    my $s="col_A:col_B:col_C\n1:2, 3 or 5:3.5\none:'one:two':'double\", single'''";
    open my $fh, "<", \$s or die "Cannot open in-memory file\n";
    my $t_fh=Data::Table::fromCSV($fh, 1, undef, {delimiter=>':', qualifier=>"'"});
    close($fh);
    print $t_fh->csv;
    # convert to the standard CSV (comma as the delimiter, double quote as the qualifier)
    # col_A,col_B,col_C
    # 1,"2, 3 or 5",3.5
    # one,one:two,"double"", single'"
    print $t->csv(1, {delimiter=>':', qualifier=>"'"}); # prints the csv file use the original definition
  
  The following example reads bbb.csv file (included in the package) by skipping the first line (skip_lines=>1), then treats any line that starts with '#' (or space comma) as comments (skip_pattern=>'^\s*#'), use ':' as the delimiter.
  
    $t = Data::Table::fromCSV("bbb.csv", 1, undef, {skip_lines=>1, delimiter=>':', skip_pattern=>'^\s*#'});
  
  Use the optional name argument encoding to specify file encoding method.
    $t = Data::Table::fromCSV("bbb.csv", 1, undef, {encoding=>'UTF-8'});
  
  =item table table::fromCSVi ($name, $includeHeader = 1, $header = ["col1", ... ])
  
  Same as Data::Table::fromCSV. However, this is an instant method (that's what 'i' stands for), which can be inherited.
  
  =item table Data::Table::fromTSV ($name, $includeHeader = 1, $header = ["col1", ... ], {OS=>$Data::Table::DEFAULTS{'OS'}, skip_lines=>0, skip_pattern=>undef, transform_element=>1, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a TSV file.
  return a table object.
  $name: the TSV file name or an already opened file handler. If a handler is used, it's not closed upon return.  To read from STDIN, use Data::Table::fromTSV(\*STDIN, 1).
  $includeHeader: 0 or 1 to ignore/interpret the first line in the file as column names,
  If it is set to 0, the array in $header is used. If $header is not supplied, the default column names are "col1", "col2", ...
  optional named argument OS specifies under which operating system the TSV file was generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used, which defaults to UNIX. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.  <b>Exception</b>: if the delimiter or the qualifier is a special symbol in regular expression, you must escape it by '\'. For example, in order to use pipe symbol as the delimiter, you must specify the delimiter as '\|'.
  
  optional name argument skip_lines let you specify how many lines in the csv file should be skipped, before the data are interpretted.
  
  optional name argument skip_pattern let you specify a regular expression. Lines that match the regular expression will be skipped.
  
  optional name argument transform_element let you switch on/off \t to tab, \N to undef (etc.) transformation. See TSV FORMAT for details. However, elements are always transformed when export table to tsv format, because not escaping an element containing a tab will be disasterous.
  
  optional name arugment encoding enables one to provide an encoding method when open the tsv file.
  
  See similar examples under Data::Table::fromCSV;
  
  Note: read "TSV FORMAT" section for details.
  
  =item table table::fromTSVi ($name, $includeHeader = 1, $header = ["col1", ... ])
  
  Same as Data::Table::fromTSV. However, this is an instant method (that's what 'i' stands for), which can be inherited.
  
  =item table Data::Table::fromFile ($file_name, $arg_ref = {linesChecked=>2, allowNumericHeader=>0, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a text file.
  return a table object.
  $file_name: the file name (cannot take a file handler).
  linesChecked: the first number of lines used for guessing the input format. The delimiter will have to produce the same number of columns for these lines. By default only check the first 2 lines, 0 means all lines in the file.
  $arg_ref can take additional parameters, such as OS, has_header, delimiter, transform_element, etc. Encoding allows one to specify encoding methods used to open the file, which defaults to UTF-8.
  
  fromFile is added after version 1.51. It relies on the following new methods to automatically figure out the correct file format in order to call fromCSV or fromTSV internally:
  
    fromFileGuessOS($file_name, {encoding=>'UTF-8'})
      returns integer, 0 for UNIX, 1 for PC, 2 for MAC
    fromFileGetTopLines($file_name, $os, $lineNumber, {encoding=>'UTF-8'}) # $os defaults to fromFileGuessOS($file_name), if not specified
      returns an array of strings, each string represents each row with linebreak removed.
    fromFileGuessDelimiter($lineArrayRef)       # guess delimiter from ",", "\t", ":";
      returns the guessed delimiter string.
    fromFileIsHeader($line_concent, $delimiter, $allowNumericHeader) # $delimiter defaults to $Data::Table::DEFAULTS{'CSV_DELIMITER'}
      returns 1 or 0.
  
  It first ask fromFileGuessOS to figure out which OS (UNIX, PC or MAC) generated the input file. The fetch the first linesChecked lines using fromFileGetTopLines. It then guesses the best delimiter using fromFileGuessDelimiter, then it checks if the first line looks like a column header row using fromFileIsHeader. Since fromFileGuessOS and fromFileGetTopLines needs to open/close the input file, these methods can only take file name, not file handler. If user specify formatting parameters in $arg_ref, the routine will skip the corresponding guess work. At the end, fromFile simply calls either fromCSV or fromTSV with $arg_ref forwarded. So if you call fromFile({transform_element=>0}) on a TSV file, transform_elment will be passed onto fromTSV calls internally.
  
  fromFileGuessOS finds the linebreak that gives shortest first line (in the priority of UNIX, PC, MAC upon tie).
  fromFileGuessDelimiter works based on the assumption that the correct delimiter will produce equal number of columns for the given rows. If multiple matches, it chooses the delimiter that gives maximum number of columns. If none matches, it returns the default delimiter.
  fromFileIsHeader works based on the assumption that no column header can be empty or numeric values.  However, if we allow numeric column names (especially integer column names), set {allowNumericHeader => 1}
  
  =item table Data::Table::fromSQL ($dbh, $sql, $vars)
  
  create a table from the result of an SQL selection query.
  It returns a table object upon success or undef otherwise.
  $dbh: a valid database handler. 
  Typically $dbh is obtained from DBI->connect, see "Interface to Database" or DBI.pm.
  $sql: an SQL query string or a DBI::st object (starting in version 1.61).
  $vars: optional reference to an array of variable values, 
  required if $sql contains '?'s which need to be replaced 
  by the corresponding variable values upon execution, see DBI.pm for details.
  Hint: in MySQL, Data::Table::fromSQL($dbh, 'show tables from test') will also create a valid table object.
  
  Data::Table::fromSQL now can take DBI::st instead of a SQL string. This is introduced, so that variable binding (such as CLOB/BLOB) can be done outside the method, for example:
  
    $sql = 'insert into test_table (id, blob_data) values (1, :val)';
    $sth = $dbh->prepare($sql);
    $sth->bind_param(':val', $blob, {ora_type => SQLT_BIN});
    Data::Table::fromSQL($dbh, $sth);
  
  =item table Data::Table::fromSQLi ($dbh, $sql, $vars)
  
  Same as Data::Table::fromSQL. However, this is an instant method (that's what 'i' stands for), whic
  h can be inherited.
  
  =back
  
  =head2 Table Access and Properties
  
  =over 4
  
  =item int table::colIndex ($colID)
  
  translate a column name into its numerical position, the first column has index 0 as in as any perl array.
  return -1 for invalid column names.
  
  Since 1.69, we allow integer to be used as a column header.  The integer $colID will first be checked against column names, if matched, the corresponding column index is returned. E.g., if column name for the 3rd column is "1", colIndex(1) will return 2 instead of 1! In such case, if one need to access the second column, one has to access it by column name, i.e., $t->col(($t->header)[1]).
  
  =item int table::nofCol
  
  return number of columns.
  
  =item int table::nofRow
  
  return number of rows.
  
  =item int table::lastCol
  
  return the index of the last columns, i.e., nofCol - 1.
  
  =item int table::lastRow
  
  return the index of the last rows, i.e., nofRow - 1; This is syntax sugar.
  
     # these two are equivalent
     foreach my $i (0 .. $t->lastRow)
     foreach my $i (0 .. $t->nofRow - 1)
  
  =item bool table::isEmpty
  
  return whether the table has any column, introduced in 1.63.
  
  =item bool table::hasCol($colID)
  
  returns whether the colID is a table column, introduced in 1.63.
  
  =item bool table::colName($colNumericIndex)
  
  returns the column name for a numeric column index, notice the first column has an index of 0. Introduced in 1.68.
  
  =item scalar table::elm ($rowIdx, $colID)
  
  return the value of a table element at [$rowIdx, $colID],
  undef if $rowIdx or $colID is invalid. 
  
  =item refto_scalar table::elmRef ($rowIdx, $colID)
  
  return the reference to a table element at [$rowIdx, $colID], to allow possible modification.
  It returns undef for invalid $rowIdx or $colID. 
  
  =item array table::header ($header)
  
  Without argument, it returns an array of column names.
  Otherwise, use the new header.
  
  =item int table::type
  
  return the implementation type of the table (row-based/column-based) at the time,
  be aware that the type of a table should be considered as volatile during method calls.
  
  =back
  
  =head2 Table Formatting
  
  =over 4
  
  =item string table::csv ($header, {OS=>$Data::Table::DEFAULTS{'OS'}, file=>undef, delimiter=>$Data::Table::DEFAULTS{'CSV_DELIMITER'}, qualifier=>$Data::Table::DEFAULTS{'CSV_QAULIFIER'}})
  
  return a string corresponding to the CSV representation of the table.
  $header controls whether to print the header line, 1 for yes, 0 for no.
  optional named argument OS specifies for which operating system the CSV file is generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  if 'file' is given, the csv content will be written into it, besides returning the string.
  One may specify custom delimiter and qualifier if the other than default are desired.
  
  =item string table::tsv
  
  return a string corresponding to the TSV representation of the table.
  $header controls whether to print the header line, 1 for yes, 0 for no.
  optional named argument OS specifies for which operating system the TSV file is generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  if 'file' is given, the tsv content will be written into it, besides returning the string.
  
  Note: read "TSV FORMAT" section for details.
  
  =item string table::html ($colorArrayRef_or_colorHashRef = ["#D4D4BF","#ECECE4","#CCCC99"], 
  			  $tag_tbl = {border => '1'},
                            $tag_tr  = {align => 'left'},
                            $tag_th  = {align => 'center'},
                            $tag_td  = {col3 => 'align="right" valign="bottom"', 4 => 'align="left"'},
                            $l_portrait = 1
                          )
  
  return a string corresponding to a 'Portrait/Landscape'-style html-tagged table.
  $colorArrayRef_or_colorHashRef: If a hash reference is provided, it will take three CSS class names for odd data rows, even data rows and for the header row.  The default hash is {even=>"data_table_even", odd=>"data_table_odd", header=>"data_table_header").
  If a hash reference is not found, a reference to an array of three color strings is expected to provided for backgrounds for even-row records, odd-row records, and -der row, respectively.  A default color array ("#D4D4BF","#ECECE4","#CCCC99") will be used if $colors isn't defined. 
  
  Before version 1.59, the parameter can only accept an array reference. 
  
  $tag_tbl: a reference to a hash that specifies any legal attributes such as name, border,
  id, class, etc. for the TABLE tag.
  
  $tag_tr: a reference to a hash that specifies any legal attributes for the TR tag.
  
  $tag_th: a reference to a hash that specifies any legal attributes for the TH tag.
  
  $tag_td: a reference to a hash that specifies any legal attributes for the TD tag.
  
  Notice $tag_tr and $tag_th controls all the rows and columns of the whole table. The keys of the hash are the attribute names in these cases. However, $tag_td is column specific, i.e., you should specify TD attributes for every column separately.
  The key of %$tag_td are either column names or column indices, the value is the full string to be inserted into the TD tag. E.g., $tag_td  = {col3 => 'align=right valign=bottom} only change the TD tag in "col3" to be &lt;TD align=right valign=bottom&gt;.
  
  $portrait controls the layout of the table. The default is 1, i.e., the table is shown in the
  "Portrait" style, like in Excel. 0 means "Landscape". Since version 1.59, tbody and thead tags are added to the portrait mode output.
  
  Attention: You will have to escape HTML-Entities yourself (for example '<' as '&lt;'), if you have characters in you table which need to be escaped. You can do this for example with the escapeHTML-function from CGI.pm (or the HTML::Entities module).
  
    use CGI qw(escapeHTML);
    [...]
    $t->colMap($columnname, sub{escapeHTML($_)}); # for every column, where HTML-Entities occur.
  
  =item string table::html2 ($colors = ["#D4D4BF","#ECECE4","#CCCC99"],
  		 	   $specs = {'name' => '', 'border' => '1', ...})
  
  This method is deprecated. It's here for compatibility. It now simple call html method with $portrait = 0, see previous description.
  
  return a string corresponding to a "Landscape" html-tagged table.
  This is useful to present a table with many columns, but very few entries.
  Check the above table::html for parameter descriptions.
  
  =back
  
  =head2 Table Operations
  
  =over 4
  
  =item int table::setElm ($rowIdx, $colID, $val)
  
  modify the value of a table element at [$rowIdx, $colID] to a new value $val.
  It returns 1 upon success, undef otherwise. 
  In 1.68, setElm can manipulate multiple elements, i.e., $rowIdx and $colIdx can be references to an index array, and setElm() will modifies all cells defined by the grid.
  
      $t->setElm([0..2], ['ColA', 'ColB'], 'new value');
      $t->setElm(0, [1..2], 'new value');
  
      # puts a limit on the price of all expensive items
      $t_product->match_pattern_hash('$_{UnitPrice} > 20');
      $t_product->setElm($t_product->{MATCH}, 'UnitPrice', 20);
  
  =item int table::addRow ($rowRef, $rowIdx = table::nofRow, $arg_ref = {addNewCol => 0})
  
  add a new row ($rowRef may point to the actual list of scalars, or it can be a hash_ref (supported since version 1.60)).  If $rowRef points to a hash, the method will lookup the value of a field by ts column name: $rowRef->{colName}, if not found, undef is used for that field.
  The new row will be referred as $rowIdx as the result. E.g., addRow($aRow, 0) will put the new row as the very first row. By default, it appends a row to the end.
  In 1.67, we support {addNewCol => 1}, if specified, a new column will be automatically created for each new element encountered in the $rowRef.
  
      # automatically add a new column "aNewColumn" to $t, in order to hold the new value
      $t->addRow({anExistingColumn => 123, aNewColumn => "XYZ"}, undef, {addNewCol => 1});
      # $t only had one column, after this call, it will contain a new column 'col2', in order to hold the new value
      $t->addRow([123, "XYZ"], undef, {addNewCol => 1});
  
  It returns 1 upon success, undef otherwise.
  
  =item refto_array table::delRow ( $rowIdx )
  
  delete a row at $rowIdx. It will the reference to the deleted row.
  
  =item refto_array table::delRows ( $rowIdcsRef )
  
  delete rows in @$rowIdcsRef. It will return an array of deleted rows in the same order of $rowIdcsRef upon success.
  upon success.
  
  =item int table::addCol ($colRef, $colName, $colIdx = numCol)
  
  add a new column ($colRef points to the actual data), the new column will be referred as $colName or $colIdx as the result. E.g., addCol($aCol, 'newCol', 0) will put the new column as the very first column.
  By default, append a column to the end.
  It will return 1 upon success or undef otherwise.
  In 1.68, $colRef can be a scalar, which is the default value that can be used to create the new column.  E.g., to create a new column with default value of undef, 0, 'default', respectively, one can do:
  
     $t->addCol(undef, 'NewCol');
     $t->addCol(0, 'NewIntCol');
     $t->addCol('default', 'NewStringCol');
  
  
  =item refto_array table::delCol ($colID)
  
  delete a column at $colID
  return the reference to the deleted column.
  
  =item arrayof_refto_array table::delCols ($colIDsRef)
  
  delete a list of columns, pointed by $colIDsRef. It will
  return an array of deleted columns in the same order of $colIDsRef  upon success.
  
  =item refto_array table::rowRef ($rowIdx)
  
  return a reference to the row at $rowIdx
  upon success or undef otherwise.
  
  =item refto_arrayof_refto_array table::rowRefs ($rowIdcsRef)
  
  return a reference to array of row references upon success, undef otherwise.
  
  =item array table::row ($rowIdx)
  
  return a copy of the row at $rowIdx 
  upon success or undef otherwise.
  
  =item refto_hash table::rowHashRef ($rowIdx)
  
  return a reference to a hash, which contains a copy of the row at $rowIdx,
  upon success or undef otherwise. The keys in the hash are column names, and
  the values are corresponding elements in that row. The hash is a copy, therefore modifying the hash values doesn't change the original table.
  
  =item refto_array table::colRef ($colID)
  
  return a reference to the column at $colID
  upon success.
  
  =item refto_arrayof_refto_array table::colRefs ($colIDsRef)
  
  return a reference to array of column references upon success.
  
  =item array table::col ($colID)
  
  return a copy to the column at $colID
  upon success or undef otherwise.
  
  =item int table::rename ($colID, $newName)
  
  rename the column at $colID to a $newName 
  (the newName must be valid, 
  and should not be identical to any other existing column names).
  It returns 1 upon success
  or undef otherwise.
  
  =item refto_array table::replace ($oldColID, $newColRef, $newName)
  
  replace the column at $oldColID by the array pointed by $newColRef, and renamed it to $newName. $newName is optional if you don't want to rename the column.
  It returns 1 upon success or undef otherwise.
  
  =item int table::swap ($colID1, $colID2)
  
  swap two columns referred by $colID1 and $colID2.
  It returns 1 upon success or undef otherwise.
  
  =item int table::moveCol($colID, $colIdx, $newColName)
  
  move column referred by $colID to a new location $colIdx.
  If $newColName is specified, the column will be renamed as well.
  It returns 1 upon success or undef otherwise.
  
  =item int table::reorder($colIDRefs, $arg_ref)
  
  Rearrange the columns according to the order specified in $colIDRef.  Columns not specified in the reference array will be appended to the end!
  If one would like to drop columns not specified, set $arg_ref to {keepRest => 0}.
  reorder() changes the table itself, while subTable(undef, $colIDRefs) will return a new table.  reorder() might also runs faster than subTable, as elements may not need to be copied.
  
  =item int table::colMap ($colID, $fun)
  
  foreach element in column $colID, map a function $fun to it.
  It returns 1 upon success or undef otherwise.
  This is a handy way to format a column. E.g. if a column named URL contains URL strings, colMap("URL", sub {"<a href='$_'>$_</a>"}) before html() will change each URL into a clickable hyper link while displayed in a web browser.
  
  =item int table::colsMap ($fun)
  
  foreach row in the table, map a function $fun to it.
  It can do whatever colMap can do and more.
  It returns 1 upon success or undef otherwise.
  colMap function only give $fun access to the particular element per row, while colsMap give $fun full access to all elements per row. E.g. if two columns named duration and unit (["2", "hrs"], ["30", "sec"]). colsMap(sub {$_->[0] .= " (".$_->[1].")"; } will change each row into (["2 hrs", "hrs"], ["30 sec", "sec"]).
  As show, in the $func, a column element should be referred as $_->[$colIndex].
  
  =item int table::sort($colID1, $type1, $order1, $colID2, $type2, $order2, ... )
  
  sort a table in place.
  First sort by column $colID1 in $order1 as $type1, then sort by $colID2 in $order2 as $type2, ...
  $type is 0 for numerical and 1 for others;
  $order is 0 for ascending and 1 for descending;
  
  In 1.62, instead of memorize these numbers, you can use constants instead (notice constants do not start with '$').
    Data::Table::NUMBER
    Data::Table::STRING
    Data::Table::ASC
    Data::Table::DESC
  
  Sorting is done in the priority of colID1, colID2, ...
  It returns 1 upon success or undef otherwise. 
  Notice the table is rearranged as a result! This is different from perl's list sort, which returns a sorted copy while leave the original list untouched, 
  the authors feel inplace sorting is more natural.
  
  table::sort can take a user supplied operator, this is useful when neither numerical nor alphabetic order is correct.
  
    $Well=["A_1", "A_2", "A_11", "A_12", "B_1", "B_2", "B_11", "B_12"];
    $t = new Data::Table([$Well], ["PlateWell"], 1);
    $t->sort("PlateWell", 1, 0);
    print join(" ", $t->col("PlateWell"));
    # prints: A_1 A_11 A_12 A_2 B_1 B_11 B_12 B_2
    # in string sorting, "A_11" and "A_12" appears before "A_2";
    my $my_sort_func = sub {
      my @a = split /_/, $_[0];
      my @b = split /_/, $_[1];
      my $res = ($a[0] cmp $b[0]) || (int($a[1]) <=> int($b[1]));
    };
    $t->sort("PlateWell", $my_sort_func, 0);
    print join(" ", $t->col("PlateWell"));
    # prints the correct order: A_1 A_2 A_11 A_12 B_1 B_2 B_11 B_12
  
  =item table table::match_pattern ($pattern, $countOnly)
  
  return a new table consisting those rows evaluated to be true by $pattern 
  upon success or undef otherwise. If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK (should use $t->{OK} after 1.62) stores a true/false array for the original table rows. Using it, users can find out what are the rows being selected/unselected.
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  
  In the $pattern string, a column element should be referred as $_->[$colIndex]. E.g., match_pattern('$_->[0]>3 && $_->[1]=~/^L') retrieve all the rows where its first column is greater than 3 and second column starts with letter 'L'. Notice it only takes colIndex, column names are not acceptable here!
  
  =item table table::match_pattern_hash ($pattern, $countOnly)
  
  return a new table consisting those rows evaluated to be true by $pattern
  upon success or undef otherwise. If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK stores a reference to a true/false array for the original table rows. Using it, users can find out what are the rows being selected/unselected.
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  
  In the $pattern string, a column element should be referred as ${column_name}.
  match_pattern_hash() is added in 1.62. The difference between this method and match_pattern is each row is fed to the pattern as a hash %_.
  In the case of match_pattern, each row is fed as an array ref $_.  The pattern for match_pattern_hash() becomes much cleaner.
  
  If a table has two columns: Col_A as the 1st column and Col_B as the 2nd column, a filter "Col_A>2 AND Col_B<2" is written before as
  	$t->match_pattern('$_->[0] > 2 && $_->[1] <2');
  where we need to figure out $t->colIndex('Col_A') is 0 and $t->colIndex('Col_B') is 1, in order to build the pattern.
  Now you can use column name directly in the pattern:
  	$t->match_pattern_hash('$_{Col_A} >2 && $_{Col_B} <2');
  This method creates $t->{OK}, as well as @Data::Table::OK, same as match_pattern().
  
  =item table table::match_string ($s, $caseIgnore, $countOnly)
  
  return a new table consisting those rows contains string $s in any of its fields upon success, undef otherwise. if $caseIgnore evaluated to true, case will is be ignored (s/$s/i). If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK stores a reference to a true/false array for the original table rows. 
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  Using it, users can find out what are the rows being selected/unselected.
  The $s string is actually treated as a regular expression and 
  applied to each row element, therefore one can actually specify several keywords 
  by saying, for instance, match_string('One|Other').
  
  =item table table::rowMask($mask, $complement)
  
  mask is reference to an array, where elements are evaluated to be true or false. The size of the mask must be equal to the nofRow of the table. return a new table consisting those rows where the corresponding mask element is true (or false, when complement is set to true).
  
  E.g., $t1=$tbl->match_string('keyword'); $t2=$tbl->rowMask(\@Data::Table::OK, 1) creates two new tables. $t1 contains all rows match 'keyword', while $t2 contains all other rows.
  
  mask is reference to an array, where elements are evaluated to be true or false. The size of the mask must be equal to the nofRow of the table. return
   a new table consisting those rows where the corresponding mask element is true (or false, when complement is set to true).
  
  E.g., $t1=$tbl->match_string('keyword'); $t2=$tbl->rowMask(\@Data::Table::OK, 1) creates two new tables. $t1 contains all rows match 'keyword', while 
  $t2 contains all other rows.
  
  =item table table::iterator({$reverse => 0})
  
  Returns a reference to a enumerator routine, which enables one to loop through each table row. If $reverse is set to 1, it will enumerate backward.  The convenience here is each row is fetch as a rowHashRef, so one can easily access row elements by name.
  
      my $next = $t_product->iterator();
      while (my $row = $next->()) {
        # have access to a row as a hash reference, access row number by &$next(1);
        $t_product->setElm($next->(1), 'ProductName', 'New! '.$row->{ProductName});
      }
  
  In this example, each $row is fetched as a hash reference, so one can access the elements by $row->{colName}.
  Be aware that the elements in the hash is a copy of the original table elements, so modifying $row->{colName} does not modify the original table.  If table modification is intended, one needs to obtain the row index of the returned row.  $next->(1) call with a non-empty argument returns the row index of the record that was previously fetched with $next->().  In this example, one uses the row index to modify the original table.
  
  =item table table::each_group($colsToGroupBy, $funsToApply)
  
  Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first (keys sorted as string). Then for each group, subroutines $funToAppy is applied to corresponding rows.
  $funToApply are passed with two parameters ($tableRef, $rowIDsRef). All rows sharing the key are passed in as a Data::Table object (with all columns and in the order of ascending row index) in the first parameter.
  The second optional parameter contains an array of row indices of the group members.  Since all rows in the passed-in table contains the same keys, the key value can be obtained from its first table row.
  
  =item table table::group($colsToGroupBy, $colsToCalculate, $funsToApply, $newColNames, $keepRestCols)
  
  Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first. Then for each group, an array of subroutines (in $funsToAppy) are applied to corresponding columns and yield a list of new columns (specified in $newColNames).
  
  $colsToGroupBy, $colsToCalculate are references to array of colIDs. $funsToApply is a reference to array of subroutine references. $newColNames are a
  reference to array of new column name strings. If specified, the size of arrays pointed by $colsToCalculate, $funsToApply and $newColNames should be i
  dentical. A column may be used more than once in $colsToCalculate. 
  
  $keepRestCols is default to 1 (was introduced as 0 in 1.64, changed to 1 in 1.66 for backward compatibility) introduced in 1.64), otherwise, the remaining columns are returned with the first encountered value of that group.
  
  E.g., an employee salary table $t contains the following columns: Name, Sex, Department, Salary. (see examples in the SYNOPSIS)
  
    $t2 = $t->group(["Department","Sex"],["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"], 0);
  
  Department, Sex are used together as the primary key columns, a new column "Nof Employee" is created by counting the number of employee names in each group, a new column "Average Salary" is created by averaging the Salary data falled into each group. As the result, we have the head count and average salary information for each (Department, Sex) pair. With your own functions (such as sum, product, average, standard deviation, etc), group method is very handy for accounting purpose.
  If primary key columns are not defined, all records will be treated as one group.
  
    $t2 = $t->group(undef,["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"], 0);
  
  The above statement will output the total number of employees and their average salary as one line.
  
  =item table table::pivot($colToSplit, $colToSplitIsStringOrNumeric, $colToFill, $colsToGroupBy, $keepRestCols)
  
  Every unique values in a column (specified by $colToSplit) become a new column. undef value become "NULL".  $colToSplitIsStringOrNumeric is set to numeric (0 or Data::Table:NUMBER), the new column names are prefixed by "oldColumnName=". The new cell element is filled by the value specified by $colToFill (was 1/0 before version 1.63).
  
  Note: yes, it seems I made an incompatible change in version 1.64, where $colToSplitIsStringOrNumber used to be $colToSplitIsNumeric, where 0 meant STRING and 1 meant NUMBER.  Now it is opposite.  However, I also added auto-type detection code, that this parameter essentially is auto-guessed and most old code should behave the same as before.
  
  When primary key columns are specified by $colsToGroupBy, all records sharing the same primary key collapse into one row, with values in $colToFill filling the corresponding new columns. If $colToFill is not specified, a cell is filled with the number of records fall into that cell.
  
  $colToSplit and $colToFill are colIDs. $colToSplitIsNumeric is 1/0. $colsToGroupBy is a reference to array of colIDs. $keepRestCols is 1/0, by default is 0. If $keepRestCols is off, only primary key columns and new columns are exported, otherwise, all the rest columns are exported as well.
  
  E.g., applying pivot method to the resultant table of the example of the group method.
  
    $t2->pivot("Sex", 0, "Average Salary",["Department"]);
  
  This creates a 2x3 table, where Departments are use as row keys, Sex (female and male) become two new columns. "Average Salary" values are used to fill the new table elements. Used together with group method, pivot method is very handy for accounting type of analysis.
  If $colsToGroupBy is left as undef, all rows are treated as one group.  If $colToSplit is left as undef, the method will generate a column named "(all)" that matches all records share the corresponding primary key.
  
  =item table table::melt($keyCols, $variableCols, $arg_ref)
  
  The idea of melt() and cast() are taken from Hadley Wickham's Reshape package in R language.
  A table is first melt() into a tall-skiny format, where measurements are stored in the format of a variable-value pair per row.
  Such a format can then be easily cast() into various contingency tables.
  
  One needs to specify the columns consisting of primary keys, columns that are consider as variable columns.  The output variable column is named 'variable' unless specified by $arg_ref{variableColName}.  The output value column is named 'value', unless specified in $arg_ref{valueColName}.  By default NULL values are not output, unless $arg_ref{skip_NULL} is set to false.  By default empty string values are kept, unless one sets skip_empty to `.
  
    For each object (id), we measure variable x1 and x2 at two time points
    $t = new Data::Table([[1,1,5,6], [1,2,3,5], [2,1,6,1], [2,2,2,4]], ['id','time','x1','x2'], Data::Table::ROW_BASED);
    # id	time	x1	x2
    # 1	1	5	6
    # 1	2	3	5
    # 2	1	6	1
    # 2	2	2	4
  
    # melting a table into a tall-and-skinny table
    $t2 = $t->melt(['id','time']);
    #id      time    variable        value
    # 1       1       x1      5
    # 1       1       x2      6
    # 1       2       x1      3
    # 1       2       x2      5
    # 2       1       x1      6
    # 2       1       x2      1
    # 2       2       x1      2
    # 2       2       x2      4
    
    # casting the table, &average is a method to calculate mean
    # for each object (id), we calculate average value of x1 and x2 over time
    $t3 = $t2->cast(['id'],'variable',Data::Table::STRING,'value', \&average);
    # id      x1      x2
    # 1       4       5.5
    # 2       4       2.5
   
  
  =item table table::cast($colsToGroupBy, $colToSplit, $colToSplitIsStringOrNumeric, $colToCalculate, $funToApply)
  
  see melt(), as melt() and cast() are meant to use together.
  
  The table has been melten before.  cast() group the table according to primary keys specified in $colsToGroupBy. For each group of objects sharing the same id,
  it further groups values (specified by $colToCalculate) according to unique variable names (specified by $colToSplit).  Then it applies subroutine $funToApply to obtain an aggregate value.
  For the output, each unique primary key will be a row, each unique variable name will become a column, the cells are the calculated aggregated value.
  
  If $colsToGroupBy is undef, all rows are treated as within the same group.  If $colToSplit is undef, a new column "(all)" is used to hold the results.
  
    $t = new Data::Table( # create an employ salary table
      [
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Peter', 'male', 'HR', 85000],
        ['Mary', 'female', 'HR', 80000],
        ['Nancy', 'female', 'IT', 55000],
        ['Jack', 'male', 'IT', 88000],
        ['Susan', 'female', 'HR', 92000]
      ],
      ['Name', 'Sex', 'Department', 'Salary'], Data::Table::ROW_BASED);
  
    # get a Department x Sex contingency table, get average salary across all four groups
    print $t->cast(['Department'], 'Sex', Data::Table::STRING, 'Salary', \&average)->csv(1);
    Department,female,male
    IT,55000,73600
    HR,86000,85000
    # get average salary for each department
    print $t->cast(['Department'], undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    Department,(all)
    IT,70500
    HR,85666.6666666667
  
    # get average salary for each gender
    print $t->cast(['Sex'], undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    Sex,(all)
    male,75500
    female,75666.6666666667
    
    # get average salary for all records
    print $t->cast(undef, undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    (all)
    75555.5555555556
  
  =back
  
  =head2 Table-Table Manipulations
  
  =over 4
  
  =item int table::rowMerge ($tbl, $argRef)
  
  Append all the rows in the table object $tbl to the original rows.
  Before 1.62, the merging table $tbl must have the same number of columns as the original, as well as the columns are in exactly the same order.
  It returns 1 upon success, undef otherwise.
  The table object $tbl should not be used afterwards, since it becomes part of
  the new table.
  
  Since 1.62, you may provide {byName =>1, addNewCol=>1} as $argRef.  If byName is set to 1, the columns in in $tbl do not need to be in the same order as they are in the first table, instead the column name is used for the matching.  If addNewCol is set to 1, if $tbl contains a new column name that does not already exist in the first table, this new column will be automatically added to the resultant table.  Typically, you want to specify there two options simultaneously.
  
  =item int table::colMerge ($tbl, $argRef)
  
  Append all the columns in table object $tbl to the original columns. 
  Table $tbl must have the same number of rows as the original.
  It returns 1 upon success, undef otherwise.
  Table $tbl should not be used afterwards, since it becomes part of
  the new table.
  
  Since 1.62, you can specify {renameCol => 1} as $argRef. This is to auto fix any column name collision.  If $tbl contains a column that already exists in the first table, it will be renamed (by a suffix _2) to avoid the collision.
  
  =item table table::join ($tbl, $type, $cols1, $cols2, $argRef)
  
  Join two tables. The following join types are supported (defined by $type):
  
  0: inner join
  1: left outer join
  2: right outer join
  3: full outer join
  
  In 1.62, instead of memorize these numbers, you can use constants instead (notice constants do not start with '$').
    Data::Table::INNER_JOIN
    Data::Table::LEFT_JOIN
    Data::Table::RIGHT_JOIN
    Data::Table::FULL_JOIN
  
  $cols1 and $cols2 are references to array of colIDs, where rows with the same elements in all listed columns are merged. As the result table, columns listed in $cols2 are deleted, before a new table is returned.
  
  The implementation is hash-join, the running time should be linear with respect to the sum of number of rows in the two tables (assume both tables fit in memory).
  
  If the non-key columns of the two tables share the same name, the routine will fail, as the result table cannot contain two columns of the same name.  In 1.62, one can specify {renameCol=>1} as $argRef, so that the second column will be automatically renamed (with suffix _2) to avoid collision.
  
  If you would like to treat the NULLs in the key columns as empty string, set {NULLasEmpty => 1}.  If you do not want to treat NULLs as empty strings, but you still like the NULLs in two tables to be considered as equal (but not equal to ''), set {matchNULL => 1}.  Obviously if NULLasEmpty is set to 1, matchNULL will have no effect.
  
  =back
  
  =head2 Internal Methods
  
  All internal methods are mainly implemented for used by 
  other methods in the Table class. Users should avoid using them.
  Nevertheless, they are listed here for developers who 
  would like to understand the code and may derive a new class from Data::Table.
  
  =over 4
  
  =item int table::rotate
  
  convert the internal structure of a table between row-based and column-based.
  return 1 upon success, undef otherwise.
  
  =item string csvEscape($string, {delimiter=>, qualifier})
  
  Encode a scalar into a CSV-formatted field.
  
  optional named arguments: delimiter and qualifier, in case user wants to use characters other than the defaults. 
  The default delimiter and qualifier is taken from $Data::Table::DEFAULTS{'CSV_DELIMITER'} (defaults to ',') and $Data::Table::DEFAULTS{'CSV_QUALIFIER'} (defaults to '"'), respectively.
  
  Please note that this function only escape one element in a table. To escape the whole table row, you need to
    join($delimiter, map {csvEscape($_)} @row . $endl;
  $endl refers to End-of-Line, which you may or may not want to add, and it is OS-dependent. Therefore, csvEscape method is kept to the simplest form as an element transformer.
  
  =item refto_array parseCSV($string)
  
  Break a CSV encoded string to an array of scalars (check it out, we did it the cool way).
  
  optional argument size: specify the expected number of fields after csv-split.
  optional named arguments: delimiter and qualifier, in case user wants to use characters other than the defaults.
  respectively. The default delimiter and qualifier is taken from $Data::Table::DEFAULTS{'CSV_DELIMITER'} (defaults to ',') and $Data::Table::DEFAULTS{'CSV_QUALIFIER'} (defaults to '"'), respectively.
  
  =item string tsvEscape($rowRef)
  
  Encode a scalar into a TSV-formatted string.
  
  =back
  
  =head1 TSV FORMAT
  
  There is no standard for TSV format as far as we know. CSV format can't handle binary data very well, therefore, we choose the TSV format to overcome this limitation.
  
  We define TSV based on MySQL convention.
  
    "\0", "\n", "\t", "\r", "\b", "'", "\"", and "\\" are all escaped by '\' in the TSV file.
    (Warning: MySQL treats '\f' as 'f', and it's not escaped here)
    Undefined values are represented as '\N'.
  
  However, you can switch off this transformation by setting {transform_element => 0} in the fromTSV or tsv method.
  Before if a cell reads 'A line break is \n', it is read in as 'A link break is [return]' in memory. When use tsv method to export, it is transformed back to 'A line break is \n'. However, if it is exported as a csv, the [return] will break the format. Now if transform_element is set to 0, the cell is stored as 'A line break is \n' in memory, so that csv export will be correct. However, do remember to set {transform_element => 0} in tsv export method, otherwise, the cell will become 'A line break is \\n'. Be aware that trasform_element controls column headers as well.
  
  =head1 INTERFACE TO OTHER SOFTWARES
  
  Spreadsheet is a very generic type, therefore Data::Table class provides an easy
  interface between databases, web pages, CSV/TSV files, graphics packages, etc.
  
  Here is a summary (partially repeat) of some classic usages of Data::Table.
  
  =head2 Interface to Database and Web
  
    use DBI;
  
    $dbh= DBI->connect("DBI:mysql:test", "test", "") or die $DBI::errstr;
    my $minAge = 10;
    $t = Data::Table::fromSQL($dbh, "select * from mytable where age >= ?", [$minAge]);
    print $t->html;
  
  =head2 Interface to CSV/TSV
  
    $t = fromFile("mydata.csv"); # after version 1.51
    $t = fromFile("mydata.tsv"); # after version 1.51
  
    $t = fromCSV("mydata.csv");
    $t->sort(1,1,0);
    print $t->csv;
  
    Same for TSV
  
  =head2 Interface to Excel XLS/XLSX
  
  Read in two tables from NorthWind.xls file, writes them out to XLSX format.  See Data::Table::Excel module for details.
  
    use Data::Table::Excel;
  
    my ($tableObjects, $tableNames)=xls2tables("NorthWind.xls");
    $t_category = $tableObjects[0];
    $t_product = $tableObjects[1];
  
    tables2xlsx("NorthWind.xlsx", [$t_category, $t_product]);
  
  =head2 Interface to Graphics Package
  
    use GD::Graph::points;
  
    $graph = GD::Graph::points->new(400, 300);
    $t2 = $t->match('$_->[1] > 20 && $_->[3] < 35.7');
    my $gd = $graph->plot($t->colRefs([0,2]));
    open(IMG, '>mygraph.png') or die $!;
    binmode IMG;
    print IMG $gd->png;
    close IMG;
  
  =head1 AUTHOR
  
  Copyright 1998-2008, Yingyao Zhou & Guangzhou Zou. All rights reserved.
  
  It was first written by Zhou in 1998, significantly improved and maintained by Zou since 1999. The authors thank Tong Peng and Yongchuang Tao for valuable suggestions. We also thank those who kindly reported bugs, some of them are acknowledged in the "Changes" file.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please send bug reports and comments to: easydatabase at gmail dot com. When sending
  bug reports, please provide the version of Table.pm, the version of
  Perl.
  
  =head1 SEE ALSO
  
    DBI, GD::Graph, Data::Table::Excel.
  
  =cut
  
DATA_TABLE

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.12';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  $Devel::StackTrace::VERSION = '1.31';
  BEGIN {
    $Devel::StackTrace::AUTHORITY = 'cpan:DROLSKY';
  }
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      # Backwards compatibility - this parameter was renamed to no_refs
      # ages ago.
      $p{no_refs} = delete $p{no_object_refs}
          if exists $p{no_object_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data();
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      # We exclude this method by starting one frame back.
      my $x = 1;
      while (
          my @c
          = $self->{no_args}
          ? caller( $x++ )
          : do {
              package    # the newline keeps dzil from adding a version here
                  DB;
              @DB::args = ();
              caller( $x++ );
          }
          ) {
  
          my @args;
  
          unless ( $self->{no_args} ) {
              @args = @DB::args;
  
              if ( $self->{no_refs} ) {
                  @args = map { ref $_ ? $self->_ref_to_string($_) : $_ } @args;
              }
          }
  
          push @{ $self->{raw} },
              {
              caller => \@c,
              args   => \@args,
              };
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      local $@;
      local $SIG{__DIE__};
  
      my $str = eval { $ref . '' };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next unless $filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub { 1 };
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          local $@;
          local $SIG{__DIE__};
  
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless eval { @{ $self->{ignore_package} } };
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $p    = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $p,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames();
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames();
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  }
  
  sub frames {
      my $self = shift;
  
      if (@_) {
          die
              "Devel::StackTrace->frames() can only take Devel::StackTrace::Frame args\n"
              if grep { !$_->isa('Devel::StackTrace::Frame') } @_;
  
          $self->{frames} = \@_;
      }
      else {
          $self->_make_frames() if $self->{raw};
      }
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames() )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames() );
  }
  
  sub as_string {
      my $self = shift;
      my $p    = shift;
  
      my $st    = '';
      my $first = 1;
      foreach my $f ( $self->frames() ) {
          $st .= $f->as_string( $first, $p ) . "\n";
          $first = 0;
      }
  
      return $st;
  }
  
  {
      package
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 1.31
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new();
  
    print $trace->as_string(); # like carp
  
    # from top (most recent) of stack to bottom.
    while ( my $frame = $trace->next_frame() ) {
        print "Has args\n" if $frame->hasargs();
    }
  
    # from bottom (least recent) of stack to top.
    while ( my $frame = $trace->prev_frame() ) {
        print "Sub: ", $frame->subroutine(), "\n";
    }
  
  =head1 DESCRIPTION
  
  The C<Devel::StackTrace> module contains two classes, C,Devel::StackTrace> and
  L<Devel::StackTrace::Frame>. These objects encapsulate the information that
  can retrieved via Perl's C<caller()> function, as well as providing a simple
  interface to this data.
  
  The C<Devel::StackTrace> object contains a set of C<Devel::StackTrace::Frame>
  objects, one for each level of the stack. The frames contain all the data
  available from C<caller()>.
  
  This code was created to support my L<Exception::Class::Base> class (part of
  L<Exception::Class>) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top' and
  'bottom'. In this context, the 'top' frame on the stack is the most recent
  frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new();  # top frame is here.
    }
  
  =head1 METHODS
  
  This class provide the following methods:
  
  =head2 Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 4
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the
  call to its constructor.
  
  However, you may want to filter out some frames with more granularity
  than 'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data
  for each frame. This is a hash reference with two keys, "caller", and
  "args", both of which are array references. The "caller" key is the
  raw data as returned by Perl's C<caller()> function, and the "args"
  key are the subroutine arguments found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or
  false if it should be skipped.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on
  the stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages
  (or is the same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package'
  parameter, meaning that the Devel::StackTrace package is B<ALWAYS>
  ignored. However, if you create a subclass of Devel::StackTrace it
  will not be ignored.
  
  =item * no_refs => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store
  references internally when generating stacktrace frames. This lets
  your objects go out of scope.
  
  Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * no_args => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store caller
  arguments in stack trace frames at all.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef()> to get
  the underlying string representation of an object, instead of
  respecting the object's stringification overloading. If you would
  prefer to see the overloaded representation of objects in stack
  traces, then set this parameter to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for each
  subroutine call. Setting this parameter causes truncates each subroutine
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess()>.
  
  =back
  
  =head2 $trace->next_frame()
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going
  down. If this method hasn't been called before it returns the first frame. It
  returns C<undef> when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<< $trace->next_frame() >> or C<<
  $trace->prev_frame() >> will work properly.
  
  =head2 $trace->prev_frame()
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going up. If
  this method hasn't been called before it returns the last frame. It returns
  undef when it reaches the top of the stack and then resets its pointer so the
  next call to C<< $trace->next_frame() >> or C<< $trace->prev_frame() >> will
  work properly.
  
  =head2 $trace->reset_pointer
  
  Resets the pointer so that the next call to C<< $trace->next_frame() >> or C<<
  $trace->prev_frame() >> will start at the top or bottom of the stack, as
  appropriate.
  
  =head2 $trace->frames()
  
  When this method is called with no arguments, it returns a list of
  L<Devel::StackTrace::Frame> objects. They are returned in order from top (most
  recent) to bottom.
  
  This method can also be used to set the object's frames if you pass it a list
  of L<Devel::StackTrace::Frame> objects.
  
  This is useful if you want to filter the list of frames in ways that are more
  complex than can be handled by the C<< $trace->filter_frames() >> method:
  
    $stacktrace->frames( my_filter( $stacktrace->frames() ) );
  
  =head2 $trace->frame($index)
  
  Given an index, this method returns the relevant frame, or undef if there is
  no frame at that index. The index is exactly like a Perl array. The first
  frame is 0 and negative indexes are allowed.
  
  =head2 $trace->frame_count()
  
  Returns the number of frames in the trace object.
  
  =head2 $trace->as_string(\%p)
  
  Calls C<< $frame->as_string() >> on each frame from top to bottom, producing
  output quite similar to the Carp module's cluck/confess methods.
  
  The optional C<\%p> parameter only has one option. The C<max_arg_length>
  parameter truncates each subroutine argument's string representation if it is
  longer than this number of characters.
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AStackTrace
  or via email at bug-devel-stacktrace@rt.cpan.org.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  $Devel::StackTrace::Frame::VERSION = '1.31';
  BEGIN {
    $Devel::StackTrace::Frame::AUTHORITY = 'cpan:DROLSKY';
  }
  
  use strict;
  use warnings;
  
  # Create accessor routines
  BEGIN {
      no strict 'refs';
      foreach my $f (
          qw( package filename line subroutine hasargs
          wantarray evaltext is_require hints bitmask args )
          ) {
          next if $f eq 'args';
          *{$f} = sub { my $s = shift; return $s->{$f} };
      }
  }
  
  {
      my @fields = (
          qw( package filename line subroutine hasargs wantarray
              evaltext is_require hints bitmask )
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@fields} = @{ shift() };
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          $self->{args} = shift;
  
          $self->{respect_overload} = shift;
  
          $self->{max_arg_length} = shift;
  
          $self->{message} = shift;
  
          $self->{indent} = shift;
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
      my $p     = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked.  All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  $_ = "undef", next unless defined $_;
  
                  # hack!
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
  
                  local $SIG{__DIE__};
                  local $@;
  
                  eval {
                      my $max_arg_length
                          = exists $p->{max_arg_length}
                          ? $p->{max_arg_length}
                          : $self->{max_arg_length};
  
                      if ( $max_arg_length
                          && length $_ > $max_arg_length ) {
                          substr( $_, $max_arg_length ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 1.31
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =for Pod::Coverage new
  
  =head1 METHODS
  
  See Perl's C<caller()> documentation for more information on what these
  methods return.
  
  =head2 $frame->package()
  
  =head2 $frame->filename()
  
  =head2 $frame->line()
  
  =head2 $frame->subroutine()
  
  =head2 $frame->hasargs()
  
  =head2 $frame->wantarray()
  
  =head2 $frame->evaltext()
  
  Returns undef if the frame was not part of an eval.
  
  =head2 $frame->is_require()
  
  Returns undef if the frame was not part of a require.
  
  =head2 $frame->args()
  
  Returns the arguments passed to the frame.  Note that any arguments
  that are references are returned as references, not copies.
  
  =head2 $frame->hints()
  
  =head2 $frame->bitmask()
  
  =head2 $frame->as_string()
  
  Returns a string containing a description of the frame.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE_FRAME

$fatpacked{"Devel/TypeTiny/Perl56Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL56COMPAT';
  package Devel::TypeTiny::Perl56Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  
  #### B doesn't provide perlstring() in 5.6. Monkey patch it.
  
  use B ();
  
  unless (exists &B::perlstring)
  {
  	my $d;
  	*B::perlstring = sub {
  		no warnings 'uninitialized';
  		require Data::Dumper;
  		$d ||= 'Data::Dumper'->new([])->Indent(0)->Purity(0)->Pad('')->Useqq(1)->Terse(1)->Freezer('')->Toaster('');
  		my $perlstring = $d->Values([''.shift])->Dump;
  		($perlstring =~ /^"/) ? $perlstring : qq["$perlstring"];
  	};
  }
  
  push @B::EXPORT_OK, 'perlstring';
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl56Compat - shims to allow Type::Tiny to run on Perl 5.6.x
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<B> to export a
  C<perlstring> function, as this was only added in Perl 5.8.0.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL56COMPAT

$fatpacked{"Devel/TypeTiny/Perl58Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL58COMPAT';
  package Devel::TypeTiny::Perl58Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  
  #### re doesn't provide is_regexp in Perl < 5.10
  
  eval 'require re';
  
  unless (exists &re::is_regexp)
  {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object($_[0])->MAGIC->TYPE eq 'r' };
  	};
  }
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl58Compat - shims to allow Type::Tiny to run on Perl 5.8.x
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<re> to provide a
  C<is_regexp> function, as this was only added in Perl 5.9.5.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL58COMPAT

$fatpacked{"Error/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY';
  package Error::TypeTiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::VERSION   = '0.038';
  }
  
  use overload
  	q[""]    => sub { $_[0]->to_string },
  	q[bool]  => sub { 1 },
  	fallback => 1,
  ;
  
  our %CarpInternal;
  $CarpInternal{$_}++ for qw(
  	Eval::TypeTiny
  	Eval::TypeTiny::Sandbox
  	Exporter::Tiny
  	Test::TypeTiny
  	Type::Coercion
  	Type::Coercion::Union
  	Error::TypeTiny
  	Type::Library
  	Type::Params
  	Type::Registry
  	Types::Standard
  	Types::Standard::_Stringable
  	Types::TypeTiny
  	Type::Tiny
  	Type::Tiny::Class
  	Type::Tiny::Duck
  	Type::Tiny::Enum
  	Type::Tiny::Intersection
  	Type::Tiny::Role
  	Type::Tiny::Union
  	Type::Utils
  );
  
  sub new
  {
  	my $class = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	return bless \%params, $class;
  }
  
  sub throw
  {
  	my $class = shift;
  	
  	my ($level, @caller, %ctxt) = 0;
  	while (
  		defined scalar caller($level) and $CarpInternal{scalar caller($level)}
  	) { $level++ };
  	if ( ((caller($level - 1))[1]||"") =~ /^parameter validation for '(.+?)'$/ )
  	{
  		my ($pkg, $func) = ($1 =~ m{^(.+)::(\w+)$});
  		$level++ if caller($level) eq ($pkg||"");
  	}
  	@ctxt{qw/ package file line /} = caller($level);
  	
  	my $stack = undef;
  	if (our $StackTrace)
  	{
  		require Devel::StackTrace;
  		$stack = "Devel::StackTrace"->new(
  			ignore_package => [ keys %CarpInternal ],
  		);
  	}
  	
  	die(
  		our $LastError = $class->new(
  			context     => \%ctxt,
  			stack_trace => $stack,
  			@_,
  		)
  	);
  }
  
  sub message     { $_[0]{message} ||= $_[0]->_build_message };
  sub context     { $_[0]{context} };
  sub stack_trace { $_[0]{stack_trace} };
  
  sub to_string
  {
  	my $e = shift;
  	my $c = $e->context;
  	my $m = $e->message;
  	
  	$m =~ /\n\z/s ? $m :
  	$c            ? sprintf("%s at %s line %s.\n", $m, $c->{file}||'file?', $c->{line}||'NaN') :
  	sprintf("%s\n", $m);
  }
  
  sub _build_message
  {
  	return 'An exception has occurred';
  }
  
  sub croak
  {
  	my ($fmt, @args) = @_;
  	@_ = (
  		__PACKAGE__,
  		message => sprintf($fmt, @args),
  	);
  	goto \&throw;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny - exceptions for Type::Tiny and friends
  
  =head1 SYNOPSIS
  
     use Data::Dumper;
     use Try::Tiny;
     use Types::Standard qw(Str);
     
     try {
        Str->assert_valid(undef);
     }
     catch {
        my $exception = shift;
        warn "Encountered Error: $exception";
        warn Dumper($exception->explain)
           if $exception->isa("Error::TypeTiny::Assertion");
     };
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  When Type::Tiny and its related modules encounter an error, they throw an
  exception object. These exception objects inherit from Error::TypeTiny.
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< throw(%attributes) >>
  
  Constructs an exception and passes it to C<die>.
  
  Automatically populates C<context> and C<stack_trace> if appropriate.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<message>
  
  The error message.
  
  =item C<context>
  
  Hashref containing the package, file and line that generated the error.
  
  =item C<stack_trace>
  
  A more complete stack trace. This feature requires L<Devel::StackTrace>;
  use the C<< $StackTrace >> package variable to switch it on.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<to_string>
  
  Returns the message, followed by the context if it is set.
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< Error::TypeTiny::croak($format, @args) >>
  
  Functional-style shortcut to C<throw> method. Takes an C<sprintf>-style
  format string and optional arguments to construct the C<message>.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to call C<to_string>.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< %Error::TypeTiny::CarpInternal >>
  
  Serves a similar purpose to C<< %Carp::CarpInternal >>.
  
  =item C<< $Error::TypeTiny::StackTrace >>
  
  Boolean to toggle stack trace generation.
  
  =item C<< $Error::TypeTiny::LastError >>
  
  A reference to the last exception object thrown.
  
  =back
  
  =head1 CAVEATS
  
  Although Error::TypeTiny objects are thrown for errors produced by
  Type::Tiny, that doesn't mean every time you use Type::Tiny you'll get
  Error::TypeTinys whenever you want.
  
  For example, if you use a Type::Tiny type constraint in a Moose attribute,
  Moose will not call the constraint's C<assert_valid> method (which throws
  an exception). Instead it will call C<check> and C<get_message> (which do
  not), and will C<confess> an error message of its own. (The C<< $LastError >>
  package variable may save your bacon.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>,
  L<Error::TypeTiny::WrongNumberOfParameters>.
  
  L<Try::Tiny>, L<Try::Tiny::ByClass>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY

$fatpacked{"Error/TypeTiny/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_ASSERTION';
  package Error::TypeTiny::Assertion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Error::TypeTiny::Assertion::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Assertion::VERSION   = '0.038';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub type               { $_[0]{type} };
  sub value              { $_[0]{value} };
  sub varname            { $_[0]{varname} ||= '$_' };
  sub attribute_step     { $_[0]{attribute_step} };
  sub attribute_name     { $_[0]{attribute_name} };
  
  sub has_type           { defined $_[0]{type} }; # sic
  sub has_attribute_step { exists $_[0]{attribute_step} };
  sub has_attribute_name { exists $_[0]{attribute_name} };
  
  sub new
  {
  	my $class = shift;
  	my $self  = $class->SUPER::new(@_);
  	
  	if (ref $Method::Generate::Accessor::CurrentAttribute)
  	{
  		require B;
  		my %d = %{$Method::Generate::Accessor::CurrentAttribute};
  		$self->{attribute_name} = $d{name} if defined $d{name};
  		$self->{attribute_step} = $d{step} if defined $d{step};
  		
  		if (defined $d{init_arg})
  		{
  			$self->{varname} = sprintf('$args->{%s}', B::perlstring($d{init_arg}));
  		}
  		elsif (defined $d{name})
  		{
  			$self->{varname} = sprintf('$self->{%s}', B::perlstring($d{name}));
  		}
  	}
  	
  	return $self;
  }
  
  sub message
  {
  	my $e = shift;
  	$e->varname eq '$_'
  		? $e->SUPER::message
  		: sprintf('%s (in %s)', $e->SUPER::message, $e->varname);
  }
  
  sub _build_message
  {
  	my $e = shift;
  	$e->has_type
  		? sprintf('%s did not pass type constraint "%s"', Type::Tiny::_dd($e->value), $e->type)
  		: sprintf('%s did not pass type constraint', Type::Tiny::_dd($e->value))
  }
  
  *to_string = sub
  {
  	my $e = shift;
  	my $msg = $e->message;
  	
  	my $c = $e->context;
  	$msg .= sprintf(" at %s line %s", $c->{file}||'file?', $c->{line}||'NaN') if $c;
  	
  	my $explain = $e->explain;
  	return $msg unless @{ $explain || [] };
  	
  	$msg .= "\n";
  	for my $line (@$explain) {
  		$msg .= "    $line\n";
  	}
  	
  	return $msg;
  } if $] >= 5.008;
  
  sub explain
  {
  	my $e = shift;
  	return undef unless $e->has_type;
  	$e->type->validate_explain($e->value, $e->varname);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Assertion - exception when a value fails a type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This exception is thrown when a value fails a type constraint assertion.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type>
  
  The type constraint that was checked against. Weakened links are involved,
  so this may end up being C<undef>.
  
  =item C<value>
  
  The value that was tested.
  
  =item C<varname>
  
  The name of the variable that was checked, if known. Defaults to C<< '$_' >>.
  
  =item C<attribute_name>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will tell you which attribute (if
  your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =item C<attribute_step>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will contain either C<< "isa check" >>
  or C<< "coercion" >> to indicate which went wrong (if your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_type>, C<has_attribute_name>, C<has_attribute_step>
  
  Predicate methods.
  
  =item C<message>
  
  Overridden to add C<varname> to the message if defined.
  
  =item C<explain>
  
  Attempts to explain why the value did not pass the type constraint. Returns
  an arrayref of strings providing step-by-step reasoning; or returns undef if
  no explanation is possible.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_ASSERTION

$fatpacked{"Error/TypeTiny/Compilation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_COMPILATION';
  package Error::TypeTiny::Compilation;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::Compilation::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Compilation::VERSION   = '0.038';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub code        { $_[0]{code} };
  sub environment { $_[0]{environment} ||= {} };
  sub errstr      { $_[0]{errstr} };
  
  sub _build_message
  {
  	my $self = shift;
  	sprintf("Failed to compile source because: %s", $self->errstr);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Compilation - exception for Eval::TypeTiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Thrown when compiling a closure fails. Common causes are problems with
  inlined type constraints, and syntax errors when coercions are given as
  strings of Perl code.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<code>
  
  The Perl source code being compiled.
  
  =item C<environment>
  
  Hashref of variables being closed over.
  
  =item C<errstr>
  
  Error message from Perl compiler.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_COMPILATION

$fatpacked{"Error/TypeTiny/WrongNumberOfParameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS';
  package Error::TypeTiny::WrongNumberOfParameters;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::WrongNumberOfParameters::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::WrongNumberOfParameters::VERSION   = '0.038';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub minimum    { $_[0]{minimum} };
  sub maximum    { $_[0]{maximum} };
  sub got        { $_[0]{got} };
  
  sub has_minimum { exists $_[0]{minimum} };
  sub has_maximum { exists $_[0]{maximum} };
  
  sub _build_message
  {
  	my $e = shift;
  	if ($e->has_minimum and $e->has_maximum and $e->minimum == $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	elsif ($e->has_minimum and $e->has_maximum and $e->minimum < $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d to %d",
  			$e->got,
  			$e->minimum,
  			$e->maximum,
  		);
  	}
  	elsif ($e->has_minimum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected at least %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	else
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d",
  			$e->got,
  		);
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::WrongNumberOfParameters - exception for Type::Params
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Thrown when a Type::Params compiled check is called with the wrong number
  of parameters.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<minimum>
  
  The minimum expected number of parameters.
  
  =item C<maximum>
  
  The maximum expected number of parameters.
  
  =item C<got>
  
  The number of parameters actually passed to the compiled check.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_minimum>, C<has_maximum>
  
  Predicate methods.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS

$fatpacked{"Eval/Closure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_CLOSURE';
  package Eval::Closure;
  BEGIN {
    $Eval::Closure::AUTHORITY = 'cpan:DOY';
  }
  {
    $Eval::Closure::VERSION = '0.11';
  }
  use strict;
  use warnings;
  # ABSTRACT: safely and cleanly create closures via string eval
  
  use Exporter 'import';
  @Eval::Closure::EXPORT = @Eval::Closure::EXPORT_OK = 'eval_closure';
  
  use Carp;
  use overload ();
  use Scalar::Util qw(reftype);
  use Try::Tiny;
  
  use constant HAS_LEXICAL_SUBS => $] >= 5.018;
  
  
  
  sub eval_closure {
      my (%args) = @_;
  
      # default to copying environment
      $args{alias} = 0 if !exists $args{alias};
  
      $args{source} = _canonicalize_source($args{source});
      _validate_env($args{environment} ||= {});
  
      $args{source} = _line_directive(@args{qw(line description)})
                    . $args{source}
          if defined $args{description} && !($^P & 0x10);
  
      my ($code, $e) = _clean_eval_closure(@args{qw(source environment alias)});
  
      if (!$code) {
          if ($args{terse_error}) {
              die "$e\n";
          }
          else {
              croak("Failed to compile source: $e\n\nsource:\n$args{source}")
          }
      }
  
      return $code;
  }
  
  sub _canonicalize_source {
      my ($source) = @_;
  
      if (defined($source)) {
          if (ref($source)) {
              if (reftype($source) eq 'ARRAY'
               || overload::Method($source, '@{}')) {
                  return join "\n", @$source;
              }
              elsif (overload::Method($source, '""')) {
                  return "$source";
              }
              else {
                  croak("The 'source' parameter to eval_closure must be a "
                      . "string or array reference");
              }
          }
          else {
              return $source;
          }
      }
      else {
          croak("The 'source' parameter to eval_closure is required");
      }
  }
  
  sub _validate_env {
      my ($env) = @_;
  
      croak("The 'environment' parameter must be a hashref")
          unless reftype($env) eq 'HASH';
  
      for my $var (keys %$env) {
          if (HAS_LEXICAL_SUBS) {
              croak("Environment key '$var' should start with \@, \%, \$, or \&")
                  unless $var =~ /^([\@\%\$\&])/;
          }
          else {
              croak("Environment key '$var' should start with \@, \%, or \$")
                  unless $var =~ /^([\@\%\$])/;
          }
          croak("Environment values must be references, not $env->{$var}")
              unless ref($env->{$var});
      }
  }
  
  sub _line_directive {
      my ($line, $description) = @_;
  
      $line = 1 unless defined($line);
  
      return qq{#line $line "$description"\n};
  }
  
  sub _clean_eval_closure {
      my ($source, $captures, $alias) = @_;
  
      my @capture_keys = sort keys %$captures;
  
      if ($ENV{EVAL_CLOSURE_PRINT_SOURCE}) {
          _dump_source(_make_compiler_source($source, $alias, @capture_keys));
      }
  
      my ($compiler, $e) = _make_compiler($source, $alias, @capture_keys);
      my $code;
      if (defined $compiler) {
          $code = $compiler->(@$captures{@capture_keys});
      }
  
      if (defined($code) && (!ref($code) || ref($code) ne 'CODE')) {
          $e = "The 'source' parameter must return a subroutine reference, "
             . "not $code";
          undef $code;
      }
  
      if ($alias) {
          require Devel::LexAlias;
          Devel::LexAlias::lexalias($code, $_, $captures->{$_})
              for grep !/^\&/, keys %$captures;
      }
  
      return ($code, $e);
  }
  
  sub _make_compiler {
      my $source = _make_compiler_source(@_);
  
      return @{ _clean_eval($source) };
  }
  
  sub _clean_eval {
      local $@;
      local $SIG{__DIE__};
      my $compiler = eval $_[0];
      my $e = $@;
      [ $compiler, $e ];
  }
  
  $Eval::Closure::SANDBOX_ID = 0;
  
  sub _make_compiler_source {
      my ($source, $alias, @capture_keys) = @_;
      $Eval::Closure::SANDBOX_ID++;
      my $i = 0;
      return join "\n", (
          "package Eval::Closure::Sandbox_$Eval::Closure::SANDBOX_ID;",
          'sub {',
              (map { _make_lexical_assignment($_, $i++, $alias) } @capture_keys),
              $source,
          '}',
      );
  }
  
  sub _make_lexical_assignment {
      my ($key, $index, $alias) = @_;
      my $sigil = substr($key, 0, 1);
      my $name = substr($key, 1);
      if (HAS_LEXICAL_SUBS && $sigil eq '&') {
          my $tmpname = '$__' . $name . '__' . $index;
          return 'use feature "lexical_subs"; '
               . 'no warnings "experimental::lexical_subs"; '
               . 'my ' . $tmpname . ' = $_[' . $index . ']; '
               . 'my sub ' . $name . ' { goto ' . $tmpname . ' }';
      }
      if ($alias) {
          return 'my ' . $key . ';';
      }
      else {
          return 'my ' . $key . ' = ' . $sigil . '{$_[' . $index . ']};';
      }
  }
  
  sub _dump_source {
      my ($source) = @_;
  
      my $output;
      if (try { require Perl::Tidy }) {
          Perl::Tidy::perltidy(
              source      => \$source,
              destination => \$output,
              argv        => [],
          );
      }
      else {
          $output = $source;
      }
  
      warn "$output\n";
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Eval::Closure - safely and cleanly create closures via string eval
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Eval::Closure;
  
    my $code = eval_closure(
        source      => 'sub { $foo++ }',
        environment => {
            '$foo' => \1,
        },
    );
  
    warn $code->(); # 1
    warn $code->(); # 2
  
    my $code2 = eval_closure(
        source => 'sub { $code->() }',
    ); # dies, $code isn't in scope
  
  =head1 DESCRIPTION
  
  String eval is often used for dynamic code generation. For instance, C<Moose>
  uses it heavily, to generate inlined versions of accessors and constructors,
  which speeds code up at runtime by a significant amount. String eval is not
  without its issues however - it's difficult to control the scope it's used in
  (which determines which variables are in scope inside the eval), and it's easy
  to miss compilation errors, since eval catches them and sticks them in $@
  instead.
  
  This module attempts to solve these problems. It provides an C<eval_closure>
  function, which evals a string in a clean environment, other than a fixed list
  of specified variables. Compilation errors are rethrown automatically.
  
  =head1 FUNCTIONS
  
  =head2 eval_closure(%args)
  
  This function provides the main functionality of this module. It is exported by
  default. It takes a hash of parameters, with these keys being valid:
  
  =over 4
  
  =item source
  
  The string to be evaled. It should end by returning a code reference. It can
  access any variable declared in the C<environment> parameter (and only those
  variables). It can be either a string, or an arrayref of lines (which will be
  joined with newlines to produce the string).
  
  =item environment
  
  The environment to provide to the eval. This should be a hashref, mapping
  variable names (including sigils) to references of the appropriate type. For
  instance, a valid value for environment would be C<< { '@foo' => [] } >> (which
  would allow the generated function to use an array named C<@foo>). Generally,
  this is used to allow the generated function to access externally defined
  variables (so you would pass in a reference to a variable that already exists).
  
  In perl 5.18 and greater, the environment hash can contain variables with a
  sigil of C<&>. This will create a lexical sub in the evaluated code (see
  L<feature/The 'lexical_subs' feature>). Using a C<&> sigil on perl versions
  before lexical subs were available will throw an error.
  
  =item alias
  
  If set to true, the coderef returned closes over the variables referenced in
  the environment hashref. (This feature requires L<Devel::LexAlias>.) If set to
  false, the coderef closes over a I<< shallow copy >> of the variables.
  
  If this argument is omitted, Eval::Closure will currently assume false, but
  this assumption may change in a future version.
  
  =item description
  
  This lets you provide a bit more information in backtraces. Normally, when a
  function that was generated through string eval is called, that stack frame
  will show up as "(eval n)", where 'n' is a sequential identifier for every
  string eval that has happened so far in the program. Passing a C<description>
  parameter lets you override that to something more useful (for instance,
  L<Moose> overrides the description for accessors to something like "accessor
  foo at MyClass.pm, line 123").
  
  =item line
  
  This lets you override the particular line number that appears in backtraces,
  much like the C<description> option. The default is 1.
  
  =item terse_error
  
  Normally, this function appends the source code that failed to compile, and
  prepends some explanatory text. Setting this option to true suppresses that
  behavior so you get only the compilation error that Perl actually reported.
  
  =back
  
  =head1 BUGS
  
  No known bugs.
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/eval-closure/issues>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Method::Accessor>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Eval::Closure
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Eval-Closure>
  
  =item * Github
  
  L<https://github.com/doy/eval-closure>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Eval-Closure>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Eval-Closure>
  
  =back
  
  =head1 NOTES
  
  Based on code from L<Class::MOP::Method::Accessor>, by Stevan Little and the
  Moose Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EVAL_CLOSURE

$fatpacked{"Eval/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_TYPETINY';
  package Eval::TypeTiny;
  
  use strict;
  
  BEGIN {
  	*HAS_LEXICAL_SUBS = ($] >= 5.018) ? sub(){!!1} : sub(){!!0};
  };
  
  {
  	my $hlv;
  	sub HAS_LEXICAL_VARS () {
  		$hlv = !! eval { require Devel::LexAlias } unless defined $hlv;
  		return $hlv;
  	}
  }
  
  sub _clean_eval
  {
  	local $@;
  	local $SIG{__DIE__};
  	my $r = eval $_[0];
  	my $e = $@;
  	return ($r, $e);
  }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  our @EXPORT    = qw( eval_closure );
  our @EXPORT_OK = qw( HAS_LEXICAL_SUBS HAS_LEXICAL_VARS );
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  use warnings;
  
  sub eval_closure
  {
  	my (%args) = @_;
  	my $src    = ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source};
  	
  	$args{alias}  = 0 unless defined $args{alias};
  	$args{line}   = 1 unless defined $args{line};
  	$args{description} =~ s/[^\w .:-\[\]\(\)\{\}\']//g if defined $args{description};
  	$src = qq{#line $args{line} "$args{description}"\n$src} if defined $args{description} && !($^P & 0x10);
  	$args{environment} ||= {};
  	
  #	for my $k (sort keys %{$args{environment}})
  #	{
  #		next if $k =~ /^\$/ && ref($args{environment}{$k}) =~ /^(SCALAR|REF)$/;
  #		next if $k =~ /^\@/ && ref($args{environment}{$k}) eq q(ARRAY);
  #		next if $k =~ /^\%/ && ref($args{environment}{$k}) eq q(HASH);
  #		
  #		require Error::TypeTiny;
  #		Error::TypeTiny::croak("Expected a variable name and ref; got %s => %s", $k, $args{environment}{$k});
  #	}
  	
  	my $sandpkg   = 'Eval::TypeTiny::Sandbox';
  	my $alias     = exists($args{alias}) ? $args{alias} : 0;
  	my @keys      = sort keys %{$args{environment}};
  	my $i         = 0;
  	my $source    = join "\n" => (
  		"package $sandpkg;",
  		"sub {",
  		map(_make_lexical_assignment($_, $i++, $alias), @keys),
  		$src,
  		"}",
  	);
  	
  	_manufacture_ties() if $alias && !HAS_LEXICAL_VARS;
  	
  	my ($compiler, $e) = _clean_eval($source);
  	if ($e)
  	{
  		chomp $e;
  		require Error::TypeTiny::Compilation;
  		"Error::TypeTiny::Compilation"->throw(
  			code        => (ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source}),
  			errstr      => $e,
  			environment => $args{environment},
  		);
  	}
  	
  	my $code = $compiler->(@{$args{environment}}{@keys});
  	undef($compiler);
  
  	if ($alias && HAS_LEXICAL_VARS) {
  		Devel::LexAlias::lexalias($code, $_, $args{environment}{$_}) for grep !/^\&/, @keys;
  	}
  	
  	return $code;
  }
  
  my $tmp;
  sub _make_lexical_assignment
  {
  	my ($key, $index, $alias) = @_;
  	my $name = substr($key, 1);
  	
  	if (HAS_LEXICAL_SUBS and $key =~ /^\&/) {
  		$tmp++;
  		my $tmpname = '$__LEXICAL_SUB__'.$tmp;
  		return
  			"no warnings 'experimental::lexical_subs';".
  			"use feature 'lexical_subs';".
  			"my $tmpname = \$_[$index];".
  			"my sub $name { goto $tmpname };";
  	}
  	
  	if (!$alias) {
  		my $sigil = substr($key, 0, 1);
  		return "my $key = $sigil\{ \$_[$index] };";
  	}
  	elsif (HAS_LEXICAL_VARS) {
  		return "my $key;";
  	}
  	else {
  		my $tieclass = {
  			'@' => 'Eval::TypeTiny::_TieArray',
  			'%' => 'Eval::TypeTiny::_TieHash',
  			'$' => 'Eval::TypeTiny::_TieScalar',
  		}->{ substr($key, 0, 1) };
  		
  		return sprintf(
  			'tie(my(%s), "%s", $_[%d]);',
  			$key,
  			$tieclass,
  			$index,
  		);
  	}
  }
  
  { my $tie; sub _manufacture_ties { $tie ||= eval <<'FALLBACK'; } }
  no warnings qw(void once uninitialized numeric);
  
  {
  	package #
  		Eval::TypeTiny::_TieArray;
  	require Tie::Array;
  	our @ISA = qw( Tie::StdArray );
  	sub TIEARRAY {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(@$self) and return tied(@$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(@$self) and tied(@$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied @{$_[0]} },
  		q[""]    => sub { '' . tied @{$_[0]} },
  		q[0+]    => sub { 0  + tied @{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieHash;
  	require Tie::Hash;
  	our @ISA = qw( Tie::StdHash );
  	sub TIEHASH {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(%$self) and return tied(%$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(%$self) and tied(%$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied %{$_[0]} },
  		q[""]    => sub { '' . tied %{$_[0]} },
  		q[0+]    => sub { 0  + tied %{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieScalar;
  	require Tie::Scalar;
  	our @ISA = qw( Tie::StdScalar );
  	sub TIESCALAR {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied($$self) and return tied($$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied($$self) and tied($$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied ${$_[0]} },
  		q[""]    => sub { '' . tied ${$_[0]} },
  		q[0+]    => sub { 0  + tied ${$_[0]} },
  		fallback => 1,
  	;
  }
  
  1;
  FALLBACK
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas coderefs
  
  =head1 NAME
  
  Eval::TypeTiny - utility to evaluate a string of Perl code in a clean environment
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This module is used by Type::Tiny to compile coderefs from strings of
  Perl code, and hashrefs of variables to close over.
  
  =head2 Functions
  
  This module exports one function, which works much like the similarly named
  function from L<Eval::Closure>:
  
  =over
  
  =item C<< eval_closure(source => $source, environment => \%env, %opt) >>
  
  =back
  
  =head2 Constants
  
  The following constants may be exported, but are not by default.
  
  =over
  
  =item C<< HAS_LEXICAL_SUBS >>
  
  Boolean indicating whether Eval::TypeTiny has support for lexical subs.
  (This feature requires Perl 5.18.)
  
  =item C<< HAS_LEXICAL_VARS >>
  
  Don't worry; closing over lexical variables in the closures is always
  supported! However, if this constant is true, it means that
  L<Devel::LexAlias> is available, which makes them slightly faster than
  the fallback solution which uses tied variables. (This only makes any
  difference when the C<< alias => 1 >> option is used.)
  
  =back
  
  =head1 EVALUATION ENVIRONMENT
  
  The evaluation is performed in the presence of L<strict>, but the absence of
  L<warnings>. (This is different to L<Eval::Closure> which enables warnings for
  compiled closures.)
  
  The L<feature> pragma is not active in the evaluation environment, so the
  following will not work:
  
     use feature qw(say);
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { say for @_ }',
     );
     $say_all->("Hello", "World");
  
  The L<feature> pragma does not "carry over" into the stringy eval. It is
  of course possible to import pragmas into the evaluated string as part of the
  string itself:
  
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { use feature qw(say); say for @_ }',
     );
     $say_all->("Hello", "World");
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Eval::Closure>, L<Error::TypeTiny::Compilation>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EVAL_TYPETINY

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  
  sub import
  {
  	my $class       = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	my @args        = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts        = mkopt(\@args);
  	
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	my @want;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		$name =~ /^[:-](.+)$/
  			? push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts))
  			: push(@want, $opt);
  	}
  	
  	$class->_exporter_validate_opts($global_opts);
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	
  	for my $wanted (@want)
  	{
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  # Called once per import, passed the "global" import options. Expected to
  # validate the import options and carp or croak if there are problems. Can
  # also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts
  {
  	1;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return map [$_ => $value], $tags->{$name}->($class, @_)
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return map [$_ => $value], @{$tags->{$name}}
  		if exists $tags->{$name};
  	
  	return map [$_ => $value], @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"}
  		if $name eq 'all';
  	
  	return map [$_ => $value], @{"$class\::EXPORT"}
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	_croak("Could not find sub '$name' to export in package '$class'");
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name = $value->{-as} || $name;
  	unless (ref($name) eq q(SCALAR))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return $installer->($globals, [$name, $sym]) if $installer;
  	return ($$name = $sym)                       if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym)               if ref($into) eq q(HASH);
  	
  	require B;
  	for (grep ref, $into->can($name))
  	{
  		my $stash = B::svref_2object($_)->STASH;
  		next unless $stash->can("NAME");
  		$stash->NAME eq $into
  			and _croak("Refusing to overwrite local sub '$name' with export from $class");
  	}
  	
  	no strict qw(refs);
  	*{"$into\::$name"} = $sym;
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { my $n = shift; ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installler >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  Exporter::Tiny performs most of its internal duties (including resolution
  of tag names to sub names, resolution of sub names to coderefs, and
  installation of coderefs into the target package) as method calls, which
  means they can be overridden to provide interesting behaviour.
  
  =head2 Utility Functions
  
  These are really for internal use, but can be exported if you need them.
  
  =over
  
  =item C<< mkopt(\@array) >>
  
  Similar to C<mkopt> from L<Data::OptList>. It doesn't support all the
  fancy options that Data::OptList does (C<moniker>, C<require_unique>,
  C<must_be> and C<name_test>) but runs about 50% faster.
  
  =item C<< mkopt_hash(\@array) >>
  
  Similar to C<mkopt_hash> from L<Data::OptList>. See also C<mkopt>.
  
  =back
  
  =head1 TIPS AND TRICKS IMPORTING FROM EXPORTER::TINY
  
  For the purposes of this discussion we'll assume we have a module called
  C<< MyUtils >> which exports one function, C<< frobnicate >>. C<< MyUtils >>
  inherits from Exporter::Tiny.
  
  Many of these tricks may seem familiar from L<Sub::Exporter>. That is
  intentional. Exporter::Tiny doesn't attempt to provide every feature of
  Sub::Exporter, but where it does it usually uses a fairly similar API.
  
  =head2 Basic importing
  
     # import "frobnicate" function
     use MyUtils "frobnicate";
  
     # import all functions that MyUtils offers
     use MyUtils -all;
  
  =head2 Renaming imported functions
  
     # call it "frob"
     use MyUtils "frobnicate" => { -as => "frob" };
  
     # call it "my_frobnicate"
     use MyUtils "frobnicate" => { -prefix => "my_" };
  
     # call it "frobnicate_util"
     use MyUtils "frobnicate" => { -suffix => "_util" };
  
     # import it twice with two different names
     use MyUtils
        "frobnicate" => { -as => "frob" },
        "frobnicate" => { -as => "frbnct" };
  
  =head2 Lexical subs
  
     {
        use Sub::Exporter::Lexical lexical_installer => { -as => "lex" };
        use MyUtils { installer => lex }, "frobnicate";
        
        frobnicate(...);  # ok
     }
     
     frobnicate(...);  # not ok
  
  =head2 Import functions into another package
  
     use MyUtils { into => "OtherPkg" }, "frobnicate";
     
     OtherPkg::frobincate(...);
  
  =head2 Import functions into a scalar
  
     my $func;
     use MyUtils "frobnicate" => { -as => \$func };
     
     $func->(...);
  
  =head2 Import functions into a hash
  
  OK, Sub::Exporter doesn't do this...
  
     my %funcs;
     use MyUtils { into => \%funcs }, "frobnicate";
     
     $funcs{frobnicate}->(...);
  
  =head1 TIPS AND TRICKS EXPORTING USING EXPORTER::TINY
  
  Simple configuration works the same as L<Exporter>; inherit from this module,
  and use the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables to list subs to export.
  
  =head2 Generators
  
  Exporter::Tiny has always allowed exported subs to be generated (like
  L<Sub::Exporter>), but until version 0.025 did not have an especially nice
  API for it.
  
  Now, it's easy. If you want to generate a sub C<foo> to export, list it in
  C<< @EXPORT >> or C<< @EXPORT_OK >> as usual, and then simply give your
  exporter module a class method called C<< _generate_foo >>.
  
     push @EXPORT_OK, 'foo';
     
     sub _generate_foo {
        my $class = shift;
        my ($name, $args, $globals) = @_;
        
        return sub {
           ...;
        }
     }
  
  You can also generate tags:
  
     my %constants = (FOO => 1, BAR => 2);
     use constant \%constants;
     
     $EXPORT_TAGS{constants} = sub {
        my $class = shift;
        my ($name, $args, $globals) = @_;
        
        return keys(%constants);
     };
  
  =head2 Overriding Internals
  
  An important difference between L<Exporter> and Exporter::Tiny is that
  the latter calls all its internal functions as I<< class methods >>. This
  means that your subclass can I<< override them >> to alter their behaviour.
  
  The following methods are available to be overridden. Despite being named
  with a leading underscore, they are considered public methods. (The underscore
  is there to avoid accidentally colliding with any of your own function names.)
  
  =over
  
  =item C<< _exporter_validate_opts($globals) >>
  
  This method is called once each time C<import> is called. It is passed a
  reference to the global options hash. (That is, the optional leading hashref
  in the C<use> statement, where the C<into> and C<installer> options can be
  provided.)
  
  You may use this method to munge the global options, or validate them,
  throwing an exception or printing a warning.
  
  The default implementation does nothing interesting.
  
  =item C<< _exporter_expand_tag($name, $args, $globals) >>
  
  This method is called to expand an import tag (e.g. C<< ":constants" >>).
  It is passed the tag name (minus the leading ":"), an optional hashref
  of options (like C<< { -prefix => "foo_" } >>), and the global options
  hashref.
  
  It is expected to return a list of ($name, $args) arrayref pairs. These
  names can be sub names to export, or further tag names (which must have
  their ":"). If returning tag names, be careful to avoid creating a tag
  expansion loop!
  
  The default implementation uses C<< %EXPORT_TAGS >> to expand tags, and
  provides fallbacks for the C<< :default >> and C<< :all >> tags.
  
  =item C<< _exporter_expand_sub($name, $args, $globals) >>
  
  This method is called to translate a sub name to a hash of name => coderef
  pairs for exporting to the caller. In general, this would just be a hash with
  one key and one value, but, for example, L<Type::Library> overrides this
  method so that C<< "+Foo" >> gets expanded to:
  
     (
        Foo         => sub { $type },
        is_Foo      => sub { $type->check(@_) },
        to_Foo      => sub { $type->assert_coerce(@_) },
        assert_Foo  => sub { $type->assert_return(@_) },
     )
  
  The default implementation checks that the name is allowed to be exported
  (using the C<_exporter_permitted_regexp> method), gets the coderef using
  the generator if there is one (or by calling C<< can >> on your exporter
  otherwise) and calls C<_exporter_fail> if it's unable to generate or
  retrieve a coderef.
  
  =item C<< _exporter_permitted_regexp($globals) >>
  
  This method is called to retrieve a regexp for validating the names of
  exportable subs. If a sub doesn't match the regexp, then the default
  implementation of C<_exporter_expand_sub> will refuse to export it. (Of
  course, you may override the default C<_exporter_expand_sub>.)
  
  The default implementation of this method assembles the regexp from
  C<< @EXPORT >> and C<< @EXPORT_OK >>.
  
  =item C<< _exporter_fail($name, $args, $globals) >>
  
  Called by C<_exporter_expand_sub> if it can't find a coderef to export.
  
  The default implementation just throws an exception. But you could emit
  a warning instead, or just ignore the failed export.
  
  If you don't throw an exception then you should be aware that this
  method is called in list context, and any list it returns will be treated
  as an C<_exporter_expand_sub>-style hash of names and coderefs for
  export.
  
  =item C<< _exporter_install_sub($name, $args, $globals, $coderef) >>
  
  This method actually installs the exported sub into its new destination.
  Its return value is ignored.
  
  The default implementation handles sub renaming (i.e. the C<< -as >>,
  C<< -prefix >> and C<< -suffix >> functions. This method does a lot of
  stuff; if you need to override it, it's probably a good idea to just
  pre-process the arguments and then call the super method rather than
  trying to handle all of it yourself.
  
  =back
  
  =head1 HISTORY
  
  L<Type::Library> had a bunch of custom exporting code which poked coderefs
  into its caller's stash. It needed this to be something more powerful than
  most exporters so that it could switch between exporting Moose, Mouse and
  Moo-compatible objects on request. L<Sub::Exporter> would have been capable,
  but had too many dependencies for the Type::Tiny project.
  
  Meanwhile L<Type::Utils>, L<Types::TypeTiny> and L<Test::TypeTiny> each
  used the venerable L<Exporter.pm|Exporter>. However, this meant they were
  unable to use the features like L<Sub::Exporter>-style function renaming
  which I'd built into Type::Library:
  
     ## import "Str" but rename it to "String".
     use Types::Standard "Str" => { -as => "String" };
  
  And so I decided to factor out code that could be shared by all Type-Tiny's
  exporters into a single place: Exporter::TypeTiny.
  
  As of version 0.026, Exporter::TypeTiny was also made available as
  L<Exporter::Tiny>, distributed independently on CPAN. CHOCOLATEBOY had
  convinced me that it was mature enough to live a life of its own.
  
  As of version 0.030, Type-Tiny depends on Exporter::Tiny and
  Exporter::TypeTiny is being phased out.
  
  =head1 OBLIGATORY EXPORTER COMPARISON
  
  Exporting is unlikely to be your application's performance bottleneck, but
  nonetheless here are some comparisons.
  
  B<< Comparative sizes according to L<Devel::SizeMe>: >>
  
     Exporter                     217.1Kb
     Sub::Exporter::Progressive   263.2Kb
     Exporter::Tiny               267.7Kb
     Exporter + Exporter::Heavy   281.5Kb
     Exporter::Renaming           406.2Kb
     Sub::Exporter                701.0Kb
  
  B<< Performance exporting a single sub: >>
  
                Rate     SubExp    ExpTiny SubExpProg      ExpPM
  SubExp      2489/s         --       -56%       -85%       -88%
  ExpTiny     5635/s       126%         --       -67%       -72%
  SubExpProg 16905/s       579%       200%         --       -16%
  ExpPM      20097/s       707%       257%        19%         --
  
  (Exporter::Renaming globally changes the behaviour of Exporter.pm, so could
  not be included in the same benchmarks.)
  
  B<< (Non-Core) Dependencies: >>
  
     Exporter                    -1
     Exporter::Renaming           0
     Exporter::Tiny               0
     Sub::Exporter::Progressive   0
     Sub::Exporter                3
  
  B<< Features: >>
  
                                        ExpPM   ExpTiny SubExp  SubExpProg
   Can export code symbols............. Yes     Yes     Yes     Yes      
   Can export non-code symbols......... Yes                              
   Groups/tags......................... Yes     Yes     Yes     Yes      
   Config avoids package variables.....                 Yes              
   Allows renaming of subs.............         Yes     Yes     Maybe    
   Install code into scalar refs.......         Yes     Yes     Maybe    
   Can be passed an "into" parameter...         Yes     Yes     Maybe    
   Can be passed an "installer" sub....         Yes     Yes     Maybe    
   Supports generators.................         Yes     Yes              
   Sane API for generators.............         Yes     Yes              
  
  (Certain Sub::Exporter::Progressive features are only available if
  Sub::Exporter is installed.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  L<Exporter::Shiny>,
  L<Sub::Exporter>,
  L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"Exporter/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TYPETINY';
  package Exporter::TypeTiny;
  require Exporter::Tiny;
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  our @ISA       = 'Exporter::Tiny';
  our @EXPORT_OK = qw| mkopt mkopt_hash _croak |;
  *import        = \&Exporter::Tiny::import;
  *mkopt         = \&Exporter::Tiny::mkopt;
  *mkopt_hash    = \&Exporter::Tiny::mkopt_hash;
  *_croak        = \&Exporter::Tiny::_croak;
  1;
EXPORTER_TYPETINY

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;
  
  # See POD at end for documentation
  
  use 5.00503;
  use strict;
  use Carp        ();
  use Config      ();
  use File::Spec  ();
  use File::Which ();
  
  # Globals
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};
  BEGIN {
  	$VERSION = '1.00';
  
  	# Inherit manually
  	require Exporter;
  	@ISA       = qw{ Exporter };
  	@EXPORT    = qw{ home     };
  	@EXPORT_OK = qw{
  		home
  		my_home
  		my_desktop
  		my_documents
  		my_music
  		my_pictures
  		my_videos
  		my_data
  		my_dist_config
  		my_dist_data
  		users_home
  		users_desktop
  		users_documents
  		users_music
  		users_pictures
  		users_videos
  		users_data
  	};
  
  	# %~ doesn't need (and won't take) exporting, as it's a magic
  	# symbol name that's always looked for in package 'main'.
  }
  
  # Inlined Params::Util functions
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  
  # Platform detection
  if ( $IMPLEMENTED_BY ) {
  	# Allow for custom HomeDir classes
  	# Leave it as the existing value
  } elsif ( $^O eq 'MSWin32' ) {
  	# All versions of Windows
  	$IMPLEMENTED_BY = 'File::HomeDir::Windows';
  } elsif ( $^O eq 'darwin') {
  	# 1st: try Mac::SystemDirectory by chansen
  	if ( eval { require Mac::SystemDirectory; 1 } ) {
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Cocoa';
  	} elsif ( eval { require Mac::Files; 1 } ) {
  		# 2nd try Mac::Files: Carbon - unmaintained since 2006 except some 64bit fixes
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Carbon';
  	} else {
  		# 3rd: fallback: pure perl
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin';
  	}
  } elsif ( $^O eq 'MacOS' ) {
  	# Legacy Mac OS
  	$IMPLEMENTED_BY = 'File::HomeDir::MacOS9';
  } elsif ( File::Which::which('xdg-user-dir') ) {
  	# freedesktop unixes
  	$IMPLEMENTED_BY = 'File::HomeDir::FreeDesktop';
  } else {
  	# Default to Unix semantics
  	$IMPLEMENTED_BY = 'File::HomeDir::Unix';
  }
  unless ( _DRIVER($IMPLEMENTED_BY, 'File::HomeDir::Driver') ) {
  	Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY");
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	$IMPLEMENTED_BY->my_home;
  }
  
  sub my_desktop {
  	$IMPLEMENTED_BY->can('my_desktop')
  		? $IMPLEMENTED_BY->my_desktop
  		: Carp::croak("The my_desktop method is not implemented on this platform");
  }
  
  sub my_documents {
  	$IMPLEMENTED_BY->can('my_documents')
  		? $IMPLEMENTED_BY->my_documents
  		: Carp::croak("The my_documents method is not implemented on this platform");
  }
  
  sub my_music {
  	$IMPLEMENTED_BY->can('my_music')
  		? $IMPLEMENTED_BY->my_music
  		: Carp::croak("The my_music method is not implemented on this platform");
  }
  
  sub my_pictures {
  	$IMPLEMENTED_BY->can('my_pictures')
  		? $IMPLEMENTED_BY->my_pictures
  		: Carp::croak("The my_pictures method is not implemented on this platform");
  }
  
  sub my_videos {
  	$IMPLEMENTED_BY->can('my_videos')
  		? $IMPLEMENTED_BY->my_videos
  		: Carp::croak("The my_videos method is not implemented on this platform");
  }
  
  sub my_data {
  	$IMPLEMENTED_BY->can('my_data')
  		? $IMPLEMENTED_BY->my_data
  		: Carp::croak("The my_data method is not implemented on this platform");
  }
  
  
  sub my_dist_data {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_data method requires an argument");
  	my $data   = my_data();
  
          # If datadir is not defined, there's nothing we can do: bail out
          # and return nothing...	
  	return undef unless defined $data;
  
          # On traditional unixes, hide the top-level directory
  	my $var = $data eq home()
  		? File::Spec->catdir( $data, '.perl', 'dist', $dist )
  		: File::Spec->catdir( $data, 'Perl',  'dist', $dist );
  
  	# directory exists: return it
  	return $var if -d $var;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $var );
  	return $var;
  }
  
  sub my_dist_config {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_config method requires an argument");
  
  	# not all platforms support a specific my_config() method
  	my $config = $IMPLEMENTED_BY->can('my_config')
  		? $IMPLEMENTED_BY->my_config
  		: $IMPLEMENTED_BY->my_documents;
  
  	# If neither configdir nor my_documents is defined, there's
  	# nothing we can do: bail out and return nothing...	
  	return undef unless defined $config;
  
  	# On traditional unixes, hide the top-level dir
  	my $etc = $config eq home()
  		? File::Spec->catdir( $config, '.perl', $dist )
  		: File::Spec->catdir( $config, 'Perl',  $dist );
  
  	# directory exists: return it
  	return $etc if -d $etc;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $etc );
  	return $etc;
  }
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	$IMPLEMENTED_BY->can('users_home')
  		? $IMPLEMENTED_BY->users_home( $_[-1] )
  		: Carp::croak("The users_home method is not implemented on this platform");
  }
  
  sub users_desktop {
  	$IMPLEMENTED_BY->can('users_desktop')
  		? $IMPLEMENTED_BY->users_desktop( $_[-1] )
  		: Carp::croak("The users_desktop method is not implemented on this platform");
  }
  
  sub users_documents {
  	$IMPLEMENTED_BY->can('users_documents')
  		? $IMPLEMENTED_BY->users_documents( $_[-1] )
  		: Carp::croak("The users_documents method is not implemented on this platform");
  }
  
  sub users_music {
  	$IMPLEMENTED_BY->can('users_music')
  		? $IMPLEMENTED_BY->users_music( $_[-1] )
  		: Carp::croak("The users_music method is not implemented on this platform");
  }
  
  sub users_pictures {
  	$IMPLEMENTED_BY->can('users_pictures')
  		? $IMPLEMENTED_BY->users_pictures( $_[-1] )
  		: Carp::croak("The users_pictures method is not implemented on this platform");
  }
  
  sub users_videos {
  	$IMPLEMENTED_BY->can('users_videos')
  		? $IMPLEMENTED_BY->users_videos( $_[-1] )
  		: Carp::croak("The users_videos method is not implemented on this platform");
  }
  
  sub users_data {
  	$IMPLEMENTED_BY->can('users_data')
  		? $IMPLEMENTED_BY->users_data( $_[-1] )
  		: Carp::croak("The users_data method is not implemented on this platform");
  }
  
  
  
  
  
  #####################################################################
  # Legacy Methods
  
  # Find the home directory of an arbitrary user
  sub home (;$) {
  	# Allow to be called as a method
  	if ( $_[0] and $_[0] eq 'File::HomeDir' ) {
  		shift();
  	}
  
  	# No params means my home
  	return my_home() unless @_;
  
  	# Check the param
  	my $name = shift;
  	if ( ! defined $name ) {
  		Carp::croak("Can't use undef as a username");
  	}
  	if ( ! length $name ) {
  		Carp::croak("Can't use empty-string (\"\") as a username");
  	}
  
  	# A dot also means my home
  	### Is this meant to mean File::Spec->curdir?
  	if ( $name eq '.' ) {
  		return my_home();
  	}
  
  	# Now hand off to the implementor
  	$IMPLEMENTED_BY->users_home($name);
  }
  
  
  
  
  
  #####################################################################
  # Tie-Based Interface
  
  # Okay, things below this point get scary
  
  CLASS: {
  	# Make the class for the %~ tied hash:
  	package File::HomeDir::TIE;
  
  	# Make the singleton object.
  	# (We don't use the hash for anything, though)
  	### THEN WHY MAKE IT???
  	my $SINGLETON = bless {};
  
  	sub TIEHASH { $SINGLETON }
  
  	sub FETCH {
  		# Catch a bad username
  		unless ( defined $_[1] ) {
  			Carp::croak("Can't use undef as a username");
  		}
  
  		# Get our homedir
  		unless ( length $_[1] ) {
  			return File::HomeDir::my_home();
  		}
  
  		# Get a named user's homedir
  		Carp::carp("The tied %~ hash has been deprecated");
  		return File::HomeDir::home($_[1]);
  	}
  
  	sub STORE    { _bad('STORE')    }
  	sub EXISTS   { _bad('EXISTS')   }
  	sub DELETE   { _bad('DELETE')   }
  	sub CLEAR    { _bad('CLEAR')    }
  	sub FIRSTKEY { _bad('FIRSTKEY') }
  	sub NEXTKEY  { _bad('NEXTKEY')  }
  
  	sub _bad ($) {
  		Carp::croak("You can't $_[0] with the %~ hash")
  	}
  }
  
  # Do the actual tie of the global %~ variable
  tie %~, 'File::HomeDir::TIE';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir - Find your home and other directories on any platform
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Modern Interface (Current User)
    $home     = File::HomeDir->my_home;
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $dist     = File::HomeDir->my_dist_data('File-HomeDir');
    $dist     = File::HomeDir->my_dist_config('File-HomeDir');
    
    # Modern Interface (Other Users)
    $home    = File::HomeDir->users_home('foo');
    $desktop = File::HomeDir->users_desktop('foo');
    $docs    = File::HomeDir->users_documents('foo');
    $music   = File::HomeDir->users_music('foo');
    $pics    = File::HomeDir->users_pictures('foo');
    $video   = File::HomeDir->users_videos('foo');
    $data    = File::HomeDir->users_data('foo');
  
  =head1 DESCRIPTION
  
  B<File::HomeDir> is a module for locating the directories that are "owned"
  by a user (typicaly your user) and to solve the various issues that arise
  trying to find them consistently across a wide variety of platforms.
  
  The end result is a single API that can find your resources on any platform,
  making it relatively trivial to create Perl software that works elegantly
  and correctly no matter where you run it.
  
  This module provides two main interfaces.
  
  The first is a modern L<File::Spec>-style interface with a consistent
  OO API and different implementation modules to support various
  platforms. You are B<strongly> recommended to use this interface.
  
  The second interface is for legacy support of the original 0.07 interface
  that exported a C<home()> function by default and tied the C<%~> variable.
  
  It is generally not recommended that you use this interface, but due to
  back-compatibility reasons they will remain supported until at least 2010.
  
  The C<%~> interface has been deprecated. Documentation was removed in 2009,
  Unit test were removed in 2011, usage will issue warnings from 2012, and the
  interface will be removed entirely in 2015  (in line with the general Perl
  toolchain convention of a 10 year support period for legacy APIs that
  are potentially or actually in common use).
  
  =head2 Platform Neutrality
  
  In the Unix world, many different types of data can be mixed together
  in your home directory (although on some Unix platforms this is no longer
  the case, particularly for "desktop"-oriented platforms).
  
  On some non-Unix platforms, separate directories are allocated for
  different types of data and have been for a long time.
  
  When writing applications on top of B<File::HomeDir>, you should thus
  always try to use the most specific method you can. User documents should
  be saved in C<my_documents>, data that supports an application but isn't
  normally editing by the user directory should go into C<my_data>.
  
  On platforms that do not make any distinction, all these different
  methods will harmlessly degrade to the main home directory, but on
  platforms that care B<File::HomeDir> will always try to Do The Right
  Thing(tm).
  
  =head1 METHODS
  
  Two types of methods are provided. The C<my_method> series of methods for
  finding resources for the current user, and the C<users_method> (read as
  "user's method") series for finding resources for arbitrary users.
  
  This split is necessary, as on most platforms it is B<much> easier to find
  information about the current user compared to other users, and indeed
  on a number you cannot find out information such as C<users_desktop> at
  all, due to security restrictions.
  
  All methods will double check (using a C<-d> test) that a directory
  actually exists before returning it, so you may trust in the values
  that are returned (subject to the usual caveats of race conditions of
  directories being deleted at the moment between a directory being returned
  and you using it).
  
  However, because in some cases platforms may not support the concept of home
  directories at all, any method may return C<undef> (both in scalar and list
  context) to indicate that there is no matching directory on the system.
  
  For example, most untrusted 'nobody'-type users do not have a home
  directory. So any modules that are used in a CGI application that
  at some level of recursion use your code, will result in calls to
  File::HomeDir returning undef, even for a basic home() call.
  
  =head2 my_home
  
  The C<my_home> method takes no arguments and returns the main home/profile
  directory for the current user.
  
  If the distinction is important to you, the term "current" refers to the
  real user, and not the effective user.
  
  This is also the case for all of the other "my" methods.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a home directory, or dies on error.
  
  =head2 my_desktop
  
  The C<my_desktop> method takes no arguments and returns the "desktop"
  directory for the current user.
  
  Due to the diversity and complexity of implementions required to deal with
  implementing the required functionality fully and completely, the
  C<my_desktop> method may or may not be implemented on each platform.
  
  That said, I am extremely interested in code to implement C<my_desktop> on
  Unix, as long as it is capable of dealing (as the Windows implementation
  does) with internationalisation. It should also avoid false positive
  results by making sure it only returns the appropriate directories for the
  appropriate platforms.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a desktop directory, or dies on error.
  
  =head2 my_documents
  
  The C<my_documents> method takes no arguments and returns the directory (for
  the current user) where the user's documents are stored.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a documents directory, or dies on error.
  
  =head2 my_music
  
  The C<my_music> method takes no arguments and returns the directory
  where the current user's music is stored.
  
  No bias is made to any particular music type or music program, rather the
  concept of a directory to hold the user's music is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_pictures
  
  The C<my_pictures> method takes no arguments and returns the directory
  where the current user's pictures are stored.
  
  No bias is made to any particular picture type or picture program, rather the
  concept of a directory to hold the user's pictures is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_videos
  
  The C<my_videos> method takes no arguments and returns the directory
  where the current user's videos are stored.
  
  No bias is made to any particular video type or video program, rather the
  concept of a directory to hold the user's videos is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_data
  
  The C<my_data> method takes no arguments and returns the directory where
  local applications should stored their internal data for the current
  user.
  
  Generally an application would create a subdirectory such as C<.foo>,
  beneath this directory, and store its data there. By creating your
  directory this way, you get an accurate result on the maximum number of
  platforms. But see the documentation about C<my_dist_config()> or
  C<my_dist_data()> below.
  
  For example, on Unix you get C<~/.foo> and on Win32 you get
  C<~/Local Settings/Application Data/.foo>
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a data directory, or dies on error.
  
  
  =head2 my_dist_config
  
    File::HomeDir->my_dist_config( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_config( 'File-HomeDir' );
    File::HomeDir->my_dist_config( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_config> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal configuration.
  
  The base directory will be either C<my_config> if the platform supports
  it, or C<my_documents> otherwise. The subdirectory itself will be 
  C<BASE/Perl/Dist-Name>. If the base directory is the user's homedir,
  C<my_dist_config> will be in C<~/.perl/Dist-Name> (and thus be hidden on
  all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  
  =head2 my_dist_data
  
    File::HomeDir->my_dist_data( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_data( 'File-HomeDir' );
    File::HomeDir->my_dist_data( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_data> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal data.
  
  This directory will be of course a subdirectory of C<my_data>. Platforms
  supporting data-specific directories will use
  C<DATA_DIR/perl/dist/Dist-Name> following the common
  "DATA/vendor/application" pattern. If the C<my_data> directory is the
  user's homedir, C<my_dist_data> will be in C<~/.perl/dist/Dist-Name>
  (and thus be hidden on all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  =head2 users_home
  
    $home = File::HomeDir->users_home('foo');
  
  The C<users_home> method takes a single param and is used to locate the
  parent home/profile directory for an identified user on the system.
  
  While most of the time this identifier would be some form of user name,
  it is permitted to vary per-platform to support user ids or UUIDs as
  applicable for that platform.
  
  Returns the directory path as a string, C<undef> if that user
  does not have a home directory, or dies on error.
  
  =head2 users_documents
  
    $docs = File::HomeDir->users_documents('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a documents directory, or dies on error.
  
  =head2 users_data
  
    $data = File::HomeDir->users_data('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a data directory, or dies on error.
  
  =head1 FUNCTIONS
  
  =head2 home
  
    use File::HomeDir;
    $home = home();
    $home = home('foo');
    $home = File::HomeDir::home();
    $home = File::HomeDir::home('foo');
  
  The C<home> function is exported by default and is provided for
  compatibility with legacy applications. In new applications, you should
  use the newer method-based interface above.
  
  Returns the directory path to a named user's home/profile directory.
  
  If provided no param, returns the directory path to the current user's
  home/profile directory.
  
  =head1 TO DO
  
  =over 4
  
  =item * Add more granularity to Unix, and add support to VMS and other
  esoteric platforms, so we can consider going core.
  
  =item * Add consistent support for users_* methods 
  
  =back
  
  =head1 SUPPORT
  
  This module is stored in an Open Repository at the following address.
  
  L<http://svn.ali.as/cpan/trunk/File-HomeDir>
  
  Write access to the repository is made available automatically to any
  published CPAN author, and to most other volunteers on request.
  
  If you are able to submit your bug report in the form of new (failing)
  unit tests, or can apply your fix directly instead of submitting a patch,
  you are B<strongly> encouraged to do so as the author currently maintains
  over 100 modules and it can take some time to deal with non-Critical bug
  reports or patches.
  
  This will guarantee that your issue will be addressed in the next
  release of the module.
  
  If you cannot provide a direct test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the CPAN
  bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-HomeDir>
  
  For other issues, for commercial enhancement or support, or to have your
  write access enabled for the repository, contact the author at the email
  address above.
  
  =head1 ACKNOWLEDGEMENTS
  
  The biggest acknowledgement goes to Chris Nandor, who wielded his
  legendary Mac-fu and turned my initial fairly ordinary Darwin
  implementation into something that actually worked properly everywhere,
  and then donated a Mac OS X license to allow it to be maintained properly.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  Chris Nandor E<lt>cnandor@cpan.orgE<gt>
  
  Stephen Steneker E<lt>stennie@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  Some parts copyright 2006 Chris Nandor.
  
  Some parts copyright 2006 Stephen Steneker.
  
  Some parts copyright 2009-2011 Jrme Quelin.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;
  
  use 5.00503;
  use strict;
  use Cwd                 ();
  use Carp                ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	my $home = (getpwuid($<))[7];
  	return $home if $home && -d $home;
  
  	return undef;
  }
  
  sub _my_home {
  	my($class, $path) = @_;
  	my $home = $class->my_home;
  	return undef unless defined $home;
  
  	my $folder = "$home/$path";
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  sub my_desktop {
  	my $class = shift;
  	$class->_my_home('Desktop');
  }
  
  sub my_documents {
  	my $class = shift;
  	$class->_my_home('Documents');
  }
  
  sub my_data {
  	my $class = shift;
  	$class->_my_home('Library/Application Support');
  }
  
  sub my_music {
  	my $class = shift;
  	$class->_my_home('Music');
  }
  
  sub my_pictures {
  	my $class = shift;
  	$class->_my_home('Pictures');
  }
  
  sub my_videos {
  	my $class = shift;
  	$class->_my_home('Movies');
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Mac OS X specific file path for determining
  common user directories in pure perl, by just using C<$ENV{HOME}>
  without Carbon nor Cocoa API calls. In normal usage this module will
  always be used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;
  
  # Basic implementation for the Dawin family of operating systems.
  # This includes (most prominently) Mac OS X.
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  
  	# This is only a child class of the pure Perl darwin
  	# class so that we can do homedir detection of all three
  	# drivers at one via ->isa.
  	@ISA = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kCurrentUserFolderType(),
  	);
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDesktopFolderType(),
  	);
  }
  
  sub my_documents {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDocumentsFolderType(),
  	);
  }
  
  sub my_data {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kApplicationSupportFolderType(),
  	);
  }
  
  sub my_music {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMusicDocumentsFolderType(),
  	);
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kPictureDocumentsFolderType(),
  	);
  }
  
  sub my_videos {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMovieDocumentsFolderType(),
  	);
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::Files;
  	my $folder = Mac::Files::FindFolder(
  		Mac::Files::kUserDomain(),
  		$name,
  	);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  # in theory this can be done, but for now, let's cheat, since the
  # rest is Hard
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Note -- since this module requires Mac::Carbon and Mac::Carbon does
  not work with 64-bit perls, on such systems, File::HomeDir will try
  L<File::HomeDir::Darwin::Cocoa> and then fall back to the (pure Perl)
  L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
  
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =head1 TODO
  
  =over 4
  
  =item * Test with Mac OS (versions 7, 8, 9)
  
  =item * Some better way for users_* ?
  
  =back
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::SystemDirectory'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::SystemDirectory;
  	return Mac::SystemDirectory::HomeDirectory();
  }
  
  # from 10.4
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())
  	}
  	||
  	$class->SUPER::my_desktop;
  }
  
  # from 10.2
  sub my_documents {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())
  	}
  	||
  	$class->SUPER::my_documents;
  }
  
  # from 10.4
  sub my_data {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())
  	}
  	||
  	$class->SUPER::my_data;
  }
  
  # from 10.6
  sub my_music {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())
  	}
  	||
  	$class->SUPER::my_music;
  }
  
  # from 10.6
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())
  	}
  	||
  	$class->SUPER::my_pictures;
  }
  
  # from 10.6
  sub my_videos {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())
  	}
  	||
  	$class->SUPER::my_videos;
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::SystemDirectory;
  	my $folder = Mac::SystemDirectory::FindDirectory($name);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin::Cocoa - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories using Cocoa API through
  L<Mac::SystemDirectory>.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Theoretically, this should return the same paths as both of the other
  Darwin drivers.
  
  Because this module requires L<Mac::SystemDirectory>, if the module
  is not installed, L<File::HomeDir> will fall back to L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;
  
  # Abstract base class that provides no functionality,
  # but confirms the class is a File::HomeDir driver class.
  
  use 5.00503;
  use strict;
  use Carp ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.00';
  }
  
  sub my_home {
  	Carp::croak("$_[0] does not implement compulsory method $_[1]");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Driver - Base class for all File::HomeDir drivers
  
  =head1 DESCRIPTION
  
  This module is the base class for all L<File::HomeDir> drivers, and must
  be inherited from to identify a class as a driver.
  
  It is primarily provided as a convenience for this specific identification
  purpose, as L<File::HomeDir> supports the specification of custom drivers
  and an C<-E<gt>isa> check is used during the loading of the driver.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;
  
  # Specific functionality for unixes running free desktops
  # compatible with (but not using) File-BaseDir-0.03
  
  # See POD at the end of the file for more documentation.
  
  use 5.00503;
  use strict;
  use Carp                ();
  use File::Spec          ();
  use File::Which         ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  # xdg uses $ENV{XDG_CONFIG_HOME}/user-dirs.dirs to know where are the
  # various "my xxx" directories. That is a shell file. The official API
  # is the xdg-user-dir executable. It has no provision for assessing
  # the directories of a user that is different than the one we are
  # running under; the standard substitute user mechanisms are needed to
  # overcome this.
  
  my $xdgprog = File::Which::which('xdg-user-dir');
  
  sub _my {
  	# No quoting because input is hard-coded and only comes from this module
  	my $thingy = qx($xdgprog $_[1]);
  	chomp $thingy;
  	return $thingy;
  }
  
  # Simple stuff
  sub my_desktop   { shift->_my('DESKTOP')   }
  sub my_documents { shift->_my('DOCUMENTS') }
  sub my_music     { shift->_my('MUSIC')     }
  sub my_pictures  { shift->_my('PICTURES')  }
  sub my_videos    { shift->_my('VIDEOS')    }
  
  sub my_data {
  	$ENV{XDG_DATA_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .local share }
  	);
  }
  
  sub my_config {
  	$ENV{XDG_CONFIG_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .config }
  	);
  }
  
  # Custom locations (currently undocumented)
  sub my_download    { shift->_my('DOWNLOAD')    }
  sub my_publicshare { shift->_my('PUBLICSHARE') }
  sub my_templates   { shift->_my('TEMPLATES')   }
  
  sub my_cache {
      $ENV{XDG_CACHE_HOME}
      ||
      File::Spec->catdir(shift->my_home, qw{ .cache });
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_desktop   { Carp::croak('The users_desktop method is not available on an XDG based system.');   }
  sub users_documents { Carp::croak('The users_documents method is not available on an XDG based system.'); }
  sub users_music     { Carp::croak('The users_music method is not available on an XDG based system.');     }
  sub users_pictures  { Carp::croak('The users_pictures method is not available on an XDG based system.');  }
  sub users_videos    { Carp::croak('The users_videos method is not available on an XDG based system.');    }
  sub users_data      { Carp::croak('The users_data method is not available on an XDG based system.');      }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::FreeDesktop - Find your home and other directories on FreeDesktop.org Unix
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;
    $docs    = File::HomeDir->my_documents;
    $music   = File::HomeDir->my_music;
    $pics    = File::HomeDir->my_pictures;
    $videos  = File::HomeDir->my_videos;
    $data    = File::HomeDir->my_data;
  
  =head1 AUTHORS
  
  Jerome Quelin E<lt>jquellin@cpan.org<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Jerome Quelin.
  
  Some parts copyright 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;
  
  # Half-assed implementation for the legacy Mac OS9 operating system.
  # Provided mainly to provide legacy compatibility. May be removed at
  # a later date.
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  # Load early if in a forking environment and we have
  # prefork, or at run-time if not.
  SCOPE: {
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# Try for $ENV{HOME} if we have it
  	if ( defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	### DESPERATION SETS IN
  
  	# We could use the desktop
  	SCOPE: {
  		local $@;
  		eval {
  			my $home = $class->my_desktop;
  			return $home if $home and -d $home;
  		};
  	}
  
  	# Desperation on any platform
  	SCOPE: {
  		# On some platforms getpwuid dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	Carp::croak("Could not locate current user's home directory");
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# Find the desktop via Mac::Files
  	local $SIG{'__DIE__'} = '';
  	require Mac::Files;
  	my $home = Mac::Files::FindFolder(
  		Mac::Files::kOnSystemDisk(),
  		Mac::Files::kDesktopFolderType(),
  		);
  	return $home if $home and -d $home;
  
  	Carp::croak("Could not locate current user's desktop");
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	SCOPE: {
  		# On some platforms getpwnam dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwnam($name))[7];
  		return $home if defined $home and -d $home;
  	}
  
  	Carp::croak("Failed to find home directory for user '$name'");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::MacOS9 - Find your home and other directories on legacy Macs
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;
    $desktop = File::HomeDir->my_desktop;
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories on legacy Mac hosts. In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module is no longer actively maintained, and is included only for
  extreme back-compatibility.
  
  Only the C<my_home> and C<my_desktop> methods are supported.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::Temp            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA %DIR $ENABLED};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  	%DIR     = ();
  	$ENABLED = 0;
  }
  
  # Special magic use in test scripts
  sub import {
  	my $class = shift;
  	die "Attempted to initialise File::HomeDir::Test trice" if %DIR;
  
  	# Fill the test directories
  	my $BASE  = File::Temp::tempdir( CLEANUP => 1 );
  	%DIR = map { $_ => File::Spec->catdir( $BASE, $_ ) } qw{
  		my_home
  		my_desktop
  		my_documents
  		my_data
  		my_music
  		my_pictures
  		my_videos
  	};
  
  	# Hijack HOME to the home directory
  	$ENV{HOME} = $DIR{my_home};
  
  	# Make File::HomeDir load us instead of the native driver
  	$File::HomeDir::IMPLEMENTED_BY = # Prevent a warning
  	$File::HomeDir::IMPLEMENTED_BY = 'File::HomeDir::Test';
  
  	# Ready to go
  	$ENABLED = 1;
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	mkdir($DIR{my_home}, 0755) unless -d $DIR{my_home};
  	return $DIR{my_home};
  }
  
  sub my_desktop {
  	mkdir($DIR{my_desktop}, 0755) unless -d $DIR{my_desktop};
  	return $DIR{my_desktop};
  }
  
  sub my_documents {
  	mkdir($DIR{my_documents}, 0755) unless -f $DIR{my_documents};
  	return $DIR{my_documents};
  }
  
  sub my_data {
  	mkdir($DIR{my_data}, 0755) unless -d $DIR{my_data};
  	return $DIR{my_data};
  }
  
  sub my_music {
  	mkdir($DIR{my_music}, 0755) unless -d $DIR{my_music};
  	return $DIR{my_music};
  }
  
  sub my_pictures {
  	mkdir($DIR{my_pictures}, 0755) unless -d $DIR{my_pictures};
  	return $DIR{my_pictures};
  }
  
  sub my_videos {
  	mkdir($DIR{my_videos}, 0755) unless -d $DIR{my_videos};
  	return $DIR{my_videos};
  }
  
  sub users_home {
  	return undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Test - Prevent the accidental creation of user-owned files during testing
  
  =head1 SYNOPSIS
  
    use Test::More test => 1;
    use File::HomeDir::Test;
    use File::HomeDir;
  
  =head1 DESCRIPTION
  
  B<File::HomeDir::Test> is a L<File::HomeDir> driver intended for use in the test scripts
  of modules or applications that write files into user-owned directories.
  
  It is designed to prevent the pollution of user directories with files that are not part
  of the application install itself, but were created during testing. These files can leak
  state information from the tests into the run-time usage of an application, and on Unix
  systems also prevents tests (which may be executed as root via sudo) from writing files
  which cannot later be modified or removed by the regular user.
  
  =head1 SUPPORT
  
  See the support section of the main L<File::HomeDir> documentation.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  	my $home  = $class->_my_home(@_);
  
  	# On Unix in general, a non-existant home means "no home"
  	# For example, "nobody"-like users might use /nonexistant
  	if ( defined $home and ! -d $home ) {
  		$home = undef;
  	}
  
  	return $home;
  }
  
  sub _my_home {
  	my $class = shift;
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# This is from the original code, but I'm guessing
  	# it means "login directory" and exists on some Unixes.
  	if ( exists $ENV{LOGDIR} and $ENV{LOGDIR} ) {
  		return $ENV{LOGDIR};
  	}
  
  	### More-desperate methods
  
  	# Light desperation on any (Unixish) platform
  	SCOPE: {
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  # On unix by default, everything is under the same folder
  sub my_desktop {
  	shift->my_home;
  }
  
  sub my_documents {
  	shift->my_home;
  }
  
  sub my_data {
  	shift->my_home;
  }
  
  sub my_music {
  	shift->my_home;
  }
  
  sub my_pictures {
  	shift->my_home;
  }
  
  sub my_videos {
  	shift->my_home;
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	# IF and only if we have getpwuid support, and the
  	# name of the user is our own, shortcut to my_home.
  	# This is needed to handle HOME environment settings.
  	if ( $name eq getpwuid($<) ) {
  		return $class->my_home;
  	}
  
  	SCOPE: {
  		my $home = (getpwnam($name))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  sub users_desktop {
  	shift->users_home(@_);
  }
  
  sub users_documents {
  	shift->users_home(@_);
  }
  
  sub users_data {
  	shift->users_home(@_);
  }
  
  sub users_music {
  	shift->users_home(@_);
  }
  
  sub users_pictures {
  	shift->users_home(@_);
  }
  
  sub users_videos {
  	shift->users_home(@_);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Unix - Find your home and other directories on legacy Unix
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;     # All of these will... 
    $docs    = File::HomeDir->my_documents;   # ...default to home...
    $music   = File::HomeDir->my_music;       # ...directory
    $pics    = File::HomeDir->my_pictures;    #
    $videos  = File::HomeDir->my_videos;      #
    $data    = File::HomeDir->my_data;        # 
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  sub CREATE () { 1 }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# Do we have a user profile?
  	if ( exists $ENV{USERPROFILE} and $ENV{USERPROFILE} ) {
  		return $ENV{USERPROFILE};
  	}
  
  	# Some Windows use something like $ENV{HOME}
  	if ( exists $ENV{HOMEDRIVE} and exists $ENV{HOMEPATH} and $ENV{HOMEDRIVE} and $ENV{HOMEPATH} ) {
  		return File::Spec->catpath(
  			$ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '',
  		);
  	}
  
  	return undef;
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# The most correct way to find the desktop
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_DESKTOP(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	# MSWindows sets WINDIR, MS WinNT sets USERPROFILE.
  	foreach my $e ( 'USERPROFILE', 'WINDIR' ) {
  		next unless $ENV{$e};
  		my $desktop = File::Spec->catdir($ENV{$e}, 'Desktop');
  		return $desktop if $desktop and $class->_d($desktop);
  	}
  
  	# As a last resort, try some hard-wired values
  	foreach my $fixed (
  		# The reason there are both types of slash here is because
  		# this set of paths has been kept from thethe original version
  		# of File::HomeDir::Win32 (before it was rewritten).
  		# I can only assume this is Cygwin-related stuff.
  		"C:\\windows\\desktop",
  		"C:\\win95\\desktop",
  		"C:/win95/desktop",
  		"C:/windows/desktop",
  	) {
  		return $fixed if $class->_d($fixed);
  	}
  
  	return undef;
  }
  
  sub my_documents {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_PERSONAL(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_data {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_music {
  	my $class = shift;
  
  	# The most correct way to find my music
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	# The most correct way to find my pictures
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_videos {
  	my $class = shift;
  
  	# The most correct way to find my videos
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  # Special case version of -d
  sub _d {
  	my $self = shift;
  	my $path = shift;
  
  	# Window can legally return a UNC path from GetFolderPath.
  	# Not only is the meaning of -d complicated in this situation,
  	# but even on a local network calling -d "\\\\cifs\\path" can
  	# take several seconds. UNC can also do even weirder things,
  	# like launching processes and such.
  	# To avoid various crazy bugs caused by this, we do NOT attempt
  	# to validate UNC paths at all so that the code that is calling
  	# us has an opportunity to take special actions without our 
  	# blundering getting in the way.
  	if ( $path =~ /\\\\/ ) {
  		return 1;
  	}
  
  	# Otherwise do a stat as normal
  	return -d $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Windows - Find your home and other directories on Windows
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user (eg. using Windows XP Professional)
    $home    = File::HomeDir->my_home;        # C:\Documents and Settings\mylogin
    $desktop = File::HomeDir->my_desktop;     # C:\Documents and Settings\mylogin\Desktop
    $docs    = File::HomeDir->my_documents;   # C:\Documents and Settings\mylogin\My Documents
    $music   = File::HomeDir->my_music;       # C:\Documents and Settings\mylogin\My Documents\My Music
    $pics    = File::HomeDir->my_pictures;    # C:\Documents and Settings\mylogin\My Documents\My Pictures
    $videos  = File::HomeDir->my_videos;      # C:\Documents and Settings\mylogin\My Documents\My Video
    $data    = File::HomeDir->my_data;        # C:\Documents and Settings\mylogin\Local Settings\Application Data
  
  =head1 DESCRIPTION
  
  This module provides Windows-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Internally this module will use L<Win32>::GetFolderPath to fetch the location
  of your directories. As a result of this, in certain unusual situations
  (usually found inside large organisations) the methods may return UNC paths
  such as C<\\cifs.local\home$>.
  
  If your application runs on Windows and you want to have it work comprehensively
  everywhere, you may need to implement your own handling for these paths as they
  can cause strange behaviour.
  
  For example, stat calls to UNC paths may work but block for several seconds, but
  opendir() may not be able to read any files (creating the appearance of an existing
  but empty directory).
  
  To avoid complicating the problem any further, in the rare situation that a UNC path
  is returned by C<GetFolderPath> the usual -d validation checks will B<not> be done.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use 5.004;
  use strict;
  use Exporter   ();
  use File::Spec ();
  
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK};
  BEGIN {
  	$VERSION   = '1.09';
  	@ISA       = 'Exporter';
  	@EXPORT    = 'which';
  	@EXPORT_OK = 'where';
  }
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
  	# WinNT. PATHEXT might be set on Cygwin, but not used.
  	if ( $ENV{PATHEXT} ) {
  		push @PATHEXT, split ';', $ENV{PATHEXT};
  	} else {
  		# Win9X or other: doesn't have PATHEXT, so needs hardcoded.
  		push @PATHEXT, qw{.com .exe .bat};
  	}
  } elsif ( IS_VMS ) {
  	push @PATHEXT, qw{.exe .com};
  }
  
  sub which {
  	my ($exec) = @_;
  
  	return undef unless $exec;
  
  	my $all = wantarray;
  	my @results = ();
  
  	# check for aliases first
  	if ( IS_VMS ) {
  		my $symbol = `SHOW SYMBOL $exec`;
  		chomp($symbol);
  		unless ( $? ) {
  			return $symbol unless $all;
  			push @results, $symbol;
  		}
  	}
  	if ( IS_MAC ) {
  		my @aliases = split /\,/, $ENV{Aliases};
  		foreach my $alias ( @aliases ) {
  			# This has not been tested!!
  			# PPT which says MPW-Perl cannot resolve `Alias $alias`,
  			# let's just hope it's fixed
  			if ( lc($alias) eq lc($exec) ) {
  				chomp(my $file = `Alias $alias`);
  				last unless $file;  # if it failed, just go on the normal way
  				return $file unless $all;
  				push @results, $file;
  				# we can stop this loop as if it finds more aliases matching,
  				# it'll just be the same result anyway
  				last;
  			}
  		}
  	}
  
  	my @path = File::Spec->path;
  	if ( IS_DOS or IS_VMS or IS_MAC ) {
  		unshift @path, File::Spec->curdir;
  	}
  
  	foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
  		for my $ext ( @PATHEXT ) {
  			my $file = $base.$ext;
  
  			# We don't want dirs (as they are -x)
  			next if -d $file;
  
  			if (
  				# Executable, normal case
  				-x _
  				or (
  					# MacOS doesn't mark as executable so we check -e
  					IS_MAC
  					||
  					(
  						IS_DOS
  						and
  						grep {
  							$file =~ /$_\z/i
  						} @PATHEXT[1..$#PATHEXT]
  					)
  					# DOSish systems don't pass -x on
  					# non-exe/bat/com files. so we check -e.
  					# However, we don't want to pass -e on files
  					# that aren't in PATHEXT, like README.
  					and -e _
  				)
  			) {
  				return $file unless $all;
  				push @results, $file;
  			}
  		}
  	}
  
  	if ( $all ) {
  		return @results;
  	} else {
  		return undef;
  	}
  }
  
  sub where {
  	# force wantarray
  	my @res = which($_[0]);
  	return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::Which - Portable implementation of the `which' utility
  
  =head1 SYNOPSIS
  
    use File::Which;                  # exports which()
    use File::Which qw(which where);  # exports which() and where()
    
    my $exe_path = which('perldoc');
    
    my @paths = where('perl');
    - Or -
    my @paths = which('perl'); # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  C<File::Which> was created to be able to get the paths to executable programs
  on systems under which the `which' program wasn't implemented in the shell.
  
  C<File::Which> searches the directories of the user's C<PATH> (as returned by
  C<File::Spec-E<gt>path()>), looking for executable files having the name
  specified as a parameter to C<which()>. Under Win32 systems, which do not have a
  notion of directly executable files, but uses special extensions such as C<.exe>
  and C<.bat> to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head1 Steps Used on Win32, DOS, OS2 and VMS
  
  =head2 Windows NT
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head2 Windows 9x and other ancient Win/DOS/OS2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  =head2 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  =head1 Functions
  
  =head2 which($short_exe_name)
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where($short_exe_name)
  
  Not exported by default.
  
  Same as C<which($short_exe_name)> in array context. Same as the
  C<`where'> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 BUGS AND CAVEATS
  
  Not tested on VMS or MacOS, although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  File::Spec adds the current directory to the front of PATH if on
  Win32, VMS or MacOS. I have no knowledge of those so don't know if the
  current directory is searced first or not. Could someone please tell
  me?
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-Which>
  
  For other issues, contact the maintainer.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Per Einar Ellefsen E<lt>pereinar@cpan.orgE<gt>
  
  Originated in F<modperl-2.0/lib/Apache/Build.pm>. Changed for use in DocSet
  (for the mod_perl site) and Win32-awareness by me, with slight modifications
  by Stas Bekman, then extracted to create C<File::Which>.
  
  Version 0.04 had some significant platform-related changes, taken from
  the Perl Power Tools C<`which'> implementation by Abigail with
  enhancements from Peter Prymmer. See
  L<http://www.perl.com/language/ppt/src/which/index.html> for more
  information.
  
  =head1 COPYRIGHT
  
  Copyright 2002 Per Einar Ellefsen.
  
  Some parts copyright 2009 Adam Kennedy.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<which(1)>, Perl Power Tools:
  L<http://www.perl.com/language/ppt/index.html>.
  
  =cut
FILE_WHICH

$fatpacked{"FindBin/libs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FINDBIN_LIBS';
  ########################################################################
  # FindBin::libs_curr
  #
  # use $FindBin::Bin to search for 'lib' directories and use them.
  #
  # default action is to look for dir's named "lib" and silently use
  # the lib's without exporting anything. print turns on a short 
  # message with the abs_path results, export pushes out a variable
  # (default name is the base value), verbose turns on decision output
  # and print. export takes an optional argument with the name of a
  # variable to export.
  #
  # 
  ########################################################################
  
  ########################################################################
  # housekeeping
  ########################################################################
  
  package FindBin::libs;
  
  use v5.10;
  use strict;
  
  use FindBin;
  use Symbol;
  
  use File::Basename;
  
  use Carp        qw( croak           );
  use List::Util  qw( first           );
  use Symbol      qw( qualify_to_ref  );
  
  use File::Spec::Functions
  qw
  (
      &splitpath
      &splitdir
      &catpath
      &catdir
  );
  
  BEGIN
  {
      # however... there have been complaints of 
      # places where abs_path does not work. 
      #
      # if abs_path fails on the working directory
      # then replace it with rel2abs and live with 
      # possibly slower, redundant directories.
      #
      # the abs_path '//' hack allows for testing 
      # broken abs_path on primitive systems that
      # cannot handle the rooted system being linked
      # back to itself.
  
      use Cwd qw( &abs_path &cwd );
  
      unless( eval {abs_path '//';  abs_path cwd } )
      {
          # abs_path seems to be having problems,
          # fix is to stub it out.
          #
          # undef avoids nastygram.
  
          my $ref = qualify_to_ref 'abs_path', __PACKAGE__;
  
          my $sub = File::Spec::Functions->can( 'rel2abs' );
  
          undef &{ $ref };
  
          *$ref = $sub
      };
  }
  
  ########################################################################
  # package variables 
  ########################################################################
  
  our $VERSION = v1.63;
  
  my %defaultz = 
  (
      base    => 'lib',
      use     => undef,
      blib    => undef,   # prefer ./blib at the first level
  
      subdir  => '',      # add this subdir also if found.
      subonly => undef,   # leave out lib's, use only subdir.
      export  => undef,   # push variable into caller's space.
      verbose => undef,   # boolean: print inputs, results.
      debug   => undef,   # boolean: set internal breakpoints.
  
      print   => 1,       # display the results
  
      p5lib   => undef,   # prefix PERL5LIB with the results
  
      ignore => '/,/usr', # dir's to skip looking for ./lib
  );
  
  my @use_undef = qw( export ignore );
  
  # only new directories are used, ignore pre-loads
  # this with unwanted values.
  
  my %found = ();
  
  # saves passing this between import and $handle_args.
  
  my %argz    = ();
  my $verbose = '';
  my $empty   = q{};
  
  ########################################################################
  # subroutines
  ########################################################################
  
  # HAK ALERT: $Bin is an absolute path, there are cases
  # where splitdir does not add the leading '' onto the
  # directory path for it on VMS. Fix is to unshift a leading
  # '' into @dirpath where the leading entry is true.
  
  my $find_libs
  = sub
  {
      my $base    = basename ( shift || $argz{ base } );
  
      my $subdir  = $argz{ subdir } || '';
  
      my $subonly = defined $argz{ subonly };
  
      # for some reason, RH Enterprise V/4 has a 
      # trailing '/'; I havn't seen another copy of 
      # FindBin that does this. fix is quick enough: 
      # strip the trailing '/'.
      #
      # using a regex to extract the value untaints it
      # (not useful for anything much, just helps the
      # poor slobs stuck in taint mode).
      #
      # after that splitpath can grab the directory 
      # portion for future use.
  
      my ( $Bin ) = ( $argz{ Bin } =~ m{^ (.+) }xs );
  
      print STDERR "\nSearching $Bin for '$base'...\n"
      if $verbose;
  
      my( $vol, $dir ) = splitpath $Bin, 1;
  
      my @dirpath = splitdir $dir;
  
      # fix for File::Spec::VMS missing the leading empty
      # string on a split. this can be removed once File::Spec
      # is fixed.
  
      unshift @dirpath, '' if $dirpath[ 0 ];
  
      my @libz    = ();
  
      for( 1 .. @dirpath )
      {
          # note that catpath is extraneous on *NIX; the 
          # volume only means something on DOS- & VMS-based
          # filesystems, and adding an empty basename on 
          # *nix is unnecessary.
          #
          # HAK ALERT: the poor slobs stuck on windog have an
          # abs_path that croaks on missing directories. have
          # to eval the check for subdir's. 
  
          my $abs
          = eval
          {
              abs_path
              catpath $vol, ( catdir @dirpath, $base ), $empty
          }
          || '';
  
          my $sub
          = $subdir
          ? eval { abs_path ( catpath '', $abs, $subdir ) } || ''
          : ''
          ;
  
          my @search = $subonly ? ( $sub ) : ( $abs, $sub );
  
          for my $dir ( @search )
          {
              if( $dir && -d $dir && ! exists $found{ $dir } )
              {
                  $found{ $dir } = ();
  
                  push @libz, $dir;
              }
          }
  
          pop @dirpath
      }
  
      # caller gets back the existing lib paths 
      # (including volume) walking up the path 
      # from $FindBin::Bin -> root.
      #
      # passing it back as a list isn't all that
      # painful for a few paths.
  
      wantarray ? @libz : \@libz
  };
  
  # break out the messy part into a separate block.
  
  my $handle_args 
  = sub
  {
      # discard the module, rest are arguments.
  
      shift;
  
      # anything after the module are options with arguments
      # assigned via '='.
  
      %argz
      = map
      {
          my ( $k, $v ) = split '=', $_, 2;
  
          defined $v
          or
          first{ $k eq $_ } @use_undef 
          or 
          $v //= 1;
  
          # "no" inverts the sense of the test.
  
          $k =~ s{^no}{}
          and $v  = ! $v;
  
          ( $k => $v )
      }
      @_;
  
      # stuff "debug=1" into your arguments and perl -d will stop here.
  
      $DB::single = 1 if defined $argz{ debug };
  
      # default if nothing is supplied is to use the result;
      # otherwise, without use supplied either of export or
      # p5lib will turn off use.
  
      if( exists $argz{ use } )
      {
      # nothing further to do
      }
      elsif( defined $argz{ export } || defined $argz{ p5lib } )
      {
      $argz{ use } = undef;
      }
      else
      {
      $argz{ use } = 1;
      }
  
      local $defaultz{ Bin }
      = exists $argz{ realbin }
      ? $FindBin::RealBin
      : $FindBin::Bin
      ;
  
      # now apply the defaults, then sanity check the result.
      # base is a special case since it always has to exist.
      #
      # if $argz{ export } is defined but false then it takes
      # its default from $argz{ base }.
  
      while( my($k,$v) = each %defaultz )
      {
      # //= doesn't work here since undef may be a 
      # legit default.
  
      exists $argz{ $k }
      or
      $argz{ $k } = $v;
      }
  
      exists $argz{ base } && $argz{ base } 
      or croak "Bogus FindBin::libs: missing/false base argument, should be 'base=NAME'";
  
      exists $argz{ export }
      and
      $argz{ export } //= $argz{ base };
  
      $argz{ ignore } =
      [
          grep { $_ } split /\s*,\s*/, $argz{ ignore }
      ];
  
      $verbose = defined $argz{ verbose };
  
      my $base = $argz{ base };
  
      # now locate the libraries.
      #
      # %found contains the abs_path results for each directory to 
      # avoid double-including directories.
      #
      # note: loop short-curcuts for the (usually) list.
  
      %found = ();
  
      for( @{ $argz{ ignore } } )
      {
          if( my $dir = eval { abs_path catdir $_, $base } )
          {
              if( -d $dir )
              {
                  $found{ $dir } = 1;
              }
          }
      }
  };
  
  sub import
  {
      &$handle_args;
  
      my @libz = $find_libs->();
  
      # HAK ALERT: the regex does nothing for security,
      # just dodges -T. putting this down here instead
      # of inside find_libs allows people to use saner
      # untainting plans via find_libs.
  
      @libz   = map { m{ (.+) }x } @libz;
  
      my $caller = caller;
  
      if( $verbose || defined $argz{ print } )
      {
          local $\ = "\n";
          local $, = "\n\t";
  
          print STDERR "Found */$argz{ base }:", @libz
          if $verbose;
      }
  
      if( $argz{ export } )
      {
          my $dest    = qualify        $argz{ export }, $caller;
          my $ref     = qualify_to_ref $dest;
  
          print STDERR "\nExporting: \@$dest\n"
          if $verbose;
  
          # Symbol this is cleaner than "no strict" 
          # for installing the array.
  
          *$ref = \@libz;
      }
  
      if( defined $argz{ p5lib } )
      {
          # stuff the lib's found at the front of $ENV{ PERL5LIB }
  
          ( substr $ENV{ PERL5LIB }, 0, 0 ) = join ':', @libz, ''
          if @libz;
  
          print STDERR "\nUpdated PERL5LIB:\t$ENV{ PERL5LIB }\n"
          if $verbose;
      }
  
      if( $argz{ use } && @libz )
      {
          # this obviously won't work if lib ever depends 
          # on the caller's package.
          #
          # it does avoids issues with -T blowing up on the
          # old eval technique.
  
          require lib;
  
          lib->import( @libz );
      }
  
      0
  }
  
  # keep require happy
  
  1
  
  __END__
  
  =head1 NAME
  
  FindBin::libs - locate and a 'use lib' or export 
  directories based on $FindBin::Bin.
  
  =head1 SYNOPSIS
  
  This version of FindBin::libs is suitable for 
  Perl v5.10+.
  
      # search up $FindBin::Bin looking for ./lib directories
      # and "use lib" them.
  
      use FindBin::libs;
  
      # same as above with explicit defaults.
  
      use FindBin::libs qw( base=lib use=1 noexport noprint );
  
      # print the lib dir's before using them.
  
      use FindBin::libs qw( print );
  
      # find and use lib "altlib" dir's
  
      use FindBin::libs qw( base=altlib );
  
      # move starting point from $FindBin::Bin to '/tmp'
  
      use FindBin::libs qw( Bin=/tmp base=altlib );
  
      # skip "use lib", export "@altlib" instead.
  
      use FindBin::libs qw( base=altlib export );
  
      # find altlib directories, use lib them and export @mylibs
  
      use FindBin::libs qw( base=altlib export=mylibs use );
  
      # "export" defaults to "nouse", these two are identical:
  
      use FindBin::libs qw( export nouse );
      use FindBin::libs qw( export       );
  
      # use and export are not exclusive:
  
      use FindBin::libs qw( use export            ); # do both
      use FindBin::libs qw( nouse noexport print  ); # print only
      use FindBin::libs qw( nouse noexport        ); # do nothting at all
  
      # print a few interesting messages about the 
      # items found.
  
      use FindBinlibs qw( verbose );
  
      # turn on a breakpoint after the args are prcoessed, before
      # any search/export/use lib is handled.
  
      use FindBin::libs qw( debug );
  
      # prefix PERL5LIB with the lib's found.
  
      use FindBin::libs qw( perl5lib );
  
      # find a subdir of the lib's looked for.
      # the first example will use both ../lib and
      # ../lib/perl5; the second ../lib/perl5/frobnicate
      # (if they exist). it can also be used with export
      # and base to locate special configuration dir's.
      #
      # subonly with a base is useful for locating config
      # files. this finds any "./config/mypackage" dir's
      # without including any ./config dir's. the result
      # ends up in @config (see also "export=", above).
  
      use FindBin::libs qw( subdir=perl5 );
  
      use FindBin::libs qw( subdir=perl5/frobnicate );
  
      use FindBin::libs qw( base=config subdir=mypackage subonly export );
  
      # base and subonly are also useful if your 
      # project is stored in multiple git 
      # repositories. 
      #
      # say you need libs under api_foo/lib from api_bar: a
      # base of the git repository directory with subdir of
      # lib and subonly will pull in those lib dirs.
  
      use FindBin::libs qw( base=api_foo subdir=lib subonly );
  
      # no harm in using this multiple times to use
      # or export multple layers of libs.
  
      use FindBin::libs qw( export                                            );
      use FindBin::libs qw( export=found base=lib                             );
      use FindBin::libs qw( export=binz  base=bin            ignore=/foo,/bar );
      use FindBin::libs qw( export=junk  base=frobnicatorium                  );
      use FindBin::libs qw( export       base=foobar                          );
  
  =head1 DESCRIPTION
  
  =head2 General Use
  
  This module will locate directories along the path to $FindBin::Bin
  and "use lib" or export an array of the directories found. The default
  is to locate "lib" directories and "use lib" them without printing
  the list.
  
  Options controll whether the lib's found are exported into the caller's
  space, exported to PERL5LIB, or printed. Exporting or setting perl5lib
  will turn off the default of "use lib" so that:
  
      use FindBin::libs qw( export );
      use FindBin::libs qw( p5lib  );
  
  are equivalent to 
  
      use FindBin::libs qw( export nouse );
      use FindBin::libs qw( p5lib  nouse );
  
  Combining export with use or p5lib may be useful, p5lib and
  use are probably not all that useful together.
  
  =head3 Alternate directory name: 'base'
  
  The basename searched for can be changed via 'base=name' so
  that
  
      use FindBin::libs qw( base=altlib );
  
  will search for directories named "altlib" and "use lib" them.
  
  =head3 Exporting a variable: 'export'
  
  The 'export' option will push an array of the directories found
  and takes an optional argument of the array name, which defaults 
  to the basename searched for:
  
      use FindBin::libs qw( export );
  
  will find "lib" directories and export @lib with the
  list of directories found.
  
      use FindBin::libs qw( export=mylibs );
  
  will find "lib" directories and export them as "@mylibs" to
  the caller.
  
  If "export" only is given then the "use" option defaults to 
  false. So:
  
      use FindBin::libs qw( export );
      use FindBin::libs qw( export nouse );
  
  are equivalent. This is mainly for use when looking for data
  directories with the "base=" argument.
  
  If base is used with export the default array name is the base
  directory value:
  
      use FindBin::libs qw( export base=meta );
  
  exports @meta while
  
      use FindBin::libs qw( export=metadirs base=meta );
  
  exports @metadirs.
  
  The use and export switches are not exclusive:
  
      use FindBin::libs qw( use export=mylibs );
  
  will locate "lib" directories, use lib them, and export 
  @mylibs into the caller's package. 
  
  =head3 Subdirectories
  
  The "subdir" and "subonly" settings will add or 
  exclusively use subdir's. This is useful if some
  of your lib's are in ../lib/perl5 along with 
  ../lib (subdir=perl5) or all of the lib's are 
  in ../lib/perl5 (subonly=perl5).
  
  This can also be handy for locating subdir's used
  for configuring packages:
  
      use FindBin::libs qw( export base=config subonly=mypackage );
  
  Will leave @config with any "mypackage" holding
  any "mypackage" subdir's.
  
  =head3 Setting PERL5LIB: p5lib
  
  For cases where the environment is more useful for setting
  up library paths "p5lib" can be used to preload this variable.
  This is mainly useful for automatically including directories
  outside of the parent tree of $FindBin::bin.
  
  For example, using:
  
      $ export PERL5LIB="/usr/local/foo:/usr/local/bar";
  
      $ myprog;
  
  or simply
  
      $ PERL5LIB="/usr/local/lib/foo:/usr/lib/bar" myprog;
  
  (depending on your shell) with #! code including:
  
      use FindBin::libs qw( p5lib );
  
  will not "use lib" any dir's found but will update PERL5LIB
  to something like:
  
      /home/me/sandbox/branches/lib:/usr/local/lib/foo:/usr/lib/bar
  
  This can make controlling the paths used simpler and avoid
  the use of symlinks for some testing (see examples below).
  
  Note that "p5lib" and "nouse" are proably worth 
  
  =head2 Skipping directories
  
  By default, lib directories under / and /usr are
  sliently ignored. This normally means that /lib, /usr/lib, and
  '/usr/local/lib' are skipped. The "ignore" parameter provides
  a comma-separated list of directories to ignore:
  
      use FindBin::libs qw( ignore=/skip/this,/and/this/also );
  
  will replace the standard list and thus skip "/skip/this/lib"
  and "/and/this/also/lib". It will search "/lib" and "/usr/lib"
  since the argument ignore list replaces the original one.
  
  =head2 Homegrown Library Management 
  
  An all-too-common occurrance managing perly projects is
  being unable to install new modules becuse "it might 
  break things", and being unable to test them because
  you can't install them. The usual outcome of this is a 
  collection of hard-coded
  
      use lib qw( /usr/local/projectX ... )
  
  code at the top of each #! file that has to be updated by
  hand for each new project.
  
  To get away from this you'll often see relative paths
  for the lib's, which require running the code from one
  specific place. All this does is push the hard-coding
  into cron, shell wrappers, and begin blocks.
  
  With FindBin::libs you need suffer no more.
  
  Automatically finding libraries in and above the executable
  means you can put your modules into cvs/svn and check them
  out with the project, have multiple copies shared by developers,
  or easily move a module up the directory tree in a testbed
  to regression test the module with existing code. All without
  having to modify a single line of code.
  
  =over 4
  
  =item Code-speicfic modules.
  
  Say your sandbox is in ./sandbox and you are currently
  working in ./sandbox/projects/package/bin on a perl
  executable. You may have some number of modules that
  are specific -- or customized -- for this pacakge, 
  share some modules within the project, and may want 
  to use company-wide modules that are managed out of 
  ./sandbox in development. All of this lives under a 
  ./qc tree on the test boxes and under ./production 
  on production servers.
  
  For simplicity, say that your sandbox lives in your
  home direcotry, /home/jowbloe, as a directory or a
  symlink.
  
  If your #! uses FindBin::libs in it then it will
  effectively
  
      use lib
      qw(
          /home/jowbloe/sandbox/lib
          /home/jowbloe/sandbox/project/lib
          /home/jowbloe/sandbox/project/package/lib
      );
  
  if you run /home/jowbloe/sandbox/project/package/bin/foobar.
  This will happen the same way if you use a relative or
  absolute path, perl -d the thing, or if any of the lib
  directories are symlinks outside of your sandbox.
  
  This means that the most specific module directories
  ("closest" to your executable) will be picked up first.
  
  If you have a version of Frobnicate.pm in your ./package/lib
  for modifications fine: you'll use it before the one in 
  ./project or ./sandbox. 
  
  Using the "p5lib" argument can help in case where some of 
  the code lives outside of the sandbox. To test a sandbox
  version of some other module:
  
      use FindBin::libs qw( p5lib );
  
  and
  
      $ PERL5LIB=/other/sandbox/module foobar;
  
  =item Regression Testing
  
  Everntually, however, you'll need to regression test 
  Frobnicate.pm with other modules. 
  
  Fine: move, copy, or symlink it into ./project/lib and
  you can merrily run ./project/*/bin/* with it and see 
  if there are any problems. In fact, so can the nice 
  folks in QC. 
  
  If you want to install and test a new module just 
  prefix it into, say, ./sandbox/lib and all the code
  that has FindBin::libs will simply use it first. 
  
  =item Testing with Symlinks
  
  $FindBin::Bin is relative to where an executable is started from.
  This allows a symlink to change the location of directories used
  by FindBin::libs. Full regression testing of an executable can be
  accomplished with a symlink:
  
      ./sandbox
          ./lib -> /homegrown/dir/lib
          ./lib/What/Ever.pm
  
          ./pre-change
              ./bin/foobar
  
          ./post-change
              ./lib/What/Ever.pm
              ./bin/foobar -> ../../pre-last-change/bin/foobar
  
  Running foobar symlinked into the post-change directory will
  test it with whatever collection of modules is in the post-change
  directory. A large regression test on some collection of 
  changed modules can be performed with a few symlinks into a 
  sandbox area.
  
  =item Managing Configuration and Meta-data Files
  
  The "base" option alters FindBin::libs standard base directory.
  This allows for a heirarchical set of metadata directories:
  
      ./sandbox
          ./meta
          ./project/
              ./meta
  
          ./project/package
              ./bin
              ./meta
  
  with
  
      use FindBin::libs qw( base=meta export );
  
      sub read_meta
      {
          my $base = shift;
  
          for my $dir ( @meta )
          {
              # open the first one and return
              ...
          }
  
          # caller gets back empty list if nothing was read.
  
          ()
      }
  
  =item using "prove" with local modules.
  
  Modules that are not intended for CPAN will not usually have
  a Makefile.PL or Build setup. This makes it harder to check
  the code via "make test". Instead of hacking a one-time 
  Makefile, FindBin::libs can be used to locate modules in 
  a "lib" directory adjacent to the "t: directory. The setup
  for this module would look like:
  
  
      ./t/01.t
      ./t/02.t
      ...
  
      ./lib/FindBin/libs.pm
  
  since the *.t files use FindBin::libs they can locate the 
  most recent version of code without it having to be copied
  into a ./blib directory (usually via make) before being
  processed. If the module did not have a Makefile this would
  allow:
  
      prove t/*.t;
  
  to check the code.
  
  =back
  
  =head1 Notes
  
  =head2 Alternatives
  
  FindBin::libs was developed to avoid pitfalls with
  the items listed below. As of FindBin::libs-1.20,
  this is also mutli-platform, where other techniques
  may be limited to *NIX or at least less portable.
  
  =over 4
  
  =item PERL5LIBS
  
  PERL5LIB can be used to accomplish the same directory
  lookups as FindBin::libs.  The problem is PERL5LIB often
  contains absolte paths and does not automatically change
  depending on where tests are run. This can leave you 
  modifying a file, changing directory to see if it works
  with some other code and testing an unmodified version of 
  the code via PERL5LIB. FindBin::libs avoids this by using
  $FindBin::bin to reference where the code is running from.
  
  The same is true of trying to use almost any environmental
  solution, with Perl's built in mechanism or one based on
  $ENV{ PWD } or qx( pwd ).
  
  Aside: Combining an existing PERL5LIB for 
  out-of-tree lookups with the "p5lib" option 
  works well for most development situations. 
  
  =item use lib qw( ../../../../Lib );
  
  This works, but how many dots do you need to get all
  the working lib's into a module or #! code? Class
  distrubuted among several levels subdirectories may
  have qw( ../../../lib ) vs. qw( ../../../../lib )
  or various combinations of them. Validating these by
  hand (let alone correcting them) leaves me crosseyed
  after only a short session.
  
  =item Anchor on a fixed lib directory.
  
  Given a standard directory, it is possible to use
  something like:
  
      BEGIN
      {
          my ( $libdir ) = $0 =~ m{ ^( .+? )/SOMEDIR/ }x;
  
          eval "use lib qw( $libdir )";
      }
  
  This looks for a standard location (e.g., /path/to/Mylib)
  in the executable path (or cwd) and uses that. 
  
  The main problem here is that if the anchor ever changes
  (e.g., when moving code between projects or relocating 
  directories now that SVN supports it) the path often has
  to change in multiple files. The regex also may have to
  support multiple platforms, or be broken into more complicated
  File::Spec code that probably looks pretty much like what
  
      use FindBin::libs qw( base=Mylib )
  
  does anyway.
  
  =back
  
  =head2 FindBin::libs-1.2+ uses File::Spec
  
  In order to accmodate a wider range of filesystems, 
  the code has been re-written to use File::Spec for
  all directory and volume manglement. 
  
  There is one thing that File::Spec does not handle,
  hoever, which is fully reolving absolute paths. That
  still has to be handled via abs_path, when it works.
  
  The issue is that File::Spec::rel2abs and 
  Cwd::abs_path work differently: abs_path only 
  returns true for existing directories and 
  resolves symlinks; rel2abs simply prepends cwd() 
  to any non-absolute paths.
  
  The difference for FinBin::libs is that 
  including redundant directories can lead to 
  unexpected results in what gets included; 
  looking up the contents of heavily-symlinked 
  paths is slow (and has some -- admittedly 
  unlikely -- failures at runtime). So, abs_path() 
  is the preferred way to find where the lib's 
  really live after they are found looking up the 
  tree. Using abs_path() also avoids problems 
  where the same directory is included twice in a 
  sandbox' tree via symlinks.
  
  Due to previous complaints that abs_path did not 
  work properly on all systems, the current 
  version of FindBin::libs uses File::Spec to 
  break apart and re-assemble directories, with 
  abs_path used optinally. If "abs_path cwd" works 
  then abs_path is used on the directory paths 
  handed by File::Spec::catpath(); otherwise the 
  paths are used as-is. This may leave users on 
  systms with non-working abs_path() having extra
  copies of external library directories in @INC.
  
  Another issue is that I've heard reports of 
  some systems failing the '-d' test on symlinks,
  where '-e' would have succeded. 
  
  =head1 See Also
  
  =over 4
  
  =item File::Spec
  
  This is used for portability in dis- and re-assembling 
  directory paths based on $FindBin::Bin.
  
  =item Older code.
  
  FindBin::libs_5_8.pm is installed if $^V indicates
  that the running perl is prior to v5.10.
  
  =back
  
  =head1 BUGS
  
  =over 4
  
  =item 
  
  In order to avoid including junk, FindBin::libs
  uses '-d' to test the items before including
  them on the library list. This works fine so 
  long as abs_path() is used to disambiguate any
  symlinks first. If abs_path() is turned off
  then legitimate directories may be left off in
  whatever local conditions might cause a valid
  symlink to fail the '-d' test."
  
  =item
  
  File::Spec 3.16 and prior have a bug in VMS of
  not returning an absolute paths in splitdir for
  dir's without a leading '.'. Fix for this is to
  unshift '', @dirpath if $dirpath[0]. While not a
  bug, this is obviously a somewhat kludgy workaround
  and should be removed (with an added test for a 
  working version) once the File::Spec is fixed.
  
  =item 
  
  The hack for prior-to-5.12 versions of perl is 
  messy, but is the only I've found that works for
  the moment on *NIX, VMS, and MSW. I am not sure
  whether any of these systems are normally configured
  to share perl modules between versions. If the 
  moduels are not shared on multiple platforms then
  I can make this work by managing the installation
  rather than checking this every time at startup.
  
  For the moment, at least, this seems to work.
  
  =back
  
  =head1 AUTHOR
  
  Steven Lembark, Workhorse Computing <lembark@wrkhors.com>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2003-2012, Steven Lembark, Workhorse Computing.
  This code is released under the same terms as Perl-5.10
  or any later version of Perl.
FINDBIN_LIBS

$fatpacked{"Import/Into.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IMPORT_INTO';
  package Import::Into;
  
  use strict;
  use warnings FATAL => 'all';
  
  our $VERSION = '1.002000'; # 1.2.0
  
  sub _prelude {
    my $target = shift;
    my ($package, $file, $line, $level)
      = ref $target         ? @{$target}{qw(package filename line)}
      : $target =~ /[^0-9]/ ? ($target)
                            : (undef, undef, undef, $target);
    if (defined $level) {
      my ($p, $fn, $ln) = caller($level + 2);
      $package ||= $p;
      $file    ||= $fn;
      $line    ||= $ln;
    }
    qq{package $package;\n}
      . ($file ? "#line $line \"$file\"\n" : '')
  }
  
  sub _make_action {
    my ($action, $target) = @_;
    my $version = ref $target && $target->{version};
    my $ver_check = $version ? '$_[0]->VERSION($version);' : '';
    eval _prelude($target).qq{sub { $ver_check shift->$action(\@_) }}
      or die "Failed to build action sub to ${action} for ${target}: $@";
  }
  
  sub import::into {
    my ($class, $target, @args) = @_;
    _make_action(import => $target)->($class, @args);
  }
  
  sub unimport::out_of {
    my ($class, $target, @args) = @_;
    _make_action(unimport => $target)->($class, @args);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Import::Into - import packages into other packages
  
  =head1 SYNOPSIS
  
    package My::MultiExporter;
  
    use Import::Into;
  
    use Thing1 ();
    use Thing2 ();
  
    # simple
    sub import {
      Thing1->import::into(scalar caller);
    }
  
    # multiple
    sub import {
      my $target = caller;
      Thing1->import::into($target);
      Thing2->import::into($target, qw(import arguments));
    }
  
    # by level
    sub import {
      Thing1->import::into(1);
    }
  
    # with exporter
    use base qw(Exporter);
    sub import {
      shift->export_to_level(1);
      Thing1->import::into(1);
    }
  
    # no My::MultiExporter == no Thing1
    sub unimport {
      Thing1->unimport::out_of(scalar caller);
    }
  
  People wanting to re-export your module should also be using L<Import::Into>.
  Any exporter or pragma will work seamlessly.
  
  Note: You do B<not> need to make any changes to Thing1 to be able to call
  C<import::into> on it. This is a global method, and is callable on any
  package (and in fact on any object as well, although it's rarer that you'd
  want to do that).
  
  =head1 DESCRIPTION
  
  Writing exporters is a pain. Some use L<Exporter>, some use L<Sub::Exporter>,
  some use L<Moose::Exporter>, some use L<Exporter::Declare> ... and some things
  are pragmas.
  
  Exporting on someone else's behalf is harder.  The exporters don't provide a
  consistent API for this, and pragmas need to have their import method called
  directly, since they effect the current unit of compilation.
  
  C<Import::Into> provides global methods to make this painless.
  
  =head1 METHODS
  
  =head2 $package->import::into( $target, @arguments );
  
  A global method, callable on any package.  Imports the given package into
  C<$target>.  C<@arguments> are passed along to the package's import method.
  
  C<$target> can be an package name to export to, an integer for the
  caller level to export to, or a hashref with the following options:
  
  =over 4
  
  =item package
  
  The target package to export to.
  
  =item filename
  
  The apparent filename to export to.  Some exporting modules, such as
  L<autodie> or L<strictures>, care about the filename they are being imported
  to.
  
  =item line
  
  The apparent line number to export to.  To be combined with the C<filename>
  option.
  
  =item level
  
  The caller level to export to.  This will automatically populate the
  C<package>, C<filename>, and C<line> options, making it the easiest most
  constent option.
  
  =item version
  
  A version number to check for the module.  The equivalent of specifying the
  version number on a C<use> line.
  
  =back
  
  =head2 $package->unimport::out_of( $target, @arguments );
  
  Equivalent to C<import::into>, but dispatches to C<$package>'s C<unimport>
  method instead of C<import>.
  
  =head1 WHY USE THIS MODULE
  
  The APIs for exporting modules aren't consistent.  L<Exporter> subclasses
  provide export_to_level, but if they overrode their import method all bets
  are off.  L<Sub::Exporter> provides an into parameter but figuring out
  something used it isn't trivial. Pragmas need to have their C<import> method
  called directly since they affect the current unit of compilation.
  
  It's ... annoying.
  
  However, there is an approach that actually works for all of these types.
  
    eval "package $target; use $thing;"
  
  will work for anything checking caller, which is everything except pragmas.
  But it doesn't work for pragmas - pragmas need:
  
    $thing->import;
  
  because they're designed to affect the code currently being compiled - so
  within an eval, that's the scope of the eval itself, not the module that
  just C<use>d you - so
  
    sub import {
      eval "use strict;"
    }
  
  doesn't do what you wanted, but
  
    sub import {
      strict->import;
    }
  
  will apply L<strict> to the calling file correctly.
  
  Of course, now you have two new problems - first, that you still need to
  know if something's a pragma, and second that you can't use either of
  these approaches alone on something like L<Moose> or L<Moo> that's both
  an exporter and a pragma.
  
  So, a solution for that is:
  
    my $sub = eval "package $target; sub { shift->import(\@_) }";
    $sub->($thing, @import_args);
  
  which means that import is called from the right place for pragmas to take
  effect, and from the right package for caller checking to work - and so
  behaves correctly for all types of exporter, for pragmas, and for hybrids.
  
  Additionally, some import routines check the filename they are being imported
  to.  This can be dealt with by generating a L<#line directive|perlsyn/Plain
  Old Comments (Not!)> in the eval, which will change what C<caller> reports for
  the filename when called in the importer. The filename and line number to use
  in the directive then need to be fetched using C<caller>:
  
    my ($target, $file, $line) = caller(1);
    my $sub = eval qq{
      package $target;
    #line $line "$file"
      sub { shift->import(\@_) }
    };
    $sub->($thing, @import_args);
  
  And you need to switch between these implementations depending on if you are
  targetting a specific package, or something in your call stack.
  
  Remembering all this, however, is excessively irritating. So I wrote a module
  so I didn't have to anymore. Loading L<Import::Into> creates a global method
  C<import::into> which you can call on any package to import it into another
  package. So now you can simply write:
  
    use Import::Into;
  
    $thing->import::into($target, @import_args);
  
  This works because of how perl resolves method calls - a call to a simple
  method name is resolved against the package of the class or object, so
  
    $thing->method_name(@args);
  
  is roughly equivalent to:
  
    my $code_ref = $thing->can('method_name');
    $code_ref->($thing, @args);
  
  while if a C<::> is found, the lookup is made relative to the package name
  (i.e. everything before the last C<::>) so
  
    $thing->Package::Name::method_name(@args);
  
  is roughly equivalent to:
  
    my $code_ref = Package::Name->can('method_name');
    $code_ref->($thing, @args);
  
  So since L<Import::Into> defines a method C<into> in package C<import>
  the syntax reliably calls that.
  
  For more craziness of this order, have a look at the article I wrote at
  L<http://shadow.cat/blog/matt-s-trout/madness-with-methods> which covers
  coderef abuse and the C<${\...}> syntax.
  
  Final note: You do still need to ensure that you already loaded C<$thing> - if
  you're receiving this from a parameter, I recommend using L<Module::Runtime>:
  
    use Import::Into;
    use Module::Runtime qw(use_module);
  
    use_module($thing)->import::into($target, @import_args);
  
  And that's it.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Getty for asking "how can I get C<< use strict; use warnings; >>
  turned on for all consumers of my code?" and then "why is this not a
  module?!".
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Import::Into L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
IMPORT_INTO

$fatpacked{"Log/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE';
  package Log::Message;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  
  use Params::Check qw[check];
  use Log::Message::Item;
  use Log::Message::Config;
  use Locale::Maketext::Simple Style => 'gettext';
  
  local $Params::Check::VERBOSE = 1;
  
  BEGIN {
      use vars        qw[$VERSION @ISA $STACK $CONFIG];
      $VERSION    =   '0.08';
      $STACK      =   [];
  }
  
  
  =pod
  
  =head1 NAME
  
  Log::Message - A generic message storing mechanism;
  
  =head1 SYNOPSIS
  
      use Log::Message private => 0, config => '/our/cf_file';
  
      my $log = Log::Message->new(    private => 1,
                                      level   => 'log',
                                      config  => '/my/cf_file',
                                 );
  
      $log->store('this is my first message');
  
      $log->store(    message => 'message #2',
                      tag     => 'MY_TAG',
                      level   => 'carp',
                      extra   => ['this is an argument to the handler'],
                 );
  
      my @last_five_items = $log->retrieve(5);
  
      my @items = $log->retrieve( tag     => qr/my_tag/i,
                                  message => qr/\d/,
                                  remove  => 1,
                                );
  
      my @items = $log->final( level => qr/carp/, amount => 2 );
  
      my $first_error = $log->first()
  
      # croak with the last error on the stack
      $log->final->croak;
  
      # empty the stack
      $log->flush();
  
  
  =head1 DESCRIPTION
  
  Log::Message is a generic message storage mechanism.
  It allows you to store messages on a stack -- either shared or private
  -- and assign meta-data to it.
  Some meta-data will automatically be added for you, like a timestamp
  and a stack trace, but some can be filled in by the user, like a tag
  by which to identify it or group it, and a level at which to handle
  the message (for example, log it, or die with it)
  
  Log::Message also provides a powerful way of searching through items
  by regexes on messages, tags and level.
  
  =head1 Hierarchy
  
  There are 4 modules of interest when dealing with the Log::Message::*
  modules:
  
  =over 4
  
  =item Log::Message
  
  Log::Message provides a few methods to manipulate the stack it keeps.
  It has the option of keeping either a private or a public stack.
  More on this below.
  
  =item Log::Message::Item
  
  These are individual message items, which are objects that contain
  the user message as well as the meta-data described above.
  See the L<Log::Message::Item> manpage to see how to extract this
  meta-data and how to work with the Item objects.
  You should never need to create your own Item objects, but knowing
  about their methods and accessors is important if you want to write
  your own handlers. (See below)
  
  =item Log::Message::Handlers
  
  These are a collection of handlers that will be called for a level
  that is used on a L<Log::Message::Item> object.
  For example, if a message is logged with the 'carp' level, the 'carp'
  handler from L<Log::Message::Handlers> will be called.
  See the L<Log::Message::Handlers> manpage for more explanation about how
  handlers work, which one are available and how to create your own.
  
  =item Log::Message::Config
  
  Per Log::Message object, there is a configuration required that will
  fill in defaults if the user did not specify arguments to override
  them (like for example what tag will be set if none was provided),
  L<Log::Message::Config> handles the creation of these configurations.
  
  Configuration can be specified in 4 ways:
  
  =over 4
  
  =item *
  
  As a configuration file when you C<use Log::Message>
  
  =item *
  
  As arguments when you C<use Log::Message>
  
  =item *
  
  As a configuration file when you create a new L<Log::Message> object.
  (The config will then only apply to that object if you marked it as
  private)
  
  =item *
  
  As arguments when you create a new Log::Message object.
  
  You should never need to use the L<Log::Message::Config> module yourself,
  as this is transparently done by L<Log::Message>, but its manpage does
  provide an explanation of how you can create a config file.
  
  =back
  
  =back
  
  =head1 Options
  
  When using Log::Message, or creating a new Log::Message object, you can
  supply various options to alter its behaviour.
  Of course, there are sensible defaults should you choose to omit these
  options.
  
  Below an explanation of all the options and how they work.
  
  =over 4
  
  =item config
  
  The path to a configuration file to be read.
  See the manpage of L<Log::Message::Config> for the required format
  
  These options will be overridden by any explicit arguments passed.
  
  =item private
  
  Whether to create, by default, private or shared objects.
  If you choose to create shared objects, all Log::Message objects will
  use the same stack.
  
  This means that even though every module may make its own $log object
  they will still be sharing the same error stack on which they are
  putting errors and from which they are retrieving.
  
  This can be useful in big projects.
  
  If you choose to create a private object, then the stack will of
  course be private to this object, but it will still fall back to the
  shared config should no private config or overriding arguments be
  provided.
  
  =item verbose
  
  Log::Message makes use of another module to validate its arguments,
  which is called L<Params::Check>, which is a lightweight, yet
  powerful input checker and parser. (See the L<Params::Check>
  manpage for details).
  
  The verbose setting will control whether this module will
  generate warnings if something improper is passed as input, or merely
  silently returns undef, at which point Log::Message will generate a
  warning.
  
  It's best to just leave this at its default value, which is '1'
  
  =item tag
  
  The tag to add to messages if none was provided. If neither your
  config, nor any specific arguments supply a tag, then Log::Message will
  set it to 'NONE'
  
  Tags are useful for searching on or grouping by. For example, you
  could tag all the messages you want to go to the user as 'USER ERROR'
  and all those that are only debug information with 'DEBUG'.
  
  At the end of your program, you could then print all the ones tagged
  'USER ERROR' to STDOUT, and those marked 'DEBUG' to a log file.
  
  =item level
  
  C<level> describes what action to take when a message is logged. Just
  like C<tag>, Log::Message will provide a default (which is 'log') if
  neither your config file, nor any explicit arguments are given to
  override it.
  
  See the Log::Message::Handlers manpage to see what handlers are
  available by default and what they do, as well as to how to add your
  own handlers.
  
  =item remove
  
  This indicates whether or not to automatically remove the messages
  from the stack when you've retrieved them.
  The default setting provided by Log::Message is '0': do not remove.
  
  =item chrono
  
  This indicates whether messages should always be fetched in
  chronological order or not.
  This simply means that you can choose whether, when retrieving items,
  the item most recently added should be returned first, or the one that
  had been added most long ago.
  
  The default is to return the newest ones first
  
  =back
  
  =cut
  
  
  ### subs ###
  sub import {
      my $pkg     = shift;
      my %hash    = @_;
  
      $CONFIG = new Log::Message::Config( %hash )
                  or die loc(qq[Problem initialising %1], __PACKAGE__);
  
  }
  
  =head1 Methods
  
  =head2 new
  
  This creates a new Log::Message object; The parameters it takes are
  described in the C<Options> section below and let it just be repeated
  that you can use these options like this:
  
      my $log = Log::Message->new( %options );
  
  as well as during C<use> time, like this:
  
      use Log::Message option1 => value, option2 => value
  
  There are but 3 rules to keep in mind:
  
  =over 4
  
  =item *
  
  Provided arguments take precedence over a configuration file.
  
  =item *
  
  Arguments to new take precedence over options provided at C<use> time
  
  =item *
  
  An object marked private will always have an empty stack to begin with
  
  =back
  
  =cut
  
  sub new {
      my $class   = shift;
      my %hash    = @_;
  
      my $conf = new Log::Message::Config( %hash, default => $CONFIG ) or return undef;
  
      if( $conf->private || $CONFIG->private ) {
  
          return _new_stack( $class, config => $conf );
  
      } else {
          my $obj = _new_stack( $class, config => $conf, stack => $STACK );
  
          ### if it was an empty stack, this was the first object
          ### in that case, set the global stack to match it for
          ### subsequent new, non-private objects
          $STACK = $obj->{STACK} unless scalar @$STACK;
  
          return $obj;
      }
  }
  
  sub _new_stack {
      my $class = shift;
      my %hash  = @_;
  
      my $tmpl = {
          stack   => { default        => [] },
          config  => { default        => bless( {}, 'Log::Message::Config'),
                       required       => 1,
                       strict_type    => 1
                  },
      };
  
      my $args = check( $tmpl, \%hash, $CONFIG->verbose ) or (
          warn(loc(q[Could not create a new stack object: %1],
                  Params::Check->last_error)
          ),
          return
      );
  
  
      my %self = map { uc, $args->{$_} } keys %$args;
  
      return bless \%self, $class;
  }
  
  sub _get_conf {
      my $self = shift;
      my $what = shift;
  
      return defined $self->{CONFIG}->$what()
                  ?  $self->{CONFIG}->$what()
                  :  defined $CONFIG->$what()
                          ?  $CONFIG->$what()
                          :  undef;           # should never get here
  }
  
  =head2 store
  
  This will create a new Item object and store it on the stack.
  
  Possible arguments you can give to it are:
  
  =over 4
  
  =item message
  
  This is the only argument that is required. If no other arguments
  are given, you may even leave off the C<message> key. The argument
  will then automatically be assumed to be the message.
  
  =item tag
  
  The tag to add to this message. If not provided, Log::Message will look
  in your configuration for one.
  
  =item level
  
  The level at which this message should be handled. If not provided,
  Log::Message will look in your configuration for one.
  
  =item extra
  
  This is an array ref with arguments passed to the handler for this
  message, when it is called from store();
  
  The handler will receive them as a normal list
  
  =back
  
  store() will return true upon success and undef upon failure, as well
  as issue a warning as to why it failed.
  
  =cut
  
  ### should extra be stored in the item object perhaps for later retrieval?
  sub store {
      my $self = shift;
      my %hash = ();
  
      my $tmpl = {
          message => {
                  default     => '',
                  strict_type => 1,
                  required    => 1,
              },
          tag     => { default => $self->_get_conf('tag')     },
          level   => { default => $self->_get_conf('level'),  },
          extra   => { default => [], strict_type => 1 },
      };
  
      ### single arg means just the message
      ### otherwise, they are named
      if( @_ == 1 ) {
          $hash{message} = shift;
      } else {
          %hash = @_;
      }
  
      my $args = check( $tmpl, \%hash ) or (
          warn( loc(q[Could not store error: %1], Params::Check->last_error) ),
          return
      );
  
      my $extra = delete $args->{extra};
      my $item = Log::Message::Item->new(   %$args,
                                          parent  => $self,
                                          id      => scalar @{$self->{STACK}}
                                      )
              or ( warn( loc(q[Could not create new log item!]) ), return undef );
  
      push @{$self->{STACK}}, $item;
  
      {   no strict 'refs';
  
          my $sub = $args->{level};
  
          $item->$sub( @$extra );
      }
  
      return 1;
  }
  
  =head2 retrieve
  
  This will retrieve all message items matching the criteria specified
  from the stack.
  
  Here are the criteria you can discriminate on:
  
  =over 4
  
  =item tag
  
  A regex to which the tag must adhere. For example C<qr/\w/>.
  
  =item level
  
  A regex to which the level must adhere.
  
  =item message
  
  A regex to which the message must adhere.
  
  =item amount
  
  Maximum amount of errors to return
  
  =item chrono
  
  Return in chronological order, or not?
  
  =item remove
  
  Remove items from the stack upon retrieval?
  
  =back
  
  In scalar context it will return the first item matching your criteria
  and in list context, it will return all of them.
  
  If an error occurs while retrieving, a warning will be issued and
  undef will be returned.
  
  =cut
  
  sub retrieve {
      my $self = shift;
      my %hash = ();
  
      my $tmpl = {
          tag     => { default => qr/.*/ },
          level   => { default => qr/.*/ },
          message => { default => qr/.*/ },
          amount  => { default => '' },
          remove  => { default => $self->_get_conf('remove')  },
          chrono  => { default => $self->_get_conf('chrono')  },
      };
  
      ### single arg means just the amount
      ### otherwise, they are named
      if( @_ == 1 ) {
          $hash{amount} = shift;
      } else {
          %hash = @_;
      }
  
      my $args = check( $tmpl, \%hash ) or (
          warn( loc(q[Could not parse input: %1], Params::Check->last_error) ),
          return
      );
  
      my @list =
              grep { $_->tag      =~ /$args->{tag}/       ? 1 : 0 }
              grep { $_->level    =~ /$args->{level}/     ? 1 : 0 }
              grep { $_->message  =~ /$args->{message}/   ? 1 : 0 }
              grep { defined }
                  $args->{chrono}
                      ? @{$self->{STACK}}
                      : reverse @{$self->{STACK}};
  
      my $amount = $args->{amount} || scalar @list;
  
      my @rv = map {
                  $args->{remove} ? $_->remove : $_
             } scalar @list > $amount
                              ? splice(@list,0,$amount)
                              : @list;
  
      return wantarray ? @rv : $rv[0];
  }
  
  =head2 first
  
  This is a shortcut for retrieving the first item(s) stored on the
  stack. It will default to only retrieving one if called with no
  arguments, and will always return results in chronological order.
  
  If you only supply one argument, it is assumed to be the amount you
  wish returned.
  
  Furthermore, it can take the same arguments as C<retrieve> can.
  
  =cut
  
  sub first {
      my $self = shift;
  
      my $amt = @_ == 1 ? shift : 1;
      return $self->retrieve( amount => $amt, @_, chrono => 1 );
  }
  
  =head2 last
  
  This is a shortcut for retrieving the last item(s) stored on the
  stack. It will default to only retrieving one if called with no
  arguments, and will always return results in reverse chronological
  order.
  
  If you only supply one argument, it is assumed to be the amount you
  wish returned.
  
  Furthermore, it can take the same arguments as C<retrieve> can.
  
  =cut
  
  sub final {
      my $self = shift;
  
      my $amt = @_ == 1 ? shift : 1;
      return $self->retrieve( amount => $amt, @_, chrono => 0 );
  }
  
  =head2 flush
  
  This removes all items from the stack and returns them to the caller
  
  =cut
  
  sub flush {
      my $self = shift;
  
      return splice @{$self->{STACK}};
  }
  
  =head1 SEE ALSO
  
  L<Log::Message::Item>, L<Log::Message::Handlers>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE

$fatpacked{"Log/Message/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_CONFIG';
  package Log::Message::Config;
  use if $] > 5.017, 'deprecate';
  use strict;
  
  use Params::Check qw[check];
  use Module::Load;
  use FileHandle;
  use Locale::Maketext::Simple Style => 'gettext';
  
  BEGIN {
      use vars        qw[$VERSION $AUTOLOAD];
      $VERSION    =   '0.08';
  }
  
  sub new {
      my $class = shift;
      my %hash  = @_;
  
      ### find out if the user specified a config file to use
      ### and/or a default configuration object
      ### and remove them from the argument hash
      my %special =   map { lc, delete $hash{$_} }
                      grep /^config|default$/i, keys %hash;
  
      ### allow provided arguments to override the values from the config ###
      my $tmpl = {
          private => { default => undef,  },
          verbose => { default => 1       },
          tag     => { default => 'NONE', },
          level   => { default => 'log',  },
          remove  => { default => 0       },
          chrono  => { default => 1       },
      };
  
      my %lc_hash = map { lc, $hash{$_} } keys %hash;
  
      my $file_conf;
      if( $special{config} ) {
          $file_conf = _read_config_file( $special{config} )
                          or ( warn( loc(q[Could not parse config file!]) ), return );
      }
  
      my $def_conf = \%{ $special{default} || {} };
  
      ### make sure to only include keys that are actually defined --
      ### the checker will assign even 'undef' if you have provided that
      ### as a value
      ### priorities goes as follows:
      ### 1: arguments passed
      ### 2: any config file passed
      ### 3: any default config passed
      my %to_check =  map     { @$_ }
                      grep    { defined $_->[1] }
                      map     {   [ $_ =>
                                      defined $lc_hash{$_}        ? $lc_hash{$_}      :
                                      defined $file_conf->{$_}    ? $file_conf->{$_}  :
                                      defined $def_conf->{$_}     ? $def_conf->{$_}   :
                                      undef
                                  ]
                              } keys %$tmpl;
  
      my $rv = check( $tmpl, \%to_check, 1 )
                  or ( warn( loc(q[Could not validate arguments!]) ), return );
  
      return bless $rv, $class;
  }
  
  sub _read_config_file {
      my $file = shift or return;
  
      my $conf = {};
      my $FH = new FileHandle;
      $FH->open("$file", 'r') or (
                          warn(loc(q[Could not open config file '%1': %2],$file,$!)),
                          return {}
                      );
  
      while(<$FH>) {
          next if     /\s*#/;
          next unless /\S/;
  
          chomp; s/^\s*//; s/\s*$//;
  
          my ($param,$val) = split /\s*=\s*/;
  
          if( (lc $param) eq 'include' ) {
              load $val;
              next;
          }
  
          ### add these to the config hash ###
          $conf->{ lc $param } = $val;
      }
      close $FH;
  
      return $conf;
  }
  
  sub AUTOLOAD {
      $AUTOLOAD =~ s/.+:://;
  
      my $self = shift;
  
      return $self->{ lc $AUTOLOAD } if exists $self->{ lc $AUTOLOAD };
  
      die loc(q[No such accessor '%1' for class '%2'], $AUTOLOAD, ref $self);
  }
  
  sub DESTROY { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Log::Message::Config - Configuration options for Log::Message
  
  =head1 SYNOPSIS
  
      # This module is implicitly used by Log::Message to create a config
      # which it uses to log messages.
      # For the options you can pass, see the C<Log::Message new()> method.
  
      # Below is a sample of a config file you could use
  
      # comments are denoted by a single '#'
      # use a shared stack, or have a private instance?
      # if none provided, set to '0',
      private = 1
  
      # do not be verbose
      verbose = 0
  
      # default tag to set on new items
      # if none provided, set to 'NONE'
      tag = SOME TAG
  
      # default level to handle items
      # if none provided, set to 'log'
      level = carp
  
      # extra files to include
      # if none provided, no files are auto included
      include = mylib.pl
      include = ../my/other/lib.pl
  
      # automatically delete items
      # when you retrieve them from the stack?
      # if none provided, set to '0'
      remove = 1
  
      # retrieve errors in chronological order, or not?
      # if none provided, set to '1'
      chrono = 0
  
  =head1 DESCRIPTION
  
  Log::Message::Config provides a standardized config object for
  Log::Message objects.
  
  It can either read options as perl arguments, or as a config file.
  See the Log::Message manpage for more information about what arguments
  are valid, and see the Synopsis for an example config file you can use
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Item>, L<Log::Message::Handlers>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_CONFIG

$fatpacked{"Log/Message/Handlers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_HANDLERS';
  package Log::Message::Handlers;
  use if $] > 5.017, 'deprecate';
  use strict;
  use vars qw[$VERSION];
  
  $VERSION = '0.08';
  
  =pod
  
  =head1 NAME
  
  Log::Message::Handlers - Message handlers for Log::Message
  
  =head1 SYNOPSIS
  
      # Implicitly used by Log::Message to serve as handlers for
      # Log::Message::Item objects
  
      # Create your own file with a package called
      # Log::Message::Handlers to add to the existing ones, or to even
      # overwrite them
  
      $item->carp;
  
      $item->trace;
  
  
  =head1 DESCRIPTION
  
  Log::Message::Handlers provides handlers for Log::Message::Item objects.
  The handler corresponding to the level (see Log::Message::Item manpage
  for an explanation about levels) will be called automatically upon
  storing the error.
  
  Handlers may also explicitly be called on an Log::Message::Item object
  if one so desires (see the Log::Message manpage on how to retrieve the
  Item objects).
  
  =head1 Default Handlers
  
  =head2 log
  
  Will simply log the error on the stack, and do nothing special
  
  =cut
  
  sub log { 1 }
  
  =head2 carp
  
  Will carp (see the Carp manpage) with the error, and add the timestamp
  of when it occurred.
  
  =cut
  
  sub carp {
      my $self = shift;
      warn join " ", $self->message, $self->shortmess, 'at', $self->when, "\n";
  }
  
  =head2 croak
  
  Will croak (see the Carp manpage) with the error, and add the
  timestamp of when it occurred.
  
  =cut
  
  sub croak {
      my $self = shift;
      die join " ", $self->message, $self->shortmess, 'at', $self->when, "\n";
  }
  
  =head2 cluck
  
  Will cluck (see the Carp manpage) with the error, and add the
  timestamp of when it occurred.
  
  =cut
  
  sub cluck {
      my $self = shift;
      warn join " ", $self->message, $self->longmess, 'at', $self->when, "\n";
  }
  
  =head2 confess
  
  Will confess (see the Carp manpage) with the error, and add the
  timestamp of when it occurred
  
  =cut
  
  sub confess {
      my $self = shift;
      die join " ", $self->message, $self->longmess, 'at', $self->when, "\n";
  }
  
  =head2 die
  
  Will simply die with the error message of the item
  
  =cut
  
  sub die  { die  shift->message; }
  
  
  =head2 warn
  
  Will simply warn with the error message of the item
  
  =cut
  
  sub warn { warn shift->message; }
  
  
  =head2 trace
  
  Will provide a traceback of this error item back to the first one that
  occurred, clucking with every item as it comes across it.
  
  =cut
  
  sub trace {
      my $self = shift;
  
      for my $item( $self->parent->retrieve( chrono => 0 ) ) {
          $item->cluck;
      }
  }
  
  =head1 Custom Handlers
  
  If you wish to provide your own handlers, you can simply do the
  following:
  
  =over 4
  
  =item *
  
  Create a file that holds a package by the name of
  C<Log::Message::Handlers>
  
  =item *
  
  Create subroutines with the same name as the levels you wish to
  handle in the Log::Message module (see the Log::Message manpage for
  explanation on levels)
  
  =item *
  
  Require that file in your program, or add it in your configuration
  (see the Log::Message::Config manpage for explanation on how to use a
  config file)
  
  =back
  
  And that is it, the handler will now be available to handle messages
  for you.
  
  The arguments a handler may receive are those specified by the
  C<extra> key, when storing the message.
  See the Log::Message manpage for details on the arguments.
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Item>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_HANDLERS

$fatpacked{"Log/Message/Item.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_ITEM';
  package Log::Message::Item;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  use vars qw[$VERSION];
  use Params::Check qw[check];
  use Log::Message::Handlers;
  
  ### for the messages to store ###
  use Carp ();
  
  BEGIN {
      use vars qw[$AUTOLOAD $VERSION];
  
      $VERSION    =   '0.08';
  }
  
  ### create a new item.
  ### note that only an id (position on the stack), message and a reference
  ### to its parent are required. all the other things it can fill in itself
  sub new {
      my $class   = shift;
      my %hash    = @_;
  
      my $tmpl = {
          when        => { no_override    => 1,   default    => scalar localtime },
          id          => { required       => 1    },
          message     => { required       => 1    },
          parent      => { required        => 1    },
          level       => { default        => ''   },      # default may be conf dependant
          tag         => { default        => ''   },      # default may be conf dependant
          longmess    => { default        => _clean(Carp::longmess()) },
          shortmess   => { default        => _clean(Carp::shortmess())},
      };
  
      my $args = check($tmpl, \%hash) or return undef;
  
      return bless $args, $class;
  }
  
  sub _clean { map { s/\s*//; chomp; $_ } shift; }
  
  sub remove {
      my $item = shift;
      my $self = $item->parent;
  
      return splice( @{$self->{STACK}}, $item->id, 1, undef );
  }
  
  sub AUTOLOAD {
      my $self = $_[0];
  
      $AUTOLOAD =~ s/.+:://;
  
      return $self->{$AUTOLOAD} if exists $self->{$AUTOLOAD};
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 3;
  
      {   no strict 'refs';
          return *{"Log::Message::Handlers::${AUTOLOAD}"}->(@_);
      }
  }
  
  sub DESTROY { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Log::Message::Item  - Message objects for Log::Message
  
  =head1 SYNOPSIS
  
      # Implicitly used by Log::Message to create Log::Message::Item objects
  
      print "this is the message's id: ",     $item->id;
  
      print "this is the message stored: ",   $item->message;
  
      print "this is when it happened: ",     $item->when;
  
      print "the message was tagged: ",       $item->tag;
  
      print "this was the severity level: ",  $item->level;
  
      $item->remove;  # delete the item from the stack it was on
  
      # Besides these methods, you can also call the handlers on
      # the object specifically.
      # See the Log::Message::Handlers manpage for documentation on what
      # handlers are available by default and how to add your own
  
  
  =head1 DESCRIPTION
  
  Log::Message::Item is a class that generates generic Log items.
  These items are stored on a Log::Message stack, so see the Log::Message
  manpage about details how to retrieve them.
  
  You should probably not create new items by yourself, but use the
  storing mechanism provided by Log::Message.
  
  However, the accessors and handlers are of interest if you want to do
  fine tuning of how your messages are handled.
  
  The accessors and methods are described below, the handlers are
  documented in the Log::Message::Handlers manpage.
  
  =head1 Methods and Accessors
  
  =head2 remove
  
  Calling remove will remove the object from the stack it was on, so it
  will not show up any more in subsequent fetches of messages.
  
  You can still call accessors and handlers on it however, to handle it
  as you will.
  
  =head2 id
  
  Returns the internal ID of the item. This may be useful for comparing
  since the ID is incremented each time a new item is created.
  Therefore, an item with ID 4 must have been logged before an item with
  ID 9.
  
  =head2 when
  
  Returns the timestamp of when the message was logged
  
  =head2 message
  
  The actual message that was stored
  
  =head2 level
  
  The severity type of this message, as well as the name of the handler
  that was called upon storing it.
  
  =head2 tag
  
  Returns the identification tag that was put on the message.
  
  =head2 shortmess
  
  Returns the equivalent of a C<Carp::shortmess> for this item.
  See the C<Carp> manpage for details.
  
  =head2 longmess
  
  Returns the equivalent of a C<Carp::longmess> for this item, which
  is essentially a stack trace.
  See the C<Carp> manpage for details.
  
  =head2 parent
  
  Returns a reference to the Log::Message object that stored this item.
  This is useful if you want to have access to the full stack in a
  handler.
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Handlers>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_ITEM

$fatpacked{"Log/Message/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_SIMPLE';
  package Log::Message::Simple;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  use Log::Message private => 0;;
  
  BEGIN {
      use vars qw[$VERSION];
      $VERSION = '0.10';
  }
  
  
  =pod
  
  =head1 NAME
  
  Log::Message::Simple - Simplified interface to Log::Message
  
  =head1 SYNOPSIS
  
      use Log::Message::Simple qw[msg error debug
                                  carp croak cluck confess];
  
      use Log::Message::Simple qw[:STD :CARP];
  
      ### standard reporting functionality
      msg(    "Connecting to database",           $verbose );
      error(  "Database connection failed: $@",   $verbose );
      debug(  "Connection arguments were: $args", $debug );
  
      ### standard carp functionality
      carp(   "Wrong arguments passed: @_" );
      croak(  "Fatal: wrong arguments passed: @_" );
      cluck(  "Wrong arguments passed -- including stacktrace: @_" );
      confess("Fatal: wrong arguments passed -- including stacktrace: @_" );
  
      ### retrieve individual message
      my @stack = Log::Message::Simple->stack;
      my @stack = Log::Message::Simple->flush;
  
      ### retrieve the entire stack in printable form
      my $msgs  = Log::Message::Simple->stack_as_string;
      my $trace = Log::Message::Simple->stack_as_string(1);
  
      ### redirect output
      local $Log::Message::Simple::MSG_FH     = \*STDERR;
      local $Log::Message::Simple::ERROR_FH   = \*STDERR;
      local $Log::Message::Simple::DEBUG_FH   = \*STDERR;
  
      ### force a stacktrace on error
      local $Log::Message::Simple::STACKTRACE_ON_ERROR = 1
  
  =head1 DESCRIPTION
  
  This module provides standardized logging facilities using the
  C<Log::Message> module.
  
  =head1 FUNCTIONS
  
  =head2 msg("message string" [,VERBOSE])
  
  Records a message on the stack, and prints it to C<STDOUT> (or actually
  C<$MSG_FH>, see the C<GLOBAL VARIABLES> section below), if the
  C<VERBOSE> option is true.
  The C<VERBOSE> option defaults to false.
  
  Exported by default, or using the C<:STD> tag.
  
  =head2 debug("message string" [,VERBOSE])
  
  Records a debug message on the stack, and prints it to C<STDOUT> (or
  actually C<$DEBUG_FH>, see the C<GLOBAL VARIABLES> section below),
  if the C<VERBOSE> option is true.
  The C<VERBOSE> option defaults to false.
  
  Exported by default, or using the C<:STD> tag.
  
  =head2 error("error string" [,VERBOSE])
  
  Records an error on the stack, and prints it to C<STDERR> (or actually
  C<$ERROR_FH>, see the C<GLOBAL VARIABLES> sections below), if the
  C<VERBOSE> option is true.
  The C<VERBOSE> options defaults to true.
  
  Exported by default, or using the C<:STD> tag.
  
  =cut
  
  {   package Log::Message::Handlers;
  
      sub msg {
          my $self    = shift;
          my $verbose = shift || 0;
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::MSG_FH;
          print '['. $self->tag (). '] ' . $self->message . "\n";
          select $old_fh;
  
          return;
      }
  
      sub debug {
          my $self    = shift;
          my $verbose = shift || 0;
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::DEBUG_FH;
          print '['. $self->tag (). '] ' . $self->message . "\n";
          select $old_fh;
  
          return;
      }
  
      sub error {
          my $self    = shift;
          my $verbose = shift;
             $verbose = 1 unless defined $verbose;    # default to true
  
          ### so you don't want us to print the error? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::ERROR_FH;
  
          my $msg     = '['. $self->tag . '] ' . $self->message;
  
          print $Log::Message::Simple::STACKTRACE_ON_ERROR
                      ? Carp::shortmess($msg)
                      : $msg . "\n";
  
          select $old_fh;
  
          return;
      }
  }
  
  =head2 carp();
  
  Provides functionality equal to C<Carp::carp()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 croak();
  
  Provides functionality equal to C<Carp::croak()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 confess();
  
  Provides functionality equal to C<Carp::confess()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 cluck();
  
  Provides functionality equal to C<Carp::cluck()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head1 CLASS METHODS
  
  =head2 Log::Message::Simple->stack()
  
  Retrieves all the items on the stack. Since C<Log::Message::Simple> is
  implemented using C<Log::Message>, consult its manpage for the
  function C<retrieve> to see what is returned and how to use the items.
  
  =head2 Log::Message::Simple->stack_as_string([TRACE])
  
  Returns the whole stack as a printable string. If the C<TRACE> option is
  true all items are returned with C<Carp::longmess> output, rather than
  just the message.
  C<TRACE> defaults to false.
  
  =head2 Log::Message::Simple->flush()
  
  Removes all the items from the stack and returns them. Since
  C<Log::Message::Simple> is  implemented using C<Log::Message>, consult its
  manpage for the function C<retrieve> to see what is returned and how
  to use the items.
  
  =cut
  
  BEGIN {
      use Exporter;
      use Params::Check   qw[ check ];
      use vars            qw[ @EXPORT @EXPORT_OK %EXPORT_TAGS @ISA ];;
  
      @ISA            = 'Exporter';
      @EXPORT         = qw[error msg debug];
      @EXPORT_OK      = qw[carp cluck croak confess];
  
      %EXPORT_TAGS    = (
          STD     => \@EXPORT,
          CARP    => \@EXPORT_OK,
          ALL     => [ @EXPORT, @EXPORT_OK ],
      );
  
      my $log         = new Log::Message;
  
      for my $func ( @EXPORT, @EXPORT_OK ) {
          no strict 'refs';
  
                          ### up the carplevel for the carp emulation
                          ### functions
          *$func = sub {  local $Carp::CarpLevel += 2
                              if grep { $_ eq $func } @EXPORT_OK;
  
                          my $msg     = shift;
                          $log->store(
                                  message => $msg,
                                  tag     => uc $func,
                                  level   => $func,
                                  extra   => [@_]
                          );
                  };
      }
  
      sub flush {
          return reverse $log->flush;
      }
  
      sub stack {
          return $log->retrieve( chrono => 1 );
      }
  
      sub stack_as_string {
          my $class = shift;
          my $trace = shift() ? 1 : 0;
  
          return join $/, map {
                          '[' . $_->tag . '] [' . $_->when . '] ' .
                          ($trace ? $_->message . ' ' . $_->longmess
                                  : $_->message);
                      } __PACKAGE__->stack;
      }
  }
  
  =head1 GLOBAL VARIABLES
  
  =over 4
  
  =item $ERROR_FH
  
  This is the filehandle all the messages sent to C<error()> are being
  printed. This defaults to C<*STDERR>.
  
  =item $MSG_FH
  
  This is the filehandle all the messages sent to C<msg()> are being
  printed. This default to C<*STDOUT>.
  
  =item $DEBUG_FH
  
  This is the filehandle all the messages sent to C<debug()> are being
  printed. This default to C<*STDOUT>.
  
  =item $STACKTRACE_ON_ERROR
  
  If this option is set to C<true>, every call to C<error()> will
  generate a stacktrace using C<Carp::shortmess()>.
  Defaults to C<false>
  
  =back
  
  =cut
  
  BEGIN {
      use vars qw[ $ERROR_FH $MSG_FH $DEBUG_FH $STACKTRACE_ON_ERROR ];
  
      local $| = 1;
      $ERROR_FH               = \*STDERR;
      $MSG_FH                 = \*STDOUT;
      $DEBUG_FH               = \*STDOUT;
  
      $STACKTRACE_ON_ERROR    = 0;
  }
  
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_SIMPLE

$fatpacked{"MRO/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MRO_COMPAT';
  package MRO::Compat;
  use strict;
  use warnings;
  require 5.006_000;
  
  # Keep this < 1.00, so people can tell the fake
  #  mro.pm from the real one
  our $VERSION = '0.12';
  
  BEGIN {
      # Alias our private functions over to
      # the mro:: namespace and load
      # Class::C3 if Perl < 5.9.5
      if($] < 5.009_005) {
          $mro::VERSION # to fool Module::Install when generating META.yml
              = $VERSION;
          $INC{'mro.pm'} = __FILE__;
          *mro::import            = \&__import;
          *mro::get_linear_isa    = \&__get_linear_isa;
          *mro::set_mro           = \&__set_mro;
          *mro::get_mro           = \&__get_mro;
          *mro::get_isarev        = \&__get_isarev;
          *mro::is_universal      = \&__is_universal;
          *mro::method_changed_in = \&__method_changed_in;
          *mro::invalidate_all_method_caches
                                  = \&__invalidate_all_method_caches;
          require Class::C3;
          if($Class::C3::XS::VERSION && $Class::C3::XS::VERSION > 0.03) {
              *mro::get_pkg_gen   = \&__get_pkg_gen_c3xs;
          }
          else {
              *mro::get_pkg_gen   = \&__get_pkg_gen_pp;
          }
      }
  
      # Load mro.pm and provide no-op Class::C3::.*initialize() funcs for 5.9.5+
      else {
          require mro;
          no warnings 'redefine';
          *Class::C3::initialize = sub { 1 };
          *Class::C3::reinitialize = sub { 1 };
          *Class::C3::uninitialize = sub { 1 };
      }
  }
  
  =head1 NAME
  
  MRO::Compat - mro::* interface compatibility for Perls < 5.9.5
  
  =head1 SYNOPSIS
  
     package PPP;      use base qw/Exporter/;
     package X;        use base qw/PPP/;
     package Y;        use base qw/PPP/;
     package Z;        use base qw/PPP/;
  
     package FooClass; use base qw/X Y Z/;
  
     package main;
     use MRO::Compat;
     my $linear = mro::get_linear_isa('FooClass');
     print join(q{, }, @$linear);
  
     # Prints: FooClass, X, PPP, Exporter, Y, Z
  
  =head1 DESCRIPTION
  
  The "mro" namespace provides several utilities for dealing
  with method resolution order and method caching in general
  in Perl 5.9.5 and higher.
  
  This module provides those interfaces for
  earlier versions of Perl (back to 5.6.0 anyways).
  
  It is a harmless no-op to use this module on 5.9.5+.  That
  is to say, code which properly uses L<MRO::Compat> will work
  unmodified on both older Perls and 5.9.5+.
  
  If you're writing a piece of software that would like to use
  the parts of 5.9.5+'s mro:: interfaces that are supported
  here, and you want compatibility with older Perls, this
  is the module for you.
  
  Some parts of this code will work better and/or faster with
  L<Class::C3::XS> installed (which is an optional prereq
  of L<Class::C3>, which is in turn a prereq of this
  package), but it's not a requirement.
  
  This module never exports any functions.  All calls must
  be fully qualified with the C<mro::> prefix.
  
  The interface documentation here serves only as a quick
  reference of what the function basically does, and what
  differences between L<MRO::Compat> and 5.9.5+ one should
  look out for.  The main docs in 5.9.5's L<mro> are the real
  interface docs, and contain a lot of other useful information.
  
  =head1 Functions
  
  =head2 mro::get_linear_isa($classname[, $type])
  
  Returns an arrayref which is the linearized "ISA" of the given class.
  Uses whichever MRO is currently in effect for that class by default,
  or the given MRO (either C<c3> or C<dfs> if specified as C<$type>).
  
  The linearized ISA of a class is a single ordered list of all of the
  classes that would be visited in the process of resolving a method
  on the given class, starting with itself.  It does not include any
  duplicate entries.
  
  Note that C<UNIVERSAL> (and any members of C<UNIVERSAL>'s MRO) are not
  part of the MRO of a class, even though all classes implicitly inherit
  methods from C<UNIVERSAL> and its parents.
  
  =cut
  
  sub __get_linear_isa_dfs {
      no strict 'refs';
  
      my $classname = shift;
  
      my @lin = ($classname);
      my %stored;
      foreach my $parent (@{"$classname\::ISA"}) {
          my $plin = __get_linear_isa_dfs($parent);
          foreach (@$plin) {
              next if exists $stored{$_};
              push(@lin, $_);
              $stored{$_} = 1;
          }
      }
      return \@lin;
  }
  
  sub __get_linear_isa {
      my ($classname, $type) = @_;
      die "mro::get_mro requires a classname" if !defined $classname;
  
      $type ||= __get_mro($classname);
      if($type eq 'dfs') {
          return __get_linear_isa_dfs($classname);
      }
      elsif($type eq 'c3') {
          return [Class::C3::calculateMRO($classname)];
      }
      die "type argument must be 'dfs' or 'c3'";
  }
  
  =head2 mro::import
  
  This allows the C<use mro 'dfs'> and
  C<use mro 'c3'> syntaxes, providing you
  L<use MRO::Compat> first.  Please see the
  L</USING C3> section for additional details.
  
  =cut
  
  sub __import {
      if($_[1]) {
          goto &Class::C3::import if $_[1] eq 'c3';
          __set_mro(scalar(caller), $_[1]);
      }
  }
  
  =head2 mro::set_mro($classname, $type)
  
  Sets the mro of C<$classname> to one of the types
  C<dfs> or C<c3>.  Please see the L</USING C3>
  section for additional details.
  
  =cut
  
  sub __set_mro {
      my ($classname, $type) = @_;
  
      if(!defined $classname || !$type) {
          die q{Usage: mro::set_mro($classname, $type)};
      }
  
      if($type eq 'c3') {
          eval "package $classname; use Class::C3";
          die $@ if $@;
      }
      elsif($type eq 'dfs') {
          # In the dfs case, check whether we need to undo C3
          if(defined $Class::C3::MRO{$classname}) {
              Class::C3::_remove_method_dispatch_table($classname);
          }
          delete $Class::C3::MRO{$classname};
      }
      else {
          die qq{Invalid mro type "$type"};
      }
  
      return;
  }
  
  =head2 mro::get_mro($classname)
  
  Returns the MRO of the given class (either C<c3> or C<dfs>).
  
  It considers any Class::C3-using class to have C3 MRO
  even before L<Class::C3::initialize()> is called.
  
  =cut
  
  sub __get_mro {
      my $classname = shift;
      die "mro::get_mro requires a classname" if !defined $classname;
      return 'c3' if exists $Class::C3::MRO{$classname};
      return 'dfs';
  }
  
  =head2 mro::get_isarev($classname)
  
  Returns an arrayref of classes who are subclasses of the
  given classname.  In other words, classes in whose @ISA
  hierarchy we appear, no matter how indirectly.
  
  This is much slower on pre-5.9.5 Perls with MRO::Compat
  than it is on 5.9.5+, as it has to search the entire
  package namespace.
  
  =cut
  
  sub __get_all_pkgs_with_isas {
      no strict 'refs';
      no warnings 'recursion';
  
      my @retval;
  
      my $search = shift;
      my $pfx;
      my $isa;
      if(defined $search) {
          $isa = \@{"$search\::ISA"};
          $pfx = "$search\::";
      }
      else {
          $search = 'main';
          $isa = \@main::ISA;
          $pfx = '';
      }
  
      push(@retval, $search) if scalar(@$isa);
  
      foreach my $cand (keys %{"$search\::"}) {
          if($cand =~ s/::$//) {
              next if $cand eq $search; # skip self-reference (main?)
              push(@retval, @{__get_all_pkgs_with_isas($pfx . $cand)});
          }
      }
  
      return \@retval;
  }
  
  sub __get_isarev_recurse {
      no strict 'refs';
  
      my ($class, $all_isas, $level) = @_;
  
      die "Recursive inheritance detected" if $level > 100;
  
      my %retval;
  
      foreach my $cand (@$all_isas) {
          my $found_me;
          foreach (@{"$cand\::ISA"}) {
              if($_ eq $class) {
                  $found_me = 1;
                  last;
              }
          }
          if($found_me) {
              $retval{$cand} = 1;
              map { $retval{$_} = 1 }
                  @{__get_isarev_recurse($cand, $all_isas, $level+1)};
          }
      }
      return [keys %retval];
  }
  
  sub __get_isarev {
      my $classname = shift;
      die "mro::get_isarev requires a classname" if !defined $classname;
  
      __get_isarev_recurse($classname, __get_all_pkgs_with_isas(), 0);
  }
  
  =head2 mro::is_universal($classname)
  
  Returns a boolean status indicating whether or not
  the given classname is either C<UNIVERSAL> itself,
  or one of C<UNIVERSAL>'s parents by C<@ISA> inheritance.
  
  Any class for which this function returns true is
  "universal" in the sense that all classes potentially
  inherit methods from it.
  
  =cut
  
  sub __is_universal {
      my $classname = shift;
      die "mro::is_universal requires a classname" if !defined $classname;
  
      my $lin = __get_linear_isa('UNIVERSAL');
      foreach (@$lin) {
          return 1 if $classname eq $_;
      }
  
      return 0;
  }
  
  =head2 mro::invalidate_all_method_caches
  
  Increments C<PL_sub_generation>, which invalidates method
  caching in all packages.
  
  Please note that this is rarely necessary, unless you are
  dealing with a situation which is known to confuse Perl's
  method caching.
  
  =cut
  
  sub __invalidate_all_method_caches {
      # Super secret mystery code :)
      @f845a9c1ac41be33::ISA = @f845a9c1ac41be33::ISA;
      return;
  }
  
  =head2 mro::method_changed_in($classname)
  
  Invalidates the method cache of any classes dependent on the
  given class.  In L<MRO::Compat> on pre-5.9.5 Perls, this is
  an alias for C<mro::invalidate_all_method_caches> above, as
  pre-5.9.5 Perls have no other way to do this.  It will still
  enforce the requirement that you pass it a classname, for
  compatibility.
  
  Please note that this is rarely necessary, unless you are
  dealing with a situation which is known to confuse Perl's
  method caching.
  
  =cut
  
  sub __method_changed_in {
      my $classname = shift;
      die "mro::method_changed_in requires a classname" if !defined $classname;
  
      __invalidate_all_method_caches();
  }
  
  =head2 mro::get_pkg_gen($classname)
  
  Returns an integer which is incremented every time a local
  method of or the C<@ISA> of the given package changes on
  Perl 5.9.5+.  On earlier Perls with this L<MRO::Compat> module,
  it will probably increment a lot more often than necessary.
  
  =cut
  
  {
      my $__pkg_gen = 2;
      sub __get_pkg_gen_pp {
          my $classname = shift;
          die "mro::get_pkg_gen requires a classname" if !defined $classname;
          return $__pkg_gen++;
      }
  }
  
  sub __get_pkg_gen_c3xs {
      my $classname = shift;
      die "mro::get_pkg_gen requires a classname" if !defined $classname;
  
      return Class::C3::XS::_plsubgen();
  }
  
  =head1 USING C3
  
  While this module makes the 5.9.5+ syntaxes
  C<use mro 'c3'> and C<mro::set_mro("Foo", 'c3')> available
  on older Perls, it does so merely by passing off the work
  to L<Class::C3>.
  
  It does not remove the need for you to call
  C<Class::C3::initialize()>, C<Class::C3::reinitialize()>, and/or
  C<Class::C3::uninitialize()> at the appropriate times
  as documented in the L<Class::C3> docs.  These three functions
  are always provided by L<MRO::Compat>, either via L<Class::C3>
  itself on older Perls, or directly as no-ops on 5.9.5+.
  
  =head1 SEE ALSO
  
  L<Class::C3>
  
  L<mro>
  
  =head1 AUTHOR
  
  Brandon L. Black, E<lt>blblack@gmail.comE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2008 Brandon L. Black E<lt>blblack@gmail.comE<gt>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
  1;
MRO_COMPAT

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Moo::Object);
  use Sub::Quote;
  use B 'perlstring';
  use Scalar::Util 'blessed';
  use overload ();
  use Module::Runtime qw(use_module);
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  
  sub _SIGDIE
  {
    our ($CurrentAttribute, $OrigSigDie);
    my $sigdie = $OrigSigDie && $OrigSigDie != \&_SIGDIE
      ? $OrigSigDie
      : sub { die $_[0] };
  
    return $sigdie->(@_) if ref($_[0]);
  
    my $attr_desc = _attr_desc(@$CurrentAttribute{qw(name init_arg)});
    $sigdie->("$CurrentAttribute->{step} for $attr_desc failed: $_[0]");
  }
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    die "You cannot overwrite a locally defined method ($method) with @{[ $type || 'an accessor' ]}";
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      die "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ /\A[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)*\z/;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
  
    for my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (!defined $spec->{default} || ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name", 'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      for my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${reader}")}{CODE};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${accessor}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${writer}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${pred}")}{CODE};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $methods{$pred} =
          quote_sub "${into}::${pred}" =>
            '    '.$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
          ;
      }
    }
    if (my $pred = $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $spec->{builder_sub} );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${cl}")}{CODE};
      $methods{$cl} =
        quote_sub "${into}::${cl}" =>
          $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], use_module('Moo::Role')->methods_provided_by(use_module($hspec))
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && *{_getglob("${into}::${proxy}")}{CODE};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
  
  
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" => $self->_generate_asserter($name, $spec),
          delete $self->{captures}
        ;
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\perlstring $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\perlstring $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa}
      ? "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n");
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
        : perlstring $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->_generate_simple_get(@args);
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $value_store = '$_[0]';
      my $code;
      if ($coerce) {
        $value_store = '$value';
        $code = "do { my (\$self, \$value) = \@_;\n"
          ."        \$value = "
          .$self->_generate_coerce($name, $value_store, $coerce).";\n";
      }
      else {
        $code = "do { my \$self = shift;\n";
      }
      if ($isa_check) {
        $code .=
          "        ".$self->_generate_isa_check($name, $value_store, $isa_check).";\n";
      }
      my $simple = $self->_generate_simple_set('$self', $name, $spec, $value_store);
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', $value_store, $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        $value_store;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return perlstring($name) if !defined($init_arg) or $init_arg eq $name;
    return perlstring($name).' (constructor argument: '.perlstring($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce)
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_die_prefix {
    my ($self, $name, $prefix, $arg, $inside) = @_;
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'
    .'    init_arg => '.(defined $arg ? B::perlstring($arg) : 'undef') . ",\n"
    .'    name     => '.B::perlstring($name).",\n"
    .'    step     => '.B::perlstring($prefix).",\n"
    ."  };\n"
    .'  local $Method::Generate::Accessor::OrigSigDie = $SIG{__DIE__};'."\n"
    .'  local $SIG{__DIE__} = \&Method::Generate::Accessor::_SIGDIE;'."\n"
    .$inside
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.$self->_sanitize_name($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify(
          $code, $values, Sub::Quote::capture_unroll($cap_name, $captures, 6), $local
        );
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.$self->_sanitize_name($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name {
    my ($self, $name) = @_;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $name, $spec
                        );
      my $get_value =
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ($spec->{coerce}) {
        $get_value = $self->_generate_coerce(
          $name, $get_value,
          $spec->{coerce}, $init_arg
        )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}, $init_arg
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name, $spec),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $source,
              $spec->{coerce}, $init_arg
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}, $init_arg
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name, $spec),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      #Internals::SetReadWrite($foo);
      #Scalar::Util::weaken ($foo);
      #Internals::SetReadOnly($foo);
      #
      # but requires XS and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : $weak_simple;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
  
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  unless (".$self->_generate_simple_has('$_[0]', $name, $spec).") {\n"
     .qq!    die "Attempted to access '${name}' but it is not set";\n!
     ."  }\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using perlstring
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      die "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      die "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B 'perlstring';
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @builds;
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use strictures 1;
  use Sub::Quote;
  use base qw(Moo::Object);
  use Sub::Defer;
  use B 'perlstring';
  use Moo::_Utils qw(_getstash);
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    my $specs = $self->{attribute_specs}||={};
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        die "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        foreach my $key (keys %$old_spec) {
          if (!exists $new_spec->{$key}) {
            $new_spec->{$key} = $old_spec->{$key}
              unless $key eq 'handles';
          }
          elsif ($key eq 'moosify') {
            $new_spec->{$key} = [
              map { ref $_ eq 'ARRAY' ? @$_ : $_ }
                ($old_spec->{$key}, $new_spec->{$key})
            ];
          }
        }
      }
      if (exists $new_spec->{init_arg} && !defined $new_spec->{init_arg}
          && $new_spec->{required}) {
        die "${name} attribute can't be required with init_arg => undef";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    my $package = $self->{package};
    defer_sub "${package}::new" => sub {
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      $body .= $self->buildall_generator->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.perlstring($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg_key = perlstring($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $test{$_},
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, qw('
      .join(' ',@required_init).')) {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  use Moo;
  Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'lazy' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'ro' },
  );
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B qw(perlstring);
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL(Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;
  
  use strictures 1;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
  	$fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  {
    $Module::Implementation::VERSION = '0.07';
  }
  BEGIN {
    $Module::Implementation::AUTHORITY = 'cpan:DROLSKY';
  }
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.07
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use strictures 1;
  use Moo::_Utils;
  use B 'perlstring';
  use Sub::Defer ();
  use Import::Into;
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
    strictures->import::into(1);
    if ($Role::Tiny::INFO{$target} and $Role::Tiny::INFO{$target}{is_role}) {
      die "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map { *$_{CODE}||() } grep !ref($_), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{"Role/Tiny.pm"} && $Role::Tiny::INFO{$superclass}) {
        require Carp;
        Carp::croak("Can't extend role '$superclass'");
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    no warnings 'once'; # piss off. -- mst
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target, $select_super) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
      require Sub::Defer;
      my ($moo_constructor, $con);
  
      if ($select_super && $MAKERS{$select_super}) {
        $moo_constructor = 1;
        $con = $MAKERS{$select_super}{constructor};
      } else {
        my $t_new = $target->can('new');
        if ($t_new) {
          if ($t_new == Moo::Object->can('new')) {
            $moo_constructor = 1;
          } elsif (my $defer_target = (Sub::Defer::defer_info($t_new)||[])->[0]) {
            my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
            if ($MAKERS{$pkg}) {
              $moo_constructor = 1;
              $con = $MAKERS{$pkg}{constructor};
            }
          }
        } else {
          $moo_constructor = 1; # no other constructor, make a Moo one
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(
          package => $target,
          accessor_generator => $class->_accessor_maker_for($target),
          $moo_constructor ? (
            $con ? (construction_string => $con->construction_string) : ()
          ) : (
            construction_builder => sub {
              '$class->'.$target.'::SUPER::new('
                .($target->can('FOREIGNBUILDARGS') ?
                  '$class->FOREIGNBUILDARGS(@_)' : '@_')
                .')'
            },
          ),
          subconstructor_handler => (
            '      if ($Moo::MAKERS{$class}) {'."\n"
            .'        '.$class.'->_constructor_maker_for($class,'.perlstring($target).');'."\n"
            .'        return $class->new(@_)'.";\n"
            .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
            .'        return $meta->new_object($class->BUILDARGS(@_));'."\n"
            .'      }'."\n"
          ),
        )
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $makers = $MAKERS{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
   use namespace::clean;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
   );
  
   has pounds => (
     is  => 'rw',
     isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  And elsewhere:
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  This module is an extremely light-weight subset of L<Moose> optimised for
  rapid startup and "pay only for what you use".
  
  It also avoids depending on any XS modules to allow simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite -- two
  thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead of provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  However, sometimes you're writing a command line script or a CGI script
  where fast startup is essential, or code designed to be deployed as a single
  file via L<App::FatPacker>, or you're writing a CPAN module and you want it
  to be usable by people with those constraints.
  
  I've tried several times to use L<Mouse> but it's 3x the size of Moo and
  takes longer to load than most of my Moo based CGI scripts take to run.
  
  If you don't want L<Moose>, you don't want "less metaprotocol" like L<Mouse>,
  you want "as little as possible" -- which means "no metaprotocol", which is
  what Moo provides.
  
  Better still, if you install and load L<Moose>, we set up metaclasses for your
  L<Moo> classes and L<Moo::Role> roles, so you can use them in L<Moose> code
  without ever noticing that some of your codebase is using L<Moo>.
  
  Hence, Moo exists as its name -- Minimal Object Orientation -- with a pledge
  to make it smooth to upgrade to L<Moose> when you need more than minimal
  features.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without anybody ever noticing you aren't using
  L<Moose> everywhere.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  classes and roles, so that C<< isa => 'MyClass' >> and C<< isa => 'MyRole' >>
  work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  So will extending a L<Mouse> class or consuming a L<Mouse::Role> - but note
  that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you want types to be upgraded to the L<Moose> types, use
  L<MooX::Types::MooseLike> and install the L<MooseX::Types> library to
  match the L<MooX::Types::MooseLike> library you're using - L<Moo> will
  load the L<MooseX::Types> library and use that type for the newly created
  metaclass.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  currently global and turns the mechanism off entirely so don't put this
  in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it
  will be used to generate simple accessors, readers, and writers for
  a speed boost.  Simple accessors are those without lazy defaults,
  type checks/coercions, or triggers.  Readers and writers generated
  by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   sub BUILDARGS {
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return { @args };
   };
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as C<BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares base class. Multiple superclasses can be passed for multiple
  inheritance (but please use roles instead).  The class will be loaded, however
  no errors will be triggered if it can't be found and there are already subs in
  the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
  
  or
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles have conflicting methods.  The
  roles will be loaded using the same mechansim as C<extends> uses.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
   package Foo;
   use Moo;
   has 'attr' => (
     is => 'ro'
   );
  
   package Bar;
   use Moo;
   extends 'Foo';
   has '+attr' => (
     default => sub { "blah" },
   );
  
  Using the C<+> notation, it's possible to override an attribute.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * is
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> generates an accessor that dies if you attempt to write to it - i.e.
  a getter only - by defaulting C<reader> to the name of the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> generates a reader like C<ro>, but also sets C<writer> to
  C<_set_${attribute_name}> for attributes that are designed to be written
  from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> generates a normal getter/setter by defaulting C<accessor> to the
  name of the attribute.
  
  =item * isa
  
  Takes a coderef which is meant to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   isa => sub {
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  Note that the return value is ignored, only whether the sub lives or
  dies matters.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<MooseX::Types> style named types, look at
  L<MooX::Types::MooseLike>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item * coerce
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always fire your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * handles
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a role (L<Moo::Role>) that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. Coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<default>
  
  Takes a coderef which will get called with $self as its only argument
  to populate an attribute if no value is supplied to the constructor - or
  if the attribute is lazy, when the attribute is first retrieved if no
  value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item * C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or <_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on instantiation.
  
  =item * C<reader>
  
  The value of this attribute will be the name of the method to get the value of
  the attribute.  If you like Java style methods, you might set this to
  C<get_foo>
  
  =item * C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item * C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened; use this when circular references are possible, which will cause
  leaks.
  
  =item * C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item * C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
   package Record;
  
   use Digest::MD5 qw(md5_hex);
  
   use Moo;
   use namespace::clean;
  
   has name => (is => 'ro', required => 1);
   has id => (is => 'lazy');
   sub _build_id {
     my ($self) = @_;
     return md5_hex($self->name);
   }
  
   1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes, so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> If you're coming to Moo from the Moose
  world, you may be accustomed to using L<namespace::autoclean> in all
  your packages. This is not recommended for L<Moo> packages, because
  L<namespace::autoclean> will inflate your class to a full L<Moose>
  class.  It'll work, but you will lose the benefits of L<Moo>.  Instead
  you are recommended to just use L<namespace::clean>.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, just make a library of coderefs, or better yet, functions
  that return quoted subs. L<MooX::Types::MooseLike> provides a similar API
  to L<MooseX::Types::Moose> so that you can write
  
    has days_to_live => (is => 'ro', isa => Int);
  
  and have it work with both; it is hoped that providing only subrefs as an
  API will encourage the use of other type systems as well, since it's
  probably the weakest part of Moose design-wise.
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you wanted
  L<Moose> - Moo succeeds at being small because it explicitly does not
  provide a metaprotocol. However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  C<BUILDARGS> is not triggered if your class does not have any attributes.
  Without attributes, C<BUILDARGS> return value would be ignored, so we just
  skip calling the method instead.
  
  Handling of warnings: when you C<use Moo> we enable FATAL warnings, and some
  several extra pragmas when used in development: L<indirect>,
  L<multidimensional>, and L<bareword::filehandles>.  See the L<strictures>
  documentation for the details on this.
  
  A similar invocation for L<Moose> would be:
  
    use Moose;
    use warnings FATAL => "all";
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
      package MyClass;
      use Moo;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
      package MyClass;
  
      use Moose;
      use MooseX::NonMoose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
      __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#moose@irc.perl.org">(click for instant chatroom login)</a>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#web-simple@irc.perl.org">(click for instant chatroom login)</a>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_CONFLICTS';
  package # hide from PAUSE
      Moo::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Moo',
      -conflicts => {
          # enter conflicting downstream deps here, with the version indicating
          # the last *broken* version that *does not work*.
          'HTML::Restrict' => '2.1.5',
      },
  
      # these dists' ::Conflicts modules (if they exist) are also checked for
      # more incompatibilities -- should include all runtime prereqs here.
      -also => [ qw(
          Carp
          Class::Method::Modifiers
          strictures
          Module::Runtime
          Role::Tiny
          Devel::GlobalDestruction
      ) ],
  ;
  
  1;
MOO_CONFLICTS

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  
  use strictures 1;
  use Moo::_Utils;
  use B qw(perlstring);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', do { no warnings 'once'; keys %Moo::MAKERS };
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    for my $spec (values %$attr_specs) {
      if (my $inflators = delete $spec->{moosify}) {
        $_->($spec) for @$inflators;
      }
    }
  
    my %methods
      = %{($am_role ? 'Role::Tiny' : 'Moo')->_concrete_methods_of($name)};
  
    # if stuff gets added afterwards, _maybe_reset_handlemoose should
    # trigger the recreation of the metaclass but we need to ensure the
    # Role::Tiny cache is cleared so we don't confuse Moo itself.
    if (my $info = $Role::Tiny::INFO{$name}) {
      delete $info->{methods};
    }
  
    # needed to ensure the method body is stable and get things named
    Sub::Defer::undefer_sub($_) for grep defined, values %methods;
    my @attrs;
    {
      # This local is completely not required for roles but harmless
      local @{_getstash($name)}{keys %methods};
      my %seen_name;
      foreach my $name (@$attr_order) {
        $seen_name{$name} = 1;
        my %spec = %{$attr_specs->{$name}};
        my %spec_map = (
          map { $_->name => $_->init_arg||$_->name }
          (
            (grep { $_->has_init_arg }
               $meta->attribute_metaclass->meta->get_all_attributes),
            grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
            map {
              my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                           ->meta;
              map $meta->get_attribute($_), $meta->get_attribute_list
            }  @{$spec{traits}||[]}
          )
        );
        # have to hard code this because Moose's role meta-model is lacking
        $spec_map{traits} ||= 'traits';
  
        $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
        my $coerce = $spec{coerce};
        if (my $isa = $spec{isa}) {
          my $tc = $spec{isa} = do {
            if (my $mapped = $TYPE_MAP{$isa}) {
              my $type = $mapped->();
              Scalar::Util::blessed($type) && $type->isa("Moose::Meta::TypeConstraint")
                or die "error inflating attribute '$name' for package '$_[0]': \$TYPE_MAP{$isa} did not return a valid type constraint'";
              $coerce ? $type->create_child_type(name => $type->name) : $type;
            } else {
              Moose::Meta::TypeConstraint->new(
                constraint => sub { eval { &$isa; 1 } }
              );
            }
          };
          if ($coerce) {
            $tc->coercion(Moose::Meta::TypeCoercion->new)
               ->_compiled_type_coercion($coerce);
            $spec{coerce} = 1;
          }
        } elsif ($coerce) {
          my $attr = perlstring($name);
          my $tc = Moose::Meta::TypeConstraint->new(
                     constraint => sub { die "This is not going to work" },
                     inlined => sub {
                        'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                     },
                   );
          $tc->coercion(Moose::Meta::TypeCoercion->new)
             ->_compiled_type_coercion($coerce);
          $spec{isa} = $tc;
          $spec{coerce} = 1;
        }
        %spec =
          map { $spec_map{$_} => $spec{$_} }
          grep { exists $spec_map{$_} }
          keys %spec;
        push @attrs, $meta->add_attribute($name => %spec);
      }
      foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
        foreach my $attr ($mouse->get_all_attributes) {
          my %spec = %{$attr};
          delete @spec{qw(
            associated_class associated_methods __METACLASS__
            provides curries
          )};
          my $name = delete $spec{name};
          next if $seen_name{$name}++;
          push @attrs, $meta->add_attribute($name => %spec);
        }
      }
    }
    for my $meth_name (keys %methods) {
      my $meth_code = $methods{$meth_name};
      $meta->add_method($meth_name, $meth_code) if $meth_code;
    }
  
    if ($am_role) {
      my $info = $Moo::Role::INFO{$name};
      $meta->add_required_methods(@{$info->{requires}});
      foreach my $modifier (@{$info->{modifiers}}) {
        my ($type, @args) = @$modifier;
        my $code = pop @args;
        $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
      }
    } else {
      foreach my $attr (@attrs) {
        foreach my $method (@{$attr->associated_methods}) {
          $method->{body} = $name->can($method->name);
        }
      }
      bless(
        $meta->find_method_by_name('new'),
        'Moo::HandleMoose::FakeConstructor',
      );
      # a combination of Moo and Moose may bypass a Moo constructor but still
      # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
      # global destruction.
      require Method::Generate::DemolishAll;
    }
    $meta->add_role(Class::MOP::class_of($_))
      for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
        do { no warnings 'once'; keys %{$Role::Tiny::APPLIED_TO{$name}} };
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->$meth(@_)
  }
  sub can {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->can(@_)
  }
  sub isa {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use strictures 1;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)[A-Z]+\(0x([0-9a-zA-Z]+)\)$/) {
      my $id = do { no warnings 'portable'; hex "$1" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  my @types = %TYPE_MAP;
  tie %TYPE_MAP, __PACKAGE__;
  %TYPE_MAP = @types;
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use strictures 1;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    $NO_BUILD{$class} and
      return bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class)
      : do {
          my $proto = ref($_[0]) eq 'HASH' ? $_[0] : { @_ };
          bless({ %$proto }, $class)->BUILDALL($proto);
        };
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    require Role::Tiny;
    { no warnings 'redefine'; *does = \&Role::Tiny::does_role }
    goto &Role::Tiny::does_role;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use strictures 1;
  use Moo::_Utils;
  use Role::Tiny ();
  use base qw(Role::Tiny);
  use Import::Into;
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  BEGIN { *INFO = \%Role::Tiny::INFO }
  
  our %INFO;
  our %APPLY_DEFAULTS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my ($me) = @_;
    _set_loaded(caller);
    strictures->import::into(1);
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      die "Cannot import Moo::Role into a Moo class";
    }
    $INFO{$target} ||= {};
    # get symbol table reference
    my $stash = _getstash($target);
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    return if $INFO{$target}{is_role}; # already exported into this package
    $INFO{$target}{is_role} = 1;
    *{_getglob("${target}::meta")} = $me->can('meta');
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later) with a map to the coderefs in case of copying or re-use
    my @not_methods = ('', map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $Role::Tiny::APPLIED_TO{$target} = { $target => undef };
  
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $INFO{$role};
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    _load_module($role);
    my $meta;
    if (!$INFO{$role}
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $Role::Tiny::APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
  
            $spec->{isa} = sub {
              &$check or die "Type constraint failed for $_[0]"
            };
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      require Class::Method::Modifiers if @$mods;
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      $me->_inhale_if_moose($role);
      die "${role} is not a Moo::Role" unless $INFO{$role};
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    $me->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $INFO{$role};
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
        $me->_inhale_if_moose($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      *{_getglob("${new_name}::ISA")} = [ $superclass ];
      $me->apply_roles_to_package($new_name, @roles);
      _set_loaded($new_name, (caller)[1]);
      return $new_name;
    }
  
    require Sub::Quote;
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Role::Tiny" unless $INFO{$role};
    }
  
    $Moo::MAKERS{$new_name} = {is_class => 1};
  
    $me->_handle_constructor($new_name, $_) for @roles;
  
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    _set_loaded(ref $new, (caller)[1]);
  
    my $apply_defaults = $APPLY_DEFAULTS{ref $new} ||= do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for(ref $new)
          and my $m = Moo->_accessor_maker_for(ref $new)) {
        require Sub::Quote;
  
        my $specs = $con_gen->all_attribute_specs;
  
        my $assign = '';
        my %captures;
        foreach my $name ( keys %attrs ) {
          my $spec = $specs->{$name};
          if ($m->has_eager_default($name, $spec)) {
            my ($has, $has_cap)
              = $m->generate_simple_has('$_[0]', $name, $spec);
            my ($code, $pop_cap)
              = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
            $assign .= $code;
            @captures{keys %$has_cap, keys %$pop_cap}
              = (values %$has_cap, values %$pop_cap);
          }
        }
        Sub::Quote::quote_sub($assign, \%captures);
      }
      else {
        sub {};
      }
    };
    $new->$apply_defaults;
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $Role::Tiny::COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    if ($INFO{$to}) {
      push @{$INFO{$to}{attributes}||=[]}, @$attr_info;
    } else {
      # only fiddle with the constructor if the target is a Moo class
      if ($INC{"Moo.pm"}
          and my $con = Moo->_constructor_maker_for($to)) {
        # shallow copy of the specs since the constructor will assign an index
        $con->register_attribute_specs(map ref() ? { %$_ } : $_, @$attr_info);
      }
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  And elsewhere:
  
   package Some::Class;
  
   use Moo;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
   package My::Role::ID;
  
   use Digest::MD5 qw(md5_hex);
   use Moo::Role;
   use Digest::SHA qw(sha1_hex);
  
   requires 'name';
  
   sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
   sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
   1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  
  no warnings 'once'; # guard against -w
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use constant lt_5_8_3 => ( $] < 5.008003 or $ENV{MOO_TEST_PRE_583} ) ? 1 : 0;
  use constant can_haz_subname => eval { require Sub::Name };
  
  use strictures 1;
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use base qw(Exporter);
  use Moo::_mro;
  use Config;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa _getstash _install_coderef _name_coderef
      _unimport_coderefs _in_global_destruction _set_loaded
  );
  
  sub _in_global_destruction ();
  *_in_global_destruction = \&Devel::GlobalDestruction::in_global_destruction;
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      require Sub::Defer;
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  sub _load_module {
    my $module = $_[0];
    my $file = module_notional_filename($module);
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    die $error;
  }
  
  sub _maybe_load_module {
    return $MAYBE_LOADED{$_[0]} if exists $MAYBE_LOADED{$_[0]};
    (my $proto = $_[0]) =~ s/::/\//g;
    local $@;
    if (eval { require "${proto}.pm"; 1 }) {
      $MAYBE_LOADED{$_[0]} = 1;
    } else {
      if (exists $INC{"${proto}.pm"}) {
        warn "$_[0] exists but failed to load with error: $@";
      }
      $MAYBE_LOADED{$_[0]} = 0;
    }
    return $MAYBE_LOADED{$_[0]};
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _get_linear_isa {
    return mro::get_linear_isa($_[0]);
  }
  
  sub _install_coderef {
    no warnings 'redefine';
    *{_getglob($_[0])} = _name_coderef(@_);
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    can_haz_subname ? Sub::Name::subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use strictures 1;
  use Moo::_Utils ();
  
  sub unimport { our $disarmed = 1 }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disarmed or Moo::_Utils::_in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  if ($INC{"Moose.pm"}) {
    require Moo::HandleMoose;
    Moo::HandleMoose->import;
  } else {
    $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
  }
  
  1;
MOO_SIFICATION

$fatpacked{"MooX/late.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOX_LATE';
  use 5.008;
  use strict;
  use warnings;
  
  package MooX::late;
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.014';
  
  use Moo              qw( );
  use Carp             qw( carp croak );
  use Scalar::Util     qw( blessed );
  use Module::Runtime  qw( is_module_name );
  
  BEGIN {
  	package MooX::late::DefinitionContext;
  	our $AUTHORITY = 'cpan:TOBYINK';
  	our $VERSION   = '0.014';
  	
  	use Moo;
  	use overload (
  		q[""]    => 'to_string',
  		q[bool]  => sub { 1 },
  		fallback => 1,
  	);
  	
  	has package  => (is => 'ro');
  	has filename => (is => 'ro');
  	has line     => (is => 'ro');
  	
  	sub to_string
  	{
  		my $self = shift;
  		sprintf(
  			'%s:%d, package %s',
  			$self->filename,
  			$self->line,
  			$self->package,
  		);
  	}
  	
  	sub new_from_caller
  	{
  		my ($class, $level) = @_;
  		$level = 0 unless defined $level;
  		
  		my ($p, $f, $c) = caller($level + 1);
  		return $class->new(
  			package  => $p,
  			filename => $f,
  			line     => $c,
  		);
  	}
  };
  
  # SUBCLASSING
  # This is a hook for people subclassing MooX::late.
  # It should be easy to tack on your own handlers
  # to the end of the list. A handler is only called
  # if exists($spec{$handler_name}) in the attribute
  # spec.
  # 
  sub _handlers
  {
  	qw( isa coerce lazy_build traits );
  }
  
  # SUBCLASSING
  # Not really sure why you'd want to override
  # this.
  #
  sub _definition_context_class
  {
  	"MooX::late::DefinitionContext";
  }
  
  sub import
  {
  	my $me = shift;
  	my $caller = caller;
  	
  	my $install_tracked;
  	{
  		no warnings;
  		if ($Moo::MAKERS{$caller})
  		{
  			$install_tracked = \&Moo::_install_tracked;
  		}
  		elsif ($Moo::Role::INFO{$caller})
  		{
  			$install_tracked = \&Moo::Role::_install_tracked;
  		}
  		else
  		{
  			croak "MooX::late applied to a non-Moo package"
  				. "(need: use Moo or use Moo::Role)";
  		}
  	}
  	
  	my $orig = $caller->can('has')  # lolcat
  		or croak "Could not locate 'has' function to alter";
  	
  	my @handlers = $me->_handlers;
  	
  	# SUBCLASSING
  	# MooX::late itself does not provide a
  	# `_finalize_attribute` method. Your subclass
  	# can, in which case it will be called right
  	# before setting up the attribute.
  	# 
  	my $finalize = $me->can("_finalize_attribute");
  	
  	$install_tracked->(
  		$caller, has => sub
  		{
  			my ($proto, %spec) = @_;
  			my $context = $me->_definition_context_class->new_from_caller(0);
  			
  			for my $name (ref $proto ? @$proto : $proto)
  			{
  				my $spec = +{ %spec }; # shallow clone
  				
  				for my $option (@handlers)
  				{
  					next unless exists $spec->{$option};
  					my $handler = $me->can("_handle_$option");
  					
  					# SUBCLASSING
  					# Note that handlers are called as methods, and
  					# get passed:
  					# 1. the attribute name
  					# 2. the attribute spec (hashref, modifiable)
  					# 3. a context object
  					# 4. the name of the caller class/role
  					#
  					$me->$handler($name, $spec, $context, $caller);
  				}
  				
  				$me->$finalize($name, $spec, $context, $caller) if $finalize;
  				$orig->($name, %$spec);
  			}
  			return;
  		},
  	);
  	
  	$me->_install_sugar($caller, $install_tracked);
  }
  
  # SUBCLASSING
  # This can be used to install additional functions
  # into the caller package.
  #
  sub _install_sugar
  {
  	my $me = shift;
  	my ($caller, $installer) = @_;
  	$installer->($caller, blessed => \&Scalar::Util::blessed);
  	$installer->($caller, confess => \&Carp::confess);
  }
  
  my %registry;
  sub _handle_isa
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	return if ref $spec->{isa};
  	
  	require Type::Utils;
  	$spec->{isa} = Type::Utils::dwim_type($spec->{isa}, for => $class);
  	
  	return;
  }
  
  sub _handle_coerce
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	my $c = $spec->{coerce};
  	my $i = $spec->{isa};
  	
  	if (defined($c) and !ref($c) and $c == 1)
  	{
  		if (blessed($i) and $i->isa('Type::Tiny') and $i->has_coercion)
  		{
  			$spec->{coerce} = $i->coercion;
  		}
  		elsif (blessed($i) and $i->can('has_coercion') and $i->has_coercion and $i->can('coerce'))
  		{
  			$spec->{coerce} = sub { $i->coerce(@_) };
  		}
  	}
  
  	if (defined($c) and !ref($c) and $c eq 0)
  	{
  		delete($spec->{coerce});
  	}
  
  	return;
  }
  
  sub _handle_lazy_build
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	return unless delete $spec->{lazy_build};
  	
  	$spec->{is}      ||= "ro";
  	$spec->{lazy}    ||= 1;
  	$spec->{builder} ||= "_build_$name";
  	
  	if ($name =~ /^_/)
  	{
  		$spec->{clearer}   ||= "_clear$name";
  		$spec->{predicate} ||= "_has$name";
  	}
  	else
  	{
  		$spec->{clearer}   ||= "clear_$name";
  		$spec->{predicate} ||= "has_$name";
  	}
  	
  	return;
  }
  
  sub _handle_traits
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	my @new;
  	foreach my $trait (@{ $spec->{traits} || [] })
  	{
  		my $handler = $me->can("_handletrait_$trait");
  		croak "$me cannot process trait $trait" unless $handler;
  		
  		# SUBCLASSING
  		# There is a second level of handlers for traits.
  		# Just add a method called "_handletrait_Foo"
  		# and it will be called to handle the trait "Foo".
  		# These handlers should normally return the empty
  		# list, but may return a list of strings to add to
  		# a *new* traits arrayref.
  		#
  		push @new, $me->$handler(@_);
  	}
  	
  	$spec->{traits} = \@new;
  	
  	if ($spec->{handles_via})
  	{
  		eval "require MooX::HandlesVia"
  			or croak("Requires MooX::HandlesVia for attribute trait defined at $context");
  		
  		my ($name, %spec) = MooX::HandlesVia::process_has($name, %$spec);
  		%$spec = %spec;
  	}
  	
  	return;
  }
  
  sub _handletrait_Array
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Collection::Array::MooseLike";
  	
  	return;
  }
  
  sub _handletrait_Hash
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Collection::Hash::MooseLike";
  	
  	return;
  }
  
  sub _handletrait_Code
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Code";
  	
  	# Special handling for execute_method!
  	while (my ($k, $v) = each %{ $spec->{handles} })
  	{
  		next unless $v eq q(execute_method);
  		
  		# MooX::HandlesVia can't handle this right yet.
  		delete $spec->{handles}{$k};
  		
  		# ... so we handle it ourselves.
  		eval qq{
  			package ${class};
  			sub ${k} {
  				my \$self = shift;
  				return \$self->${name}->(\$self, \@_);
  			}
  		};
  	}
  	
  	return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf8
  
  =for stopwords superset MooX
  
  =head1 NAME
  
  MooX::late - easily translate Moose code to Moo
  
  =head1 SYNOPSIS
  
     package Foo;
     use Moo;
     use MooX::late;
     has bar => (is => "ro", isa => "Str", default => "MacLaren's Pub");
  
  (Examples for Moo roles in section below.)
  
  =head1 DESCRIPTION
  
  L<Moo> is a light-weight object oriented programming framework which aims
  to be compatible with L<Moose>. It does this by detecting when Moose has
  been loaded, and automatically "inflating" its classes and roles to full
  Moose classes and roles. This way, Moo classes can consume Moose roles,
  Moose classes can extend Moo classes, and so forth.
  
  However, the surface syntax of Moo differs somewhat from Moose. For example
  the C<isa> option when defining attributes in Moose must be either a string
  or a blessed L<Moose::Meta::TypeConstraint> object; but in Moo must be a
  coderef. These differences in surface syntax make porting code from Moose to
  Moo potentially tricky. L<MooX::late> provides some assistance by enabling a
  slightly more Moosey surface syntax.
  
  MooX::late does the following:
  
  =over
  
  =item 1.
  
  Allows C<< isa => $string >> to work when defining attributes for all
  Moose's built-in type constraints (and assumes other strings are package
  names).
  
  This feature requires L<Types::Standard>.
  
  =item 2.
  
  B<< Retired feature: >> this is now built in to Moo.
  
  Allows C<< default => $non_reference_value >> to work when defining
  attributes.
  
  =item 3.
  
  Allows C<< lazy_build => 1 >> to work when defining attributes.
  
  =item 4.
  
  Exports C<blessed> and C<confess> functions to your namespace.
  
  =item 5.
  
  Handles certain attribute traits. Currently C<Hash>, C<Array> and C<Code>
  are supported. This feature requires L<MooX::HandlesVia>. 
  
  C<String>, C<Number>, C<Counter> and C<Bool> are unlikely to ever be
  supported because of internal implementation details of Moo. If you need
  another attribute trait to be supported, let me know and I will consider
  it.
  
  =item 6.
  
  Supports C<< coerce => 1 >> if the type constraint is a blessed object
  implementing L<Type::API::Constraint::Coercible>.
  
  =back
  
  Five features. It is not the aim of C<MooX::late> to make every aspect of
  Moo behave exactly identically to Moose. It's just going after the low-hanging
  fruit. So it does five things right now, and I promise that future versions
  will never do more than seven.
  
  =head2 Use in Moo::Roles
  
  MooX::late should work in Moo::Roles, with no particular caveats.
  
     package MyRole;
     use Moo::Role;
     use MooX::late;
  
  L<Package::Variant> can be used to build the Moo equivalent of
  parameterized roles. MooX::late should work in roles built with
  Package::Variant.
  
     use Package::Variant
        importing => [ qw( Moo::Role MooX::late ) ],
        subs      => [ qw( has with ) ];
  
  =head2 Type constraints
  
  Type constraint strings are interpreted using L<Type::Parser>, using the
  type constraints defined in L<Types::Standard>. This provides a very slight
  superset of Moose's type constraint syntax and built-in type constraints.
  
  Any unrecognized string that looks like it might be a class name is
  interpreted as a class type constraint.
  
  =head2 Subclassing
  
  MooX::late is designed to be reasonably easy to subclass. There are comments
  in the source code explaining hooks for extensibility.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=MooX-late>.
  
  =head1 SEE ALSO
  
  C<MooX::late> uses L<Types::Standard> to check type constraints.
  
  C<MooX::late> uses L<MooX::HandlesVia> to provide native attribute traits
  support.
  
  The following modules bring additional Moose functionality to Moo:
  
  =over
  
  =item *
  
  L<MooX::Override> - support override/super
  
  =item *
  
  L<MooX::Augment> - support augment/inner
  
  =back
  
  L<MooX> allows you to load Moo plus multiple MooX extension modules in a
  single line.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2012-2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MOOX_LATE

$fatpacked{"Number/Bytes/Human.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_BYTES_HUMAN';
  package Number::Bytes::Human;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.09';
  
  require Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(format_bytes parse_bytes);
  
  require POSIX;
  use Carp qw(croak carp);
  
  #my $DEFAULT_BLOCK = 1024;
  #my $DEFAULT_ZERO = '0';
  #my $DEFAULT_ROUND_STYLE = 'ceil';
  my %DEFAULT_SUFFIXES = (
    1024 => ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'],
    1000 => ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'],
    1024000 => ['', 'M', 'T', 'E', 'Y'],
    si_1024 => ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],
    si_1000 => ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
  );
  my @DEFAULT_PREFIXES = @{$DEFAULT_SUFFIXES{1024}};
  
  sub _default_suffixes {
    my $set = shift || 1024;
    if (exists $DEFAULT_SUFFIXES{$set}) {
      return @{$DEFAULT_SUFFIXES{$set}} if wantarray;
      return [ @{$DEFAULT_SUFFIXES{$set}} ];
    }
    croak "unknown suffix set '$set'";
  }
  
  my %ROUND_FUNCTIONS = (
    ceil => sub { return POSIX::ceil($_[0] * (10 ** $_[1])) / 10**$_[1]; },
    floor => sub { return POSIX::floor($_[0] * (10 ** $_[1])) / 10**$_[1]; },
    round => sub { return sprintf( "%." . ( $_[1] || 0 ) . "f", $_[0] ); },
    trunc => sub { return sprintf( "%d", $_[0] * (10 ** $_[1])) / 10**$_[1]; },
    # what about 'ceiling'?
  );
  
  sub _round_function {
    my $style = shift;
    if (exists $ROUND_FUNCTIONS{$style}) {
      return $ROUND_FUNCTIONS{$style}
    }
    croak "unknown round style '$style'";
  }
  
  # options
  #   block | block_size | base | bs => 1024 | 1000
  #   base_1024 | block_1024 | 1024 => $true
  #   base_1000 | block_1000 | 1000 => $true
  #
  #   round_function => \&
  #   round_style => 'ceiling', 'round', 'floor', 'trunc'
  #
  #   suffixes => 1024 | 1000 | si_1024 | si_1000 | 1024000 | \@
  #   si => 1
  #   unit => string (eg., 'B' | 'bps' | 'b')
  #
  #   zero => '0' (default) | '-' | '0%S' | undef
  #
  #
  #   supress_point_zero | no_point_zero =>
  #   b_to_i => 1
  #   to_s => \&
  #
  #   allow_minus => 0 | 1
  #   too_large => string
  #   quiet => 1 (supresses "too large number" warning)
  
  
  
  #  PROBABLY CRAP:
  #   precision => integer
  
  # parsed options
  #   BLOCK => 1024 | 1000
  #   ROUND_STYLE => 'ceil', 'round', 'floor', 'trunc'
  #   ROUND_FUNCTION => \&
  #   SUFFIXES => \@
  #   ZERO =>
  #   SI => undef | 1			Parse SI compatible
  
  
  =begin private
  
    $options = _parse_args($seed, $args)
    $options = _parse_args($seed, arg1 => $val1, ...)
  
  $seed is undef or a hashref
  $args is a hashref
  
  =end private
  
  =cut
  
  sub _parse_args {
    my $seed = shift;
    my %args;
  
    my %options;
    unless (defined $seed) { # use defaults
      $options{BLOCK} = 1024;
      $options{ROUND_STYLE} = 'ceil';
      $options{ROUND_FUNCTION} = _round_function($options{ROUND_STYLE});
      $options{ZERO} = '0';
      $options{SI} = undef;
      $options{PRECISION} = 1;
      $options{PRECISION_CUTOFF} = 1;
      #$options{SUFFIXES} = # deferred to the last minute when we know BLOCK, seek [**]
      $options{UNIT} = undef;
    }
    # else { %options = %$seed } # this is set if @_!=0, down below
  
    if (@_==0) { # quick return for default values (no customized args)
      return (defined $seed) ? $seed : \%options;
    } elsif (@_==1 && ref $_[0]) { # \%args
      %args = %{$_[0]};
    } else { # arg1 => $val1, arg2 => $val2
      %args = @_;
    }
  
    # this is done here so this assignment/copy doesn't happen if @_==0
    %options = %$seed unless %options;
  
  # block | block_size | base | bs => 1024 | 1000
  # block_1024 | base_1024 | 1024 => $true
  # block_1000 | base_1000 | 1024 => $true
    if ($args{block} ||
        $args{block_size} ||
        $args{base} ||
        $args{bs}
      ) {
      my $block = $args{block} ||
                  $args{block_size} ||
                  $args{base} ||
                  $args{bs};
      unless ($block==1000 || $block==1024 || $block==1_024_000) {
        croak "invalid base: $block (should be 1024, 1000 or 1024000)";
      }
      $options{BLOCK} = $block;
  
    } elsif ($args{block_1024} ||
             $args{base_1024}  ||
             $args{1024}) {
  
      $options{BLOCK} = 1024;
    } elsif ($args{block_1000} ||
             $args{base_1000}  ||
             $args{1000}) {
  
      $options{BLOCK} = 1000;
    }
  
  # round_function => \&
  # round_style => 'ceil' | 'floor' | 'round' | 'trunc'
    if ($args{round_function}) {
      unless (ref $args{round_function} eq 'CODE') {
        croak "round function ($args{round_function}) should be a code ref";
      }
      $options{ROUND_FUNCTION} = $args{round_function};
      $options{ROUND_STYLE} = $args{round_style} || 'unknown';
    } elsif ($args{round_style}) {
      $options{ROUND_FUNCTION} = _round_function($args{round_style});
      $options{ROUND_STYLE} = $args{round_style};
    }
  
  # SI compatibility (mostly for parsing)
    if ($args{si}) {
      $options{SI} = 1;
    }
  
  # suffixes => 1024 | 1000 | si_1024 | si_1000 | 1024000 | \@
    if ($args{suffixes}) {
      if (ref $args{suffixes} eq 'ARRAY') {
        $options{SUFFIXES} = $args{suffixes};
      } elsif ($args{suffixes} =~ /^(si_)?(1000|1024)$/) {
        $options{SUFFIXES} = _default_suffixes($args{suffixes});
      } else {
        croak "suffixes ($args{suffixes}) should be 1024, 1000, si_1024, si_1000, 1024000 or an array ref";
      }
    }
    if (defined $args{unit}) {
      $options{UNIT} = $args{unit};
    }
  
  # zero => undef | string
    if (exists $args{zero}) {
      $options{ZERO} = $args{zero};
      if (defined $options{ZERO}) {
        $options{ZERO} =~ s/%S/$options{SUFFIXES}->[0]/g
      }
    }
  
  # precision => <integer>
    if (exists $args{precision} and $args{precision} =~ /\A\d+\z/) {
      $options{PRECISION} = $args{precision};
    }
  
  # precision_cutoff => <intenger>
    if (exists $args{precision_cutoff} and ($args{precision_cutoff} =~ /\A\d+\z/ or $args{precision_cutoff} = '-1')) {
      $options{PRECISION_CUTOFF} = $args{precision_cutoff};
    }
  
  # quiet => 1
    if ($args{quiet}) {
      $options{QUIET} = 1;
    }
  
    if (defined $seed) {
      %$seed = %options;
      return $seed;
    }
    return \%options
  }
  
  # NOTE. _format_bytes() SHOULD not change $options - NEVER.
  
  sub _format_bytes {
    my $bytes = shift;
    return undef unless defined $bytes;
    my $options = shift;
    my %options = %$options;
  
    local *human_round = $options{ROUND_FUNCTION};
  
    return $options{ZERO} if ($bytes==0 && defined $options{ZERO});
  
    my $block = $options{BLOCK};
  
    # if a suffix set was not specified, pick a default [**]
    my @suffixes = $options{SUFFIXES} ? @{$options{SUFFIXES}} : _default_suffixes( ($options{SI} ? 'si_' : '') . $block);
  
    # WHAT ABOUT NEGATIVE NUMBERS: -1K ?
    my $sign = '';
    if ($bytes<0) {
       $bytes = -$bytes;
       $sign = '-';
    }
  
    my $suffix = $suffixes[0];
    my $x = $bytes;
    my $magnitude = 0;
    if($bytes >= $block) {
    #  return "$sign$bytes" if $bytes<$block;
      do {
        $x /= $block;
        $magnitude++;
      } while ( human_round($x, $options{PRECISION}) >= $block );
      if($magnitude >= (0 + @suffixes)) {
        carp "number too large (>= $block**$magnitude)" unless ($options{QUIET});
      }
      $suffix = $suffixes[$magnitude];
    }
    #$x = human_round( $x, $options{PRECISION} );
  
    $x = _precision_cutoff($x, $options);
    #reasses encase the precision_cutoff caused the value to cross the block size
    if($x >= $block) {
      $x /= $block;
      $magnitude++;
      if($magnitude >= (0 + @suffixes)) {
        carp "number too large (>= $block**$magnitude)" unless ($options{QUIET});
      }
      $suffix = $suffixes[$magnitude];
      $x = _precision_cutoff($x, $options);
    }
  
    my $unit = $options{UNIT} || '';
  
    return $sign . $x . $suffix . $unit;
  
  }
  
  sub _precision_cutoff {
   my $bytes   = shift;
   my $options = shift;
   my %options = %$options;
   if ( $options{PRECISION_CUTOFF} != -1 and ( length( sprintf( "%d", $bytes ) ) > $options{PRECISION_CUTOFF} ) ) {
     $bytes = sprintf( "%d", human_round( $bytes, 0 ) );
   } else {
     $bytes = sprintf( "%." . $options{PRECISION} . "f", human_round( $bytes, $options{PRECISION} ) );
   }
   return $bytes;
  }
  
  sub _parse_bytes {
    my $human = shift;
    my $options = shift;
    my %options = %$options;
  
    return 0 if( exists $options{ZERO} && ((!defined $options{ZERO} && !defined $human) || (defined $human && $human eq $options{ZERO})) );
    return undef unless defined $human;
  
    my %suffix_mult;
    my %suffix_block;
    my $m;
  
    if( $options{SUFFIXES} ) {
      $m = 1;
      foreach my $s (@{$options{SUFFIXES}}) {
        $suffix_mult{$s} = $m;
        $suffix_block{$s} = $options{BLOCK};
        $m *= $suffix_block{$s};
      }
    } else {
      if( !defined $options{SI} || $options{SI} == 1 ) {
        # If SI compatibility has been set BLOCK is ignored as it is infered from the unit
        $m = 1;
        foreach my $s (@{$DEFAULT_SUFFIXES{si_1000}}) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = 1000;
          $m *= $suffix_block{$s};
        }
      
        $m = 1;
        foreach my $s (@{$DEFAULT_SUFFIXES{si_1024}}) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = 1024;
          $m *= $suffix_block{$s};
        }
      }
  
      # The regular suffixes are only taken into account in default mode without specifically asking for SI compliance
      if( !defined $options{SI} ) {
        $m = 1;
        foreach my $s (_default_suffixes( $options{BLOCK} )) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = $options{BLOCK};
          $m *= $suffix_block{$s};
        }
      }
    }
  
    my ($sign, $int, $frac, $unit) = ($human =~ /^\s*(-?)\s*(\d*)(?:\.(\d*))?\s*(\D*)$/);
  
    $frac ||= 0;
  
  #  print STDERR "S: $sign I: $int F: $frac U: $unit\n";
  
  
    my $mult;
    my $block;
    my $u = $options{UNIT} || '';
    foreach my $s (keys %suffix_block) {
      if( $unit =~ /^${s}${u}$/i ) {
        $mult = ($sign eq '-' ? -1 : 1) * $suffix_mult{$s};
        $block = $suffix_block{$s};
        last;
      }
    }
  
    if( !defined $mult ) {
      carp "Could not parse human readable byte value '$human'";
  use Data::Dumper;
  print STDERR Dumper( %suffix_block );
      return undef;
    }
  
    my $bytes = int( ($int + ($frac / $block)) * $mult );
  
    return $bytes;
  }
  
  
  # convert byte count (file size) to human readable format
  sub format_bytes {
    my $bytes = shift;
    my $options = _parse_args(undef, @_);
    #use YAML; print Dump $options;
    return _format_bytes($bytes, $options);
  }
  
  # convert human readable format to byte count (file size)
  sub parse_bytes {
    my $human = shift;
    my $options = _parse_args(undef, @_);
    #use YAML; print Dump $options;
    return _parse_bytes($human, $options);
  }
  
  ### the OO way
  
  # new()
  sub new {
    my $proto = shift;
    my $class = ref $proto || $proto;
    my $opts = _parse_args(undef, @_);
    return bless $opts, $class;
  }
  
  # set_options()
  sub set_options {
    my $self = shift;
    return $self->_parse_args(@_);
  }
  
  # format()
  sub format {
    my $self = shift;
    my $bytes = shift;
    return _format_bytes($bytes, $self);
  }
  
  # parse()
  sub parse {
    my $self = shift;
    my $human = shift;
    return _parse_bytes($human, $self);
  }
  
  # the solution by COG in Filesys::DiskUsage
  # convert size to human readable format
  #sub _convert {
  #  defined (my $size = shift) || return undef;
  #  my $config = {@_};
  #  $config->{human} || return $size;
  #  my $block = $config->{'Human-readable'} ? 1000 : 1024;
  #  my @args = qw/B K M G/;
  #
  #  while (@args && $size > $block) {
  #    shift @args;
  #    $size /= $block;
  #  }
  #
  #  if ($config->{'truncate-readable'} > 0) {
  #    $size = sprintf("%.$config->{'truncate-readable'}f",$size);
  #  }
  #
  #  "$size$args[0]";
  #}
  #
  # not exact: 1024 => 1024B instead of 1K
  # not nicely formatted => 1.00 instead of 1K
  
  1;
  
  __END__
  
  =head1 NAME
  
  Number::Bytes::Human - Convert byte count to human readable format
  
  =head1 SYNOPSIS
  
    use Number::Bytes::Human qw(format_bytes parse_bytes);
    $size = format_bytes(0); # '0'
    $size = format_bytes(2*1024); # '2.0K'
  
    $size = format_bytes(1_234_890, bs => 1000); # '1.3M'
    $size = format_bytes(1E9, bs => 1000); # '1.0G'
  
    my $bytes = parse_bytes('1.0K');   # 1024
    my $bytes = parse_bytes('1.0KB');  # 1000, SI unit
    my $bytes = parse_bytes('1.0KiB'); # 1024, SI unit
  
    # the OO way
    $human = Number::Bytes::Human->new(bs => 1000, si => 1);
    $size = $human->format(1E7); # '10MB'
  
    $bytes = $human->parse('10MB');   # 10*1000*1000
    $bytes = $human->parse('10MiB');  # 10*1024*1024
    $bytes = $human->parse('10M');    # Error, no SI unit
  
    $human->set_options(zero => '-');
    $size = $human->format(0);    # '-'
    $bytes = $human->parse('-');  # 0
  
    $human = Number::Bytes::Human->new(bs => 1000, round_style => 'round', precision => 2);
    $size = $human->format(10240000); # '10.24MB'
  
  =head1 DESCRIPTION
  
  THIS IS ALPHA SOFTWARE: THE DOCUMENTATION AND THE CODE WILL SUFFER
  CHANGES SOME DAY (THANKS, GOD!).
  
  This module provides a formatter which turns byte counts
  to usual readable format, like '2.0K', '3.1G', '100B'.
  It was inspired in the C<-h> option of Unix
  utilities like C<du>, C<df> and C<ls> for "human-readable" output.
  
  From the FreeBSD man page of C<df>: http://www.freebsd.org/cgi/man.cgi?query=df
  
    "Human-readable" output.  Use unit suffixes: Byte, Kilobyte,
    Megabyte, Gigabyte, Terabyte and Petabyte in order to reduce the
    number of digits to four or fewer using base 2 for sizes.
  
    byte      B
    kilobyte  K = 2**10 B = 1024 B
    megabyte  M = 2**20 B = 1024 * 1024 B
    gigabyte  G = 2**30 B = 1024 * 1024 * 1024 B
    terabyte  T = 2**40 B = 1024 * 1024 * 1024 * 1024 B
  
    petabyte  P = 2**50 B = 1024 * 1024 * 1024 * 1024 * 1024 B
    exabyte   E = 2**60 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
    zettabyte Z = 2**70 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
    yottabyte Y = 2**80 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
  
  I have found this link to be quite useful:
  
    http://www.t1shopper.com/tools/calculate/
  
  If you feel like a hard-drive manufacturer, you can start
  counting bytes by powers of 1000 (instead of the generous 1024).
  Just use C<< bs => 1000 >>.
  
  But if you are a floppy disk manufacturer and want to start
  counting in units of 1024000 (for your "1.44 MB" disks)?
  Then use C<< bs => 1_024_000 >>.
  
  If you feel like a purist academic, you can force the use of
  metric prefixes
  according to the Dec 1998 standard by the IEC. Never mind the units for base 1000
  are C<('B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB')> and,
  even worse, the ones for base 1024 are
  C<('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB')>
  with the horrible names: bytes, kibibytes, mebibytes, etc.
  All you have to do is to use C<< si => 1 >>. Ain't that beautiful
  the SI system? Read about it:
  
    http://physics.nist.gov/cuu/Units/binary.html
  
  You can try a pure Perl C<"ls -lh">-inspired command with the one-liner, er, two-liner:
  
    $ perl -MNumber::Bytes::Human=format_bytes \
           -e 'printf "%5s %s\n", format_bytes(-s), $_ for @ARGV' *
  
  Why to write such a module? Because if people can write such things
  in C, it can be written much easier in Perl and then reused,
  refactored, abused. And then, when it is much improved, some
  brave soul can port it back to C (if only for the warm feeling
  of painful programming).
  
  It is also possible to parse human readable formatted bytes. The 
  automatic format detection recognizes SI units with the blocksizes
  of 1000 and 1024 respectively and additionally the customary K / M / G etc. with
  blocksize 1024. When si => 1 is added to the options only SI units
  are recognized. Explicitly specifying a blocksize changes it
  for all detected units.
  
  =head2 OBJECTS
  
  An alternative to the functional style of this module
  is the OO fashion. This is useful for avoiding the
  unnecessary parsing of the arguments over and over
  if you have to format lots of numbers
  
  
    for (@sizes) {
      my $fmt_size = format_bytes($_, @args);
      ...
    }
  
  versus
  
    my $human = Number::Format::Bytes->new(@args);
    for (@sizes) {
      my $fmt_size = $human->format($_);
      ...
    }
  
  for TODO
  [TODO] MAKE IT JUST A MATTER OF STYLE: memoize _parse_args()
  $seed == undef
  
  =head2 FUNCTIONS
  
  =over 4
  
  =item B<format_bytes>
  
    $h_size = format_bytes($size, @options);
  
  Turns a byte count (like 1230) to a readable format like '1.3K'.
  You have a bunch of options to play with. See the section
  L</"OPTIONS"> to know the details.
  
  =item B<parse_bytes>
  
    $size = parse_bytes($h_size, @options);
  
  Turns a human readable byte count into a number of the equivalent bytes.
  
  =back
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
    $h = Number::Bytes::Human->new(@options);
  
  The constructor. For details on the arguments, see the section
  L</"OPTIONS">.
  
  =item B<format>
  
    $h_size = $h->format($size);
  
  Turns a byte count (like 1230) to a readable format like '1.3K'.
  The statements
  
    $h = Number::Bytes::Human->new(@options);
    $h_size = $h->format($size);
  
  are equivalent to C<$h_size = format_bytes($size, @options)>,
  with only one pass for the option arguments.
  
  =item B<parse>
  
    $size = $h->parse($h_size)
  
  Turns a human readable byte count into the number of bytes.
  The statements
  
    $h = Number::Bytes::Human->new(@options);
    $size = $h->format($h_size);
  
  are equivalent to C<$size = parse_bytes($h_size, @options)>,
  with only one pass for the option arguments.
  
  =item B<set_options>
  
    $h->set_options(@options);
  
  To alter the options of a C<Number::Bytes::Human> object.
  See L</"OPTIONS">.
  
  =back
  
  =head2 OPTIONS
  
  =over 4
  
  =item BASE
  
    block | base | block_size | bs => 1000 | 1024 | 1024000
    base_1024 | block_1024 | 1024 => 1
    base_1000 | block_1000 | 1000 => 1
  
  The base to be used: 1024 (default), 1000 or 1024000.
  
  Any other value throws an exception.
  
  =item SUFFIXES
  
    suffixes => 1000 | 1024 | 1024000 | si_1000 | si_1024 | $arrayref
  
  By default, the used suffixes stand for '', 'K', 'M', ...
  for base 1024 and '', 'k', 'M', ... for base 1000
  (which are indeed the usual metric prefixes with implied unit
  as bytes, 'B'). For the weird 1024000 base, suffixes are
  '', 'M', 'T', etc.
  
  =item ZERO
  
    zero => string | undef
  
  The string C<0> maps to ('0' by default). If C<undef>, the general case is used.
  The string may contain '%S' in which case the suffix for byte is used.
  
    format_bytes(0, zero => '-') => '-'
  
  =item METRIC SYSTEM
  
    si => 1
  
  =item ROUND
  
    round_function => $coderef
    round_style => 'ceil' | 'floor' | 'round' | 'trunc'
  
  =item TO_S
  
  =item QUIET
  
    quiet => 1
  
  Suppresses the warnings emitted. Currently, the only case is
  when the number is large than C<$base**(@suffixes+1)>.
  
  =item PRECISION
  
    precision => <integer>
  
  default = 1
  sets the precicion of digits, only apropreacte for round_style 'round' or if you
  want to accept it in as the second parameter to your custome round_function.
  
  =item PRECISION_CUTOFF
  
    precision_cutoff => <integer>
  
  default = 1
  when the number of digits exceeds this number causes the precision to be cutoff
  (was default behaviour in 0.07 and below)
  
  =back
  
  =head2 EXPORT
  
  It is alright to import C<format_bytes> and C<parse_bytes>, but nothing is exported by default.
  
  =head1 DIAGNOSTICS
  
    "unknown round style '$style'";
  
    "invalid base: $block (should be 1024, 1000 or 1024000)";
  
    "round function ($args{round_function}) should be a code ref";
  
    "suffixes ($args{suffixes}) should be 1000, 1024, 1024000 or an array ref";
  
    "negative numbers are not allowed" (??)
  
  =head1 TO DO
  
  A function C<parse_bytes>
  
    parse_bytes($str, $options)
  
  which transforms '1k' to 1000, '1K' to 1024, '1MB' to 1E6,
  '1M' to 1024*1024, etc. (like gnu du).
  
    $str =~ /^\s*(\d*\.?\d*)\s*(\S+)/ # $num $suffix
  
  =head1 SEE ALSO
  
  F<lib/human.c> and F<lib/human.h> in GNU coreutils.
  
  The C<_convert()> solution by COG in Filesys::DiskUsage.
  
  =head1 BUGS
  
  Please report bugs via CPAN RT L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Number-Bytes-Human>
  or L<mailto://bug-Number-Bytes-Human@rt.cpan.org>. I will not be able to close the bug
  as BestPractical ignore my claims that I cannot log in, but I will answer anyway.
  
  =head1 AUTHOR
  
  Adriano R. Ferreira, E<lt>ferreira@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2005-2007 by Adriano R. Ferreira
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
NUMBER_BYTES_HUMAN

$fatpacked{"Ouch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OUCH';
  use strict;
  use warnings;
  package Ouch;
  {
    $Ouch::VERSION = '0.0408';
  }
  use Carp qw(longmess shortmess);
  use parent 'Exporter';
  use overload bool => sub {1}, q{""} => 'scalar', fallback => 1;
  use Scalar::Util qw(blessed);
  
  our @EXPORT = qw(bleep ouch kiss hug barf);
  our @EXPORT_OK = qw(try throw catch catch_all caught caught_all);
  our %EXPORT_TAGS = ( traditional => [qw(try throw catch catch_all)], trytiny => [qw( throw caught caught_all )] );
  
  sub new {
    my ($class, $code, $message, $data) = @_;
    bless {code => $code, message => $message, data => $data, shortmess => shortmess($message), trace => longmess($message) }, $class;
  }
  
  sub try (&) {
    my $try = shift;
    eval { $try->() };
    return $@;
  }
  
  sub ouch {
    my ($code, $message, $data) = @_;
    my $self = __PACKAGE__->new($code, $message, $data);
    die $self;
  }
  
  sub throw {  # alias
    ouch @_;
  }
  
  sub kiss {
    my ($code, $e) = @_;
    $e ||= $@;
    if (blessed $e && $e->isa('Ouch') && $e->code eq $code) {
      return 1;
    }
    return 0;
  }
  
  sub catch {
    kiss @_;
  }
  
  sub caught {
    kiss @_;
  }
  
  sub hug {
    my ($e) = @_;
    $e ||= $@;
    return $@ ? 1 : 0;
  }
  
  sub catch_all {
    hug @_;
  }
  
  sub caught_all {
    hug @_;
  }
  
  sub bleep {
    my ($e) = @_;
    $e ||= $@;
    if (blessed $e && $e->isa('Ouch')) {
      return $e->message;
    }
    else {
      my $message = $@;
      if ($message =~ m{^(.*)\s+at\s.*line\s\d+.}xms) {
          return $1;
      }
      else {
          return $message;
      }
    }
  }
  
  sub barf {
      my ($e) = @_;
      my $code;
      $e ||= $@;
      if (blessed $e && $e->isa('Ouch')) {
          $code = $e->code;
      } 
      else {
          $code = 1;
      }
  
      print STDERR bleep($e)."\n";
      exit $code;
  }
  
  sub scalar {
    my $self = shift;
    return $self->{shortmess};
  }
  
  sub trace {
    my $self = shift;
    return $self->{trace};
  }
  
  sub hashref {
    my $self = shift;
    return {
      code    => $self->{code},
      message => $self->{message},
      data    => $self->{data},
    };
  }
  
  sub code {
    my $self = shift;
    return $self->{code};
  }
  
  sub message {
    my $self = shift;
    return $self->{message};
  }
  
  sub data {
    my $self = shift;
    return $self->{data};
  }
  
  =head1 NAME
  
  Ouch - Exceptions that don't hurt.
  
  =head1 VERSION
  
  version 0.0408
  
  =head1 SYNOPSIS
  
   use Ouch;
  
   eval { ouch(404, 'File not found.'); };
  
   if (kiss 404) {
     check_elsewhere();
   }
  
   say $@;           # These two lines do the
   say $@->scalar;   # same thing.
  
  =head1 DESCRIPTION
  
  Ouch provides a class for exception handling that doesn't require a lot of boilerplate, nor any up front definition. If L<Exception::Class>
  is working for you, great! But if you want something that is faster, easier to use, requires less typing, and has no prereqs, but still gives 
  you much of that same functionality, then Ouch is for you.
  
  =head2 Why another exception handling module?
  
  It really comes down to L<Carp> isn't enough for me, and L<Exception::Class> does what I want but makes me type way too much. Also, I tend to work on a lot of protocol-based systems that use error codes (HTTP, FTP, SMTP, JSON-RPC) rather than error classes, so that feels more natural to me. Consider the difference between these:
  
  B<Ouch>
  
   use Ouch;
   ouch 404, 'File not found.', 'file';
  
  B<Exception::Class>
  
   use Exception::Class (
      'FileNotFound' => {
          fields  => [ 'code', 'field' ],
      },
   );
   FileNotFound->throw( error => 'File not found.', code => 404, field => 'file' );
  
  And if you want to catch the exception you're looking at:
  
  B<Ouch>
  
   if (kiss 404) {
     # do something
   }
  
  B<Exception::Class>
  
   my $e;
   if ($e = Exception::Class->caught('FileNotFound')) {
     # do something
   }
  
  Those differences may not seem like a lot, but over any substantial program with lots of exceptions it can become a big deal. 
  
  =head2 Usage
  
  Most of the time, all you need to do is:
  
   ouch $code, $message, $data;
   ouch -32700, 'Parse error.', $request; # JSON-RPC 2.0 error
   ouch 441, 'You need to specify an email address.', 'email'; # form processing error
   ouch 'missing_param', 'You need to specify an email address.', 'email';
  
  You can also go long form if you prefer:
  
   die Ouch->new($code, $message, $data);
  
  If you want to rethrow an Ouch, you can simply C<die> it.
  
   eval { ouch(404, 'File not found.'); } ;
   die $@;
  
  =head2 Functional Interface
  
  =head3 ouch
  
  Some nice sugar instead of using the object oriented interface.
  
   ouch 2121, 'Did not do the big thing.';
  
  =over
  
  =item code
  
  An error code. An integer or string representing error type. Try to stick to codes used in whatever domain you happen to be working in. HTTP Status codes. JSON-RPC error codes, etc.
  
  =item message
  
  A human readable error message.
  
  =item data
  
  Optional. Anything you want to attach to the exception to help a developer catching it decide what to do. For example, if you're doing form processing, you might want this to be the name of the field that caused the exception. 
  
  B<WARNING:> Do not include objects or code refs in your data. This should only be stuff that is easily serializable like scalars, array refs, and hash refs.
  
  =back
  
  =head3 kiss
  
  Some nice sugar to trap an Ouch.
  
   if (kiss $code) {
      # make it go
   }
  
  =over
  
  =item code
  
  The code you're looking for.
  
  =item exception
  
  Optional. If you like you can pass the exception into C<kiss>. If not, it will just use whatever is in C<$@>. You might want to do this if you've saved the exception before running another C<eval>, for example.
  
  =back
  
  
  =head3 hug
  
  Some nice sugar to trap any exception.
  
   if (hug) {
     # make it stop
   }
  
  =over 
  
  =item exception
  
  Optional. If you like you can pass the exception into C<hug>. If not, it will just use whatever is in C<$@>.
  
  =back
  
  
  =head3 bleep 
  
  A little sugar to make exceptions human friendly. Returns a clean error message from any exception, including an Ouch.
  
   File not found.
  
  Rather than:
  
   File not found. at /Some/File.pm line 63.
  
  =over
  
  =item exception
  
  Optional. If you like you can pass the exception into C<bleep>. If not, it will just use whatever is in C<$@>.
  
  =back
  
  =head3 barf
  
  Calls C<bleep>, and then exits with error code
  
  =over
  
  =item exception
  
  Optional. You can pass an exception into C<barf> which then gets passed to C<bleep> otherwise it will use whatever's in C<$@>
  
  =back
  
  
  =head2 Object-Oriented Interface
  
  =head3 new
  
  Constructor for the object-oriented interface. Takes the same parameters as C<ouch>.
  
   Ouch->new($code, $message, $data);
  
  =head3 scalar
  
  Returns the scalar form of the error message:
  
   Crap! at /Some/File.pm line 43.
  
  Just as if you had done:
  
   die 'Crap!';
  
  Rather than:
  
   ouch $code, 'Crap!'; 
  
  =head3 trace
  
  Call this if you want the full stack trace that lead up to the ouch.
  
  =head3 hashref
  
  Returns a formatted hash reference of the exception, which can be useful for handing off to a serializer like L<JSON>.
  
   {
     code     => $code,
     message  => $message,
     data     => $data,
   }
  
  =head3 code
  
  Returns the C<code> passed into the constructor.
  
  =head3 message
  
  Returns the C<messsage> passed into the constructor.
  
  =head3 data
  
  Returns the C<data> passed into the constructor.
  
  =head2 Try::Tiny
  
  Many Ouch users like to use Ouch with L<Try::Tiny>.
  
   use Try::Tiny;
   use Ouch;
  
   try {
      ouch 404, 'File not found!';
   }
   catch {
      if (kiss(401, $_)) {
          # do something
      }
      else {
          die $_; # rethrow
      }
   };
  
  Some users are sticks in the mud who can't bring themselves to C<ouch> and C<kiss>. For them, there is the C<:trytiny> interface. Here's how it works:
  
   use Try::Tiny;
   use Ouch qw(:trytiny);
  
   try {
      throw(404, 'File not found!';
   }
   catch {
      if (caught(401, $_)) {
          # do something
      }
      else {
          die $_; # rethrow
      }
   };
  
  =head3 throw
  
  See C<ouch> for details.
  
  =head3 caught
  
  See C<kiss> for details.
  
  =head3 caught_all
  
  See C<hug> for details.
  
  =head1 DEPRECATED
  
  This functionality is deprecated and will be removed in a future release. Use Try::Tiny instead.
  
  =head2 Traditional Interface
  
  Some people just can't bring themselves to use the sugary cuteness of Ouch. For them there is the C<:traditional> interface. Here's how it works:
  
   use Ouch qw(:traditional);
  
   my $e = try {
     throw 404, 'File not found.';
   };
  
   if ( catch 404, $e ) {
     # do the big thing
   }
   elsif ( catch_all $e ) {
     # make it stop
   }
   else {
     # make it go
   }
  
  B<NOTE:> C<try> also populates C<$@>, and C<catch> and C<catch_all> will also use C<$@> if you don't specify an exception.
  
  =head3 try
  
  Returns an exception. Is basically just a nice wrapper around C<eval>.
  
  =over
  
  =item block
  
  Try accepts a code ref, anonymous subroutine, or a block. 
  
  B<NOTE:> You need a semi-colon at the end of a C<try> block.
  
  =back
  
  =head3 throw
  
  Works exactly like C<ouch>. See C<ouch> for details.
  
  =head3 catch
  
  Works exactly like C<kiss>. See C<kiss> for details.
  
  =head3 catch_all
  
  Works exactly like C<hug>. See C<hug> for details.
  
  
  =head1 REQUIREMENTS
  
  Requires Perl 5.12 or higher.
  
  
  
  =head1 SUPPORT
  
  =over
  
  =item Repository
  
  L<http://github.com/rizen/Ouch>
  
  =item Bug Reports
  
  L<http://github.com/rizen/Ouch/issues>
  
  =back
  
  
  =head1 SEE ALSO
  
  If you're looking for something lighter, check out L<Carp> that ships with Perl. Or if you're looking for something heavier check out L<Exception::Class>.
  
  =head1 AUTHOR
  
  JT Smith <jt_at_plainblack_dot_com>
  
  =head1 LEGAL
  
  Ouch is Copyright 2011 Plain Black Corporation (L<http://www.plainblack.com>) and is licensed under the same terms as Perl itself.
  
  =cut
  
  1;
OUCH

$fatpacked{"Package/DeprecationManager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_DEPRECATIONMANAGER';
  package Package::DeprecationManager;
  {
    $Package::DeprecationManager::VERSION = '0.13';
  }
  
  use strict;
  use warnings;
  
  use Carp qw( croak );
  use List::MoreUtils qw( any );
  use Params::Util qw( _HASH0 );
  use Sub::Install;
  
  sub import {
      shift;
      my %args = @_;
  
      croak
          'You must provide a hash reference -deprecations parameter when importing Package::DeprecationManager'
          unless $args{-deprecations} && _HASH0( $args{-deprecations} );
  
      my %registry;
  
      my $import = _build_import( \%registry );
      my $warn = _build_warn( \%registry, $args{-deprecations}, $args{-ignore} );
  
      my $caller = caller();
  
      Sub::Install::install_sub(
          {
              code => $import,
              into => $caller,
              as   => 'import',
          }
      );
  
      Sub::Install::install_sub(
          {
              code => $warn,
              into => $caller,
              as   => 'deprecated',
          }
      );
  
      return;
  }
  
  sub _build_import {
      my $registry = shift;
  
      return sub {
          my $class = shift;
          my %args  = @_;
  
          $args{-api_version} ||= delete $args{-compatible};
  
          $registry->{ caller() } = $args{-api_version}
              if $args{-api_version};
  
          return;
      };
  }
  
  sub _build_warn {
      my $registry      = shift;
      my $deprecated_at = shift;
      my $ignore        = shift;
  
      my %ignore = map { $_ => 1 } grep { !ref } @{ $ignore || [] };
      my @ignore_res = grep {ref} @{ $ignore || [] };
  
      my %warned;
  
      return sub {
          my %args = @_ < 2 ? ( message => shift ) : @_;
  
          my ( $package, undef, undef, $sub ) = caller(1);
  
          my $skipped = 1;
  
          if ( @ignore_res || keys %ignore ) {
              while ( defined $package
                  && ( $ignore{$package} || any { $package =~ $_ } @ignore_res )
                  ) {
                  $package = caller( $skipped++ );
              }
          }
  
          $package = 'unknown package' unless defined $package;
  
          unless ( defined $args{feature} ) {
              $args{feature} = $sub;
          }
  
          my $compat_version = $registry->{$package};
  
          my $deprecated_at = $deprecated_at->{ $args{feature} };
  
          return
              if defined $compat_version
                  && defined $deprecated_at
                  && $compat_version lt $deprecated_at;
  
          my $msg;
          if ( defined $args{message} ) {
              $msg = $args{message};
          }
          else {
              $msg = "$args{feature} has been deprecated";
              $msg .= " since version $deprecated_at"
                  if defined $deprecated_at;
          }
  
          return if $warned{$package}{ $args{feature} }{$msg};
  
          $warned{$package}{ $args{feature} }{$msg} = 1;
  
          # We skip at least two levels. One for this anon sub, and one for the
          # sub calling it.
          local $Carp::CarpLevel = $Carp::CarpLevel + $skipped;
  
          Carp::cluck($msg);
      };
  }
  
  1;
  
  # ABSTRACT: Manage deprecation warnings for your distribution
  
  
  
  =pod
  
  =head1 NAME
  
  Package::DeprecationManager - Manage deprecation warnings for your distribution
  
  =head1 VERSION
  
  version 0.13
  
  =head1 SYNOPSIS
  
    package My::Class;
  
    use Package::DeprecationManager -deprecations => {
        'My::Class::foo' => '0.02',
        'My::Class::bar' => '0.05',
        'feature-X'      => '0.07',
    };
  
    sub foo {
        deprecated( 'Do not call foo!' );
  
        ...
    }
  
    sub bar {
        deprecated();
  
        ...
    }
  
    sub baz {
        my %args = @_;
  
        if ( $args{foo} ) {
            deprecated(
                message => ...,
                feature => 'feature-X',
            );
        }
    }
  
    package Other::Class;
  
    use My::Class -api_version => '0.04';
  
    My::Class->new()->foo(); # warns
    My::Class->new()->bar(); # does not warn
    My::Class->new()->bar(); # does not warn again
  
  =head1 DESCRIPTION
  
  This module allows you to manage a set of deprecations for one or more modules.
  
  When you import C<Package::DeprecationManager>, you must provide a set of
  C<-deprecations> as a hash ref. The keys are "feature" names, and the values
  are the version when that feature was deprecated.
  
  In many cases, you can simply use the fully qualified name of a subroutine or
  method as the feature name. This works for cases where the whole subroutine is
  deprecated. However, the feature names can be any string. This is useful if
  you don't want to deprecate an entire subroutine, just a certain usage.
  
  You can also provide an optional array reference in the C<-ignore>
  parameter.
  
  The values to be ignored can be package names or regular expressions (made
  with C<qr//>).  Use this to ignore packages in your distribution that can
  appear on the call stack when a deprecated feature is used.
  
  As part of the import process, C<Package::DeprecationManager> will export two
  subroutines into its caller. It provides an C<import()> sub for the caller and a
  C<deprecated()> sub.
  
  The C<import()> sub allows callers of I<your> class to specify an C<-api_version>
  parameter. If this is supplied, then deprecation warnings are only issued for
  deprecations for api versions earlier than the one specified.
  
  You must call the C<deprecated()> sub in each deprecated subroutine. When
  called, it will issue a warning using C<Carp::cluck()>.
  
  The C<deprecated()> sub can be called in several ways. If you do not pass any
  arguments, it will generate an appropriate warning message. If you pass a
  single argument, this is used as the warning message.
  
  Finally, you can call it with named arguments. Currently, the only allowed
  names are C<message> and C<feature>. The C<feature> argument should correspond
  to the feature name passed in the C<-deprecations> hash.
  
  If you don't explicitly specify a feature, the C<deprecated()> sub uses
  C<caller()> to identify its caller, using its fully qualified subroutine name.
  
  A given deprecation warning is only issued once for a given package. This
  module tracks this based on both the feature name I<and> the error message
  itself. This means that if you provide several different error messages for
  the same feature, all of those errors will appear.
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  C<bug-package-deprecationmanager@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.  I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order
  for me to continue working on this particular software. I will
  continue to do so, inasmuch as I have in the past, for as long as it
  interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time, which seems unlikely at best.
  
  To donate, log into PayPal and send money to autarch@urth.org or use the
  button on this page: L<http://www.urth.org/~autarch/fs-donation.html>
  
  =head1 CREDITS
  
  The idea for this functionality and some of its implementation was originally
  created as L<Class::MOP::Deprecated> by Goro Fuji.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
  
  
  __END__
  
PACKAGE_DEPRECATIONMANAGER

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;
  BEGIN {
    $Package::Stash::AUTHORITY = 'cpan:DOY';
  }
  {
    $Package::Stash::VERSION = '0.36';
  }
  use strict;
  use warnings;
  use 5.008001;
  # ABSTRACT: routines for manipulating stashes
  
  our $IMPLEMENTATION;
  
  use Module::Implementation 0.06;
  
  BEGIN {
      local $ENV{PACKAGE_STASH_IMPLEMENTATION} = $IMPLEMENTATION
        if ( $IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION} );
  
      Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => [qw(
              new
              name
              namespace
              add_symbol
              remove_glob
              has_symbol
              get_symbol
              get_or_add_symbol
              remove_symbol
              list_all_symbols
              get_all_symbols
          )],
      )->();
      $IMPLEMENTATION = Module::Implementation::implementation_for(__PACKAGE__);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Package::Stash - routines for manipulating stashes
  
  =head1 VERSION
  
  version 0.36
  
  =head1 SYNOPSIS
  
    my $stash = Package::Stash->new('Foo');
    $stash->add_symbol('%foo', {bar => 1});
    # $Foo::foo{bar} == 1
    $stash->has_symbol('$foo') # false
    my $namespace = $stash->namespace;
    *{ $namespace->{foo} }{HASH} # {bar => 1}
  
  =head1 DESCRIPTION
  
  Manipulating stashes (Perl's symbol tables) is occasionally necessary, but
  incredibly messy, and easy to get wrong. This module hides all of that behind a
  simple API.
  
  NOTE: Most methods in this class require a variable specification that includes
  a sigil. If this sigil is absent, it is assumed to represent the IO slot.
  
  Due to limitations in the typeglob API available to perl code, and to typeglob
  manipulation in perl being quite slow, this module provides two
  implementations - one in pure perl, and one using XS. The XS implementation is
  to be preferred for most usages; the pure perl one is provided for cases where
  XS modules are not a possibility. The current implementation in use can be set
  by setting C<$ENV{PACKAGE_STASH_IMPLEMENTATION}> or
  C<$Package::Stash::IMPLEMENTATION> before loading Package::Stash (with the
  environment variable taking precedence), otherwise, it will use the XS
  implementation if possible, falling back to the pure perl one.
  
  =head1 METHODS
  
  =head2 new $package_name
  
  Creates a new C<Package::Stash> object, for the package given as the only
  argument.
  
  =head2 name
  
  Returns the name of the package that this object represents.
  
  =head2 namespace
  
  Returns the raw stash itself.
  
  =head2 add_symbol $variable $value %opts
  
  Adds a new package symbol, for the symbol given as C<$variable>, and optionally
  gives it an initial value of C<$value>. C<$variable> should be the name of
  variable including the sigil, so
  
    Package::Stash->new('Foo')->add_symbol('%foo')
  
  will create C<%Foo::foo>.
  
  Valid options (all optional) are C<filename>, C<first_line_num>, and
  C<last_line_num>.
  
  C<$opts{filename}>, C<$opts{first_line_num}>, and C<$opts{last_line_num}> can
  be used to indicate where the symbol should be regarded as having been defined.
  Currently these values are only used if the symbol is a subroutine ('C<&>'
  sigil) and only if C<$^P & 0x10> is true, in which case the special C<%DB::sub>
  hash is updated to record the values of C<filename>, C<first_line_num>, and
  C<last_line_num> for the subroutine. If these are not passed, their values are
  inferred (as much as possible) from C<caller> information.
  
  This is especially useful for debuggers and profilers, which use C<%DB::sub> to
  determine where the source code for a subroutine can be found.  See
  L<http://perldoc.perl.org/perldebguts.html#Debugger-Internals> for more
  information about C<%DB::sub>.
  
  =head2 remove_glob $name
  
  Removes all package variables with the given name, regardless of sigil.
  
  =head2 has_symbol $variable
  
  Returns whether or not the given package variable (including sigil) exists.
  
  =head2 get_symbol $variable
  
  Returns the value of the given package variable (including sigil).
  
  =head2 get_or_add_symbol $variable
  
  Like C<get_symbol>, except that it will return an empty hashref or
  arrayref if the variable doesn't exist.
  
  =head2 remove_symbol $variable
  
  Removes the package variable described by C<$variable> (which includes the
  sigil); other variables with the same name but different sigils will be
  untouched.
  
  =head2 list_all_symbols $type_filter
  
  Returns a list of package variable names in the package, without sigils. If a
  C<type_filter> is passed, it is used to select package variables of a given
  type, where valid types are the slots of a typeglob ('SCALAR', 'CODE', 'HASH',
  etc). Note that if the package contained any C<BEGIN> blocks, perl will leave
  an empty typeglob in the C<BEGIN> slot, so this will show up if no filter is
  used (and similarly for C<INIT>, C<END>, etc).
  
  =head2 get_all_symbols $type_filter
  
  Returns a hashref, keyed by the variable names in the package. If
  C<$type_filter> is passed, the hash will contain every variable of that type in
  the package as values, otherwise, it will contain the typeglobs corresponding
  to the variable names (basically, a clone of the stash).
  
  =head1 WORKING WITH VARIABLES
  
  It is important to note, that when working with scalar variables, the default
  behavior is to B<copy> values.
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is a copy of $variable
    $stash->add_symbol('$name', $variable);
    $variable++
    # $Some::Namespace::name == 1 , $variable == 2
  
  This will likely confuse people who expect it to work the same as typeglob
  assignment, which simply creates new references to existing variables.
  
    my $variable = 1;
    {
        no strict 'refs';
        # assign $Package::Stash::name = $variable
        *{'Package::Stash::name'} = \$variable;
    }
    $variable++ # affects both names
  
  If this behaviour is desired when working with Package::Stash, simply pass
  Package::Stash a scalar ref:
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is now $variable
    $stash->add_symbol('$name', \$variable);
    $variable++
    # $Some::Namespace::name == 2 , $variable == 2
  
  This will be what you want as well if you're ever working with L<Readonly>
  variables:
  
    use Readonly;
    Readonly my $value, 'hello';
  
    $stash->add_symbol('$name', \$value); # reference
    print $Some::Namespace::name; # hello
    # Tries to modify the read-only 'hello' and dies.
    $Some::Namespace::name .= " world";
  
    $stash->add_symbol('$name', $value); # copy
    print $Some::Namespace::name; # hello
    # No problem, modifying a copy, not the original
    $Some::Namespace::name .= " world";
  
  =head1 BUGS / CAVEATS
  
  =over 4
  
  =item * Prior to perl 5.10, scalar slots are only considered to exist if they are defined
  
  This is due to a shortcoming within perl itself. See
  L<perlref/Making References> point 7 for more information.
  
  =item * GLOB and FORMAT variables are not (yet) accessible through this module.
  
  =item * Also, see the BUGS section for the specific backends (L<Package::Stash::XS> and L<Package::Stash::PP>)
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Package-Stash>
  
  =item * Github
  
  L<https://github.com/doy/package-stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =back
  
  =head1 HISTORY
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package # hide from PAUSE
      Package::Stash::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Package::Stash',
      -conflicts => {
          'Class::MOP' => '1.08',
          'MooseX::Method::Signatures' => '0.36',
          'MooseX::Role::WithOverloading' => '0.08',
          'namespace::clean' => '0.18',
      },
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Package::Stash
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Package::Stash::Conflicts - Provide information on conflicts for Package::Stash
  
  =head1 VERSION
  
  version 0.36
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;
  BEGIN {
    $Package::Stash::PP::AUTHORITY = 'cpan:DOY';
  }
  {
    $Package::Stash::PP::VERSION = '0.36';
  }
  use strict;
  use warnings;
  # ABSTRACT: pure perl implementation of the Package::Stash API
  
  use B;
  use Carp qw(confess);
  use Scalar::Util qw(blessed reftype weaken);
  use Symbol;
  # before 5.12, assigning to the ISA glob would make it lose its magical ->isa
  # powers
  use constant BROKEN_ISA_ASSIGNMENT => ($] < 5.012);
  # before 5.10, stashes don't ever seem to drop to a refcount of zero, so
  # weakening them isn't helpful
  use constant BROKEN_WEAK_STASH     => ($] < 5.010);
  # before 5.10, the scalar slot was always treated as existing if the
  # glob existed
  use constant BROKEN_SCALAR_INITIALIZATION => ($] < 5.010);
  # add_method on anon stashes triggers rt.perl #1804 otherwise
  # fixed in perl commit v5.13.3-70-g0fe688f
  use constant BROKEN_GLOB_ASSIGNMENT => ($] < 5.013004);
  # pre-5.10, ->isa lookups were cached in the ::ISA::CACHE:: slot
  use constant HAS_ISA_CACHE => ($] < 5.010);
  
  
  sub new {
      my $class = shift;
      my ($package) = @_;
  
      if (!defined($package) || (ref($package) && reftype($package) ne 'HASH')) {
          confess "Package::Stash->new must be passed the name of the "
                . "package to access";
      }
      elsif (ref($package) && reftype($package) eq 'HASH') {
          confess "The PP implementation of Package::Stash does not support "
                . "anonymous stashes before perl 5.14"
              if BROKEN_GLOB_ASSIGNMENT;
  
          return bless {
              'namespace' => $package,
          }, $class;
      }
      elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/) {
          return bless {
              'package' => $package,
          }, $class;
      }
      else {
          confess "$package is not a module name";
      }
  
  }
  
  sub name {
      confess "Can't call name as a class method"
          unless blessed($_[0]);
      confess "Can't get the name of an anonymous package"
          unless defined($_[0]->{package});
      return $_[0]->{package};
  }
  
  sub namespace {
      confess "Can't call namespace as a class method"
          unless blessed($_[0]);
  
      if (BROKEN_WEAK_STASH) {
          no strict 'refs';
          return \%{$_[0]->name . '::'};
      }
      else {
          return $_[0]->{namespace} if defined $_[0]->{namespace};
  
          {
              no strict 'refs';
              $_[0]->{namespace} = \%{$_[0]->name . '::'};
          }
  
          weaken($_[0]->{namespace});
  
          return $_[0]->{namespace};
      }
  }
  
  {
      my %SIGIL_MAP = (
          '$' => 'SCALAR',
          '@' => 'ARRAY',
          '%' => 'HASH',
          '&' => 'CODE',
          ''  => 'IO',
      );
  
      sub _deconstruct_variable_name {
          my ($variable) = @_;
  
          my @ret;
          if (ref($variable) eq 'HASH') {
              @ret = @{$variable}{qw[name sigil type]};
          }
          else {
              (defined $variable && length $variable)
                  || confess "You must pass a variable name";
  
              my $sigil = substr($variable, 0, 1, '');
  
              if (exists $SIGIL_MAP{$sigil}) {
                  @ret = ($variable, $sigil, $SIGIL_MAP{$sigil});
              }
              else {
                  @ret = ("${sigil}${variable}", '', $SIGIL_MAP{''});
              }
          }
  
          # XXX in pure perl, this will access things in inner packages,
          # in xs, this will segfault - probably look more into this at
          # some point
          ($ret[0] !~ /::/)
              || confess "Variable names may not contain ::";
  
          return @ret;
      }
  }
  
  sub _valid_for_type {
      my ($value, $type) = @_;
      if ($type eq 'HASH' || $type eq 'ARRAY'
       || $type eq 'IO'   || $type eq 'CODE') {
          return reftype($value) eq $type;
      }
      else {
          my $ref = reftype($value);
          return !defined($ref) || $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING';
      }
  }
  
  sub add_symbol {
      my ($self, $variable, $initial_value, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      if (@_ > 2) {
          _valid_for_type($initial_value, $type)
              || confess "$initial_value is not of type $type";
  
          # cheap fail-fast check for PERLDBf_SUBLINE and '&'
          if ($^P and $^P & 0x10 && $sigil eq '&') {
              my $filename = $opts{filename};
              my $first_line_num = $opts{first_line_num};
  
              (undef, $filename, $first_line_num) = caller
                  if not defined $filename;
  
              my $last_line_num = $opts{last_line_num} || ($first_line_num ||= 0);
  
              # http://perldoc.perl.org/perldebguts.html#Debugger-Internals
              $DB::sub{$self->name . '::' . $name} = "$filename:$first_line_num-$last_line_num";
          }
      }
  
      if (BROKEN_GLOB_ASSIGNMENT) {
          if (@_ > 2) {
              no strict 'refs';
              no warnings 'redefine';
              *{ $self->name . '::' . $name } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              no strict 'refs';
              if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA') {
                  *{ $self->name . '::' . $name };
              }
              else {
                  my $undef = _undef_ref_for_type($type);
                  *{ $self->name . '::' . $name } = $undef;
              }
          }
      }
      else {
          my $namespace = $self->namespace;
          {
              # using glob aliasing instead of Symbol::gensym, because otherwise,
              # magic doesn't get applied properly.
              # see <20120710063744.19360.qmail@lists-nntp.develooper.com> on p5p
              local *__ANON__:: = $namespace;
              no strict 'refs';
              no warnings 'void';
              *{"__ANON__::$name"};
          }
  
          if (@_ > 2) {
              no warnings 'redefine';
              *{ $namespace->{$name} } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';
              *{ $namespace->{$name} } = _undef_ref_for_type($type);
          }
      }
  }
  
  sub _undef_ref_for_type {
      my ($type) = @_;
  
      if ($type eq 'ARRAY') {
          return [];
      }
      elsif ($type eq 'HASH') {
          return {};
      }
      elsif ($type eq 'SCALAR') {
          return \undef;
      }
      elsif ($type eq 'IO') {
          return Symbol::geniosym;
      }
      elsif ($type eq 'CODE') {
          confess "Don't know how to vivify CODE variables";
      }
      else {
          confess "Unknown type $type in vivication";
      }
  }
  
  sub remove_glob {
      my ($self, $name) = @_;
      delete $self->namespace->{$name};
  }
  
  sub has_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      return unless exists $namespace->{$name};
  
      my $entry_ref = \$namespace->{$name};
      if (reftype($entry_ref) eq 'GLOB') {
          if ($type eq 'SCALAR') {
              if (BROKEN_SCALAR_INITIALIZATION) {
                  return defined ${ *{$entry_ref}{$type} };
              }
              else {
                  my $sv = B::svref_2object($entry_ref)->SV;
                  return $sv->isa('B::SV')
                      || ($sv->isa('B::SPECIAL')
                       && $B::specialsv_name[$$sv] ne 'Nullsv');
              }
          }
          else {
              return defined *{$entry_ref}{$type};
          }
      }
      else {
          # a symbol table entry can be -1 (stub), string (stub with prototype),
          # or reference (constant)
          return $type eq 'CODE';
      }
  }
  
  sub get_symbol {
      my ($self, $variable, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      if (!exists $namespace->{$name}) {
          if ($opts{vivify}) {
              $self->add_symbol($variable);
          }
          else {
              return undef;
          }
      }
  
      my $entry_ref = \$namespace->{$name};
  
      if (ref($entry_ref) eq 'GLOB') {
          return *{$entry_ref}{$type};
      }
      else {
          if ($type eq 'CODE') {
              if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})) {
                  no strict 'refs';
                  return \&{ $self->name . '::' . $name };
              }
  
              # XXX we should really be able to support arbitrary anonymous
              # stashes here... (not just via Package::Anon)
              if (blessed($namespace) && $namespace->isa('Package::Anon')) {
                  # ->can will call gv_init for us, which inflates the glob
                  # don't know how to do this in general
                  $namespace->bless(\(my $foo))->can($name);
              }
              else {
                  confess "Don't know how to inflate a " . ref($entry_ref)
                        . " into a full coderef (perhaps you could use"
                        . " Package::Anon instead of a bare stash?)"
              }
  
              return *{ $namespace->{$name} }{CODE};
          }
          else {
              return undef;
          }
      }
  }
  
  sub get_or_add_symbol {
      my $self = shift;
      $self->get_symbol(@_, vivify => 1);
  }
  
  sub remove_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      # FIXME:
      # no doubt this is grossly inefficient and
      # could be done much easier and faster in XS
  
      my %desc = (
          SCALAR => { sigil => '$', type => 'SCALAR', name => $name },
          ARRAY  => { sigil => '@', type => 'ARRAY',  name => $name },
          HASH   => { sigil => '%', type => 'HASH',   name => $name },
          CODE   => { sigil => '&', type => 'CODE',   name => $name },
          IO     => { sigil => '',  type => 'IO',     name => $name },
      );
      confess "This should never ever ever happen" if !$desc{$type};
  
      my @types_to_store = grep { $type ne $_ && $self->has_symbol($desc{$_}) }
                                keys %desc;
      my %values = map { $_, $self->get_symbol($desc{$_}) } @types_to_store;
  
      $values{SCALAR} = $self->get_symbol($desc{SCALAR})
        if !defined $values{SCALAR}
          && $type ne 'SCALAR'
          && BROKEN_SCALAR_INITIALIZATION;
  
      $self->remove_glob($name);
  
      $self->add_symbol($desc{$_} => $values{$_})
          for grep { defined $values{$_} } keys %values;
  }
  
  sub list_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      if (HAS_ISA_CACHE) {
          return grep { $_ ne '::ISA::CACHE::' } keys %{$namespace}
              unless defined $type_filter;
      }
      else {
          return keys %{$namespace}
              unless defined $type_filter;
      }
  
      # NOTE:
      # or we can filter based on
      # type (SCALAR|ARRAY|HASH|CODE)
      if ($type_filter eq 'CODE') {
          return grep {
              # any non-typeglob in the symbol table is a constant or stub
              ref(\$namespace->{$_}) ne 'GLOB'
                  # regular subs are stored in the CODE slot of the typeglob
                  || defined(*{$namespace->{$_}}{CODE})
          } keys %{$namespace};
      }
      elsif ($type_filter eq 'SCALAR') {
          return grep {
              !(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::') &&
              (BROKEN_SCALAR_INITIALIZATION
                  ? (ref(\$namespace->{$_}) eq 'GLOB'
                        && defined(${*{$namespace->{$_}}{'SCALAR'}}))
                  : (do {
                        my $entry = \$namespace->{$_};
                        ref($entry) eq 'GLOB'
                            && B::svref_2object($entry)->SV->isa('B::SV')
                    }))
          } keys %{$namespace};
      }
      else {
          return grep {
              ref(\$namespace->{$_}) eq 'GLOB'
                  && defined(*{$namespace->{$_}}{$type_filter})
          } keys %{$namespace};
      }
  }
  
  sub get_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      return { %{$namespace} } unless defined $type_filter;
  
      return {
          map { $_ => $self->get_symbol({name => $_, type => $type_filter}) }
              $self->list_all_symbols($type_filter)
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Package::Stash::PP - pure perl implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.36
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash> implemented in pure perl, for those without a compiler or who would like to use this inline in scripts.
  
  =head1 BUGS
  
  =over 4
  
  =item * remove_symbol also replaces the associated typeglob
  
  This can cause unexpected behavior when doing manipulation at compile time -
  removing subroutines will still allow them to be called from within the package
  as subroutines (although they will not be available as methods). This can be
  considered a feature in some cases (this is how L<namespace::clean> works, for
  instance), but should not be relied upon - use C<remove_glob> directly if you
  want this behavior.
  
  =item * Some minor memory leaks
  
  The pure perl implementation has a couple minor memory leaks (see the TODO
  tests in t/20-leaks.t) that I'm having a hard time tracking down - these may be
  core perl bugs, it's hard to tell.
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Mostly copied from code from L<Class::MOP::Package>, by Stevan Little and the
  Moose Cabal.
  
  =for Pod::Coverage BROKEN_ISA_ASSIGNMENT
  add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH_PP

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  our $VERSION = '0.052'; # VERSION
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 3.40 ();
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_BSD   => ( scalar $^O =~ /bsd$/ ),
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?$}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT$/ ) : ( $_[0] eq '/' );
  }
  
  # flock doesn't work on NFS on BSD.  Since program authors often can't control
  # or detect that, we warn once instead of being fatal if we can detect it and
  # people who need it strict can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use if Path::Tiny::IS_BSD(), 'warnings::register' }
  #>>>
  
  my $WARNED_BSD_NFS = 0;
  
  sub _throw {
      my ( $self, $function, $file ) = @_;
      if (   IS_BSD()
          && $function =~ /^flock/
          && $! =~ /operation not supported/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_BSD_NFS ) {
              warnings::warn( flock => "No flock for NFS on BSD: continuing in unsafe mode" );
              $WARNED_BSD_NFS++;
          }
      }
      else {
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ), $! );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  
  sub path {
      my $path = shift;
      Carp::croak("path() requires a defined, positive-length argument")
        unless defined $path && length $path;
  
      # stringify initial path
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};
          $path .= "/" if $path =~ m{^$UNC_VOL$};
      }
  
      # concatenate more arguments (stringifies any objects, too)
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize paths
      my $cpath = $path = File::Spec->canonpath($path); # ugh, but probably worth it
      $path =~ tr[\\][/] if IS_WIN32();                 # unix convention enforced
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL$}; # canonpath strips it
  
      # hack to make splitpath give us a basename; root paths must always have
      # a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?$}{/};
      }
      else {
          $path =~ s{/$}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          my ($homedir) = glob($1); # glob without list context == heisenbug!
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      # and we're finally done
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  
  sub new { shift; path(@_) }
  
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  
  sub tempfile {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # relative path on any OS
      require Cwd;
      return path( ( defined($base) ? $base : Cwd::getcwd() ), $_[0]->[PATH] );
  }
  
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, ">>", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &append }
  
  sub append_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          append( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &append;
      }
  }
  
  
  sub basename {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[FILE];
      return $self->[FILE];
  }
  
  
  sub canonpath { $_[0]->[CANON] }
  
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  }
  
  
  sub digest {
      my ( $self, $alg, @args ) = @_;
      $alg = 'SHA-256' unless defined $alg;
      require Digest;
      return Digest->new( $alg, @args )->add( $self->slurp_raw )->hexdigest;
  }
  
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -f $_[0]->[PATH] }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked/ );
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX
              $opentype = "+<";
              $lock     = Fcntl::LOCK_EX();
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( @result, $counter );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if $chomp;
              push @result, $line;
              last if ++$counter == $args->{count};
          }
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})$//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() )
          && $args->{chomp}
          && !$args->{count} )
      {
          return split /(?:\x{0d}?\x{0a}|\x{0d})/, slurp_utf8($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err} = \$err unless defined $args->{err};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst'" );
  }
  
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.$)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  
  sub realpath {
      my $self = shift;
      require Cwd;
      my $realpath = eval {
          local $SIG{__WARN__} = sub { }; # (sigh) pure-perl CWD can carp
          Cwd::realpath( $self->[PATH] );
      };
      $self->_throw("resolving realpath") unless defined $realpath and length $realpath;
      return path($realpath);
  }
  
  
  # Easy to get wrong, so wash it through File::Spec (sigh)
  sub relative { path( File::Spec->abs2rel( $_[0]->[PATH], $_[1] ) ) }
  
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink $self->[PATH] || $self->_throw('unlink');
  }
  
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err}  = \$err unless defined $args->{err};
      $args->{safe} = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $temp = path( $self->[PATH] . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      # spewing need to follow the link
      # and replace the destination instead
      my $resolved_path = $self->[PATH];
      $resolved_path = readlink $resolved_path while -l $resolved_path;
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          spew( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  
  sub stringify { $_[0]->[PATH] }
  
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|$)};
      }
  }
  
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      $epoch = defined($epoch) ? $epoch : time();
      utime $epoch, $epoch, $self->[PATH]
        or $self->_throw("utime ($epoch)");
      return $self;
  }
  
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.052
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    $head = $file->lines( {count => 1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module attempts to provide a small, fast utility for working with
  file paths.  It is friendlier to use than L<File::Spec> and provides
  easy access to functions from several other core file handling modules.
  
  It doesn't attempt to be as full-featured as L<IO::All> or L<Path::Class>,
  nor does it try to work for anything except Unix-like and Win32 platforms.
  Even then, it might break if you try something particularly obscure or
  tortuous.  (Quick!  What does this mean: C<< ///../../..//./././a//b/.././c/././ >>?
  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode without CRLF translation.  Installing L<Unicode::UTF8> 0.58 or later
  will speed up several of them and is highly recommended.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  Unless an argument is given, the current directory is used as the
  absolute base path.  The argument must be absolute or you won't get an absolute
  result.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<binmode()> on the handle used for writing.
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  append will be done instead on the data encoded with C<Unicode::UTF8>.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename; # bar.txt
  
  Returns the file portion or last directory portion of a path.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt$/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies a file using L<File::Copy>'s C<copy> function.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  
  Returns a hexadecimal digest for a file.  Any arguments are passed to the
  constructor for L<Digest> to select an algorithm.  If no arguments are given,
  the default is SHA-256.
  
  =head2 dirname
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory name portion of the path.  This is roughly
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually has the trailing slash. If that's not desired, stringify directories
  or call C<parent> on files.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }
      if ( path("/tmp")->is_file ) { ... }
      if ( path("/tmp")->is_dir ) { ... }
  
  Just like C<-e>, C<-f> or C<-d>.  This means the file or directory actually has to
  exist on the filesystem.  Until then, it's just a path.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", "<<", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked with C<LOCK_SH>.  When using
  C<locked>, ">" or "+>" modes will delay truncation until after the lock is
  acquired.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.  If C<binmode>
  is provided, it will be set on the handle prior to reading.  If C<count> is
  provided, up to that many lines will be returned. If C<chomp> is set, any
  end-of-line character sequences (C<CR>, C<CRLF>, or C<LF>) will be removed
  from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of
  C<:raw:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Just like C<rename>.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the path can't be resolved (e.g. if it includes directories that don't exist),
  an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a relative path name.
  Given the trickiness of this, it's a thin wrapper around
  C<< File::Spec->abs2rel() >>.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  B<Note: as of 0.012, remove only works on files>.
  
  This is just like C<unlink>, except if the path does not exist, it returns
  false rather than throwing an exception.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference may be
  used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  slurp will be done instead and the result decoded with C<Unicode::UTF8>.
  This is just as strict and is roughly an order of magnitude faster than
  using C<:encoding(UTF-8)>.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>.
  If L<Unicode::UTF8> 0.58+ is installed, a raw spew will be done instead on
  the data encoded with C<Unicode::UTF8>.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with spew:
  
      path("foo.txt")->touch->spew( $content );
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_BSD IS_WIN32
  
  =head1 EXCEPTION HANDLING
  
  Failures will be thrown as exceptions in the class C<Path::Tiny::Error>.
  
  The object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op>  a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file>  the file or directory relating to the error
  
  =item *
  
  C<err>  hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg>  a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 CAVEATS
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  Path::Tiny has some heuristics to detect this
  and will warn once and let you continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  Consider L<PerlIO::utf8_strict> for a faster L<PerlIO> layer alternative to
  C<:encoding(UTF-8)>, though it does not appear to be as fast as the
  C<Unicode::UTF8> approach.
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
   - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Reply/Plugin/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REPLY_PLUGIN_TYPETINY';
  package Reply::Plugin::TypeTiny;
  
  use strict;
  use warnings;
  
  BEGIN {
  	$Reply::Plugin::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Reply::Plugin::TypeTiny::VERSION   = '0.038';
  };
  
  require Reply::Plugin;
  our @ISA = 'Reply::Plugin';
  
  use Scalar::Util qw(blessed);
  use Term::ANSIColor;
  
  sub mangle_error {
  	my $self  = shift;
  	my ($err) = @_;
  	
  	if (blessed $err and $err->isa("Error::TypeTiny::Assertion"))
  	{
  		my $explain = $err->explain;
  		if ($explain)
  		{
  			print color("cyan");
  			print "Error::TypeTiny::Assertion explain:\n";
  			$self->_explanation($explain, "");
  			local $| = 1;
  			print "\n";
  			print color("reset");
  		}
  	}
  	
  	return @_;
  }
  
  sub _explanation
  {
  	my $self = shift;
  	my ($ex, $indent)  = @_;
  	
  	for my $line (@$ex)
  	{
  		if (ref($line) eq q(ARRAY))
  		{
  			print "$indent * Explain:\n";
  			$self->_explanation($line, "$indent   ");
  		}
  		else
  		{
  			print "$indent * $line\n";
  		}
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Reply::Plugin::TypeTiny - improved type constraint exceptions in Reply
  
  =head1 STATUS
  
  This module is not covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is a small plugin to improve error messages in L<Reply>.
  Not massively tested.
  
  =begin trustme
  
  =item mangle_error
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>, L<Reply>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
REPLY_PLUGIN_TYPETINY

$fatpacked{"SHARYANTO/String/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SHARYANTO_STRING_UTIL';
  package SHARYANTO::String::Util;
  
  use 5.010001;
  use strict;
  use warnings;
  
  our $VERSION = '0.26'; # VERSION
  
  use Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(
                         ltrim
                         rtrim
                         trim
                         ltrim_lines
                         rtrim_lines
                         trim_lines
                         trim_blank_lines
                         ellipsis
                         indent
                         linenum
                         pad
                         qqquote
                 );
  
  sub ltrim {
      my $str = shift;
      $str =~ s/\A\s+//s;
      $str;
  }
  
  sub rtrim {
      my $str = shift;
      $str =~ s/\s+\z//s;
      $str;
  }
  
  sub trim {
      my $str = shift;
      $str =~ s/\A\s+//s;
      $str =~ s/\s+\z//s;
      $str;
  }
  
  sub ltrim_lines {
      my $str = shift;
      $str =~ s/^[ \t]+//mg; # XXX other unicode non-newline spaces
      $str;
  }
  
  sub rtrim_lines {
      my $str = shift;
      $str =~ s/[ \t]+$//mg;
      $str;
  }
  
  sub trim_lines {
      my $str = shift;
      $str =~ s/^[ \t]+//mg;
      $str =~ s/[ \t]+$//mg;
      $str;
  }
  
  sub trim_blank_lines {
      local $_ = shift;
      return $_ unless defined;
      s/\A(?:\n\s*)+//;
      s/(?:\n\s*){2,}\z/\n/;
      $_;
  }
  
  sub ellipsis {
      my ($str, $maxlen, $ellipsis) = @_;
      $maxlen   //= 80;
      $ellipsis //= "...";
  
      if (length($str) <= $maxlen) {
          return $str;
      } else {
          return substr($str, 0, $maxlen-length($ellipsis)) . $ellipsis;
      }
  }
  
  sub indent {
      my ($indent, $str, $opts) = @_;
      $opts //= {};
  
      if ($opts->{indent_blank_lines} // 1) {
          $str =~ s/^/$indent/mg;
      } else {
          $str =~ s/^([^\r\n]*\S[^\r\n]*)/$indent$1/mg;
      }
      $str;
  }
  
  sub linenum {
      my ($str, $opts) = @_;
      $opts //= {};
      $opts->{width}      //= 4;
      $opts->{zeropad}    //= 0;
      $opts->{skip_empty} //= 1;
  
      my $i = 0;
      $str =~ s/^(([\t ]*\S)?.*)/
          sprintf(join("",
                       "%",
                       ($opts->{zeropad} && !($opts->{skip_empty}
                                                  && !defined($2)) ? "0" : ""),
                       $opts->{width}, "s",
                       "|%s"),
                  ++$i && $opts->{skip_empty} && !defined($2) ? "" : $i,
                  $1)/meg;
  
      $str;
  }
  
  sub pad {
      my ($text, $width, $which, $padchar, $is_trunc) = @_;
      if ($which) {
          $which = substr($which, 0, 1);
      } else {
          $which = "r";
      }
      $padchar //= " ";
  
      my $w = length($text);
      if ($is_trunc && $w > $width) {
          $text = substr($text, 0, $width, 1);
      } else {
          if ($which eq 'l') {
              $text = ($padchar x ($width-$w)) . $text;
          } elsif ($which eq 'c') {
              my $n = int(($width-$w)/2);
              $text = ($padchar x $n) . $text . ($padchar x ($width-$w-$n));
          } else {
              $text .= ($padchar x ($width-$w));
          }
      }
      $text;
  }
  
  # BEGIN COPY PASTE FROM Data::Dump
  my %esc = (
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  # put a string value in double quotes
  sub qqquote {
    local($_) = $_[0];
    # If there are many '"' we might want to use qq() instead
    s/([\\\"\@\$])/\\$1/g;
    return qq("$_") unless /[^\040-\176]/;  # fast exit
  
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    # no need for 3 digits in escape for these
    s/([\0-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
    s/([\0-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
    s/([^\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
    return qq("$_");
  }
  # END COPY PASTE FROM Data::Dump
  
  1;
  # ABSTRACT: String utilities
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  SHARYANTO::String::Util - String utilities
  
  =head1 DESCRIPTION
  
  =head1 FUNCTIONS
  
  =head2 ltrim($str) => STR
  
  Trim whitespaces (including newlines) at the beginning of string. Equivalent to:
  
   $str =~ s/\A\s+//s;
  
  =head2 ltrim_lines($str) => STR
  
  Trim whitespaces (not including newlines) at the beginning of each line of
  string. Equivalent to:
  
   $str =~ s/^\s+//mg;
  
  =head2 rtrim($str) => STR
  
  Trim whitespaces (including newlines) at the end of string. Equivalent to:
  
   $str =~ s/[ \t]+\z//s;
  
  =head2 rtrim_lines($str) => STR
  
  Trim whitespaces (not including newlines) at the end of each line of
  string. Equivalent to:
  
   $str =~ s/[ \t]+$//mg;
  
  =head2 trim($str) => STR
  
  ltrim + rtrim.
  
  =head2 trim_lines($str) => STR
  
  ltrim_lines + rtrim_lines.
  
  =head2 trim_blank_lines($str) => STR
  
  Trim blank lines at the beginning and the end. Won't trim blank lines in the
  middle. Blank lines include lines with only whitespaces in them.
  
  =head2 ellipsis($str[, $maxlen, $ellipsis]) => STR
  
  Return $str unmodified if $str's length is less than $maxlen (default 80).
  Otherwise cut $str to ($maxlen - length($ellipsis)) and append $ellipsis
  (default '...') at the end.
  
  =head2 indent($indent, $str, \%opts) => STR
  
  Indent every line in $str with $indent. Example:
  
   indent('  ', "one\ntwo\nthree") # "  one\n  two\n  three"
  
  %opts is optional. Known options:
  
  =over 4
  
  =item * indent_blank_lines => BOOL (default 1)
  
  If set to false, does not indent blank lines (i.e., lines containing only zero
  or more whitespaces).
  
  =back
  
  =head2 linenum($str, \%opts) => STR
  
  Add line numbers. For example:
  
       1|line1
       2|line2
        |
       4|line4
  
  Known options:
  
  =over 4
  
  =item * width => INT (default: 4)
  
  =item * zeropad => BOOL (default: 0)
  
  If turned on, will output something like:
  
    0001|line1
    0002|line2
        |
    0004|line4
  
  =item * skip_empty => BOOL (default: 1)
  
  If set to false, keep printing line number even if line is empty:
  
       1|line1
       2|line2
       3|
       4|line4
  
  =back
  
  =head2 pad($text, $width[, $which[, $padchar[, $truncate]]]) => STR
  
  Return C<$text> padded with C<$padchar> to C<$width> columns. C<$which> is
  either "r" or "right" for padding on the right (the default if not specified),
  "l" or "left" for padding on the right, or "c" or "center" or "centre" for
  left+right padding to center the text.
  
  C<$padchar> is whitespace if not specified. It should be string having the width
  of 1 column.
  
  =head2 qqquote($str) => STR
  
  Quote or encode C<$str> to the Perl double quote (C<qq>) literal representation
  of the string. Example:
  
   say qqquote("a");        # => "a"
   say qqquote("a\n");      # => "a\n"
   say qqquote('"');        # => "\""
   say qqquote('$foo');     # => "\$foo"
  
  This code is taken from C<quote()> in L<Data::Dump>. Maybe I didn't look more
  closely, but I couldn't a module that provides a function to do something like
  this. L<String::Escape>, for example, provides C<qqbackslash> but it does not
  escape C<$>.
  
  
  None are exported by default, but they are exportable.
  
  =head1 SEE ALSO
  
  L<SHARYANTO>
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/SHARYANTO-String-Util>.
  
  =head1 SOURCE
  
  Source repository is at L<HASH(0x353ed90)>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website
  https://rt.cpan.org/Public/Dist/Display.html?Name=SHARYANTO-String-Util
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SHARYANTO_STRING_UTIL

$fatpacked{"Sort/Naturally.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SORT_NATURALLY';
  
  require 5;
  package Sort::Naturally;  # Time-stamp: "2004-12-29 18:30:03 AST"
  $VERSION = '1.03';
  @EXPORT = ('nsort', 'ncmp');
  require Exporter;
  @ISA = ('Exporter');
  
  use strict;
  use locale;
  use integer;
  
  #-----------------------------------------------------------------------------
  # constants:
  BEGIN { *DEBUG = sub () {0} unless defined &DEBUG }
  
  use Config ();
  BEGIN {
    # Make a constant such that if a whole-number string is that long
    #  or shorter, we KNOW it's treatable as an integer
    no integer;
    my $x = length(256 ** $Config::Config{'intsize'} / 2) - 1;
    die "Crazy intsize: <$Config::Config{'intsize'}>" if $x < 4;
    eval 'sub MAX_INT_SIZE () {' . $x . '}';
    die $@ if $@;
    print "intsize $Config::Config{'intsize'} => MAX_INT_SIZE $x\n" if DEBUG;
  }
  
  sub X_FIRST () {-1}
  sub Y_FIRST () { 1}
  
  my @ORD = ('same', 'swap', 'asis');
  
  #-----------------------------------------------------------------------------
  # For lack of a preprocessor:
  
  my($code, $guts);
  $guts = <<'EOGUTS';  # This is the guts of both ncmp and nsort:
  
      if($x eq $y) {
        # trap this expensive case first, and then fall thru to tiebreaker
        $rv = 0;
  
      # Convoluted hack to get numerics to sort first, at string start:
      } elsif($x =~ m/^\d/s) {
        if($y =~ m/^\d/s) {
          $rv = 0;    # fall thru to normal comparison for the two numbers
        } else {
          $rv = X_FIRST;
          DEBUG > 1 and print "Numeric-initial $x trumps letter-initial $y\n";
        }
      } elsif($y =~ m/^\d/s) {
        $rv = Y_FIRST;
        DEBUG > 1 and print "Numeric-initial $y trumps letter-initial $x\n";
      } else {
        $rv = 0;
      }
  
      unless($rv) {
        # Normal case:
        $rv = 0;
        DEBUG and print "<$x> and <$y> compared...\n";
  
       Consideration:
        while(length $x and length $y) {
  
          DEBUG > 2 and print " <$x> and <$y>...\n";
  
          # First, non-numeric comparison:
          $x2 = ($x =~ m/^(\D+)/s) ? length($1) : 0;
          $y2 = ($y =~ m/^(\D+)/s) ? length($1) : 0;
          # Now make x2 the min length of the two:
          $x2 = $y2 if $x2 > $y2;
          if($x2) {
            DEBUG > 1 and printf " <%s> and <%s> lexically for length $x2...\n",
              substr($x,0,$x2), substr($y,0,$x2);
            do {
             my $i = substr($x,0,$x2);
             my $j = substr($y,0,$x2);
             my $sv = $i cmp $j;
             print "SCREAM! on <$i><$j> -- $sv != $rv \n" unless $rv == $sv;
             last;
            }
  
  
             if $rv =
             # The ''. things here force a copy that seems to work around a
             #  mysterious intermittent bug that 'use locale' provokes in
             #  many versions of Perl.
                     $cmp
                     ? $cmp->(substr($x,0,$x2) . '',
                              substr($y,0,$x2) . '',
                             )
                     :
                     scalar(( substr($x,0,$x2) . '' ) cmp
                            ( substr($y,0,$x2) . '' )
                            )
            ;
            # otherwise trim and keep going:
            substr($x,0,$x2) = '';
            substr($y,0,$x2) = '';
          }
  
          # Now numeric:
          #  (actually just using $x2 and $y2 as scratch)
  
          if( $x =~ s/^(\d+)//s ) {
            $x2 = $1;
            if( $y =~ s/^(\d+)//s ) {
              # We have two numbers here.
              DEBUG > 1 and print " <$x2> and <$1> numerically\n";
              if(length($x2) < MAX_INT_SIZE and length($1) < MAX_INT_SIZE) {
                # small numbers: we can compare happily
                last if $rv = $x2 <=> $1;
              } else {
                # ARBITRARILY large integers!
  
                # This saves on loss of precision that could happen
                #  with actual stringification.
                # Also, I sense that very large numbers aren't too
                #  terribly common in sort data.
  
                # trim leading 0's:
                ($y2 = $1) =~ s/^0+//s;
                $x2 =~ s/^0+//s;
                print "   Treating $x2 and $y2 as bigint\n" if DEBUG;
  
                no locale; # we want the dumb cmp back.
                last if $rv = (
                   # works only for non-negative whole numbers:
                   length($x2) <=> length($y2)
                     # the longer the numeral, the larger the value
                   or $x2 cmp $y2
                     # between equals, compare lexically!!  amazing but true.
                );
              }
            } else {
              # X is numeric but Y isn't
              $rv = Y_FIRST;
              last;
            }
          } elsif( $y =~ s/^\d+//s ) {  # we don't need to capture the substring
            $rv = X_FIRST;
            last;
          }
           # else one of them is 0-length.
  
         # end-while
        }
      }
  EOGUTS
  
  sub maker {
    my $code = $_[0];
    $code =~ s/~COMPARATOR~/$guts/g || die "Can't find ~COMPARATOR~";
    eval $code;
    die $@ if $@;
  }
  
  ##############################################################################
  
  maker(<<'EONSORT');
  sub nsort {
    # get options:
    my($cmp, $lc);
    ($cmp,$lc) = @{shift @_} if @_ and ref($_[0]) eq 'ARRAY';
  
    return @_ unless @_ > 1 or wantarray; # be clever
  
    my($x, $x2, $y, $y2, $rv);  # scratch vars
  
    # We use a Schwartzian xform to memoize the lc'ing and \W-removal
  
    map $_->[0],
    sort {
      if($a->[0] eq $b->[0]) { 0 }   # trap this expensive case
      else {
  
      $x = $a->[1];
      $y = $b->[1];
  
  ~COMPARATOR~
  
      # Tiebreakers...
      DEBUG > 1 and print " -<${$a}[0]> cmp <${$b}[0]> is $rv ($ORD[$rv])\n";
      $rv ||= (length($x) <=> length($y))  # shorter is always first
          ||  ($cmp and $cmp->($x,$y) || $cmp->($a->[0], $b->[0]))
          ||  ($x      cmp $y     )
          ||  ($a->[0] cmp $b->[0])
      ;
  
      DEBUG > 1 and print "  <${$a}[0]> cmp <${$b}[0]> is $rv ($ORD[$rv])\n";
      $rv;
    }}
  
    map {;
      $x = $lc ? $lc->($_) : lc($_); # x as scratch
      $x =~ s/\W+//s;
      [$_, $x];
    }
    @_
  }
  EONSORT
  
  #-----------------------------------------------------------------------------
  maker(<<'EONCMP');
  sub ncmp {
    # The guts are basically the same as above...
  
    # get options:
    my($cmp, $lc);
    ($cmp,$lc) = @{shift @_} if @_ and ref($_[0]) eq 'ARRAY';
  
    if(@_ == 0) {
      @_ = ($a, $b); # bit of a hack!
      DEBUG > 1 and print "Hacking in <$a><$b>\n";
    } elsif(@_ != 2) {
      require Carp;
      Carp::croak("Not enough options to ncmp!");
    }
    my($a,$b) = @_;
    my($x, $x2, $y, $y2, $rv);  # scratch vars
  
    DEBUG > 1 and print "ncmp args <$a><$b>\n";
    if($a eq $b) { # trap this expensive case
      0;
    } else {
      $x = ($lc ? $lc->($a) : lc($a));
      $x =~ s/\W+//s;
      $y = ($lc ? $lc->($b) : lc($b));
      $y =~ s/\W+//s;
  
  ~COMPARATOR~
  
  
      # Tiebreakers...
      DEBUG > 1 and print " -<$a> cmp <$b> is $rv ($ORD[$rv])\n";
      $rv ||= (length($x) <=> length($y))  # shorter is always first
          ||  ($cmp and $cmp->($x,$y) || $cmp->($a,$b))
          ||  ($x cmp $y)
          ||  ($a cmp $b)
      ;
  
      DEBUG > 1 and print "  <$a> cmp <$b> is $rv\n";
      $rv;
    }
  }
  EONCMP
  
  # clean up:
  undef $guts;
  undef &maker;
  
  #-----------------------------------------------------------------------------
  1;
  
  ############### END OF MAIN SOURCE ###########################################
  __END__
  
  =head1 NAME
  
  Sort::Naturally -- sort lexically, but sort numeral parts numerically
  
  =head1 SYNOPSIS
  
    @them = nsort(qw(
     foo12a foo12z foo13a foo 14 9x foo12 fooa foolio Foolio Foo12a
    ));
    print join(' ', @them), "\n";
  
  Prints:
  
    9x 14 foo fooa foolio Foolio foo12 foo12a Foo12a foo12z foo13a
  
  (Or "foo12a" + "Foo12a" and "foolio" + "Foolio" and might be
  switched, depending on your locale.)
  
  =head1 DESCRIPTION
  
  This module exports two functions, C<nsort> and C<ncmp>; they are used
  in implementing my idea of a "natural sorting" algorithm.  Under natural
  sorting, numeric substrings are compared numerically, and other
  word-characters are compared lexically.
  
  This is the way I define natural sorting:
  
  =over
  
  =item *
  
  Non-numeric word-character substrings are sorted lexically,
  case-insensitively: "Foo" comes between "fish" and "fowl".
  
  =item *
  
  Numeric substrings are sorted numerically:
  "100" comes after "20", not before.
  
  =item *
  
  \W substrings (neither words-characters nor digits) are I<ignored>.
  
  =item *
  
  Our use of \w, \d, \D, and \W is locale-sensitive:  Sort::Naturally
  uses a C<use locale> statement.
  
  =item *
  
  When comparing two strings, where a numeric substring in one
  place is I<not> up against a numeric substring in another,
  the non-numeric always comes first.  This is fudged by
  reading pretending that the lack of a number substring has
  the value -1, like so:
  
    foo       =>  "foo",  -1
    foobar    =>  "foo",  -1,  "bar"
    foo13     =>  "foo",  13,
    foo13xyz  =>  "foo",  13,  "xyz"
  
  That's so that "foo" will come before "foo13", which will come
  before "foobar".
  
  =item *
  
  The start of a string is exceptional: leading non-\W (non-word,
  non-digit)
  components are are ignored, and numbers come I<before> letters.
  
  =item *
  
  I define "numeric substring" just as sequences matching m/\d+/ --
  scientific notation, commas, decimals, etc., are not seen.  If
  your data has thousands separators in numbers
  ("20,000 Leagues Under The Sea" or "20.000 lieues sous les mers"),
  consider stripping them before feeding them to C<nsort> or
  C<ncmp>.
  
  =back
  
  =head2 The nsort function
  
  This function takes a list of strings, and returns a copy of the list,
  sorted.
  
  This is what most people will want to use:
  
    @stuff = nsort(...list...);
  
  When nsort needs to compare non-numeric substrings, it
  uses Perl's C<lc> function in scope of a <use locale>.
  And when nsort needs to lowercase things, it uses Perl's
  C<lc> function in scope of a <use locale>.  If you want nsort
  to use other functions instead, you can specify them in
  an arrayref as the first argument to nsort:
  
    @stuff = nsort( [
                      \&string_comparator,   # optional
                      \&lowercaser_function  # optional
                    ],
                    ...list...
                  );
  
  If you want to specify a string comparator but no lowercaser,
  then the options list is C<[\&comparator, '']> or
  C<[\&comparator]>.  If you want to specify no string comparator
  but a lowercaser, then the options list is
  C<['', \&lowercaser]>.
  
  Any comparator you specify is called as
  C<$comparator-E<gt>($left, $right)>,
  and, like a normal Perl C<cmp> replacement, must return
  -1, 0, or 1 depending on whether the left argument is stringwise
  less than, equal to, or greater than the right argument.
  
  Any lowercaser function you specify is called as
  C<$lowercased = $lowercaser-E<gt>($original)>.  The routine
  must not modify its C<$_[0]>.
  
  =head2 The ncmp function
  
  Often, when sorting non-string values like this:
  
     @objects_sorted = sort { $a->tag cmp $b->tag } @objects;
  
  ...or even in a Schwartzian transform, like this:
  
     @strings =
       map $_->[0]
       sort { $a->[1] cmp $b->[1] }
       map { [$_, make_a_sort_key_from($_) ]
       @_
     ;
  
  ...you wight want something that replaces not C<sort>, but C<cmp>.
  That's what Sort::Naturally's C<ncmp> function is for.  Call it with
  the syntax C<ncmp($left,$right)> instead of C<$left cmp $right>,
  but otherwise it's a fine replacement:
  
     @objects_sorted = sort { ncmp($a->tag,$b->tag) } @objects;
  
     @strings =
       map $_->[0]
       sort { ncmp($a->[1], $b->[1]) }
       map { [$_, make_a_sort_key_from($_) ]
       @_
     ;
  
  Just as with C<nsort> can take different a string-comparator
  and/or lowercaser, you can do the same with C<ncmp>, by passing
  an arrayref as the first argument:
  
    ncmp( [
            \&string_comparator,   # optional
            \&lowercaser_function  # optional
          ],
          $left, $right
        )
  
  You might get string comparators from L<Sort::ArbBiLex|Sort::ArbBiLex>.
  
  =head1 NOTES
  
  =over
  
  =item *
  
  This module is not a substitute for
  L<Sort::Versions|Sort::Versions>!  If
  you just need proper version sorting, use I<that!>
  
  =item *
  
  If you need something that works I<sort of> like this module's
  functions, but not quite the same, consider scouting thru this
  module's source code, and adapting what you see.  Besides
  the functions that actually compile in this module, after the POD,
  there's several alternate attempts of mine at natural sorting
  routines, which are not compiled as part of the module, but which you
  might find useful.  They should all be I<working> implementations of
  slightly different algorithms
  (all of them based on Martin Pool's C<nsort>) which I eventually
  discarded in favor of my algorithm.  If you are having to
  naturally-sort I<very large> data sets, and sorting is getting
  ridiculously slow, you might consider trying one of those
  discarded functions -- I have a feeling they might be faster on
  large data sets.  Benchmark them on your data and see.  (Unless
  you I<need> the speed, don't bother.  Hint: substitute C<sort>
  for C<nsort> in your code, and unless your program speeds up
  drastically, it's not the sorting that's slowing things down.
  But if it I<is> C<nsort> that's slowing things down, consider
  just:
  
        if(@set >= SOME_VERY_BIG_NUMBER) {
          no locale; # vroom vroom
          @sorted = sort(@set);  # feh, good enough
        } elsif(@set >= SOME_BIG_NUMBER) {
          use locale;
          @sorted = sort(@set);  # feh, good enough
        } else {
          # but keep it pretty for normal cases
          @sorted = nsort(@set);
        }
  
  =item *
  
  If you do adapt the routines in this module, email me; I'd
  just be interested in hearing about it.
  
  =item *
  
  Thanks to the EFNet #perl people for encouraging this module,
  especially magister and a-mused.
  
  =back
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  Copyright 2001, Sean M. Burke C<sburke@cpan.org>, all rights
  reserved.  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Sean M. Burke C<sburke@cpan.org>
  
  =cut
  
  ############   END OF DOCS   ############
  
  ############################################################################
  ############################################################################
  
  ############ BEGIN OLD STUFF ############
  
  # We can't have "use integer;", or else (5 <=> 5.1) comes out "0" !
  
  #-----------------------------------------------------------------------------
  sub nsort {
    my($cmp, $lc);
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      if($x =~ m/^[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee](?:[+-]?\d+))?\z/s) {
        # It's entirely purely numeric, so treat it specially:
        push @bit, '', $x;
      } else {
        # Consume the string.
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          push @bit, ($x =~ s/^(\d+)//s) ?    $1  :  0;
        }
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      # End result: [original bit         , (text, number), (text, number), ...]
      # Minimally:  [0-length original bit,]
      # Examples:
      #    ['10'         => ''   ,  10,              ]
      #    ['fo900'      => 'fo' , 900,              ]
      #    ['foo10'      => 'foo',  10,              ]
      #    ['foo9.pl'    => 'foo',   9,   , '.pl', 0 ]
      #    ['foo32.pl'   => 'foo',  32,   , '.pl', 0 ]
      #    ['foo325.pl'  => 'foo', 325,   , '.pl', 0 ]
      #  Yes, always an ODD number of elements.
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Same as before, except without the pure-number trap.
  
  sub nsorts {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      while(length $x) {
        push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
        push @bit, ($x =~ s/^(\d+)//s) ?    $1  :  0;
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      # End result: [original bit         , (text, number), (text, number), ...]
      # Minimally:  [0-length original bit,]
      # Examples:
      #    ['10'         => ''   ,  10,              ]
      #    ['fo900'      => 'fo' , 900,              ]
      #    ['foo10'      => 'foo',  10,              ]
      #    ['foo9.pl'    => 'foo',   9,   , '.pl', 0 ]
      #    ['foo32.pl'   => 'foo',  32,   , '.pl', 0 ]
      #    ['foo325.pl'  => 'foo', 325,   , '.pl', 0 ]
      #  Yes, always an ODD number of elements.
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Same as before, except for the sort-key-making
  
  sub nsort0 {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      if($x =~ m/^[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee](?:[+-]?\d+))?\z/s) {
        # It's entirely purely numeric, so treat it specially:
        push @bit, '', $x;
      } else {
        # Consume the string.
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          # Secret sauce:
          if($x =~ s/^(\d+)//s) {
            if(substr($1,0,1) eq '0' and $1 != 0) {
              push @bit, $1 / (10 ** length($1));
            } else {
              push @bit, $1;
            }
          } else {
            push @bit, 0;
          }
        }
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Like nsort0, but WITHOUT pure number handling, and WITH special treatment
  # of pulling off extensions and version numbers.
  
  sub nsortf {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 3;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a     <=> @$b    ) || ($a->[1] cmp $b->[1])
         || ($a->[2] <=> $b->[2]) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use the
        #  lc'd extension, otherwise the verison, otherwise use
        #  the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ( ($x = defined($_) ? $_ : ''), '',0 );
  
      {
        # Consume the string.
  
        # First, pull off any VAX-style version
        $bit[2] = $1 if $x =~ s/;(\d+)$//;
  
        # Then pull off any apparent extension
        if( $x !~ m/^\.+$/s and     # don't mangle ".", "..", or "..."
            $x =~ s/(\.[^\.\;]*)$//sg
            # We could try to avoid catching all-digit extensions,
            #  but I think that's getting /too/ clever.
        ) {
          $i = $1;
          if($x =~ m<[^\\\://]$>s) {
            # We didn't take the whole basename.
            $bit[1] = lc $i;
            DEBUG and print "Consuming extension \"$1\"\n";
          } else {
            # We DID take the whole basename.  Fix it.
            $x = $1;  # Repair it.
          }
        }
  
        push @bit, '', -1   if $x =~ m/^\./s;
         # A hack to make .-initial filenames sort first, regardless of locale.
         # And -1 is always a sort-firster, since in the code below, there's
         # no allowance for filenames containing negative numbers: -1.dat
         # will be read as string '-' followed by number 1.
  
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          # Secret sauce:
          if($x =~ s/^(\d+)//s) {
            if(substr($1,0,1) eq '0' and $1 != 0) {
              push @bit, $1 / (10 ** length($1));
            } else {
              push @bit, $1;
            }
          } else {
            push @bit, 0;
          }
        }
      }
  
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      \@bit;
    }
    @_;
  }
  
  # yowza yowza yowza.
  
SORT_NATURALLY

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_Utils;
  use Scalar::Util qw(weaken);
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    weaken($DEFERRED{$made} = $DEFERRED{$deferred});
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    $DEFERRED{$deferred||''};
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_info;
    my $deferred = sub {
      $undeferred ||= undefer_sub($deferred_info->[3]);
      goto &$undeferred;
    };
    $deferred_info = [ $target, $maker, \$undeferred, $deferred ];
    weaken($DEFERRED{$deferred} = $deferred_info);
    _install_coderef($target => $deferred) if defined $target;
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map { defined $_ ? ($_->[3] => $_) : () } values %DEFERRED;
    weaken($_) for values %DEFERRED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all defered subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  {
    $Sub::Exporter::VERSION = '0.987';
  }
  # ABSTRACT: a sophisticated exporter for custom-built routines
  
  use Carp ();
  use Data::OptList 0.100 ();
  use Params::Util 0.14 (); # _CODELIKE
  use Sub::Install 0.92 ();
  
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  
  
  "jn8:32"; # <-- magic true value
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.987
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The package with the generator for that would look something like this:
  
    package Data::Analyze;
    use Sub::Exporter -setup => {
      exports => [
        analyze => \&build_analyzer,
      ],
    };
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertently imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function3);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the importer to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as an exercise for the
  reader.
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and helped me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001011';
  
  use Carp ();
  use List::Util ();
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if (List::Util::first { ref || !m/ \A [:-]? \w+ \z /xm } @args) {
           Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif (defined(my $num = List::Util::first { !ref and m/^\d/ } @args)) {
           die "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ($setup eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              Carp::croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              Carp::croak $too_complicated if List::Util::first { ref } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 Carp::croak $too_complicated if List::Util::first { / \A - (?! all \b ) /x || ref } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              Carp::croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        Carp::croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 AUTHOR
  
  frew - Arthur Axel Schmidt (cpan:FREW) <frioux+cpan@gmail.com>
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Sub::Exporter::Progressive L</AUTHOR> and
  L</CONTRIBUTORS> as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  package Sub::Exporter::Util;
  {
    $Sub::Exporter::Util::VERSION = '0.987';
  }
  # ABSTRACT: utilities to make Sub::Exporter easier
  
  use Data::OptList ();
  use Params::Util ();
  
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.987
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilities may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain(
        new => gather_data => analyze => [ detail => 100 ] => 'results'
      ),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Spliner->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multiple exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  {
    $Sub::Install::VERSION = '0.927';
  }
  # ABSTRACT: install subroutines into packages easily
  
  use Carp;
  use Scalar::Util ();
  
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine \S+ redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ \S+\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.927
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  use strictures 1;
  
  sub _clean_eval { eval $_[0] }
  
  use Sub::Defer;
  use B 'perlstring';
  use Scalar::Util qw(weaken);
  use base qw(Exporter);
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub);
  
  our %QUOTED;
  
  our %WEAK_REFS;
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    my $assign = '';
    if (my ($code_args) = $code =~ /^\s*my\s*\(([^)]+)\)\s*=\s*\@_;$/s) {
      if ($code_args ne $args) {
        $assign = 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $assign = ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$assign.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my ($package, $hints, $bitmask, $hintshash) = (caller(0))[0,8,9,10];
    my $context
      ="package $package;\n"
      ."BEGIN {\n"
      ."  \$^H = ".B::perlstring($hints).";\n"
      ."  \${^WARNING_BITS} = ".B::perlstring($bitmask).";\n"
      ."  \%^H = (\n"
      . join('', map
       "    ".B::perlstring($_)." => ".B::perlstring($hintshash->{$_}).",",
        keys %$hintshash)
      ."  );\n"
      ."}\n";
    $code = "$context$code";
    my $quoted_info;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      unquote_sub($quoted_info->[4]);
    };
    $quoted_info = [ $name, $code, $captures, undef, $deferred ];
    weaken($QUOTED{$deferred} = $quoted_info);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    $QUOTED{$sub||''};
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    unless ($QUOTED{$sub}[3]) {
      my ($name, $code, $captures) = @{$QUOTED{$sub}};
  
      my $make_sub = "{\n";
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_QUOTED'} = \$QUOTED{$sub};
      $make_sub .= capture_unroll("\$_[1]", \%captures, 2);
  
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$_QUOTED->[3] = sub {\n"
      );
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$_QUOTED->[3] = \\&${name}\n";
      }
      $make_sub .= "}\n1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{$name} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          die "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
      }
    }
    $QUOTED{$sub}[3];
  }
  
  sub CLONE {
    %QUOTED = map { defined $_ ? ($_->[4] => $_) : () } values %QUOTED;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   };
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few caveats
  apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_QUOTE

$fatpacked{"Term/ReadLine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_READLINE';
  =head1 NAME
  
  Term::ReadLine - Perl interface to various C<readline> packages.
  If no real package is found, substitutes stubs instead of basic functions.
  
  =head1 SYNOPSIS
  
    use Term::ReadLine;
    my $term = Term::ReadLine->new('Simple Perl calc');
    my $prompt = "Enter your arithmetic expression: ";
    my $OUT = $term->OUT || \*STDOUT;
    while ( defined ($_ = $term->readline($prompt)) ) {
      my $res = eval($_);
      warn $@ if $@;
      print $OUT $res, "\n" unless $@;
      $term->addhistory($_) if /\S/;
    }
  
  =head1 DESCRIPTION
  
  This package is just a front end to some other packages. It's a stub to
  set up a common interface to the various ReadLine implementations found on
  CPAN (under the C<Term::ReadLine::*> namespace).
  
  =head1 Minimal set of supported functions
  
  All the supported functions should be called as methods, i.e., either as 
  
    $term = Term::ReadLine->new('name');
  
  or as 
  
    $term->addhistory('row');
  
  where $term is a return value of Term::ReadLine-E<gt>new().
  
  =over 12
  
  =item C<ReadLine>
  
  returns the actual package that executes the commands. Among possible
  values are C<Term::ReadLine::Gnu>, C<Term::ReadLine::Perl>,
  C<Term::ReadLine::Stub>.
  
  =item C<new>
  
  returns the handle for subsequent calls to following
  functions. Argument is the name of the application. Optionally can be
  followed by two arguments for C<IN> and C<OUT> filehandles. These
  arguments should be globs.
  
  =item C<readline>
  
  gets an input line, I<possibly> with actual C<readline>
  support. Trailing newline is removed. Returns C<undef> on C<EOF>.
  
  =item C<addhistory>
  
  adds the line to the history of input, from where it can be used if
  the actual C<readline> is present.
  
  =item C<IN>, C<OUT>
  
  return the filehandles for input and output or C<undef> if C<readline>
  input and output cannot be used for Perl.
  
  =item C<MinLine>
  
  If argument is specified, it is an advice on minimal size of line to
  be included into history.  C<undef> means do not include anything into
  history. Returns the old value.
  
  =item C<findConsole>
  
  returns an array with two strings that give most appropriate names for
  files for input and output using conventions C<"E<lt>$in">, C<"E<gt>out">.
  
  =item Attribs
  
  returns a reference to a hash which describes internal configuration
  of the package. Names of keys in this hash conform to standard
  conventions with the leading C<rl_> stripped.
  
  =item C<Features>
  
  Returns a reference to a hash with keys being features present in
  current implementation. Several optional features are used in the
  minimal interface: C<appname> should be present if the first argument
  to C<new> is recognized, and C<minline> should be present if
  C<MinLine> method is not dummy.  C<autohistory> should be present if
  lines are put into history automatically (maybe subject to
  C<MinLine>), and C<addhistory> if C<addhistory> method is not dummy.
  
  If C<Features> method reports a feature C<attribs> as present, the
  method C<Attribs> is not dummy.
  
  =back
  
  =head1 Additional supported functions
  
  Actually C<Term::ReadLine> can use some other package, that will
  support a richer set of commands.
  
  All these commands are callable via method interface and have names
  which conform to standard conventions with the leading C<rl_> stripped.
  
  The stub package included with the perl distribution allows some
  additional methods: 
  
  =over 12
  
  =item C<tkRunning>
  
  makes Tk event loop run when waiting for user input (i.e., during
  C<readline> method).
  
  =item C<event_loop>
  
  Registers call-backs to wait for user input (i.e., during C<readline>
  method).  This supersedes tkRunning.
  
  The first call-back registered is the call back for waiting.  It is
  expected that the callback will call the current event loop until
  there is something waiting to get on the input filehandle.  The parameter
  passed in is the return value of the second call back.
  
  The second call-back registered is the call back for registration.  The
  input filehandle (often STDIN, but not necessarily) will be passed in.
  
  For example, with AnyEvent:
  
    $term->event_loop(sub {
      my $data = shift;
      $data->[1] = AE::cv();
      $data->[1]->recv();
    }, sub {
      my $fh = shift;
      my $data = [];
      $data->[0] = AE::io($fh, 0, sub { $data->[1]->send() });
      $data;
    });
  
  The second call-back is optional if the call back is registered prior to
  the call to $term-E<gt>readline.
  
  Deregistration is done in this case by calling event_loop with C<undef>
  as its parameter:
  
      $term->event_loop(undef);
  
  This will cause the data array ref to be removed, allowing normal garbage
  collection to clean it up.  With AnyEvent, that will cause $data->[0] to
  be cleaned up, and AnyEvent will automatically cancel the watcher at that
  time.  If another loop requires more than that to clean up a file watcher,
  that will be up to the caller to handle.
  
  =item C<ornaments>
  
  makes the command line stand out by using termcap data.  The argument
  to C<ornaments> should be 0, 1, or a string of a form
  C<"aa,bb,cc,dd">.  Four components of this string should be names of
  I<terminal capacities>, first two will be issued to make the prompt
  standout, last two to make the input line standout.
  
  =item C<newTTY>
  
  takes two arguments which are input filehandle and output filehandle.
  Switches to use these filehandles.
  
  =back
  
  One can check whether the currently loaded ReadLine package supports
  these methods by checking for corresponding C<Features>.
  
  =head1 EXPORTS
  
  None
  
  =head1 ENVIRONMENT
  
  The environment variable C<PERL_RL> governs which ReadLine clone is
  loaded. If the value is false, a dummy interface is used. If the value
  is true, it should be tail of the name of the package to use, such as
  C<Perl> or C<Gnu>.  
  
  As a special case, if the value of this variable is space-separated,
  the tail might be used to disable the ornaments by setting the tail to
  be C<o=0> or C<ornaments=0>.  The head should be as described above, say
  
  If the variable is not set, or if the head of space-separated list is
  empty, the best available package is loaded.
  
    export "PERL_RL=Perl o=0" # Use Perl ReadLine sans ornaments
    export "PERL_RL= o=0"     # Use best available ReadLine sans ornaments
  
  (Note that processing of C<PERL_RL> for ornaments is in the discretion of the 
  particular used C<Term::ReadLine::*> package).
  
  =cut
  
  use strict;
  
  package Term::ReadLine::Stub;
  our @ISA = qw'Term::ReadLine::Tk Term::ReadLine::TermCap';
  
  $DB::emacs = $DB::emacs;	# To pacify -w
  our @rl_term_set;
  *rl_term_set = \@Term::ReadLine::TermCap::rl_term_set;
  
  sub PERL_UNICODE_STDIN () { 0x0001 }
  
  sub ReadLine {'Term::ReadLine::Stub'}
  sub readline {
    my $self = shift;
    my ($in,$out,$str) = @$self;
    my $prompt = shift;
    print $out $rl_term_set[0], $prompt, $rl_term_set[1], $rl_term_set[2];
    $self->register_Tk
       if not $Term::ReadLine::registered and $Term::ReadLine::toloop;
    #$str = scalar <$in>;
    $str = $self->get_line;
    utf8::upgrade($str)
        if (${^UNICODE} & PERL_UNICODE_STDIN || defined ${^ENCODING}) &&
           utf8::valid($str);
    print $out $rl_term_set[3];
    # bug in 5.000: chomping empty string creates length -1:
    chomp $str if defined $str;
    $str;
  }
  sub addhistory {}
  
  sub findConsole {
      my $console;
      my $consoleOUT;
  
      if (-e "/dev/tty" and $^O ne 'MSWin32') {
  	$console = "/dev/tty";
      } elsif (-e "con" or $^O eq 'MSWin32' or $^O eq 'msys') {
         $console = 'CONIN$';
         $consoleOUT = 'CONOUT$';
      } elsif ($^O eq 'VMS') {
  	$console = "sys\$command";
      } elsif ($^O eq 'os2' && !$DB::emacs) {
  	$console = "/dev/con";
      } else {
  	$console = undef;
      }
  
      $consoleOUT = $console unless defined $consoleOUT;
      $console = "&STDIN" unless defined $console;
      if ($console eq "/dev/tty" && !open(my $fh, "<", $console)) {
        $console = "&STDIN";
        undef($consoleOUT);
      }
      if (!defined $consoleOUT) {
        $consoleOUT = defined fileno(STDERR) && $^O ne 'MSWin32' ? "&STDERR" : "&STDOUT";
      }
      ($console,$consoleOUT);
  }
  
  sub new {
    die "method new called with wrong number of arguments" 
      unless @_==2 or @_==4;
    #local (*FIN, *FOUT);
    my ($FIN, $FOUT, $ret);
    if (@_==2) {
      my($console, $consoleOUT) = $_[0]->findConsole;
  
  
      # the Windows CONIN$ needs GENERIC_WRITE mode to allow
      # a SetConsoleMode() if we end up using Term::ReadKey
      open FIN, (  $^O eq 'MSWin32' && $console eq 'CONIN$' ) ? "+<$console" :
                                                                "<$console";
      open FOUT,">$consoleOUT";
  
      #OUT->autoflush(1);		# Conflicts with debugger?
      my $sel = select(FOUT);
      $| = 1;				# for DB::OUT
      select($sel);
      $ret = bless [\*FIN, \*FOUT];
    } else {			# Filehandles supplied
      $FIN = $_[2]; $FOUT = $_[3];
      #OUT->autoflush(1);		# Conflicts with debugger?
      my $sel = select($FOUT);
      $| = 1;				# for DB::OUT
      select($sel);
      $ret = bless [$FIN, $FOUT];
    }
    if ($ret->Features->{ornaments} 
        and not ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/)) {
      local $Term::ReadLine::termcap_nowarn = 1;
      $ret->ornaments(1);
    }
    return $ret;
  }
  
  sub newTTY {
    my ($self, $in, $out) = @_;
    $self->[0] = $in;
    $self->[1] = $out;
    my $sel = select($out);
    $| = 1;				# for DB::OUT
    select($sel);
  }
  
  sub IN { shift->[0] }
  sub OUT { shift->[1] }
  sub MinLine { undef }
  sub Attribs { {} }
  
  my %features = (tkRunning => 1, ornaments => 1, 'newTTY' => 1);
  sub Features { \%features }
  
  #sub get_line {
  #  my $self = shift;
  #  my $in = $self->IN;
  #  local ($/) = "\n";
  #  return scalar <$in>;
  #}
  
  package Term::ReadLine;		# So late to allow the above code be defined?
  
  our $VERSION = '1.14';
  
  my ($which) = exists $ENV{PERL_RL} ? split /\s+/, $ENV{PERL_RL} : undef;
  if ($which) {
    if ($which =~ /\bgnu\b/i){
      eval "use Term::ReadLine::Gnu;";
    } elsif ($which =~ /\bperl\b/i) {
      eval "use Term::ReadLine::Perl;";
    } elsif ($which =~ /^(Stub|TermCap|Tk)$/) {
      # it is already in memory to avoid false exception as seen in:
      # PERL_RL=Stub perl -e'$SIG{__DIE__} = sub { print @_ }; require Term::ReadLine'
    } else {
      eval "use Term::ReadLine::$which;";
    }
  } elsif (defined $which and $which ne '') {	# Defined but false
    # Do nothing fancy
  } else {
    eval "use Term::ReadLine::Gnu; 1" or eval "use Term::ReadLine::EditLine; 1" or eval "use Term::ReadLine::Perl; 1";
  }
  
  #require FileHandle;
  
  # To make possible switch off RL in debugger: (Not needed, work done
  # in debugger).
  our @ISA;
  if (defined &Term::ReadLine::Gnu::readline) {
    @ISA = qw(Term::ReadLine::Gnu Term::ReadLine::Stub);
  } elsif (defined &Term::ReadLine::EditLine::readline) {
    @ISA = qw(Term::ReadLine::EditLine Term::ReadLine::Stub);
  } elsif (defined &Term::ReadLine::Perl::readline) {
    @ISA = qw(Term::ReadLine::Perl Term::ReadLine::Stub);
  } elsif (defined $which && defined &{"Term::ReadLine::$which\::readline"}) {
    @ISA = "Term::ReadLine::$which";
  } else {
    @ISA = qw(Term::ReadLine::Stub);
  }
  
  package Term::ReadLine::TermCap;
  
  # Prompt-start, prompt-end, command-line-start, command-line-end
  #     -- zero-width beautifies to emit around prompt and the command line.
  our @rl_term_set = ("","","","");
  # string encoded:
  our $rl_term_set = ',,,';
  
  our $terminal;
  sub LoadTermCap {
    return if defined $terminal;
    
    require Term::Cap;
    $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
  }
  
  sub ornaments {
    shift;
    return $rl_term_set unless @_;
    $rl_term_set = shift;
    $rl_term_set ||= ',,,';
    $rl_term_set = 'us,ue,md,me' if $rl_term_set eq '1';
    my @ts = split /,/, $rl_term_set, 4;
    eval { LoadTermCap };
    unless (defined $terminal) {
      warn("Cannot find termcap: $@\n") unless $Term::ReadLine::termcap_nowarn;
      $rl_term_set = ',,,';
      return;
    }
    @rl_term_set = map {$_ ? $terminal->Tputs($_,1) || '' : ''} @ts;
    return $rl_term_set;
  }
  
  
  package Term::ReadLine::Tk;
  
  # This package inserts a Tk->fileevent() before the diamond operator.
  # The Tk watcher dispatches Tk events until the filehandle returned by
  # the$term->IN() accessor becomes ready for reading.  It's assumed
  # that the diamond operator will return a line of input immediately at
  # that point.
  
  my ($giveup);
  
  # maybe in the future the Tk-specific aspects will be removed.
  sub Tk_loop{
      if (ref $Term::ReadLine::toloop)
      {
          $Term::ReadLine::toloop->[0]->($Term::ReadLine::toloop->[2]);
      }
      else
      {
          Tk::DoOneEvent(0) until $giveup;
          $giveup = 0;
      }
  };
  
  sub register_Tk {
      my $self = shift;
      unless ($Term::ReadLine::registered++)
      {
          if (ref $Term::ReadLine::toloop)
          {
              $Term::ReadLine::toloop->[2] = $Term::ReadLine::toloop->[1]->($self->IN) if $Term::ReadLine::toloop->[1];
          }
          else
          {
              Tk->fileevent($self->IN,'readable',sub { $giveup = 1});
          }
      }
  };
  
  sub tkRunning {
    $Term::ReadLine::toloop = $_[1] if @_ > 1;
    $Term::ReadLine::toloop;
  }
  
  sub event_loop {
      shift;
  
      # T::RL::Gnu and T::RL::Perl check that this exists, if not,
      # it doesn't call the loop.  Those modules will need to be
      # fixed before this can be removed.
      if (not defined &Tk::DoOneEvent)
      {
          *Tk::DoOneEvent = sub {
              die "what?"; # this shouldn't be called.
          }
      }
  
      # store the callback in toloop, again so that other modules will
      # recognise it and call us for the loop.
      $Term::ReadLine::toloop = [ @_ ] if @_ > 0; # 0 because we shifted off $self.
      $Term::ReadLine::toloop;
  }
  
  sub PERL_UNICODE_STDIN () { 0x0001 }
  
  sub get_line {
    my $self = shift;
    my ($in,$out,$str) = @$self;
  
    if ($Term::ReadLine::toloop) {
      $self->register_Tk if not $Term::ReadLine::registered;
      $self->Tk_loop;
    }
  
    local ($/) = "\n";
    $str = <$in>;
  
    utf8::upgrade($str)
        if (${^UNICODE} & PERL_UNICODE_STDIN || defined ${^ENCODING}) &&
           utf8::valid($str);
    print $out $rl_term_set[3];
    # bug in 5.000: chomping empty string creates length -1:
    chomp $str if defined $str;
  
    $str;
  }
  
  1;
  
TERM_READLINE

$fatpacked{"Term/UI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_UI';
  package Term::UI;
  
  use if $] > 5.017, 'deprecate';
  
  use Carp;
  use Params::Check qw[check allow];
  use Term::ReadLine;
  use Locale::Maketext::Simple Style => 'gettext';
  use Term::UI::History;
  
  use strict;
  
  BEGIN {
      use vars        qw[$VERSION $AUTOREPLY $VERBOSE $INVALID];
      $VERBOSE    =   1;
      $VERSION    =   '0.42';
      $INVALID    =   loc('Invalid selection, please try again: ');
  }
  
  push @Term::ReadLine::Stub::ISA, __PACKAGE__
          unless grep { $_ eq __PACKAGE__ } @Term::ReadLine::Stub::ISA;
  
  
  =pod
  
  =head1 NAME
  
  Term::UI - Term::ReadLine UI made easy
  
  =head1 SYNOPSIS
  
      use Term::UI;
      use Term::ReadLine;
  
      my $term = Term::ReadLine->new('brand');
  
      my $reply = $term->get_reply(
                      prompt => 'What is your favourite colour?',
                      choices => [qw|blue red green|],
                      default => 'blue',
      );
  
      my $bool = $term->ask_yn(
                          prompt => 'Do you like cookies?',
                          default => 'y',
                  );
  
  
      my $string = q[some_command -option --no-foo --quux='this thing'];
  
      my ($options,$munged_input) = $term->parse_options($string);
  
  
      ### don't have Term::UI issue warnings -- default is '1'
      $Term::UI::VERBOSE = 0;
  
      ### always pick the default (good for non-interactive terms)
      ### -- default is '0'
      $Term::UI::AUTOREPLY = 1;
  
      ### Retrieve the entire session as a printable string:
      $hist = Term::UI::History->history_as_string;
      $hist = $term->history_as_string;
  
  =head1 DESCRIPTION
  
  C<Term::UI> is a transparent way of eliminating the overhead of having
  to format a question and then validate the reply, informing the user
  if the answer was not proper and re-issuing the question.
  
  Simply give it the question you want to ask, optionally with choices
  the user can pick from and a default and C<Term::UI> will DWYM.
  
  For asking a yes or no question, there's even a shortcut.
  
  =head1 HOW IT WORKS
  
  C<Term::UI> places itself at the back of the C<Term::ReadLine>
  C<@ISA> array, so you can call its functions through your term object.
  
  C<Term::UI> uses C<Term::UI::History> to record all interactions
  with the commandline. You can retrieve this history, or alter
  the filehandle the interaction is printed to. See the
  C<Term::UI::History> manpage or the C<SYNOPSIS> for details.
  
  =head1 METHODS
  
  =head2 $reply = $term->get_reply( prompt => 'question?', [choices => \@list, default => $list[0], multi => BOOL, print_me => "extra text to print & record", allow => $ref] );
  
  C<get_reply> asks a user a question, and then returns the reply to the
  caller. If the answer is invalid (more on that below), the question will
  be reposed, until a satisfactory answer has been entered.
  
  You have the option of providing a list of choices the user can pick from
  using the C<choices> argument. If the answer is not in the list of choices
  presented, the question will be reposed.
  
  If you provide a C<default>  answer, this will be returned when either
  C<$AUTOREPLY> is set to true, (see the C<GLOBAL VARIABLES> section further
  below), or when the user just hits C<enter>.
  
  You can indicate that the user is allowed to enter multiple answers by
  toggling the C<multi> flag. Note that a list of answers will then be
  returned to you, rather than a simple string.
  
  By specifying an C<allow> handler, you can yourself validate the answer
  a user gives. This can be any of the types that the Params::Check C<allow>
  function allows, so please refer to that manpage for details.
  
  Finally, you have the option of adding a C<print_me> argument, which is
  simply printed before the prompt. It's printed to the same file handle
  as the rest of the questions, so you can use this to keep track of a
  full session of Q&A with the user, and retrieve it later using the
  C<< Term::UI->history_as_string >> function.
  
  See the C<EXAMPLES> section for samples of how to use this function.
  
  =cut
  
  sub get_reply {
      my $term = shift;
      my %hash = @_;
  
      my $tmpl = {
          default     => { default => undef,  strict_type => 0 },
          prompt      => { default => '',     strict_type => 1, required => 1 },
          choices     => { default => [],     strict_type => 1 },
          multi       => { default => 0,      allow => [0, 1] },
          allow       => { default => qr/.*/ },
          print_me    => { default => '',     strict_type => 1 },
      };
  
      my $args = check( $tmpl, \%hash, $VERBOSE )
                  or ( carp( loc(q[Could not parse arguments]) ), return );
  
      # Check for legacy default on multi=1
      if ($args->{multi} and ref($args->{default}) ne "ARRAY") {
          $args->{default} = [ $args->{default} ];
      }
  
      ### add this to the prompt to indicate the default
      ### answer to the question if there is one.
      my $prompt_add;
  
      ### if you supplied several choices to pick from,
      ### we'll print them separately before the prompt
      if( @{$args->{choices}} ) {
          my $i;
  
          for my $choice ( @{$args->{choices}} ) {
              $i++;   # the answer counter -- but humans start counting
                      # at 1 :D
  
              ### so this choice is the default? add it to 'prompt_add'
              ### so we can construct a "foo? [DIGIT]" type prompt
              if (defined $args->{default}) {
                  if ($args->{multi}) {
                      push @$prompt_add, $i if (scalar(grep { m/^$choice$/ } @{$args->{default}}));
                  }
                  else {
                      $prompt_add = $i if ($choice eq $args->{default});
                  }
              }
  
              ### create a "DIGIT> choice" type line
              $args->{print_me} .= sprintf "\n%3s> %-s", $i, $choice;
          }
  
          $prompt_add = join(" ", @$prompt_add) if ($args->{multi});
  
          ### we listed some choices -- add another newline for
          ### pretty printing
          $args->{print_me} .= "\n" if $i;
  
          ### allowable answers are now equal to the choices listed
          $args->{allow} = $args->{choices};
  
      ### no choices, but a default? set 'prompt_add' to the default
      ### to construct a 'foo? [DEFAULT]' type prompt
      } elsif ( defined $args->{default} ) {
          if ($args->{multi} and ref($args->{default}) eq "ARRAY") {
              $prompt_add = join(" ", @{$args->{default}});
          }
          else {
              $prompt_add = $args->{default};
          }
      }
  
      ### we set up the defaults, prompts etc, dispatch to the readline call
      return $term->_tt_readline( %$args, prompt_add => $prompt_add );
  
  }
  
  =head2 $bool = $term->ask_yn( prompt => "your question", [default => (y|1,n|0), print_me => "extra text to print & record"] )
  
  Asks a simple C<yes> or C<no> question to the user, returning a boolean
  indicating C<true> or C<false> to the caller.
  
  The C<default> answer will automatically returned, if the user hits
  C<enter> or if C<$AUTOREPLY> is set to true. See the C<GLOBAL VARIABLES>
  section further below.
  
  Also, you have the option of adding a C<print_me> argument, which is
  simply printed before the prompt. It's printed to the same file handle
  as the rest of the questions, so you can use this to keep track of a
  full session of Q&A with the user, and retrieve it later using the
  C<< Term::UI->history_as_string >> function.
  
  
  See the C<EXAMPLES> section for samples of how to use this function.
  
  =cut
  
  sub ask_yn {
      my $term = shift;
      my %hash = @_;
  
      my $tmpl = {
          default     => { default => undef, allow => [qw|0 1 y n|],
                                                              strict_type => 1 },
          prompt      => { default => '', required => 1,      strict_type => 1 },
          print_me    => { default => '',                     strict_type => 1 },
          multi       => { default => 0,                      no_override => 1 },
          choices     => { default => [qw|y n|],              no_override => 1 },
          allow       => { default => [qr/^y(?:es)?$/i, qr/^n(?:o)?$/i],
                           no_override => 1
                         },
      };
  
      my $args = check( $tmpl, \%hash, $VERBOSE ) or return undef;
  
      ### uppercase the default choice, if there is one, to be added
      ### to the prompt in a 'foo? [Y/n]' type style.
      my $prompt_add;
      {   my @list = @{$args->{choices}};
          if( defined $args->{default} ) {
  
              ### if you supplied the default as a boolean, rather than y/n
              ### transform it to a y/n now
              $args->{default} = $args->{default} =~ /\d/
                                  ? { 0 => 'n', 1 => 'y' }->{ $args->{default} }
                                  : $args->{default};
  
              @list = map { lc $args->{default} eq lc $_
                                  ? uc $args->{default}
                                  : $_
                      } @list;
          }
  
          $prompt_add .= join("/", @list);
      }
  
      my $rv = $term->_tt_readline( %$args, prompt_add => $prompt_add );
  
      return $rv =~ /^y/i ? 1 : 0;
  }
  
  
  
  sub _tt_readline {
      my $term = shift;
      my %hash = @_;
  
      local $Params::Check::VERBOSE = 0;  # why is this?
      local $| = 1;                       # print ASAP
  
  
      my ($default, $prompt, $choices, $multi, $allow, $prompt_add, $print_me);
      my $tmpl = {
          default     => { default => undef,  strict_type => 0,
                              store => \$default },
          prompt      => { default => '',     strict_type => 1, required => 1,
                              store => \$prompt },
          choices     => { default => [],     strict_type => 1,
                              store => \$choices },
          multi       => { default => 0,      allow => [0, 1], store => \$multi },
          allow       => { default => qr/.*/, store => \$allow, },
          prompt_add  => { default => '',     store => \$prompt_add, strict_type => 1 },
          print_me    => { default => '',     store => \$print_me },
      };
  
      check( $tmpl, \%hash, $VERBOSE ) or return;
  
      ### prompts for Term::ReadLine can't be longer than one line, or
      ### it can display wonky on some terminals.
      history( $print_me ) if $print_me;
  
  
      if ($prompt_add) {
          ### we might have to add a default value to the prompt, to
          ### show the user what will be picked by default:
          $prompt .= " [$prompt_add]: " ;
      }
      else {
          $prompt .= " : ";
      }
  
  
      ### are we in autoreply mode?
      if ($AUTOREPLY) {
  
          ### you used autoreply, but didn't provide a default!
          carp loc(
              q[You have '%1' set to true, but did not provide a default!],
              '$AUTOREPLY'
          ) if( !defined $default && $VERBOSE);
  
          ### print it out for visual feedback
          if ($multi and defined($default)) {
              history( join ' ', grep { defined } $prompt, @$default );
              ### and return the default
              return @$default;
          }
          else {
              history( join ' ', grep { defined } $prompt, $default );
              ### and return the default
              return $default;
          }
  
      }
  
      if ($multi and defined($default)) {
          $default = join(' ', @$default);
      }
  
      ### so, no AUTOREPLY, let's see what the user will answer
      LOOP: {
  
          ### annoying bug in T::R::Perl that mucks up lines with a \n
          ### in them; So split by \n, save the last line as the prompt
          ### and just print the rest
          {   my @lines   = split "\n", $prompt;
              $prompt     = pop @lines;
  
              history( "$_\n" ) for @lines;
          }
  
          ### pose the question
          my $answer  = $term->readline($prompt);
          $answer     = $default unless length $answer;
  
          $term->addhistory( $answer ) if length $answer;
  
          ### add both prompt and answer to the history
          history( "$prompt $answer", 0 );
  
          ### if we're allowed to give multiple answers, split
          ### the answer on whitespace
          my @answers = $multi ? split(/\s+/, $answer) : $answer;
  
          ### the return value list
          my @rv;
  
          if( @$choices ) {
  
              for my $answer (@answers) {
  
                  ### a digit implies a multiple choice question,
                  ### a non-digit is an open answer
                  if( $answer =~ /\D/ ) {
                      push @rv, $answer if allow( $answer, $allow );
                  } else {
  
                      ### remember, the answer digits are +1 compared to
                      ### the choices, because humans want to start counting
                      ### at 1, not at 0
                      push @rv, $choices->[ $answer - 1 ]
                          if $answer > 0 && defined $choices->[ $answer - 1 ];
                  }
              }
  
          ### no fixed list of choices.. just check if the answers
          ### (or otherwise the default!) pass the allow handler
          } else {
              push @rv, grep { allow( $_, $allow ) } @answers;
          }
  
          ### if not all the answers made it to the return value list,
          ### at least one of them was an invalid answer -- make the
          ### user do it again
          if( (@rv != @answers) or
              (scalar(@$choices) and not scalar(@answers))
          ) {
              $prompt = $INVALID;
              $prompt .= "[$prompt_add] " if $prompt_add;
              redo LOOP;
  
          ### otherwise just return the answer, or answers, depending
          ### on the multi setting
          } else {
              return $multi ? @rv : $rv[0];
          }
      }
  }
  
  =head2 ($opts, $munged) = $term->parse_options( STRING );
  
  C<parse_options> will convert all options given from an input string
  to a hash reference. If called in list context it will also return
  the part of the input string that it found no options in.
  
  Consider this example:
  
      my $str =   q[command --no-foo --baz --bar=0 --quux=bleh ] .
                  q[--option="some'thing" -one-dash -single=blah' arg];
  
      my ($options,$munged) =  $term->parse_options($str);
  
      ### $options would contain: ###
      $options = {
                  'foo'       => 0,
                  'bar'       => 0,
                  'one-dash'  => 1,
                  'baz'       => 1,
                  'quux'      => 'bleh',
                  'single'    => 'blah\'',
                  'option'    => 'some\'thing'
      };
  
      ### and this is the munged version of the input string,
      ### ie what's left of the input minus the options
      $munged = 'command arg';
  
  As you can see, you can either use a single or a double C<-> to
  indicate an option.
  If you prefix an option with C<no-> and do not give it a value, it
  will be set to 0.
  If it has no prefix and no value, it will be set to 1.
  Otherwise, it will be set to its value. Note also that it can deal
  fine with single/double quoting issues.
  
  =cut
  
  sub parse_options {
      my $term    = shift;
      my $input   = shift;
  
      my $return = {};
  
      ### there's probably a more elegant way to do this... ###
      while ( $input =~ s/(?:^|\s+)--?([-\w]+=("|').+?\2)(?=\Z|\s+)//  or
              $input =~ s/(?:^|\s+)--?([-\w]+=\S+)(?=\Z|\s+)//         or
              $input =~ s/(?:^|\s+)--?([-\w]+)(?=\Z|\s+)//
      ) {
          my $match = $1;
  
          if( $match =~ /^([-\w]+)=("|')(.+?)\2$/ ) {
              $return->{$1} = $3;
  
          } elsif( $match =~ /^([-\w]+)=(\S+)$/ ) {
              $return->{$1} = $2;
  
          } elsif( $match =~ /^no-?([-\w]+)$/i ) {
              $return->{$1} = 0;
  
          } elsif ( $match =~ /^([-\w]+)$/ ) {
              $return->{$1} = 1;
  
          } else {
              carp(loc(q[I do not understand option "%1"\n], $match)) if $VERBOSE;
          }
      }
  
      return wantarray ? ($return,$input) : $return;
  }
  
  =head2 $str = $term->history_as_string
  
  Convenience wrapper around C<< Term::UI::History->history_as_string >>.
  
  Consult the C<Term::UI::History> man page for details.
  
  =cut
  
  sub history_as_string { return Term::UI::History->history_as_string };
  
  1;
  
  =head1 GLOBAL VARIABLES
  
  The behaviour of Term::UI can be altered by changing the following
  global variables:
  
  =head2 $Term::UI::VERBOSE
  
  This controls whether Term::UI will issue warnings and explanations
  as to why certain things may have failed. If you set it to 0,
  Term::UI will not output any warnings.
  The default is 1;
  
  =head2 $Term::UI::AUTOREPLY
  
  This will make every question be answered by the default, and warn if
  there was no default provided. This is particularly useful if your
  program is run in non-interactive mode.
  The default is 0;
  
  =head2 $Term::UI::INVALID
  
  This holds the string that will be printed when the user makes an
  invalid choice.
  You can override this string from your program if you, for example,
  wish to do localization.
  The default is C<Invalid selection, please try again: >
  
  =head2 $Term::UI::History::HISTORY_FH
  
  This is the filehandle all the print statements from this module
  are being sent to. Please consult the C<Term::UI::History> manpage
  for details.
  
  This defaults to C<*STDOUT>.
  
  =head1 EXAMPLES
  
  =head2 Basic get_reply sample
  
      ### ask a user (with an open question) for their favourite colour
      $reply = $term->get_reply( prompt => 'Your favourite colour? );
  
  which would look like:
  
      Your favourite colour?
  
  and C<$reply> would hold the text the user typed.
  
  =head2 get_reply with choices
  
      ### now provide a list of choices, so the user has to pick one
      $reply = $term->get_reply(
                  prompt  => 'Your favourite colour?',
                  choices => [qw|red green blue|] );
  
  which would look like:
  
        1> red
        2> green
        3> blue
  
      Your favourite colour?
  
  C<$reply> will hold one of the choices presented. C<Term::UI> will repose
  the question if the user attempts to enter an answer that's not in the
  list of choices. The string presented is held in the C<$Term::UI::INVALID>
  variable (see the C<GLOBAL VARIABLES> section for details.
  
  =head2 get_reply with choices and default
  
      ### provide a sensible default option -- everyone loves blue!
      $reply = $term->get_reply(
                  prompt  => 'Your favourite colour?',
                  choices => [qw|red green blue|],
                  default => 'blue' );
  
  which would look like:
  
        1> red
        2> green
        3> blue
  
      Your favourite colour? [3]:
  
  Note the default answer after the prompt. A user can now just hit C<enter>
  (or set C<$Term::UI::AUTOREPLY> -- see the C<GLOBAL VARIABLES> section) and
  the sensible answer 'blue' will be returned.
  
  =head2 get_reply using print_me & multi
  
      ### allow the user to pick more than one colour and add an
      ### introduction text
      @reply = $term->get_reply(
                  print_me    => 'Tell us what colours you like',
                  prompt      => 'Your favourite colours?',
                  choices     => [qw|red green blue|],
                  multi       => 1 );
  
  which would look like:
  
      Tell us what colours you like
        1> red
        2> green
        3> blue
  
      Your favourite colours?
  
  An answer of C<3 2 1> would fill C<@reply> with C<blue green red>
  
  =head2 get_reply & allow
  
      ### pose an open question, but do a custom verification on
      ### the answer, which will only exit the question loop, if
      ### the answer matches the allow handler.
      $reply = $term->get_reply(
                  prompt  => "What is the magic number?",
                  allow   => 42 );
  
  Unless the user now enters C<42>, the question will be reposed over
  and over again. You can use more sophisticated C<allow> handlers (even
  subroutines can be used). The C<allow> handler is implemented using
  C<Params::Check>'s C<allow> function. Check its manpage for details.
  
  =head2 an elaborate ask_yn sample
  
      ### ask a user if he likes cookies. Default to a sensible 'yes'
      ### and inform him first what cookies are.
      $bool = $term->ask_yn( prompt   => 'Do you like cookies?',
                             default  => 'y',
                             print_me => 'Cookies are LOVELY!!!' );
  
  would print:
  
      Cookies are LOVELY!!!
      Do you like cookies? [Y/n]:
  
  If a user then simply hits C<enter>, agreeing with the default,
  C<$bool> would be set to C<true>. (Simply hitting 'y' would also
  return C<true>. Hitting 'n' would return C<false>)
  
  We could later retrieve this interaction by printing out the Q&A
  history as follows:
  
      print $term->history_as_string;
  
  which would then print:
  
      Cookies are LOVELY!!!
      Do you like cookies? [Y/n]:  y
  
  There's a chance we're doing this non-interactively, because a console
  is missing, the user indicated he just wanted the defaults, etc.
  
  In this case, simply setting C<$Term::UI::AUTOREPLY> to true, will
  return from every question with the default answer set for the question.
  Do note that if C<AUTOREPLY> is true, and no default is set, C<Term::UI>
  will warn about this and return C<undef>.
  
  =head1 See Also
  
  C<Params::Check>, C<Term::ReadLine>, C<Term::UI::History>
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-term-ui@rt.cpan.org<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  =cut
TERM_UI

$fatpacked{"Term/UI/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_UI_HISTORY';
  package Term::UI::History;
  
  use strict;
  use vars qw[$VERSION];
  use base 'Exporter';
  use base 'Log::Message::Simple';
  
  $VERSION = '0.42';
  
  =pod
  
  =head1 NAME
  
  Term::UI::History - history function
  
  =head1 SYNOPSIS
  
      use Term::UI::History qw[history];
  
      history("Some message");
  
      ### retrieve the history in printable form
      $hist  = Term::UI::History->history_as_string;
  
      ### redirect output
      local $Term::UI::History::HISTORY_FH = \*STDERR;
  
  =head1 DESCRIPTION
  
  This module provides the C<history> function for C<Term::UI>,
  printing and saving all the C<UI> interaction.
  
  Refer to the C<Term::UI> manpage for details on usage from
  C<Term::UI>.
  
  This module subclasses C<Log::Message::Simple>. Refer to its
  manpage for additional functionality available via this package.
  
  =head1 FUNCTIONS
  
  =head2 history("message string" [,VERBOSE])
  
  Records a message on the stack, and prints it to C<STDOUT>
  (or actually C<$HISTORY_FH>, see the C<GLOBAL VARIABLES> section
  below), if the C<VERBOSE> option is true.
  
  The C<VERBOSE> option defaults to true.
  
  =cut
  
  BEGIN {
      use Log::Message private => 0;
  
      use vars      qw[ @EXPORT $HISTORY_FH ];
      @EXPORT     = qw[ history ];
      my $log     = new Log::Message;
      $HISTORY_FH = \*STDOUT;
  
      for my $func ( @EXPORT ) {
          no strict 'refs';
  
          *$func = sub {  my $msg     = shift;
                          $log->store(
                                  message => $msg,
                                  tag     => uc $func,
                                  level   => $func,
                                  extra   => [@_]
                          );
                  };
      }
  
      sub history_as_string {
          my $class = shift;
  
          return join $/, map { $_->message } __PACKAGE__->stack;
      }
  }
  
  
  {
      package # hide this from PAUSE
        Log::Message::Handlers;
  
      sub history {
          my $self    = shift;
          my $verbose = shift;
             $verbose = 1 unless defined $verbose;    # default to true
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          local $| = 1;
          my $old_fh = select $Term::UI::History::HISTORY_FH;
  
          print $self->message . "\n";
          select $old_fh;
  
          return;
      }
  }
  
  
  =head1 GLOBAL VARIABLES
  
  =over 4
  
  =item $HISTORY_FH
  
  This is the filehandle all the messages sent to C<history()> are being
  printed. This defaults to C<*STDOUT>.
  
  =back
  
  =head1 See Also
  
  C<Log::Message::Simple>, C<Term::UI>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2005 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
TERM_UI_HISTORY

$fatpacked{"Test/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TYPETINY';
  package Test::TypeTiny;
  
  use strict;
  use warnings;
  
  use Test::More qw();
  use Scalar::Util qw(blessed);
  use Types::TypeTiny qw(to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN {
  	*EXTENDED_TESTING = $ENV{EXTENDED_TESTING} ? sub(){!!1} : sub(){!!0};
  };
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  our @EXPORT    = qw( should_pass should_fail ok_subtype );
  our @EXPORT_OK = qw( EXTENDED_TESTING matchfor );
  
  sub matchfor
  {
  	my @matchers = @_;
  	bless \@matchers, do {
  		package #
  		Test::TypeTiny::Internal::MATCHFOR;
  		use overload
  			q[==] => 'match',
  			q[eq] => 'match',
  			q[""] => 'to_string',
  			fallback => 1;
  		sub to_string {
  			$_[0][0]
  		}
  		sub match {
  			my ($self, $e) = @_;
  			my $does = Scalar::Util::blessed($e) ? ($e->can('DOES') || $e->can('isa')) : undef;
  			for my $s (@$self) {
  				return 1 if  ref($s) && $e =~ $s;
  				return 1 if !ref($s) && $does && $e->$does($s);
  			}
  			return;
  		}
  		__PACKAGE__;
  	};
  }
  
  sub _mk_message
  {
  	require Type::Tiny;
  	my ($template, $value) = @_;
  	sprintf($template, Type::Tiny::_dd($value));
  }
  
  sub ok_subtype
  {
  	my ($type, @s) = @_;
  	@_ = (
  		not(scalar grep !$_->is_subtype_of($type), @s),
  		sprintf("%s subtype: %s", $type, join q[, ], @s),
  	);
  	goto \&Test::More::ok;
  }
  
  eval(EXTENDED_TESTING ? <<'SLOW' : <<'FAST');
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!!$type->check($value), '->check');
  	$test->ok(!!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!$type->check($value), '->check');
  	$test->ok(!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  SLOW
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!!$type->check($value),
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!$type->check($value),
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  FAST
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Test::TypeTiny - useful functions for testing the efficacy of type constraints
  
  =head1 SYNOPSIS
  
     use strict;
     use warnings;
     use Test::More;
     use Test::TypeTiny;
     
     use Types::Mine qw(Integer);
     
     should_pass(1, Integer);
     should_pass(-1, Integer);
     should_pass(0, Integer);
     should_fail(2.5, Integer);
     
     ok_subtype(Number, Integer);
     
     done_testing;
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Test::TypeTiny> provides a few handy functions for testing type constraints.
  
  =head2 Functions
  
  =over
  
  =item C<< should_pass($value, $type, $test_name) >>
  
  =item C<< should_pass($value, $type) >>
  
  Test that passes iff C<< $value >> passes C<< $type->check >>.
  
  =item C<< should_fail($value, $type, $test_name) >>
  
  =item C<< should_fail($value, $type) >>
  
  Test that passes iff C<< $value >> fails C<< $type->check >>.
  
  =item C<< ok_subtype($type, @subtypes) >>
  
  Test that passes iff all C<< @subtypes >> are subtypes of C<< $type >>.
  
  =item C<< EXTENDED_TESTING >>
  
  Exportable boolean constant.
  
  =item C<< matchfor(@things) >>
  
  Assistant for matching exceptions. Not exported by default.
  See also L<Test::Fatal::matchfor>.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the C<EXTENDED_TESTING> environment variable is set to true, this
  module will promote each C<should_pass> or C<should_fail> test into a
  subtest block and test the type constraint in both an inlined and
  non-inlined manner.
  
  This variable must be set at compile time (i.e. before this module is
  loaded).
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  For an alternative to C<should_pass>, see L<Test::Deep::Type> which will
  happily accept a Type::Tiny type constraint instead of a MooseX::Types one.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TEST_TYPETINY

$fatpacked{"Test/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_YAML';
  package Test::YAML;
  $Test::YAML::VERSION = '0.90';
  use Test::Base -Base;
  use lib 'lib';
  
  our $YAML    = 'YAML';
  our @EXPORT  = qw(
      no_diff
      run_yaml_tests
      run_roundtrip_nyn roundtrip_nyn
      run_load_passes load_passes
      dumper Load Dump LoadFile DumpFile
      XXX
  );
  
  delimiters('===', '+++');
  
  sub Dump     () { YAML(Dump => @_)     }
  sub Load     () { YAML(Load => @_)     }
  sub DumpFile () { YAML(DumpFile => @_) }
  sub LoadFile () { YAML(LoadFile => @_) }
  
  sub YAML () {
      load_yaml_pm();
      my $meth = shift;
      my $code = $YAML->can($meth) or die "$YAML cannot do $meth";
      goto &$code;
  }
  
  sub load_yaml_pm {
      my $file = "$YAML.pm";
      $file =~ s{::}{/}g;
      require $file;
  }
  
  sub run_yaml_tests() {
      run {
          my $block = shift;
          &{_get_function($block)}($block) unless
            _skip_tests_for_now($block) or
            _skip_yaml_tests($block);
      };
  }
  
  sub run_roundtrip_nyn() {
      my @options = @_;
      run {
          my $block = shift;
          roundtrip_nyn($block, @options);
      };
  }
  
  sub roundtrip_nyn() {
      my $block = shift;
      my $option = shift || '';
      die "'perl' data section required"
          unless exists $block->{perl};
      my @values = eval $block->perl;
      die "roundtrip_nyn eval perl error: $@" if $@;
      my $config = $block->config || '';
      my $result = eval "$config; Dump(\@values)";
      die "roundtrip_nyn YAML::Dump error: $@" if $@;
      if (exists $block->{yaml}) {
          is $result, $block->yaml,
              $block->description . ' (n->y)';
      }
      else {
          pass $block->description . ' (n->y)';
      }
  
      return if exists $block->{no_round_trip} or
          not exists $block->{yaml};
  
      if ($option eq 'dumper') {
          is dumper(Load($block->yaml)), dumper(@values),
              $block->description . ' (y->n)';
      }
      else {
          is_deeply [Load($block->yaml)], [@values],
              $block->description . ' (y->n)';
      }
  }
  
  sub count_roundtrip_nyn() {
      my $block = shift or die "Bad call to count_roundtrip_nyn";
      return 1 if exists $block->{skip_this_for_now};
      my $count = 0;
      $count++ if exists $block->{perl};
      $count++ unless exists $block->{no_round_trip} or
          not exists $block->{yaml};
      die "Invalid test definition" unless $count;
      return $count;
  }
  
  sub run_load_passes() {
      run {
          my $block = shift;
          my $yaml = $block->yaml;
          eval { YAML(Load => $yaml) };
          is("$@", "");
      };
  }
  
  sub load_passes() {
      my $block = shift;
      my $yaml = $block->yaml;
      eval { YAML(Load => $yaml) };
      is "$@", "", $block->description;
  }
  
  sub count_load_passes() {1}
  
  sub dumper() {
      require Data::Dumper;
      $Data::Dumper::Sortkeys = 1;
      $Data::Dumper::Terse = 1;
      $Data::Dumper::Indent = 1;
      return Data::Dumper::Dumper(@_);
  }
  
  sub _count_tests() {
      my $block = shift or die "Bad call to _count_tests";
      no strict 'refs';
      &{'count_' . _get_function_name($block)}($block);
  }
  
  sub _get_function_name() {
      my $block = shift;
      return $block->function || 'roundtrip_nyn';
  }
  
  sub _get_function() {
      my $block = shift;
      no strict 'refs';
      \ &{_get_function_name($block)};
  }
  
  sub _skip_tests_for_now() {
      my $block = shift;
      if (exists $block->{skip_this_for_now}) {
          _skip_test(
              $block->description,
              _count_tests($block),
          );
          return 1;
      }
      return 0;
  }
  
  sub _skip_yaml_tests() {
      my $block = shift;
      if ($block->skip_unless_modules) {
          my @modules = split /[\s\,]+/, $block->skip_unless_modules;
          for my $module (@modules) {
              eval "require $module";
              if ($@) {
                  _skip_test(
                      "This test requires the '$module' module",
                      _count_tests($block),
                  );
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub _skip_test() {
      my ($message, $count) = @_;
      SKIP: {
          skip($message, $count);
      }
  }
  
  #-------------------------------------------------------------------------------
  package Test::YAML::Filter;
  $Test::YAML::Filter::VERSION = '0.90';
  use Test::Base::Filter ();
  
  our @ISA = 'Test::Base::Filter';
  
  sub yaml_dump {
      Test::YAML::Dump(@_);
  }
  
  sub yaml_load {
      Test::YAML::Load(@_);
  }
  
  sub Dump { goto &Test::YAML::Dump }
  sub Load { goto &Test::YAML::Load }
  sub DumpFile { goto &Test::YAML::DumpFile }
  sub LoadFile { goto &Test::YAML::LoadFile }
  
  sub yaml_load_or_fail {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $result;
  }
  
  sub yaml_load_error_or_warning {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub perl_eval_error_or_warning {
      my ($result, $error, $warning) =
        $self->_perl_eval_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub _yaml_load_result_error_warning {
      $self->assert_scalar(@_);
      my $yaml = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval {
          $self->yaml_load($yaml);
      };
      return ($result, $@, $warning);
  }
  
  sub _perl_eval_result_error_warning {
      $self->assert_scalar(@_);
      my $perl = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval $perl;
      return ($result, $@, $warning);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::YAML - Testing Module for YAML Implementations
  
  =head1 SYNOPSIS
  
      use Test::YAML tests => 1;
  
      pass;
  
  =head1 DESCRIPTION
  
  Test::YAML is a subclass of Test::Base with YAML specific support.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST_YAML

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;
  BEGIN {
    $Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
  }
  $Try::Tiny::VERSION = '0.19';
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    subname("${caller}::try {...} " => $try);
    subname("${caller}::catch {...} " => $catch) if $catch;
    subname("${caller}::finally {...} " => $_) foreach @finally;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $fail to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.19
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || { "bar" };
    my $x = (try { die "foo" }) // { "bar" };
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considired experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Yuval Kogman.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"Type/Coercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION';
  package Type::Coercion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::VERSION   = '0.038';
  }
  
  use Eval::TypeTiny qw<>;
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny qw<>;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(+)       => sub { __PACKAGE__->add(@_) },
  	fallback   => 1,
  ;
  
  BEGIN {
  	require Type::Tiny;
  	overload->import(q(~~) => sub { $_[0]->has_coercion_for_value($_[1]) })
  		if Type::Tiny::SUPPORT_SMARTMATCH();
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	
  	if ("Sub::Quote"->can("quote_sub") && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_coercion('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->coerce(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	$params{name} = '__ANON__' unless exists($params{name});
  	my $C = delete($params{type_coercion_map}) || [];
  	my $F = delete($params{frozen});
  	
  	my $self = bless \%params, $class;
  	$self->add_type_coercions(@$C) if @$C;
  	Scalar::Util::weaken($self->{type_constraint}); # break ref cycle
  	$self->{frozen} = $F if $F;
  	
  	unless ($self->is_anon)
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$self->name =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $self->name =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid coercion name', $self->name;
  	}
  	
  	return $self;
  }
  
  sub name                   { $_[0]{name} }
  sub display_name           { $_[0]{display_name}      ||= $_[0]->_build_display_name }
  sub library                { $_[0]{library} }
  sub type_constraint        { $_[0]{type_constraint} }
  sub type_coercion_map      { $_[0]{type_coercion_map} ||= [] }
  sub moose_coercion         { $_[0]{moose_coercion}    ||= $_[0]->_build_moose_coercion }
  sub compiled_coercion      { $_[0]{compiled_coercion} ||= $_[0]->_build_compiled_coercion }
  sub frozen                 { $_[0]{frozen}            ||= 0 }
  sub coercion_generator     { $_[0]{coercion_generator} }
  sub parameters             { $_[0]{parameters} }
  
  sub has_library            { exists $_[0]{library} }
  sub has_type_constraint    { defined $_[0]{type_constraint} } # sic
  sub has_coercion_generator { exists $_[0]{coercion_generator} }
  sub has_parameters         { exists $_[0]{parameters} }
  
  sub add
  {
  	my $class = shift;
  	my ($x, $y, $swap) = @_;
  	
  	Types::TypeTiny::TypeTiny->check($x) and return $x->plus_fallback_coercions($y);
  	Types::TypeTiny::TypeTiny->check($y) and return $y->plus_coercions($x);
  	
  	_croak "Attempt to add $class to something that is not a $class"
  		unless blessed($x) && blessed($y) && $x->isa($class) && $y->isa($class);
  
  	($y, $x) = ($x, $y) if $swap;
  
  	my %opts;
  	if ($x->has_type_constraint and $y->has_type_constraint and $x->type_constraint == $y->type_constraint)
  	{
  		$opts{type_constraint} = $x->type_constraint;
  	}
  	elsif ($x->has_type_constraint and $y->has_type_constraint)
  	{
  #		require Type::Tiny::Union;
  #		$opts{type_constraint} = "Type::Tiny::Union"->new(
  #			type_constraints => [ $x->type_constraint, $y->type_constraint ],
  #		);
  	}
  	$opts{display_name} ||= "$x+$y";
  	delete $opts{display_name} if $opts{display_name} eq '__ANON__+__ANON__';
  	
  	my $new = $class->new(%opts);
  	$new->add_type_coercions( @{$x->type_coercion_map} );
  	$new->add_type_coercions( @{$y->type_coercion_map} );
  	return $new;
  }
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	
  	if ($self->has_library and not $self->is_anon)
  	{
  		return sprintf("%s::%s", $self->library, $self->name);
  	}
  	
  	return $self->name;
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub _clear_compiled_coercion {
  	delete $_[0]{_overload_coderef};
  	delete $_[0]{compiled_coercion};
  }
  
  sub freeze { $_[0]{frozen} = 1; $_[0] }
  
  sub coerce
  {
  	my $self = shift;
  	return $self->compiled_coercion->(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	my $r = $self->coerce(@_);
  	$self->type_constraint->assert_valid($r)
  		if $self->has_type_constraint;
  	return $r;
  }
  
  sub has_coercion_for_type
  {
  	my $self = shift;
  	my $type = Types::TypeTiny::to_TypeTiny($_[0]);
  	
  	return "0 but true"
  		if $self->has_type_constraint && $type->is_a_type_of($self->type_constraint);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $type->is_a_type_of($c->[$i]);
  	}
  	return;
  }
  
  sub has_coercion_for_value
  {
  	my $self = shift;
  	local $_ = $_[0];
  	
  	return "0 but true"
  		if $self->has_type_constraint && $self->type_constraint->check(@_);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $c->[$i]->check(@_);
  	}
  	return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	my @args = @_;
  	
  	_croak "Attempt to add coercion code to a Type::Coercion which has been frozen" if $self->frozen;
  	
  	while (@args)
  	{
  		my $type     = Types::TypeTiny::to_TypeTiny(shift @args);
  		my $coercion = shift @args;
  		
  		_croak "Types must be blessed Type::Tiny objects"
  			unless Types::TypeTiny::TypeTiny->check($type);
  		_croak "Coercions must be code references or strings"
  			unless Types::TypeTiny::StringLike->check($coercion) || Types::TypeTiny::CodeLike->check($coercion);
  		
  		push @{$self->type_coercion_map}, $type, $coercion;
  	}
  	
  	$self->_clear_compiled_coercion;
  	return $self;
  }
  
  sub _build_compiled_coercion
  {
  	my $self = shift;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return sub { $_[0] } unless @mishmash;
  
  	if ($self->can_be_inlined)
  	{
  		return Eval::TypeTiny::eval_closure(
  			source      => sprintf('sub ($) { %s }', $self->inline_coercion('$_[0]')),
  			description => sprintf("compiled coercion '%s'", $self),
  		);
  	}
  
  	# These arrays will be closed over.
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub,
  			$types[$i]->can_be_inlined ? sprintf('if (%s)', $types[$i]->inline_check('$_[0]')) :
  			sprintf('if ($checks[%d]->(@_))', $i);
  		push @sub,
  			!defined($codes[$i])
  				? sprintf('  { return $_[0] }') :
  			Types::TypeTiny::StringLike->check($codes[$i])
  				? sprintf('  { local $_ = $_[0]; return( %s ) }', $codes[$i]) :
  			sprintf('  { local $_ = $_[0]; return $codes[%d]->(@_) }', $i);
  	}
  	
  	push @sub, 'return $_[0];';
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', join qq[\n], @sub),
  		description => sprintf("compiled coercion '%s'", $self),
  		environment => {
  			'@checks' => [ map $_->compiled_check, @types ],
  			'@codes'  => \@codes,
  		},
  	);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	return
  		if $self->has_type_constraint
  		&& !$self->type_constraint->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type, $converter) = splice(@mishmash, 0, 2);
  		return unless $type->can_be_inlined;
  		return unless Types::TypeTiny::StringLike->check($converter);
  	}
  	return !!1;
  }
  
  sub _source_type_union
  {
  	my $self = shift;
  	
  	my @r;
  	push @r, $self->type_constraint if $self->has_type_constraint;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type) = splice(@mishmash, 0, 2);
  		push @r, $type;
  	}
  	
  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@r, tmp => 1);
  }
  
  sub inline_coercion
  {
  	my $self = shift;
  	my $varname = $_[0];
  	
  	_croak "This coercion cannot be inlined" unless $self->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return "($varname)" unless @mishmash;
  	
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub, sprintf('(%s) ?', $types[$i]->inline_check($varname));
  		push @sub,
  			(defined($codes[$i]) && ($varname eq '$_'))
  				? sprintf('scalar(%s) :', $codes[$i]) :
  			defined($codes[$i])
  				? sprintf('do { local $_ = %s; scalar(%s) } :', $varname, $codes[$i]) :
  			sprintf('%s :', $varname);
  	}
  	
  	push @sub, "$varname";
  	
  	"@sub";
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	my %options = ();
  	$options{type_coercion_map} = [ $self->freeze->_codelike_type_coercion_map('moose_type') ];
  	$options{type_constraint}   = $self->type_constraint if $self->has_type_constraint;
  	
  	require Moose::Meta::TypeCoercion;
  	my $r = "Moose::Meta::TypeCoercion"->new(%options);
  	
  	return $r;
  }
  
  sub _codelike_type_coercion_map
  {
  	my $self = shift;
  	my $modifier = $_[0];
  	
  	my @orig = @{ $self->type_coercion_map };
  	my @new;
  	
  	while (@orig)
  	{
  		my ($type, $converter) = splice(@orig, 0, 2);
  		
  		push @new, $modifier ? $type->$modifier : $type;
  		
  		if (Types::TypeTiny::CodeLike->check($converter))
  		{
  			push @new, $converter;
  		}
  		else
  		{
  			Eval::TypeTiny::eval_closure(
  				source      => sprintf('sub { local $_ = $_[0]; %s }', $converter),
  				description => sprintf("temporary compiled converter from '%s'", $type),
  			);
  		}
  	}
  	
  	return @new;
  }
  
  sub is_parameterizable
  {
  	shift->has_coercion_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  sub parameterize
  {
  	my $self = shift;
  	return $self unless @_;
  	$self->is_parameterizable
  		or _croak "Constraint '%s' does not accept parameters", "$self";
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  	
  	return ref($self)->new(
  		type_constraint    => $self->type_constraint,
  		type_coercion_map  => [ $self->coercion_generator->($self, $self->type_constraint, @_) ],
  		parameters         => \@_,
  		frozen             => 1,
  	);
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] eq 'Moose::Meta::TypeCoercion')
  	{
  		return !!1;
  	}
  	
  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] =~ /^Moose/ and my $r = $self->moose_coercion->isa(@_))
  	{
  		return $r;
  	}
  	
  	$self->SUPER::isa(@_);
  }
  
  sub can
  {
  	my $self = shift;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can(@_))
  	{
  		return sub { $method->(shift->moose_coercion, @_) };
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can($m))
  	{
  		return $method->($self->moose_coercion, @_);
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  # Private Moose method, but Moo uses this...
  sub _compiled_type_coercion
  {
  	my $self = shift;
  	if (@_)
  	{
  		my $thing = $_[0];
  		if (blessed($thing) and $thing->isa("Type::Coercion"))
  		{
  			$self->add_type_coercions(@{$thing->type_coercion_map});
  		}
  		elsif (Types::TypeTiny::CodeLike->check($thing))
  		{
  			require Types::Standard;
  			$self->add_type_coercions(Types::Standard::Any(), $thing);
  		}
  	}
  	$self->compiled_coercion;
  }
  
  *compile_type_coercion = \&compiled_coercion;
  sub meta { _croak("Not really a Moose::Meta::TypeCoercion. Sorry!") }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion - a set of coercions to a particular target type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< add($c1, $c2) >>
  
  Create a Type::Coercion from two existing Type::Coercion objects.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<name>
  
  A name for the coercion. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous coercion.
  
  =item C<display_name>
  
  A name to display for the coercion when stringified. These don't have
  to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<library>
  
  The package name of the type library this coercion is associated with.
  Optional. Informational only: setting this attribute does not install
  the coercion into the package.
  
  =item C<type_constraint>
  
  Weak reference to the target type constraint (i.e. the type constraint which
  the output of coercion coderefs is expected to conform to).
  
  =item C<type_coercion_map>
  
  Arrayref of source-type/code pairs. Don't set this in the constructor; use
  the C<add_type_coercions> method instead.
  
  =item C<< compiled_coercion >>
  
  Coderef to coerce a value (C<< $_[0] >>).
  
  The general point of this attribute is that you should not set it, and
  rely on the lazily-built default. Type::Coerce will usually generate a
  pretty fast coderef, inlining all type constraint checks, etc.
  
  =item C<moose_coercion>
  
  A L<Moose::Meta::TypeCoercion> object equivalent to this one. Don't set this
  manually; rely on the default built one.
  
  =item C<frozen>
  
  Boolean; default false. A frozen coercion cannot have C<add_type_coercions>
  called upon it.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_type_constraint>, C<has_library>
  
  Predicate methods.
  
  =item C<is_anon>
  
  Returns true iff the coercion does not have a C<name>.
  
  =item C<< qualified_name >>
  
  For non-anonymous coercions that have a library, returns a qualified
  C<< "Library::Type" >> sort of name. Otherwise, returns the same as C<name>.
  
  =item C<< add_type_coercions($type1, $code1, ...) >>
  
  Takes one or more pairs of L<Type::Tiny> constraints and coercion code,
  creating an ordered list of source types and coercion codes.
  
  Coercion codes can be expressed as either a string of Perl code (this
  includes objects which overload stringification), or a coderef (or object
  that overloads coderefification). In either case, the value to be coerced
  is C<< $_ >>.
  
  =item C<< coerce($value) >>
  
  Coerce the value to the target type.
  
  Returns the coerced value, or the original value if no coercion was
  possible.
  
  =item C<< assert_coerce($value) >>
  
  Coerce the value to the target type, and throw an exception if the result
  does not validate against the target type constraint.
  
  Returns the coerced value.
  
  =item C<< has_coercion_for_type($source_type) >>
  
  Returns true iff this coercion has a coercion from the source type.
  
  Returns the special string C<< "0 but true" >> if no coercion should
  actually be necessary for this type. (For example, if a coercion coerces
  to a theoretical "Number" type, there is probably no coercion necessary
  for values that already conform to the "Integer" type.)
  
  =item C<< has_coercion_for_value($value) >>
  
  Returns true iff the value could be coerced by this coercion.
  
  Returns the special string C<< "0 but true" >> if no coercion would be
  actually be necessary for this value (due to it already meeting the target
  type constraint).
  
  =item C<< can_be_inlined >>
  
  Returns true iff the coercion can be inlined.
  
  =item C<< inline_coercion($varname) >>
  
  Much like C<inline_coerce> from L<Type::Tiny>.
  
  =item C<< freeze >>
  
  Set C<frozen> to true. There is no C<unfreeze>. Called automatically by
  L<Type::Tiny> sometimes.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeCoercion.
  
  =back
  
  The following methods are used for parameterized coercions, but are not
  fully documented because they may change in the near future:
  
  =over
  
  =item C<< coercion_generator >>
  
  =item C<< has_coercion_generator >>
  
  =item C<< has_parameters >>
  
  =item C<< is_parameterizable >>
  
  =item C<< is_parameterized >>
  
  =item C<< parameterize(@params) >>
  
  =item C<< parameters >>
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_coercion >>
  
  =item C<< meta >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<coerce>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<has_coercion_for_value>.
  
  =item *
  
  Addition is overloaded to call C<add>.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item B<< Attempt to add coercion code to a Type::Coercion which has been frozen >>
  
  Type::Tiny type constraints are designed as immutable objects. Once you've
  created a constraint, rather than modifying it you generally create child
  constraints to do what you need.
  
  Type::Coercion objects, on the other hand, are mutable. Coercion routines
  can be added at any time during the object's lifetime.
  
  Sometimes Type::Tiny needs to freeze a Type::Coercion object to prevent this.
  In L<Moose> and L<Mouse> code this is likely to happen as soon as you use a
  type constraint in an attribute.
  
  Workarounds:
  
  =over
  
  =item *
  
  Define as many of your coercions as possible within type libraries, not
  within the code that uses the type libraries. The type library will be
  evaluated relatively early, likely before there is any reason to freeze
  a coercion.
  
  =item *
  
  If you do need to add coercions to a type within application code outside
  the type library, instead create a subtype and add coercions to that. The
  C<plus_coercions> method provided by L<Type::Tiny> should make this simple.
  
  =back
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Types::Standard>.
  
  L<Type::Coercion::Union>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_COERCION

$fatpacked{"Type/Coercion/FromMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_FROMMOOSE';
  package Type::Coercion::FromMoose;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::FromMoose::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::FromMoose::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	my @from = @{ $self->type_constraint->moose_type->coercion->type_coercion_map };
  
  	my @return;
  	while (@from)
  	{
  		my ($type, $code) = splice(@from, 0, 2);
  		$type = Moose::Util::TypeConstraints::find_type_constraint($type)
  			unless ref $type;
  		push @return, Types::TypeTiny::to_TypeTiny($type), $code;
  	}
  	
  	return \@return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::FromMoose not currently supported" if @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::FromMoose - a set of coercions borrowed from Moose
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  Moose.
  
  This is mostly for internal purposes.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_FROMMOOSE

$fatpacked{"Type/Coercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_UNION';
  package Type::Coercion::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::Union::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);
  	$type->isa('Type::Tiny::Union')
  		or _croak "Type::Coercion::Union must be used in conjunction with Type::Tiny::Union";
  	
  	my @c;
  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		push @c, @{$tc->coercion->type_coercion_map};
  	}
  	return \@c;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::Union not currently supported" if @_;
  }
  
  # sub _build_moose_coercion ???
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::Union - a set of coercions to a union type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  the child constraints of the union type constraint.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion::Union>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_UNION

$fatpacked{"Type/Library.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_LIBRARY';
  package Type::Library;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Library::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Library::VERSION   = '0.038';
  }
  
  use Eval::TypeTiny qw< eval_closure >;
  use Scalar::Util qw< blessed >;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny >;
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN { *NICE_PROTOTYPES = ($] >= 5.014) ? sub () { !!1 } : sub () { !!0 } };
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  {
  	my $got_subname;
  	sub _subname ($$)
  	{
  		$got_subname = 1 && goto \&Sub::Name::subname
  			if $got_subname || eval "require Sub::Name";
  		return $_[1];
  	}
  }
  
  sub _exporter_validate_opts
  {
  	my $class = shift;
  	
  	no strict "refs";
  	my $into  = $_[0]{into};
  	push @{"$into\::ISA"}, $class if $_[0]{base};
  	
  	return $class->SUPER::_exporter_validate_opts(@_);
  }
  
  sub _exporter_expand_tag
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	$name eq 'types'     and return map [ "$_"        => $value ], $class->type_names;
  	$name eq 'is'        and return map [ "is_$_"     => $value ], $class->type_names;
  	$name eq 'assert'    and return map [ "assert_$_" => $value ], $class->type_names;
  	$name eq 'to'        and return map [ "to_$_"     => $value ], $class->type_names;
  	$name eq 'coercions' and return map [ "$_"        => $value ], $class->coercion_names;
  	
  	if ($name eq 'all')
  	{
  		no strict "refs";
  		return (
  			map(
  				[ "+$_" => $value ],
  				$class->type_names,
  			),
  			map(
  				[ $_ => $value ],
  				$class->coercion_names,
  				@{"$class\::EXPORT"},
  				@{"$class\::EXPORT_OK"},
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_expand_tag(@_);
  }
  
  sub _mksub
  {
  	my $class = shift;
  	my ($type, $post_method) = @_;
  	$post_method ||= q();
  	
  	my $source = $type->is_parameterizable
  		? sprintf(
  			q{
  				sub (%s) {
  					my $params; $params = shift if ref($_[0]) eq q(ARRAY);
  					my $t = $params ? $type->parameterize(@$params) : $type;
  					@_ && wantarray ? return($t%s, @_) : return $t%s;
  				}
  			},
  			NICE_PROTOTYPES ? q(;$) : q(;@),
  			$post_method,
  			$post_method,
  		)
  		: sprintf(
  			q{ sub () { $type%s if $] } },
  			$post_method,
  		);
  		
  	return _subname(
  		$type->qualified_name,
  		eval_closure(
  			source      => $source,
  			description => sprintf("exportable function '%s'", $type),
  			environment => {'$type' => \$type},
  		),
  	);
  }
  
  sub _exporter_permitted_regexp
  {
  	my $class = shift;
  	
  	my $inherited = $class->SUPER::_exporter_permitted_regexp(@_);
  	my $types = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->type_names;
  	my $coercions = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->coercion_names;
  	
  	qr{^(?:
  		$inherited
  		| (?: (?:is_|to_|assert_)? (?:$types) )
  		| (?:$coercions)
  	)$}xms;
  }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	if ($name =~ /^\+(.+)/ and $class->has_type($1))
  	{
  		my $type   = $1;
  		my $value2 = +{%{$value||{}}};
  		
  		return map $class->_exporter_expand_sub($_, $value2, $globals),
  			$type, "is_$type", "assert_$type", "to_$type";
  	}
  	
  	if (my $type = $class->get_type($name))
  	{
  		my $post_method = q();
  		$post_method = '->mouse_type' if $globals->{mouse};
  		$post_method = '->moose_type' if $globals->{moose};
  		return ($name => $class->_mksub($type, $post_method)) if $post_method;
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  #sub _exporter_install_sub
  #{
  #	my $class = shift;
  #	my ($name, $value, $globals, $sym) = @_;
  #	
  #	warn sprintf(
  #		'Exporter %s exporting %s with prototype %s',
  #		$class,
  #		$name,
  #		prototype($sym),
  #	);
  #	
  #	$class->SUPER::_exporter_install_sub(@_);
  #}
  
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	my $into = $globals->{into}
  		or _croak("Parameter 'into' not supplied");
  	
  	if ($globals->{declare})
  	{
  		my $declared = sub (;$)
  		{
  			my $params; $params = shift if ref($_[0]) eq "ARRAY";
  			my $type = $into->get_type($name);
  			unless ($type)
  			{
  				_croak "Cannot parameterize a non-existant type" if $params;
  				$type = $name;
  			}
  			
  			my $t = $params ? $type->parameterize(@$params) : $type;
  			@_ && wantarray ? return($t, @_) : return $t;
  		};
  		
  		return(
  			$name,
  			_subname(
  				"$class\::$name",
  				NICE_PROTOTYPES ? sub (;$) { goto $declared } : sub (;@) { goto $declared },
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_fail(@_);
  }
  
  sub meta
  {
  	no strict "refs";
  	no warnings "once";
  	return $_[0] if blessed $_[0];
  	${"$_[0]\::META"} ||= bless {}, $_[0];
  }
  
  sub add_type
  {
  	my $meta  = shift->meta;
  	my $class = blessed($meta);
  	
  	my $type =
  		ref($_[0]) =~ /^Type::Tiny\b/  ? $_[0] :
  		blessed($_[0])                 ? to_TypeTiny($_[0]) :
  		ref($_[0]) eq q(HASH)          ? "Type::Tiny"->new(library => $class, %{$_[0]}) :
  		"Type::Tiny"->new(library => $class, @_);
  	my $name = $type->{name};
  	
  	$meta->{types} ||= {};
  	_croak 'Type %s already exists in this library', $name if $meta->has_type($name);
  	_croak 'Type %s conflicts with coercion of same name', $name if $meta->has_coercion($name);
  	_croak 'Cannot add anonymous type to a library' if $type->is_anon;
  	$meta->{types}{$name} = $type;
  	
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	
  	# There is an inlined coercion available, but don't use that because
  	# additional coercions can be added *after* the type has been installed
  	# into the library.
  	#
  	# XXX: maybe we can use it if the coercion is frozen???
  	#
  	*{"$class\::$name"}        = $class->_mksub($type);
  	*{"$class\::is_$name"}     = _subname "is_"    .$type->qualified_name, $type->compiled_check;
  	*{"$class\::to_$name"}     = _subname "to_"    .$type->qualified_name, sub ($) { $type->coerce($_[0]) };
  	*{"$class\::assert_$name"} = _subname "assert_".$type->qualified_name, $type->_overload_coderef;
  	
  	return $type;
  }
  
  sub get_type
  {
  	my $meta = shift->meta;
  	$meta->{types}{$_[0]};
  }
  
  sub has_type
  {
  	my $meta = shift->meta;
  	exists $meta->{types}{$_[0]};
  }
  
  sub type_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{types} };
  }
  
  sub add_coercion
  {
  	require Type::Coercion;
  	my $meta = shift->meta;
  	my $c    = blessed($_[0]) ? $_[0] : "Type::Coercion"->new(@_);
  	my $name = $c->name;
  
  	$meta->{coercions} ||= {};
  	_croak 'Coercion %s already exists in this library', $name if $meta->has_coercion($name);
  	_croak 'Coercion %s conflicts with type of same name', $name if $meta->has_type($name);
  	_croak 'Cannot add anonymous type to a library' if $c->is_anon;
  	$meta->{coercions}{$name} = $c;
  
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	my $class = blessed($meta);
  	*{"$class\::$name"} = $class->_mksub($c);
  	
  	return $c;
  }
  
  sub get_coercion
  {
  	my $meta = shift->meta;
  	$meta->{coercions}{$_[0]};
  }
  
  sub has_coercion
  {
  	my $meta = shift->meta;
  	exists $meta->{coercions}{$_[0]};
  }
  
  sub coercion_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{coercions} };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX::Types-like
  
  =head1 NAME
  
  Type::Library - tiny, yet Moo(se)-compatible type libraries
  
  =head1 SYNOPSIS
  
     package Types::Mine {
        use Scalar::Util qw(looks_like_number);
        use Type::Library -base;
        use Type::Tiny;
        
        my $NUM = "Type::Tiny"->new(
           name       => "Number",
           constraint => sub { looks_like_number($_) },
           message    => sub { "$_ ain't a number" },
        );
        
        __PACKAGE__->meta->add_type($NUM);
     }
        
     package Ermintrude {
        use Moo;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Bullwinkle {
        use Moose;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Maisy {
        use Mouse;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Library> is a tiny class for creating MooseX::Types-like type
  libraries which are compatible with Moo, Moose and Mouse.
  
  If you're reading this because you want to create a type library, then
  you're probably better off reading L<Type::Tiny::Manual::Libraries>.
  
  =head2 Methods
  
  A type library is a singleton class. Use the C<meta> method to get a blessed
  object which other methods can get called on. For example:
  
     Types::Mine->meta->add_type($foo);
  
  =begin trustme
  
  =item meta
  
  =end trustme
  
  =over
  
  =item C<< add_type($type) >> or C<< add_type(%opts) >>
  
  Add a type to the library. If C<< %opts >> is given, then this method calls
  C<< Type::Tiny->new(%opts) >> first, and adds the resultant type.
  
  Adding a type named "Foo" to the library will automatically define four
  functions in the library's namespace:
  
  =over
  
  =item C<< Foo >>
  
  Returns the Type::Tiny object.
  
  =item C<< is_Foo($value) >>
  
  Returns true iff $value passes the type constraint.
  
  =item C<< assert_Foo($value) >>
  
  Returns $value iff $value passes the type constraint. Dies otherwise.
  
  =item C<< to_Foo($value) >>
  
  Coerces the value to the type.
  
  =back
  
  =item C<< get_type($name) >>
  
  Gets the C<Type::Tiny> object corresponding to the name.
  
  =item C<< has_type($name) >>
  
  Boolean; returns true if the type exists in the library.
  
  =item C<< type_names >>
  
  List all types defined by the library.
  
  =item C<< add_coercion($c) >> or C<< add_coercion(%opts) >>
  
  Add a standalone coercion to the library. If C<< %opts >> is given, then
  this method calls C<< Type::Coercion->new(%opts) >> first, and adds the
  resultant coercion.
  
  Adding a coercion named "FooFromBar" to the library will automatically
  define a function in the library's namespace:
  
  =over
  
  =item C<< FooFromBar >>
  
  Returns the Type::Coercion object.
  
  =back
  
  =item C<< get_coercion($name) >>
  
  Gets the C<Type::Coercion> object corresponding to the name.
  
  =item C<< has_coercion($name) >>
  
  Boolean; returns true if the coercion exists in the library.
  
  =item C<< coercion_names >>
  
  List all standalone coercions defined by the library.
  
  =item C<< import(@args) >>
  
  Type::Library-based libraries are exporters.
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< NICE_PROTOTYPES >>
  
  If this is true, then Type::Library will give parameterizable type constraints
  slightly the nicer prototype of C<< (;$) >> instead of the default C<< (;@) >>.
  This allows constructs like:
  
     ArrayRef[Int] | HashRef[Int]
  
  ... to "just work". Sadly, this constant is false on Perl < 5.14, and
  expressions like the above need lots of parentheses to do what you mean.
  
  =back
  
  =head2 Export
  
  Type libraries are exporters. For the purposes of the following examples,
  assume that the C<Types::Mine> library defines types C<Number> and C<String>.
  
     # Exports nothing.
     # 
     use Types::Mine;
     
     # Exports a function "String" which is a constant returning
     # the String type constraint.
     #
     use Types::Mine qw( String );
     
     # Exports both String and Number as above.
     #
     use Types::Mine qw( String Number );
     
     # Same.
     #
     use Types::Mine qw( :types );
     
     # Exports a sub "is_String" so that "is_String($foo)" is equivalent
     # to "String->check($foo)".
     #
     use Types::Mine qw( is_String );
     
     # Exports "is_String" and "is_Number".
     #
     use Types::Mine qw( :is );
     
     # Exports a sub "assert_String" so that "assert_String($foo)" is
     # equivalent to "String->assert_return($foo)".
     #
     use Types::Mine qw( assert_String );
     
     # Exports "assert_String" and "assert_Number".
     #
     use Types::Mine qw( :assert );
     
     # Exports a sub "to_String" so that "to_String($foo)" is equivalent
     # to "String->coerce($foo)".
     #
     use Types::Mine qw( to_String );
     
     # Exports "to_String" and "to_Number".
     #
     use Types::Mine qw( :to );
     
     # Exports "String", "is_String", "assert_String" and "coerce_String".
     #
     use Types::Mine qw( +String );
     
     # Exports everything.
     #
     use Types::Mine qw( :all );
  
  Type libraries automatically inherit from L<Exporter::Tiny>; see the
  documentation of that module for tips and tricks importing from libraries.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_LIBRARY

$fatpacked{"Type/Params.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARAMS';
  package Type::Params;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Params::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Params::VERSION   = '0.038';
  }
  
  use B qw();
  use Eval::TypeTiny;
  use Scalar::Util qw(refaddr);
  use Error::TypeTiny;
  use Error::TypeTiny::Assertion;
  use Error::TypeTiny::WrongNumberOfParameters;
  use Type::Tiny::Union;
  use Types::Standard -types;
  use Types::TypeTiny qw(CodeLike ArrayLike to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  our @EXPORT = qw( compile );
  our @EXPORT_OK = qw( multisig validate Invocant );
  
  BEGIN {
  	my $Invocant = 'Type::Tiny::Union'->new(
  		name             => 'Invocant',
  		type_constraints => [Object, ClassName],
  	);
  	sub Invocant () { $Invocant };
  };
  
  sub _mkslurpy
  {
  	my ($name, $type, $tc, $i) = @_;
  	$name = 'local $_' if $name eq '$_';
  	
  	$type eq '@'
  		? sprintf(
  			'%s = [ @_[%d..$#_] ];',
  			$name,
  			$i,
  		)
  		: sprintf(
  			'%s = (($#_-%d)%%2)==0 ? "Error::TypeTiny::WrongNumberOfParameters"->throw(message => sprintf("Odd number of elements in %%s", %s)) : +{ @_[%d..$#_] };',
  			$name,
  			$i,
  			B::perlstring("$tc"),
  			$i,
  			$i,
  		);
  }
  
  sub compile
  {
  	my (@code, %env);
  	@code = 'my (@R, %tmp, $tmp);';
  	push @code, '#placeholder';   # $code[1]
  	
  	my %options    = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my $arg        = -1;
  	my $saw_slurpy = 0;
  	my $min_args   = 0;
  	my $max_args   = 0;
  	my $saw_opt    = 0;
  	
  	while (@_)
  	{
  		++$arg;
  		my $constraint = shift;
  		my $is_optional;
  		my $is_slurpy;
  		my $varname;
  		
  		if (Bool->check($constraint))
  		{
  			$constraint = $constraint ? Any : Optional[Any];
  		}
  		
  		if (HashRef->check($constraint))
  		{
  			$constraint = to_TypeTiny($constraint->{slurpy});
  			push @code,
  				$constraint->is_a_type_of(Dict)     ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Map)      ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Tuple)    ? _mkslurpy('$_', '@', $constraint => $arg) :
  				$constraint->is_a_type_of(HashRef)  ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(ArrayRef) ? _mkslurpy('$_', '@', $constraint => $arg) :
  				Error::TypeTiny::croak("Slurpy parameter not of type HashRef or ArrayRef");
  			$varname = '$_';
  			$is_slurpy++;
  			$saw_slurpy++;
  		}
  		else
  		{
  			Error::TypeTiny::croak("Parameter following slurpy parameter") if $saw_slurpy;
  			
  			$is_optional = grep $_->{uniq} == Optional->{uniq}, $constraint->parents;
  			
  			if ($is_optional)
  			{
  				push @code, sprintf 'return @R if $#_ < %d;', $arg;
  				$saw_opt++;
  				$max_args++;
  			}
  			else
  			{
  				Error::TypeTiny::croak("Non-Optional parameter following Optional parameter") if $saw_opt;
  				$min_args++;
  				$max_args++;
  			}
  			
  			$varname = sprintf '$_[%d]', $arg;
  		}
  		
  		if ($constraint->has_coercion and $constraint->coercion->can_be_inlined)
  		{
  			push @code, sprintf(
  				'$tmp%s = %s;',
  				($is_optional ? '{x}' : ''),
  				$constraint->coercion->inline_coercion($varname)
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		elsif ($constraint->has_coercion)
  		{
  			$env{'@coerce'}[$arg] = $constraint->coercion->compiled_coercion;
  			push @code, sprintf(
  				'$tmp%s = $coerce[%d]->(%s);',
  				($is_optional ? '{x}' : ''),
  				$arg,
  				$varname,
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		
  		if ($constraint->can_be_inlined)
  		{
  			push @code, sprintf(
  				'(%s) or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				$constraint->inline_check($varname),
  				$constraint->{uniq},
  				B::perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		else
  		{
  			$env{'@check'}[$arg] = $constraint->compiled_check;
  			push @code, sprintf(
  				'%s or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				sprintf(sprintf '$check[%d]->(%s)', $arg, $varname),
  				$constraint->{uniq},
  				B::perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		
  		push @code, sprintf 'push @R, %s;', $varname;
  	}
  	
  	if ($min_args == $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ != %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  		);
  	}
  	elsif ($min_args < $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ < %d || @_ > %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  			$max_args,
  		);
  	}
  	elsif ($min_args and $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d) if @_ < %d;',
  			$min_args,
  			$min_args,
  		);
  	}
  	
  	push @code, '@R;';
  	
  	my $source  = "sub { no warnings; ".join("\n", @code)." };";
  	
  	return $source if $options{want_source};
  	
  	my $closure = eval_closure(
  		source      => $source,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => \%env,
  	);
  	
  	return {
  		min_args   => $min_args,
  		max_args   => $saw_slurpy ? undef : $max_args,
  		closure    => $closure,
  	} if $options{want_details};
  	
  	return $closure;
  }
  
  my %compiled;
  sub validate
  {
  	my $arr = shift;
  	my $sub = $compiled{ join ":", map($_->{uniq}||"\@$_->{slurpy}", @_) } ||= compile({ caller_level => 1 }, @_);
  	@_ = @$arr;
  	goto $sub;
  }
  
  sub multisig
  {
  	my %options = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my @multi = map {
  		CodeLike->check($_)  ? { closure => $_ } :
  		ArrayLike->check($_) ? compile({ want_details => 1 }, @$_) :
  		$_;
  	} @_;
  	
  	my @code = 'sub { my $r; ';
  	
  	for my $i (0 .. $#multi)
  	{
  		my $sig = $multi[$i];
  		my @cond;
  		push @cond, sprintf('@_ >= %s', $sig->{min_args}) if defined $sig->{min_args};
  		push @cond, sprintf('@_ <= %s', $sig->{max_args}) if defined $sig->{max_args};
  		push @code, sprintf('if (%s){', join(' and ', @cond)) if @cond;
  		push @code, sprintf('eval { $r = [ $multi[%d]{closure}->(@_) ] };', $i);
  		push @code, 'return(@$r) if $r;';
  		push @code, '}' if @cond;
  	}
  	
  	push @code, '"Error::TypeTiny"->throw(message => "Parameter validation failed");';
  	push @code, '}';
  	
  	eval_closure(
  		source      => \@code,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => { '@multi' => \@multi },
  	);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords evals
  
  =head1 NAME
  
  Type::Params - Params::Validate-like parameter validation using Type::Tiny type constraints and coercions
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Params qw( compile );
   use Types::Standard qw( slurpy Str ArrayRef Num );
     
   sub deposit_monies
   {
      state $check = compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      my $account = Local::BankAccount->new($sort_code, $account_number);
      $account->deposit($_) for @$monies;
   }
   
   deposit_monies("12-34-56", "11223344", 1.2, 3, 99.99);
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type::Params uses L<Type::Tiny> constraints to validate the parameters to a
  sub. It takes the slightly unorthodox approach of separating validation
  into two stages:
  
  =over
  
  =item 1.
  
  Compiling the parameter specification into a coderef; then
  
  =item 2.
  
  Using the coderef to validate parameters.
  
  =back
  
  The first stage is slow (it might take a couple of milliseconds), but you
  only need to do it the first time the sub is called. The second stage is
  fast; according to my benchmarks faster even than the XS version of
  L<Params::Validate>.
  
  If you're using a modern version of Perl, you can use the C<state> keyword
  which was a feature added to Perl in 5.10. If you're stuck on Perl 5.8, the
  example from the SYNOPSIS could be rewritten as:
  
   my $deposit_monies_check;
   sub deposit_monies
   {
      $deposit_monies_check ||= compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      ...;
   }
  
  Not quite as neat, but not awful either.
  
  There's a shortcut reducing it to one step:
  
   use Type::Params qw( validate );
   
   sub deposit_monies
   {
      my ($sort_code, $account_number, $monies) = 
         validate( \@_, Str, Str, slurpy ArrayRef[Num] );
      
      ...;
   }
  
  Type::Params has a few tricks up its sleeve to make sure performance doesn't
  suffer too much with the shortcut, but it's never going to be as fast as the
  two stage compile/execute.
  
  =begin trustme
  
  Dude, these functions are documented!
  
  =item compile
  
  =item validate
  
  =item Invocant
  
  =item multisig
  
  =end trustme
  
  =head1 COOKBOOK
  
  =head2 Positional Parameters
  
     sub nth_root
     {
        state $check = compile( Num, Num );
        my ($x, $n) = $check->(@_);
        
        return $x ** (1 / $n);
     }
  
  =head2 Method Calls
  
  Type::Params exports an additional keyword C<Invocant> on request. This is
  a type constraint accepting blessed objects and also class names.
  
     use Types::Standard qw( ClassName Object Str Int );
     use Type::Params qw( compile Invocant );
     
     # a class method
     sub new_from_json
     {
        state $check = compile( ClassName, Str );
        my ($class, $json) = $check->(@_);
        
        $class->new( from_json($json) );
     }
     
     # an object method
     sub dump
     {
        state $check = compile( Object, Int );
        my ($self, $limit) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     # can be called as either and object or class method
     sub run
     {
        state $check = compile( Invocant );
        my ($proto) = $check->(@_);
        
        my $self = ref($proto) ? $proto : $default_instance;
        $self->_run;
     }
  
  =head2 Optional Parameters
  
     use Types::Standard qw( Object Optional Int );
     
     sub dump
     {
        state $check = compile( Object, Optional[Int] );
        my ($self, $limit) = $check->(@_);
        $limit //= 0;
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     $obj->dump(1);      # ok
     $obj->dump();       # ok
     $obj->dump(undef);  # dies
  
  =head2 Slurpy Parameters
  
     use Types::Standard qw( slurpy ClassName HashRef );
     
     sub new
     {
        state $check = compile( ClassName, slurpy HashRef );
        my ($class, $ref) = $check->(@_);
        bless $ref => $class;
     }
     
     __PACKAGE__->new(foo => 1, bar => 2);
  
  The following types from L<Types::Standard> can be made slurpy:
  C<ArrayRef>, C<Tuple>, C<HashRef>, C<Map>, C<Dict>. Hash-like types
  will die if an odd number of elements are slurped in.
  
  A check may only have one slurpy parameter, and it must be the last
  parameter.
  
  =head2 Named Parameters
  
  Just use a slurpy C<Dict>:
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub dump
     {
        state $check = compile(
           slurpy Dict[
              var    => Ref,
              limit  => Optional[Int],
           ],
        );
        my ($arg) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $arg->{limit};
        print Data::Dumper::Dumper($arg->{var});
     }
     
     dump(var => $foo, limit => 1);   # ok
     dump(var => $foo);               # ok
     dump(limit => 1);                # dies
  
  =head2 Mixed Positional and Named Parameters
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub my_print
     {
        state $check = compile(
           Str,
           slurpy Dict[
              colour => Optional[Str],
              size   => Optional[Int],
           ],
        );
        my ($string, $arg) = $check->(@_);
     }
     
     my_print("Hello World", colour => "blue");
  
  =head2 Coercions
  
  Coercions will automatically be applied for I<all> type constraints that have
  a coercion associated.
  
     use Type::Utils;
     use Types::Standard qw( Int Num );
     
     my $RoundedInt = declare as Int;
     coerce $RoundedInt, from Num, q{ int($_) };
     
     sub set_age
     {
        state $check = compile( Object, $RoundedInt );
        my ($self, $age) = $check->(@_);
        
        $self->{age} = $age;
     }
     
     $obj->set_age(32.5);   # ok; coerced to "32".
  
  Coercions carry over into structured types such as C<ArrayRef> automatically:
  
     sub delete_articles
     {
        state $check = compile( Object, slurpy ArrayRef[$RoundedInt] );
        my ($db, $articles) = $check->(@_);
        
        $db->select_article($_)->delete for @$articles;
     }
     
     # delete articles 1, 2 and 3
     delete_articles($my_db, 1.1, 2.2, 3.3);
  
  If type C<Foo> has coercions from C<Str> and C<ArrayRef> and you want to
  B<prevent> coercion, then use:
  
     state $check = compile( Foo->no_coercions );
  
  Or if you just want to prevent coercion from C<Str>, use:
  
     state $check = compile( Foo->minus_coercions(Str) );
  
  Or maybe add an extra coercion:
  
     state $check = compile(
        Foo->plus_coercions(Int, q{ Foo->new_from_number($_) }),
     );
  
  Note that the coercion is specified as a string of Perl code. This is usually
  the fastest way to do it, but a coderef is also accepted. Either way, the
  value to be coerced is C<< $_ >>.
  
  =head2 Alternatives
  
  Type::Params can export a C<multisig> function that compiles multiple
  alternative signatures into one, and uses the first one that works:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        [ HashRef, Num ],
        [ CodeRef ],
     );
     
     my ($int, $arrayref) = $check->( 1, [] );
     my ($hashref, $num)  = $check->( {}, 1.1 );
     my ($code)           = $check->( sub { 1 } );
     
     $check->( sub { 1 }, 1.1 );  # throws an exception
  
  Coercions, slurpy parameters, etc still work.
  
  There's currently no indication of which of the multiple signatures
  succeeded.
  
  The present implementation involves compiling each signature independently,
  and trying them each (in their given order!) in an C<eval> block. The only
  slightly intelligent part is that it checks if C<< scalar(@_) >> fits into
  the signature properly (taking into account optional and slurpy parameters),
  and skips evals which couldn't possibly succeed.
  
  It's also possible to list coderefs as alternatives in C<multisig>:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        sub { ... },
        [ HashRef, Num ],
        [ CodeRef ],
     );
  
  The coderef is expected to die if that alternative should be abandoned (and
  the next alternative tried), or return the list of accepted parameters. Here's
  a full example:
  
     sub get_from {
        state $check = multisig(
           [ Int, ArrayRef ],
           [ Str, HashRef ],
           sub {
              my ($meth, $obj);
              die unless is_Object($obj);
              die unless $obj->can($meth);
              return ($meth, $obj);
           },
        );
        my ($needle, $haystack) = $check->(@_);
        
        is_HashRef($haystack)  ? $haystack->{$needle} :
        is_ArrayRef($haystack) ? $haystack->[$needle] :
        is_Object($haystack)   ? $haystack->$needle   :
        die;
     }
     
     get_from(0, \@array);      # returns $array[0]
     get_from('foo', \%hash);   # returns $hash{foo}
     get_from('foo', $obj);     # returns $obj->foo
  
  =head1 COMPARISON WITH PARAMS::VALIDATE
  
  L<Type::Params> is not really a drop-in replacement for L<Params::Validate>;
  the API differs far too much to claim that. Yet it performs a similar task,
  so it makes sense to compare them.
  
  =over
  
  =item *
  
  Type::Params will tend to be faster if you've got a sub which is called
  repeatedly, but may be a little slower than Params::Validate for subs that
  are only called a few times. This is because it does a bunch of work the
  first time your sub is called to make subsequent calls a lot faster.
  
  =item *
  
  Type::Params is mostly geared towards positional parameters, while
  Params::Validate seems to be primarily aimed at named parameters. (Though
  either works for either.) Params::Validate doesn't appear to have a
  particularly natural way of validating a mix of positional and named
  parameters.
  
  =item *
  
  Type::Utils allows you to coerce parameters. For example, if you expect
  a L<Path::Tiny> object, you could coerce it from a string.
  
  =item *
  
  Params::Validate allows you to supply defaults for missing parameters;
  Type::Params does not, but you may be able to use coercion from Undef.
  
  =item *
  
  If you are primarily writing object-oriented code, using Moose or similar,
  and you are using Type::Tiny type constraints for your attributes, then
  using Type::Params allows you to use the same constraints for method calls.
  
  =item *
  
  Type::Params comes bundled with Types::Standard, which provides a much
  richer vocabulary of types than the type validation constants that come
  with Params::Validate. For example, Types::Standard provides constraints
  like C<< ArrayRef[Int] >> (an arrayref of integers), while the closest from
  Params::Validate is C<< ARRAYREF >>, which you'd need to supplement with
  additional callbacks if you wanted to check that the arrayref contained
  integers.
  
  Whatsmore, Type::Params doesn't just work with Types::Standard, but also
  any other Type::Tiny type constraints.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>, L<Type::Coercion>, L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARAMS

$fatpacked{"Type/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARSER';
  package Type::Parser;
  
  use strict;
  use warnings;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  
  # Token types
  # 
  sub TYPE      () { "TYPE" };
  sub QUOTELIKE () { "QUOTELIKE" };
  sub STRING    () { "STRING" };
  sub CLASS     () { "CLASS" };
  sub L_BRACKET () { "L_BRACKET" };
  sub R_BRACKET () { "R_BRACKET" };
  sub COMMA     () { "COMMA" };
  sub SLURPY    () { "SLURPY" };
  sub UNION     () { "UNION" };
  sub INTERSECT () { "INTERSECT" };
  sub NOT       () { "NOT" };
  sub L_PAREN   () { "L_PAREN" };
  sub R_PAREN   () { "R_PAREN" };
  sub MYSTERY   () { "MYSTERY" };
  
  our @EXPORT_OK = qw( eval_type _std_eval parse );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  Evaluate: {
  	
  	sub parse
  	{
  		my $str = $_[0];
  		my $parser = "Type::Parser::AstBuilder"->new(input => $str);
  		$parser->build;
  		wantarray ? ($parser->ast, $parser->remainder) : $parser->ast;
  	}
  	
  	sub extract_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		wantarray ? (_eval_type($parsed, $reg), $tail) : _eval_type($parsed, $reg);
  	}
  	
  	sub eval_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		_croak("Unexpected tail on type expression: $tail") if $tail =~ /\S/sm;
  		return _eval_type($parsed, $reg);
  	}
  	
  	my $std;
  	sub _std_eval
  	{
  		require Type::Registry;
  		unless ($std)
  		{
  			$std = "Type::Registry"->new;
  			$std->add_types(-Standard);
  		}
  		eval_type($_[0], $std);
  	}
  	
  	sub _eval_type
  	{
  		my ($node, $reg) = @_;
  		
  		$node = _simplify_expression($node);
  		
  		if ($node->{type} eq "list")
  		{
  			return map _eval_type($_, $reg), @{$node->{list}};
  		}
  		
  		if ($node->{type} eq "union")
  		{
  			require Type::Tiny::Union;
  			return "Type::Tiny::Union"->new(
  				type_constraints => [ map _eval_type($_, $reg), @{$node->{union}} ],
  			);
  		}
  		
  		if ($node->{type} eq "intersect")
  		{
  			require Type::Tiny::Intersection;
  			return "Type::Tiny::Intersection"->new(
  				type_constraints => [ map _eval_type($_, $reg), @{$node->{intersect}} ],
  			);
  		}
  		
  		if ($node->{type} eq "slurpy")
  		{
  			return +{ slurpy => _eval_type($node->{of}, $reg) };
  		}
  		
  		if ($node->{type} eq "complement")
  		{
  			return _eval_type($node->{of}, $reg)->complementary_type;
  		}
  		
  		if ($node->{type} eq "parameterized")
  		{
  			my $base = _eval_type($node->{base}, $reg);
  			
  			return $base unless $base->is_parameterizable || $node->{params};
  			return $base->parameterize($node->{params} ? _eval_type($node->{params}, $reg) : ());
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq CLASS)
  		{
  			my $class = substr($node->{token}->spelling, 0, length($node->{token}->spelling) - 2);
  			require Type::Tiny::Class;
  			return "Type::Tiny::Class"->new(class => $class);
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq QUOTELIKE)
  		{
  			return eval($node->{token}->spelling); #ARGH
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq STRING)
  		{
  			return $node->{token}->spelling;
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq TYPE)
  		{
  			my $t = $node->{token}->spelling;
  			my $r;
  			if ($t =~ /^(.+)::(\w+)$/)
  			{
  				require Types::TypeTiny;
  				my $library = $1; $t = $2;
  				eval "require $library;";
  				$r =
  					$library->isa('MooseX::Types::Base')  ? Types::TypeTiny::to_TypeTiny(Moose::Util::TypeConstraints::find_type_constraint($library->get_type($t))) :
  					$library->can("get_type")             ? $library->get_type($t) :
  					$reg->simple_lookup("$library\::$t", 1);
  				}
  			else
  			{
  				$r = $reg->simple_lookup($t, 1);
  			}
  			$r or _croak("%s is not a known type constraint", $node->{token}->spelling);
  			return $r;
  		}
  	}
  	
  	sub _simplify_expression
  	{
  		my $expr = shift;
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq COMMA)
  		{
  			return _simplify("list", COMMA, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq UNION)
  		{
  			return _simplify("union", UNION, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq INTERSECT)
  		{
  			return _simplify("intersect", INTERSECT, $expr);
  		}
  		
  		return $expr;
  	}
  	
  	sub _simplify
  	{
  		my $type = shift;
  		my $op   = shift;
  		
  		my @list;
  		for my $expr ($_[0]{lhs}, $_[0]{rhs})
  		{
  			if ($expr->{type} eq "expression" and $expr->{op}[0] eq $op)
  			{
  				my $simple = _simplify($type, $op, $expr);
  				push @list, @{ $simple->{$type} };
  			}
  			else
  			{
  				push @list, $expr;
  			}
  		}
  		
  		return { type => $type, $type => \@list };
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::AstBuilder;
  	
  	sub new
  	{
  		my $class = shift;
  		bless { @_ }, $class;
  	}
  	
  	our %precedence = (
  #		Type::Parser::COMMA()     , 1 ,
  		Type::Parser::UNION()     , 2 ,
  		Type::Parser::INTERSECT() , 3 ,
  		Type::Parser::NOT()       , 4 ,
  	);
  	
  	sub _parse_primary
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		$tokens->assert_not_empty;
  		
  		if ($tokens->peek(0)->type eq Type::Parser::NOT)
  		{
  			$tokens->eat(Type::Parser::NOT);
  			$tokens->assert_not_empty;
  			return {
  				type  => "complement",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::SLURPY)
  		{
  			$tokens->eat(Type::Parser::SLURPY);
  			$tokens->assert_not_empty;
  			return {
  				type  => "slurpy",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::L_PAREN)
  		{
  			$tokens->eat(Type::Parser::L_PAREN);
  			my $r = $self->_parse_expression;
  			$tokens->eat(Type::Parser::R_PAREN);
  			return $r;
  		}
  		
  		if ($tokens->peek(1)
  		and $tokens->peek(0)->type eq Type::Parser::TYPE
  		and $tokens->peek(1)->type eq Type::Parser::L_BRACKET)
  		{
  			my $base = { type  => "primary", token => $tokens->eat(Type::Parser::TYPE) };
  			$tokens->eat(Type::Parser::L_BRACKET);
  			$tokens->assert_not_empty;
  			
  			local $precedence{ Type::Parser::COMMA() } = 1;
  			
  			my $params = undef;
  			if ($tokens->peek(0)->type eq Type::Parser::R_BRACKET)
  			{
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			else
  			{
  				$params = $self->_parse_expression;
  				$params = { type => "list", list => [$params] } unless $params->{type} eq "list";
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			return {
  				type   => "parameterized",
  				base   => $base,
  				params => $params,
  			};
  		}
  		
  		my $type = $tokens->peek(0)->type;
  		if ($type eq Type::Parser::TYPE
  		or  $type eq Type::Parser::QUOTELIKE
  		or  $type eq Type::Parser::STRING
  		or  $type eq Type::Parser::CLASS)
  		{
  			return { type  => "primary", token => $tokens->eat };
  		}
  		
  		Type::Parser::_croak("Unexpected token in primary type expression; got '%s'", $tokens->peek(0)->spelling);
  	}
  	
  	sub _parse_expression_1
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		my ($lhs, $min_p) = @_;
  		while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} >= $min_p)
  		{
  			my $op  = $tokens->eat;
  			my $rhs = $self->_parse_primary;
  			
  			while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} > $precedence{$op->type})
  			{
  				my $lookahead = $tokens->peek(0);
  				$rhs = $self->_parse_expression_1($rhs, $precedence{$lookahead->type});
  			}
  			
  			$lhs = {
  				type => "expression",
  				op   => $op,
  				lhs  => $lhs,
  				rhs  => $rhs,
  			};
  		}
  		return $lhs;
  	}
  	
  	sub _parse_expression
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		return $self->_parse_expression_1($self->_parse_primary, 0);
  	}
  	
  	sub build
  	{
  		my $self = shift;
  		$self->{tokens} = "Type::Parser::TokenStream"->new(remaining => $self->{input});
  		$self->{ast}    = $self->_parse_expression;
  	}
  	
  	sub ast
  	{
  		$_[0]{ast};
  	}
  	
  	sub remainder
  	{
  		$_[0]{tokens}->remainder;
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::Token;
  	sub type     { $_[0][0] }
  	sub spelling { $_[0][1] }
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::TokenStream;
  	
  	use Scalar::Util qw(looks_like_number);
  	use Text::Balanced qw(extract_quotelike);
  	
  	sub new
  	{
  		my $class = shift;
  		bless { stack => [], done => [], @_ }, $class;
  	}
  	
  	sub peek
  	{
  		my $self  = shift;
  		my $ahead = $_[0];
  		
  		while ($self->_stack_size <= $ahead and length $self->{remaining})
  		{
  			$self->_stack_extend;
  		}
  		
  		my @tokens = grep ref, @{ $self->{stack} };
  		return $tokens[$ahead];
  	}
  	
  	sub empty
  	{
  		my $self = shift;
  		not $self->peek(0);
  	}
  	
  	sub eat
  	{
  		my $self = shift;
  		$self->_stack_extend unless $self->_stack_size;
  		my $r;
  		while (defined(my $item = shift @{$self->{stack}}))
  		{
  			push @{ $self->{done} }, $item;
  			if (ref $item)
  			{
  				$r = $item;
  				last;
  			}
  		}
  		
  		if (@_ and $_[0] ne $r->type)
  		{
  			unshift @{$self->{stack}}, pop @{$self->{done}};
  			Type::Parser::_croak("Expected $_[0]; got ".$r->type);
  		}
  		
  		return $r;
  	}
  	
  	sub assert_not_empty
  	{
  		my $self = shift;
  		Type::Parser::_croak("Expected token; got empty string") if $self->empty;
  	}
  	
  	sub _stack_size
  	{
  		my $self = shift;
  		scalar grep ref, @{ $self->{stack} };
  	}
  	
  	sub _stack_extend
  	{
  		my $self = shift;
  		push @{ $self->{stack} }, $self->_read_token;
  		my ($space) = ($self->{remaining} =~ m/^([\s\n\r]*)/sm);
  		return unless length $space;
  		push @{ $self->{stack} }, $space;
  		substr($self->{remaining}, 0, length $space) = "";
  	}
  	
  	sub remainder
  	{
  		my $self = shift;
  		return join "",
  			map { ref($_) ? $_->spelling : $_ }
  			(@{$self->{stack}}, $self->{remaining})
  	}
  	
  	my %punctuation = (
  		'['       => bless([ Type::Parser::L_BRACKET, "[" ], "Type::Parser::Token"),
  		']'       => bless([ Type::Parser::R_BRACKET, "]" ], "Type::Parser::Token"),
  		'('       => bless([ Type::Parser::L_PAREN,   "[" ], "Type::Parser::Token"),
  		')'       => bless([ Type::Parser::R_PAREN,   "]" ], "Type::Parser::Token"),
  		','       => bless([ Type::Parser::COMMA,     "," ], "Type::Parser::Token"),
  		'=>'      => bless([ Type::Parser::COMMA,     "=>" ], "Type::Parser::Token"),
  		'slurpy'  => bless([ Type::Parser::SLURPY,    "slurpy" ], "Type::Parser::Token"),
  		'|'       => bless([ Type::Parser::UNION,     "|" ], "Type::Parser::Token"),
  		'&'       => bless([ Type::Parser::INTERSECT, "&" ], "Type::Parser::Token"),
  		'~'       => bless([ Type::Parser::NOT,       "~" ], "Type::Parser::Token"),
  	);
  	
  	sub _read_token
  	{
  		my $self = shift;
  		
  		return if $self->{remaining} eq "";
  		
  		# Punctuation
  		# 
  		
  		if ($self->{remaining} =~ /^( => | [()\]\[|&~,] )/xsm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			return $punctuation{$spelling};
  		}
  		
  		if (my $quotelike = extract_quotelike $self->{remaining})
  		{
  			return bless([ Type::Parser::QUOTELIKE, $quotelike ], "Type::Parser::Token"),;
  		}
  		
  		if ($self->{remaining} =~ /^([+-]?[\w:.+]+)/sm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			
  			if ($spelling =~ /::$/sm)
  			{
  				return bless([ Type::Parser::CLASS, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif (looks_like_number($spelling))
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($self->{remaining} =~ /^\s*=>/sm) # peek ahead
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($spelling eq "slurpy")
  			{
  				return $punctuation{$spelling};
  			}
  			
  			return bless([ Type::Parser::TYPE, $spelling ], "Type::Parser::Token");
  		}
  		
  		my $rest = $self->{remaining};
  		$self->{remaining} = "";
  		return bless([ Type::Parser::MYSTERY, $rest ], "Type::Parser::Token");
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords non-whitespace
  
  =head1 NAME
  
  Type::Parser - parse type constraint strings
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Parser qw( eval_type );
   use Type::Registry;
   
   my $reg = Type::Registry->for_me;
   $reg->add_types("Types::Standard");
   
   my $type = eval_type("Int | ArrayRef[Int]", $reg);
   
   $type->check(10);        # true
   $type->check([1..4]);    # true
   $type->check({foo=>1});  # false
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Generally speaking, you probably don't want to be using this module directly.
  Instead use the C<< lookup >> method from L<Type::Registry> which wraps it.
  
  =head2 Functions
  
  =over
  
  =item C<< parse($string) >>
  
  Parse the type constraint string into something like an AST.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< extract_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< eval_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  Throws an error if the "tail" contains any non-whitespace character.
  
  =back
  
  =head2 Constants
  
  The following constants correspond to values returned by C<< $token->type >>.
  
  =over
  
  =item C<< TYPE >>
  
  =item C<< QUOTELIKE >>
  
  =item C<< STRING >>
  
  =item C<< CLASS >>
  
  =item C<< L_BRACKET >>
  
  =item C<< R_BRACKET >>
  
  =item C<< COMMA >>
  
  =item C<< SLURPY >>
  
  =item C<< UNION >>
  
  =item C<< INTERSECT >>
  
  =item C<< NOT >>
  
  =item C<< L_PAREN >>
  
  =item C<< R_PAREN >>
  
  =item C<< MYSTERY >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Registry>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARSER

$fatpacked{"Type/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_REGISTRY';
  package Type::Registry;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Registry::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Registry::VERSION   = '0.038';
  }
  
  use Exporter::Tiny qw( mkopt );
  use Scalar::Util qw( refaddr );
  use Type::Parser qw( eval_type );
  use Types::TypeTiny qw( CodeLike ArrayLike to_TypeTiny );
  
  our @ISA = 'Exporter::Tiny';
  our @EXPORT_OK = qw(t);
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	
  	if ($name eq "t")
  	{
  		my $caller = $globals->{into};
  		my $reg = $class->for_class(
  			ref($caller) ? sprintf('HASH(0x%08X)', refaddr($caller)) : $caller
  		);
  		return t => sub (;$) { @_ ? $reg->lookup(@_) : $reg };
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  sub new
  {
  	my $class = shift;
  	ref($class) and _croak("Not an object method");
  	bless {}, $class;
  }
  
  {
  	my %registries;
  	
  	sub for_class
  	{
  		my $class = shift;
  		my ($for) = @_;
  		$registries{$for} ||= $class->new;
  	}
  	
  	sub for_me
  	{
  		my $class = shift;
  		my $for   = caller;
  		$registries{$for} ||= $class->new;
  	}
  }
  
  sub add_types
  {
  	my $self = shift;
  	my $opts = mkopt(\@_);
  	for my $opt (@$opts)
  	{
  		my ($lib, $types) = @_;
  		
  		$lib =~ s/^-/Types::/;
  		eval "require $lib";
  		
  		my %hash;
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$types ||= [qw/-types/];
  			ArrayLike->check($types)
  				or _croak("Expected arrayref following '%s'; got %s", $lib, $types);
  			
  			$lib->import({into => \%hash}, @$types);
  			$hash{$_} = &{$hash{$_}}() for keys %hash;
  		}
  		elsif ($lib->isa("MooseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MooseX::Types type constraint library. No import options currently supported", $lib);
  			
  			require Moose::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Moose::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		elsif ($lib->isa("MouseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MouseX::Types type constraint library. No import options currently supported", $lib);
  			
  			require Mouse::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Mouse::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		else
  		{
  			_croak("%s is not a type library", $lib);
  		}
  		
  		for my $key (sort keys %hash)
  		{
  			exists($self->{$key})
  				and _croak("Duplicate type name: %s", $key);
  			$self->{$key} = $hash{$key};
  		}
  	}
  	$self;
  }
  
  sub add_type
  {
  	my $self = shift;
  	my ($type, $name) = @_;
  	$type = to_TypeTiny($type);
  	$name ||= do {
  		$type->is_anon
  			and _croak("Expected named type constraint; got anonymous type constraint");
  		$type->name;
  	};
  	
  	exists($self->{$name})
  		and _croak("Duplicate type name: %s", $name);
  	
  	$self->{$name} = $type;
  	$self;
  }
  
  sub alias_type
  {
  	my $self = shift;
  	my ($old, @new) = @_;
  	$self->{$_} = $self->{$old} for @new;
  	$self;
  }
  
  sub simple_lookup
  {
  	my $self = shift;
  	
  	my ($tc) = @_;
  	$tc =~ s/(^\s+|\s+$)//g;
  	
  	if (exists $self->{$tc})
  	{
  		return $self->{$tc};
  	}
  	
  	return;
  }
  
  sub lookup
  {
  	my $self = shift;
  	
  	$self->simple_lookup(@_) or eval_type($_[0], $self);
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  	my $type = $self->simple_lookup($method);
  	return $type if $type;
  	_croak(q[Can't locate object method "%s" via package "%s"], $method, ref($self));
  }
  
  # Prevent AUTOLOAD being called for DESTROY!
  sub DESTROY
  {
  	return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords optlist
  
  =head1 NAME
  
  Type::Registry - a glorified hashref for looking up type constraints
  
  =head1 SYNOPSIS
  
     package Foo::Bar;
     
     use Type::Registry;
     
     my $reg = "Type::Registry"->for_me;  # a registry for Foo::Bar
     
     # Register all types from Types::Standard
     $reg->add_types(-Standard);
     
     # Register just one type from Types::XSD
     $reg->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     $reg->add_types("MyApp::Types");
     
     # Create a type alias
     $reg->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = $reg->lookup("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  Alternatively:
  
     package Foo::Bar;
     
     use Type::Registry qw( t );
     
     # Register all types from Types::Standard
     t->add_types(-Standard);
     
     # Register just one type from Types::XSD
     t->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     t->add_types("MyApp::Types");
     
     # Create a type alias
     t->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = t("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head2 Changes under consideration
  
  An exception to this policy is that the following feature is being
  considered. When type constraint barewords are imported into a package
  that has a registry:
  
     use Type::Registry qw(t);
     use Types::Standard -types;
  
  Then the C<Str>, C<Num>, etc keywords imported from L<Types::Standard> will
  work fine, but C<< t->lookup("Str") >> and C<< t->lookup("Num") >> will fail,
  because importing types from a library does not automatically add them to
  your registry.
  
  Some kind of integration may be desirable between Type::Registry and
  L<Type::Library>, but exactly what form that will take is still to be
  decided.
  
  =head1 DESCRIPTION
  
  A type registry is basically just a hashref mapping type names to type
  constraint objects.
  
  =head2 Constructors
  
  =over
  
  =item C<< new >>
  
  Create a new glorified hashref.
  
  =item C<< for_class($class) >>
  
  Create or return the existing glorified hashref associated with the given
  class.
  
  =item C<< for_me >>
  
  Create or return the existing glorified hashref associated with the caller.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< add_types(@libraries) >>
  
  The libraries list is treated as an "optlist" (a la L<Data::OptList>).
  
  Strings are the names of type libraries; if the first character is a
  hyphen, it is expanded to the "Types::" prefix. If followed by an
  arrayref, this is the list of types to import from that library.
  Otherwise, imports all types from the library.
  
     use Type::Registry qw(t);
     
     t->add_types(-Standard);  # OR: t->add_types("Types::Standard");
     
     t->add_types(
        -TypeTiny => ['HashLike'],
        -Standard => ['HashRef' => { -as => 'RealHash' }],
     );
  
  L<MooseX::Types> (and experimentally, L<MouseX::Types>) libraries can
  also be added this way, but I<< cannot be followed by an arrayref of
  types to import >>.
  
  =item C<< add_type($type, $name) >>
  
  The long-awaited singular form of C<add_types>. Given a type constraint
  object, adds it to the registry with a given name. The name may be
  omitted, in which case C<< $type->name >> is called, and Type::Registry
  will throw an error if C<< $type >> is anonymous. If a name is explicitly
  given, Type::Registry cares not one wit whether the type constraint is
  anonymous.
  
  This method can even add L<MooseX::Types> and L<MouseX::Types> type
  constraints; indeed anything that can be handled by L<Types::TypeTiny>'s
  C<to_TypeTiny> function. (Bear in mind that to_TypeTiny I<always> results
  in an anonymous type constraint, so C<< $name >> will be required.)
  
  =item C<< alias_type($oldname, $newname) >>
  
  Create an alias for an existing type.
  
  =item C<< simple_lookup($name) >>
  
  Look up a type in the registry by name. 
  
  Returns undef if not found.
  
  =item C<< lookup($name) >>
  
  Look up by name, with a DSL.
  
     t->lookup("Int|ArrayRef[Int]")
  
  The DSL can be summed up as:
  
     X               type from this registry
     My::Lib::X      type from a type library
     ~X              complementary type
     X | Y           union
     X & Y           intersection
     X[...]          parameterized type
     slurpy X        slurpy type
     Foo::Bar::      class type
  
  Croaks if not found.
  
  =item C<< AUTOLOAD >>
  
  Overloaded to call C<lookup>.
  
     $registry->Str;  # like $registry->lookup("Str")
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< t >>
  
  This class can export a function C<< t >> which acts like
  C<< "Type::Registry"->for_class($importing_class) >>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Library>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_REGISTRY

$fatpacked{"Type/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY';
  package Type::Tiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::VERSION   = '0.038';
  }
  
  use Eval::TypeTiny ();
  use Scalar::Util qw( blessed weaken refaddr isweak );
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _swap { $_[2] ? @_[1,0] : @_[0,1] }
  
  BEGIN {
  	($] > 5.010001)
  		? eval q{ sub SUPPORT_SMARTMATCH () { !!0 } }
  		: eval q{ sub SUPPORT_SMARTMATCH () { !!1 } }
  }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(+)       => sub { $_[2] ? $_[1]->plus_coercions($_[0]) : $_[0]->plus_fallback_coercions($_[1]) },
  	q(|)       => sub { my @tc = _swap @_; require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@tc) },
  	q(&)       => sub { my @tc = _swap @_; require Type::Tiny::Intersection; "Type::Tiny::Intersection"->new(type_constraints => \@tc) },
  	q(~)       => sub { shift->complementary_type },
  	q(==)      => sub { $_[0]->equals($_[1]) },
  	q(<)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(_swap @_) },
  	q(>)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(reverse _swap @_) },
  	q(<=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(_swap @_) },
  	q(>=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(reverse _swap @_) },
  	q(eq)      => sub { "$_[0]" eq "$_[1]" },
  	q(cmp)     => sub { $_[2] ? ("$_[1]" cmp "$_[0]") : ("$_[0]" cmp "$_[1]") },
  	fallback   => 1,
  ;
  BEGIN {
  	overload->import(q(~~) => sub { $_[0]->check($_[1]) })
  		if Type::Tiny::SUPPORT_SMARTMATCH;
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	$self->message unless exists $self->{message};
  	
  #	if ($self->has_parent && $self->_is_null_constraint)
  #	{
  #		$self->{_overload_coderef} ||= $self->parent->_overload_coderef;
  #	}
  #	els
  	if (!exists($self->{message}) && exists(&Sub::Quote::quote_sub) && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_assert('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->assert_return(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  our %ALL_TYPES;
  
  my $QFS;
  my $uniq = 1;
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	if (exists $params{parent})
  	{
  		$params{parent} = ref($params{parent}) =~ /^Type::Tiny\b/
  			? $params{parent}
  			: Types::TypeTiny::to_TypeTiny($params{parent});
  		
  		_croak "Parent must be an instance of %s", __PACKAGE__
  			unless blessed($params{parent}) && $params{parent}->isa(__PACKAGE__);
  	}
  	
  	$params{name} = "__ANON__" unless exists $params{name};
  	$params{uniq} = $uniq++;
  	
  	if ($params{name} ne "__ANON__")
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$params{name} =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid type name', $params{name};
  	}
  	
  	if (exists $params{coercion} and !ref $params{coercion} and $params{coercion})
  	{
  		$params{parent}->has_coercion
  			or _croak "coercion => 1 requires type to have a direct parent with a coercion";
  		
  		$params{coercion} = $params{parent}->coercion;
  	}
  	
  	if (!exists $params{inlined}
  	and exists $params{constraint}
  	and ( !exists $params{parent} or $params{parent}->can_be_inlined )
  	and $QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($params{constraint}) || [] };
  		
  		$params{inlined} = sub {
  			my ($self, $var) = @_;
  			my $code = Sub::Quote::inlinify(
  				$var eq q($_) ? $perlstring : "local \$_ = $var; $perlstring",
  				$var,
  			);
  			$code = sprintf('%s and %s', $self->parent->inline_check($var), $code) if $self->has_parent;
  			return $code;
  		} if $perlstring && !$captures;
  	}
  	
  	my $self = bless \%params, $class;
  	
  	unless ($params{tmp})
  	{
  		my $uniq = $self->{uniq};
  		
  		$ALL_TYPES{$uniq} = $self;
  		weaken( $ALL_TYPES{$uniq} );
  		
  		package # no index
  			Moo::HandleMoose;
  		$Moo::HandleMoose::TYPE_MAP{$self} = sub { $ALL_TYPES{$uniq} };
  	}
  	
  	if (ref($params{coercion}) eq q(CODE))
  	{
  		require Types::Standard;
  		my $code = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(Types::Standard::Any(), $code);
  	}
  	elsif (ref($params{coercion}) eq q(ARRAY))
  	{
  		my $arr = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(@$arr);
  	}
  	
  	$self->{type_constraints} ||= undef;
  	
  	return $self;
  }
  
  sub DESTROY
  {
  	my $self = shift;
  	delete( $ALL_TYPES{$self->{uniq}} );
  	package # no index
  		Moo::HandleMoose;
  	delete( $Moo::HandleMoose::TYPE_MAP{$self} );
  	return;
  }
  
  sub _clone
  {
  	my $self = shift;
  	my %opts;
  	$opts{$_} = $self->{$_} for qw< name display_name message >;
  	$self->create_child_type(%opts);
  }
  
  our $DD;
  sub _dd
  {
  	@_ = $_ unless @_;
  	my ($value) = @_;
  	
  	goto $DD if ref($DD) eq q(CODE);
  	
  	require B;
  	
  	!defined $value ? 'Undef' :
  	!ref $value     ? sprintf('Value %s', B::perlstring($value)) :
  	do {
  		my $N = 0 + (defined($DD) ? $DD : 72);
  		require Data::Dumper;
  		local $Data::Dumper::Indent   = 0;
  		local $Data::Dumper::Useqq    = 1;
  		local $Data::Dumper::Terse    = 1;
  		local $Data::Dumper::Sortkeys = 1;
  		local $Data::Dumper::Maxdepth = 2;
  		my $str = Data::Dumper::Dumper($value);
  		$str = substr($str, 0, $N - 12).'...'.substr($str, -1, 1)
  			if length($str) >= $N;
  		"Reference $str";
  	}
  }
  
  sub _loose_to_TypeTiny
  {
  	map +(
  		ref($_)
  			? Types::TypeTiny::to_TypeTiny($_)
  			: do { require Type::Utils; Type::Utils::dwim_type($_) }
  	), @_;
  }
  
  sub name                     { $_[0]{name} }
  sub display_name             { $_[0]{display_name}   ||= $_[0]->_build_display_name }
  sub parent                   { $_[0]{parent} }
  sub constraint               { $_[0]{constraint}     ||= $_[0]->_build_constraint }
  sub compiled_check           { $_[0]{compiled_type_constraint} ||= $_[0]->_build_compiled_check }
  sub coercion                 { $_[0]{coercion}       ||= $_[0]->_build_coercion }
  sub message                  { $_[0]{message} }
  sub library                  { $_[0]{library} }
  sub inlined                  { $_[0]{inlined} }
  sub constraint_generator     { $_[0]{constraint_generator} }
  sub inline_generator         { $_[0]{inline_generator} }
  sub name_generator           { $_[0]{name_generator} ||= $_[0]->_build_name_generator }
  sub coercion_generator       { $_[0]{coercion_generator} }
  sub parameters               { $_[0]{parameters} }
  sub moose_type               { $_[0]{moose_type}     ||= $_[0]->_build_moose_type }
  sub mouse_type               { $_[0]{mouse_type}     ||= $_[0]->_build_mouse_type }
  sub deep_explanation         { $_[0]{deep_explanation} }
  
  sub has_parent               { exists $_[0]{parent} }
  sub has_library              { exists $_[0]{library} }
  sub has_coercion             {        $_[0]{coercion} and !!@{ $_[0]{coercion}->type_coercion_map } }
  sub has_inlined              { exists $_[0]{inlined} }
  sub has_constraint_generator { exists $_[0]{constraint_generator} }
  sub has_inline_generator     { exists $_[0]{inline_generator} }
  sub has_coercion_generator   { exists $_[0]{coercion_generator} }
  sub has_parameters           { exists $_[0]{parameters} }
  sub has_message              { defined $_[0]{message} }
  sub has_deep_explanation     { exists $_[0]{deep_explanation} }
  
  sub _default_message         { $_[0]{_default_message} ||= $_[0]->_build_default_message }
  
  sub _assert_coercion
  {
  	my $self = shift;
  	_croak "No coercion for this type constraint"
  		unless $self->has_coercion && @{$self->coercion->type_coercion_map};
  	return $self->coercion;
  }
  
  my $null_constraint = sub { !!1 };
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub _build_constraint
  {
  	return $null_constraint;
  }
  
  sub _is_null_constraint
  {
  	shift->constraint == $null_constraint;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion;
  	my $self = shift;
  	my %opts = (type_constraint => $self);
  	$opts{display_name} = "to_$self" unless $self->is_anon;
  	return "Type::Coercion"->new(%opts);
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	return sub { sprintf '%s did not pass type constraint', _dd($_[0]) } if "$self" eq "__ANON__";
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s"', _dd($_[0]), $name };
  }
  
  sub _build_name_generator
  {
  	my $self = shift;
  	return sub {
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], @a);
  	};
  }
  
  sub _build_compiled_check
  {
  	my $self = shift;
  	
  	if ($self->_is_null_constraint and $self->has_parent)
  	{
  		return $self->parent->compiled_check;
  	}
  	
  	if ($INC{'Mouse/Util.pm'} and Mouse::Util::MOUSE_XS())
  	{
  		require Mouse::Util::TypeConstraints;
  		
  		if ($self->{_is_core})
  		{
  			my $xs = "Mouse::Util::TypeConstraints"->can($self->name);
  			return $xs if $xs;
  		}
  		elsif ($self->is_parameterized and $self->has_parent
  		and $self->parent->{_is_core} and $self->parent->name =~ /^(ArrayRef|HashRef|Maybe)$/)
  		{
  			my $xs = "Mouse::Util::TypeConstraints"->can("_parameterize_".$self->parent->name."_for");
  			return $xs->($self->parameters->[0]) if $xs;
  		}
  	}
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', $self->inline_check('$_[0]')),
  		description => sprintf("compiled check '%s'", $self),
  	) if $self->can_be_inlined;
  	
  	my @constraints;
  	push @constraints, $self->parent->compiled_check if $self->has_parent;
  	push @constraints, $self->constraint if !$self->_is_null_constraint;
  	return $null_constraint unless @constraints;
  	
  	return sub ($)
  	{
  		local $_ = $_[0];
  		for my $c (@constraints)
  		{
  			return unless $c->(@_);
  		}
  		return !!1;
  	};
  }
  
  sub equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if refaddr($self) == refaddr($other);
  	
  	return !!1 if $self->has_parent  && $self->_is_null_constraint  && $self->parent==$other;
  	return !!1 if $other->has_parent && $other->_is_null_constraint && $other->parent==$self;
  	
  	return !!1 if refaddr($self->compiled_check) == refaddr($other->compiled_check);
  	
  	return $self->qualified_name eq $other->qualified_name
  		if $self->has_library && !$self->is_anon && $other->has_library && !$other->is_anon;
  	
  	return $self->inline_check('$x') eq $other->inline_check('$x')
  		if $self->can_be_inlined && $other->can_be_inlined;
  	
  	return;
  }
  
  sub is_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->equals($other) or $self->parent->is_subtype_of($other);
  }
  
  sub is_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_subtype_of($self);
  }
  
  sub is_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->equals($other) or $self->is_subtype_of($other);
  }
  
  sub strictly_equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	$self->{uniq} == $other->{uniq};
  }
  
  sub is_strictly_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->strictly_equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->strictly_equals($other) or $self->parent->is_strictly_subtype_of($other);
  }
  
  sub is_strictly_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_strictly_subtype_of($self);
  }
  
  sub is_strictly_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->strictly_equals($other) or $self->is_strictly_subtype_of($other);
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	(exists $self->{library} and $self->name ne "__ANON__")
  		? "$self->{library}::$self->{name}"
  		: $self->{name};
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub parents
  {
  	my $self = shift;
  	return unless $self->has_parent;
  	return ($self->parent, $self->parent->parents);
  }
  
  sub check
  {
  	my $self = shift;
  	($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  }
  
  sub _strict_check
  {
  	my $self = shift;
  	local $_ = $_[0];
  
  	my @constraints =
  		reverse
  		map  { $_->constraint }
  		grep { not $_->_is_null_constraint }
  		($self, $self->parents);
  	
  	for my $c (@constraints)
  	{
  		return unless $c->(@_);
  	}
  	
  	return !!1;
  }
  
  sub get_message
  {
  	my $self = shift;
  	local $_ = $_[0];
  	$self->has_message
  		? $self->message->(@_)
  		: $self->_default_message->(@_);
  }
  
  sub validate
  {
  	my $self = shift;
  	
  	return undef if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	return $self->get_message(@_);
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	if ($self->has_parent)
  	{
  		my $parent = $self->parent->validate_explain($value, $varname);
  		return [ sprintf('"%s" is a subtype of "%s"', $self, $self->parent), @$parent ] if $parent;
  	}
  	
  	my $message = sprintf(
  		'%s%s',
  		$self->get_message($value),
  		$varname eq q{$_} ? '' : sprintf(' (in %s)', $varname),
  	);
  	
  	if ($self->is_parameterized and $self->parent->has_deep_explanation)
  	{
  		my $deep = $self->parent->deep_explanation->($self, $value, $varname);
  		return [ $message, @$deep ] if $deep;
  	}
  	
  	return [ $message, sprintf('"%s" is defined as: %s', $self, $self->_perlcode) ];
  }
  
  my $b;
  sub _perlcode
  {
  	my $self = shift;
  	
  	return $self->inline_check('$_')
  		if $self->can_be_inlined;
  	
  	$b ||= do {
  		require B::Deparse;
  		my $tmp = "B::Deparse"->new;
  		$tmp->ambient_pragmas(strict => "all", warnings => "all") if $tmp->can('ambient_pragmas');
  		$tmp;
  	};
  	
  	my $code = $b->coderef2text($self->constraint);
  	$code =~ s/\s+/ /g;
  	return "sub $code";
  }
  
  sub assert_valid
  {
  	my $self = shift;
  	
  	return !!1 if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub assert_return
  {
  	my $self = shift;
  	
  	return $_[0] if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	return $self->parent->can_be_inlined
  		if $self->has_parent && $self->_is_null_constraint;
  	return !!1
  		if !$self->has_parent && $self->_is_null_constraint;
  	return $self->has_inlined;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	_croak 'Cannot inline type constraint check for "%s"', $self
  		unless $self->can_be_inlined;
  	
  	return $self->parent->inline_check(@_)
  		if $self->has_parent && $self->_is_null_constraint;
  	return '(!!1)'
  		if !$self->has_parent && $self->_is_null_constraint;
  	
  	local $_ = $_[0];
  	my @r = $self->inlined->($self, @_);
  	if (@r and not defined $r[0])
  	{
  		_croak 'Inlining type constraint check for "%s" returned undef!', $self
  			unless $self->has_parent;
  		$r[0] = $self->parent->inline_check(@_);
  	}
  	my $r = join " && " => map { /[;{}]/ ? "do { $_ }" : "($_)" } @r;
  	return @r==1 ? $r : "($r)";
  }
  
  sub inline_assert
  {
  	require B;
  	my $self = shift;
  	my $varname = $_[0];
  	my $code = sprintf(
  		q[do { no warnings "void"; %s ? %s : Type::Tiny::_failed_check(%d, %s, %s) };],
  		$self->inline_check(@_),
  		$varname,
  		$self->{uniq},
  		B::perlstring("$self"),
  		$varname,
  	);
  	return $code;
  }
  
  sub _failed_check
  {
  	require Error::TypeTiny::Assertion;
  	
  	my ($self, $name, $value, %attrs) = @_;
  	$self = $ALL_TYPES{$self} unless ref $self;
  	
  	my $exception_class = delete($attrs{exception_class}) || "Error::TypeTiny::Assertion";
  	
  	if ($self)
  	{
  		$exception_class->throw(
  			message => $self->get_message($value),
  			type    => $self,
  			value   => $value,
  			%attrs,
  		);
  	}
  	else
  	{
  		$exception_class->throw(
  			message => sprintf('%s did not pass type constraint "%s"', _dd($value), $name),
  			value   => $value,
  			%attrs,
  		);
  	}
  }
  
  sub coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->coerce(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->assert_coerce(@_);
  }
  
  sub is_parameterizable
  {
  	shift->has_constraint_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  my %param_cache;
  sub parameterize
  {
  	my $self = shift;
  	
  	$self->is_parameterizable
  		or @_ ? _croak("Type '%s' does not accept parameters", "$self") : return($self);
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  
  	# Generate a key for caching parameterized type constraints,
  	# but only if all the parameters are strings or type constraints.
  	my $key;
  	if ( not grep(ref($_) && !Types::TypeTiny::TypeTiny->check($_), @_) )
  	{
  		require B;
  		$key = join ":", map(Types::TypeTiny::TypeTiny->check($_) ? $_->{uniq} : B::perlstring($_), $self, @_);
  	}
  	
  	return $param_cache{$key} if defined $key && defined $param_cache{$key};
  	
  	local $Type::Tiny::parameterize_type = $self;
  	local $_ = $_[0];
  	my $P;
  	
  	my $constraint = $self->constraint_generator->(@_);
  	
  	if (Types::TypeTiny::TypeTiny->check($constraint))
  	{
  		$P = $constraint;
  	}
  	else
  	{
  		my %options = (
  			constraint   => $constraint,
  			display_name => $self->name_generator->($self, @_),
  			parameters   => [@_],
  		);
  		$options{inlined} = $self->inline_generator->(@_)
  			if $self->has_inline_generator;
  		exists $options{$_} && !defined $options{$_} && delete $options{$_}
  			for keys %options;
  		
  		$P = $self->create_child_type(%options);
  		
  		my $coercion;
  		$coercion = $self->coercion_generator->($self, $P, @_)
  			if $self->has_coercion_generator;
  		$P->coercion->add_type_coercions( @{$coercion->type_coercion_map} )
  			if $coercion;
  	}
  	
  	if (defined $key)
  	{
  		$param_cache{$key} = $P;
  		weaken($param_cache{$key});
  	}
  	
  	return $P;
  }
  
  sub child_type_class
  {
  	__PACKAGE__;
  }
  
  sub create_child_type
  {
  	my $self = shift;
  	return $self->child_type_class->new(parent => $self, @_);
  }
  
  sub complementary_type
  {
  	my $self = shift;
  	my $r    = ($self->{complementary_type} ||= $self->_build_complementary_type);
  	weaken($self->{complementary_type}) unless isweak($self->{complementary_type});
  	return $r;
  }
  
  sub _build_complementary_type
  {
  	my $self = shift;
  	my %opts = (
  		constraint   => sub { not $self->check($_) },
  		display_name => sprintf("~%s", $self),
  	);
  	$opts{display_name} =~ s/^\~{2}//;
  	$opts{inlined} = sub { shift; "not(".$self->inline_check(@_).")" }
  		if $self->can_be_inlined;
  	return "Type::Tiny"->new(%opts);
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	require Moose::Meta::TypeConstraint;
  	return "Moose::Meta::TypeConstraint"->new(%opts);
  }
  
  sub _build_moose_type
  {
  	my $self = shift;
  	
  	my $r;
  	if ($self->{_is_core})
  	{
  		require Moose::Util::TypeConstraints;
  		$r = Moose::Util::TypeConstraints::find_type_constraint($self->name);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		Scalar::Util::weaken($r->{"Types::TypeTiny::to_TypeTiny"});
  	}
  	else
  	{
  		my %opts;
  		$opts{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  		$opts{parent}     = $self->parent->moose_type if $self->has_parent;
  		$opts{constraint} = $self->constraint         unless $self->_is_null_constraint;
  		$opts{message}    = $self->message            if $self->has_message;
  		$opts{inlined}    = $self->inlined            if $self->has_inlined;
  		
  		$r = $self->_instantiate_moose_type(%opts);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		$self->{moose_type} = $r;  # prevent recursion
  		$r->coercion($self->coercion->moose_coercion) if $self->has_coercion;
  	}
  		
  	return $r;
  }
  
  sub _build_mouse_type
  {
  	my $self = shift;
  	
  	my %options;
  	$options{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  	$options{parent}     = $self->parent->mouse_type if $self->has_parent;
  	$options{constraint} = $self->constraint         unless $self->_is_null_constraint;
  	$options{message}    = $self->message            if $self->has_message;
  		
  	require Mouse::Meta::TypeConstraint;
  	my $r = "Mouse::Meta::TypeConstraint"->new(%options);
  	
  	$self->{mouse_type} = $r;  # prevent recursion
  	$r->_add_type_coercions(
  		$self->coercion->freeze->_codelike_type_coercion_map('mouse_type')
  	) if $self->has_coercion;
  	
  	return $r;
  }
  
  sub plus_coercions
  {
  	my $self = shift;
  	
  	my @more = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? @{ $_[0]->type_coercion_map }
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@more,
  		@{$self->coercion->type_coercion_map},
  	);
  	return $new;
  }
  
  sub plus_fallback_coercions
  {
  	my $self = shift;
  	
  	my @more = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? @{ $_[0]->type_coercion_map }
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@{$self->coercion->type_coercion_map},
  		@more,
  	);
  	return $new;
  }
  
  sub minus_coercions
  {
  	my $self = shift;
  	
  	my @not = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? grep(blessed($_)&&$_->isa("Type::Tiny"), @{ $_[0]->type_coercion_map })
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my @keep;
  	my $c = $self->coercion->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		my $keep_this = 1;
  		NOT: for my $n (@not)
  		{
  			if ($c->[$i] == $n)
  			{
  				$keep_this = 0;
  				last NOT;
  			}
  		}
  		
  		push @keep, $c->[$i], $c->[$i+1] if $keep_this;
  	}
  
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(@keep);
  	return $new;
  }
  
  sub no_coercions
  {
  	shift->_clone;
  }
  
  sub coercibles
  {
  	my $self = shift;
  	$self->has_coercion ? $self->coercion->_source_type_union : $self;
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and ref($self))
  	{
  		return !!1                       if $_[0] eq 'Moose::Meta::TypeConstraint';
  		return $self->is_parameterized   if $_[0] eq 'Moose::Meta::TypeConstraint::Parameterized';
  		return $self->is_parameterizable if $_[0] eq 'Moose::Meta::TypeConstraint::Parameterizable';
  	}
  	
  	if ($INC{"Moose.pm"} and ref($self) and $_[0] =~ /^Moose/ and my $r = $self->moose_type->isa(@_))
  	{
  		return $r;
  	}
  
  	if ($INC{"Mouse.pm"} and ref($self) and $_[0] eq 'Mouse::Meta::TypeConstraint')
  	{
  		return !!1;
  	}
  
  	$self->SUPER::isa(@_);
  }
  
  sub can
  {
  	my $self = shift;
  	
  	return !!0 if $_[0] eq 'type_parameter' && blessed($_[0]) && $_[0]->has_parameters;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if ($INC{"Moose.pm"} and ref($self) and my $method = $self->moose_type->can(@_))
  	{
  		return sub { $method->(shift->moose_type, @_) };
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if ($INC{"Moose.pm"} and ref($self) and my $method = $self->moose_type->can($m))
  	{
  		return $method->($self->moose_type, @_);
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  sub DOES
  {
  	my $self = shift;
  	
  	return !!1 if  ref($self) && $_[0] =~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;
  	return !!1 if !ref($self) && $_[0] eq 'Type::API::Constraint::Constructor';
  	
  	"UNIVERSAL"->can("DOES") ? $self->SUPER::DOES(@_) : $self->isa(@_);
  }
  
  # fill out Moose-compatible API
  sub inline_environment         { +{} }
  sub _inline_check              { shift->inline_check(@_) }
  sub _compiled_type_constraint  { shift->compiled_check(@_) }
  sub meta                       { _croak("Not really a Moose::Meta::TypeConstraint. Sorry!") }
  sub compile_type_constraint    { shift->compiled_check }
  sub _actually_compile_type_constraint   { shift->_build_compiled_check }
  sub hand_optimized_type_constraint      { shift->{hand_optimized_type_constraint} }
  sub has_hand_optimized_type_constraint  { exists(shift->{hand_optimized_type_constraint}) }
  sub type_parameter             { (shift->parameters || [])->[0] }
  
  # some stuff for Mouse-compatible API
  sub __is_parameterized         { shift->is_parameterized(@_) }
  sub _add_type_coercions        { shift->coercion->add_type_coercions(@_) };
  sub _as_string                 { shift->qualified_name(@_) }
  sub _compiled_type_coercion    { shift->coercion->compiled_coercion(@_) };
  sub _identity                  { refaddr(shift) };
  sub _unite                     { require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@_) };
  
  # Hooks for Type::Tie
  sub TIESCALAR  { require Type::Tie; unshift @_, 'Type::Tie::SCALAR'; goto \&Type::Tie::SCALAR::TIESCALAR };
  sub TIEARRAY   { require Type::Tie; unshift @_, 'Type::Tie::ARRAY';  goto \&Type::Tie::SCALAR::TIEARRAY };
  sub TIEHASH    { require Type::Tie; unshift @_, 'Type::Tie::HASH';   goto \&Type::Tie::SCALAR::TIEHASH };
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX MouseX MooX Moose-compat
  
  =head1 NAME
  
  Type::Tiny - tiny, yet Moo(se)-compatible type constraint
  
  =head1 SYNOPSIS
  
     use Scalar::Util qw(looks_like_number);
     use Type::Tiny;
     
     my $NUM = "Type::Tiny"->new(
        name       => "Number",
        constraint => sub { looks_like_number($_) },
        message    => sub { "$_ ain't a number" },
     );
     
     package Ermintrude {
        use Moo;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Bullwinkle {
        use Moose;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Maisy {
        use Mouse;
        has favourite_number => (is => "ro", isa => $NUM);
     }
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> is a tiny class for creating Moose-like type constraint
  objects which are compatible with Moo, Moose and Mouse.
  
  Maybe now we won't need to have separate MooseX, MouseX and MooX versions
  of everything? We can but hope...
  
  This documents the internals of L<Type::Tiny>. L<Type::Tiny::Manual> is
  a better starting place if you're new.
  
  =head2 Constructor
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<< name >>
  
  The name of the type constraint. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous type constraint.
  
  =item C<< display_name >>
  
  A name to display for the type constraint when stringified. These don't
  have to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<< parent >>
  
  Optional attribute; parent type constraint. For example, an "Integer"
  type constraint might have a parent "Number".
  
  If provided, must be a Type::Tiny object.
  
  =item C<< constraint >>
  
  Coderef to validate a value (C<< $_ >>) against the type constraint. The
  coderef will not be called unless the value is known to pass any parent
  type constraint.
  
  Defaults to C<< sub { 1 } >> - i.e. a coderef that passes all values.
  
  =item C<< compiled_check >>
  
  Coderef to validate a value (C<< $_[0] >>) against the type constraint.
  This coderef is expected to also handle all validation for the parent
  type constraints.
  
  The general point of this attribute is that you should not set it, and
  rely on the lazily-built default. Type::Tiny will usually generate a
  pretty fast coderef.
  
  =item C<< message >>
  
  Coderef that returns an error message when C<< $_ >> does not validate
  against the type constraint. Optional (there's a vaguely sensible default.)
  
  =item C<< inlined >>
  
  A coderef which returns a string of Perl code suitable for inlining this
  type. Optional.
  
  If C<constraint> (above) is a coderef generated via L<Sub::Quote>, then
  Type::Tiny I<may> be able to automatically generate C<inlined> for you.
  
  =item C<< library >>
  
  The package name of the type library this type is associated with.
  Optional. Informational only: setting this attribute does not install
  the type into the package.
  
  =item C<< coercion >>
  
  A L<Type::Coercion> object associated with this type.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built coercion object.
  
  You may pass C<< coercion => 1 >> to the constructor to inherit coercions
  from the constraint's parent. (This requires the parent constraint to have
  a coercion.)
  
  =item C<< complementary_type >>
  
  A complementary type for this type. For example, the complementary type
  for an integer type would be all things that are not integers, including
  floating point numbers, but also alphabetic strings, arrayrefs, filehandles,
  etc.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built complementary type.
  
  =item C<< moose_type >>, C<< mouse_type >>
  
  Objects equivalent to this type constraint, but as a
  L<Moose::Meta::TypeConstraint> or L<Mouse::Meta::TypeConstraint>.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built objects.
  
  It should rarely be necessary to obtain a L<Moose::Meta::TypeConstraint>
  object from L<Type::Tiny> because the L<Type::Tiny> object itself should
  be usable pretty much anywhere a L<Moose::Meta::TypeConstraint> is expected.
  
  =back
  
  The following additional attributes are used for parameterizable (e.g.
  C<ArrayRef>) and parameterized (e.g. C<< ArrayRef[Int] >>) type
  constraints. Unlike Moose, these aren't handled by separate subclasses.
  
  =over
  
  =item C<< parameters >>
  
  In parameterized types, returns an arrayref of the parameters.
  
  =item C<< name_generator >>
  
  A coderef which generates a new display_name based on parameters.
  Optional; the default is reasonable.
  
  =item C<< constraint_generator >>
  
  Coderef that generates a new constraint coderef based on parameters.
  Optional; providing a generator makes this type into a parameterizable
  type constraint.
  
  =item C<< inline_generator >>
  
  A coderef which generates a new inlining coderef based on parameters.
  
  =item C<< coercion_generator >>
  
  A coderef which generates a new L<Type::Coercion> object based on parameters.
  
  =item C<< deep_explanation >>
  
  This API is not finalized. Coderef used by L<Error::TypeTiny::Assertion> to
  peek inside parameterized types and figure out why a value doesn't pass the
  constraint.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_parent>, C<has_library>, C<has_inlined>, C<has_constraint_generator>, C<has_inline_generator>, C<has_coercion_generator>, C<has_parameters>, C<has_message>, C<has_deep_explanation>
  
  Predicate methods.
  
  =item C<has_coercion>
  
  Predicate method with a little extra DWIM. Returns false if the coercion is
  a no-op.
  
  =item C<< is_anon >>
  
  Returns true iff the type constraint does not have a C<name>.
  
  =item C<< is_parameterized >>, C<< is_parameterizable >>
  
  Indicates whether a type has been parameterized (e.g. C<< ArrayRef[Int] >>)
  or could potentially be (e.g. C<< ArrayRef >>).
  
  =item C<< qualified_name >>
  
  For non-anonymous type constraints that have a library, returns a qualified
  C<< "Library::Type" >> sort of name. Otherwise, returns the same as C<name>.
  
  =item C<< parents >>
  
  Returns a list of all this type constraint's ancestor constraints. For
  example, if called on the C<Str> type constraint would return the list
  C<< (Value, Defined, Item, Any) >>.
  
  B<< Due to a historical misunderstanding, this differs from the Moose
  implementation of the C<parents> method. In Moose, C<parents> only returns the
  immediate parent type constraints, and because type constraints only have
  one immediate parent, this is effectively an alias for C<parent>. The
  extension module L<MooseX::Meta::TypeConstraint::Intersection> is the only
  place where multiple type constraints are returned; and they are returned
  as an arrayref in violation of the base class' documentation. I'm keeping
  my behaviour as it seems more useful. >>
  
  =item C<< equals($other) >>, C<< is_subtype_of($other) >>, C<< is_supertype_of($other) >>, C<< is_a_type_of($other) >>
  
  Compare two types. See L<Moose::Meta::TypeConstraint> for what these all mean.
  (OK, Moose doesn't define C<is_supertype_of>, but you get the idea, right?)
  
  Note that these have a slightly DWIM side to them. If you create two
  L<Type::Tiny::Class> objects which test the same class, they're considered
  equal. And:
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_subtype_of( $subtype_of_Num );  # true
  
  =item C<< strictly_equals($other) >>, C<< is_strictly_subtype_of($other) >>, C<< is_strictly_supertype_of($other) >>, C<< is_strictly_a_type_of($other) >>
  
  Stricter versions of the type comparison functions. These only care about
  explicit inheritance via C<parent>.
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_strictly_subtype_of( $subtype_of_Num );  # false
  
  =item C<< check($value) >>
  
  Returns true iff the value passes the type constraint.
  
  =item C<< validate($value) >>
  
  Returns the error message for the value; returns an explicit undef if the
  value passes the type constraint.
  
  =item C<< validate_explain($value, $varname) >>
  
  Like C<validate> but instead of a string error message, returns an arrayref
  of strings explaining the reasoning why the value does not meet the type
  constraint, examining parent types, etc.
  
  The C<< $varname >> is an optional string like C<< '$foo' >> indicating the
  name of the variable being checked.
  
  =item C<< assert_valid($value) >>
  
  Like C<< check($value) >> but dies if the value does not pass the type
  constraint.
  
  Yes, that's three very similar methods. Blame L<Moose::Meta::TypeConstraint>
  whose API I'm attempting to emulate. :-)
  
  =item C<< assert_return($value) >>
  
  Like C<< assert_valid($value) >> but returns the value if it passes the type
  constraint.
  
  This seems a more useful behaviour than C<< assert_valid($value) >>. I would
  have just changed C<< assert_valid($value) >> to do this, except that there
  are edge cases where it could break Moose compatibility.
  
  =item C<< get_message($value) >>
  
  Returns the error message for the value; even if the value passes the type
  constraint.
  
  =item C<< coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type.
  
  =item C<< assert_coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type. Throws an exception if this is
  not possible.
  
  =item C<< coercibles >>
  
  Return a type constraint which is the union of type constraints that can be
  coerced to this one (including this one). If this type constraint has no
  coercions, returns itself.
  
  =item C<< can_be_inlined >>
  
  Returns boolean indicating if this type can be inlined.
  
  =item C<< inline_check($varname) >>
  
  Creates a type constraint check for a particular variable as a string of
  Perl code. For example:
  
     print( Types::Standard::Num->inline_check('$foo') );
  
  prints the following output:
  
     (!ref($foo) && Scalar::Util::looks_like_number($foo))
  
  For Moose-compat, there is an alias C<< _inline_check >> for this method.
  
  =item C<< inline_assert($varname) >>
  
  Much like C<inline_check> but outputs a statement of the form:
  
     die ... unless ...;
  
  Note that if this type has a custom error message, the inlined code will
  I<ignore> this custom message!!
  
  =item C<< parameterize(@parameters) >>
  
  Creates a new parameterized type; throws an exception if called on a
  non-parameterizable type.
  
  =item C<< create_child_type(%attributes) >>
  
  Construct a new Type::Tiny object with this object as its parent.
  
  =item C<< child_type_class >>
  
  The class that create_child_type will construct.
  
  =item C<< plus_coercions($type1, $code1, ...) >>
  
  Shorthand for creating a new child type constraint with the same coercions
  as this one, but then adding some extra coercions (at a higher priority than
  the existing ones).
  
  =item C<< plus_fallback_coercions($type1, $code1, ...) >>
  
  Like C<plus_coercions>, but added at a lower priority.
  
  =item C<< minus_coercions($type1, ...) >>
  
  Shorthand for creating a new child type constraint with fewer type coercions.
  
  =item C<< no_coercions >>
  
  Shorthand for creating a new child type constraint with no coercions at all.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeConstraint.
  
  If Mouse is loaded, then C<isa> mocks Mouse::Meta::TypeConstraint.
  
  =item C<< DOES($role) >>
  
  Overridden to advertise support for various roles.
  
  See also L<Type::API::Constraint>, etc.
  
  =item C<< TIESCALAR >>, C<< TIEARRAY >>, C<< TIEHASH >>
  
  These are provided as hooks that wrap L<Type::Tie>. (Type::Tie is distributed
  separately, and can be used with non-Type::Tiny type constraints too.) They
  allow the following to work:
  
     use Types::Standard qw(Int);
     tie my @list, Int;
     push @list, 123, 456;   # ok
     push @list, "Hello";    # dies
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_constraint >>
  
  =item C<< hand_optimized_type_constraint >>
  
  =item C<< has_hand_optimized_type_constraint >>
  
  =item C<< inline_environment >>
  
  =item C<< meta >>
  
  =item C<< type_parameter >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to return the qualified name.
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<assert_return>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<check>.
  
  =item *
  
  The C<< == >> operator is overloaded to call C<equals>.
  
  =item *
  
  The C<< < >> and C<< > >> operators are overloaded to call C<is_subtype_of>
  and C<is_supertype_of>.
  
  =item *
  
  The C<< ~ >> operator is overloaded to call C<complementary_type>.
  
  =item *
  
  The C<< | >> operator is overloaded to build a union of two type constraints.
  See L<Type::Tiny::Union>.
  
  =item *
  
  The C<< & >> operator is overloaded to build the intersection of two type
  constraints. See L<Type::Tiny::Intersection>.
  
  =item *
  
  The C<< + >> operator is overloaded to call C<plus_coercions> or
  C<plus_fallback_coercions> as appropriate.
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< Type::Tiny::SUPPORT_SMARTMATCH >>
  
  Indicates whether the smart match overload is supported on your
  version of Perl.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< $Type::Tiny::DD >>
  
  This in undef by default but may be set to a coderef that Type::Tiny
  and related modules will use to dump data structures in things like
  error messages.
  
  Otherwise Type::Tiny uses it's own routine to dump data structures.
  C<< $DD >> may then be set to a number to limit the lengths of the
  dumps. (Default limit is 72.)
  
  This is a package variable (rather than get/set class methods) to allow
  for easy localization.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>, L<Type::API>.
  
  L<Type::Library>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>, L<Type::Tiny::Intersection>.
  
  L<Moose::Meta::TypeConstraint>,
  L<Mouse::Meta::TypeConstraint>.
  
  L<Type::Params>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 THANKS
  
  Thanks to Matt S Trout for advice on L<Moo> integration.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY

$fatpacked{"Type/Tiny/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_CLASS';
  package Type::Tiny::Class;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::Class::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Class::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	return $proto->class->new(@_) if blessed $proto; # DWIM
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Class type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Class type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Class type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply class name" unless exists $opts{class};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub class       { $_[0]{class} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self  = shift;
  	my $class = $self->class;
  	return sub { blessed($_) and $_->isa($class) };
  }
  
  sub _build_inlined
  {
  	my $self  = shift;
  	my $class = $self->class;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and $var->isa(q[$class])};
  	};
  }
  
  sub _build_default_message
  {
  	no warnings 'uninitialized';
  	my $self = shift;
  	my $c = $self->class;
  	return sub { sprintf '%s did not pass type constraint (not isa %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not isa %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Class;
  	return "Moose::Meta::TypeConstraint::Class"->new(%opts, class => $self->class);
  }
  
  sub plus_constructors
  {
  	my $self = shift;
  	
  	unless (@_)
  	{
  		require Types::Standard;
  		push @_, Types::Standard::HashRef(), "new";
  	}
  	
  	require B;
  	require Types::TypeTiny;
  	
  	my $class = B::perlstring($self->class);
  	
  	my @r;
  	while (@_)
  	{
  		my $source = shift;
  		Types::TypeTiny::TypeTiny->check($source)
  			or _croak "Expected type constraint; got $source";
  		
  		my $constructor = shift;
  		Types::TypeTiny::StringLike->check($constructor)
  			or _croak "Expected string; got $constructor";
  		
  		push @r, $source, sprintf('%s->%s($_)', $class, $constructor);
  	}
  	
  	return $self->plus_coercions(\@r);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self  = shift;
  	my $class = $self->class;
  	
  	my @isa = grep $class->isa($_), do { no strict "refs"; no warnings; @{"$class\::ISA"} };
  	
  	if (@isa == 0)
  	{
  		require Types::Standard;
  		return Types::Standard::Object();
  	}
  	
  	if (@isa == 1)
  	{
  		return ref($self)->new(class => $isa[0])
  	}
  	
  	require Type::Tiny::Intersection;
  	"Type::Tiny::Intersection"->new(
  		type_constraints => [ map ref($self)->new(class => $_), @isa ],
  	);
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	my @isa;
  	if (eval { require mro })
  	{
  		@isa = @{ mro::get_linear_isa(ref $value) };
  	}
  	else
  	{
  		require Class::ISA;
  		@isa = Class::ISA::super_path(ref $value);
  	}
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	require Type::Utils;
  	return [
  		sprintf('"%s" requires that the reference isa %s', $self, $self->class),
  		sprintf('The reference%s isa %s', $display_var, Type::Utils::english_list(@isa)),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Class - type constraints based on the "isa" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->isa("Some::Class") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Constructor
  
  =over
  
  =item C<new>
  
  When the constructor is called on an I<instance> of Type::Tiny::Class, it
  passes the call through to the constructor of the class for the constraint.
  So for example:
  
     my $type = Type::Tiny::Class->new(class => "Foo::Bar");
     my $obj  = $type->new(hello => "World");
     say ref($obj);   # prints "Foo::Bar"
  
  This little bit of DWIM was borrowed from L<MooseX::Types::TypeDecorator>,
  but Type::Tiny doesn't take the idea quite as far.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<class>
  
  The class for the constraint.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is automatically calculated, and cannot be passed to the constructor.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< plus_constructors($source, $method_name) >>
  
  Much like C<plus_coercions> but adds coercions that go via a constructor.
  (In fact, this is implemented as a wrapper for C<plus_coercions>.)
  
  Example:
  
     package MyApp::Minion;
     
     use Moose; extends "MyApp::Person";
     
     use Types::Standard qw( HashRef Str );
     use Type::Utils qw( class_type );
     
     my $Person = class_type({ class => "MyApp::Person" });
     
     has boss => (
        is     => "ro",
        isa    => $Person->plus_constructors(
           HashRef,     "new",
           Str,         "_new_from_name",
        ),
        coerce => 1,
     );
     
     package main;
     
     MyApp::Minion->new(
        ...,
        boss => "Bob",  ## via MyApp::Person->_new_from_name
     );
     
     MyApp::Minion->new(
        ...,
        boss => { name => "Bob" },  ## via MyApp::Person->new
     );
  
  Because coercing C<HashRef> via constructor is a common desire, if
  you call C<plus_constructors> with no arguments at all, this is the
  default.
  
     $classtype->plus_constructors(Types::Standard::HashRef, "new")
     $classtype->plus_constructors()  ## identical to above
  
  This is handy for Moose/Mouse/Moo-based classes.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Class>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_CLASS

$fatpacked{"Type/Tiny/Duck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_DUCK';
  package Type::Tiny::Duck;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Duck::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Duck::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Duck type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Duck type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Duck type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of methods" unless exists $opts{methods};
  	
  	$opts{methods} = [$opts{methods}] unless ref $opts{methods};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub methods     { $_[0]{methods} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self    = shift;
  	my @methods = @{$self->methods};
  	return sub { blessed($_[0]) and not grep(!$_[0]->can($_), @methods) };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my @methods = @{$self->methods};
  	sub {
  		my $var = $_[1];
  		local $" = q{ };
  		qq{ Scalar::Util::blessed($var) and not grep(!$var->can(\$_), qw/@methods/) };
  	};
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	require Moose::Meta::TypeConstraint::DuckType;
  	return "Moose::Meta::TypeConstraint::DuckType"->new(%opts, methods => $self->methods);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the reference can %s',
  			$self,
  			Type::Utils::english_list(map qq["$_"], @{$self->methods}),
  		),
  		map  sprintf('The reference cannot "%s"', $_),
  		grep !$value->can($_),
  		@{$self->methods}
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Duck - type constraints based on the "can" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->can("method") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<methods>
  
  An arrayref of method names.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::DuckType>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_DUCK

$fatpacked{"Type/Tiny/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ENUM';
  package Type::Tiny::Enum;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Enum::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Enum::VERSION   = '0.038';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => 'values';
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new
  {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Enum type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Enum type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Enum type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of values" unless exists $opts{values};
  	
  	my %tmp =
  		map { $_ => 1 }
  		@{ ref $opts{values} eq "ARRAY" ? $opts{values} : [$opts{values}] };
  	$opts{values} = [sort keys %tmp];
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub values      { $_[0]{values} }
  sub constraint  { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	sprintf("Enum[%s]", join q[,], @$self);
  }
  
  sub _build_constraint
  {
  	my $self = shift;
  	my $regexp = join "|", map quotemeta, @$self;
  	return sub { defined and m{\A(?:$regexp)\z} };
  }
  
  sub can_be_inlined
  {
  	!!1;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	my $regexp = join "|", map quotemeta, @$self;
  	$_[0] eq '$_'
  		? "(defined and !ref and m{\\A(?:$regexp)\\z})"
  		: "(defined($_[0]) and !ref($_[0]) and $_[0] =~ m{\\A(?:$regexp)\\z})";
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Enum;
  	return "Moose::Meta::TypeConstraint::Enum"->new(%opts, values => $self->values);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Str();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	!defined($value) ? [
  		sprintf(
  			'"%s" requires that the value is defined',
  			$self,
  		),
  	] :
  	@$self < 13 ? [
  		sprintf(
  			'"%s" requires that the value is equal to %s',
  			$self,
  			Type::Utils::english_list(\"or", map B::perlstring($_), @$self),
  		),
  	] :
  	[
  		sprintf(
  			'"%s" requires that the value is one of an enumerated list of strings',
  			$self,
  		),
  	];
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Enum - string enum type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Enum type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<values>
  
  Arrayref of allowable value strings. Non-string values (e.g. objects with
  overloading) will be stringified in the constructor.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Str, and cannot be passed to the
  constructor.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<values>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Enum>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ENUM

$fatpacked{"Type/Tiny/Intersection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_INTERSECTION';
  package Type::Tiny::Intersection;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Intersection::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Intersection::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Intersection type constraints cannot have a parent constraint" if exists $opts{parent};
  	_croak "Intersection type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Intersection type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[&], @$self;
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) || return for @checks;
  		return !!1;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	sprintf '(%s)', join " and ", map $_->inline_check($_[0]), @$self;
  }
  
  sub has_parent
  {
  	!!@{ $_[0]{type_constraints} };
  }
  
  sub parent
  {
  	$_[0]{type_constraints}[0];
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	for my $type (@$self)
  	{
  		my $deep = $type->validate_explain($value, $varname);
  		return [
  			sprintf(
  				'"%s" requires that the value pass %s',
  				$self,
  				Type::Utils::english_list(map qq["$_"], @$self),
  			),
  			@$deep,
  		] if $deep;
  	}
  	
  	return ["Mysterious!"];
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Intersection - intersection type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Intersection type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the
  intersection is itself an intersection type constraint, this is "exploded"
  into the new intersection.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  (Technically any of the types in the intersection could be treated as a
  parent type; we choose the first arbitrarily.)
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<MooseX::Meta::TypeConstraint::Intersection>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_INTERSECTION

$fatpacked{"Type/Tiny/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ROLE';
  package Type::Tiny::Role;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Role::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Role::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed weaken >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  my %cache;
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Role type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Role type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Role type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply role name" unless exists $opts{role};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub role        { $_[0]{role} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self = shift;
  	my $role = $self->role;
  	return sub { blessed($_) and do { my $method = $_->can('DOES')||$_->can('isa'); $_->$method($role) } };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my $role = $self->role;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and do { my \$method = $var->can('DOES')||$var->can('isa'); $var->\$method(q[$role]) }};
  	};
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	my $c = $self->role;
  	return sub { sprintf '%s did not pass type constraint (not DOES %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not DOES %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	return ["Reference provides no DOES method to check roles"] unless $value->can('DOES');
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	return [
  		sprintf('"%s" requires that the reference does %s', $self, $self->role),
  		sprintf("The reference%s doesn't %s", $display_var, $self->role),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Role - type constraints based on the "DOES" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->DOES("Some::Role") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<role>
  
  The role for the constraint.
  
  Note that this package doesn't subscribe to any particular flavour of roles
  (L<Moose::Role>, L<Mouse::Role>, L<Moo::Role>, L<Role::Tiny>, etc). It simply
  trusts the object's C<DOES> method (see L<UNIVERSAL>).
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Role>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ROLE

$fatpacked{"Type/Tiny/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_UNION';
  package Type::Tiny::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Union::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Union type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Union type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Union type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	my $self = $proto->SUPER::new(%opts);
  	$self->coercion if grep $_->has_coercion, @$self;
  	return $self;
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[|], @$self;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion::Union;
  	my $self = shift;
  	return "Type::Coercion::Union"->new(type_constraint => $self);
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) && return !!1 for @checks;
  		return;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	sprintf '(%s)', join " or ", map $_->inline_check($_[0]), @$self;
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	my @tc = map $_->moose_type, @{$self->type_constraints};
  	
  	require Moose::Meta::TypeConstraint::Union;
  	return "Moose::Meta::TypeConstraint::Union"->new(%opts, type_constraints => \@tc);
  }
  
  sub has_parent
  {
  	defined(shift->parent);
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self = shift;
  	my ($first, @rest) = @$self;
  	
  	for my $parent ($first, $first->parents)
  	{
  		return $parent unless grep !$_->is_a_type_of($parent), @rest;
  	}
  	
  	return;
  }
  
  sub find_type_for
  {
  	my @types = @{+shift};
  	for my $type (@types)
  	{
  		return $type if $type->check(@_);
  	}
  	return;
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the value pass %s',
  			$self,
  			Type::Utils::english_list(\"or", map qq["$_"], @$self),
  		),
  		map {
  			$_->get_message($value),
  			map("    $_", @{ $_->validate_explain($value) || []}),
  		} @$self
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Union - union type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Union type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the union
  is itself a union type constraint, this is "exploded" into the new union.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  =item C<coercion>
  
  Will typically be a L<Type::Coercion::Union>.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< find_type_for($value) >>
  
  Returns the first individual type constraint in the union which
  C<< $value >> passes.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_UNION

$fatpacked{"Type/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_UTILS';
  package Type::Utils;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Utils::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Utils::VERSION   = '0.038';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Scalar::Util qw< blessed >;
  use Type::Library;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny HashLike StringLike CodeLike >;
  
  our @EXPORT = qw<
  	declare as where message inline_as
  	class_type role_type duck_type union intersection enum
  	coerce from via
  	declare_coercion to_type
  >;
  our @EXPORT_OK = (
  	@EXPORT,
  	qw<
  		extends type subtype
  		match_on_type compile_match_on_type
  		dwim_type english_list
  	>,
  );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  sub extends
  {
  	_croak "Not a type library" unless caller->isa("Type::Library");
  	my $caller = caller->meta;
  	
  	foreach my $lib (@_)
  	{
  		eval "use $lib; 1" or _croak "Could not load library '$lib': $@";
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$caller->add_type( $lib->get_type($_) )
  				for sort $lib->meta->type_names;
  			$caller->add_coercion( $lib->get_coercion($_) )
  				for sort $lib->meta->coercion_names;
  		}
  		elsif ($lib->isa('MooseX::Types::Base'))
  		{
  			require Moose::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $moose = Moose::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($moose);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $moose->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		elsif ($lib->isa('MouseX::Types::Base'))
  		{
  			require Mouse::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $mouse = Mouse::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($mouse);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $mouse->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		else
  		{
  			_croak("'$lib' is not a type constraint library");
  		}
  	}
  }
  
  sub declare
  {
  	my %opts;
  	if (@_ % 2 == 0)
  	{
  		%opts = @_;
  	}
  	else
  	{
  		(my($name), %opts) = @_;
  		_croak "Cannot provide two names for type" if exists $opts{name};
  		$opts{name} = $name;
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	if (defined $opts{parent})
  	{
  		$opts{parent} = to_TypeTiny($opts{parent});
  		
  		unless (TypeTiny->check($opts{parent}))
  		{
  			$caller->isa("Type::Library")
  				or _croak("Parent type cannot be a %s", ref($opts{parent})||'non-reference scalar');
  			$opts{parent} = $caller->meta->get_type($opts{parent})
  				or _croak("Could not find parent type");
  		}
  	}
  	
  	my $type;
  	if (defined $opts{parent})
  	{
  		$type = delete($opts{parent})->create_child_type(%opts);
  	}
  	else
  	{
  		my $bless = delete($opts{bless}) || "Type::Tiny";
  		eval "require $bless";
  		$type = $bless->new(%opts);
  	}
  	
  	if ($caller->isa("Type::Library"))
  	{
  		$caller->meta->add_type($type) unless $type->is_anon;
  	}
  	
  	return $type;
  }
  
  *subtype = \&declare;
  *type = \&declare;
  
  sub as (@)
  {
  	parent => @_;
  }
  
  sub where (&;@)
  {
  	constraint => @_;
  }
  
  sub message (&;@)
  {
  	message => @_;
  }
  
  sub inline_as (&;@)
  {
  	inlined => @_;
  }
  
  sub class_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ +shift };
  	
  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{class} = $name unless exists $opts{class};
  	}
  	
  	$opts{bless} = "Type::Tiny::Class";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub role_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ +shift };
  	
  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{role}  = $name unless exists $opts{role};
  	}
  	
  	$opts{bless} = "Type::Tiny::Role";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub duck_type
  {
  	my $name    = ref($_[0]) ? undef : shift;
  	my @methods = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{methods} = \@methods;
  	
  	$opts{bless} = "Type::Tiny::Duck";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub enum
  {
  	my $name   = ref($_[0]) ? undef : shift;
  	my @values = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{values} = \@values;
  	
  	$opts{bless} = "Type::Tiny::Enum";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub union
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Union";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub intersection
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Intersection";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub declare_coercion
  {
  	my %opts;
  	$opts{name} = shift if !ref($_[0]);
  	
  	while (HashLike->check($_[0]) and not TypeTiny->check($_[0]))
  	{
  		%opts = (%opts, %{+shift});
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	my $bless = delete($opts{bless}) || "Type::Coercion";
  	eval "require $bless";
  	my $c = $bless->new(%opts);
  	
  	my @C;
  	
  	if ($caller->isa("Type::Library"))
  	{
  		my $meta = $caller->meta;
  		$meta->add_coercion($c) unless $c->is_anon;
  		while (@_)
  		{
  			push @C, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @C, shift;
  		}
  	}
  	
  	$c->add_type_coercions(@C);
  	
  	return $c->freeze;
  }
  
  sub coerce
  {
  	if ((scalar caller)->isa("Type::Library"))
  	{
  		my $meta = (scalar caller)->meta;
  		my ($type) = map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  		my @opts;
  		while (@_)
  		{
  			push @opts, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @opts, shift;
  		}
  		return $type->coercion->add_type_coercions(@opts);
  	}
  	
  	my ($type, @opts) = @_;
  	$type = to_TypeTiny($type);
  	return $type->coercion->add_type_coercions(@opts);
  }
  
  sub from (@)
  {
  	return @_;
  }
  
  sub to_type (@)
  {
  	my $type = shift;
  	unless (TypeTiny->check($type))
  	{
  		caller->isa("Type::Library")
  			or _croak "Target type cannot be a string";
  		$type = caller->meta->get_type($type)
  			or _croak "Could not find target type";
  	}
  	return +{ type_constraint => $type }, @_;
  }
  
  sub via (&;@)
  {
  	return @_;
  }
  
  sub match_on_type
  {
  	my $value = shift;
  	
  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}
  		
  		$type->check($value) or next;
  		
  		if (StringLike->check($code))
  		{
  			local $_ = $value;
  			if (wantarray) {
  				my @r = eval "$code";
  				die $@ if $@;
  				return @r;
  			}
  			if (defined wantarray) {
  				my $r = eval "$code";
  				die $@ if $@;
  				return $r;
  			}
  			eval "$code";
  			die $@ if $@;
  			return;
  		}
  		else
  		{
  			CodeLike->($code);
  			local $_ = $value;
  			return $code->($value);
  		}
  	}
  	
  	_croak("No cases matched for %s", Type::Tiny::_dd($value));
  }
  
  sub compile_match_on_type
  {
  	my @code = 'sub { local $_ = $_[0]; ';
  	my @checks;
  	my @actions;
  	
  	my $els = '';
  	
  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}
  		
  		if ($type->can_be_inlined)
  		{
  			push @code, sprintf('%sif (%s)', $els, $type->inline_check('$_'));
  		}
  		else
  		{
  			push @checks, $type;
  			push @code, sprintf('%sif ($checks[%d]->check($_))', $els, $#checks);
  		}
  		
  		$els = 'els';
  		
  		if (StringLike->check($code))
  		{
  			push @code, sprintf('  { %s }', $code);
  		}
  		else
  		{
  			CodeLike->($code);
  			push @actions, $code;
  			push @code, sprintf('  { $actions[%d]->(@_) }', $#actions);
  		}
  	}
  	
  	push @code, 'else', '  { Type::Util::_croak("No cases matched for %s", Type::Tiny::_dd($_[0])) }';
  	
  	push @code, '}';  # /sub
  	
  	require Eval::TypeTiny;
  	return Eval::TypeTiny::eval_closure(
  		source      => \@code,
  		environment => {
  			'@actions' => \@actions,
  			'@checks'  => \@checks,
  		},
  	);
  }
  
  {
  	package #hide
  	Type::Registry::DWIM;
  	
  	our @ISA = qw(Type::Registry);
  	
  	sub simple_lookup
  	{
  		my $self = shift;
  		my $r;
  		
  		# If the lookup is chained to a class, then the class' own
  		# type registry gets first refusal.
  		#
  		if (defined $self->{"~~chained"})
  		{
  			my $chained = "Type::Registry"->for_class($self->{"~~chained"});
  			$r = eval { $chained->simple_lookup(@_) } unless $self == $chained;
  			return $r if defined $r;
  		}
  		
  		# Fall back to types in Types::Standard.
  		require Types::Standard;
  		return 'Types::Standard'->get_type($_[0]) if 'Types::Standard'->has_type($_[0]);
  		
  		# Only continue any further if we've been called from Type::Parser.
  		return unless $_[1];
  		
  		# If Moose is loaded...
  		if ($INC{'Moose.pm'})
  		{
  			require Moose::Util::TypeConstraints;
  			require Types::TypeTiny;
  			$r = Moose::Util::TypeConstraints::find_type_constraint($_[0]);
  			return Types::TypeTiny::to_TypeTiny($r) if defined $r;
  		}
  		
  		# If Mouse is loaded...
  		if ($INC{'Mouse.pm'})
  		{
  			require Mouse::Util::TypeConstraints;
  			require Types::TypeTiny;
  			$r = Mouse::Util::TypeConstraints::find_type_constraint($_[0]);
  			return Types::TypeTiny::to_TypeTiny($r) if defined $r;
  		}
  		
  		return unless $_[0] =~ /^\s*(\w+(::\w+)*)\s*$/sm;
  		return unless defined $self->{"~~assume"};
  		
  		# Lastly, if it looks like a class/role name, assume it's
  		# supposed to be a class/role type.
  		#
  		
  		if ($self->{"~~assume"} eq "Type::Tiny::Class")
  		{
  			require Type::Tiny::Class;
  			return "Type::Tiny::Class"->new(class => $_[0]);
  		}
  		
  		if ($self->{"~~assume"} eq "Type::Tiny::Role")
  		{
  			require Type::Tiny::Role;
  			return "Type::Tiny::Role"->new(role => $_[0]);
  		}
  		
  		die;
  	}
  }
  
  our $dwimmer;
  sub dwim_type
  {
  	my ($string, %opts) = @_;
  	$opts{for} = caller unless defined $opts{for};
  	
  	$dwimmer ||= do {
  		require Type::Registry;
  		'Type::Registry::DWIM'->new;
  	};
  	
  	local $dwimmer->{'~~chained'} = $opts{for};
  	local $dwimmer->{'~~assume'}  = $opts{does} ? 'Type::Tiny::Role' : 'Type::Tiny::Class';
  	
  	$dwimmer->lookup($string);
  }
  
  sub english_list
  {
  	my $conjunction = ref($_[0]) eq 'SCALAR' ? ${+shift} : 'and';
  	my @items = sort @_;
  	
  	return $items[0] if @items == 1;
  	return "$items[0] $conjunction $items[1]" if @items == 2;
  	
  	my $tail = pop @items;
  	join(', ', @items, "$conjunction $tail");
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smush smushed
  
  =head1 NAME
  
  Type::Utils - utility functions to make defining and using type constraints a little easier
  
  =head1 SYNOPSIS
  
     package Types::Mine;
     
     use Type::Library -base;
     use Type::Utils -all;
     
     BEGIN { extends "Types::Standard" };
     
     declare "AllCaps",
        as "Str",
        where { uc($_) eq $_ },
        inline_as { my $varname = $_[1]; "uc($varname) eq $varname" };
     
     coerce "AllCaps",
        from "Str", via { uc($_) };
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This module provides utility functions to make defining and using type
  constraints a little easier. 
  
  =head2 Type declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< declare $name, %options >>
  
  =item C<< declare %options >>
  
  Declare a named or anonymous type constraint. Use C<as> and C<where> to
  specify the parent type (if any) and (possibly) refine its definition.
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
     my $EvenInt = declare as Int, where { $_ % 2 == 0 };
  
  B<< NOTE: >>
  If the caller package inherits from L<Type::Library> then any non-anonymous
  types declared in the package will be automatically installed into the
  library.
  
  Hidden gem: if you're inheriting from a type constraint that includes some
  coercions, you can include C<< coercion => 1 >> in the C<< %options >> hash
  to inherit the coercions.
  
  =item C<< subtype $name, %options >>
  
  =item C<< subtype %options >>
  
  Declare a named or anonymous type constraint which is descended from an
  existing type constraint. Use C<as> and C<where> to specify the parent
  type and refine its definition.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< type $name, %options >>
  
  =item C<< type %options >>
  
  Declare a named or anonymous type constraint which is not descended from
  an existing type constraint. Use C<where> to provide a coderef that
  constrains values.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< as $parent >>
  
  Used with C<declare> to specify a parent type constraint:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  =item C<< where { BLOCK } >>
  
  Used with C<declare> to provide the constraint coderef:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  The coderef operates on C<< $_ >>, which is the value being tested.
  
  =item C<< message { BLOCK } >>
  
  Generate a custom error message when a value fails validation.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        message {
           Int->validate($_) or "$_ is not divisible by two";
        };
  
  Without a custom message, the messages generated by Type::Tiny are along
  the lines of I<< Value "33" did not pass type constraint "EvenInt" >>,
  which is usually reasonable.
  
  =item C<< inline_as { BLOCK } >>
  
  Generate a string of Perl code that can be used to inline the type check into
  other functions. If your type check is being used within a L<Moose> or L<Moo>
  constructor or accessor methods, or used by L<Type::Params>, this can lead to
  significant performance improvements.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           my ($constraint, $varname) = @_;
           my $perlcode = 
              $constraint->parent->inline_check($varname)
              . "&& ($varname % 2 == 0)";
           return $perlcode;
        };
     
     warn EvenInt->inline_check('$xxx');  # demonstration
  
  B<Experimental:> your C<inline_as> block can return a list, in which case
  these will be smushed together with "&&". The first item on the list may
  be undef, in which case the undef will be replaced by the inlined parent
  type constraint. (And will throw an exception if there is no parent.)
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           return (undef, "($_ % 2 == 0)");
        };
  
  Returning a list like this is considered experimental, is not tested very
  much, and I offer no guarantees that it will necessarily work with
  Moose/Mouse/Moo.
  
  =item C<< class_type $name, { class => $package, %options } >>
  
  =item C<< class_type { class => $package, %options } >>
  
  Shortcut for declaring a L<Type::Tiny::Class> type constraint.
  
  =item C<< role_type $name, { role => $package, %options } >>
  
  =item C<< role_type { role => $package, %options } >>
  
  Shortcut for declaring a L<Type::Tiny::Role> type constraint.
  
  =item C<< duck_type $name, \@methods >>
  
  =item C<< duck_type \@methods >>
  
  Shortcut for declaring a L<Type::Tiny::Duck> type constraint.
  
  =item C<< union $name, \@constraints >>
  
  =item C<< union \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Union> type constraint.
  
  =item C<< enum $name, \@values >>
  
  =item C<< enum \@values >>
  
  Shortcut for declaring a L<Type::Tiny::Enum> type constraint.
  
  =item C<< intersection $name, \@constraints >>
  
  =item C<< intersection \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Intersection> type constraint.
  
  =back
  
  =head2 Coercion declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< coerce $target, @coercions >>
  
  Add coercions to the target type constraint. The list of coercions is a
  list of type constraint, conversion code pairs. Conversion code can be
  either a string of Perl code or a coderef; in either case the value to
  be converted is C<< $_ >>.
  
  =item C<< from $source >>
  
  Sugar to specify a type constraint in a list of coercions:
  
     coerce EvenInt, from Int, via { $_ * 2 };  # As a coderef...
     coerce EvenInt, from Int, q { $_ * 2 };    # or as a string!
  
  =item C<< via { BLOCK } >>
  
  Sugar to specify a coderef in a list of coercions.
  
  =item C<< declare_coercion $name, \%opts, $type1, $code1, ... >>
  
  =item C<< declare_coercion \%opts, $type1, $code1, ... >>
  
  Declares a coercion that is not explicitly attached to any type in the
  library. For example:
  
     declare_coercion "ArrayRefFromAny", from "Any", via { [$_] };
  
  This coercion will be exportable from the library as a L<Type::Coercion>
  object, but the ArrayRef type exported by the library won't automatically
  use it.
  
  Coercions declared this way are immutable (frozen).
  
  =item C<< to_type $type >>
  
  Used with C<declare_coercion> to declare the target type constraint for
  a coercion, but still without explicitly attaching the coercion to the
  type constraint:
  
     declare_coercion "ArrayRefFromAny",
        to_type "ArrayRef",
        from "Any", via { [$_] };
  
  You should pretty much always use this when declaring an unattached
  coercion because it's exceedingly useful for a type coercion to know what
  it will coerce to - this allows it to skip coercion when no coercion is
  needed (e.g. avoiding coercing C<< [] >> to C<< [ [] ] >>) and allows
  C<assert_coerce> to work properly.
  
  =back
  
  =head2 Type library management
  
  =over
  
  =item C<< extends @libraries >>
  
  Indicates that this type library extends other type libraries, importing
  their type constraints.
  
  Should usually be executed in a C<< BEGIN >> block.
  
  This is not exported by default because it's not fun to export it to Moo,
  Moose or Mouse classes! C<< use Type::Utils -all >> can be used to import
  it into your type library.
  
  =back
  
  =head2 Other
  
  =over
  
  =item C<< match_on_type $value => ($type => \&action, ..., \&default?) >>
  
  Something like a C<switch>/C<case> or C<given>/C<when> construct. Dispatches
  along different code paths depending on the type of the incoming value.
  Example blatantly stolen from the Moose documentation:
  
     sub to_json
     {
        my $value = shift;
        
        return match_on_type $value => (
           HashRef() => sub {
              my $hash = shift;
              '{ '
                 . (
                 join ", " =>
                 map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                 sort keys %$hash
              ) . ' }';
           },
           ArrayRef() => sub {
              my $array = shift;
              '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
           },
           Num()   => q {$_},
           Str()   => q { '"' . $_ . '"' },
           Undef() => q {'null'},
           => sub { die "$_ is not acceptable json type" },
        );
     }
  
  Note that unlike Moose, code can be specified as a string instead of a
  coderef. (e.g. for C<Num>, C<Str> and C<Undef> above.)
  
  For improved performance, try C<compile_match_on_type>.
  
  This function is not exported by default.
  
  =item C<< my $coderef = compile_match_on_type($type => \&action, ..., \&default?) >>
  
  Compile a C<match_on_type> block into a coderef. The following JSON
  converter is about two orders of magnitude faster than the previous
  example:
  
     sub to_json;
     *to_json = compile_match_on_type(
        HashRef() => sub {
           my $hash = shift;
           '{ '
              . (
              join ", " =>
              map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
              sort keys %$hash
           ) . ' }';
        },
        ArrayRef() => sub {
           my $array = shift;
           '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
        },
        Num()   => q {$_},
        Str()   => q { '"' . $_ . '"' },
        Undef() => q {'null'},
        => sub { die "$_ is not acceptable json type" },
     );
  
  Remember to store the coderef somewhere fairly permanent so that you
  don't compile it over and over. C<state> variables (in Perl >= 5.10)
  are good for this. (Same sort of idea as L<Type::Params>.)
  
  This function is not exported by default.
  
  =item C<< dwim_type($string, %options) >>
  
  Given a string like "ArrayRef[Int|CodeRef]", turns it into a type constraint
  object, hopefully doing what you mean.
  
  It uses the syntax of L<Type::Parser>. Firstly the L<Type::Registry>
  for the caller package is consulted; if that doesn't have a match,
  L<Types::Standard> is consulted for type constraint names; and if
  there's still no match, then if a type constraint looks like a class
  name, a new L<Type::Tiny::Class> object is created for it.
  
  Somewhere along the way, it also checks Moose/Mouse's type constraint
  registries if they are loaded.
  
  You can specify an alternative for the caller using the C<for> option.
  If you'd rather create a L<Type::Tiny::Role> object, set the C<does>
  option to true.
  
     # An arrayref of objects, each of which must do role Foo.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);
     
     Type::Registry->for_me->add_types("-Standard");
     Type::Registry->for_me->alias_type("Int" => "Foo");
     
     # An arrayref of integers.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);
  
  While it's probably better overall to use the proper L<Type::Registry>
  interface for resolving type constraint strings, this function often does
  what you want.
  
  It should never die if it fails to find a type constraint (but may die
  if the type constraint string is syntactically malformed), preferring to
  return undef.
  
  This function is not exported by default.
  
  =item C<< english_list(\$conjunction, @items) >>
  
  Joins the items with commas, placing a conjunction before the final item.
  The conjunction is optional, defaulting to "and".
  
     english_list(qw/foo bar baz/);       # "foo, bar, and baz"
     english_list(\"or", qw/quux quuux/); # "quux or quuux"
  
  This function is not exported by default.
  
  =back
  
  =head1 EXPORT
  
  By default, all of the functions documented above are exported, except
  C<subtype> and C<type> (prefer C<declare> instead), C<extends>, C<dwim_type>,
  and C<match_on_type>/C<compile_match_on_type>.
  
  This module uses L<Exporter::Tiny>; see the documentation of that module
  for tips and tricks importing from Type::Utils.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_UTILS

$fatpacked{"Types/Common/Numeric.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_NUMERIC';
  package Types::Common::Numeric;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::Numeric::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::Numeric::VERSION   = '0.038';
  }
  
  use Type::Library -base, -declare => qw(
  	PositiveNum PositiveOrZeroNum
  	PositiveInt PositiveOrZeroInt
  	NegativeNum NegativeOrZeroNum
  	NegativeInt NegativeOrZeroInt
  	SingleDigit
  );
  
  use Types::Standard qw( Num Int );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => 'PositiveNum',
  	parent     => Num,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive number" },
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be a number greater than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'PositiveInt',
  	parent     => Int,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive integer" },
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be an integer greater than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'NegativeNum',
  	parent     => Num,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative number" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be a number less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'NegativeInt',
  	parent     => Int,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative integer" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be an integer less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'SingleDigit',
  	parent     => Int,
  	constraint => sub { $_ >= -9 and $_ <= 9 },
  	inlined    => sub { undef, qq($_ >= -9), qq($_ <= 9) },
  	message    => sub { "Must be a single digit" },
  );
   
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::Numeric - drop-in replacement for MooseX::Types::Common::Numeric
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::Numeric>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::Numeric>.
  
  =over
  
  =item C<PositiveNum>
  
  =item C<PositiveOrZeroNum>
  
  =item C<PositiveInt>
  
  =item C<PositiveOrZeroInt>
  
  =item C<NegativeNum>
  
  =item C<NegativeOrZeroNum>
  
  =item C<NegativeInt>
  
  =item C<NegativeOrZeroInt>
  
  =item C<SingleDigit>
  
  =back
  
  C<SingleDigit> interestingly accepts the numbers -9 to -1; not
  just 0 to 9. 
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::String>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_NUMERIC

$fatpacked{"Types/Common/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_STRING';
  package Types::Common::String;
  
  use 5.006001;
  use strict;
  use warnings;
  use utf8;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::String::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::String::VERSION   = '0.038';
  }
  
  use Type::Library -base, -declare => qw(
  	SimpleStr
  	NonEmptySimpleStr
  	NumericCode
  	LowerCaseSimpleStr
  	UpperCaseSimpleStr
  	Password
  	StrongPassword
  	NonEmptyStr
  	LowerCaseStr
  	UpperCaseStr
  );
  
  use Types::Standard qw( Str );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => SimpleStr,
  	parent     => Str,
  	constraint => sub { length($_) <= 255 and not /\n/ },
  	inlined    => sub { undef, qq(length($_) <= 255), qq($_ !~ /\\n/) },
  	message    => sub { "Must be a single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NonEmptySimpleStr,
  	parent     => SimpleStr,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must be a non-empty single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NumericCode,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { /^[0-9]+$/ },
  	inlined    => sub { SimpleStr->inline_check($_), qq($_ =~ m/^[0-9]+\$/) },
  	message    => sub {
  		'Must be a non-empty single line of no more than 255 chars that consists '
  			. 'of numeric characters only'
  	},
  );
  
  NumericCode->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ do { (my $code = $_) =~ s/[[:punct:]]//g; $code } ],
  );
  
  $meta->add_type(
  	name       => Password,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { length($_) > 3 },
  	inlined    => sub { SimpleStr->inline_check($_), qq(length($_) > 3) },
  	message    => sub { "Must be between 4 and 255 chars" },
  );
  
  $meta->add_type(
  	name       => StrongPassword,
  	parent     => Password,
  	constraint => sub { length($_) > 7 and /[^a-zA-Z]/ },
  	inlined    => sub { SimpleStr()->inline_check($_), qq(length($_) > 7), qq($_ =~ /[^a-zA-Z]/) },
  	message    => sub { "Must be between 8 and 255 chars, and contain a non-alpha char" },
  );
  
  $meta->add_type(
  	name       => NonEmptyStr,
  	parent     => Str,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must not be empty" },
  );
  
  $meta->add_type(
  	name       => LowerCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain upper case letters" },
  );
  
  LowerCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ uc($_) ],
  );
  
  $meta->add_type(
  	name       => LowerCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain pper case letters" },
  );
  
  LowerCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ uc($_) ],
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::String - drop-in replacement for MooseX::Types::Common::String
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::String>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::String>.
  
  =over
  
  =item C<SimpleStr>
  
  =item C<NonEmptySimpleStr>
  
  =item C<NumericCode>
  
  =item C<LowerCaseSimpleStr>
  
  =item C<UpperCaseSimpleStr>
  
  =item C<Password>
  
  =item C<StrongPassword>
  
  =item C<NonEmptyStr>
  
  =item C<LowerCaseStr>
  
  =item C<UpperCaseStr>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::Numeric>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_STRING

$fatpacked{"Types/Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Types::Path::Tiny;
  # ABSTRACT: Path::Tiny types and coercions for Moose and Moo
  our $VERSION = '0.005'; # VERSION
  
  use Path::Tiny qw();
  use Type::Library 0.008 -base, -declare => qw( Path AbsPath File AbsFile Dir AbsDir );
  use Type::Utils;
  use Types::Standard qw( Str ArrayRef );
  use Types::TypeTiny 0.004 StringLike => { -as => "Stringable" };
  
  #<<<
  class_type Path, { class => "Path::Tiny" };
  
  declare AbsPath,
      as Path, where { $_->is_absolute },
      inline_as { $_[0]->parent->inline_check($_) . "&& ${_}->is_absolute" },
      message {
          is_Path($_) ? "Path '$_' is not absolute" : Path->get_message($_);
      };
  
  declare File,
      as Path, where { $_->is_file },
      inline_as { $_[0]->parent->inline_check($_) . "&& (-f $_)" },
      message {
          is_Path($_) ? "File '$_' does not exist" : Path->get_message($_);
      };
  
  declare Dir,
      as Path, where { $_->is_dir },
      inline_as { $_[0]->parent->inline_check($_) . "&& (-d $_)" },
      message {
          is_Path($_) ? "Directory '$_' does not exist" : Path->get_message($_);
      };
  
  declare AbsFile,
      as intersection([AbsPath, File]),
      message {
          is_AbsPath($_) ? File->get_message($_) : AbsPath->get_message($_);
      };
  
  declare AbsDir,
      as intersection([AbsPath, Dir]),
      message {
          is_AbsPath($_) ? Dir->get_message($_) : AbsPath->get_message($_);
      };
  #>>>
  
  for my $type ( Path, File, Dir ) {
      coerce(
          $type,
          from Str()        => q{ Path::Tiny::path($_) },
          from Stringable() => q{ Path::Tiny::path($_) },
          from ArrayRef()   => q{ Path::Tiny::path(@$_) },
      );
  }
  
  for my $type ( AbsPath, AbsFile, AbsDir ) {
      coerce(
          $type,
          from Path         => q{ $_->absolute },
          from Str()        => q{ Path::Tiny::path($_)->absolute },
          from Stringable() => q{ Path::Tiny::path($_)->absolute },
          from ArrayRef()   => q{ Path::Tiny::path(@$_)->absolute },
      );
  }
  
  ### optionally add Getopt option type (adapted from MooseX::Types:Path::Class
  ##eval { require MooseX::Getopt; };
  ##if ( !$@ ) {
  ##    MooseX::Getopt::OptionTypeMap->add_option_type_to_map( $_, '=s', )
  ##      for ( 'Path::Tiny', Path );
  ##}
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Path::Tiny - Path::Tiny types and coercions for Moose and Moo
  
  =head1 VERSION
  
  version 0.005
  
  =head1 SYNOPSIS
  
    ### specification of type constraint with coercion
  
    package Foo;
  
    use Moose;
    use Types::Path::Tiny qw/Path AbsPath/;
  
    has filename => (
      is => 'ro',
      isa => Path,
      coerce => 1,
    );
  
    has directory => (
      is => 'ro',
      isa => AbsPath,
      coerce => 1,
    );
  
    ### usage in code
  
    Foo->new( filename => 'foo.txt' ); # coerced to Path::Tiny
    Foo->new( directory => '.' ); # coerced to path('.')->absolute
  
  =head1 DESCRIPTION
  
  This module provides L<Path::Tiny> types for Moose, Moo, etc.
  
  It handles two important types of coercion:
  
  =over 4
  
  =item *
  
  coercing objects with overloaded stringification
  
  =item *
  
  coercing to absolute paths
  
  =back
  
  It also can check to ensure that files or directories exist.
  
  =for Pod::Coverage method_names_here
  
  =head1 SUBTYPES
  
  This module uses L<Type::Tiny> to define the following subtypes.
  
  =head2 Path
  
  C<Path> ensures an attribute is a L<Path::Tiny> object.  Strings and
  objects with overloaded stringification may be coerced.
  
  =head2 AbsPath
  
  C<AbsPath> is a subtype of C<Path> (above), but coerces to an absolute path.
  
  =head2 File, AbsFile
  
  These are just like C<Path> and C<AbsPath>, except they check C<-f> to ensure
  the file actually exists on the filesystem.
  
  =head2 Dir, AbsDir
  
  These are just like C<Path> and C<AbsPath>, except they check C<-d> to ensure
  the directory actually exists on the filesystem.
  
  =head1 CAVEATS
  
  =head2 Path vs File vs Dir
  
  C<Path> just ensures you have a L<Path::Tiny> object.
  
  C<File> and C<Dir> check the filesystem.  Don't use them unless that's really
  what you want.
  
  =head2 Usage with File::Temp
  
  Be careful if you pass in a File::Temp object. Because the argument is
  stringified during coercion into a Path::Tiny object, no reference to the
  original File::Temp argument is held.  Be sure to hold an external reference to
  it to avoid immediate cleanup of the temporary file or directory at the end of
  the enclosing scope.
  
  A better approach is to use Path::Tiny's own C<tempfile> or C<tempdir>
  constructors, which hold the reference for you.
  
      Foo->new( filename => Path::Tiny->tempfile );
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Path::Tiny>
  
  =item *
  
  L<Moose::Manual::Types>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/types-path-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/types-path-tiny>
  
    git clone git://github.com/dagolden/types-path-tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTOR
  
  Toby Inkster <tobyink@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
TYPES_PATH_TINY

$fatpacked{"Types/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD';
  package Types::Standard;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	eval { require re };
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  	if ($] < 5.010) { require Devel::TypeTiny::Perl58Compat };
  }
  
  BEGIN {
  	$Types::Standard::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::VERSION   = '0.038';
  }
  
  use Type::Library -base;
  
  our @EXPORT_OK = qw( slurpy );
  
  use Scalar::Util qw( blessed looks_like_number );
  use Types::TypeTiny ();
  
  sub _is_class_loaded {
  	return !!0 if ref $_[0];
  	return !!0 if not $_[0];
  	my $stash = do { no strict 'refs'; \%{"$_[0]\::"} };
  	return !!1 if exists $stash->{'ISA'};
  	return !!1 if exists $stash->{'VERSION'};
  	foreach my $globref (values %$stash) {
  		return !!1 if *{$globref}{CODE};
  	}
  	return !!0;
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = __PACKAGE__->meta;
  
  sub Stringable (&)
  {
  	package #private
  	Types::Standard::_Stringable;
  	use overload q[""] => sub { $_[0]{text} ||= $_[0]{code}->() }, fallback => 1;
  	bless +{ code => $_[0] };
  }
  
  sub LazyLoad ($$)
  {
  	package #private
  	Types::Standard::LazyLoad;
  	use overload fallback => 1, q[&{}] => sub {
  		my ($typename, $function) = @{$_[0]};
  		my $type  = $meta->get_type($typename);
  		my $class = "Types::Standard::$typename";
  		eval "require $class; 1" or die($@);
  		# Majorly break encapsulation for Type::Tiny :-O
  		for my $key (keys %$type)
  		{
  			next unless ref($type->{$key}) eq __PACKAGE__;
  			my $f = $type->{$key}[1];
  			$type->{$key} = $class->can("__$f");
  		}
  		return $class->can("__$function");
  	};
  	bless \@_;
  }
  
  no warnings;
  
  BEGIN { *STRICTNUM = $ENV{PERL_TYPES_STANDARD_STRICTNUM} ? sub(){!!1} : sub(){!!0} };
  
  my $_any = $meta->add_type({
  	name       => "Any",
  	_is_core   => 1,
  	inlined    => sub { "!!1" },
  });
  
  my $_item = $meta->add_type({
  	name       => "Item",
  	_is_core   => 1,
  	inlined    => sub { "!!1" },
  	parent     => $_any,
  });
  
  $meta->add_type({
  	name       => "Bool",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { !defined $_ or $_ eq q() or $_ eq '0' or $_ eq '1' },
  	inlined    => sub { "!defined $_[1] or $_[1] eq q() or $_[1] eq '0' or $_[1] eq '1'" },
  });
  
  my $_undef = $meta->add_type({
  	name       => "Undef",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { !defined $_ },
  	inlined    => sub { "!defined($_[1])" },
  });
  
  my $_def = $meta->add_type({
  	name       => "Defined",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { defined $_ },
  	inlined    => sub { "defined($_[1])" },
  });
  
  my $_val = $meta->add_type({
  	name       => "Value",
  	_is_core   => 1,
  	parent     => $_def,
  	constraint => sub { not ref $_ },
  	inlined    => sub { "defined($_[1]) and not ref($_[1])" },
  });
  
  my $_str = $meta->add_type({
  	name       => "Str",
  	_is_core   => 1,
  	parent     => $_val,
  	constraint => sub { ref(\$_) eq 'SCALAR' or ref(\(my $val = $_)) eq 'SCALAR' },
  	inlined    => sub {
  		"defined($_[1]) and do { ref(\\$_[1]) eq 'SCALAR' or ref(\\(my \$val = $_[1])) eq 'SCALAR' }"
  	},
  });
  
  my $_laxnum = $meta->add_type({
  	name       => "LaxNum",
  	parent     => $_str,
  	constraint => sub { looks_like_number $_ },
  	inlined    => sub { "defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1])" },
  });
  
  my $_strictnum = $meta->add_type({
  	name       => "StrictNum",
  	parent     => $_str,
  	constraint => sub {
  		my $val = $_;
  		($val =~ /\A[+-]?[0-9]+\z/) ||
  		( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
  		(?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
  		[0-9]*                                #matches 0-9 zero or more times
  		(?:\.[0-9]+)?                         #matches optional .89 or nothing
  		(?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
  		\z/x );
  	},
  	inlined    => sub {
  		'my $val = '.$_[1].';'.
  		Value()->inline_check('$val')
  		.' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
  		. '$val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
  			(?=[0-9]|\.[0-9])                 # matches previous +- only if there is something like 3 or .3
  			[0-9]*                            # matches 0-9 zero or more times
  			(?:\.[0-9]+)?                     # matches optional .89 or nothing
  			(?:[Ee](?:[+-]?[0-9]+))?          # matches E1 or e1 or e-1 or e+1 etc
  		\z/x ); '
  	},
  });
  
  my $_num = $meta->add_type({
  	name       => "Num",
  	_is_core   => 1,
  	parent     => (STRICTNUM ? $_strictnum : $_laxnum),
  });
  
  $meta->add_type({
  	name       => "Int",
  	_is_core   => 1,
  	parent     => $_num,
  	constraint => sub { /\A-?[0-9]+\z/ },
  	inlined    => sub { "defined $_[1] and $_[1] =~ /\\A-?[0-9]+\\z/" },
  });
  
  my $_classn = $meta->add_type({
  	name       => "ClassName",
  	_is_core   => 1,
  	parent     => $_str,
  	constraint => sub { goto \&_is_class_loaded },
  	inlined    => sub { "Types::Standard::_is_class_loaded($_[1])" },
  });
  
  $meta->add_type({
  	name       => "RoleName",
  	parent     => $_classn,
  	constraint => sub { not $_->can("new") },
  	inlined    => sub { "Types::Standard::_is_class_loaded($_[1]) and not $_[1]\->can('new')" },
  });
  
  my $_ref = $meta->add_type({
  	name       => "Ref",
  	_is_core   => 1,
  	parent     => $_def,
  	constraint => sub { ref $_ },
  	inlined    => sub { "!!ref($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Ref') unless @_;
  		
  		my $reftype = shift;
  		Types::TypeTiny::StringLike->check($reftype)
  			or _croak("Parameter to Ref[`a] expected to be string; got $reftype");
  		
  		$reftype = "$reftype";
  		return sub {
  			ref($_[0]) and Scalar::Util::reftype($_[0]) eq $reftype;
  		}
  	},
  	inline_generator => sub
  	{
  		my $reftype = shift;
  		return sub {
  			my $v = $_[1];
  			"ref($v) and Scalar::Util::reftype($v) eq q($reftype)";
  		};
  	},
  	deep_explanation => sub {
  		require B;
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		return if $type->check($value);
  		my $reftype = Scalar::Util::reftype($value);
  		return [
  			sprintf('"%s" constrains reftype(%s) to be equal to %s', $type, $varname, B::perlstring($param)),
  			sprintf('reftype(%s) is %s', $varname, defined($reftype) ? B::perlstring($reftype) : "undef"),
  		];
  	},
  });
  
  $meta->add_type({
  	name       => "CodeRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "CODE" },
  	inlined    => sub { "ref($_[1]) eq 'CODE'" },
  });
  
  $meta->add_type({
  	name       => "RegexpRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref($_) && !!re::is_regexp($_) },
  	inlined    => sub { "ref($_[1]) && !!re::is_regexp($_[1])" },
  });
  
  $meta->add_type({
  	name       => "GlobRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "GLOB" },
  	inlined    => sub { "ref($_[1]) eq 'GLOB'" },
  });
  
  $meta->add_type({
  	name       => "FileHandle",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub {
  		(ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
  		or (blessed($_) && $_->isa("IO::Handle"))
  	},
  	inlined    => sub {
  		"(ref($_[1]) eq \"GLOB\" && Scalar::Util::openhandle($_[1])) ".
  		"or (Scalar::Util::blessed($_[1]) && $_[1]\->isa(\"IO::Handle\"))"
  	},
  });
  
  my $_arr = $meta->add_type({
  	name       => "ArrayRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "ARRAY" },
  	inlined    => sub { "ref($_[1]) eq 'ARRAY'" },
  	constraint_generator => LazyLoad(ArrayRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ArrayRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ArrayRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ArrayRef => 'coercion_generator'),
  });
  
  my $_hash = $meta->add_type({
  	name       => "HashRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "HASH" },
  	inlined    => sub { "ref($_[1]) eq 'HASH'" },
  	constraint_generator => LazyLoad(HashRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(HashRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(HashRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(HashRef => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "ScalarRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "SCALAR" or ref $_ eq "REF" },
  	inlined    => sub { "ref($_[1]) eq 'SCALAR' or ref($_[1]) eq 'REF'" },
  	constraint_generator => LazyLoad(ScalarRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ScalarRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ScalarRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ScalarRef => 'coercion_generator'),
  });
  
  my $_obj = $meta->add_type({
  	name       => "Object",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { blessed $_ },
  	inlined    => sub { "Scalar::Util::blessed($_[1])" },
  });
  
  $meta->add_type({
  	name       => "Maybe",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Maybe') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Maybe[`a] expected to be a type constraint; got $param");
  		
  		return sub
  		{
  			my $value = shift;
  			return !!1 unless defined $value;
  			return $param->check($value);
  		};
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!defined($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s is defined', Type::Tiny::_dd($value)),
  			sprintf('"%s" constrains the value with "%s" if it is defined', $type, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  my $_map = $meta->add_type({
  	name       => "Map",
  	parent     => $_hash,
  	constraint_generator => LazyLoad(Map => 'constraint_generator'),
  	inline_generator     => LazyLoad(Map => 'inline_generator'),
  	deep_explanation     => LazyLoad(Map => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Map => 'coercion_generator'),
  });
  
  my $_Optional = $meta->add_type({
  	name       => "Optional",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Optional') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Optional[`a] expected to be a type constraint; got $param");
  		
  		sub { exists($_[0]) ? $param->check($_[0]) : !!1 }
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!exists($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s exists', $varname),
  			sprintf('"%s" constrains %s with "%s" if it exists', $type, $varname, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  sub slurpy {
  	my $t = shift;
  	wantarray ? (+{ slurpy => $t }, @_) : +{ slurpy => $t };
  }
  
  $meta->add_type({
  	name       => "Tuple",
  	parent     => $_arr,
  	name_generator => sub
  	{
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], map { ref($_) eq "HASH" ? sprintf("slurpy %s", $_->{slurpy}) : $_ } @a);
  	},
  	constraint_generator => LazyLoad(Tuple => 'constraint_generator'),
  	inline_generator     => LazyLoad(Tuple => 'inline_generator'),
  	deep_explanation     => LazyLoad(Tuple => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Tuple => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "Dict",
  	parent     => $_hash,
  	name_generator => sub
  	{
  		my ($s, @p) = @_;
  		my $l = ref($p[-1]) eq q(HASH) ? pop(@p)->{slurpy} : undef;
  		my %a = @p;
  		sprintf('%s[%s%s]', $s, join(q[,], map sprintf("%s=>%s", $_, $a{$_}), sort keys %a), $l ? ",slurpy $l" : '');
  	},
  	constraint_generator => LazyLoad(Dict => 'constraint_generator'),
  	inline_generator     => LazyLoad(Dict => 'inline_generator'),
  	deep_explanation     => LazyLoad(Dict => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Dict => 'coercion_generator'),
  });
  
  use overload ();
  $meta->add_type({
  	name       => "Overload",
  	parent     => $_obj,
  	constraint => sub { overload::Overloaded($_) },
  	inlined    => sub { "Scalar::Util::blessed($_[1]) and overload::Overloaded($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Overload') unless @_;
  		
  		my @operations = map {
  			Types::TypeTiny::StringLike->check($_)
  				? "$_"
  				: _croak("Parameters to Overload[`a] expected to be a strings; got $_");
  		} @_;
  		
  		return sub {
  			my $value = shift;
  			for my $op (@operations) {
  				return unless overload::Method($value, $op);
  			}
  			return !!1;
  		}
  	},
  	inline_generator => sub {
  		my @operations = @_;
  		return sub {
  			my $v = $_[1];
  			join " and ",
  				"Scalar::Util::blessed($v)",
  				map "overload::Method($v, q[$_])", @operations;
  		};
  	},
  });
  
  our %_StrMatch;
  $meta->add_type({
  	name       => "StrMatch",
  	parent     => $_str,
  	constraint_generator => sub
  	{
  		return $meta->get_type('StrMatch') unless @_;
  		
  		my ($regexp, $checker) = @_;
  		
  		ref($regexp) eq 'Regexp'
  			or _croak("First parameter to StrMatch[`a] expected to be a Regexp; got $regexp");
  		
  		if (@_ > 1)
  		{
  			$checker = Types::TypeTiny::to_TypeTiny($checker);
  			Types::TypeTiny::TypeTiny->check($checker)
  				or _croak("Second parameter to StrMatch[`a] expected to be a type constraint; got $checker")
  		}
  		
  		$checker
  			? sub {
  				my $value = shift;
  				return if ref($value);
  				my @m = ($value =~ $regexp);
  				$checker->check(\@m);
  			}
  			: sub {
  				my $value = shift;
  				!ref($value) and $value =~ $regexp;
  			}
  		;
  	},
  	inline_generator => sub
  	{
  		require B;
  		my ($regexp, $checker) = @_;
  		my $regexp_string = "$regexp";
  		$_StrMatch{$regexp_string} = $regexp;
  		if ($checker)
  		{
  			return unless $checker->can_be_inlined;
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and do { my \$m = [$v =~ \$Types::Standard::_StrMatch{%s}]; %s }",
  					B::perlstring($regexp_string),
  					$checker->inline_check('$m'),
  				;
  			};
  		}
  		else
  		{
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and $v =~ \$Types::Standard::_StrMatch{%s}",
  					B::perlstring($regexp_string),
  				;
  			};
  		}
  	},
  });
  
  $meta->add_type({
  	name       => "OptList",
  	parent     => $_arr,
  	constraint => sub {
  		for my $inner (@$_) {
  			return unless ref($inner) eq q(ARRAY);
  			return unless @$inner == 2;
  			return unless is_Str($inner->[0]);
  		}
  		return !!1;
  	},
  	inlined     => sub {
  		my ($self, $var) = @_;
  		my $Str_check = Str()->inline_check('$inner->[0]');
  		my @code = 'do { my $ok = 1; ';
  		push @code,   sprintf('for my $inner (@{%s}) { no warnings; ', $var);
  		push @code,   sprintf('($ok=0) && last unless ref($inner) eq q(ARRAY) && @$inner == 2 && (%s); ', $Str_check);
  		push @code,   '} ';
  		push @code, '$ok }';
  		return (undef, join(q( ), @code));
  	},
  });
  
  $meta->add_type({
  	name       => "Tied",
  	parent     => $_ref,
  	constraint => sub {
  		!!tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_})
  	},
  	inlined    => sub {
  		my ($self, $var) = @_;
  		$self->parent->inline_check($var)
  		. " and !!tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var})"
  	},
  	name_generator => sub
  	{
  		my $self  = shift;
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require B;
  			return sprintf("%s[%s]", $self, B::perlstring($param));
  		}
  		return sprintf("%s[%s]", $self, $param);
  	},
  	constraint_generator => sub
  	{
  		return $meta->get_type('Tied') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		
  		my $check = $param->compiled_check;
  		return sub {
  			$check->(tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_}));
  		};
  	},
  	inline_generator => sub {
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		return unless $param->can_be_inlined;
  		
  		return sub {
  			require B;
  			my $var = $_[1];
  			sprintf(
  				"%s and do { my \$TIED = tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var}); %s }",
  				Ref()->inline_check($var),
  				$param->inline_check('$TIED')
  			);
  		};
  	},
  });
  
  $meta->add_type({
  	name       => "InstanceOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('InstanceOf') unless @_;
  		require Type::Tiny::Class;
  		my @classes = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Class"->new(class => $_, display_name => sprintf('InstanceOf[%s]', B::perlstring($_)))
  		} @_;
  		return $classes[0] if @classes == 1;
  		
  		require B;
  		require Type::Tiny::Union;
  		return "Type::Tiny::Union"->new(
  			type_constraints => \@classes,
  			display_name     => sprintf('InstanceOf[%s]', join q[,], map B::perlstring($_->class), @classes),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "ConsumerOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('ConsumerOf') unless @_;
  		require B;
  		require Type::Tiny::Role;
  		my @roles = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Role"->new(role => $_, display_name => sprintf('ConsumerOf[%s]', B::perlstring($_)))
  		} @_;
  		return $roles[0] if @roles == 1;
  		
  		require Type::Tiny::Intersection;
  		return "Type::Tiny::Intersection"->new(
  			type_constraints => \@roles,
  			display_name     => sprintf('ConsumerOf[%s]', join q[,], map B::perlstring($_->role), @roles),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "HasMethods",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('HasMethods') unless @_;
  		require B;
  		require Type::Tiny::Duck;
  		return "Type::Tiny::Duck"->new(
  			methods      => \@_,
  			display_name => sprintf('HasMethods[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "Enum",
  	parent     => $_str,
  	constraint_generator => sub {
  		return $meta->get_type('Enum') unless @_;
  		require B;
  		require Type::Tiny::Enum;
  		return "Type::Tiny::Enum"->new(
  			values       => \@_,
  			display_name => sprintf('Enum[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_coercion({
  	name               => "MkOpt",
  	type_constraint    => $meta->get_type("OptList"),
  	type_coercion_map  => [
  		$_arr,    q{ Exporter::Tiny::mkopt($_) },
  		$_hash,   q{ Exporter::Tiny::mkopt($_) },
  		$_undef,  q{ [] },
  	],
  });
  
  $meta->add_coercion({
  	name               => "Join",
  	type_constraint    => $_str,
  	coercion_generator => sub {
  		my ($self, $target, $sep) = @_;
  		Types::TypeTiny::StringLike->check($sep)
  			or _croak("Parameter to Join[`a] expected to be a string; got $sep");
  		require B;
  		$sep = B::perlstring($sep);
  		return (ArrayRef(), qq{ join($sep, \@\$_) });
  	},
  });
  
  $meta->add_coercion({
  	name               => "Split",
  	type_constraint    => $_arr,
  	coercion_generator => sub {
  		my ($self, $target, $re) = @_;
  		ref($re) eq q(Regexp)
  			or _croak("Parameter to Split[`a] expected to be a regular expresssion; got $re");
  		my $regexp_string = "$re";
  		$regexp_string =~ s/\\\//\\\\\//g; # toothpicks
  		return (Str(), qq{ [split /$regexp_string/, \$_] });
  	},
  });
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords booleans vstrings typeglobs
  
  =encoding utf-8
  
  =for stopwords datetimes
  
  =head1 NAME
  
  Types::Standard - bundled set of built-in types for Type::Tiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> bundles a few types which seem to be useful.
  
  =head2 Moose-like
  
  The following types are similar to those described in
  L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< Any >>
  
  Absolutely any value passes this type constraint (even undef).
  
  =item C<< Item >>
  
  Essentially the same as C<Any>. All other type constraints in this library
  inherit directly or indirectly from C<Item>.
  
  =item C<< Bool >>
  
  Values that are reasonable booleans. Accepts 1, 0, the empty string and
  undef.
  
  =item C<< Maybe[`a] >>
  
  Given another type constraint, also accepts undef. For example,
  C<< Maybe[Int] >> accepts all integers plus undef.
  
  =item C<< Undef >>
  
  Only undef passes this type constraint.
  
  =item C<< Defined >>
  
  Only undef fails this type constraint.
  
  =item C<< Value >>
  
  Any defined, non-reference value.
  
  =item C<< Str >>
  
  Any string.
  
  (The only difference between C<Value> and C<Str> is that the former accepts
  typeglobs and vstrings.)
  
  Other customers also bought: C<< StringLike >> from L<Types::TypeTiny>.
  
  =item C<< Num >>
  
  See C<LaxNum> and C<StrictNum> below.
  
  =item C<< Int >>
  
  An integer; that is a string of digits 0 to 9, optionally prefixed with a
  hyphen-minus character.
  
  =item C<< ClassName >>
  
  The name of a loaded package. The package must have C<< @ISA >> or
  C<< $VERSION >> defined, or must define at least one sub to be considered
  a loaded package.
  
  =item C<< RoleName >>
  
  Like C<< ClassName >>, but the package must I<not> define a method called
  C<new>. This is subtly different from Moose's type constraint of the same
  name; let me know if this causes you any problems. (I can't promise I'll
  change anything though.)
  
  =item C<< Ref[`a] >>
  
  Any defined reference value, including blessed objects.
  
  Unlike Moose, C<Ref> is a parameterized type, allowing Scalar::Util::reftype
  checks, a la
  
     Ref["HASH"]  # hashrefs, including blessed hashrefs
  
  =item C<< ScalarRef[`a] >>
  
  A value where C<< ref($value) eq "SCALAR" or ref($value) eq "REF" >>.
  
  If parameterized, the referred value must pass the additional constraint.
  For example, C<< ScalarRef[Int] >> must be a reference to a scalar which
  holds an integer value.
  
  =item C<< ArrayRef[`a] >>
  
  A value where C<< ref($value) eq "ARRAY" >>.
  
  If parameterized, the elements of the array must pass the additional
  constraint. For example, C<< ArrayRef[Num] >> must be a reference to an
  array of numbers.
  
  Other customers also bought: C<< ArrayLike >> from L<Types::TypeTiny>.
  
  =item C<< HashRef[`a] >>
  
  A value where C<< ref($value) eq "HASH" >>.
  
  If parameterized, the values of the hash must pass the additional
  constraint. For example, C<< HashRef[Num] >> must be a reference to an
  hash where the values are numbers. The hash keys are not constrained,
  but Perl limits them to strings; see C<Map> below if you need to further
  constrain the hash values.
  
  Other customers also bought: C<< HashLike >> from L<Types::TypeTiny>.
  
  =item C<< CodeRef >>
  
  A value where C<< ref($value) eq "CODE" >>.
  
  Other customers also bought: C<< CodeLike >> from L<Types::TypeTiny>.
  
  =item C<< RegexpRef >>
  
  A value where C<< ref($value) eq "Regexp" >>.
  
  =item C<< GlobRef >>
  
  A value where C<< ref($value) eq "GLOB" >>.
  
  =item C<< FileHandle >>
  
  A file handle.
  
  =item C<< Object >>
  
  A blessed object.
  
  (This also accepts regexp refs.)
  
  =back
  
  =head2 Structured
  
  OK, so I stole some ideas from L<MooseX::Types::Structured>.
  
  =over
  
  =item C<< Map[`k, `v] >>
  
  Similar to C<HashRef> but parameterized with type constraints for both the
  key and value. The constraint for keys would typically be a subtype of
  C<Str>.
  
  =item C<< Tuple[...] >>
  
  Subtype of C<ArrayRef>, accepting an list of type constraints for
  each slot in the array.
  
  C<< Tuple[Int, HashRef] >> would match C<< [1, {}] >> but not C<< [{}, 1] >>.
  
  =item C<< Dict[...] >>
  
  Subtype of C<HashRef>, accepting an list of type constraints for
  each slot in the hash.
  
  For example C<< Dict[name => Str, id => Int] >> allows
  C<< { name => "Bob", id => 42 } >>.
  
  =item C<< Optional[`a] >>
  
  Used in conjunction with C<Dict> and C<Tuple> to specify slots that are
  optional and may be omitted (but not necessarily set to an explicit undef).
  
  C<< Dict[name => Str, id => Optional[Int]] >> allows C<< { name => "Bob" } >>
  but not C<< { name => "Bob", id => "BOB" } >>.
  
  =back
  
  This module also exports a C<slurpy> function, which can be used as follows:
  
     my $type = Tuple[Str, slurpy ArrayRef[Int]];
     
     $type->( ["Hello"] );                # ok
     $type->( ["Hello", 1, 2, 3] );       # ok
     $type->( ["Hello", [1, 2, 3]] );     # not ok
  
  =begin trustme
  
  =item slurpy
  
  =end trustme
  
  =head2 Objects
  
  OK, so I stole some ideas from L<MooX::Types::MooseLike::Base>.
  
  =over
  
  =item C<< InstanceOf[`a] >>
  
  Shortcut for a union of L<Type::Tiny::Class> constraints.
  
  C<< InstanceOf["Foo", "Bar"] >> allows objects blessed into the C<Foo>
  or C<Bar> classes, or subclasses of those.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< ConsumerOf[`a] >>
  
  Shortcut for an intersection of L<Type::Tiny::Role> constraints.
  
  C<< ConsumerOf["Foo", "Bar"] >> allows objects where C<< $o->DOES("Foo") >>
  and C<< $o->DOES("Bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< HasMethods[`a] >>
  
  Shortcut for a L<Type::Tiny::Duck> constraint.
  
  C<< HasMethods["foo", "bar"] >> allows objects where C<< $o->can("foo") >>
  and C<< $o->can("bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =back
  
  =head2 More
  
  There are a few other types exported by this function:
  
  =over
  
  =item C<< Overload[`a] >>
  
  With no parameters, checks that the value is an overloaded object. Can
  be given one or more string parameters, which are specific operations
  to check are overloaded. For example, the following checks for objects
  which overload addition and subtraction.
  
     Overload["+", "-"]
  
  =item C<< Tied[`a] >>
  
  A reference to a tied scalar, array or hash.
  
  Can be parameterized with a type constraint which will be applied to
  the object returned by the C<< tied() >> function. As a convenience,
  can also be parameterized with a string, which will be inflated to a
  L<Type::Tiny::Class>.
  
     use Types::Standard qw(Tied);
     use Type::Utils qw(class_type);
     
     my $My_Package = class_type { class => "My::Package" };
     
     tie my %h, "My::Package";
     \%h ~~ Tied;                   # true
     \%h ~~ Tied[ $My_Package ];    # true
     \%h ~~ Tied["My::Package"];    # true
     
     tie my $s, "Other::Package";
     \$s ~~ Tied;                   # true
     $s  ~~ Tied;                   # false !!
  
  If you need to check that something is specifically a reference to
  a tied hash, use an intersection:
  
     use Types::Standard qw( Tied HashRef );
     
     my $TiedHash = (Tied) & (HashRef);
     
     tie my %h, "My::Package";
     tie my $s, "Other::Package";
     
     \%h ~~ $TiedHash;     # true
     \$s ~~ $TiedHash;     # false
  
  =item C<< StrMatch[`a] >>
  
  A string that matches a regular expression:
  
     declare "Distance",
        as StrMatch[ qr{^([0-9]+)\s*(mm|cm|m|km)$} ];
  
  You can optionally provide a type constraint for the array of subexpressions:
  
     declare "Distance",
        as StrMatch[
           qr{^([0-9]+)\s*(.+)$},
           Tuple[
              Int,
              enum(DistanceUnit => [qw/ mm cm m km /]),
           ],
        ];
  
  =item C<< Enum[`a] >>
  
  As per MooX::Types::MooseLike::Base:
  
     has size => (is => "ro", isa => Enum[qw( S M L XL XXL )]);
  
  =item C<< OptList >>
  
  An arrayref of arrayrefs in the style of L<Data::OptList> output.
  
  =item C<< LaxNum >>, C<< StrictNum >>
  
  In Moose 2.09, the C<Num> type constraint implementation was changed from
  being a wrapper around L<Scalar::Util>'s C<looks_like_number> function to
  a stricter regexp (which disallows things like "-Inf" and "Nan").
  
  Types::Standard provides I<both> implementations. C<LaxNum> is measurably
  faster.
  
  The C<Num> type constraint is currently an alias for C<LaxNum> unless you
  set the C<PERL_TYPES_STANDARD_STRICTNUM> environment variable to true before
  loading Types::Standard, in which case it becomes an alias for C<StrictNum>.
  The constant C<< Types::Standard::STRICTNUM >> can be used to check if
  C<Num> is being strict.
  
  Most people should probably use C<Num> or C<StrictNum>. Don't explicitly
  use C<LaxNum> unless you specifically need an attribute which will accept
  things like "Inf".
  
  =back
  
  =head2 Coercions
  
  None of the types in this type library have any coercions by default.
  However some standalone coercions may be exported. These can be combined
  with type constraints using the C<< + >> operator.
  
  =over
  
  =item C<< MkOpt >>
  
  A coercion from C<ArrayRef>, C<HashRef> or C<Undef> to C<OptList>. Example
  usage in a Moose attribute:
  
     use Types::Standard qw( OptList MkOpt );
     
     has options => (
        is     => "ro",
        isa    => OptList + MkOpt,
        coerce => 1,
     );
  
  =item C<< Split[`a] >>
  
  Split a string on a regexp.
  
     use Types::Standard qw( ArrayRef Str Split );
     
     has name => (
        is     => "ro",
        isa    => (ArrayRef[Str]) + (Split[qr/\s/]),
        coerce => 1,
     );
  
  =item C<< Join[`a] >>
  
  Join an array of strings with a delimiter.
  
     use Types::Standard qw( Str Join );
     
     my $FileLines = Str + Join["\n"];
     
     has file_contents => (
        is     => "ro",
        isa    => $FileLines,
        coerce => 1,
     );
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< Types::Standard::STRICTNUM >>
  
  Indicates whether C<Num> is an alias for C<StrictNum>. (It is usually an
  alias for C<LaxNum>.)
  
  =back
  
  =begin private
  
  =item Stringable
  
  =item LazyLoad
  
  =end private
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>,
  L<MooseX::Types::Structured>.
  
  L<Types::XSD> provides some type constraints based on XML Schema's data
  types; this includes constraints for ISO8601-formatted datetimes, integer
  ranges (e.g. C<< PositiveInteger[maxInclusive=>10] >> and so on.
  
  L<Types::Encodings> provides C<Bytes> and C<Chars> type constraints that
  were formerly found in Types::Standard.
  
  L<Types::Common::Numeric> and L<Types::Common::String> provide replacements
  for L<MooseX::Types::Common>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD

$fatpacked{"Types/Standard/ArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_ARRAYREF';
  package Types::Standard::ArrayRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ArrayRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ArrayRef::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ArrayRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ArrayRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $array = shift;
  		$param->check($_) || return for @$array;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'ARRAY' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (\@{$v}) { "
  		.    "\$ok = 0 && last unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $i (0 .. $#$value)
  	{
  		my $item = $value->[$i];
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the array with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->[%d]', $varname, $i)) },
  		]
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @new) = ($_, 0);';
  			push @code,    'for (@$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('push @new, (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my @new;
  				for my $item (@$value)
  				{
  					return $value unless $coercable_item->check($item);
  					push @new, $param->coerce($item);
  				}
  				return \@new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ArrayRef - internals for the Types::Standard ArrayRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_ARRAYREF

$fatpacked{"Types/Standard/Dict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_DICT';
  package Types::Standard::Dict;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Dict::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Dict::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_hash = Types::Standard::HashRef;
  my $_map  = Types::Standard::Map;
  my $_any  = Types::Standard::Any;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my %constraints = @_;
  	
  	while (my ($k, $v) = each %constraints)
  	{
  		$constraints{$k} = Types::TypeTiny::to_TypeTiny($v);
  		Types::TypeTiny::TypeTiny->check($v)
  			or _croak("Parameter to Dict[`a] for key '$k' expected to be a type constraint; got $v");
  	}
  	
  	return sub
  	{
  		my $value = $_[0];
  		if ($slurpy)
  		{
  			my %tmp = map {
  				exists($constraints{$_}) ? () : ($_ => $value->{$_})
  			} keys %$value;
  			return unless $slurpy->check(\%tmp);
  		}
  		else
  		{
  			exists($constraints{$_}) || return for sort keys %$value;
  		}
  		for (sort keys %constraints) {
  			my $c = $constraints{$_};
  			return unless exists($value->{$_}) || $c->is_strictly_a_type_of(Types::Standard::Optional);
  			return unless $c->check( exists $value->{$_} ? $value->{$_} : () );
  		}
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	# We can only inline a parameterized Dict if all the
  	# constraints inside can be inlined.
  	
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	return if $slurpy && !$slurpy->can_be_inlined;
  	
  	# Is slurpy a very loose type constraint?
  	# i.e. Any, Item, Defined, Ref, or HashRef
  	my $slurpy_is_any = $slurpy && $_hash->is_a_type_of( $slurpy );
  	
  	# Is slurpy a parameterized Map, or expressable as a parameterized Map?
  	my $slurpy_is_map = $slurpy
  		&& $slurpy->is_parameterized
  		&& ((
  			$slurpy->parent->strictly_equals($_map)
  			&& $slurpy->parameters
  		)||(
  			$slurpy->parent->strictly_equals($_hash)
  			&& [ $_any, $slurpy->parameters->[0] ]
  		));
  	
  	my %constraints = @_;
  	for my $c (values %constraints)
  	{
  		next if $c->can_be_inlined;
  		return;
  	}
  	
  	my $regexp = join "|", map quotemeta, sort keys %constraints;
  	return sub
  	{
  		require B;
  		my $h = $_[1];
  		join " and ",
  			"ref($h) eq 'HASH'",
  			( $slurpy_is_any ? '1'
  			: $slurpy_is_map ? do {
  				'(not grep {'
  				."my \$v = ($h)->{\$_};"
  				.sprintf(
  					'not((%s) and (%s))',
  					$slurpy_is_map->[0]->inline_check('$_'),
  					$slurpy_is_map->[1]->inline_check('$v'),
  				) ."} keys \%{$h})"
  			}
  			: $slurpy ? do {
  				'do {'
  				. "my \$slurpy_tmp = +{ map /\\A(?:$regexp)\\z/ ? () : (\$_ => ($h)->{\$_}), keys \%{$h} };"
  				. $slurpy->inline_check('$slurpy_tmp')
  				. '}'
  			}
  			: "not(grep !/\\A(?:$regexp)\\z/, keys \%{$h})" ),
  			( map {
  				my $k = B::perlstring($_);
  				$constraints{$_}->is_strictly_a_type_of( Types::Standard::Optional )
  					? $constraints{$_}->inline_check("$h\->{$k}")
  					: ( "exists($h\->{$k})", $constraints{$_}->inline_check("$h\->{$k}") )
  			} sort keys %constraints ),
  	}
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my @params = @{ $type->parameters };
  	
  	my $slurpy = ref($params[-1]) eq q(HASH) ? pop(@params)->{slurpy} : undef;
  	my %constraints = @params;
  			
  	for my $k (sort keys %constraints)
  	{
  		next if $constraints{$k}->parent == Types::Standard::Optional && !exists $value->{$k};
  		next if $constraints{$k}->check($value->{$k});
  		
  		return [
  			sprintf('"%s" requires key %s to appear in hash', $type, B::perlstring($k))
  		] unless exists $value->{$k};
  		
  		return [
  			sprintf('"%s" constrains value at key %s of hash with "%s"', $type, B::perlstring($k), $constraints{$k}),
  			@{ $constraints{$k}->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	if ($slurpy)
  	{
  		my %tmp = map {
  			exists($constraints{$_}) ? () : ($_ => $value->{$_})
  		} keys %$value;
  		
  		my $explain = $slurpy->validate_explain(\%tmp, '$slurpy');
  		return [
  			sprintf('"%s" requires the hashref of additional key/value pairs to conform to "%s"', $type, $slurpy),
  			@$explain,
  		] if $explain;
  	}
  	else
  	{
  		for my $k (sort keys %$value)
  		{
  			return [
  				sprintf('"%s" does not allow key %s to appear in hash', $type, B::perlstring($k))
  			] unless exists $constraints{$k};
  		}
  	}
  	
  	return;
  }
  
  my $label_counter = 0;
  our ($keycheck_counter, @KEYCHECK) = -1;
  sub __coercion_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my ($parent, $child, %dict) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $all_inlinable = 1;
  	for my $tc (values %dict)
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	$all_inlinable = 0 if $slurpy && !$slurpy->can_be_inlined;
  	$all_inlinable = 0 if $slurpy && $slurpy->has_coercion && !$slurpy->coercion->can_be_inlined;
  	
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			require B;
  			
  			my $keycheck = join "|", map quotemeta, sort { length($b) <=> length($a) or $a cmp $b } keys %dict;
  			$keycheck = $KEYCHECK[++$keycheck_counter] = qr{^($keycheck)$}ms; # regexp for legal keys
  			
  			my $label = sprintf("DICTLABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %tmp, %new) = ($_, 0);';
  			push @code,       "$label: {";
  			if ($slurpy)
  			{
  				push @code, sprintf('my $slurped = +{ map +($_=~$%s::KEYCHECK[%d])?():($_=>$orig->{$_}), keys %%$orig };', __PACKAGE__, $keycheck_counter);
  				if ($slurpy->has_coercion)
  				{
  					push @code, sprintf('my $coerced = %s;', $slurpy->coercion->inline_coercion('$slurped'));
  					push @code, sprintf('((%s)&&(%s))?(%%new=%%$coerced):(($return_orig = 1), last %s);', $_hash->inline_check('$coerced'), $slurpy->inline_check('$coerced'), $label);
  				}
  				else
  				{
  					push @code, sprintf('(%s)?(%%new=%%$slurped):(($return_orig = 1), last %s);', $slurpy->inline_check('$slurped'), $label);
  				}
  			}
  			else
  			{
  				push @code, sprintf('($_ =~ $%s::KEYCHECK[%d])||(($return_orig = 1), last %s) for sort keys %%$orig;', __PACKAGE__, $keycheck_counter, $label);
  			}
  			for my $k (keys %dict)
  			{
  				my $ct = $dict{$k};
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);
  				my $K = B::perlstring($k);
  				
  				push @code, "if (exists \$orig->{$K}) {" if $ct_optional;
  				if ($ct_coerce)
  				{
  					push @code, sprintf('%%tmp = (); $tmp{x} = %s;', $ct->coercion->inline_coercion("\$orig->{$K}"));
  					push @code, sprintf(
  #						$ct_optional
  #							? 'if (%s) { $new{%s}=$tmp{x} }'
  #							:
  						'if (%s) { $new{%s}=$tmp{x} } else { $return_orig = 1; last %s }',
  						$ct->inline_check('$tmp{x}'),
  						$K,
  						$label,
  					);
  				}
  				else
  				{
  					push @code, sprintf(
  #						$ct_optional
  #							? 'if (%s) { $new{%s}=$orig->{%s} }'
  #							:
  						'if (%s) { $new{%s}=$orig->{%s} } else { $return_orig = 1; last %s }',
  						$ct->inline_check("\$orig->{$K}"),
  						$K,
  						$K,
  						$label,
  					);
  				}
  				push @code, '}' if $ct_optional;
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			#warn "CODE:: @code";
  			"@code";
  		});
  	}
  	
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				
  				if ($slurpy)
  				{
  					my %slurped = map exists($dict{$_}) ? () : ($_ => $value->{$_}), keys %$value;
  					
  					if ($slurpy->check(\%slurped))
  					{
  						%new = %slurped;
  					}
  					elsif ($slurpy->has_coercion)
  					{
  						my $coerced = $slurpy->coerce(\%slurped);
  						$slurpy->check($coerced) ? (%new = %$coerced) : (return $value);
  					}
  					else
  					{
  						return $value;
  					}
  				}
  				else
  				{
  					for my $k (keys %$value)
  					{
  						return $value unless exists $dict{$k};
  					}
  				}
  
  				for my $k (keys %dict)
  				{
  					my $ct = $dict{$k};
  					my @accept;
  					
  					if (exists $value->{$k} and $ct->check($value->{$k}))
  					{
  						@accept = $value->{$k};
  					}
  					elsif (exists $value->{$k} and $ct->has_coercion)
  					{
  						my $x = $ct->coerce($value->{$k});
  						@accept = $x if $ct->check($x);
  					}
  					elsif (exists $value->{$k})
  					{
  						return $value;
  					}
  					
  					if (@accept)
  					{
  						$new{$k} = $accept[0];
  					}
  					elsif (not $ct->is_a_type_of(Types::Standard::Optional))
  					{
  						return $value;
  					}
  				}
  				
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Dict - internals for the Types::Standard Dict type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_DICT

$fatpacked{"Types/Standard/HashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_HASHREF';
  package Types::Standard::HashRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::HashRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::HashRef::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::HashRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to HashRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $hash = shift;
  		$param->check($_) || return for values %$hash;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (values \%{$v}) { "
  		.    "\$ok = 0 && last unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $k (sort keys %$value)
  	{
  		my $item = $value->{$k};
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the hash with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{$_} = (%s);', $param->coercion->inline_coercion('$orig->{$_}'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $coercable_item->check($value->{$k});
  					$new{$k} = $param->coerce($value->{$k});
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::HashRef - internals for the Types::Standard HashRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_HASHREF

$fatpacked{"Types/Standard/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_MAP';
  package Types::Standard::Map;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Map::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Map::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = Types::Standard->meta;
  
  no warnings;
  
  sub __constraint_generator
  {
  	return $meta->get_type('Map') unless @_;
  	
  	my ($keys, $values) = map Types::TypeTiny::to_TypeTiny($_), @_;
  	Types::TypeTiny::TypeTiny->check($keys)
  		or _croak("First parameter to Map[`k,`v] expected to be a type constraint; got $keys");
  	Types::TypeTiny::TypeTiny->check($values)
  		or _croak("Second parameter to Map[`k,`v] expected to be a type constraint; got $values");
  	
  	return sub
  	{
  		my $hash = shift;
  		$keys->check($_)   || return for keys %$hash;
  		$values->check($_) || return for values %$hash;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my ($k, $v) = @_;
  	return unless $k->can_be_inlined && $v->can_be_inlined;
  	my $k_check = $k->inline_check('$k');
  	my $v_check = $v->inline_check('$v');
  	return sub {
  		my $h = $_[1];
  		"ref($h) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$v (values \%{$h}) { "
  		.    "\$ok = 0 && last unless $v_check "
  		.  "}; "
  		.  "for my \$k (keys \%{$h}) { "
  		.    "\$ok = 0 && last unless $k_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my ($kparam, $vparam) = @{ $type->parameters };
  	
  	for my $k (sort keys %$value)
  	{
  		unless ($kparam->check($k))
  		{
  			return [
  				sprintf('"%s" constrains each key in the hash with "%s"', $type, $kparam),
  				@{ $kparam->validate_explain($k, sprintf('key %s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  		
  		unless ($vparam->check($value->{$k}))
  		{
  			return [
  				sprintf('"%s" constrains each value in the hash with "%s"', $type, $vparam),
  				@{ $vparam->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $kparam, $vparam) = @_;
  	return unless $kparam->has_coercion || $vparam->has_coercion;
  	
  	my $kcoercable_item = $kparam->has_coercion ? $kparam->coercion->_source_type_union : $kparam;
  	my $vcoercable_item = $vparam->has_coercion ? $vparam->coercion->_source_type_union : $vparam;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ((!$kparam->has_coercion or $kparam->coercion->can_be_inlined)
  	and (!$vparam->has_coercion or $vparam->coercion->can_be_inlined)
  	and $kcoercable_item->can_be_inlined
  	and $vcoercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $kcoercable_item->inline_check('$_'));
  			push @code, sprintf('$return_orig++ && last unless (%s);', $vcoercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{(%s)} = (%s);',
  				$kparam->has_coercion ? $kparam->coercion->inline_coercion('$_') : '$_',
  				$vparam->has_coercion ? $vparam->coercion->inline_coercion('$orig->{$_}') : '$orig->{$_}',
  			);
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $kcoercable_item->check($k) && $vcoercable_item->check($value->{$k});
  					$new{$kparam->has_coercion ? $kparam->coerce($k) : $k} =
  						$vparam->has_coercion ? $vparam->coerce($value->{$k}) : $value->{$k};
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Map - internals for the Types::Standard Map type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_MAP

$fatpacked{"Types/Standard/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_SCALARREF';
  package Types::Standard::ScalarRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ScalarRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ScalarRef::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ScalarRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ScalarRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $ref = shift;
  		$param->check($$ref) || return;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	return sub {
  		my $v = $_[1];
  		my $param_check = $param->inline_check("\${$v}");
  		"(ref($v) eq 'SCALAR' or ref($v) eq 'REF') and $param_check";
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $item ($$value)
  	{
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains the referenced scalar value with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('${%s}', $varname)) },
  		];
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $new) = ($_, 0);';
  			push @code,    'for ($$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('$new = (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\$new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my $new;
  				for my $item ($$value)
  				{
  					return $value unless $coercable_item->check($item);
  					$new = $param->coerce($item);
  				}
  				return \$new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ScalarRef - internals for the Types::Standard ScalarRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_SCALARREF

$fatpacked{"Types/Standard/Tuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_TUPLE';
  package Types::Standard::Tuple;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Tuple::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Tuple::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_Optional = Types::Standard::Optional;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  		Types::TypeTiny::TypeTiny->check($slurpy)
  			or _croak("Slurpy parameter to Tuple[...] expected to be a type constraint; got $slurpy");
  	}
  	
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	for (@constraints)
  	{
  		Types::TypeTiny::TypeTiny->check($_)
  			or _croak("Parameters to Tuple[...] expected to be type constraints; got $_");
  	}
  		
  	return sub
  	{
  		my $value = $_[0];
  		if ($#constraints < $#$value)
  		{
  			defined($slurpy) && $slurpy->check(
  				$slurpy->is_a_type_of(Types::Standard::HashRef)
  					? +{@$value[$#constraints+1 .. $#$value]}
  					: +[@$value[$#constraints+1 .. $#$value]]
  			) or return;
  		}
  		for my $i (0 .. $#constraints)
  		{
  			$i <= $#$value or $constraints[$i]->is_strictly_a_type_of($_Optional) or return;
  			$constraints[$i]->check(exists $value->[$i] ? $value->[$i] : ()) or return;
  		}
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = pop(@constraints)->{slurpy};
  	}
  	
  	return if grep { not $_->can_be_inlined } @constraints;
  	return if defined $slurpy && !$slurpy->can_be_inlined;
  	
  	my $tmpl = defined($slurpy) && $slurpy->is_a_type_of(Types::Standard::HashRef)
  		? "do { my \$tmp = +{\@{%s}[%d..\$#{%s}]}; %s }"
  		: "do { my \$tmp = +[\@{%s}[%d..\$#{%s}]]; %s }";
  	
  	my $min = 0 + grep !$_->is_strictly_a_type_of($_Optional), @constraints;
  	
  	return sub
  	{
  		my $v = $_[1];
  		join " and ",
  			"ref($v) eq 'ARRAY'",
  			"scalar(\@{$v}) >= $min",
  			($slurpy
  				? sprintf($tmpl, $v, $#constraints+1, $v, $slurpy->inline_check('$tmp'))
  				: sprintf("\@{$v} <= %d", scalar @constraints)
  			),
  			map { $constraints[$_]->inline_check("$v\->[$_]") } 0 .. $#constraints;
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	
  	my @constraints = @{ $type->parameters };
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  	}
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	
  	if ($#constraints < $#$value and not $slurpy)
  	{
  		return [
  			sprintf('"%s" expects at most %d values in the array', $type, $#constraints),
  			sprintf('%d values found; too many', $#$value),
  		];
  	}
  	
  	for my $i (0 .. $#constraints)
  	{
  		next if $constraints[$i]->is_strictly_a_type_of( Types::Standard::Optional ) && $i > $#$value;
  		next if $constraints[$i]->check($value->[$i]);
  		
  		return [
  			sprintf('"%s" constrains value at index %d of array with "%s"', $type, $i, $constraints[$i]),
  			@{ $constraints[$i]->validate_explain($value->[$i], sprintf('%s->[%s]', $varname, $i)) },
  		];
  	}
  	
  	if (defined($slurpy))
  	{
  		my $tmp = $slurpy->is_a_type_of(Types::Standard::HashRef)
  			? +{@$value[$#constraints+1 .. $#$value]}
  			: +[@$value[$#constraints+1 .. $#$value]];
  		$slurpy->check($tmp) or return [
  			sprintf(
  				'Array elements from index %d are slurped into a %s which is constrained with "%s"',
  				$#constraints+1,
  				$slurpy->is_a_type_of(Types::Standard::HashRef) ? 'hashref' : 'arrayref',
  				$slurpy,
  			),
  			@{ $slurpy->validate_explain($tmp, '$SLURPY') },
  		];
  	}
  	
  	return;
  }
  
  my $label_counter = 0;
  sub __coercion_generator
  {
  	my ($parent, $child, @tuple) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $slurpy;
  	if (exists $tuple[-1] and ref $tuple[-1] eq "HASH")
  	{
  		$slurpy = pop(@tuple)->{slurpy};
  	}
  	
  	my $all_inlinable = 1;
  	for my $tc (@tuple, ($slurpy ? $slurpy : ()))
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my $label = sprintf("TUPLELABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @tmp, @new) = ($_, 0);';
  			push @code,       "$label: {";
  			push @code,       sprintf('(($return_orig = 1), last %s) if @$orig > %d;', $label, scalar @tuple) unless $slurpy;
  			for my $i (0 .. $#tuple)
  			{
  				my $ct = $tuple[$i];
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);
  				
  				if ($ct_coerce)
  				{
  					push @code, sprintf('@tmp = (); $tmp[0] = %s;', $ct->coercion->inline_coercion("\$orig->[$i]"));
  					push @code, sprintf(
  						$ct_optional
  							? 'if (%s) { $new[%d]=$tmp[0] }'
  							: 'if (%s) { $new[%d]=$tmp[0] } else { $return_orig = 1; last %s }',
  						$ct->inline_check('$tmp[0]'),
  						$i,
  						$label,
  					);
  				}
  				else
  				{
  					push @code, sprintf(
  						$ct_optional
  							? 'if (%s) { $new[%d]=$orig->[%s] }'
  							: 'if (%s) { $new[%d]=$orig->[%s] } else { $return_orig = 1; last %s }',
  						$ct->inline_check("\$orig->[$i]"),
  						$i,
  						$i,
  						$label,
  					);
  				}
  			}
  			if ($slurpy)
  			{
  				my $size = @tuple;
  				push @code, sprintf('if (@$orig > %d) {', $size);
  				push @code, sprintf('my $tail = [ @{$orig}[%d .. $#$orig] ];', $size);
  				push @code, $slurpy->has_coercion
  					? sprintf('$tail = %s;', $slurpy->coercion->inline_coercion('$tail'))
  					: q();
  				push @code, sprintf(
  					'(%s) ? push(@new, @$tail) : ($return_orig++);',
  					$slurpy->inline_check('$tail'),
  				);
  				push @code, '}';
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				
  				if (!$slurpy and @$value > @tuple)
  				{
  					return $value;
  				}
  				
  				my @new;
  				for my $i (0 .. $#tuple)
  				{
  					my $ct = $tuple[$i];
  					my @accept;
  					
  					if (exists $value->[$i] and $ct->check($value->[$i]))
  					{
  						@accept = $value->[$i];
  					}
  					elsif (exists $value->[$i] and $ct->has_coercion)
  					{
  						my $x = $ct->coerce($value->[$i]);
  						@accept = $x if $ct->check($x);
  					}
  					else
  					{
  						return $value;
  					}
  					
  					if (@accept)
  					{
  						$new[$i] = $accept[0];
  					}
  					elsif (not $ct->is_a_type_of(Types::Standard::Optional))
  					{
  						return $value;
  					}
  				}
  				
  				if ($slurpy and @$value > @tuple)
  				{
  					my $tmp = $slurpy->has_coercion
  						? $slurpy->coerce([ @{$value}[@tuple .. $#$value] ])
  						: [ @{$value}[@tuple .. $#$value] ];
  					$slurpy->check($tmp) ? push(@new, @$tmp) : return($value);
  				}
  				
  				return \@new;
  			},
  		);
  	};
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Tuple - internals for the Types::Standard Tuple type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_TUPLE

$fatpacked{"Types/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_TYPETINY';
  package Types::TypeTiny;
  
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  
  use Scalar::Util qw< blessed refaddr weaken >;
  
  our @EXPORT_OK = ( __PACKAGE__->type_names, qw/to_TypeTiny/ );
  
  my %cache;
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  sub meta
  {
  	return $_[0];
  }
  
  sub has_type
  {
  	defined(shift->get_coercion(@_))
  }
  
  sub get_type
  {
  	my $self = shift;
  	my $func = $self->can(@_) or return;
  	my $type = $func->();
  	return $type if blessed($type) && $type->isa("Type::Tiny");
  	return;
  }
  
  sub type_names
  {
  	qw( CodeLike StringLike TypeTiny HashLike ArrayLike );
  }
  
  sub has_coercion
  {
  	defined(shift->get_coercion(@_))
  }
  
  sub get_coercion
  {
  	();
  }
  
  sub coercion_names
  {
  	();
  }
  
  sub StringLike ()
  {
  	require Type::Tiny;
  	$cache{StringLike} ||= "Type::Tiny"->new(
  		name       => "StringLike",
  		constraint => sub {    !ref($_   ) or Scalar::Util::blessed($_   ) && overload::Method($_   , q[""])  },
  		inlined    => sub { qq/!ref($_[1]) or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[""])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub HashLike ()
  {
  	require Type::Tiny;
  	$cache{HashLike} ||= "Type::Tiny"->new(
  		name       => "HashLike",
  		constraint => sub {    ref($_   ) eq q[HASH] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[%{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[HASH] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\%{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub ArrayLike ()
  {
  	require Type::Tiny;
  	$cache{ArrayLike} ||= "Type::Tiny"->new(
  		name       => "ArrayLike",
  		constraint => sub {    ref($_   ) eq q[ARRAY] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[@{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[ARRAY] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\@{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub CodeLike ()
  {
  	require Type::Tiny;
  	$cache{CodeLike} ||= "Type::Tiny"->new(
  		name       => "CodeLike",
  		constraint => sub {    ref($_   ) eq q[CODE] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[&{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[CODE] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\&{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub TypeTiny ()
  {
  	require Type::Tiny;
  	$cache{TypeTiny} ||= "Type::Tiny"->new(
  		name       => "TypeTiny",
  		constraint => sub {  Scalar::Util::blessed($_   ) && $_   ->isa(q[Type::Tiny])  },
  		inlined    => sub { my $var = $_[1]; "Scalar::Util::blessed($var) && $var\->isa(q[Type::Tiny])" },
  		library    => __PACKAGE__,
  	);
  }
  
  my %ttt_cache;
  
  sub to_TypeTiny
  {
  	my $t = $_[0];
  	
  	return $t unless ref $t;
  	return $t if ref($t) =~ /^Type::Tiny\b/;
  	
  	return $ttt_cache{ refaddr($t) } if $ttt_cache{ refaddr($t) };
  	
  	if (my $class = blessed $t)
  	{
  		return $t                           if $class->isa("Type::Tiny");
  		goto \&_TypeTinyFromMoose           if $class->isa("Moose::Meta::TypeConstraint");
  		goto \&_TypeTinyFromMoose           if $class->isa("MooseX::Types::TypeDecorator");
  		goto \&_TypeTinyFromValidationClass if $class->isa("Validation::Class::Simple");
  		goto \&_TypeTinyFromValidationClass if $class->isa("Validation::Class");
  		goto \&_TypeTinyFromGeneric         if $t->can("check") && $t->can("get_message"); # i.e. Type::API::Constraint
  	}
  	
  	goto \&_TypeTinyFromCodeRef if ref($t) eq q(CODE);
  	
  	$t;
  }
  
  sub _TypeTinyFromMoose
  {
  	my $t = $_[0];
  	
  	if (ref $t->{"Types::TypeTiny::to_TypeTiny"})
  	{
  		return $t->{"Types::TypeTiny::to_TypeTiny"};
  	}
  	
  	if ($t->name ne '__ANON__')
  	{
  		require Types::Standard;
  		my $ts = 'Types::Standard'->get_type($t->name);
  		return $ts if $ts->{_is_core};
  	}
  	
  	my %opts;
  	$opts{display_name} = $t->name;
  	$opts{constraint}   = $t->constraint;
  	$opts{parent}       = to_TypeTiny($t->parent)              if $t->has_parent;
  	$opts{inlined}      = sub { shift; $t->_inline_check(@_) } if $t->can_be_inlined;
  	$opts{message}      = sub { $t->get_message($_) }          if $t->has_message;
  	$opts{moose_type}   = $t;
  	
  	require Type::Tiny;
  	my $new = 'Type::Tiny'->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	
  	$new->{coercion} = do {
  		require Type::Coercion::FromMoose;
  		'Type::Coercion::FromMoose'->new(type_constraint => $new);
  	} if $t->has_coercion;
  	
  	return $new;
  }
  
  sub _TypeTinyFromValidationClass
  {
  	my $t = $_[0];
  	
  	require Type::Tiny;
  	require Types::Standard;
  	
  	my %opts = (
  		parent            => Types::Standard::HashRef(),
  		_validation_class => $t,
  	);
  	
  	if ($t->VERSION >= "7.900048")
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = eval { $t->validate };
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = (eval { $t->validate } ? "OK" : $t->errors_to_string);
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  	}
  	else  # need to use hackish method
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate };
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate } ? "OK" : $t->errors_to_string;
  		};
  	}
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	
  	$new->coercion->add_type_coercions(
  		Types::Standard::HashRef() => sub {
  			my %params = %$_;
  			for my $k (keys %params)
  				{ delete $params{$_} unless $t->get_fields($k) };
  			$t->params->clear;
  			$t->params->add(%params);
  			eval { $t->validate };
  			$t->get_hash;
  		},
  	);
  	
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  sub _TypeTinyFromGeneric
  {
  	my $t = $_[0];
  	
  	# XXX - handle inlining??
  	
  	my %opts = (
  		constraint => sub { $t->check(@_ ? @_ : $_) },
  		message    => sub { $t->get_message(@_ ? @_ : $_) },
  	);
  	
  	$opts{display_name} = $t->name if $t->can("name");
  	
  	$opts{coercion} = sub { $t->coerce(@_ ? @_ : $_) }
  		if $t->can("has_coercion") && $t->has_coercion && $t->can("coerce");
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  sub _TypeTinyFromCodeRef
  {
  	my $t = $_[0];
  	
  	my %opts = (
  		constraint => sub {
  			return !!eval { $t->($_) };
  		},
  		message => sub {
  			local $@;
  			eval { $t->($_); 1 } or do { chomp $@; return $@ if $@ };
  			return sprintf('%s did not pass type constraint', Type::Tiny::_dd($_));
  		},
  	);
  
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords arrayfication hashification
  
  =head1 NAME
  
  Types::TypeTiny - type constraints used internally by Type::Tiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Dogfooding.
  
  This isn't a real Type::Library-based type library; that would involve
  too much circularity. But it exports some type constraints which, while
  designed for use within Type::Tiny, may be more generally useful.
  
  =head2 Types
  
  =over
  
  =item C<< StringLike >>
  
  Accepts strings and objects overloading stringification.
  
  =item C<< HashLike >>
  
  Accepts hashrefs and objects overloading hashification.
  
  =item C<< ArrayLike >>
  
  Accepts arrayrefs and objects overloading arrayfication.
  
  =item C<< CodeLike >>
  
  Accepts coderefs and objects overloading codification.
  
  =item C<< TypeTiny >>
  
  Accepts blessed L<Type::Tiny> objects.
  
  =back
  
  =head2 Coercion Functions
  
  =over
  
  =item C<< to_TypeTiny($constraint) >>
  
  Promotes (or "demotes" if you prefer) a Moose::Meta::TypeConstraint object
  to a Type::Tiny object.
  
  Can also handle L<Validation::Class> objects. Type constraints built from 
  Validation::Class objects deliberately I<ignore> field filters when they
  do constraint checking (and go to great lengths to do so); using filters for
  coercion only. (The behaviour of C<coerce> if we don't do that is just too
  weird!)
  
  Can also handle any object providing C<check> and C<get_message> methods.
  (This includes L<Mouse::Meta::TypeConstraint> objects.) If the object also
  provides C<has_coercion> and C<coerce> methods, these will be used too.
  
  Can also handle coderefs (but not blessed coderefs or objects overloading
  C<< &{} >>). Coderefs are expected to return true iff C<< $_ >> passes the
  constraint. If C<< $_ >> fails the type constraint, they may either return
  false, or die with a helpful error message.
  
  =back
  
  =head2 Methods
  
  These are implemented so that C<< Types::TypeTiny->meta->get_type($foo) >>
  works, for rough compatibility with a real L<Type::Library> type library.
  
  =over
  
  =item C<< meta >>
  
  =item C<< type_names >>
  
  =item C<< get_type($name) >>
  
  =item C<< has_type($name) >>
  
  =item C<< coercion_names >>
  
  =item C<< get_coercion($name) >>
  
  =item C<< has_coercion($name) >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_TYPETINY

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  use 5.008001;
  package YAML;
  $YAML::VERSION = '0.90';
  use YAML::Mo;
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML - YAML Ain't Markup Language (tm)
  
  =head1 NOTE
  
  This module has been released to CPAN as YAML::Old, and soon YAML.pm
  will be changed to just be a frontend interface module for all the
  various Perl YAML implementation modules, including YAML::Old.
  
  If you want robust and fast YAML processing using the normal Dump/Load
  API, please consider switching to YAML::XS. It is by far the best Perl
  module for YAML at this time. It requires that you have a C compiler,
  since it is written in C.
  
  If you really need to use this version of YAML.pm it will always be
  available as YAML::Old.
  
  If you don't care which YAML module use, as long as it's the best one
  installed on your system, use YAML::Any.
  
  The rest of this documentation is left unchanged, until YAML.pm is
  switched over to the new UI-only version.
  
  =head1 SYNOPSIS
  
      use YAML;
  
      # Load a YAML stream of 3 YAML documents into Perl data structures.
      my ($hashref, $arrayref, $string) = Load(<<'...');
      ---
      name: ingy
      age: old
      weight: heavy
      # I should comment that I also like pink, but don't tell anybody.
      favorite colors:
          - red
          - green
          - blue
      ---
      - Clark Evans
      - Oren Ben-Kiki
      - Ingy dt Net
      --- >
      You probably think YAML stands for "Yet Another Markup Language". It
      ain't! YAML is really a data serialization language. But if you want
      to think of it as a markup, that's OK with me. A lot of people try
      to use XML as a serialization format.
  
      "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
      ...
  
      # Dump the Perl data structures back into YAML.
      print Dump($string, $arrayref, $hashref);
  
      # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
      use Data::Dumper;
      print Dumper($string, $arrayref, $hashref);
  
  =head1 DESCRIPTION
  
  The YAML.pm module implements a YAML Loader and Dumper based on the YAML
  1.0 specification. L<http://www.yaml.org/spec/>
  
  YAML is a generic data serialization language that is optimized for
  human readability. It can be used to express the data structures of most
  modern programming languages. (Including Perl!!!)
  
  For information on the YAML syntax, please refer to the YAML
  specification.
  
  =head1 WHY YAML IS COOL
  
  =over 4
  
  =item YAML is readable for people.
  
  It makes clear sense out of complex data structures. You should find
  that YAML is an exceptional data dumping tool. Structure is shown
  through indentation, YAML supports recursive data, and hash keys are
  sorted by default. In addition, YAML supports several styles of scalar
  formatting for different types of data.
  
  =item YAML is editable.
  
  YAML was designed from the ground up to be an excellent syntax for
  configuration files. Almost all programs need configuration files, so
  why invent a new syntax for each one? And why subject users to the
  complexities of XML or native Perl code?
  
  =item YAML is multilingual.
  
  Yes, YAML supports Unicode. But I'm actually referring to programming
  languages. YAML was designed to meet the serialization needs of Perl,
  Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
  interoperable between those languages. That means YAML serializations
  produced by Perl can be processed by Python.
  
  =item YAML is taint safe.
  
  Using modules like Data::Dumper for serialization is fine as long as you
  can be sure that nobody can tamper with your data files or
  transmissions. That's because you need to use Perl's C<eval()> built-in
  to deserialize the data. Somebody could add a snippet of Perl to erase
  your files.
  
  YAML's parser does not need to eval anything.
  
  =item YAML is full featured.
  
  YAML can accurately serialize all of the common Perl data structures and
  deserialize them again without losing data relationships. Although it is
  not 100% perfect (no serializer is or can be perfect), it fares as well
  as the popular current modules: Data::Dumper, Storable, XML::Dumper and
  Data::Denter.
  
  YAML.pm also has the ability to handle code (subroutine) references and
  typeglobs. (Still experimental) These features are not found in Perl's
  other serialization modules.
  
  =item YAML is extensible.
  
  The YAML language has been designed to be flexible enough to solve it's
  own problems. The markup itself has 3 basic construct which resemble
  Perl's hash, array and scalar. By default, these map to their Perl
  equivalents. But each YAML node also supports a tagging mechanism (type
  system) which can cause that node to be interpreted in a completely
  different manner. That's how YAML can support object serialization and
  oddball structures like Perl's typeglob.
  
  =back
  
  =head1 YAML IMPLEMENTATIONS IN PERL
  
  This module, YAML.pm, is really just the interface module for YAML
  modules written in Perl. The basic interface for YAML consists of two
  functions: C<Dump> and C<Load>. The real work is done by the modules
  YAML::Dumper and YAML::Loader.
  
  Different YAML module distributions can be created by subclassing
  YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple
  consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
  
  Why would there be more than one implementation of YAML? Well, despite
  YAML's offering of being a simple data format, YAML is actually very
  deep and complex. Implementing the entirety of the YAML specification is
  a daunting task.
  
  For this reason I am currently working on 3 different YAML implementations.
  
  =over
  
  =item YAML
  
  The main YAML distribution will keeping evolving to support the entire
  YAML specification in pure Perl. This may not be the fastest or most
  stable module though. Currently, YAML.pm has lots of known bugs. It is
  mostly a great tool for dumping Perl data structures to a readable form.
  
  =item YAML::Tiny
  
  The point of YAML::Tiny is to strip YAML down to the 90% that people
  use most and offer that in a small, fast, stable, pure Perl form.
  YAML::Tiny will simply die when it is asked to do something it can't.
  
  =item YAML::Syck
  
  C<libsyck> is the C based YAML processing library used by the Ruby
  programming language (and also Python, PHP and Pugs). YAML::Syck is the
  Perl binding to C<libsyck>. It should be very fast, but may have
  problems of its own. It will also require C compilation.
  
  NOTE: Audrey Tang has actually completed this module and it works great
        and is 10 times faster than YAML.pm.
  
  =back
  
  In the future, there will likely be even more YAML modules. Remember,
  people other than Ingy are allowed to write YAML modules!
  
  =head1 FUNCTIONAL USAGE
  
  YAML is completely OO under the hood. Still it exports a few useful top
  level functions so that it is dead simple to use. These functions just
  do the OO stuff for you. If you want direct access to the OO API see the
  documentation for YAML::Dumper and YAML::Loader.
  
  =head2 Exported Functions
  
  The following functions are exported by YAML.pm by default. The reason
  they are exported is so that YAML works much like Data::Dumper. If you
  don't want functions to be imported, just use YAML with an empty
  import list:
  
      use YAML ();
  
  =over 4
  
  =item Dump(list-of-Perl-data-structures)
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper(). It takes a list of Perl data structures and
  dumps them into a serialized form. It returns a string containing the
  YAML stream. The structures can be references or plain scalars.
  
  =item Load(string-containing-a-YAML-stream)
  
  Turn YAML into Perl data. This is the opposite of Dump. Just like
  Storable's thaw() function or the eval() function in relation to
  Data::Dumper. It parses a string containing a valid YAML stream into a
  list of Perl data structures.
  
  =back
  
  =head2 Exportable Functions
  
  These functions are not exported by default but you can request them in
  an import list like this:
  
      use YAML qw'freeze thaw Bless';
  
  =over 4
  
  =item freeze() and thaw()
  
  Aliases to Dump() and Load() for Storable fans. This will also allow
  YAML.pm to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =item DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =item LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =item Bless(perl-node, [yaml-node | class-name])
  
  Associate a normal Perl node, with a yaml node. A yaml node is an object
  tied to the YAML::Node class. The second argument is either a yaml node
  that you've already created or a class (package) name that supports a
  yaml_dump() function. A yaml_dump() function should take a perl node and
  return a yaml node. If no second argument is provided, Bless will create
  a yaml node. This node is not returned, but can be retrieved with the
  Blessed() function.
  
  Here's an example of how to use Bless. Say you have a hash containing
  three keys, but you only want to dump two of them. Furthermore the keys
  must be dumped in a certain order. Here's how you do that:
  
      use YAML qw(Dump Bless);
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash)->keys(['banana', 'apple']);
      print Dump $hash;
  
  produces:
  
      ---
      apple: good
      banana: bad
      cauliflower: ugly
      ---
      banana: bad
      apple: good
  
  Bless returns the tied part of a yaml-node, so that you can call the
  YAML::Node methods. This is the same thing that YAML::Node::ynode()
  returns. So another way to do the above example is:
  
      use YAML qw(Dump Bless);
      use YAML::Node;
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash);
      $ynode = ynode(Blessed($hash));
      $ynode->keys(['banana', 'apple']);
      print Dump $hash;
  
  Note that Blessing a Perl data structure does not change it anyway. The
  extra information is stored separately and looked up by the Blessed
  node's memory address.
  
  =item Blessed(perl-node)
  
  Returns the yaml node that a particular perl node is associated with
  (see above). Returns undef if the node is not (YAML) Blessed.
  
  =back
  
  =head1 GLOBAL OPTIONS
  
  YAML options are set using a group of global variables in the YAML
  namespace. This is similar to how Data::Dumper works.
  
  For example, to change the indentation width, do something like:
  
      local $YAML::Indent = 3;
  
  The current options are:
  
  =over 4
  
  =item DumperClass
  
  You can override which module/class YAML uses for Dumping data.
  
  =item LoaderClass
  
  You can override which module/class YAML uses for Loading data.
  
  =item Indent
  
  This is the number of space characters to use for each indentation level
  when doing a Dump(). The default is 2.
  
  By the way, YAML can use any number of characters for indentation at any
  level. So if you are editing YAML by hand feel free to do it anyway that
  looks pleasing to you; just be consistent for a given level.
  
  =item SortKeys
  
  Default is 1. (true)
  
  Tells YAML.pm whether or not to sort hash keys when storing a document.
  
  YAML::Node objects can have their own sort order, which is usually what
  you want. To override the YAML::Node order and sort the keys anyway, set
  SortKeys to 2.
  
  =item Stringify
  
  Default is 0. (false)
  
  Objects with string overloading should honor the overloading and dump the
  stringification of themselves, rather than the actual object's guts.
  
  =item UseHeader
  
  Default is 1. (true)
  
  This tells YAML.pm whether to use a separator string for a Dump
  operation. This only applies to the first document in a stream.
  Subsequent documents must have a YAML header by definition.
  
  =item UseVersion
  
  Default is 0. (false)
  
  Tells YAML.pm whether to include the YAML version on the
  separator/header.
  
      --- %YAML:1.0
  
  =item AnchorPrefix
  
  Default is ''.
  
  Anchor names are normally numeric. YAML.pm simply starts with '1' and
  increases by one for each new anchor. This option allows you to specify a
  string to be prepended to each anchor number.
  
  =item UseCode
  
  Setting the UseCode option is a shortcut to set both the DumpCode and
  LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
  Perl code references as Perl (using B::Deparse) and to load them back
  into memory using eval(). The reason this has to be an option is that
  using eval() to parse untrusted code is, well, untrustworthy.
  
  =item DumpCode
  
  Determines if and how YAML.pm should serialize Perl code references. By
  default YAML.pm will dump code references as dummy placeholders (much
  like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
  references will be dumped as actual Perl code.
  
  DumpCode can also be set to a subroutine reference so that you can
  write your own serializing routine. YAML.pm passes you the code ref. You
  pass back the serialization (as a string) and a format indicator. The
  format indicator is a simple string like: 'deparse' or 'bytecode'.
  
  =item LoadCode
  
  LoadCode is the opposite of DumpCode. It tells YAML if and how to
  deserialize code references. When set to '1' or 'deparse' it will use
  C<eval()>. Since this is potentially risky, only use this option if you
  know where your YAML has been.
  
  LoadCode can also be set to a subroutine reference so that you can write
  your own deserializing routine. YAML.pm passes the serialization (as a
  string) and a format indicator. You pass back the code reference.
  
  =item UseBlock
  
  YAML.pm uses heuristics to guess which scalar style is best for a given
  node. Sometimes you'll want all multiline scalars to use the 'block'
  style. If so, set this option to 1.
  
  NOTE: YAML's block style is akin to Perl's here-document.
  
  =item UseFold
  
  If you want to force YAML to use the 'folded' style for all multiline
  scalars, then set $UseFold to 1.
  
  NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.
  
  =item UseAliases
  
  YAML has an alias mechanism such that any given structure in memory gets
  serialized once. Any other references to that structure are serialized
  only as alias markers. This is how YAML can serialize duplicate and
  recursive structures.
  
  Sometimes, when you KNOW that your data is nonrecursive in nature, you
  may want to serialize such that every node is expressed in full. (ie as
  a copy of the original). Setting $YAML::UseAliases to 0 will allow you
  to do this. This also may result in faster processing because the lookup
  overhead is by bypassed.
  
  THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option
  *will* cause Dump() to run in an endless loop, chewing up your computers
  memory. You have been warned.
  
  =item CompressSeries
  
  Default is 1.
  
  Compresses the formatting of arrays of hashes:
  
      -
        foo: bar
      -
        bar: foo
  
  becomes:
  
      - foo: bar
      - bar: foo
  
  Since this output is usually more desirable, this option is turned on by
  default.
  
  =back
  
  =head1 YAML TERMINOLOGY
  
  YAML is a full featured data serialization language, and thus has its
  own terminology.
  
  It is important to remember that although YAML is heavily influenced by
  Perl and Python, it is a language in its own right, not merely just a
  representation of Perl structures.
  
  YAML has three constructs that are conspicuously similar to Perl's hash,
  array, and scalar. They are called mapping, sequence, and string
  respectively. By default, they do what you would expect. But each
  instance may have an explicit or implicit tag (type) that makes it
  behave differently. In this manner, YAML can be extended to represent
  Perl's Glob or Python's tuple, or Ruby's Bigint.
  
  =over 4
  
  =item stream
  
  A YAML stream is the full sequence of Unicode characters that a YAML
  parser would read or a YAML emitter would write. A stream may contain
  one or more YAML documents separated by YAML headers.
  
      ---
      a: mapping
      foo: bar
      ---
      - a
      - sequence
  
  =item document
  
  A YAML document is an independent data structure representation within a
  stream. It is a top level node. Each document in a YAML stream must
  begin with a YAML header line. Actually the header is optional on the
  first document.
  
      ---
      This: top level mapping
      is:
          - a
          - YAML
          - document
  
  =item header
  
  A YAML header is a line that begins a YAML document. It consists of
  three dashes, possibly followed by more info. Another purpose of the
  header line is that it serves as a place to put top level tag and anchor
  information.
  
      --- !recursive-sequence &001
      - * 001
      - * 001
  
  =item node
  
  A YAML node is the representation of a particular data structure. Nodes
  may contain other nodes. (In Perl terms, nodes are like scalars.
  Strings, arrayrefs and hashrefs. But this refers to the serialized
  format, not the in-memory structure.)
  
  =item tag
  
  This is similar to a type. It indicates how a particular YAML node
  serialization should be transferred into or out of memory. For instance
  a Foo::Bar object would use the tag 'perl/Foo::Bar':
  
      - !perl/Foo::Bar
          foo: 42
          bar: stool
  
  =item collection
  
  A collection is the generic term for a YAML data grouping. YAML has two
  types of collections: mappings and sequences. (Similar to hashes and arrays)
  
  =item mapping
  
  A mapping is a YAML collection defined by unordered key/value pairs with
  unique keys. By default YAML mappings are loaded into Perl hashes.
  
      a mapping:
          foo: bar
          two: times two is 4
  
  =item sequence
  
  A sequence is a YAML collection defined by an ordered list of elements. By
  default YAML sequences are loaded into Perl arrays.
  
      a sequence:
          - one bourbon
          - one scotch
          - one beer
  
  =item scalar
  
  A scalar is a YAML node that is a single value. By default YAML scalars
  are loaded into Perl scalars.
  
      a scalar key: a scalar value
  
  YAML has many styles for representing scalars. This is important because
  varying data will have varying formatting requirements to retain the
  optimum human readability.
  
  =item plain scalar
  
  A plain scalar is unquoted. All plain scalars are automatic candidates
  for "implicit tagging". This means that their tag may be determined
  automatically by examination. The typical uses for this are plain alpha
  strings, integers, real numbers, dates, times and currency.
  
      - a plain string
      - -42
      - 3.1415
      - 12:34
      - 123 this is an error
  
  =item single quoted scalar
  
  This is similar to Perl's use of single quotes. It means no escaping
  except for single quotes which are escaped by using two adjacent
  single quotes.
  
      - 'When I say ''\n'' I mean "backslash en"'
  
  =item double quoted scalar
  
  This is similar to Perl's use of double quotes. Character escaping can
  be used.
  
      - "This scalar\nhas two lines, and a bell -->\a"
  
  =item folded scalar
  
  This is a multiline scalar which begins on the next line. It is
  indicated by a single right angle bracket. It is unescaped like the
  single quoted scalar. Line folding is also performed.
  
      - >
       This is a multiline scalar which begins on
       the next line. It is indicated by a single
       carat. It is unescaped like the single
       quoted scalar. Line folding is also
       performed.
  
  =item block scalar
  
  This final multiline form is akin to Perl's here-document except that
  (as in all YAML data) scope is indicated by indentation. Therefore, no
  ending marker is required. The data is verbatim. No line folding.
  
      - |
          QTY  DESC          PRICE  TOTAL
          ---  ----          -----  -----
            1  Foo Fighters  $19.95 $19.95
            2  Bar Belles    $29.95 $59.90
  
  =item parser
  
  A YAML processor has four stages: parse, load, dump, emit.
  
  A parser parses a YAML stream. YAML.pm's Load() function contains a
  parser.
  
  =item loader
  
  The other half of the Load() function is a loader. This takes the
  information from the parser and loads it into a Perl data structure.
  
  =item dumper
  
  The Dump() function consists of a dumper and an emitter. The dumper
  walks through each Perl data structure and gives info to the emitter.
  
  =item emitter
  
  The emitter takes info from the dumper and turns it into a YAML stream.
  
  NOTE:
  In YAML.pm the parser/loader and the dumper/emitter code are currently
  very closely tied together. In the future they may be broken into
  separate stages.
  
  =back
  
  For more information please refer to the immensely helpful YAML
  specification available at L<http://www.yaml.org/spec/>.
  
  =head1 ysh - The YAML Shell
  
  The YAML distribution ships with a script called 'ysh', the YAML shell.
  ysh provides a simple, interactive way to play with YAML. If you type in
  Perl code, it displays the result in YAML. If you type in YAML it turns
  it into Perl code.
  
  To run ysh, (assuming you installed it along with YAML.pm) simply type:
  
      ysh [options]
  
  Please read the C<ysh> documentation for the full details. There are
  lots of options.
  
  =head1 BUGS & DEFICIENCIES
  
  If you find a bug in YAML, please try to recreate it in the YAML Shell
  with logging turned on ('ysh -L'). When you have successfully reproduced
  the bug, please mail the LOG file to the author (ingy@cpan.org).
  
  WARNING: This is still *ALPHA* code. Well, most of this code has been
  around for years...
  
  BIGGER WARNING: YAML.pm has been slow in the making, but I am committed
  to having top notch YAML tools in the Perl world. The YAML team is close
  to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of
  a very old pre 1.0 spec. In actuality there isn't a ton of difference,
  and this YAML.pm is still fairly useful. Things will get much better in
  the future.
  
  =head1 RESOURCES
  
  L<http://lists.sourceforge.net/lists/listinfo/yaml-core> is the mailing
  list. This is where the language is discussed and designed.
  
  L<http://www.yaml.org> is the official YAML website.
  
  L<http://www.yaml.org/spec/> is the YAML 1.0 specification.
  
  L<http://yaml.kwiki.org> is the official YAML wiki.
  
  =head1 SEE ALSO
  
  See YAML::XS. Fast!
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  is responsible for YAML.pm.
  
  The YAML serialization language is the result of years of collaboration
  between Oren Ben-Kiki, Clark Evans and Ingy dt Net. Several others
  have added help along the way.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005, 2006, 2008, 2011-2014. Ingy dt Net.
  
  Copyright (c) 2001, 2002, 2005. Brian Ingerson.
  
  Some parts copyright (c) 2009 - 2010 Adam Kennedy
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  package YAML::Any;
  $YAML::Any::VERSION = '0.90';
  use strict;
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::Croak(@_);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Any - Pick a YAML implementation and use it.
  
  =head1 SYNOPSIS
  
      use YAML::Any;
      $YAML::Indent = 3;
      my $yaml = Dump(@objects);
  
  =head1 DESCRIPTION
  
  There are several YAML implementations that support the Dump/Load API.
  This module selects the best one available and uses it.
  
  =head1 ORDER
  
  Currently, YAML::Any will choose the first one of these YAML
  implementations that is installed on your system:
  
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  
  =head1 OPTIONS
  
  If you specify an option like:
  
      $YAML::Indent = 4;
  
  And YAML::Any is using YAML::XS, it will use the proper variable:
  $YAML::XS::Indent.
  
  =head1 SUBROUTINES
  
  Like all the YAML modules that YAML::Any uses, the following subroutines
  are exported by default:
  
      Dump
      Load
  
  and the following subroutines are exportable by request:
  
      DumpFile
      LoadFile
  
  =head1 METHODS
  
  YAML::Any provides the following class methods.
  
  =over
  
  =item YAML::Any->order;
  
  This method returns a list of the current possible implementations that
  YAML::Any will search for.
  
  =item YAML::Any->implementation;
  
  This method returns the implementation the YAML::Any will use. This
  result is obtained by finding the first member of YAML::Any->order that
  is either already loaded in C<%INC> or that can be loaded using
  C<require>. If no implementation is found, an error will be thrown.
  
  =back
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008, 2014. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  $YAML::Dumper::VERSION = '0.90';
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo);
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0],
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) =
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      require YAML;
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} =
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) =
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash.
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
  
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Dumper - YAML class for dumping Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Dumper;
      my $dumper = YAML::Dumper->new;
      $dumper->indent_width(4);
      print $dumper->dump({foo => 'bar'});
  
  =head1 DESCRIPTION
  
  YAML::Dumper is the module that YAML.pm used to serialize Perl objects to
  YAML. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  $YAML::Dumper::Base::VERSION = '0.90';
  use YAML::Mo;
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
  
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Dumper::Base - Base class for YAML Dumper classes
  
  =head1 SYNOPSIS
  
      package YAML::Dumper::Something;
      use YAML::Dumper::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Dumper::Base is a base class for creating YAML dumper classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  $YAML::Error::VERSION = '0.90';
  use YAML::Mo;
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)}
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
       YAML_PARSE_ERR_NO_ANCHOR
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  $YAML::Warning::VERSION = '0.90';
  our @ISA = 'YAML::Error';
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Error - Error formatting class for YAML modules
  
  =head1 SYNOPSIS
  
      $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias);
      $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
  
  =head1 DESCRIPTION
  
  This module provides a C<die> and a C<warn> facility.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  $YAML::Loader::VERSION = '0.90';
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';
  my $LIT_CHAR_RX = "\\$LIT_CHAR";
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS')
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE')
        if length($self->stream) and
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) =
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) =
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) {
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE');
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface);
  }
  
  # Morph a node to it's explicit type
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
  
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
  
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) =
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      # https://rt.cpan.org/Public/Bug/Display.html?id=90593
      if ($self->inline =~ /^"((?>(?>(?:\\"|[^"]){0,32766}){0,32766}))"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`\^]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/ or die;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or die;
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
  
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos;
  
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
  
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Loader - YAML class for loading Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Loader;
      my $loader = YAML::Loader->new;
      my $hash = $loader->load(<<'...');
      foo: bar
      ...
  
  =head1 DESCRIPTION
  
  YAML::Loader is the module that YAML.pm used to deserialize YAML to Perl
  objects. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  $YAML::Loader::Base::VERSION = '0.90';
  use YAML::Mo;
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Loader::Base - Base class for YAML Loader classes
  
  =head1 SYNOPSIS
  
      package YAML::Loader::Something;
      use YAML::Loader::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Loader::Base is a base class for creating YAML loader classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict; use warnings;
  package YAML::Marshall;
  $YAML::Marshall::VERSION = '0.90';
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Marshall - YAML marshalling class you can mixin to your classes
  
  =head1 SYNOPSIS
  
      package Bar;
      use Foo -base;
      use YAML::Marshall -mixin;
  
  =head1 DESCRIPTION
  
  For classes that want to handle their own YAML serialization.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo;
  $YAML::Mo::VERSION = '0.90';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict; use warnings;
  package YAML::Node;
  $YAML::Node::VERSION = '0.90';
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
  	$self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
  	$self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
  	$self = tied(*{$_[0]});
      }
      else {
  	$self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
  		    ($type eq 'HASH') ? 'mapping' :
  		    $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
  	yaml_scalar->new($self, $_[1]);
  	return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{TAG} = YAML::Tag->new($value);
  	return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{KEYS} = $value;
  	return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  $yaml_scalar::VERSION = '0.90';
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  $yaml_sequence::VERSION = '0.90';
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  $yaml_mapping::VERSION = '0.90';
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}};
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
  	return (grep {$_ eq $key} @{$self->{KEYS}})
  	       ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
  	$self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
  	$self->{HASH}{$key} = $value;
      }
      else {
  	if (not grep {$_ eq $key} @{$self->{KEYS}}) {
  	    push(@{$self->{KEYS}}, $key);
  	}
  	$self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
  	$return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
  	$return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
  	if ($self->{KEYS}[$i] eq $key) {
  	    splice(@{$self->{KEYS}}, $i, 1);
  	}
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Node - A generic data node that encapsulates YAML information
  
  =head1 SYNOPSIS
  
      use YAML;
      use YAML::Node;
  
      my $ynode = YAML::Node->new({}, 'ingerson.com/fruit');
      %$ynode = qw(orange orange apple red grape green);
      print Dump $ynode;
  
  yields:
  
      --- !ingerson.com/fruit
      orange: orange
      apple: red
      grape: green
  
  =head1 DESCRIPTION
  
  A generic node in YAML is similar to a plain hash, array, or scalar node
  in Perl except that it must also keep track of its type. The type is a
  URI called the YAML type tag.
  
  YAML::Node is a class for generating and manipulating these containers.
  A YAML node (or ynode) is a tied hash, array or scalar. In most ways it
  behaves just like the plain thing. But you can assign and retrieve and
  YAML type tag URI to it. For the hash flavor, you can also assign the
  order that the keys will be retrieved in. By default a ynode will offer
  its keys in the same order that they were assigned.
  
  YAML::Node has a class method call new() that will return a ynode. You
  pass it a regular node and an optional type tag. After that you can
  use it like a normal Perl node, but when you YAML::Dump it, the magical
  properties will be honored.
  
  This is how you can control the sort order of hash keys during a YAML
  serialization. By default, YAML sorts keys alphabetically. But notice
  in the above example that the keys were Dumped in the same order they
  were assigned.
  
  YAML::Node exports a function called ynode(). This function returns the tied object so that you can call special methods on it like ->keys().
  
  keys() works like this:
  
      use YAML;
      use YAML::Node;
  
      %$node = qw(orange orange apple red grape green);
      $ynode = YAML::Node->new($node);
      ynode($ynode)->keys(['grape', 'apple']);
      print Dump $ynode;
  
  produces:
  
      ---
      grape: green
      apple: red
  
  It tells the ynode which keys and what order to use.
  
  ynodes will play a very important role in how programs use YAML. They
  are the foundation of how a Perl class can marshall the Loading and
  Dumping of its objects.
  
  The upcoming versions of YAML.pm will have much more information on this.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  Copyright (c) 2002. Brian Ingerson. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict; use warnings;
  package YAML::Tag;
  $YAML::Tag::VERSION = '0.90';
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Tag - Tag URI object class for YAML
  
  =head1 SYNOPSIS
  
      use YAML::Tag;
  
  =head1 DESCRIPTION
  
  Used by YAML::Node.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  $YAML::Types::VERSION = '0.90';
  use YAML::Mo;
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  $YAML::Type::blessed::VERSION = '0.90';
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  $YAML::Type::undef::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  $YAML::Type::glob::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
      my $ynode = YAML::Node->new({}, '!perl/glob:');
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value;
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  $YAML::Type::code::VERSION = '0.90';
  my $dummy_warned = 0;
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  $YAML::Type::ref::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  $YAML::Type::regexp::VERSION = '0.90';
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Types - Marshall Perl internal data types to/from YAML
  
  =head1 SYNOPSIS
  
      $::foo = 42;
      print YAML::Dump(*::foo);
  
      print YAML::Dump(qr{match me});
  
  =head1 DESCRIPTION
  
  This module has the helper classes for transferring objects,
  subroutines, references, globs, regexps and file handles to and
  from YAML.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TYPES

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use strictures 1;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
OO

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;
  
  use strict;
  use warnings FATAL => 'all';
  
  BEGIN {
    *_PERL_LT_5_8_4 = ($] < 5.008004) ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '1.005003'; # 1.5.3
  
  sub VERSION {
    my ($class, $version) = @_;
    for ($version) {
      last unless defined && !ref && int != 1;
      die "Major version specified as $_ - this is strictures version 1";
    }
    # passing undef here may either warn or die depending on the version of perl.
    # we can't match the caller's warning state in this case, so just disable the
    # warning.
    no warnings 'uninitialized';
    shift->SUPER::VERSION(@_);
  }
  
  our $extra_load_states;
  
  our $Smells_Like_VCS = (-e '.git' || -e '.svn' || -e '.hg'
    || (-e '../../dist.ini'
        && (-e '../../.git' || -e '../../.svn' || -e '../../.hg' )));
  
  sub import {
    strict->import;
    warnings->import(FATAL => 'all');
  
    my $extra_tests = do {
      if (exists $ENV{PERL_STRICTURES_EXTRA}) {
        if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}) {
          die 'PERL_STRICTURES_EXTRA checks are not available on perls older than 5.8.4: '
            . "please unset \$ENV{PERL_STRICTURES_EXTRA}\n";
        }
        $ENV{PERL_STRICTURES_EXTRA};
      } elsif (! _PERL_LT_5_8_4) {
        !!((caller)[1] =~ /^(?:t|xt|lib|blib)/
           and $Smells_Like_VCS)
      }
    };
    if ($extra_tests) {
      $extra_load_states ||= do {
  
        my (%rv, @failed);
        foreach my $mod (qw(indirect multidimensional bareword::filehandles)) {
          eval "require $mod; \$rv{'$mod'} = 1;" or do {
            push @failed, $mod;
  
            # courtesy of the 5.8 require bug
            # (we do a copy because 5.16.2 at least uses the same read-only
            # scalars for the qw() list and it doesn't seem worth a $^V check)
  
            (my $file = $mod) =~ s|::|/|g;
            delete $INC{"${file}.pm"};
          };
        }
  
        if (@failed) {
          my $failed = join ' ', @failed;
          print STDERR <<EOE;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  EOE
        }
  
        \%rv;
      };
  
      indirect->unimport(':fatal') if $extra_load_states->{indirect};
      multidimensional->unimport if $extra_load_states->{multidimensional};
      bareword::filehandles->unimport if $extra_load_states->{'bareword::filehandles'};
    }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures - turn on strict and make all warnings fatal
  
  =head1 SYNOPSIS
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
  
  except when called from a file which matches:
  
    (caller)[1] =~ /^(?:t|xt|lib|blib)/
  
  and when either C<.git>, C<.svn>, or C<.hg> is present in the current directory (with
  the intention of only forcing extra tests on the author side) -- or when C<.git>,
  C<.svn>, or C<.hg> is present two directories up along with C<dist.ini> (which would
  indicate we are in a C<dzil test> operation, via L<Dist::Zilla>) --
  or when the C<PERL_STRICTURES_EXTRA> environment variable is set, in which case
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Note that C<PERL_STRICTURES_EXTRA> may at some point add even more tests, with only a minor
  version increase, but any changes to the effect of C<use strictures> in
  normal mode will involve a major version bump.
  
  If any of the extra testing modules are not present, L<strictures> will
  complain loudly, once, via C<warn()>, and then shut up. But you really
  should consider installing them, they're all great anti-footgun tools.
  
  =head1 DESCRIPTION
  
  I've been writing the equivalent of this module at the top of my code for
  about a year now. I figured it was time to make it shorter.
  
  Things like the importer in C<use Moose> don't help me because they turn
  warnings on but don't make them fatal -- which from my point of view is
  useless because I want an exception to tell me my code isn't warnings-clean.
  
  Any time I see a warning from my code, that indicates a mistake.
  
  Any time my code encounters a mistake, I want a crash -- not spew to STDERR
  and then unknown (and probably undesired) subsequent behaviour.
  
  I also want to ensure that obvious coding mistakes, like indirect object
  syntax (and not so obvious mistakes that cause things to accidentally compile
  as such) get caught, but not at the cost of an XS dependency and not at the
  cost of blowing things up on another machine.
  
  Therefore, L<strictures> turns on additional checking, but only when it thinks
  it's running in a test file in a VCS checkout -- although if this causes
  undesired behaviour this can be overridden by setting the
  C<PERL_STRICTURES_EXTRA> environment variable.
  
  If additional useful author side checks come to mind, I'll add them to the
  C<PERL_STRICTURES_EXTRA> code path only -- this will result in a minor version increase (e.g.
  1.000000 to 1.001000 (1.1.0) or similar). Any fixes only to the mechanism of
  this code will result in a sub-version increase (e.g. 1.000000 to 1.000001
  (1.0.1)).
  
  If the behaviour of C<use strictures> in normal mode changes in any way, that
  will constitute a major version increase -- and the code already checks
  when its version is tested to ensure that
  
    use strictures 1;
  
  will continue to only introduce the current set of strictures even if 2.0 is
  installed.
  
  =head1 METHODS
  
  =head2 import
  
  This method does the setup work described above in L</DESCRIPTION>
  
  =head2 VERSION
  
  This method traps the C<< strictures->VERSION(1) >> call produced by a use line
  with a version number on it and does the version check.
  
  =head1 EXTRA TESTING RATIONALE
  
  Every so often, somebody complains that they're deploying via C<git pull>
  and that they don't want L<strictures> to enable itself in this case -- and that
  setting C<PERL_STRICTURES_EXTRA> to 0 isn't acceptable (additional ways to
  disable extra testing would be welcome but the discussion never seems to get
  that far).
  
  In order to allow us to skip a couple of stages and get straight to a
  productive conversation, here's my current rationale for turning the
  extra testing on via a heuristic:
  
  The extra testing is all stuff that only ever blows up at compile time;
  this is intentional. So the oft-raised concern that it's different code being
  tested is only sort of the case -- none of the modules involved affect the
  final optree to my knowledge, so the author gets some additional compile
  time crashes which he/she then fixes, and the rest of the testing is
  completely valid for all environments.
  
  The point of the extra testing -- especially C<no indirect> -- is to catch
  mistakes that newbie users won't even realise are mistakes without
  help. For example,
  
    foo { ... };
  
  where foo is an & prototyped sub that you forgot to import -- this is
  pernicious to track down since all I<seems> fine until it gets called
  and you get a crash. Worse still, you can fail to have imported it due
  to a circular require, at which point you have a load order dependent
  bug which I've seen before now I<only> show up in production due to tiny
  differences between the production and the development environment. I wrote
  L<http://shadow.cat/blog/matt-s-trout/indirect-but-still-fatal/> to explain
  this particular problem before L<strictures> itself existed.
  
  As such, in my experience so far L<strictures>' extra testing has
  I<avoided> production versus development differences, not caused them.
  
  Additionally, L<strictures>' policy is very much "try and provide as much
  protection as possible for newbies -- who won't think about whether there's
  an option to turn on or not" -- so having only the environment variable
  is not sufficient to achieve that (I get to explain that you need to add
  C<use strict> at least once a week on freenode #perl -- newbies sometimes
  completely skip steps because they don't understand that that step
  is important).
  
  I make no claims that the heuristic is perfect -- it's already been evolved
  significantly over time, especially for 1.004 where we changed things to
  ensure it only fires on files in your checkout (rather than L<strictures>-using
  modules you happened to have installed, which was just silly). However, I
  hope the above clarifies why a heuristic approach is not only necessary but
  desirable from a point of view of providing new users with as much safety as possible,
  and will allow any future discussion on the subject to focus on "how do we
  minimise annoyance to people deploying from checkouts intentionally".
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<indirect>
  
  =item *
  
  L<multidimensional>
  
  =item *
  
  L<bareword::filehandles>
  
  =back
  
  =head1 COMMUNITY AND SUPPORT
  
  =head2 IRC channel
  
  irc.perl.org #toolchain
  
  (or bug 'mst' in query on there or freenode)
  
  =head2 Git repository
  
  Gitweb is on http://git.shadowcat.co.uk/ and the clone URL is:
  
    git clone git://git.shadowcat.co.uk/p5sagit/strictures.git
  
  The web interface to the repository is at:
  
    http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=p5sagit/strictures.git
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@gmail.com>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the strictures L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
STRICTURES

$fatpacked{"x86_64-linux-thread-multi/Class/MOP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP';
  
  package Class::MOP;
  BEGIN {
    $Class::MOP::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use 5.008003;
  
  use MRO::Compat;
  
  use Class::Load 0.07 ();
  use Scalar::Util  'weaken', 'isweak', 'reftype', 'blessed';
  use Data::OptList;
  use Try::Tiny;
  
  use Class::MOP::Mixin::AttributeCore;
  use Class::MOP::Mixin::HasAttributes;
  use Class::MOP::Mixin::HasMethods;
  use Class::MOP::Class;
  use Class::MOP::Attribute;
  use Class::MOP::Method;
  
  BEGIN {
      *IS_RUNNING_ON_5_10 = ($] < 5.009_005)
          ? sub () { 0 }
          : sub () { 1 };
  
      # this is either part of core or set up appropriately by MRO::Compat
      *check_package_cache_flag = \&mro::get_pkg_gen;
  }
  
  XSLoader::load(
      'Moose',
      $Class::MOP::{VERSION} ? ${ $Class::MOP::{VERSION} } : ()
  );
  
  {
      # Metaclasses are singletons, so we cache them here.
      # there is no need to worry about destruction though
      # because they should die only when the program dies.
      # After all, do package definitions even get reaped?
      # Anonymous classes manage their own destruction.
      my %METAS;
  
      sub get_all_metaclasses         {        %METAS         }
      sub get_all_metaclass_instances { values %METAS         }
      sub get_all_metaclass_names     { keys   %METAS         }
      sub get_metaclass_by_name       { $METAS{$_[0]}         }
      sub store_metaclass_by_name     { $METAS{$_[0]} = $_[1] }
      sub weaken_metaclass            { weaken($METAS{$_[0]}) }
      sub metaclass_is_weak           { isweak($METAS{$_[0]}) }
      sub does_metaclass_exist        { exists $METAS{$_[0]} && defined $METAS{$_[0]} }
      sub remove_metaclass_by_name    { delete $METAS{$_[0]}; return }
  
      # This handles instances as well as class names
      sub class_of {
          return unless defined $_[0];
          my $class = blessed($_[0]) || $_[0];
          return $METAS{$class};
      }
  
      # NOTE:
      # We only cache metaclasses, meaning instances of
      # Class::MOP::Class. We do not cache instance of
      # Class::MOP::Package or Class::MOP::Module. Mostly
      # because I don't yet see a good reason to do so.
  }
  
  sub load_class {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::load_class is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::load_class;
  }
  
  sub load_first_existing_class {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::load_first_existing_class is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::load_first_existing_class;
  }
  
  sub is_class_loaded {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::is_class_loaded is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::is_class_loaded;
  }
  
  sub _definition_context {
      my %context;
      @context{qw(package file line)} = caller(1);
  
      return (
          definition_context => \%context,
      );
  }
  
  ## ----------------------------------------------------------------------------
  ## Setting up our environment ...
  ## ----------------------------------------------------------------------------
  ## Class::MOP needs to have a few things in the global perl environment so
  ## that it can operate effectively. Those things are done here.
  ## ----------------------------------------------------------------------------
  
  # ... nothing yet actually ;)
  
  ## ----------------------------------------------------------------------------
  ## Bootstrapping
  ## ----------------------------------------------------------------------------
  ## The code below here is to bootstrap our MOP with itself. This is also
  ## sometimes called "tying the knot". By doing this, we make it much easier
  ## to extend the MOP through subclassing and such since now you can use the
  ## MOP itself to extend itself.
  ##
  ## Yes, I know, that's weird and insane, but it's a good thing, trust me :)
  ## ----------------------------------------------------------------------------
  
  # We need to add in the meta-attributes here so that
  # any subclass of Class::MOP::* will be able to
  # inherit them using _construct_instance
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasMethods
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('_methods' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              '_method_map' => \&Class::MOP::Mixin::HasMethods::_method_map
          },
          default => sub { {} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('method_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'method_metaclass' => \&Class::MOP::Mixin::HasMethods::method_metaclass
          },
          default  => 'Class::MOP::Method',
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('wrapped_method_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'wrapped_method_metaclass' => \&Class::MOP::Mixin::HasMethods::wrapped_method_metaclass
          },
          default  => 'Class::MOP::Method::Wrapped',
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasMethods
  
  Class::MOP::Mixin::HasAttributes->meta->add_attribute(
      Class::MOP::Attribute->new('attributes' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              '_attribute_map' => \&Class::MOP::Mixin::HasAttributes::_attribute_map
          },
          default  => sub { {} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasAttributes->meta->add_attribute(
      Class::MOP::Attribute->new('attribute_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'attribute_metaclass' => \&Class::MOP::Mixin::HasAttributes::attribute_metaclass
          },
          default  => 'Class::MOP::Attribute',
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Package
  
  Class::MOP::Package->meta->add_attribute(
      Class::MOP::Attribute->new('package' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'name' => \&Class::MOP::Package::name
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Package->meta->add_attribute(
      Class::MOP::Attribute->new('namespace' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'namespace' => \&Class::MOP::Package::namespace
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Module
  
  # NOTE:
  # yeah this is kind of stretching things a bit,
  # but truthfully the version should be an attribute
  # of the Module, the weirdness comes from having to
  # stick to Perl 5 convention and store it in the
  # $VERSION package variable. Basically if you just
  # squint at it, it will look how you want it to look.
  # Either as a package variable, or as a attribute of
  # the metaclass, isn't abstraction great :)
  
  Class::MOP::Module->meta->add_attribute(
      Class::MOP::Attribute->new('version' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'version' => \&Class::MOP::Module::version
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  # NOTE:
  # By following the same conventions as version here,
  # we are opening up the possibility that people can
  # use the $AUTHORITY in non-Class::MOP modules as
  # well.
  
  Class::MOP::Module->meta->add_attribute(
      Class::MOP::Attribute->new('authority' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'authority' => \&Class::MOP::Module::authority
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Class
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('superclasses' => (
          accessor => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'superclasses' => \&Class::MOP::Class::superclasses
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('instance_metaclass' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'instance_metaclass' => \&Class::MOP::Class::instance_metaclass
          },
          default  => 'Class::MOP::Instance',
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('immutable_trait' => (
          reader   => {
              'immutable_trait' => \&Class::MOP::Class::immutable_trait
          },
          default => "Class::MOP::Class::Immutable::Trait",
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('constructor_name' => (
          reader   => {
              'constructor_name' => \&Class::MOP::Class::constructor_name,
          },
          default => "new",
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('constructor_class' => (
          reader   => {
              'constructor_class' => \&Class::MOP::Class::constructor_class,
          },
          default => "Class::MOP::Method::Constructor",
          _definition_context(),
      ))
  );
  
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('destructor_class' => (
          reader   => {
              'destructor_class' => \&Class::MOP::Class::destructor_class,
          },
          _definition_context(),
      ))
  );
  
  # NOTE:
  # we don't actually need to tie the knot with
  # Class::MOP::Class here, it is actually handled
  # within Class::MOP::Class itself in the
  # _construct_class_instance method.
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::AttributeCore
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('name' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'name' => \&Class::MOP::Mixin::AttributeCore::name
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('accessor' => (
          reader    => { 'accessor'     => \&Class::MOP::Mixin::AttributeCore::accessor     },
          predicate => { 'has_accessor' => \&Class::MOP::Mixin::AttributeCore::has_accessor },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('reader' => (
          reader    => { 'reader'     => \&Class::MOP::Mixin::AttributeCore::reader     },
          predicate => { 'has_reader' => \&Class::MOP::Mixin::AttributeCore::has_reader },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('initializer' => (
          reader    => { 'initializer'     => \&Class::MOP::Mixin::AttributeCore::initializer     },
          predicate => { 'has_initializer' => \&Class::MOP::Mixin::AttributeCore::has_initializer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('definition_context' => (
          reader    => { 'definition_context'     => \&Class::MOP::Mixin::AttributeCore::definition_context     },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('writer' => (
          reader    => { 'writer'     => \&Class::MOP::Mixin::AttributeCore::writer     },
          predicate => { 'has_writer' => \&Class::MOP::Mixin::AttributeCore::has_writer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('predicate' => (
          reader    => { 'predicate'     => \&Class::MOP::Mixin::AttributeCore::predicate     },
          predicate => { 'has_predicate' => \&Class::MOP::Mixin::AttributeCore::has_predicate },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('clearer' => (
          reader    => { 'clearer'     => \&Class::MOP::Mixin::AttributeCore::clearer     },
          predicate => { 'has_clearer' => \&Class::MOP::Mixin::AttributeCore::has_clearer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('builder' => (
          reader    => { 'builder'     => \&Class::MOP::Mixin::AttributeCore::builder     },
          predicate => { 'has_builder' => \&Class::MOP::Mixin::AttributeCore::has_builder },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('init_arg' => (
          reader    => { 'init_arg'     => \&Class::MOP::Mixin::AttributeCore::init_arg     },
          predicate => { 'has_init_arg' => \&Class::MOP::Mixin::AttributeCore::has_init_arg },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('default' => (
          # default has a custom 'reader' method ...
          predicate => { 'has_default' => \&Class::MOP::Mixin::AttributeCore::has_default },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('insertion_order' => (
          reader      => { 'insertion_order' => \&Class::MOP::Mixin::AttributeCore::insertion_order },
          writer      => { '_set_insertion_order' => \&Class::MOP::Mixin::AttributeCore::_set_insertion_order },
          predicate   => { 'has_insertion_order' => \&Class::MOP::Mixin::AttributeCore::has_insertion_order },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Attribute
  Class::MOP::Attribute->meta->add_attribute(
      Class::MOP::Attribute->new('associated_class' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'associated_class' => \&Class::MOP::Attribute::associated_class
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Attribute->meta->add_attribute(
      Class::MOP::Attribute->new('associated_methods' => (
          reader   => { 'associated_methods' => \&Class::MOP::Attribute::associated_methods },
          default  => sub { [] },
          _definition_context(),
      ))
  );
  
  Class::MOP::Attribute->meta->add_method('clone' => sub {
      my $self  = shift;
      $self->meta->clone_object($self, @_);
  });
  
  ## --------------------------------------------------------
  ## Class::MOP::Method
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('body' => (
          reader   => { 'body' => \&Class::MOP::Method::body },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass' => (
          reader   => { 'associated_metaclass' => \&Class::MOP::Method::associated_metaclass },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('package_name' => (
          reader   => { 'package_name' => \&Class::MOP::Method::package_name },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('name' => (
          reader   => { 'name' => \&Class::MOP::Method::name },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('original_method' => (
          reader   => { 'original_method'      => \&Class::MOP::Method::original_method },
          writer   => { '_set_original_method' => \&Class::MOP::Method::_set_original_method },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Wrapped
  
  # NOTE:
  # the way this item is initialized, this
  # really does not follow the standard
  # practices of attributes, but we put
  # it here for completeness
  Class::MOP::Method::Wrapped->meta->add_attribute(
      Class::MOP::Attribute->new('modifier_table' => (
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Generated
  
  Class::MOP::Method::Generated->meta->add_attribute(
      Class::MOP::Attribute->new('is_inline' => (
          reader   => { 'is_inline' => \&Class::MOP::Method::Generated::is_inline },
          default  => 0,
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Generated->meta->add_attribute(
      Class::MOP::Attribute->new('definition_context' => (
          reader   => { 'definition_context' => \&Class::MOP::Method::Generated::definition_context },
          _definition_context(),
      ))
  );
  
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Inlined
  
  Class::MOP::Method::Inlined->meta->add_attribute(
      Class::MOP::Attribute->new('_expected_method_class' => (
          reader   => { '_expected_method_class' => \&Class::MOP::Method::Inlined::_expected_method_class },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Accessor
  
  Class::MOP::Method::Accessor->meta->add_attribute(
      Class::MOP::Attribute->new('attribute' => (
          reader   => {
              'associated_attribute' => \&Class::MOP::Method::Accessor::associated_attribute
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Accessor->meta->add_attribute(
      Class::MOP::Attribute->new('accessor_type' => (
          reader   => { 'accessor_type' => \&Class::MOP::Method::Accessor::accessor_type },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Constructor
  
  Class::MOP::Method::Constructor->meta->add_attribute(
      Class::MOP::Attribute->new('options' => (
          reader   => {
              'options' => \&Class::MOP::Method::Constructor::options
          },
          default  => sub { +{} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Constructor->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass' => (
          init_arg => "metaclass", # FIXME alias and rename
          reader   => {
              'associated_metaclass' => \&Class::MOP::Method::Constructor::associated_metaclass
          },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Instance
  
  # NOTE:
  # these don't yet do much of anything, but are just
  # included for completeness
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass',
          reader   => { associated_metaclass => \&Class::MOP::Instance::associated_metaclass },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('_class_name',
          init_arg => undef,
          reader   => { _class_name => \&Class::MOP::Instance::_class_name },
          #lazy     => 1, # not yet supported by Class::MOP but out our version does it anyway
          #default  => sub { $_[0]->associated_metaclass->name },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('attributes',
          reader   => { attributes => \&Class::MOP::Instance::get_all_attributes },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('slots',
          reader   => { slots => \&Class::MOP::Instance::slots },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('slot_hash',
          reader   => { slot_hash => \&Class::MOP::Instance::slot_hash },
          _definition_context(),
      ),
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Object
  
  # need to replace the meta method there with a real meta method object
  Class::MOP::Object->meta->_add_meta_method('meta');
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin
  
  # need to replace the meta method there with a real meta method object
  Class::MOP::Mixin->meta->_add_meta_method('meta');
  
  require Class::MOP::Deprecated unless our $no_deprecated;
  
  # we need the meta instance of the meta instance to be created now, in order
  # for the constructor to be able to use it
  Class::MOP::Instance->meta->get_meta_instance;
  
  # pretend the add_method never happened. it hasn't yet affected anything
  undef Class::MOP::Instance->meta->{_package_cache_flag};
  
  ## --------------------------------------------------------
  ## Now close all the Class::MOP::* classes
  
  # NOTE: we don't need to inline the accessors this only lengthens the compile
  # time of the MOP, and gives us no actual benefits.
  
  $_->meta->make_immutable(
      inline_constructor  => 0,
      constructor_name    => "_new",
      inline_accessors => 0,
  ) for qw/
      Class::MOP::Package
      Class::MOP::Module
      Class::MOP::Class
  
      Class::MOP::Attribute
      Class::MOP::Method
      Class::MOP::Instance
  
      Class::MOP::Object
  
      Class::MOP::Method::Generated
      Class::MOP::Method::Inlined
  
      Class::MOP::Method::Accessor
      Class::MOP::Method::Constructor
      Class::MOP::Method::Wrapped
  
      Class::MOP::Method::Meta
      Class::MOP::Method::Overload
  /;
  
  $_->meta->make_immutable(
      inline_constructor  => 0,
      constructor_name    => undef,
      inline_accessors => 0,
  ) for qw/
      Class::MOP::Mixin
      Class::MOP::Mixin::AttributeCore
      Class::MOP::Mixin::HasAttributes
      Class::MOP::Mixin::HasMethods
  /;
  
  1;
  
  # ABSTRACT: A Meta Object Protocol for Perl 5
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP - A Meta Object Protocol for Perl 5
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This module is a fully functioning meta object protocol for the
  Perl 5 object system. It makes no attempt to change the behavior or
  characteristics of the Perl 5 object system, only to create a
  protocol for its manipulation and introspection.
  
  That said, it does attempt to create the tools for building a rich set
  of extensions to the Perl 5 object system. Every attempt has been made
  to abide by the spirit of the Perl 5 object system that we all know
  and love.
  
  This documentation is sparse on conceptual details. We suggest looking
  at the items listed in the L<SEE ALSO> section for more
  information. In particular the book "The Art of the Meta Object
  Protocol" was very influential in the development of this system.
  
  =head2 What is a Meta Object Protocol?
  
  A meta object protocol is an API to an object system.
  
  To be more specific, it abstracts the components of an object system
  (classes, object, methods, object attributes, etc.). These
  abstractions can then be used to inspect and manipulate the object
  system which they describe.
  
  It can be said that there are two MOPs for any object system; the
  implicit MOP and the explicit MOP. The implicit MOP handles things
  like method dispatch or inheritance, which happen automatically as
  part of how the object system works. The explicit MOP typically
  handles the introspection/reflection features of the object system.
  
  All object systems have implicit MOPs. Without one, they would not
  work. Explicit MOPs are much less common, and depending on the
  language can vary from restrictive (Reflection in Java or C#) to wide
  open (CLOS is a perfect example).
  
  =head2 Yet Another Class Builder! Why?
  
  This is B<not> a class builder so much as a I<class builder
  B<builder>>. The intent is that an end user will not use this module
  directly, but instead this module is used by module authors to build
  extensions and features onto the Perl 5 object system.
  
  This system is used by L<Moose>, which supplies a powerful class
  builder system built entirely on top of C<Class::MOP>.
  
  =head2 Who is this module for?
  
  This module is for anyone who has ever created or wanted to create a
  module for the Class:: namespace. The tools which this module provides
  make doing complex Perl 5 wizardry simpler, by removing such barriers
  as the need to hack symbol tables, or understand the fine details of
  method dispatch.
  
  =head2 What changes do I have to make to use this module?
  
  This module was designed to be as unobtrusive as possible. Many of its
  features are accessible without B<any> change to your existing
  code. It is meant to be a complement to your existing code and not an
  intrusion on your code base. Unlike many other B<Class::> modules,
  this module B<does not> require you subclass it, or even that you
  C<use> it in within your module's package.
  
  The only features which require additions to your code are the
  attribute handling and instance construction features, and these are
  both completely optional features. The only reason for this is because
  Perl 5's object system does not actually have these features built
  in. More information about this feature can be found below.
  
  =head2 About Performance
  
  It is a common misconception that explicit MOPs are a performance hit.
  This is not a universal truth, it is a side-effect of some specific
  implementations. For instance, using Java reflection is slow because
  the JVM cannot take advantage of any compiler optimizations, and the
  JVM has to deal with much more runtime type information as well.
  
  Reflection in C# is marginally better as it was designed into the
  language and runtime (the CLR). In contrast, CLOS (the Common Lisp
  Object System) was built to support an explicit MOP, and so
  performance is tuned for it.
  
  This library in particular does its absolute best to avoid putting
  B<any> drain at all upon your code's performance. In fact, by itself
  it does nothing to affect your existing code. So you only pay for what
  you actually use.
  
  =head2 About Metaclass compatibility
  
  This module makes sure that all metaclasses created are both upwards
  and downwards compatible. The topic of metaclass compatibility is
  highly esoteric and is something only encountered when doing deep and
  involved metaclass hacking. There are two basic kinds of metaclass
  incompatibility; upwards and downwards.
  
  Upwards metaclass compatibility means that the metaclass of a
  given class is either the same as (or a subclass of) all of the
  metaclasses of the class's ancestors.
  
  Downward metaclass compatibility means that the metaclasses of a
  given class's ancestors are all the same as (or a subclass of) that
  class's metaclass.
  
  Here is a diagram showing a set of two classes (C<A> and C<B>) and
  two metaclasses (C<Meta::A> and C<Meta::B>) which have correct
  metaclass compatibility both upwards and downwards.
  
      +---------+     +---------+
      | Meta::A |<----| Meta::B |      <....... (instance of  )
      +---------+     +---------+      <------- (inherits from)
           ^               ^
           :               :
      +---------+     +---------+
      |    A    |<----|    B    |
      +---------+     +---------+
  
  In actuality, I<all> of a class's metaclasses must be compatible,
  not just the class metaclass. That includes the instance, attribute,
  and method metaclasses, as well as the constructor and destructor
  classes.
  
  C<Class::MOP> will attempt to fix some simple types of
  incompatibilities. If all the metaclasses for the parent class are
  I<subclasses> of the child's metaclasses then we can simply replace
  the child's metaclasses with the parent's. In addition, if the child
  is missing a metaclass that the parent has, we can also just make the
  child use the parent's metaclass.
  
  As I said this is a highly esoteric topic and one you will only run
  into if you do a lot of subclassing of L<Class::MOP::Class>. If you
  are interested in why this is an issue see the paper I<Uniform and
  safe metaclass composition> linked to in the L<SEE ALSO> section of
  this document.
  
  =head2 Using custom metaclasses
  
  Always use the L<metaclass> pragma when using a custom metaclass, this
  will ensure the proper initialization order and not accidentally
  create an incorrect type of metaclass for you. This is a very rare
  problem, and one which can only occur if you are doing deep metaclass
  programming. So in other words, don't worry about it.
  
  Note that if you're using L<Moose> we encourage you to I<not> use the
  L<metaclass> pragma, and instead use L<Moose::Util::MetaRole> to apply
  roles to a class's metaclasses. This topic is covered at length in
  various L<Moose::Cookbook> recipes.
  
  =head1 PROTOCOLS
  
  The meta-object protocol is divided into 4 main sub-protocols:
  
  =head2 The Class protocol
  
  This provides a means of manipulating and introspecting a Perl 5
  class. It handles symbol table hacking for you, and provides a rich
  set of methods that go beyond simple package introspection.
  
  See L<Class::MOP::Class> for more details.
  
  =head2 The Attribute protocol
  
  This provides a consistent representation for an attribute of a Perl 5
  class. Since there are so many ways to create and handle attributes in
  Perl 5 OO, the Attribute protocol provide as much of a unified
  approach as possible. Of course, you are always free to extend this
  protocol by subclassing the appropriate classes.
  
  See L<Class::MOP::Attribute> for more details.
  
  =head2 The Method protocol
  
  This provides a means of manipulating and introspecting methods in the
  Perl 5 object system. As with attributes, there are many ways to
  approach this topic, so we try to keep it pretty basic, while still
  making it possible to extend the system in many ways.
  
  See L<Class::MOP::Method> for more details.
  
  =head2 The Instance protocol
  
  This provides a layer of abstraction for creating object instances.
  Since the other layers use this protocol, it is relatively easy to
  change the type of your instances from the default hash reference to
  some other type of reference. Several examples are provided in the
  F<examples/> directory included in this distribution.
  
  See L<Class::MOP::Instance> for more details.
  
  =head1 FUNCTIONS
  
  Note that this module does not export any constants or functions.
  
  =head2 Utility functions
  
  Note that these are all called as B<functions, not methods>.
  
  =over 4
  
  =item B<Class::MOP::get_code_info($code)>
  
  This function returns two values, the name of the package the C<$code>
  is from and the name of the C<$code> itself. This is used by several
  elements of the MOP to determine where a given C<$code> reference is
  from.
  
  =item B<Class::MOP::class_of($instance_or_class_name)>
  
  This will return the metaclass of the given instance or class name.  If the
  class lacks a metaclass, no metaclass will be initialized, and C<undef> will be
  returned.
  
  You should almost certainly be using
  L<C<Moose::Util::find_meta>|Moose::Util/find_meta> instead.
  
  =back
  
  =head2 Metaclass cache functions
  
  C<Class::MOP> holds a cache of metaclasses. The following are functions
  (B<not methods>) which can be used to access that cache. It is not
  recommended that you mess with these. Bad things could happen, but if
  you are brave and willing to risk it: go for it!
  
  =over 4
  
  =item B<Class::MOP::get_all_metaclasses>
  
  This will return a hash of all the metaclass instances that have
  been cached by L<Class::MOP::Class>, keyed by the package name.
  
  =item B<Class::MOP::get_all_metaclass_instances>
  
  This will return a list of all the metaclass instances that have
  been cached by L<Class::MOP::Class>.
  
  =item B<Class::MOP::get_all_metaclass_names>
  
  This will return a list of all the metaclass names that have
  been cached by L<Class::MOP::Class>.
  
  =item B<Class::MOP::get_metaclass_by_name($name)>
  
  This will return a cached L<Class::MOP::Class> instance, or nothing
  if no metaclass exists with that C<$name>.
  
  =item B<Class::MOP::store_metaclass_by_name($name, $meta)>
  
  This will store a metaclass in the cache at the supplied C<$key>.
  
  =item B<Class::MOP::weaken_metaclass($name)>
  
  In rare cases (e.g. anonymous metaclasses) it is desirable to
  store a weakened reference in the metaclass cache. This
  function will weaken the reference to the metaclass stored
  in C<$name>.
  
  =item B<Class::MOP::metaclass_is_weak($name)>
  
  Returns true if the metaclass for C<$name> has been weakened
  (via C<weaken_metaclass>).
  
  =item B<Class::MOP::does_metaclass_exist($name)>
  
  This will return true of there exists a metaclass stored in the
  C<$name> key, and return false otherwise.
  
  =item B<Class::MOP::remove_metaclass_by_name($name)>
  
  This will remove the metaclass stored in the C<$name> key.
  
  =back
  
  Some utility functions (such as C<Class::MOP::load_class>) that were
  previously defined in C<Class::MOP> regarding loading of classes have been
  extracted to L<Class::Load>. Please see L<Class::Load> for documentation.
  
  =head1 SEE ALSO
  
  =head2 Books
  
  There are very few books out on Meta Object Protocols and Metaclasses
  because it is such an esoteric topic. The following books are really
  the only ones I have found. If you know of any more, B<I<please>>
  email me and let me know, I would love to hear about them.
  
  =over 4
  
  =item I<The Art of the Meta Object Protocol>
  
  =item I<Advances in Object-Oriented Metalevel Architecture and Reflection>
  
  =item I<Putting MetaClasses to Work>
  
  =item I<Smalltalk: The Language>
  
  =back
  
  =head2 Papers
  
  =over 4
  
  =item "Uniform and safe metaclass composition"
  
  An excellent paper by the people who brought us the original Traits paper.
  This paper is on how Traits can be used to do safe metaclass composition,
  and offers an excellent introduction section which delves into the topic of
  metaclass compatibility.
  
  L<http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf>
  
  =item "Safe Metaclass Programming"
  
  This paper seems to precede the above paper, and propose a mix-in based
  approach as opposed to the Traits based approach. Both papers have similar
  information on the metaclass compatibility problem space.
  
  L<http://citeseer.ist.psu.edu/37617.html>
  
  =back
  
  =head2 Prior Art
  
  =over 4
  
  =item The Perl 6 MetaModel work in the Pugs project
  
  =over 4
  
  =item L<http://svn.openfoundry.org/pugs/misc/Perl-MetaModel/>
  
  =item L<http://github.com/perl6/p5-modules/tree/master/Perl6-ObjectSpace/>
  
  =back
  
  =back
  
  =head2 Articles
  
  =over 4
  
  =item CPAN Module Review of Class::MOP
  
  L<http://www.oreillynet.com/onlamp/blog/2006/06/cpan_module_review_classmop.html>
  
  =back
  
  =head1 SIMILAR MODULES
  
  As I have said above, this module is a class-builder-builder, so it is
  not the same thing as modules like L<Class::Accessor> and
  L<Class::MethodMaker>. That being said there are very few modules on CPAN
  with similar goals to this module. The one I have found which is most
  like this module is L<Class::Meta>, although its philosophy and the MOP it
  creates are very different from this modules.
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception.
  
  Please report any bugs to C<bug-class-mop@rt.cpan.org>, or through the
  web interface at L<http://rt.cpan.org>.
  
  You can also discuss feature requests or possible bugs on the Moose
  mailing list (moose@perl.org) or on IRC at
  L<irc://irc.perl.org/#moose>.
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item Rob Kinyon
  
  Thanks to Rob for actually getting the development of this module kick-started.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_ATTRIBUTE';
  
  package Class::MOP::Attribute;
  BEGIN {
    $Class::MOP::Attribute::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Attribute::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP::Method::Accessor;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Object', 'Class::MOP::Mixin::AttributeCore';
  
  use Moose::Util 'throw_exception';
  
  # NOTE: (meta-circularity)
  # This method will be replaced in the
  # boostrap section of Class::MOP, by
  # a new version which uses the
  # &Class::MOP::Class::construct_instance
  # method to build an attribute meta-object
  # which itself is described with attribute
  # meta-objects.
  #     - Ain't meta-circularity grand? :)
  sub new {
      my ( $class, @args ) = @_;
  
      unshift @args, "name" if @args % 2 == 1;
      my %options = @args;
  
      my $name = $options{name};
  
      (defined $name)
          || throw_exception( MOPAttributeNewNeedsAttributeName => class  => $class,
                                                                   params => \%options
                            );
  
      $options{init_arg} = $name
          if not exists $options{init_arg};
      if(exists $options{builder}){
          throw_exception( BuilderMustBeAMethodName => class  => $class,
                                                       params => \%options
                         )
              if ref $options{builder} || !(defined $options{builder});
          throw_exception( BothBuilderAndDefaultAreNotAllowed => class  => $class,
                                                                 params => \%options
                         )
              if exists $options{default};
      } else {
          ($class->is_default_a_coderef(\%options))
              || throw_exception( ReferencesAreNotAllowedAsDefault => class          => $class,
                                                                      params         => \%options,
                                                                      attribute_name => $options{name}
                                )
                  if exists $options{default} && ref $options{default};
      }
  
      if( $options{required} and not( defined($options{builder}) || defined($options{init_arg}) || exists $options{default} ) ) {
          throw_exception( RequiredAttributeLacksInitialization => class  => $class,
                                                                   params => \%options
                         );
      }
  
      $class->_new(\%options);
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $options = @_ == 1 ? $_[0] : {@_};
  
      bless {
          'name'               => $options->{name},
          'accessor'           => $options->{accessor},
          'reader'             => $options->{reader},
          'writer'             => $options->{writer},
          'predicate'          => $options->{predicate},
          'clearer'            => $options->{clearer},
          'builder'            => $options->{builder},
          'init_arg'           => $options->{init_arg},
          exists $options->{default}
              ? ('default'     => $options->{default})
              : (),
          'initializer'        => $options->{initializer},
          'definition_context' => $options->{definition_context},
          # keep a weakened link to the
          # class we are associated with
          'associated_class' => undef,
          # and a list of the methods
          # associated with this attr
          'associated_methods' => [],
          # this let's us keep track of
          # our order inside the associated
          # class
          'insertion_order'    => undef,
      }, $class;
  }
  
  # NOTE:
  # this is a primitive (and kludgy) clone operation
  # for now, it will be replaced in the Class::MOP
  # bootstrap with a proper one, however we know
  # that this one will work fine for now.
  sub clone {
      my $self    = shift;
      my %options = @_;
      (blessed($self))
          || confess "Can only clone an instance";
      # this implementation is overwritten by the bootstrap process,
      # so this exception will never trigger. If it ever does occur,
      # it indicates a gigantic problem with the most internal parts
      # of Moose, so we wouldn't want a Moose-based exception object anyway
  
      return bless { %{$self}, %options } => ref($self);
  }
  
  sub initialize_instance_slot {
      my ($self, $meta_instance, $instance, $params) = @_;
      my $init_arg = $self->{'init_arg'};
  
      # try to fetch the init arg from the %params ...
  
      # if nothing was in the %params, we can use the
      # attribute's default value (if it has one)
      if(defined $init_arg and exists $params->{$init_arg}){
          $self->_set_initial_slot_value(
              $meta_instance,
              $instance,
              $params->{$init_arg},
          );
      }
      elsif (exists $self->{'default'}) {
          $self->_set_initial_slot_value(
              $meta_instance,
              $instance,
              $self->default($instance),
          );
      }
      elsif (defined( my $builder = $self->{'builder'})) {
          if ($builder = $instance->can($builder)) {
              $self->_set_initial_slot_value(
                  $meta_instance,
                  $instance,
                  $instance->$builder,
              );
          }
          else {
              throw_exception( BuilderMethodNotSupportedForAttribute => attribute => $self,
                                                                        instance  => $instance
                             );
          }
      }
  }
  
  sub _set_initial_slot_value {
      my ($self, $meta_instance, $instance, $value) = @_;
  
      my $slot_name = $self->name;
  
      return $meta_instance->set_slot_value($instance, $slot_name, $value)
          unless $self->has_initializer;
  
      my $callback = $self->_make_initializer_writer_callback(
          $meta_instance, $instance, $slot_name
      );
  
      my $initializer = $self->initializer;
  
      # most things will just want to set a value, so make it first arg
      $instance->$initializer($value, $callback, $self);
  }
  
  sub _make_initializer_writer_callback {
      my $self = shift;
      my ($meta_instance, $instance, $slot_name) = @_;
  
      return sub {
          $meta_instance->set_slot_value($instance, $slot_name, $_[0]);
      };
  }
  
  sub get_read_method  {
      my $self   = shift;
      my $reader = $self->reader || $self->accessor;
      # normal case ...
      return $reader unless ref $reader;
      # the HASH ref case
      my ($name) = %$reader;
      return $name;
  }
  
  sub get_write_method {
      my $self   = shift;
      my $writer = $self->writer || $self->accessor;
      # normal case ...
      return $writer unless ref $writer;
      # the HASH ref case
      my ($name) = %$writer;
      return $name;
  }
  
  sub get_read_method_ref {
      my $self = shift;
      if ((my $reader = $self->get_read_method) && $self->associated_class) {
          return $self->associated_class->get_method($reader);
      }
      else {
          my $code = sub { $self->get_value(@_) };
          if (my $class = $self->associated_class) {
              return $class->method_metaclass->wrap(
                  $code,
                  package_name => $class->name,
                  name         => '__ANON__'
              );
          }
          else {
              return $code;
          }
      }
  }
  
  sub get_write_method_ref {
      my $self = shift;
      if ((my $writer = $self->get_write_method) && $self->associated_class) {
          return $self->associated_class->get_method($writer);
      }
      else {
          my $code = sub { $self->set_value(@_) };
          if (my $class = $self->associated_class) {
              return $class->method_metaclass->wrap(
                  $code,
                  package_name => $class->name,
                  name         => '__ANON__'
              );
          }
          else {
              return $code;
          }
      }
  }
  
  # slots
  
  sub slots { (shift)->name }
  
  # class association
  
  sub attach_to_class {
      my ($self, $class) = @_;
      (blessed($class) && $class->isa('Class::MOP::Class'))
          || throw_exception( AttachToClassNeedsAClassMOPClassInstanceOrASubclass => attribute => $self,
                                                                                     class     => $class
                            );
      weaken($self->{'associated_class'} = $class);
  }
  
  sub detach_from_class {
      my $self = shift;
      $self->{'associated_class'} = undef;
  }
  
  # method association
  
  sub associate_method {
      my ($self, $method) = @_;
      push @{$self->{'associated_methods'}} => $method;
  }
  
  ## Slot management
  
  sub set_initial_value {
      my ($self, $instance, $value) = @_;
      $self->_set_initial_slot_value(
          Class::MOP::Class->initialize(ref($instance))->get_meta_instance,
          $instance,
          $value
      );
  }
  
  sub set_value { shift->set_raw_value(@_) }
  
  sub set_raw_value {
      my $self = shift;
      my ($instance, $value) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->set_slot_value($instance, $self->name, $value);
  }
  
  sub _inline_set_value {
      my $self = shift;
      return $self->_inline_instance_set(@_) . ';';
  }
  
  sub _inline_instance_set {
      my $self = shift;
      my ($instance, $value) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_set_slot_value($instance, $self->name, $value);
  }
  
  sub get_value { shift->get_raw_value(@_) }
  
  sub get_raw_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->get_slot_value($instance, $self->name);
  }
  
  sub _inline_get_value {
      my $self = shift;
      return $self->_inline_instance_get(@_) . ';';
  }
  
  sub _inline_instance_get {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_get_slot_value($instance, $self->name);
  }
  
  sub has_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->is_slot_initialized($instance, $self->name);
  }
  
  sub _inline_has_value {
      my $self = shift;
      return $self->_inline_instance_has(@_) . ';';
  }
  
  sub _inline_instance_has {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_is_slot_initialized($instance, $self->name);
  }
  
  sub clear_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->deinitialize_slot($instance, $self->name);
  }
  
  sub _inline_clear_value {
      my $self = shift;
      return $self->_inline_instance_clear(@_) . ';';
  }
  
  sub _inline_instance_clear {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_deinitialize_slot($instance, $self->name);
  }
  
  ## load em up ...
  
  sub accessor_metaclass { 'Class::MOP::Method::Accessor' }
  
  sub _process_accessors {
      my ($self, $type, $accessor, $generate_as_inline_methods) = @_;
  
      my $method_ctx = { %{ $self->definition_context || {} } };
  
      if (ref($accessor)) {
          (ref($accessor) eq 'HASH')
              || throw_exception( BadOptionFormat => attribute    => $self,
                                                     option_value => $accessor,
                                                     option_name  => $type
                                );
  
          my ($name, $method) = %{$accessor};
  
          $method_ctx->{description} = $self->_accessor_description($name, $type);
  
          $method = $self->accessor_metaclass->wrap(
              $method,
              attribute    => $self,
              package_name => $self->associated_class->name,
              name         => $name,
              associated_metaclass => $self->associated_class,
              definition_context => $method_ctx,
          );
          $self->associate_method($method);
          return ($name, $method);
      }
      else {
          my $inline_me = ($generate_as_inline_methods && $self->associated_class->instance_metaclass->is_inlinable);
          my $method;
          try {
              $method_ctx->{description} = $self->_accessor_description($accessor, $type);
  
              $method = $self->accessor_metaclass->new(
                  attribute     => $self,
                  is_inline     => $inline_me,
                  accessor_type => $type,
                  package_name  => $self->associated_class->name,
                  name          => $accessor,
                  associated_metaclass => $self->associated_class,
                  definition_context => $method_ctx,
              );
          }
          catch {
              throw_exception( CouldNotCreateMethod => attribute    => $self,
                                                       option_value => $accessor,
                                                       option_name  => $type,
                                                       error        => $_
                             );
          };
          $self->associate_method($method);
          return ($accessor, $method);
      }
  }
  
  sub _accessor_description {
      my $self = shift;
      my ($name, $type) = @_;
  
      my $desc = "$type " . $self->associated_class->name . "::$name";
      if ( $name ne $self->name ) {
          $desc .= " of attribute " . $self->name;
      }
  
      return $desc;
  }
  
  sub install_accessors {
      my $self   = shift;
      my $inline = shift;
      my $class  = $self->associated_class;
  
      $class->add_method(
          $self->_process_accessors('accessor' => $self->accessor(), $inline)
      ) if $self->has_accessor();
  
      $class->add_method(
          $self->_process_accessors('reader' => $self->reader(), $inline)
      ) if $self->has_reader();
  
      $class->add_method(
          $self->_process_accessors('writer' => $self->writer(), $inline)
      ) if $self->has_writer();
  
      $class->add_method(
          $self->_process_accessors('predicate' => $self->predicate(), $inline)
      ) if $self->has_predicate();
  
      $class->add_method(
          $self->_process_accessors('clearer' => $self->clearer(), $inline)
      ) if $self->has_clearer();
  
      return;
  }
  
  {
      my $_remove_accessor = sub {
          my ($accessor, $class) = @_;
          if (ref($accessor) && ref($accessor) eq 'HASH') {
              ($accessor) = keys %{$accessor};
          }
          my $method = $class->get_method($accessor);
          $class->remove_method($accessor)
              if (ref($method) && $method->isa('Class::MOP::Method::Accessor'));
      };
  
      sub remove_accessors {
          my $self = shift;
          # TODO:
          # we really need to make sure to remove from the
          # associates methods here as well. But this is
          # such a slimly used method, I am not worried
          # about it right now.
          $_remove_accessor->($self->accessor(),  $self->associated_class()) if $self->has_accessor();
          $_remove_accessor->($self->reader(),    $self->associated_class()) if $self->has_reader();
          $_remove_accessor->($self->writer(),    $self->associated_class()) if $self->has_writer();
          $_remove_accessor->($self->predicate(), $self->associated_class()) if $self->has_predicate();
          $_remove_accessor->($self->clearer(),   $self->associated_class()) if $self->has_clearer();
          return;
      }
  
  }
  
  1;
  
  # ABSTRACT: Attribute Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Attribute - Attribute Meta Object
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    Class::MOP::Attribute->new(
        foo => (
            accessor  => 'foo',           # dual purpose get/set accessor
            predicate => 'has_foo',       # predicate check for defined-ness
            init_arg  => '-foo',          # class->new will look for a -foo key
            default   => 'BAR IS BAZ!'    # if no -foo key is provided, use this
        )
    );
  
    Class::MOP::Attribute->new(
        bar => (
            reader    => 'bar',           # getter
            writer    => 'set_bar',       # setter
            predicate => 'has_bar',       # predicate check for defined-ness
            init_arg  => ':bar',          # class->new will look for a :bar key
                                          # no default value means it is undef
        )
    );
  
  =head1 DESCRIPTION
  
  The Attribute Protocol is almost entirely an invention of
  C<Class::MOP>. Perl 5 does not have a consistent notion of
  attributes. There are so many ways in which this is done, and very few
  (if any) are easily discoverable by this module.
  
  With that said, this module attempts to inject some order into this
  chaos, by introducing a consistent API which can be used to create
  object attributes.
  
  =head1 METHODS
  
  =head2 Creation
  
  =over 4
  
  =item B<< Class::MOP::Attribute->new($name, ?%options) >>
  
  An attribute must (at the very least), have a C<$name>. All other
  C<%options> are added as key-value pairs.
  
  =over 8
  
  =item * init_arg
  
  This is a string value representing the expected key in an
  initialization hash. For instance, if we have an C<init_arg> value of
  C<-foo>, then the following code will Just Work.
  
    MyClass->meta->new_object( -foo => 'Hello There' );
  
  If an init_arg is not assigned, it will automatically use the
  attribute's name. If C<init_arg> is explicitly set to C<undef>, the
  attribute cannot be specified during initialization.
  
  =item * builder
  
  This provides the name of a method that will be called to initialize
  the attribute. This method will be called on the object after it is
  constructed. It is expected to return a valid value for the attribute.
  
  =item * default
  
  This can be used to provide an explicit default for initializing the
  attribute. If the default you provide is a subroutine reference, then
  this reference will be called I<as a method> on the object.
  
  If the value is a simple scalar (string or number), then it can be
  just passed as is. However, if you wish to initialize it with a HASH
  or ARRAY ref, then you need to wrap that inside a subroutine
  reference:
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub { [] },
        )
    );
  
    # or ...
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub { {} },
        )
    );
  
  If you wish to initialize an attribute with a subroutine reference
  itself, then you need to wrap that in a subroutine as well:
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub {
                sub { print "Hello World" }
            },
        )
    );
  
  And lastly, if the value of your attribute is dependent upon some
  other aspect of the instance structure, then you can take advantage of
  the fact that when the C<default> value is called as a method:
  
    Class::MOP::Attribute->new(
        'object_identity' => (
            default => sub { Scalar::Util::refaddr( $_[0] ) },
        )
    );
  
  Note that there is no guarantee that attributes are initialized in any
  particular order, so you cannot rely on the value of some other
  attribute when generating the default.
  
  =item * initializer
  
  This option can be either a method name or a subroutine
  reference. This method will be called when setting the attribute's
  value in the constructor. Unlike C<default> and C<builder>, the
  initializer is only called when a value is provided to the
  constructor. The initializer allows you to munge this value during
  object construction.
  
  The initializer is called as a method with three arguments. The first
  is the value that was passed to the constructor. The second is a
  subroutine reference that can be called to actually set the
  attribute's value, and the last is the associated
  C<Class::MOP::Attribute> object.
  
  This contrived example shows an initializer that sets the attribute to
  twice the given value.
  
    Class::MOP::Attribute->new(
        'doubled' => (
            initializer => sub {
                my ( $self, $value, $set, $attr ) = @_;
                $set->( $value * 2 );
            },
        )
    );
  
  Since an initializer can be a method name, you can easily make
  attribute initialization use the writer:
  
    Class::MOP::Attribute->new(
        'some_attr' => (
            writer      => 'some_attr',
            initializer => 'some_attr',
        )
    );
  
  Your writer (actually, a wrapper around the writer, using
  L<method modifications|Moose::Manual::MethodModifiers>) will need to examine
  C<@_> and determine under which
  context it is being called:
  
    around 'some_attr' => sub {
        my $orig = shift;
        my $self = shift;
        # $value is not defined if being called as a reader
        # $setter and $attr are only defined if being called as an initializer
        my ($value, $setter, $attr) = @_;
  
        # the reader behaves normally
        return $self->$orig if not @_;
  
        # mutate $value as desired
        # $value = <something($value);
  
        # if called as an initializer, set the value and we're done
        return $setter->($row) if $setter;
  
        # otherwise, call the real writer with the new value
        $self->$orig($row);
    };
  
  =back
  
  The C<accessor>, C<reader>, C<writer>, C<predicate> and C<clearer>
  options all accept the same parameters. You can provide the name of
  the method, in which case an appropriate default method will be
  generated for you. Or instead you can also provide hash reference
  containing exactly one key (the method name) and one value. The value
  should be a subroutine reference, which will be installed as the
  method itself.
  
  =over 8
  
  =item * accessor
  
  An C<accessor> is a standard Perl-style read/write accessor. It will
  return the value of the attribute, and if a value is passed as an
  argument, it will assign that value to the attribute.
  
  Note that C<undef> is a legitimate value, so this will work:
  
    $object->set_something(undef);
  
  =item * reader
  
  This is a basic read-only accessor. It returns the value of the
  attribute.
  
  =item * writer
  
  This is a basic write accessor, it accepts a single argument, and
  assigns that value to the attribute.
  
  Note that C<undef> is a legitimate value, so this will work:
  
    $object->set_something(undef);
  
  =item * predicate
  
  The predicate method returns a boolean indicating whether or not the
  attribute has been explicitly set.
  
  Note that the predicate returns true even if the attribute was set to
  a false value (C<0> or C<undef>).
  
  =item * clearer
  
  This method will uninitialize the attribute. After an attribute is
  cleared, its C<predicate> will return false.
  
  =item * definition_context
  
  Mostly, this exists as a hook for the benefit of Moose.
  
  This option should be a hash reference containing several keys which
  will be used when inlining the attribute's accessors. The keys should
  include C<line>, the line number where the attribute was created, and
  either C<file> or C<description>.
  
  This information will ultimately be used when eval'ing inlined
  accessor code so that error messages report a useful line and file
  name.
  
  =back
  
  =item B<< $attr->clone(%options) >>
  
  This clones the attribute. Any options you provide will override the
  settings of the original attribute. You can change the name of the new
  attribute by passing a C<name> key in C<%options>.
  
  =back
  
  =head2 Informational
  
  These are all basic read-only accessors for the values passed into
  the constructor.
  
  =over 4
  
  =item B<< $attr->name >>
  
  Returns the attribute's name.
  
  =item B<< $attr->accessor >>
  
  =item B<< $attr->reader >>
  
  =item B<< $attr->writer >>
  
  =item B<< $attr->predicate >>
  
  =item B<< $attr->clearer >>
  
  The C<accessor>, C<reader>, C<writer>, C<predicate>, and C<clearer>
  methods all return exactly what was passed to the constructor, so it
  can be either a string containing a method name, or a hash reference.
  
  =item B<< $attr->initializer >>
  
  Returns the initializer as passed to the constructor, so this may be
  either a method name or a subroutine reference.
  
  =item B<< $attr->init_arg >>
  
  =item B<< $attr->is_default_a_coderef >>
  
  =item B<< $attr->builder >>
  
  =item B<< $attr->default($instance) >>
  
  The C<$instance> argument is optional. If you don't pass it, the
  return value for this method is exactly what was passed to the
  constructor, either a simple scalar or a subroutine reference.
  
  If you I<do> pass an C<$instance> and the default is a subroutine
  reference, then the reference is called as a method on the
  C<$instance> and the generated value is returned.
  
  =item B<< $attr->slots >>
  
  Return a list of slots required by the attribute. This is usually just
  one, the name of the attribute.
  
  A slot is the name of the hash key used to store the attribute in an
  object instance.
  
  =item B<< $attr->get_read_method >>
  
  =item B<< $attr->get_write_method >>
  
  Returns the name of a method suitable for reading or writing the value
  of the attribute in the associated class.
  
  If an attribute is read- or write-only, then these methods can return
  C<undef> as appropriate.
  
  =item B<< $attr->has_read_method >>
  
  =item B<< $attr->has_write_method >>
  
  This returns a boolean indicating whether the attribute has a I<named>
  read or write method.
  
  =item B<< $attr->get_read_method_ref >>
  
  =item B<< $attr->get_write_method_ref >>
  
  Returns the subroutine reference of a method suitable for reading or
  writing the attribute's value in the associated class. These methods
  always return a subroutine reference, regardless of whether or not the
  attribute is read- or write-only.
  
  =item B<< $attr->insertion_order >>
  
  If this attribute has been inserted into a class, this returns a zero
  based index regarding the order of insertion.
  
  =back
  
  =head2 Informational predicates
  
  These are all basic predicate methods for the values passed into C<new>.
  
  =over 4
  
  =item B<< $attr->has_accessor >>
  
  =item B<< $attr->has_reader >>
  
  =item B<< $attr->has_writer >>
  
  =item B<< $attr->has_predicate >>
  
  =item B<< $attr->has_clearer >>
  
  =item B<< $attr->has_initializer >>
  
  =item B<< $attr->has_init_arg >>
  
  This will be I<false> if the C<init_arg> was set to C<undef>.
  
  =item B<< $attr->has_default >>
  
  This will be I<false> if the C<default> was set to C<undef>, since
  C<undef> is the default C<default> anyway.
  
  =item B<< $attr->has_builder >>
  
  =item B<< $attr->has_insertion_order >>
  
  This will be I<false> if this attribute has not be inserted into a class
  
  =back
  
  =head2 Value management
  
  These methods are basically "back doors" to the instance, and can be
  used to bypass the regular accessors, but still stay within the MOP.
  
  These methods are not for general use, and should only be used if you
  really know what you are doing.
  
  =over 4
  
  =item B<< $attr->initialize_instance_slot($meta_instance, $instance, $params) >>
  
  This method is used internally to initialize the attribute's slot in
  the object C<$instance>.
  
  The C<$params> is a hash reference of the values passed to the object
  constructor.
  
  It's unlikely that you'll need to call this method yourself.
  
  =item B<< $attr->set_value($instance, $value) >>
  
  Sets the value without going through the accessor. Note that this
  works even with read-only attributes.
  
  =item B<< $attr->set_raw_value($instance, $value) >>
  
  Sets the value with no side effects such as a trigger.
  
  This doesn't actually apply to Class::MOP attributes, only to subclasses.
  
  =item B<< $attr->set_initial_value($instance, $value) >>
  
  Sets the value without going through the accessor. This method is only
  called when the instance is first being initialized.
  
  =item B<< $attr->get_value($instance) >>
  
  Returns the value without going through the accessor. Note that this
  works even with write-only accessors.
  
  =item B<< $attr->get_raw_value($instance) >>
  
  Returns the value without any side effects such as lazy attributes.
  
  Doesn't actually apply to Class::MOP attributes, only to subclasses.
  
  =item B<< $attr->has_value($instance) >>
  
  Return a boolean indicating whether the attribute has been set in
  C<$instance>. This how the default C<predicate> method works.
  
  =item B<< $attr->clear_value($instance) >>
  
  This will clear the attribute's value in C<$instance>. This is what
  the default C<clearer> calls.
  
  Note that this works even if the attribute does not have any
  associated read, write or clear methods.
  
  =back
  
  =head2 Class association
  
  These methods allow you to manage the attributes association with
  the class that contains it. These methods should not be used
  lightly, nor are they very magical, they are mostly used internally
  and by metaclass instances.
  
  =over 4
  
  =item B<< $attr->associated_class >>
  
  This returns the L<Class::MOP::Class> with which this attribute is
  associated, if any.
  
  =item B<< $attr->attach_to_class($metaclass) >>
  
  This method stores a weakened reference to the C<$metaclass> object
  internally.
  
  This method does not remove the attribute from its old class,
  nor does it create any accessors in the new class.
  
  It is probably best to use the L<Class::MOP::Class> C<add_attribute>
  method instead.
  
  =item B<< $attr->detach_from_class >>
  
  This method removes the associate metaclass object from the attribute
  it has one.
  
  This method does not remove the attribute itself from the class, or
  remove its accessors.
  
  It is probably best to use the L<Class::MOP::Class>
  C<remove_attribute> method instead.
  
  =back
  
  =head2 Attribute Accessor generation
  
  =over 4
  
  =item B<< $attr->accessor_metaclass >>
  
  Accessor methods are generated using an accessor metaclass. By
  default, this is L<Class::MOP::Method::Accessor>. This method returns
  the name of the accessor metaclass that this attribute uses.
  
  =item B<< $attr->associate_method($method) >>
  
  This associates a L<Class::MOP::Method> object with the
  attribute. Typically, this is called internally when an attribute
  generates its accessors.
  
  =item B<< $attr->associated_methods >>
  
  This returns the list of methods which have been associated with the
  attribute.
  
  =item B<< $attr->install_accessors >>
  
  This method generates and installs code the attributes various
  accessors. It is typically called from the L<Class::MOP::Class>
  C<add_attribute> method.
  
  =item B<< $attr->remove_accessors >>
  
  This method removes all of the accessors associated with the
  attribute.
  
  This does not currently remove methods from the list returned by
  C<associated_methods>.
  
  =item B<< $attr->inline_get >>
  
  =item B<< $attr->inline_set >>
  
  =item B<< $attr->inline_has >>
  
  =item B<< $attr->inline_clear >>
  
  These methods return a code snippet suitable for inlining the relevant
  operation. They expect strings containing variable names to be used in the
  inlining, like C<'$self'> or C<'$_[1]'>.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Attribute->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_ATTRIBUTE

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_CLASS';
  
  package Class::MOP::Class;
  BEGIN {
    $Class::MOP::Class::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Class::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP::Instance;
  use Class::MOP::Method::Wrapped;
  use Class::MOP::Method::Accessor;
  use Class::MOP::Method::Constructor;
  use Class::MOP::MiniTrait;
  
  use Carp         'confess';
  use Module::Runtime 'use_package_optimistically';
  use Scalar::Util 'blessed', 'reftype', 'weaken';
  use Sub::Name    'subname';
  use Try::Tiny;
  use List::MoreUtils 'all';
  
  use parent 'Class::MOP::Module',
           'Class::MOP::Mixin::HasAttributes',
           'Class::MOP::Mixin::HasMethods';
  
  use Moose::Util 'throw_exception';
  
  # Creation
  
  sub initialize {
      my $class = shift;
  
      my $package_name;
  
      if ( @_ % 2 ) {
          $package_name = shift;
      } else {
          my %options = @_;
          $package_name = $options{package};
      }
  
      ($package_name && !ref($package_name))
          || throw_exception( InitializeTakesUnBlessedPackageName => package_name => $package_name );
      return Class::MOP::get_metaclass_by_name($package_name)
          || $class->_construct_class_instance(package => $package_name, @_);
  }
  
  sub reinitialize {
      my ( $class, @args ) = @_;
      unshift @args, "package" if @args % 2;
      my %options = @args;
      my $old_metaclass = blessed($options{package})
          ? $options{package}
          : Class::MOP::get_metaclass_by_name($options{package});
      $options{weaken} = Class::MOP::metaclass_is_weak($old_metaclass->name)
          if !exists $options{weaken}
          && blessed($old_metaclass)
          && $old_metaclass->isa('Class::MOP::Class');
      $old_metaclass->_remove_generated_metaobjects
          if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
      my $new_metaclass = $class->SUPER::reinitialize(%options);
      $new_metaclass->_restore_metaobjects_from($old_metaclass)
          if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
      return $new_metaclass;
  }
  
  # NOTE: (meta-circularity)
  # this is a special form of _construct_instance
  # (see below), which is used to construct class
  # meta-object instances for any Class::MOP::*
  # class. All other classes will use the more
  # normal &construct_instance.
  sub _construct_class_instance {
      my $class        = shift;
      my $options      = @_ == 1 ? $_[0] : {@_};
      my $package_name = $options->{package};
      (defined $package_name && $package_name)
          || throw_exception("ConstructClassInstanceTakesPackageName");
      # NOTE:
      # return the metaclass if we have it cached,
      # and it is still defined (it has not been
      # reaped by DESTROY yet, which can happen
      # annoyingly enough during global destruction)
  
      if (defined(my $meta = Class::MOP::get_metaclass_by_name($package_name))) {
          return $meta;
      }
  
      $class
          = ref $class
          ? $class->_real_ref_name
          : $class;
  
      # now create the metaclass
      my $meta;
      if ($class eq 'Class::MOP::Class') {
          $meta = $class->_new($options);
      }
      else {
          # NOTE:
          # it is safe to use meta here because
          # class will always be a subclass of
          # Class::MOP::Class, which defines meta
          $meta = $class->meta->_construct_instance($options)
      }
  
      # and check the metaclass compatibility
      $meta->_check_metaclass_compatibility();
  
      Class::MOP::store_metaclass_by_name($package_name, $meta);
  
      # NOTE:
      # we need to weaken any anon classes
      # so that they can call DESTROY properly
      Class::MOP::weaken_metaclass($package_name) if $options->{weaken};
  
      $meta;
  }
  
  sub _real_ref_name {
      my $self = shift;
  
      # NOTE: we need to deal with the possibility of class immutability here,
      # and then get the name of the class appropriately
      return $self->is_immutable
          ? $self->_get_mutable_metaclass_name()
          : ref $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Package
          'package' => $options->{package},
  
          # NOTE:
          # since the following attributes will
          # actually be loaded from the symbol
          # table, and actually bypass the instance
          # entirely, we can just leave these things
          # listed here for reference, because they
          # should not actually have a value associated
          # with the slot.
          'namespace' => \undef,
          'methods'   => {},
  
          # inherited from Class::MOP::Module
          'version'   => \undef,
          'authority' => \undef,
  
          # defined in Class::MOP::Class
          'superclasses' => \undef,
  
          'attributes' => {},
          'attribute_metaclass' =>
              ( $options->{'attribute_metaclass'} || 'Class::MOP::Attribute' ),
          'method_metaclass' =>
              ( $options->{'method_metaclass'} || 'Class::MOP::Method' ),
          'wrapped_method_metaclass' => (
              $options->{'wrapped_method_metaclass'}
                  || 'Class::MOP::Method::Wrapped'
          ),
          'instance_metaclass' =>
              ( $options->{'instance_metaclass'} || 'Class::MOP::Instance' ),
          'immutable_trait' => (
              $options->{'immutable_trait'}
                  || 'Class::MOP::Class::Immutable::Trait'
          ),
          'constructor_name' => ( $options->{constructor_name} || 'new' ),
          'constructor_class' => (
              $options->{constructor_class} || 'Class::MOP::Method::Constructor'
          ),
          'destructor_class' => $options->{destructor_class},
      }, $class;
  }
  
  ## Metaclass compatibility
  {
      my %base_metaclass = (
          attribute_metaclass      => 'Class::MOP::Attribute',
          method_metaclass         => 'Class::MOP::Method',
          wrapped_method_metaclass => 'Class::MOP::Method::Wrapped',
          instance_metaclass       => 'Class::MOP::Instance',
          constructor_class        => 'Class::MOP::Method::Constructor',
          destructor_class         => 'Class::MOP::Method::Destructor',
      );
  
      sub _base_metaclasses { %base_metaclass }
  }
  
  sub _check_metaclass_compatibility {
      my $self = shift;
  
      my @superclasses = $self->superclasses
          or return;
  
      $self->_fix_metaclass_incompatibility(@superclasses);
  
      my %base_metaclass = $self->_base_metaclasses;
  
      # this is always okay ...
      return
          if ref($self) eq 'Class::MOP::Class'
              && all {
                  my $meta = $self->$_;
                  !defined($meta) || $meta eq $base_metaclass{$_};
          }
          keys %base_metaclass;
  
      for my $superclass (@superclasses) {
          $self->_check_class_metaclass_compatibility($superclass);
      }
  
      for my $metaclass_type ( keys %base_metaclass ) {
          next unless defined $self->$metaclass_type;
          for my $superclass (@superclasses) {
              $self->_check_single_metaclass_compatibility( $metaclass_type,
                  $superclass );
          }
      }
  }
  
  sub _check_class_metaclass_compatibility {
      my $self = shift;
      my ( $superclass_name ) = @_;
  
      if (!$self->_class_metaclass_is_compatible($superclass_name)) {
          my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
  
          my $super_meta_type = $super_meta->_real_ref_name;
  
          throw_exception( IncompatibleMetaclassOfSuperclass => class                => $self,
                                                                superclass_name      => $superclass_name,
                                                                superclass_meta_type => $super_meta_type
                         );
      }
  }
  
  sub _class_metaclass_is_compatible {
      my $self = shift;
      my ( $superclass_name ) = @_;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
          || return 1;
  
      my $super_meta_name = $super_meta->_real_ref_name;
  
      return $self->_is_compatible_with($super_meta_name);
  }
  
  sub _check_single_metaclass_compatibility {
      my $self = shift;
      my ( $metaclass_type, $superclass_name ) = @_;
  
      if (!$self->_single_metaclass_is_compatible($metaclass_type, $superclass_name)) {
          my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
  
          throw_exception( MetaclassTypeIncompatible => class           => $self,
                                                        superclass_name => $superclass_name,
                                                        metaclass_type  => $metaclass_type
                         );
      }
  }
  
  sub _single_metaclass_is_compatible {
      my $self = shift;
      my ( $metaclass_type, $superclass_name ) = @_;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
          || return 1;
  
      # for instance, Moose::Meta::Class has a error_class attribute, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return 1 unless $super_meta->can($metaclass_type);
      # for instance, Moose::Meta::Class has a destructor_class, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return 1 unless defined $super_meta->$metaclass_type;
      # if metaclass is defined in superclass but not here, it's not compatible
      # this is a really odd case
      return 0 unless defined $self->$metaclass_type;
  
      return $self->$metaclass_type->_is_compatible_with($super_meta->$metaclass_type);
  }
  
  sub _fix_metaclass_incompatibility {
      my $self = shift;
      my @supers = map { Class::MOP::Class->initialize($_) } @_;
  
      my $necessary = 0;
      for my $super (@supers) {
          $necessary = 1
              if $self->_can_fix_metaclass_incompatibility($super);
      }
      return unless $necessary;
  
      for my $super (@supers) {
          if (!$self->_class_metaclass_is_compatible($super->name)) {
              $self->_fix_class_metaclass_incompatibility($super);
          }
      }
  
      my %base_metaclass = $self->_base_metaclasses;
      for my $metaclass_type (keys %base_metaclass) {
          for my $super (@supers) {
              if (!$self->_single_metaclass_is_compatible($metaclass_type, $super->name)) {
                  $self->_fix_single_metaclass_incompatibility(
                      $metaclass_type, $super
                  );
              }
          }
      }
  }
  
  sub _can_fix_metaclass_incompatibility {
      my $self = shift;
      my ($super_meta) = @_;
  
      return 1 if $self->_class_metaclass_can_be_made_compatible($super_meta);
  
      my %base_metaclass = $self->_base_metaclasses;
      for my $metaclass_type (keys %base_metaclass) {
          return 1 if $self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type);
      }
  
      return;
  }
  
  sub _class_metaclass_can_be_made_compatible {
      my $self = shift;
      my ($super_meta) = @_;
  
      return $self->_can_be_made_compatible_with($super_meta->_real_ref_name);
  }
  
  sub _single_metaclass_can_be_made_compatible {
      my $self = shift;
      my ($super_meta, $metaclass_type) = @_;
  
      my $specific_meta = $self->$metaclass_type;
  
      return unless $super_meta->can($metaclass_type);
      my $super_specific_meta = $super_meta->$metaclass_type;
  
      # for instance, Moose::Meta::Class has a destructor_class, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return unless defined $super_specific_meta;
  
      # if metaclass is defined in superclass but not here, it's fixable
      # this is a really odd case
      return 1 unless defined $specific_meta;
  
      return 1 if $specific_meta->_can_be_made_compatible_with($super_specific_meta);
  }
  
  sub _fix_class_metaclass_incompatibility {
      my $self = shift;
      my ( $super_meta ) = @_;
  
      if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
          ($self->is_pristine)
              || throw_exception( CannotFixMetaclassCompatibility => class      => $self,
                                                                     superclass => $super_meta
                                );
  
          my $super_meta_name = $super_meta->_real_ref_name;
  
          $self->_make_compatible_with($super_meta_name);
      }
  }
  
  sub _fix_single_metaclass_incompatibility {
      my $self = shift;
      my ( $metaclass_type, $super_meta ) = @_;
  
      if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
          ($self->is_pristine)
              || throw_exception( CannotFixMetaclassCompatibility => class          => $self,
                                                                     superclass     => $super_meta,
                                                                     metaclass_type => $metaclass_type
                                );
  
          my $new_metaclass = $self->$metaclass_type
              ? $self->$metaclass_type->_get_compatible_metaclass($super_meta->$metaclass_type)
              : $super_meta->$metaclass_type;
          $self->{$metaclass_type} = $new_metaclass;
      }
  }
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->_restore_metamethods_from($old_meta);
      $self->_restore_metaattributes_from($old_meta);
  }
  
  sub _remove_generated_metaobjects {
      my $self = shift;
  
      for my $attr (map { $self->get_attribute($_) } $self->get_attribute_list) {
          $attr->remove_accessors;
      }
  }
  
  # creating classes with MOP ...
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{superclasses} eq 'ARRAY')
          || throw_exception( CreateMOPClassTakesArrayRefOfSuperclasses => class  => $class,
                                                                           params => \%options
                            )
              if exists $options{superclasses};
  
      (ref $options{attributes} eq 'ARRAY')
          || throw_exception( CreateMOPClassTakesArrayRefOfAttributes => class  => $class,
                                                                         params => \%options
                            )
              if exists $options{attributes};
  
      (ref $options{methods} eq 'HASH')
          || throw_exception( CreateMOPClassTakesHashRefOfMethods => class  => $class,
                                                                     params => \%options
                            )
              if exists $options{methods};
  
      my $package      = delete $options{package};
      my $superclasses = delete $options{superclasses};
      my $attributes   = delete $options{attributes};
      my $methods      = delete $options{methods};
      my $meta_name    = exists $options{meta_name}
                           ? delete $options{meta_name}
                           : 'meta';
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  
      $meta->superclasses(@{$superclasses})
          if defined $superclasses;
      # NOTE:
      # process attributes first, so that they can
      # install accessors, but locally defined methods
      # can then overwrite them. It is maybe a little odd, but
      # I think this should be the order of things.
      if (defined $attributes) {
          foreach my $attr (@{$attributes}) {
              $meta->add_attribute($attr);
          }
      }
      if (defined $methods) {
          foreach my $method_name (keys %{$methods}) {
              $meta->add_method($method_name, $methods->{$method_name});
          }
      }
      return $meta;
  }
  
  # XXX: something more intelligent here?
  sub _anon_package_prefix { 'Class::MOP::Class::__ANON__::SERIAL::' }
  
  sub create_anon_class { shift->create_anon(@_) }
  sub is_anon_class     { shift->is_anon(@_)     }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
      # Makes something like Super::Class|Super::Class::2
      return join '=' => (
          join( '|', sort @{ $options{superclasses} || [] } ),
      );
  }
  
  # Instance Construction & Cloning
  
  sub new_object {
      my $class = shift;
  
      # NOTE:
      # we need to protect the integrity of the
      # Class::MOP::Class singletons here, so we
      # delegate this to &construct_class_instance
      # which will deal with the singletons
      return $class->_construct_class_instance(@_)
          if $class->name->isa('Class::MOP::Class');
      return $class->_construct_instance(@_);
  }
  
  sub _construct_instance {
      my $class = shift;
      my $params = @_ == 1 ? $_[0] : {@_};
      my $meta_instance = $class->get_meta_instance();
      # FIXME:
      # the code below is almost certainly incorrect
      # but this is foreign inheritance, so we might
      # have to kludge it in the end.
      my $instance;
      if (my $instance_class = blessed($params->{__INSTANCE__})) {
          ($instance_class eq $class->name)
              || throw_exception( InstanceBlessedIntoWrongClass => class    => $class,
                                                                   params   => $params,
                                                                   instance => $params->{__INSTANCE__}
                                );
          $instance = $params->{__INSTANCE__};
      }
      elsif (exists $params->{__INSTANCE__}) {
          throw_exception( InstanceMustBeABlessedReference => class    => $class,
                                                              params   => $params,
                                                              instance => $params->{__INSTANCE__}
                         );
      }
      else {
          $instance = $meta_instance->create_instance();
      }
      foreach my $attr ($class->get_all_attributes()) {
          $attr->initialize_instance_slot($meta_instance, $instance, $params);
      }
      if (Class::MOP::metaclass_is_weak($class->name)) {
          $meta_instance->_set_mop_slot($instance, $class);
      }
      return $instance;
  }
  
  sub _inline_new_object {
      my $self = shift;
  
      return (
          'my $class = shift;',
          '$class = Scalar::Util::blessed($class) || $class;',
          $self->_inline_fallback_constructor('$class'),
          $self->_inline_params('$params', '$class'),
          $self->_inline_generate_instance('$instance', '$class'),
          $self->_inline_slot_initializers,
          $self->_inline_preserve_weak_metaclasses,
          $self->_inline_extra_init,
          'return $instance',
      );
  }
  
  sub _inline_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return (
          'return ' . $self->_generate_fallback_constructor($class),
              'if ' . $class . ' ne \'' . $self->name . '\';',
      );
  }
  
  sub _generate_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return 'Class::MOP::Class->initialize(' . $class . ')->new_object(@_)',
  }
  
  sub _inline_params {
      my $self = shift;
      my ($params, $class) = @_;
      return (
          'my ' . $params . ' = @_ == 1 ? $_[0] : {@_};',
      );
  }
  
  sub _inline_generate_instance {
      my $self = shift;
      my ($inst, $class) = @_;
      return (
          'my ' . $inst . ' = ' . $self->_inline_create_instance($class) . ';',
      );
  }
  
  sub _inline_create_instance {
      my $self = shift;
  
      return $self->get_meta_instance->inline_create_instance(@_);
  }
  
  sub _inline_slot_initializers {
      my $self = shift;
  
      my $idx = 0;
  
      return map { $self->_inline_slot_initializer($_, $idx++) }
                 sort { $a->name cmp $b->name } $self->get_all_attributes;
  }
  
  sub _inline_slot_initializer {
      my $self  = shift;
      my ($attr, $idx) = @_;
  
      if (defined(my $init_arg = $attr->init_arg)) {
          my @source = (
              'if (exists $params->{\'' . $init_arg . '\'}) {',
                  $self->_inline_init_attr_from_constructor($attr, $idx),
              '}',
          );
          if (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
              push @source, (
                  'else {',
                      @default,
                  '}',
              );
          }
          return @source;
      }
      elsif (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
          return (
              '{',
                  @default,
              '}',
          );
      }
      else {
          return ();
      }
  }
  
  sub _inline_init_attr_from_constructor {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my @initial_value = $attr->_inline_set_value(
          '$instance', '$params->{\'' . $attr->init_arg . '\'}',
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_init_attr_from_default {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my $default = $self->_inline_default_value($attr, $idx);
      return unless $default;
  
      my @initial_value = $attr->_inline_set_value('$instance', $default);
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_default_value {
      my $self = shift;
      my ($attr, $index) = @_;
  
      if ($attr->has_default) {
          # NOTE:
          # default values can either be CODE refs
          # in which case we need to call them. Or
          # they can be scalars (strings/numbers)
          # in which case we can just deal with them
          # in the code we eval.
          if ($attr->is_default_a_coderef) {
              return '$defaults->[' . $index . ']->($instance)';
          }
          else {
              return '$defaults->[' . $index . ']';
          }
      }
      elsif ($attr->has_builder) {
          return '$instance->' . $attr->builder;
      }
      else {
          return;
      }
  }
  
  sub _inline_preserve_weak_metaclasses {
      my $self = shift;
      if (Class::MOP::metaclass_is_weak($self->name)) {
          return (
              $self->_inline_set_mop_slot(
                  '$instance', 'Class::MOP::class_of($class)'
              ) . ';'
          );
      }
      else {
          return ();
      }
  }
  
  sub _inline_extra_init { }
  
  sub _eval_environment {
      my $self = shift;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
  
      my $defaults = [map { $_->default } @attrs];
  
      return {
          '$defaults' => \$defaults,
      };
  }
  
  
  sub get_meta_instance {
      my $self = shift;
      $self->{'_meta_instance'} ||= $self->_create_meta_instance();
  }
  
  sub _create_meta_instance {
      my $self = shift;
  
      my $instance = $self->instance_metaclass->new(
          associated_metaclass => $self,
          attributes => [ $self->get_all_attributes() ],
      );
  
      $self->add_meta_instance_dependencies()
          if $instance->is_dependent_on_superclasses();
  
      return $instance;
  }
  
  # TODO: this is actually not being used!
  sub _inline_rebless_instance {
      my $self = shift;
  
      return $self->get_meta_instance->inline_rebless_instance_structure(@_);
  }
  
  sub _inline_get_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_get_mop_slot(@_);
  }
  
  sub _inline_set_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_set_mop_slot(@_);
  }
  
  sub _inline_clear_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_clear_mop_slot(@_);
  }
  
  sub clone_object {
      my $class    = shift;
      my $instance = shift;
      (blessed($instance) && $instance->isa($class->name))
          || throw_exception( CloneObjectExpectsAnInstanceOfMetaclass => class    => $class,
                                                                         instance => $instance
                            );
      # NOTE:
      # we need to protect the integrity of the
      # Class::MOP::Class singletons here, they
      # should not be cloned.
      return $instance if $instance->isa('Class::MOP::Class');
      $class->_clone_instance($instance, @_);
  }
  
  sub _clone_instance {
      my ($class, $instance, %params) = @_;
      (blessed($instance))
          || throw_exception( OnlyInstancesCanBeCloned => class    => $class,
                                                          instance => $instance,
                                                          params   => \%params
                            );
      my $meta_instance = $class->get_meta_instance();
      my $clone = $meta_instance->clone_instance($instance);
      foreach my $attr ($class->get_all_attributes()) {
          if ( defined( my $init_arg = $attr->init_arg ) ) {
              if (exists $params{$init_arg}) {
                  $attr->set_value($clone, $params{$init_arg});
              }
          }
      }
      return $clone;
  }
  
  sub _force_rebless_instance {
      my ($self, $instance, %params) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      $old_metaclass->rebless_instance_away($instance, $self, %params)
          if $old_metaclass;
  
      my $meta_instance = $self->get_meta_instance;
  
      if (Class::MOP::metaclass_is_weak($old_metaclass->name)) {
          $meta_instance->_clear_mop_slot($instance);
      }
  
      # rebless!
      # we use $_[1] here because of t/cmop/rebless_overload.t regressions
      # on 5.8.8
      $meta_instance->rebless_instance_structure($_[1], $self);
  
      $self->_fixup_attributes_after_rebless($instance, $old_metaclass, %params);
  
      if (Class::MOP::metaclass_is_weak($self->name)) {
          $meta_instance->_set_mop_slot($instance, $self);
      }
  }
  
  sub rebless_instance {
      my ($self, $instance, %params) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      my $old_class = $old_metaclass ? $old_metaclass->name : blessed($instance);
      $self->name->isa($old_class)
          || throw_exception( CanReblessOnlyIntoASubclass => class    => $self,
                                                             instance => $instance,
                                                             params   => \%params
                            );
  
      $self->_force_rebless_instance($_[1], %params);
  
      return $instance;
  }
  
  sub rebless_instance_back {
      my ( $self, $instance ) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
      my $old_class
          = $old_metaclass ? $old_metaclass->name : blessed($instance);
      $old_class->isa( $self->name )
          || throw_exception( CanReblessOnlyIntoASuperclass => class    => $self,
                                                               instance => $instance,
                            );
  
      $self->_force_rebless_instance($_[1]);
  
      return $instance;
  }
  
  sub rebless_instance_away {
      # this intentionally does nothing, it is just a hook
  }
  
  sub _fixup_attributes_after_rebless {
      my $self = shift;
      my ($instance, $rebless_from, %params) = @_;
      my $meta_instance = $self->get_meta_instance;
  
      for my $attr ( $rebless_from->get_all_attributes ) {
          next if $self->find_attribute_by_name( $attr->name );
          $meta_instance->deinitialize_slot( $instance, $_ ) for $attr->slots;
      }
  
      foreach my $attr ( $self->get_all_attributes ) {
          if ( $attr->has_value($instance) ) {
              if ( defined( my $init_arg = $attr->init_arg ) ) {
                  $params{$init_arg} = $attr->get_value($instance)
                      unless exists $params{$init_arg};
              }
              else {
                  $attr->set_value($instance, $attr->get_value($instance));
              }
          }
      }
  
      foreach my $attr ($self->get_all_attributes) {
          $attr->initialize_instance_slot($meta_instance, $instance, \%params);
      }
  }
  
  sub _attach_attribute {
      my ($self, $attribute) = @_;
      $attribute->attach_to_class($self);
  }
  
  sub _post_add_attribute {
      my ( $self, $attribute ) = @_;
  
      $self->invalidate_meta_instances;
  
      # invalidate package flag here
      try {
          local $SIG{__DIE__};
          $attribute->install_accessors;
      }
      catch {
          $self->remove_attribute( $attribute->name );
          die $_;
      };
  }
  
  sub remove_attribute {
      my $self = shift;
  
      my $removed_attribute = $self->SUPER::remove_attribute(@_)
          or return;
  
      $self->invalidate_meta_instances;
  
      $removed_attribute->remove_accessors;
      $removed_attribute->detach_from_class;
  
      return$removed_attribute;
  }
  
  sub find_attribute_by_name {
      my ( $self, $attr_name ) = @_;
  
      foreach my $class ( $self->linearized_isa ) {
          # fetch the meta-class ...
          my $meta = Class::MOP::Class->initialize($class);
          return $meta->get_attribute($attr_name)
              if $meta->has_attribute($attr_name);
      }
  
      return;
  }
  
  sub get_all_attributes {
      my $self = shift;
      my %attrs = map { %{ Class::MOP::Class->initialize($_)->_attribute_map } }
          reverse $self->linearized_isa;
      return values %attrs;
  }
  
  # Inheritance
  
  sub superclasses {
      my $self     = shift;
  
      my $isa = $self->get_or_add_package_symbol('@ISA');
  
      if (@_) {
          my @supers = @_;
          @{$isa} = @supers;
  
          # NOTE:
          # on 5.8 and below, we need to call
          # a method to get Perl to detect
          # a cycle in the class hierarchy
          my $class = $self->name;
          $class->isa($class);
  
          # NOTE:
          # we need to check the metaclass
          # compatibility here so that we can
          # be sure that the superclass is
          # not potentially creating an issues
          # we don't know about
  
          $self->_check_metaclass_compatibility();
          $self->_superclasses_updated();
      }
  
      return @{$isa};
  }
  
  sub _superclasses_updated {
      my $self = shift;
      $self->update_meta_instance_dependencies();
      # keep strong references to all our parents, so they don't disappear if
      # they are anon classes and don't have any direct instances
      $self->_superclass_metas(
          map { Class::MOP::class_of($_) } $self->superclasses
      );
  }
  
  sub _superclass_metas {
      my $self = shift;
      $self->{_superclass_metas} = [@_];
  }
  
  sub subclasses {
      my $self = shift;
      my $super_class = $self->name;
  
      return @{ $super_class->mro::get_isarev() };
  }
  
  sub direct_subclasses {
      my $self = shift;
      my $super_class = $self->name;
  
      return grep {
          grep {
              $_ eq $super_class
          } Class::MOP::Class->initialize($_)->superclasses
      } $self->subclasses;
  }
  
  sub linearized_isa {
      return @{ mro::get_linear_isa( (shift)->name ) };
  }
  
  sub class_precedence_list {
      my $self = shift;
      my $name = $self->name;
  
      unless (Class::MOP::IS_RUNNING_ON_5_10()) {
          # NOTE:
          # We need to check for circular inheritance here
          # if we are not on 5.10, cause 5.8 detects it late.
          # This will do nothing if all is well, and blow up
          # otherwise. Yes, it's an ugly hack, better
          # suggestions are welcome.
          # - SL
          ($name || return)->isa('This is a test for circular inheritance')
      }
  
      # if our mro is c3, we can
      # just grab the linear_isa
      if (mro::get_mro($name) eq 'c3') {
          return @{ mro::get_linear_isa($name) }
      }
      else {
          # NOTE:
          # we can't grab the linear_isa for dfs
          # since it has all the duplicates
          # already removed.
          return (
              $name,
              map {
                  Class::MOP::Class->initialize($_)->class_precedence_list()
              } $self->superclasses()
          );
      }
  }
  
  sub _method_lookup_order {
      return (shift->linearized_isa, 'UNIVERSAL');
  }
  
  ## Methods
  
  {
      my $fetch_and_prepare_method = sub {
          my ($self, $method_name) = @_;
          my $wrapped_metaclass = $self->wrapped_method_metaclass;
          # fetch it locally
          my $method = $self->get_method($method_name);
          # if we don't have local ...
          unless ($method) {
              # try to find the next method
              $method = $self->find_next_method_by_name($method_name);
              # die if it does not exist
              (defined $method)
                  || throw_exception( MethodNameNotFoundInInheritanceHierarchy => class       => $self,
                                                                                  method_name => $method_name
                                    );
              # and now make sure to wrap it
              # even if it is already wrapped
              # because we need a new sub ref
              $method = $wrapped_metaclass->wrap($method,
                  package_name => $self->name,
                  name         => $method_name,
              );
          }
          else {
              # now make sure we wrap it properly
              $method = $wrapped_metaclass->wrap($method,
                  package_name => $self->name,
                  name         => $method_name,
              ) unless $method->isa($wrapped_metaclass);
          }
          $self->add_method($method_name => $method);
          return $method;
      };
  
      sub add_before_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || throw_exception( MethodModifierNeedsMethodName => class => $self );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_before_modifier(
              subname(':before' => $method_modifier)
          );
      }
  
      sub add_after_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || throw_exception( MethodModifierNeedsMethodName => class => $self );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_after_modifier(
              subname(':after' => $method_modifier)
          );
      }
  
      sub add_around_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || throw_exception( MethodModifierNeedsMethodName => class => $self );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_around_modifier(
              subname(':around' => $method_modifier)
          );
      }
  
      # NOTE:
      # the methods above used to be named like this:
      #    ${pkg}::${method}:(before|after|around)
      # but this proved problematic when using one modifier
      # to wrap multiple methods (something which is likely
      # to happen pretty regularly IMO). So instead of naming
      # it like this, I have chosen to just name them purely
      # with their modifier names, like so:
      #    :(before|after|around)
      # The fact is that in a stack trace, it will be fairly
      # evident from the context what method they are attached
      # to, and so don't need the fully qualified name.
  }
  
  sub find_method_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || throw_exception( MethodNameNotGiven => class => $self );
      foreach my $class ($self->_method_lookup_order) {
          my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
          return $method if defined $method;
      }
      return;
  }
  
  sub get_all_methods {
      my $self = shift;
  
      my %methods;
      for my $class ( reverse $self->_method_lookup_order ) {
          my $meta = Class::MOP::Class->initialize($class);
  
          $methods{ $_->name } = $_ for $meta->_get_local_methods;
      }
  
      return values %methods;
  }
  
  sub get_all_method_names {
      my $self = shift;
      map { $_->name } $self->get_all_methods;
  }
  
  sub find_all_methods_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || throw_exception( MethodNameNotGiven => class => $self );
      my @methods;
      foreach my $class ($self->_method_lookup_order) {
          # fetch the meta-class ...
          my $meta = Class::MOP::Class->initialize($class);
          push @methods => {
              name  => $method_name,
              class => $class,
              code  => $meta->get_method($method_name)
          } if $meta->has_method($method_name);
      }
      return @methods;
  }
  
  sub find_next_method_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || throw_exception( MethodNameNotGiven => class => $self );
      my @cpl = ($self->_method_lookup_order);
      shift @cpl; # discard ourselves
      foreach my $class (@cpl) {
          my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
          return $method if defined $method;
      }
      return;
  }
  
  sub update_meta_instance_dependencies {
      my $self = shift;
  
      if ( $self->{meta_instance_dependencies} ) {
          return $self->add_meta_instance_dependencies;
      }
  }
  
  sub add_meta_instance_dependencies {
      my $self = shift;
  
      $self->remove_meta_instance_dependencies;
  
      my @attrs = $self->get_all_attributes();
  
      my %seen;
      my @classes = grep { not $seen{ $_->name }++ }
          map { $_->associated_class } @attrs;
  
      foreach my $class (@classes) {
          $class->add_dependent_meta_instance($self);
      }
  
      $self->{meta_instance_dependencies} = \@classes;
  }
  
  sub remove_meta_instance_dependencies {
      my $self = shift;
  
      if ( my $classes = delete $self->{meta_instance_dependencies} ) {
          foreach my $class (@$classes) {
              $class->remove_dependent_meta_instance($self);
          }
  
          return $classes;
      }
  
      return;
  
  }
  
  sub add_dependent_meta_instance {
      my ( $self, $metaclass ) = @_;
      push @{ $self->{dependent_meta_instances} }, $metaclass;
  }
  
  sub remove_dependent_meta_instance {
      my ( $self, $metaclass ) = @_;
      my $name = $metaclass->name;
      @$_ = grep { $_->name ne $name } @$_
          for $self->{dependent_meta_instances};
  }
  
  sub invalidate_meta_instances {
      my $self = shift;
      $_->invalidate_meta_instance()
          for $self, @{ $self->{dependent_meta_instances} };
  }
  
  sub invalidate_meta_instance {
      my $self = shift;
      undef $self->{_meta_instance};
  }
  
  # check if we can reinitialize
  sub is_pristine {
      my $self = shift;
  
      # if any local attr is defined
      return if $self->get_attribute_list;
  
      # or any non-declared methods
      for my $method ( map { $self->get_method($_) } $self->get_method_list ) {
          return if $method->isa("Class::MOP::Method::Generated");
          # FIXME do we need to enforce this too? return unless $method->isa( $self->method_metaclass );
      }
  
      return 1;
  }
  
  ## Class closing
  
  sub is_mutable   { 1 }
  sub is_immutable { 0 }
  
  sub immutable_options { %{ $_[0]{__immutable}{options} || {} } }
  
  sub _immutable_options {
      my ( $self, @args ) = @_;
  
      return (
          inline_accessors   => 1,
          inline_constructor => 1,
          inline_destructor  => 0,
          debug              => 0,
          immutable_trait    => $self->immutable_trait,
          constructor_name   => $self->constructor_name,
          constructor_class  => $self->constructor_class,
          destructor_class   => $self->destructor_class,
          @args,
      );
  }
  
  sub make_immutable {
      my ( $self, @args ) = @_;
  
      return $self unless $self->is_mutable;
  
      my ($file, $line) = (caller)[1..2];
  
      $self->_initialize_immutable(
          file => $file,
          line => $line,
          $self->_immutable_options(@args),
      );
      $self->_rebless_as_immutable(@args);
  
      return $self;
  }
  
  sub make_mutable {
      my $self = shift;
  
      if ( $self->is_immutable ) {
          my @args = $self->immutable_options;
          $self->_rebless_as_mutable();
          $self->_remove_inlined_code(@args);
          delete $self->{__immutable};
          return $self;
      }
      else {
          return;
      }
  }
  
  sub _rebless_as_immutable {
      my ( $self, @args ) = @_;
  
      $self->{__immutable}{original_class} = ref $self;
  
      bless $self => $self->_immutable_metaclass(@args);
  }
  
  sub _immutable_metaclass {
      my ( $self, %args ) = @_;
  
      if ( my $class = $args{immutable_metaclass} ) {
          return $class;
      }
  
      my $trait = $args{immutable_trait} = $self->immutable_trait
          || throw_exception( NoImmutableTraitSpecifiedForClass => class  => $self,
                                                                   params => \%args
                            );
  
      my $meta      = $self->meta;
      my $meta_attr = $meta->find_attribute_by_name("immutable_trait");
  
      my $class_name;
  
      if ( $meta_attr and $trait eq $meta_attr->default ) {
          # if the trait is the same as the default we try and pick a
          # predictable name for the immutable metaclass
          $class_name = 'Class::MOP::Class::Immutable::' . ref($self);
      }
      else {
          $class_name = join '::', 'Class::MOP::Class::Immutable::CustomTrait',
              $trait, 'ForMetaClass', ref($self);
      }
  
      return $class_name
          if Class::MOP::does_metaclass_exist($class_name);
  
      # If the metaclass is a subclass of CMOP::Class which has had
      # metaclass roles applied (via Moose), then we want to make sure
      # that we preserve that anonymous class (see Fey::ORM for an
      # example of where this matters).
      my $meta_name = $meta->_real_ref_name;
  
      my $immutable_meta = $meta_name->create(
          $class_name,
          superclasses => [ ref $self ],
      );
  
      Class::MOP::MiniTrait::apply( $immutable_meta, $trait );
  
      $immutable_meta->make_immutable(
          inline_constructor => 0,
          inline_accessors   => 0,
      );
  
      return $class_name;
  }
  
  sub _remove_inlined_code {
      my $self = shift;
  
      $self->remove_method( $_->name ) for $self->_inlined_methods;
  
      delete $self->{__immutable}{inlined_methods};
  }
  
  sub _inlined_methods { @{ $_[0]{__immutable}{inlined_methods} || [] } }
  
  sub _add_inlined_method {
      my ( $self, $method ) = @_;
  
      push @{ $self->{__immutable}{inlined_methods} ||= [] }, $method;
  }
  
  sub _initialize_immutable {
      my ( $self, %args ) = @_;
  
      $self->{__immutable}{options} = \%args;
      $self->_install_inlined_code(%args);
  }
  
  sub _install_inlined_code {
      my ( $self, %args ) = @_;
  
      # FIXME
      $self->_inline_accessors(%args)   if $args{inline_accessors};
      $self->_inline_constructor(%args) if $args{inline_constructor};
      $self->_inline_destructor(%args)  if $args{inline_destructor};
  }
  
  sub _rebless_as_mutable {
      my $self = shift;
  
      bless $self, $self->_get_mutable_metaclass_name;
  
      return $self;
  }
  
  sub _inline_accessors {
      my $self = shift;
  
      foreach my $attr_name ( $self->get_attribute_list ) {
          $self->get_attribute($attr_name)->install_accessors(1);
      }
  }
  
  sub _inline_constructor {
      my ( $self, %args ) = @_;
  
      my $name = $args{constructor_name};
      # A class may not even have a constructor, and that's okay.
      return unless defined $name;
  
      if ( $self->has_method($name) && !$args{replace_constructor} ) {
          my $class = $self->name;
          warn "Not inlining a constructor for $class since it defines"
              . " its own constructor.\n"
              . "If you are certain you don't need to inline your"
              . " constructor, specify inline_constructor => 0 in your"
              . " call to $class->meta->make_immutable\n";
          return;
      }
  
      my $constructor_class = $args{constructor_class};
  
      {
          local $@;
          use_package_optimistically($constructor_class);
      }
  
      my $constructor = $constructor_class->new(
          options      => \%args,
          metaclass    => $self,
          is_inline    => 1,
          package_name => $self->name,
          name         => $name,
          definition_context => {
              description => "constructor " . $self->name . "::" . $name,
              file        => $args{file},
              line        => $args{line},
          },
      );
  
      if ( $args{replace_constructor} or $constructor->can_be_inlined ) {
          $self->add_method( $name => $constructor );
          $self->_add_inlined_method($constructor);
      }
  }
  
  sub _inline_destructor {
      my ( $self, %args ) = @_;
  
      ( exists $args{destructor_class} && defined $args{destructor_class} )
          || throw_exception( NoDestructorClassSpecified => class  => $self,
                                                            params => \%args
                            );
  
      if ( $self->has_method('DESTROY') && ! $args{replace_destructor} ) {
          my $class = $self->name;
          warn "Not inlining a destructor for $class since it defines"
              . " its own destructor.\n";
          return;
      }
  
      my $destructor_class = $args{destructor_class};
  
      {
          local $@;
          use_package_optimistically($destructor_class);
      }
  
      return unless $destructor_class->is_needed($self);
  
      my $destructor = $destructor_class->new(
          options      => \%args,
          metaclass    => $self,
          package_name => $self->name,
          name         => 'DESTROY',
          definition_context => {
              description => "destructor " . $self->name . "::DESTROY",
              file        => $args{file},
              line        => $args{line},
          },
      );
  
      if ( $args{replace_destructor} or $destructor->can_be_inlined ) {
          $self->add_method( 'DESTROY' => $destructor );
          $self->_add_inlined_method($destructor);
      }
  }
  
  1;
  
  # ABSTRACT: Class Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Class - Class Meta Object
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    # assuming that class Foo
    # has been defined, you can
  
    # use this for introspection ...
  
    # add a method to Foo ...
    Foo->meta->add_method( 'bar' => sub {...} )
  
    # get a list of all the classes searched
    # the method dispatcher in the correct order
    Foo->meta->class_precedence_list()
  
    # remove a method from Foo
    Foo->meta->remove_method('bar');
  
    # or use this to actually create classes ...
  
    Class::MOP::Class->create(
        'Bar' => (
            version      => '0.01',
            superclasses => ['Foo'],
            attributes   => [
                Class::MOP::Attribute->new('$bar'),
                Class::MOP::Attribute->new('$baz'),
            ],
            methods => {
                calculate_bar => sub {...},
                construct_baz => sub {...}
            }
        )
    );
  
  =head1 DESCRIPTION
  
  The Class Protocol is the largest and most complex part of the
  Class::MOP meta-object protocol. It controls the introspection and
  manipulation of Perl 5 classes, and it can create them as well. The
  best way to understand what this module can do is to read the
  documentation for each of its methods.
  
  =head1 INHERITANCE
  
  C<Class::MOP::Class> is a subclass of L<Class::MOP::Module>.
  
  =head1 METHODS
  
  =head2 Class construction
  
  These methods all create new C<Class::MOP::Class> objects. These
  objects can represent existing classes or they can be used to create
  new classes from scratch.
  
  The metaclass object for a given class is a singleton. If you attempt
  to create a metaclass for the same class twice, you will just get the
  existing object.
  
  =over 4
  
  =item B<< Class::MOP::Class->create($package_name, %options) >>
  
  This method creates a new C<Class::MOP::Class> object with the given
  package name. It accepts a number of options:
  
  =over 8
  
  =item * version
  
  An optional version number for the newly created package.
  
  =item * authority
  
  An optional authority for the newly created package.
  
  =item * superclasses
  
  An optional array reference of superclass names.
  
  =item * methods
  
  An optional hash reference of methods for the class. The keys of the
  hash reference are method names and values are subroutine references.
  
  =item * attributes
  
  An optional array reference of L<Class::MOP::Attribute> objects.
  
  =item * meta_name
  
  Specifies the name to install the C<meta> method for this class under.
  If it is not passed, C<meta> is assumed, and if C<undef> is explicitly
  given, no meta method will be installed.
  
  =item * weaken
  
  If true, the metaclass that is stored in the global cache will be a
  weak reference.
  
  Classes created in this way are destroyed once the metaclass they are
  attached to goes out of scope, and will be removed from Perl's internal
  symbol table.
  
  All instances of a class with a weakened metaclass keep a special
  reference to the metaclass object, which prevents the metaclass from
  going out of scope while any instances exist.
  
  This only works if the instance is based on a hash reference, however.
  
  =back
  
  =item B<< Class::MOP::Class->create_anon_class(%options) >>
  
  This method works just like C<< Class::MOP::Class->create >> but it
  creates an "anonymous" class. In fact, the class does have a name, but
  that name is a unique name generated internally by this module.
  
  It accepts the same C<superclasses>, C<methods>, and C<attributes>
  parameters that C<create> accepts.
  
  It also accepts a C<cache> option. If this is C<true>, then the anonymous class
  will be cached based on its superclasses and roles. If an existing anonymous
  class in the cache has the same superclasses and roles, it will be reused.
  
  Anonymous classes default to C<< weaken => 1 >> if cache is C<false>, although
  this can be overridden.
  
  =item B<< Class::MOP::Class->initialize($package_name, %options) >>
  
  This method will initialize a C<Class::MOP::Class> object for the
  named package. Unlike C<create>, this method I<will not> create a new
  class.
  
  The purpose of this method is to retrieve a C<Class::MOP::Class>
  object for introspecting an existing class.
  
  If an existing C<Class::MOP::Class> object exists for the named
  package, it will be returned, and any options provided will be
  ignored!
  
  If the object does not yet exist, it will be created.
  
  The valid options that can be passed to this method are
  C<attribute_metaclass>, C<method_metaclass>,
  C<wrapped_method_metaclass>, and C<instance_metaclass>. These are all
  optional, and default to the appropriate class in the C<Class::MOP>
  distribution.
  
  =back
  
  =head2 Object instance construction and cloning
  
  These methods are all related to creating and/or cloning object
  instances.
  
  =over 4
  
  =item B<< $metaclass->clone_object($instance, %params) >>
  
  This method clones an existing object instance. Any parameters you
  provide are will override existing attribute values in the object.
  
  This is a convenience method for cloning an object instance, then
  blessing it into the appropriate package.
  
  You could implement a clone method in your class, using this method:
  
    sub clone {
        my ($self, %params) = @_;
        $self->meta->clone_object($self, %params);
    }
  
  =item B<< $metaclass->rebless_instance($instance, %params) >>
  
  This method changes the class of C<$instance> to the metaclass's class.
  
  You can only rebless an instance into a subclass of its current
  class. If you pass any additional parameters, these will be treated
  like constructor parameters and used to initialize the object's
  attributes. Any existing attributes that are already set will be
  overwritten.
  
  Before reblessing the instance, this method will call
  C<rebless_instance_away> on the instance's current metaclass. This method
  will be passed the instance, the new metaclass, and any parameters
  specified to C<rebless_instance>. By default, C<rebless_instance_away>
  does nothing; it is merely a hook.
  
  =item B<< $metaclass->rebless_instance_back($instance) >>
  
  Does the same thing as C<rebless_instance>, except that you can only
  rebless an instance into one of its superclasses. Any attributes that
  do not exist in the superclass will be deinitialized.
  
  This is a much more dangerous operation than C<rebless_instance>,
  especially when multiple inheritance is involved, so use this carefully!
  
  =item B<< $metaclass->new_object(%params) >>
  
  This method is used to create a new object of the metaclass's
  class. Any parameters you provide are used to initialize the
  instance's attributes. A special C<__INSTANCE__> key can be passed to
  provide an already generated instance, rather than having Class::MOP
  generate it for you. This is mostly useful for using Class::MOP with
  foreign classes which generate instances using their own constructors.
  
  =item B<< $metaclass->instance_metaclass >>
  
  Returns the class name of the instance metaclass. See
  L<Class::MOP::Instance> for more information on the instance
  metaclass.
  
  =item B<< $metaclass->get_meta_instance >>
  
  Returns an instance of the C<instance_metaclass> to be used in the
  construction of a new instance of the class.
  
  =back
  
  =head2 Informational predicates
  
  These are a few predicate methods for asking information about the
  class itself.
  
  =over 4
  
  =item B<< $metaclass->is_anon_class >>
  
  This returns true if the class was created by calling C<<
  Class::MOP::Class->create_anon_class >>.
  
  =item B<< $metaclass->is_mutable >>
  
  This returns true if the class is still mutable.
  
  =item B<< $metaclass->is_immutable >>
  
  This returns true if the class has been made immutable.
  
  =item B<< $metaclass->is_pristine >>
  
  A class is I<not> pristine if it has non-inherited attributes or if it
  has any generated methods.
  
  =back
  
  =head2 Inheritance Relationships
  
  =over 4
  
  =item B<< $metaclass->superclasses(@superclasses) >>
  
  This is a read-write accessor which represents the superclass
  relationships of the metaclass's class.
  
  This is basically sugar around getting and setting C<@ISA>.
  
  =item B<< $metaclass->class_precedence_list >>
  
  This returns a list of all of the class's ancestor classes. The
  classes are returned in method dispatch order.
  
  =item B<< $metaclass->linearized_isa >>
  
  This returns a list based on C<class_precedence_list> but with all
  duplicates removed.
  
  =item B<< $metaclass->subclasses >>
  
  This returns a list of all subclasses for this class, even indirect
  subclasses.
  
  =item B<< $metaclass->direct_subclasses >>
  
  This returns a list of immediate subclasses for this class, which does not
  include indirect subclasses.
  
  =back
  
  =head2 Method introspection and creation
  
  These methods allow you to introspect a class's methods, as well as
  add, remove, or change methods.
  
  Determining what is truly a method in a Perl 5 class requires some
  heuristics (aka guessing).
  
  Methods defined outside the package with a fully qualified name (C<sub
  Package::name { ... }>) will be included. Similarly, methods named
  with a fully qualified name using L<Sub::Name> are also included.
  
  However, we attempt to ignore imported functions.
  
  Ultimately, we are using heuristics to determine what truly is a
  method in a class, and these heuristics may get the wrong answer in
  some edge cases. However, for most "normal" cases the heuristics work
  correctly.
  
  =over 4
  
  =item B<< $metaclass->get_method($method_name) >>
  
  This will return a L<Class::MOP::Method> for the specified
  C<$method_name>. If the class does not have the specified method, it
  returns C<undef>
  
  =item B<< $metaclass->has_method($method_name) >>
  
  Returns a boolean indicating whether or not the class defines the
  named method. It does not include methods inherited from parent
  classes.
  
  =item B<< $metaclass->get_method_list >>
  
  This will return a list of method I<names> for all methods defined in
  this class.
  
  =item B<< $metaclass->add_method($method_name, $method) >>
  
  This method takes a method name and a subroutine reference, and adds
  the method to the class.
  
  The subroutine reference can be a L<Class::MOP::Method>, and you are
  strongly encouraged to pass a meta method object instead of a code
  reference. If you do so, that object gets stored as part of the
  class's method map directly. If not, the meta information will have to
  be recreated later, and may be incorrect.
  
  If you provide a method object, this method will clone that object if
  the object's package name does not match the class name. This lets us
  track the original source of any methods added from other classes
  (notably Moose roles).
  
  =item B<< $metaclass->remove_method($method_name) >>
  
  Remove the named method from the class. This method returns the
  L<Class::MOP::Method> object for the method.
  
  =item B<< $metaclass->method_metaclass >>
  
  Returns the class name of the method metaclass, see
  L<Class::MOP::Method> for more information on the method metaclass.
  
  =item B<< $metaclass->wrapped_method_metaclass >>
  
  Returns the class name of the wrapped method metaclass, see
  L<Class::MOP::Method::Wrapped> for more information on the wrapped
  method metaclass.
  
  =item B<< $metaclass->get_all_methods >>
  
  This will traverse the inheritance hierarchy and return a list of all
  the L<Class::MOP::Method> objects for this class and its parents.
  
  =item B<< $metaclass->find_method_by_name($method_name) >>
  
  This will return a L<Class::MOP::Method> for the specified
  C<$method_name>. If the class does not have the specified method, it
  returns C<undef>
  
  Unlike C<get_method>, this method I<will> look for the named method in
  superclasses.
  
  =item B<< $metaclass->get_all_method_names >>
  
  This will return a list of method I<names> for all of this class's
  methods, including inherited methods.
  
  =item B<< $metaclass->find_all_methods_by_name($method_name) >>
  
  This method looks for the named method in the class and all of its
  parents. It returns every matching method it finds in the inheritance
  tree, so it returns a list of methods.
  
  Each method is returned as a hash reference with three keys. The keys
  are C<name>, C<class>, and C<code>. The C<code> key has a
  L<Class::MOP::Method> object as its value.
  
  The list of methods is distinct.
  
  =item B<< $metaclass->find_next_method_by_name($method_name) >>
  
  This method returns the first method in any superclass matching the
  given name. It is effectively the method that C<SUPER::$method_name>
  would dispatch to.
  
  =back
  
  =head2 Attribute introspection and creation
  
  Because Perl 5 does not have a core concept of attributes in classes,
  we can only return information about attributes which have been added
  via this class's methods. We cannot discover information about
  attributes which are defined in terms of "regular" Perl 5 methods.
  
  =over 4
  
  =item B<< $metaclass->get_attribute($attribute_name) >>
  
  This will return a L<Class::MOP::Attribute> for the specified
  C<$attribute_name>. If the class does not have the specified
  attribute, it returns C<undef>.
  
  NOTE that get_attribute does not search superclasses, for that you
  need to use C<find_attribute_by_name>.
  
  =item B<< $metaclass->has_attribute($attribute_name) >>
  
  Returns a boolean indicating whether or not the class defines the
  named attribute. It does not include attributes inherited from parent
  classes.
  
  =item B<< $metaclass->get_attribute_list >>
  
  This will return a list of attributes I<names> for all attributes
  defined in this class.  Note that this operates on the current class
  only, it does not traverse the inheritance hierarchy.
  
  =item B<< $metaclass->get_all_attributes >>
  
  This will traverse the inheritance hierarchy and return a list of all
  the L<Class::MOP::Attribute> objects for this class and its parents.
  
  =item B<< $metaclass->find_attribute_by_name($attribute_name) >>
  
  This will return a L<Class::MOP::Attribute> for the specified
  C<$attribute_name>. If the class does not have the specified
  attribute, it returns C<undef>.
  
  Unlike C<get_attribute>, this attribute I<will> look for the named
  attribute in superclasses.
  
  =item B<< $metaclass->add_attribute(...) >>
  
  This method accepts either an existing L<Class::MOP::Attribute>
  object or parameters suitable for passing to that class's C<new>
  method.
  
  The attribute provided will be added to the class.
  
  Any accessor methods defined by the attribute will be added to the
  class when the attribute is added.
  
  If an attribute of the same name already exists, the old attribute
  will be removed first.
  
  =item B<< $metaclass->remove_attribute($attribute_name) >>
  
  This will remove the named attribute from the class, and
  L<Class::MOP::Attribute> object.
  
  Removing an attribute also removes any accessor methods defined by the
  attribute.
  
  However, note that removing an attribute will only affect I<future>
  object instances created for this class, not existing instances.
  
  =item B<< $metaclass->attribute_metaclass >>
  
  Returns the class name of the attribute metaclass for this class. By
  default, this is L<Class::MOP::Attribute>.
  
  =back
  
  =head2 Overload introspection and creation
  
  These methods provide an API to the core L<overload> functionality.
  
  =over 4
  
  =item B<< $metaclass->is_overloaded >>
  
  Returns true if overloading is enabled for this class. Corresponds to
  L<overload::Overloaded|overload/Public Functions>.
  
  =item B<< $metaclass->get_overloaded_operator($op) >>
  
  Returns the L<Class::MOP::Method::Overload> object corresponding to the
  operator named C<$op>, if one exists for this class.
  
  =item B<< $metaclass->has_overloaded_operator($op) >>
  
  Returns whether or not the operator C<$op> is overloaded for this class.
  
  =item B<< $metaclass->get_overload_list >>
  
  Returns a list of operator names which have been overloaded (see
  L<overload/Overloadable Operations> for the list of valid operator names).
  
  =item B<< $metaclass->get_all_overloaded_operators >>
  
  Returns a list of L<Class::MOP::Method::Overload> objects corresponding to the
  operators that have been overloaded.
  
  =item B<< $metaclass->add_overloaded_operator($op, $impl) >>
  
  Overloads the operator C<$op> for this class, with the implementation C<$impl>.
  C<$impl> can be either a coderef or a method name. Corresponds to
  C<< use overload $op => $impl; >>
  
  =item B<< $metaclass->remove_overloaded_operator($op) >>
  
  Remove overloading for operator C<$op>. Corresponds to C<< no overload $op; >>
  
  =back
  
  =head2 Class Immutability
  
  Making a class immutable "freezes" the class definition. You can no
  longer call methods which alter the class, such as adding or removing
  methods or attributes.
  
  Making a class immutable lets us optimize the class by inlining some
  methods, and also allows us to optimize some methods on the metaclass
  object itself.
  
  After immutabilization, the metaclass object will cache most informational
  methods that returns information about methods or attributes. Methods which
  would alter the class, such as C<add_attribute> and C<add_method>, will
  throw an error on an immutable metaclass object.
  
  The immutabilization system in L<Moose> takes much greater advantage
  of the inlining features than Class::MOP itself does.
  
  =over 4
  
  =item B<< $metaclass->make_immutable(%options) >>
  
  This method will create an immutable transformer and use it to make
  the class and its metaclass object immutable, and returns true
  (you should not rely on the details of this value apart from its truth).
  
  This method accepts the following options:
  
  =over 8
  
  =item * inline_accessors
  
  =item * inline_constructor
  
  =item * inline_destructor
  
  These are all booleans indicating whether the specified method(s)
  should be inlined.
  
  By default, accessors and the constructor are inlined, but not the
  destructor.
  
  =item * immutable_trait
  
  The name of a class which will be used as a parent class for the
  metaclass object being made immutable. This "trait" implements the
  post-immutability functionality of the metaclass (but not the
  transformation itself).
  
  This defaults to L<Class::MOP::Class::Immutable::Trait>.
  
  =item * constructor_name
  
  This is the constructor method name. This defaults to "new".
  
  =item * constructor_class
  
  The name of the method metaclass for constructors. It will be used to
  generate the inlined constructor. This defaults to
  "Class::MOP::Method::Constructor".
  
  =item * replace_constructor
  
  This is a boolean indicating whether an existing constructor should be
  replaced when inlining a constructor. This defaults to false.
  
  =item * destructor_class
  
  The name of the method metaclass for destructors. It will be used to
  generate the inlined destructor. This defaults to
  "Class::MOP::Method::Denstructor".
  
  =item * replace_destructor
  
  This is a boolean indicating whether an existing destructor should be
  replaced when inlining a destructor. This defaults to false.
  
  =back
  
  =item B<< $metaclass->immutable_options >>
  
  Returns a hash of the options used when making the class immutable, including
  both defaults and anything supplied by the user in the call to C<<
  $metaclass->make_immutable >>. This is useful if you need to temporarily make
  a class mutable and then restore immutability as it was before.
  
  =item B<< $metaclass->make_mutable >>
  
  Calling this method reverse the immutabilization transformation.
  
  =back
  
  =head2 Method Modifiers
  
  Method modifiers are hooks which allow a method to be wrapped with
  I<before>, I<after> and I<around> method modifiers. Every time a
  method is called, its modifiers are also called.
  
  A class can modify its own methods, as well as methods defined in
  parent classes.
  
  =head3 How method modifiers work?
  
  Method modifiers work by wrapping the original method and then
  replacing it in the class's symbol table. The wrappers will handle
  calling all the modifiers in the appropriate order and preserving the
  calling context for the original method.
  
  The return values of C<before> and C<after> modifiers are
  ignored. This is because their purpose is B<not> to filter the input
  and output of the primary method (this is done with an I<around>
  modifier).
  
  This may seem like an odd restriction to some, but doing this allows
  for simple code to be added at the beginning or end of a method call
  without altering the function of the wrapped method or placing any
  extra responsibility on the code of the modifier.
  
  Of course if you have more complex needs, you can use the C<around>
  modifier which allows you to change both the parameters passed to the
  wrapped method, as well as its return value.
  
  Before and around modifiers are called in last-defined-first-called
  order, while after modifiers are called in first-defined-first-called
  order. So the call tree might looks something like this:
  
    before 2
     before 1
      around 2
       around 1
        primary
       around 1
      around 2
     after 1
    after 2
  
  =head3 What is the performance impact?
  
  Of course there is a performance cost associated with method
  modifiers, but we have made every effort to make that cost directly
  proportional to the number of modifier features you use.
  
  The wrapping method does its best to B<only> do as much work as it
  absolutely needs to. In order to do this we have moved some of the
  performance costs to set-up time, where they are easier to amortize.
  
  All this said, our benchmarks have indicated the following:
  
    simple wrapper with no modifiers             100% slower
    simple wrapper with simple before modifier   400% slower
    simple wrapper with simple after modifier    450% slower
    simple wrapper with simple around modifier   500-550% slower
    simple wrapper with all 3 modifiers          1100% slower
  
  These numbers may seem daunting, but you must remember, every feature
  comes with some cost. To put things in perspective, just doing a
  simple C<AUTOLOAD> which does nothing but extract the name of the
  method called and return it costs about 400% over a normal method
  call.
  
  =over 4
  
  =item B<< $metaclass->add_before_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference. The modifier will be called as a method itself, and will
  receive the same arguments as are passed to the method.
  
  When the modifier exits, the wrapped method will be called.
  
  The return value of the modifier will be ignored.
  
  =item B<< $metaclass->add_after_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference. The modifier will be called as a method itself, and will
  receive the same arguments as are passed to the method.
  
  When the wrapped methods exits, the modifier will be called.
  
  The return value of the modifier will be ignored.
  
  =item B<< $metaclass->add_around_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference.
  
  The first argument passed to the modifier will be a subroutine
  reference to the wrapped method. The second argument is the object,
  and after that come any arguments passed when the method is called.
  
  The around modifier can choose to call the original method, as well as
  what arguments to pass if it does so.
  
  The return value of the modifier is what will be seen by the caller.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Class->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_CLASS

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Class/Immutable/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_CLASS_IMMUTABLE_TRAIT';
  package Class::MOP::Class::Immutable::Trait;
  BEGIN {
    $Class::MOP::Class::Immutable::Trait::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Class::Immutable::Trait::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use MRO::Compat;
  
  use Scalar::Util 'blessed', 'weaken';
  
  use Moose::Util 'throw_exception';
  
  # the original class of the metaclass instance
  sub _get_mutable_metaclass_name { $_[0]{__immutable}{original_class} }
  
  sub is_mutable   { 0 }
  sub is_immutable { 1 }
  
  sub _immutable_metaclass { ref $_[1] }
  
  sub _immutable_read_only {
      my $name = shift;
      throw_exception( CallingReadOnlyMethodOnAnImmutableInstance => method_name => $name );
  }
  
  sub _immutable_cannot_call {
      my $name = shift;
      throw_exception( CallingMethodOnAnImmutableInstance => method_name => $name );
  }
  
  for my $name (qw/superclasses/) {
      no strict 'refs';
      *{__PACKAGE__."::$name"} = sub {
          my $orig = shift;
          my $self = shift;
          _immutable_read_only($name) if @_;
          $self->$orig;
      };
  }
  
  for my $name (qw/add_method alias_method remove_method add_attribute remove_attribute remove_package_symbol add_package_symbol/) {
      no strict 'refs';
      *{__PACKAGE__."::$name"} = sub { _immutable_cannot_call($name) };
  }
  
  sub class_precedence_list {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{class_precedence_list}
              ||= [ $self->$orig ] };
  }
  
  sub linearized_isa {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{linearized_isa} ||= [ $self->$orig ] };
  }
  
  sub get_all_methods {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_methods} ||= [ $self->$orig ] };
  }
  
  sub get_all_method_names {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_method_names} ||= [ $self->$orig ] };
  }
  
  sub get_all_attributes {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_attributes} ||= [ $self->$orig ] };
  }
  
  sub get_meta_instance {
      my $orig = shift;
      my $self = shift;
      $self->{__immutable}{get_meta_instance} ||= $self->$orig;
  }
  
  sub _method_map {
      my $orig = shift;
      my $self = shift;
      $self->{__immutable}{_method_map} ||= $self->$orig;
  }
  
  1;
  
  # ABSTRACT: Implements immutability for metaclass objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Class::Immutable::Trait - Implements immutability for metaclass objects
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class provides a pseudo-trait that is applied to immutable metaclass
  objects. In reality, it is simply a parent class.
  
  It implements caching and read-only-ness for various metaclass methods.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_CLASS_IMMUTABLE_TRAIT

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Deprecated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_DEPRECATED';
  package Class::MOP::Deprecated;
  BEGIN {
    $Class::MOP::Deprecated::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Deprecated::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Package::DeprecationManager -deprecations => {
      'Class::Load wrapper functions' => '2.1100',
  };
  
  1;
  
  # ABSTRACT: Manages deprecation warnings for Class::MOP
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Deprecated - Manages deprecation warnings for Class::MOP
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
      use Class::MOP::Deprecated -api_version => $version;
  
  =head1 FUNCTIONS
  
  This module manages deprecation warnings for features that have been
  deprecated in Class::MOP.
  
  If you specify C<< -api_version => $version >>, you can use deprecated features
  without warnings. Note that this special treatment is limited to the package
  that loads C<Class::MOP::Deprecated>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_DEPRECATED

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_INSTANCE';
  
  package Class::MOP::Instance;
  BEGIN {
    $Class::MOP::Instance::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Instance::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'isweak', 'weaken', 'blessed';
  
  use parent 'Class::MOP::Object';
  
  # make this not a valid method name, to avoid (most) attribute conflicts
  my $RESERVED_MOP_SLOT = '<<MOP>>';
  
  sub BUILDARGS {
      my ($class, @args) = @_;
  
      if ( @args == 1 ) {
          unshift @args, "associated_metaclass";
      } elsif ( @args >= 2 && blessed($args[0]) && $args[0]->isa("Class::MOP::Class") ) {
          # compat mode
          my ( $meta, @attrs ) = @args;
          @args = ( associated_metaclass => $meta, attributes => \@attrs );
      }
  
      my %options = @args;
      # FIXME lazy_build
      $options{slots} ||= [ map { $_->slots } @{ $options{attributes} || [] } ];
      $options{slot_hash} = { map { $_ => undef } @{ $options{slots} } }; # FIXME lazy_build
  
      return \%options;
  }
  
  sub new {
      my $class = shift;
      my $options = $class->BUILDARGS(@_);
  
      # FIXME replace with a proper constructor
      my $instance = $class->_new(%$options);
  
      # FIXME weak_ref => 1,
      weaken($instance->{'associated_metaclass'});
  
      return $instance;
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
      return bless {
          # NOTE:
          # I am not sure that it makes
          # sense to pass in the meta
          # The ideal would be to just
          # pass in the class name, but
          # that is placing too much of
          # an assumption on bless(),
          # which is *probably* a safe
          # assumption,.. but you can
          # never tell <:)
          'associated_metaclass' => $params->{associated_metaclass},
          'attributes'           => $params->{attributes},
          'slots'                => $params->{slots},
          'slot_hash'            => $params->{slot_hash},
      } => $class;
  }
  
  sub _class_name { $_[0]->{_class_name} ||= $_[0]->associated_metaclass->name }
  
  sub create_instance {
      my $self = shift;
      bless {}, $self->_class_name;
  }
  
  sub clone_instance {
      my ($self, $instance) = @_;
  
      my $clone = $self->create_instance;
      for my $attr ($self->get_all_attributes) {
          next unless $attr->has_value($instance);
          for my $slot ($attr->slots) {
              my $val = $self->get_slot_value($instance, $slot);
              $self->set_slot_value($clone, $slot, $val);
              $self->weaken_slot_value($clone, $slot)
                  if $self->slot_value_is_weak($instance, $slot);
          }
      }
  
      $self->_set_mop_slot($clone, $self->_get_mop_slot($instance))
          if $self->_has_mop_slot($instance);
  
      return $clone;
  }
  
  # operations on meta instance
  
  sub get_all_slots {
      my $self = shift;
      return @{$self->{'slots'}};
  }
  
  sub get_all_attributes {
      my $self = shift;
      return @{$self->{attributes}};
  }
  
  sub is_valid_slot {
      my ($self, $slot_name) = @_;
      exists $self->{'slot_hash'}->{$slot_name};
  }
  
  # operations on created instances
  
  sub get_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $instance->{$slot_name};
  }
  
  sub set_slot_value {
      my ($self, $instance, $slot_name, $value) = @_;
      $instance->{$slot_name} = $value;
  }
  
  sub initialize_slot {
      my ($self, $instance, $slot_name) = @_;
      return;
  }
  
  sub deinitialize_slot {
      my ( $self, $instance, $slot_name ) = @_;
      delete $instance->{$slot_name};
  }
  
  sub initialize_all_slots {
      my ($self, $instance) = @_;
      foreach my $slot_name ($self->get_all_slots) {
          $self->initialize_slot($instance, $slot_name);
      }
  }
  
  sub deinitialize_all_slots {
      my ($self, $instance) = @_;
      foreach my $slot_name ($self->get_all_slots) {
          $self->deinitialize_slot($instance, $slot_name);
      }
  }
  
  sub is_slot_initialized {
      my ($self, $instance, $slot_name, $value) = @_;
      exists $instance->{$slot_name};
  }
  
  sub weaken_slot_value {
      my ($self, $instance, $slot_name) = @_;
      weaken $instance->{$slot_name};
  }
  
  sub slot_value_is_weak {
      my ($self, $instance, $slot_name) = @_;
      isweak $instance->{$slot_name};
  }
  
  sub strengthen_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->set_slot_value($instance, $slot_name, $self->get_slot_value($instance, $slot_name));
  }
  
  sub rebless_instance_structure {
      my ($self, $instance, $metaclass) = @_;
  
      # we use $_[1] here because of t/cmop/rebless_overload.t regressions
      # on 5.8.8
      bless $_[1], $metaclass->name;
  }
  
  sub is_dependent_on_superclasses {
      return; # for meta instances that require updates on inherited slot changes
  }
  
  sub _get_mop_slot {
      my ($self, $instance) = @_;
      $self->get_slot_value($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _has_mop_slot {
      my ($self, $instance) = @_;
      $self->is_slot_initialized($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _set_mop_slot {
      my ($self, $instance, $value) = @_;
      $self->set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
  }
  
  sub _clear_mop_slot {
      my ($self, $instance) = @_;
      $self->deinitialize_slot($instance, $RESERVED_MOP_SLOT);
  }
  
  # inlinable operation snippets
  
  sub is_inlinable { 1 }
  
  sub inline_create_instance {
      my ($self, $class_variable) = @_;
      'bless {} => ' . $class_variable;
  }
  
  sub inline_slot_access {
      my ($self, $instance, $slot_name) = @_;
      sprintf q[%s->{"%s"}], $instance, quotemeta($slot_name);
  }
  
  sub inline_get_is_lvalue { 1 }
  
  sub inline_get_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_set_slot_value {
      my ($self, $instance, $slot_name, $value) = @_;
      $self->inline_slot_access($instance, $slot_name) . " = $value",
  }
  
  sub inline_initialize_slot {
      my ($self, $instance, $slot_name) = @_;
      return '';
  }
  
  sub inline_deinitialize_slot {
      my ($self, $instance, $slot_name) = @_;
      "delete " . $self->inline_slot_access($instance, $slot_name);
  }
  sub inline_is_slot_initialized {
      my ($self, $instance, $slot_name) = @_;
      "exists " . $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_weaken_slot_value {
      my ($self, $instance, $slot_name) = @_;
      sprintf "Scalar::Util::weaken( %s )", $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_strengthen_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->inline_set_slot_value($instance, $slot_name, $self->inline_slot_access($instance, $slot_name));
  }
  
  sub inline_rebless_instance_structure {
      my ($self, $instance, $class_variable) = @_;
      "bless $instance => $class_variable";
  }
  
  sub _inline_get_mop_slot {
      my ($self, $instance) = @_;
      $self->inline_get_slot_value($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _inline_set_mop_slot {
      my ($self, $instance, $value) = @_;
      $self->inline_set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
  }
  
  sub _inline_clear_mop_slot {
      my ($self, $instance) = @_;
      $self->inline_deinitialize_slot($instance, $RESERVED_MOP_SLOT);
  }
  
  1;
  
  # ABSTRACT: Instance Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Instance - Instance Meta Object
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  The Instance Protocol controls the creation of object instances, and
  the storage of attribute values in those instances.
  
  Using this API directly in your own code violates encapsulation, and
  we recommend that you use the appropriate APIs in L<Class::MOP::Class>
  and L<Class::MOP::Attribute> instead. Those APIs in turn call the
  methods in this class as appropriate.
  
  This class also participates in generating inlined code by providing
  snippets of code to access an object instance.
  
  =head1 METHODS
  
  =head2 Object construction
  
  =over 4
  
  =item B<< Class::MOP::Instance->new(%options) >>
  
  This method creates a new meta-instance object.
  
  It accepts the following keys in C<%options>:
  
  =over 8
  
  =item * associated_metaclass
  
  The L<Class::MOP::Class> object for which instances will be created.
  
  =item * attributes
  
  An array reference of L<Class::MOP::Attribute> objects. These are the
  attributes which can be stored in each instance.
  
  =back
  
  =back
  
  =head2 Creating and altering instances
  
  =over 4
  
  =item B<< $metainstance->create_instance >>
  
  This method returns a reference blessed into the associated
  metaclass's class.
  
  The default is to use a hash reference. Subclasses can override this.
  
  =item B<< $metainstance->clone_instance($instance) >>
  
  Given an instance, this method creates a new object by making
  I<shallow> clone of the original.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< $metainstance->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object associated with the
  meta-instance object.
  
  =item B<< $metainstance->get_all_slots >>
  
  This returns a list of slot names stored in object instances. In
  almost all cases, slot names correspond directly attribute names.
  
  =item B<< $metainstance->is_valid_slot($slot_name) >>
  
  This will return true if C<$slot_name> is a valid slot name.
  
  =item B<< $metainstance->get_all_attributes >>
  
  This returns a list of attributes corresponding to the attributes
  passed to the constructor.
  
  =back
  
  =head2 Operations on Instance Structures
  
  It's important to understand that the meta-instance object is a
  different entity from the actual instances it creates. For this
  reason, any operations on the C<$instance_structure> always require
  that the object instance be passed to the method.
  
  =over 4
  
  =item B<< $metainstance->get_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->set_slot_value($instance_structure, $slot_name, $value) >>
  
  =item B<< $metainstance->initialize_slot($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->deinitialize_slot($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->initialize_all_slots($instance_structure) >>
  
  =item B<< $metainstance->deinitialize_all_slots($instance_structure) >>
  
  =item B<< $metainstance->is_slot_initialized($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->weaken_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->slot_value_is_weak($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->strengthen_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->rebless_instance_structure($instance_structure, $new_metaclass) >>
  
  The exact details of what each method does should be fairly obvious
  from the method name.
  
  =back
  
  =head2 Inlinable Instance Operations
  
  =over 4
  
  =item B<< $metainstance->is_inlinable >>
  
  This is a boolean that indicates whether or not slot access operations
  can be inlined. By default it is true, but subclasses can override
  this.
  
  =item B<< $metainstance->inline_create_instance($class_variable) >>
  
  This method expects a string that, I<when inlined>, will become a
  class name. This would literally be something like C<'$class'>, not an
  actual class name.
  
  It returns a snippet of code that creates a new object for the
  class. This is something like C< bless {}, $class_name >.
  
  =item B<< $metainstance->inline_get_is_lvalue >>
  
  Returns whether or not C<inline_get_slot_value> is a valid lvalue. This can be
  used to do extra optimizations when generating inlined methods.
  
  =item B<< $metainstance->inline_slot_access($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_get_slot_value($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_set_slot_value($instance_variable, $slot_name, $value) >>
  
  =item B<< $metainstance->inline_initialize_slot($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_deinitialize_slot($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_is_slot_initialized($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_weaken_slot_value($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_strengthen_slot_value($instance_variable, $slot_name) >>
  
  These methods all expect two arguments. The first is the name of a
  variable, than when inlined, will represent the object
  instance. Typically this will be a literal string like C<'$_[0]'>.
  
  The second argument is a slot name.
  
  The method returns a snippet of code that, when inlined, performs some
  operation on the instance.
  
  =item B<< $metainstance->inline_rebless_instance_structure($instance_variable, $class_variable) >>
  
  This takes the name of a variable that will, when inlined, represent the object
  instance, and the name of a variable that will represent the class to rebless
  into, and returns code to rebless an instance into a class.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Instance->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_INSTANCE

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD';
  
  package Class::MOP::Method;
  BEGIN {
    $Class::MOP::Method::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Method::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'weaken', 'reftype', 'blessed';
  
  use parent 'Class::MOP::Object';
  
  # NOTE:
  # if poked in the right way,
  # they should act like CODE refs.
  use overload '&{}' => sub { $_[0]->body }, fallback => 1;
  
  # construction
  
  sub wrap {
      my ( $class, @args ) = @_;
  
      unshift @args, 'body' if @args % 2 == 1;
  
      my %params = @args;
      my $code = $params{body};
  
      require Moose::Util;
      if (blessed($code) && $code->isa(__PACKAGE__)) {
          my $method = $code->clone;
          delete $params{body};
          Class::MOP::class_of($class)->rebless_instance($method, %params);
          return $method;
      }
      elsif (!ref $code || 'CODE' ne reftype($code)) {
          Moose::Util::throw_exception( WrapTakesACodeRefToBless => params => \%params,
                                                                    class  => $class,
                                                                    code   => $code
                                      );
      }
  
      ($params{package_name} && $params{name})
          || Moose::Util::throw_exception( PackageNameAndNameParamsNotGivenToWrap => params => \%params,
                                                                                     class  => $class,
                                                                                     code   => $code
                                         );
  
      my $self = $class->_new(\%params);
  
      weaken($self->{associated_metaclass}) if $self->{associated_metaclass};
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
      } => $class;
  }
  
  ## accessors
  
  sub associated_metaclass { shift->{'associated_metaclass'} }
  
  sub attach_to_class {
      my ( $self, $class ) = @_;
      $self->{associated_metaclass} = $class;
      weaken($self->{associated_metaclass});
  }
  
  sub detach_from_class {
      my $self = shift;
      delete $self->{associated_metaclass};
  }
  
  sub fully_qualified_name {
      my $self = shift;
      $self->package_name . '::' . $self->name;
  }
  
  sub original_method { (shift)->{'original_method'} }
  
  sub _set_original_method { $_[0]->{'original_method'} = $_[1] }
  
  # It's possible that this could cause a loop if there is a circular
  # reference in here. That shouldn't ever happen in normal
  # circumstances, since original method only gets set when clone is
  # called. We _could_ check for such a loop, but it'd involve some sort
  # of package-lexical variable, and wouldn't be terribly subclassable.
  sub original_package_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_package_name
          : $self->package_name;
  }
  
  sub original_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_name
          : $self->name;
  }
  
  sub original_fully_qualified_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_fully_qualified_name
          : $self->fully_qualified_name;
  }
  
  sub execute {
      my $self = shift;
      $self->body->(@_);
  }
  
  # We used to go through use Class::MOP::Class->clone_instance to do this, but
  # this was awfully slow. This method may be called a number of times when
  # classes are loaded (especially during Moose role application), so it is
  # worth optimizing. - DR
  sub clone {
      my $self = shift;
  
      my $clone = bless { %{$self}, @_ }, blessed($self);
      weaken($clone->{associated_metaclass}) if $clone->{associated_metaclass};
  
      $clone->_set_original_method($self);
  
      return $clone;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method - Method Meta Object
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  The Method Protocol is very small, since methods in Perl 5 are just
  subroutines in a specific package. We provide a very basic
  introspection interface.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method->wrap($code, %options) >>
  
  This is the constructor. It accepts a method body in the form of
  either a code reference or a L<Class::MOP::Method> instance, followed
  by a hash of options.
  
  The options are:
  
  =over 8
  
  =item * name
  
  The method name (without a package name). This is required if C<$code>
  is a coderef.
  
  =item * package_name
  
  The package name for the method. This is required if C<$code> is a
  coderef.
  
  =item * associated_metaclass
  
  An optional L<Class::MOP::Class> object. This is the metaclass for the
  method's class.
  
  =back
  
  =item B<< $metamethod->clone(%params) >>
  
  This makes a shallow clone of the method object. In particular,
  subroutine reference itself is shared between all clones of a given
  method.
  
  When a method is cloned, the original method object will be available
  by calling C<original_method> on the clone.
  
  =item B<< $metamethod->body >>
  
  This returns a reference to the method's subroutine.
  
  =item B<< $metamethod->name >>
  
  This returns the method's name
  
  =item B<< $metamethod->package_name >>
  
  This returns the method's package name.
  
  =item B<< $metamethod->fully_qualified_name >>
  
  This returns the method's fully qualified name (package name and
  method name).
  
  =item B<< $metamethod->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object for the method, if one
  exists.
  
  =item B<< $metamethod->original_method >>
  
  If this method object was created as a clone of some other method
  object, this returns the object that was cloned.
  
  =item B<< $metamethod->original_name >>
  
  This returns the method's original name, wherever it was first
  defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the name from the I<first> method in the chain of clones.
  
  =item B<< $metamethod->original_package_name >>
  
  This returns the method's original package name, wherever it was first
  defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the package name from the I<first> method in the chain of
  clones.
  
  =item B<< $metamethod->original_fully_qualified_name >>
  
  This returns the method's original fully qualified name, wherever it
  was first defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the fully qualified name from the I<first> method in the chain
  of clones.
  
  =item B<< $metamethod->is_stub >>
  
  Returns true if the method is just a stub:
  
    sub foo;
  
  =item B<< $metamethod->attach_to_class($metaclass) >>
  
  Given a L<Class::MOP::Class> object, this method sets the associated
  metaclass for the method. This will overwrite any existing associated
  metaclass.
  
  =item B<< $metamethod->detach_from_class >>
  
  Removes any associated metaclass object for the method.
  
  =item B<< $metamethod->execute(...) >>
  
  This executes the method. Any arguments provided will be passed on to
  the method itself.
  
  =item B<< Class::MOP::Method->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_ACCESSOR';
  
  package Class::MOP::Method::Accessor;
  BEGIN {
    $Class::MOP::Method::Accessor::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Method::Accessor::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Method::Generated';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (exists $options{attribute})
          || throw_exception( MustSupplyAnAttributeToConstructWith => params => \%options,
                                                                      class  => $class,
                            );
  
      (exists $options{accessor_type})
          || throw_exception( MustSupplyAnAccessorTypeToConstructWith => params => \%options,
                                                                         class  => $class,
                            );
  
      (blessed($options{attribute}) && $options{attribute}->isa('Class::MOP::Attribute'))
          || throw_exception( MustSupplyAClassMOPAttributeInstance => params => \%options,
                                                                      class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = $class->_new(\%options);
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'attribute'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          body                 => $params->{body},
          associated_metaclass => $params->{associated_metaclass},
          package_name         => $params->{package_name},
          name                 => $params->{name},
          original_method      => $params->{original_method},
  
          # inherit from Class::MOP::Generated
          is_inline            => $params->{is_inline} || 0,
          definition_context   => $params->{definition_context},
  
          # defined in this class
          attribute            => $params->{attribute},
          accessor_type        => $params->{accessor_type},
      } => $class;
  }
  
  ## accessors
  
  sub associated_attribute { (shift)->{'attribute'}     }
  sub accessor_type        { (shift)->{'accessor_type'} }
  
  ## factory
  
  sub _initialize_body {
      my $self = shift;
  
      my $method_name = join "_" => (
          '_generate',
          $self->accessor_type,
          'method',
          ($self->is_inline ? 'inline' : ())
      );
  
      $self->{'body'} = $self->$method_name();
  }
  
  ## generators
  
  sub _generate_accessor_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          if (@_ >= 2) {
              $attr->set_value($_[0], $_[1]);
          }
          $attr->get_value($_[0]);
      };
  }
  
  sub _generate_accessor_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  'if (@_ > 1) {',
                      $attr->_inline_set_value('$_[0]', '$_[1]'),
                  '}',
                  $attr->_inline_get_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "accessor"
                         );
      };
  }
  
  sub _generate_reader_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
      my $class = $attr->associated_class;
  
      return sub {
          throw_exception( CannotAssignValueToReadOnlyAccessor => class     => $class,
                                                                  value     => $_[1],
                                                                  attribute => $attr
                         )
              if @_ > 1;
          $attr->get_value($_[0]);
      };
  }
  
  sub _generate_reader_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
      my $attr_name = $attr->name;
  
      return try {
          $self->_compile_code([
              'sub {',
                  'if (@_ > 1) {',
                      $self->_inline_throw_exception( "CannotAssignValueToReadOnlyAccessor => ".
                                                      'class_name                          => ref $_[0],'.
                                                      'value                               => $_[1],'.
                                                      "attribute_name                      => '".$attr_name."'",
                      ) . ';',
                  '}',
                  $attr->_inline_get_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "reader"
                         );
      };
  }
  
  sub _inline_throw_exception {
      my ( $self, $throw_args ) = @_;
      return 'require Moose::Util; Moose::Util::throw_exception('.$throw_args.')';
  }
  
  sub _generate_writer_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->set_value($_[0], $_[1]);
      };
  }
  
  sub _generate_writer_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_set_value('$_[0]', '$_[1]'),
              '}',
          ]);
      }
      catch {
          throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "writer"
                         );
      };
  }
  
  sub _generate_predicate_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->has_value($_[0])
      };
  }
  
  sub _generate_predicate_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_has_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "predicate"
                         );
      };
  }
  
  sub _generate_clearer_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->clear_value($_[0])
      };
  }
  
  sub _generate_clearer_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_clear_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "clearer"
                         );
      };
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for accessors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Accessor - Method Meta Object for accessors
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
      use Class::MOP::Method::Accessor;
  
      my $reader = Class::MOP::Method::Accessor->new(
          attribute     => $attribute,
          is_inline     => 1,
          accessor_type => 'reader',
      );
  
      $reader->body->execute($instance); # call the reader method
  
  =head1 DESCRIPTION
  
  This is a subclass of C<Class::MOP::Method> which is used by
  C<Class::MOP::Attribute> to generate accessor code. It handles
  generation of readers, writers, predicates and clearers. For each type
  of method, it can either create a subroutine reference, or actually
  inline code by generating a string and C<eval>'ing it.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Accessor->new(%options) >>
  
  This returns a new C<Class::MOP::Method::Accessor> based on the
  C<%options> provided.
  
  =over 4
  
  =item * attribute
  
  This is the C<Class::MOP::Attribute> for which accessors are being
  generated. This option is required.
  
  =item * accessor_type
  
  This is a string which should be one of "reader", "writer",
  "accessor", "predicate", or "clearer". This is the type of method
  being generated. This option is required.
  
  =item * is_inline
  
  This indicates whether or not the accessor should be inlined. This
  defaults to false.
  
  =item * name
  
  The method name (without a package name). This is required.
  
  =item * package_name
  
  The package name for the method. This is required.
  
  =back
  
  =item B<< $metamethod->accessor_type >>
  
  Returns the accessor type which was passed to C<new>.
  
  =item B<< $metamethod->is_inline >>
  
  Returns a boolean indicating whether or not the accessor is inlined.
  
  =item B<< $metamethod->associated_attribute >>
  
  This returns the L<Class::MOP::Attribute> object which was passed to
  C<new>.
  
  =item B<< $metamethod->body >>
  
  The method itself is I<generated> when the accessor object is
  constructed.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_ACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_CONSTRUCTOR';
  
  package Class::MOP::Method::Constructor;
  BEGIN {
    $Class::MOP::Method::Constructor::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Method::Constructor::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Method::Inlined';
  
  use Moose::Util 'throw_exception';
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (blessed $options{metaclass} && $options{metaclass}->isa('Class::MOP::Class'))
          || throw_exception( MustSupplyAMetaclass => params => \%options,
                                                      class  => $class
                            )
              if $options{is_inline};
  
      ($options{package_name} && $options{name})
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = $class->_new(\%options);
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          body                 => $params->{body},
          # associated_metaclass => $params->{associated_metaclass}, # overridden
          package_name         => $params->{package_name},
          name                 => $params->{name},
          original_method      => $params->{original_method},
  
          # inherited from Class::MOP::Generated
          is_inline            => $params->{is_inline} || 0,
          definition_context   => $params->{definition_context},
  
          # inherited from Class::MOP::Inlined
          _expected_method_class => $params->{_expected_method_class},
  
          # defined in this subclass
          options              => $params->{options} || {},
          associated_metaclass => $params->{metaclass},
      }, $class;
  }
  
  ## accessors
  
  sub options              { (shift)->{'options'}              }
  sub associated_metaclass { (shift)->{'associated_metaclass'} }
  
  ## method
  
  sub _initialize_body {
      my $self        = shift;
      my $method_name = '_generate_constructor_method';
  
      $method_name .= '_inline' if $self->is_inline;
  
      $self->{'body'} = $self->$method_name;
  }
  
  sub _eval_environment {
      my $self = shift;
      return $self->associated_metaclass->_eval_environment;
  }
  
  sub _generate_constructor_method {
      return sub { Class::MOP::Class->initialize(shift)->new_object(@_) }
  }
  
  sub _generate_constructor_method_inline {
      my $self = shift;
  
      my $meta = $self->associated_metaclass;
  
      my @source = (
          'sub {',
              $meta->_inline_new_object,
          '}',
      );
  
      warn join("\n", @source) if $self->options->{debug};
  
      my $code = try {
          $self->_compile_code(\@source);
      }
      catch {
          my $source = join("\n", @source);
          throw_exception( CouldNotEvalConstructor => constructor_method => $self,
                                                      source             => $source,
                                                      error              => $_
                         );
      };
  
      return $code;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for constructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Constructor - Method Meta Object for constructors
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    use Class::MOP::Method::Constructor;
  
    my $constructor = Class::MOP::Method::Constructor->new(
        metaclass => $metaclass,
        options   => {
            debug => 1, # this is all for now
        },
    );
  
    # calling the constructor ...
    $constructor->body->execute($metaclass->name, %params);
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Class::MOP::Method> which generates
  constructor methods.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Constructor->new(%options) >>
  
  This creates a new constructor object. It accepts a hash reference of
  options.
  
  =over 8
  
  =item * metaclass
  
  This should be a L<Class::MOP::Class> object. It is required.
  
  =item * name
  
  The method name (without a package name). This is required.
  
  =item * package_name
  
  The package name for the method. This is required.
  
  =item * is_inline
  
  This indicates whether or not the constructor should be inlined. This
  defaults to false.
  
  =back
  
  =item B<< $metamethod->is_inline >>
  
  Returns a boolean indicating whether or not the constructor is
  inlined.
  
  =item B<< $metamethod->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object for the method.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_CONSTRUCTOR

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Method/Generated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_GENERATED';
  
  package Class::MOP::Method::Generated;
  BEGIN {
    $Class::MOP::Method::Generated::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Method::Generated::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Eval::Closure;
  
  use parent 'Class::MOP::Method';
  
  use Moose::Util 'throw_exception';
  
  ## accessors
  
  sub new {
      throw_exception( CannotCallAnAbstractBaseMethod => package_name => __PACKAGE__ );
  }
  
  sub _initialize_body {
      throw_exception( NoBodyToInitializeInAnAbstractBaseClass => package_name => __PACKAGE__ );
  }
  
  sub _generate_description {
      my ( $self, $context ) = @_;
      $context ||= $self->definition_context;
  
      my $desc = "generated method";
      my $origin = "unknown origin";
  
      if (defined $context) {
          if (defined $context->{description}) {
              $desc = $context->{description};
          }
  
          if (defined $context->{file} || defined $context->{line}) {
              $origin = "defined at "
                      . (defined $context->{file}
                          ? $context->{file} : "<unknown file>")
                      . " line "
                      . (defined $context->{line}
                          ? $context->{line} : "<unknown line>");
          }
      }
  
      return "$desc ($origin)";
  }
  
  sub _compile_code {
      my ( $self, @args ) = @_;
      unshift @args, 'source' if @args % 2;
      my %args = @args;
  
      my $context = delete $args{context};
      my $environment = $self->can('_eval_environment')
          ? $self->_eval_environment
          : {};
  
      return eval_closure(
          environment => $environment,
          description => $self->_generate_description($context),
          %args,
      );
  }
  
  1;
  
  # ABSTRACT: Abstract base class for generated methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Generated - Abstract base class for generated methods
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is a C<Class::MOP::Method> subclass which is subclassed by
  C<Class::MOP::Method::Accessor> and
  C<Class::MOP::Method::Constructor>.
  
  It is not intended to be used directly.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_GENERATED

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Method/Inlined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_INLINED';
  package Class::MOP::Method::Inlined;
  BEGIN {
    $Class::MOP::Method::Inlined::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Method::Inlined::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken', 'looks_like_number', 'refaddr';
  
  use parent 'Class::MOP::Method::Generated';
  
  sub _uninlined_body {
      my $self = shift;
  
      my $super_method
          = $self->associated_metaclass->find_next_method_by_name( $self->name )
          or return;
  
      if ( $super_method->isa(__PACKAGE__) ) {
          return $super_method->_uninlined_body;
      }
      else {
          return $super_method->body;
      }
  }
  
  sub can_be_inlined {
      my $self      = shift;
      my $metaclass = $self->associated_metaclass;
      my $class     = $metaclass->name;
  
      # If we don't find an inherited method, this is a rather weird
      # case where we have no method in the inheritance chain even
      # though we're expecting one to be there
      my $inherited_method
          = $metaclass->find_next_method_by_name( $self->name );
  
      if (   $inherited_method
          && $inherited_method->isa('Class::MOP::Method::Wrapped') ) {
          warn "Not inlining '"
              . $self->name
              . "' for $class since it "
              . "has method modifiers which would be lost if it were inlined\n";
  
          return 0;
      }
  
      my $expected_class = $self->_expected_method_class
          or return 1;
  
      # if we are shadowing a method we first verify that it is
      # compatible with the definition we are replacing it with
      my $expected_method = $expected_class->can( $self->name );
  
      if ( ! $expected_method ) {
          warn "Not inlining '"
              . $self->name
              . "' for $class since ${expected_class}::"
              . $self->name
              . " is not defined\n";
  
          return 0;
      }
  
      my $actual_method = $class->can( $self->name )
          or return 1;
  
      # the method is what we wanted (probably Moose::Object::new)
      return 1
          if refaddr($expected_method) == refaddr($actual_method);
  
      # otherwise we have to check that the actual method is an inlined
      # version of what we're expecting
      if ( $inherited_method->isa(__PACKAGE__) ) {
          if ( $inherited_method->_uninlined_body
               && refaddr( $inherited_method->_uninlined_body )
               == refaddr($expected_method) ) {
              return 1;
          }
      }
      elsif ( refaddr( $inherited_method->body )
              == refaddr($expected_method) ) {
          return 1;
      }
  
      my $warning
          = "Not inlining '"
          . $self->name
          . "' for $class since it is not"
          . " inheriting the default ${expected_class}::"
          . $self->name . "\n";
  
      if ( $self->isa("Class::MOP::Method::Constructor") ) {
  
          # FIXME kludge, refactor warning generation to a method
          $warning
              .= "If you are certain you don't need to inline your"
              . " constructor, specify inline_constructor => 0 in your"
              . " call to $class->meta->make_immutable\n";
      }
  
      warn $warning;
  
      return 0;
  }
  
  1;
  
  # ABSTRACT: Method base class for methods which have been inlined
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Inlined - Method base class for methods which have been inlined
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method::Generated> subclass for methods which
  can be inlined.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< $metamethod->can_be_inlined >>
  
  This method returns true if the method in question can be inlined in
  the associated metaclass.
  
  If it cannot be inlined, it spits out a warning and returns false.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_INLINED

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Method/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_META';
  
  package Class::MOP::Method::Meta;
  BEGIN {
    $Class::MOP::Method::Meta::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Method::Meta::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  
  use constant DEBUG_NO_META => $ENV{DEBUG_NO_META} ? 1 : 0;
  
  use parent 'Class::MOP::Method';
  
  sub _is_caller_mop_internal {
      my $self = shift;
      my ($caller) = @_;
      return $caller =~ /^(?:Class::MOP|metaclass)(?:::|$)/;
  }
  
  sub _generate_meta_method {
      my $method_self = shift;
      my $metaclass   = shift;
      weaken($metaclass);
  
      sub {
          # this will be compiled out if the env var wasn't set
          if (DEBUG_NO_META) {
              confess "'meta' method called by MOP internals"
                  # it's okay to call meta methods on metaclasses, since we
                  # explicitly ask for them
                  if !$_[0]->isa('Class::MOP::Object')
                  && !$_[0]->isa('Class::MOP::Mixin')
                  # it's okay if the test itself calls ->meta, we only care about
                  # if the mop internals call ->meta
                  && $method_self->_is_caller_mop_internal(scalar caller);
          }
          # we must re-initialize so that it
          # works as expected in subclasses,
          # since metaclass instances are
          # singletons, this is not really a
          # big deal anyway.
          $metaclass->initialize(blessed($_[0]) || $_[0])
      };
  }
  
  sub wrap {
      my ($class, @args) = @_;
  
      unshift @args, 'body' if @args % 2 == 1;
      my %params = @args;
      require Moose::Util;
      Moose::Util::throw_exception( CannotOverrideBodyOfMetaMethods => params => \%params,
                                                                       class  => $class
                                  )
          if $params{body};
  
      my $metaclass_class = $params{associated_metaclass}->meta;
      $params{body} = $class->_generate_meta_method($metaclass_class);
      return $class->SUPER::wrap(%params);
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is that CMOP::Method::Meta
      # objects are subclasses of CMOP::Method, but when we get to moose, they'll
      # need to be compatible with Moose::Meta::Method, which isn't possible. the
      # right solution here is to make ::Meta into a role that gets applied to
      # whatever the method_metaclass happens to be and get rid of
      # _meta_method_metaclass entirely, but that's not going to happen until
      # we ditch cmop and get roles into the bootstrapping, so. i'm not
      # maintaining the previous behavior of turning them into instances of the
      # new method_metaclass because that's equally broken, and at least this way
      # any issues will at least be detectable and potentially fixable. -doy
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for C<meta> methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Meta - Method Meta Object for C<meta> methods
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which represents C<meta>
  methods installed into classes by Class::MOP.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Wrapped->wrap($metamethod, %options) >>
  
  This is the constructor. It accepts a L<Class::MOP::Method> object and
  a hash of options. The options accepted are identical to the ones
  accepted by L<Class::MOP::Method>, except that C<body> cannot be passed
  (it will be generated automatically).
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_META

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Method/Overload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_OVERLOAD';
  
  package Class::MOP::Method::Overload;
  BEGIN {
    $Class::MOP::Method::Overload::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Method::Overload::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Carp 'confess';
  
  use parent 'Class::MOP::Method';
  
  sub wrap {
      my $class = shift;
      my (@args) = @_;
      unshift @args, 'body' if @args % 2 == 1;
      my %params = @args;
  
      require Moose::Util;
      Moose::Util::throw_exception( OperatorIsRequired => params => \%params,
                                                          class  => $class
                                  )
          unless exists $params{operator};
  
      return $class->SUPER::wrap(
          name => "($params{operator}",
          %params,
      );
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
  
          # defined in this class
          'operator'             => $params->{operator},
      } => $class;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for methods which implement overloading
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Overload - Method Meta Object for methods which implement overloading
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which represents methods that
  implement overloading.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Overload->wrap($metamethod, %options) >>
  
  This is the constructor. The options accepted are identical to the ones
  accepted by L<Class::MOP::Method>, except that it also required an C<operator>
  parameter, which should be an operator as defined by the L<overload> pragma.
  
  =item B<< $metamethod->operator >>
  
  This returns the operator that was passed to new.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_OVERLOAD

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Method/Wrapped.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_WRAPPED';
  
  package Class::MOP::Method::Wrapped;
  BEGIN {
    $Class::MOP::Method::Wrapped::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Method::Wrapped::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Method';
  
  use Moose::Util 'throw_exception';
  
  # NOTE:
  # this ugly beast is the result of trying
  # to micro optimize this as much as possible
  # while not completely loosing maintainability.
  # At this point it's "fast enough", after all
  # you can't get something for nothing :)
  my $_build_wrapped_method = sub {
      my $modifier_table = shift;
      my ($before, $after, $around) = (
          $modifier_table->{before},
          $modifier_table->{after},
          $modifier_table->{around},
      );
      if (@$before && @$after) {
          $modifier_table->{cache} = sub {
              for my $c (@$before) { $c->(@_) };
              my @rval;
              ((defined wantarray) ?
                  ((wantarray) ?
                      (@rval = $around->{cache}->(@_))
                      :
                      ($rval[0] = $around->{cache}->(@_)))
                  :
                  $around->{cache}->(@_));
              for my $c (@$after) { $c->(@_) };
              return unless defined wantarray;
              return wantarray ? @rval : $rval[0];
          }
      }
      elsif (@$before && !@$after) {
          $modifier_table->{cache} = sub {
              for my $c (@$before) { $c->(@_) };
              return $around->{cache}->(@_);
          }
      }
      elsif (@$after && !@$before) {
          $modifier_table->{cache} = sub {
              my @rval;
              ((defined wantarray) ?
                  ((wantarray) ?
                      (@rval = $around->{cache}->(@_))
                      :
                      ($rval[0] = $around->{cache}->(@_)))
                  :
                  $around->{cache}->(@_));
              for my $c (@$after) { $c->(@_) };
              return unless defined wantarray;
              return wantarray ? @rval : $rval[0];
          }
      }
      else {
          $modifier_table->{cache} = $around->{cache};
      }
  };
  
  sub wrap {
      my ( $class, $code, %params ) = @_;
  
      (blessed($code) && $code->isa('Class::MOP::Method'))
          || throw_exception( CanOnlyWrapBlessedCode => params => \%params,
                                                        class  => $class,
                                                        code   => $code
                            );
  
      my $modifier_table = {
          cache  => undef,
          orig   => $code->body,
          before => [],
          after  => [],
          around => {
              cache   => $code->body,
              methods => [],
          },
      };
      $_build_wrapped_method->($modifier_table);
      return $class->SUPER::wrap(
          sub { $modifier_table->{cache}->(@_) },
          # get these from the original
          # unless explicitly overridden
          package_name   => $params{package_name} || $code->package_name,
          name           => $params{name}         || $code->name,
          original_method => $code,
  
          modifier_table => $modifier_table,
      );
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
  
          # defined in this class
          'modifier_table'       => $params->{modifier_table}
      } => $class;
  }
  
  sub get_original_method {
      my $code = shift;
      $code->original_method;
  }
  
  sub add_before_modifier {
      my $code     = shift;
      my $modifier = shift;
      unshift @{$code->{'modifier_table'}->{before}} => $modifier;
      $_build_wrapped_method->($code->{'modifier_table'});
  }
  
  sub before_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{before}};
  }
  
  sub add_after_modifier {
      my $code     = shift;
      my $modifier = shift;
      push @{$code->{'modifier_table'}->{after}} => $modifier;
      $_build_wrapped_method->($code->{'modifier_table'});
  }
  
  sub after_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{after}};
  }
  
  {
      # NOTE:
      # this is another possible candidate for
      # optimization as well. There is an overhead
      # associated with the currying that, if
      # eliminated might make around modifiers
      # more manageable.
      my $compile_around_method = sub {{
          my $f1 = pop;
          return $f1 unless @_;
          my $f2 = pop;
          push @_, sub { $f2->( $f1, @_ ) };
          redo;
      }};
  
      sub add_around_modifier {
          my $code     = shift;
          my $modifier = shift;
          unshift @{$code->{'modifier_table'}->{around}->{methods}} => $modifier;
          $code->{'modifier_table'}->{around}->{cache} = $compile_around_method->(
              @{$code->{'modifier_table'}->{around}->{methods}},
              $code->{'modifier_table'}->{orig}
          );
          $_build_wrapped_method->($code->{'modifier_table'});
      }
  }
  
  sub around_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{around}->{methods}};
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is that CMOP::Method::Wrapped
      # objects are subclasses of CMOP::Method, but when we get to moose, they'll
      # need to be compatible with Moose::Meta::Method, which isn't possible. the
      # right solution here is to make ::Wrapped into a role that gets applied to
      # whatever the method_metaclass happens to be and get rid of
      # wrapped_method_metaclass entirely, but that's not going to happen until
      # we ditch cmop and get roles into the bootstrapping, so. i'm not
      # maintaining the previous behavior of turning them into instances of the
      # new method_metaclass because that's equally broken, and at least this way
      # any issues will at least be detectable and potentially fixable. -doy
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for methods with before/after/around modifiers
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Wrapped - Method Meta Object for methods with before/after/around modifiers
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which implements before,
  after, and around method modifiers.
  
  =head1 METHODS
  
  =head2 Construction
  
  =over 4
  
  =item B<< Class::MOP::Method::Wrapped->wrap($metamethod, %options) >>
  
  This is the constructor. It accepts a L<Class::MOP::Method> object and
  a hash of options.
  
  The options are:
  
  =over 8
  
  =item * name
  
  The method name (without a package name). This will be taken from the
  provided L<Class::MOP::Method> object if it is not provided.
  
  =item * package_name
  
  The package name for the method. This will be taken from the provided
  L<Class::MOP::Method> object if it is not provided.
  
  =item * associated_metaclass
  
  An optional L<Class::MOP::Class> object. This is the metaclass for the
  method's class.
  
  =back
  
  =item B<< $metamethod->get_original_method >>
  
  This returns the L<Class::MOP::Method> object that was passed to the
  constructor.
  
  =item B<< $metamethod->add_before_modifier($code) >>
  
  =item B<< $metamethod->add_after_modifier($code) >>
  
  =item B<< $metamethod->add_around_modifier($code) >>
  
  These methods all take a subroutine reference and apply it as a
  modifier to the original method.
  
  =item B<< $metamethod->before_modifiers >>
  
  =item B<< $metamethod->after_modifiers >>
  
  =item B<< $metamethod->around_modifiers >>
  
  These methods all return a list of subroutine references which are
  acting as the specified type of modifier.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_METHOD_WRAPPED

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/MiniTrait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MINITRAIT';
  package Class::MOP::MiniTrait;
  BEGIN {
    $Class::MOP::MiniTrait::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::MiniTrait::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Module::Runtime 'use_package_optimistically';
  
  sub apply {
      my ( $to_class, $trait ) = @_;
  
      for ( grep { !ref } $to_class, $trait ) {
          use_package_optimistically($_);
          $_ = Class::MOP::Class->initialize($_);
      }
  
      for my $meth ( grep { $_->package_name ne 'UNIVERSAL' } $trait->get_all_methods ) {
          my $meth_name = $meth->name;
  
          if ( $to_class->find_method_by_name($meth_name) ) {
              $to_class->add_around_method_modifier( $meth_name, $meth->body );
          }
          else {
              $to_class->add_method( $meth_name, $meth->clone );
          }
      }
  }
  
  # We can't load this with use, since it may be loaded and used from Class::MOP
  # (via CMOP::Class, etc). However, if for some reason this module is loaded
  # _without_ first loading Class::MOP we need to require Class::MOP so we can
  # use it and CMOP::Class.
  require Class::MOP;
  
  1;
  
  # ABSTRACT: Extremely limited trait application
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::MiniTrait - Extremely limited trait application
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This package provides a single function, C<apply>, which does a half-assed job
  of applying a trait to a class. It exists solely for use inside Class::MOP and
  L<Moose> core classes.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MINITRAIT

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Mixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MIXIN';
  package Class::MOP::Mixin;
  BEGIN {
    $Class::MOP::Mixin::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Mixin::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  sub meta {
      require Class::MOP::Class;
      Class::MOP::Class->initialize( blessed( $_[0] ) || $_[0] );
  }
  
  1;
  
  # ABSTRACT: Base class for mixin classes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin - Base class for mixin classes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class provides a single method shared by all mixins
  
  =head1 METHODS
  
  This class provides a few methods which are useful in all metaclasses.
  
  =over 4
  
  =item B<< Class::MOP::Mixin->meta >>
  
  This returns a L<Class::MOP::Class> object for the mixin class.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MIXIN

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Mixin/AttributeCore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MIXIN_ATTRIBUTECORE';
  package Class::MOP::Mixin::AttributeCore;
  BEGIN {
    $Class::MOP::Mixin::AttributeCore::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Mixin::AttributeCore::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Mixin';
  
  sub has_accessor        { defined $_[0]->{'accessor'} }
  sub has_reader          { defined $_[0]->{'reader'} }
  sub has_writer          { defined $_[0]->{'writer'} }
  sub has_predicate       { defined $_[0]->{'predicate'} }
  sub has_clearer         { defined $_[0]->{'clearer'} }
  sub has_builder         { defined $_[0]->{'builder'} }
  sub has_init_arg        { defined $_[0]->{'init_arg'} }
  sub has_default         { exists  $_[0]->{'default'} }
  sub has_initializer     { defined $_[0]->{'initializer'} }
  sub has_insertion_order { defined $_[0]->{'insertion_order'} }
  
  sub _set_insertion_order { $_[0]->{'insertion_order'} = $_[1] }
  
  sub has_read_method  { $_[0]->has_reader || $_[0]->has_accessor }
  sub has_write_method { $_[0]->has_writer || $_[0]->has_accessor }
  
  sub is_default_a_coderef {
      # Uber hack because it is called from CMOP::Attribute constructor as
      # $class->is_default_a_coderef(\%options)
      my ($value) = ref $_[0] ? $_[0]->{'default'} : $_[1]->{'default'};
  
      return unless ref($value);
  
      return ref($value) eq 'CODE'
          || ( blessed($value) && $value->isa('Class::MOP::Method') );
  }
  
  sub default {
      my ( $self, $instance ) = @_;
      if ( defined $instance && $self->is_default_a_coderef ) {
          # if the default is a CODE ref, then we pass in the instance and
          # default can return a value based on that instance. Somewhat crude,
          # but works.
          return $self->{'default'}->($instance);
      }
      $self->{'default'};
  }
  
  1;
  
  # ABSTRACT: Core attributes shared by attribute metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::AttributeCore - Core attributes shared by attribute metaclasses
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class implements the core attributes (aka properties) shared by all
  attributes. See the L<Class::MOP::Attribute> documentation for API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MIXIN_ATTRIBUTECORE

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Mixin/HasAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MIXIN_HASATTRIBUTES';
  package Class::MOP::Mixin::HasAttributes;
  BEGIN {
    $Class::MOP::Mixin::HasAttributes::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Mixin::HasAttributes::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Mixin';
  
  use Moose::Util 'throw_exception';
  
  sub add_attribute {
      my $self = shift;
  
      my $attribute
          = blessed( $_[0] ) ? $_[0] : $self->attribute_metaclass->new(@_);
  
      ( $attribute->isa('Class::MOP::Mixin::AttributeCore') )
          || throw_exception( AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass => attribute => $attribute,
                                                                                       class     => $self
                            );
  
      $self->_attach_attribute($attribute);
  
      my $attr_name = $attribute->name;
  
      $self->remove_attribute($attr_name)
          if $self->has_attribute($attr_name);
  
      my $order = ( scalar keys %{ $self->_attribute_map } );
      $attribute->_set_insertion_order($order);
  
      $self->_attribute_map->{$attr_name} = $attribute;
  
      # This method is called to allow for installing accessors. Ideally, we'd
      # use method overriding, but then the subclass would be responsible for
      # making the attribute, which would end up with lots of code
      # duplication. Even more ideally, we'd use augment/inner, but this is
      # Class::MOP!
      $self->_post_add_attribute($attribute)
          if $self->can('_post_add_attribute');
  
      return $attribute;
  }
  
  sub has_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || throw_exception( MustDefineAnAttributeName => class => $self );
  
      exists $self->_attribute_map->{$attribute_name};
  }
  
  sub get_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || throw_exception( MustDefineAnAttributeName => class => $self );
  
      return $self->_attribute_map->{$attribute_name};
  }
  
  sub remove_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || throw_exception( MustDefineAnAttributeName => class => $self );
  
      my $removed_attribute = $self->_attribute_map->{$attribute_name};
      return unless defined $removed_attribute;
  
      delete $self->_attribute_map->{$attribute_name};
  
      return $removed_attribute;
  }
  
  sub get_attribute_list {
      my $self = shift;
      keys %{ $self->_attribute_map };
  }
  
  sub _restore_metaattributes_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      for my $attr (sort { $a->insertion_order <=> $b->insertion_order }
                         map { $old_meta->get_attribute($_) }
                             $old_meta->get_attribute_list) {
          $attr->_make_compatible_with($self->attribute_metaclass);
          $self->add_attribute($attr);
      }
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::HasAttributes - Methods for metaclasses which have attributes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have attributes
  (L<Class::MOP::Class> and L<Moose::Meta::Role>). See L<Class::MOP::Class> for
  API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MIXIN_HASATTRIBUTES

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Mixin/HasMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MIXIN_HASMETHODS';
  package Class::MOP::Mixin::HasMethods;
  BEGIN {
    $Class::MOP::Mixin::HasMethods::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Mixin::HasMethods::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP::Method::Meta;
  use Class::MOP::Method::Overload;
  
  use Scalar::Util 'blessed', 'reftype';
  use Sub::Name    'subname';
  
  use overload ();
  
  use parent 'Class::MOP::Mixin';
  require Moose::Util;
  
  sub _meta_method_class { 'Class::MOP::Method::Meta' }
  
  sub _add_meta_method {
      my $self = shift;
      my ($name) = @_;
      my $existing_method = $self->can('find_method_by_name')
                                ? $self->find_method_by_name($name)
                                : $self->get_method($name);
      return if $existing_method
             && $existing_method->isa($self->_meta_method_class);
      $self->add_method(
          $name => $self->_meta_method_class->wrap(
              name                 => $name,
              package_name         => $self->name,
              associated_metaclass => $self,
          )
      );
  }
  
  sub wrap_method_body {
      my ( $self, %args ) = @_;
  
      ( $args{body} && 'CODE' eq reftype $args{body} )
          || Moose::Util::throw_exception( CodeBlockMustBeACodeRef => instance => $self,
                                                                      params   => \%args
                                         );
      $self->method_metaclass->wrap(
          package_name => $self->name,
          %args,
      );
  }
  
  sub add_method {
      my ( $self, $method_name, $method ) = @_;
      ( defined $method_name && length $method_name )
          || Moose::Util::throw_exception( MustDefineAMethodName => instance => $self );
  
      my $package_name = $self->name;
  
      my $body;
      if ( blessed($method) && $method->isa('Class::MOP::Method') ) {
          $body = $method->body;
          if ( $method->package_name ne $package_name ) {
              $method = $method->clone(
                  package_name => $package_name,
                  name         => $method_name,
              );
          }
  
          $method->attach_to_class($self);
      }
      else {
          # If a raw code reference is supplied, its method object is not created.
          # The method object won't be created until required.
          $body = $method;
      }
  
      $self->_method_map->{$method_name} = $method;
  
      my ($current_package, $current_name) = Class::MOP::get_code_info($body);
  
      subname($package_name . '::' . $method_name, $body)
          unless defined $current_name && $current_name !~ /^__ANON__/;
  
      $self->add_package_symbol("&$method_name", $body);
  
      # we added the method to the method map too, so it's still valid
      $self->update_package_cache_flag;
  }
  
  sub _code_is_mine {
      my ( $self, $code ) = @_;
  
      my ( $code_package, $code_name ) = Class::MOP::get_code_info($code);
  
      return ( $code_package && $code_package eq $self->name )
          || ( $code_package eq 'constant' && $code_name eq '__ANON__' );
  }
  
  sub has_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || Moose::Util::throw_exception( MustDefineAMethodName => instance => $self );
  
      my $method = $self->_get_maybe_raw_method($method_name)
          or return;
  
      return defined($self->_method_map->{$method_name} = $method);
  }
  
  sub get_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || Moose::Util::throw_exception( MustDefineAMethodName => instance => $self );
  
      my $method = $self->_get_maybe_raw_method($method_name)
          or return;
  
      return $method if blessed($method) && $method->isa('Class::MOP::Method');
  
      return $self->_method_map->{$method_name} = $self->wrap_method_body(
          body                 => $method,
          name                 => $method_name,
          associated_metaclass => $self,
      );
  }
  
  sub _get_maybe_raw_method {
      my ( $self, $method_name ) = @_;
  
      my $map_entry = $self->_method_map->{$method_name};
      return $map_entry if defined $map_entry;
  
      my $code = $self->get_package_symbol("&$method_name");
  
      return unless $code && $self->_code_is_mine($code);
  
      return $code;
  }
  
  sub remove_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || Moose::Util::throw_exception( MustDefineAMethodName => instance => $self );
  
      my $removed_method = delete $self->_method_map->{$method_name};
  
      $self->remove_package_symbol("&$method_name");
  
      $removed_method->detach_from_class
          if blessed($removed_method) && $removed_method->isa('Class::MOP::Method');
  
      # still valid, since we just removed the method from the map
      $self->update_package_cache_flag;
  
      return $removed_method;
  }
  
  sub get_method_list {
      my $self = shift;
  
      return keys %{ $self->_full_method_map };
  }
  
  sub _get_local_methods {
      my $self = shift;
  
      return values %{ $self->_full_method_map };
  }
  
  sub _restore_metamethods_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      my $package_name = $self->name;
  
      # Check if Perl debugger is enabled
      my $debugger_enabled = ($^P & 0x10);
      my $debug_method_info;
  
      for my $method ($old_meta->_get_local_methods) {
          my $method_name = $method->name;
  
          # Track DB::sub information for this method if debugger is enabled.
          # This contains original method filename and line numbers.
          $debug_method_info = '';
          if ($debugger_enabled) {
              $debug_method_info = $DB::sub{$package_name . "::" . $method_name}
          }
  
          $method->_make_compatible_with($self->method_metaclass);
          $self->add_method($method_name => $method);
  
          # Restore method debug information, which can be clobbered by add_method.
          # Note that we handle this here instead of in add_method, because we
          # only want to preserve the original debug info in cases where we are
          # restoring a method, not overwriting a method.
          if ($debugger_enabled && $debug_method_info) {
              $DB::sub{$package_name . "::" . $method_name} = $debug_method_info;
          }
      }
  }
  
  sub reset_package_cache_flag  { (shift)->{'_package_cache_flag'} = undef }
  sub update_package_cache_flag {
      my $self = shift;
      # NOTE:
      # we can manually update the cache number
      # since we are actually adding the method
      # to our cache as well. This avoids us
      # having to regenerate the method_map.
      # - SL
      $self->{'_package_cache_flag'} = Class::MOP::check_package_cache_flag($self->name);
  }
  
  sub _full_method_map {
      my $self = shift;
  
      my $pkg_gen = Class::MOP::check_package_cache_flag($self->name);
  
      if (($self->{_package_cache_flag_full} || -1) != $pkg_gen) {
          # forcibly reify all method map entries
          $self->get_method($_)
              for $self->list_all_package_symbols('CODE');
          $self->{_package_cache_flag_full} = $pkg_gen;
      }
  
      return $self->_method_map;
  }
  
  # overloading
  
  my $overload_operators;
  sub overload_operators {
      $overload_operators ||= [map { split /\s+/ } values %overload::ops];
      return @$overload_operators;
  }
  
  sub is_overloaded {
      my $self = shift;
      return overload::Overloaded($self->name);
  }
  
  # XXX this could probably stand to be cached, but i figure it should be
  # uncommon enough to not particularly matter
  sub _overload_map {
      my $self = shift;
  
      return {} unless $self->is_overloaded;
  
      my %map;
      for my $op ($self->overload_operators) {
          my $body = $self->_get_overloaded_operator_body($op);
          next unless defined $body;
          $map{$op} = $body;
      }
  
      return \%map;
  }
  
  sub get_overload_list {
      my $self = shift;
      return keys %{ $self->_overload_map };
  }
  
  sub get_all_overloaded_operators {
      my $self = shift;
      my $map = $self->_overload_map;
      return map { $self->_wrap_overload($_, $map->{$_}) } keys %$map;
  }
  
  sub has_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
      return defined $self->_get_overloaded_operator_body($op);
  }
  
  sub get_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
      my $body = $self->_get_overloaded_operator_body($op);
      return unless defined $body;
      return $self->_wrap_overload($op, $body);
  }
  
  sub add_overloaded_operator {
      my $self = shift;
      my ($op, $body) = @_;
      $self->name->overload::OVERLOAD($op => $body);
  }
  
  sub remove_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
  
      if ( $] < 5.018 ) {
          # ugh, overload.pm provides no api for this - but the problem that
          # makes this necessary has been fixed in 5.18
          $self->get_or_add_package_symbol('%OVERLOAD')->{dummy}++;
      }
  
      $self->remove_package_symbol('&(' . $op);
  }
  
  sub _get_overloaded_operator_body {
      my $self = shift;
      my ($op) = @_;
      return overload::Method($self->name, $op);
  }
  
  sub _wrap_overload {
      my $self = shift;
      my ($op, $body) = @_;
      return Class::MOP::Method::Overload->wrap(
          operator             => $op,
          package_name         => $self->name,
          associated_metaclass => $self,
          body                 => $body,
      );
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::HasMethods - Methods for metaclasses which have methods
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have methods
  (L<Class::MOP::Package> and L<Moose::Meta::Role>). See L<Class::MOP::Package>
  for API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MIXIN_HASMETHODS

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MODULE';
  
  package Class::MOP::Module;
  BEGIN {
    $Class::MOP::Module::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Module::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Package';
  
  use Moose::Util 'throw_exception';
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
      return bless {
          # Need to quote package to avoid a problem with PPI mis-parsing this
          # as a package statement.
  
          # from Class::MOP::Package
          'package' => $params->{package},
          namespace => \undef,
  
          # attributes
          version   => \undef,
          authority => \undef
      } => $class;
  }
  
  sub version {
      my $self = shift;
      ${$self->get_or_add_package_symbol('$VERSION')};
  }
  
  sub authority {
      my $self = shift;
      ${$self->get_or_add_package_symbol('$AUTHORITY')};
  }
  
  sub identifier {
      my $self = shift;
      join '-' => (
          $self->name,
          ($self->version   || ()),
          ($self->authority || ()),
      );
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      my $package   = delete $options{package};
      my $version   = delete $options{version};
      my $authority = delete $options{authority};
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_instantiate_module($version, $authority);
  
      return $meta;
  }
  
  sub _anon_package_prefix { 'Class::MOP::Module::__ANON__::SERIAL::' }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
      throw_exception( PackagesAndModulesAreNotCachable => class_name => $class,
                                                           params     => \%options,
                                                           is_module  => 1
                     );
  }
  
  sub _instantiate_module {
      my($self, $version, $authority) = @_;
      my $package_name = $self->name;
  
      $self->add_package_symbol('$VERSION' => $version)
          if defined $version;
      $self->add_package_symbol('$AUTHORITY' => $authority)
          if defined $authority;
  
      return;
  }
  
  1;
  
  # ABSTRACT: Module Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Module - Module Meta Object
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  A module is essentially a L<Class::MOP::Package> with metadata, in our
  case the version and authority.
  
  =head1 INHERITANCE
  
  B<Class::MOP::Module> is a subclass of L<Class::MOP::Package>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Module->create($package, %options) >>
  
  Overrides C<create> from L<Class::MOP::Package> to provide these additional
  options:
  
  =over 4
  
  =item C<version>
  
  A version number, to be installed in the C<$VERSION> package global variable.
  
  =item C<authority>
  
  An authority, to be installed in the C<$AUTHORITY> package global variable.
  
  =back
  
  =item B<< $metamodule->version >>
  
  This is a read-only attribute which returns the C<$VERSION> of the
  package, if one exists.
  
  =item B<< $metamodule->authority >>
  
  This is a read-only attribute which returns the C<$AUTHORITY> of the
  package, if one exists.
  
  =item B<< $metamodule->identifier >>
  
  This constructs a string which combines the name, version and
  authority.
  
  =item B<< Class::MOP::Module->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_MODULE

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_OBJECT';
  
  package Class::MOP::Object;
  BEGIN {
    $Class::MOP::Object::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Object::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  # introspection
  
  sub throw_error {
      shift;
      require Moose::Util;
      Moose::Util::throw_exception( Legacy => message => join('', @_) );
  }
  
  sub _inline_throw_error {
      my ( $self, $message ) = @_;
      return 'Moose->throw_error('.$message.')';
  }
  
  sub meta {
      require Class::MOP::Class;
      Class::MOP::Class->initialize(blessed($_[0]) || $_[0]);
  }
  
  sub _new {
      Class::MOP::class_of(shift)->new_object(@_);
  }
  
  # RANT:
  # Cmon, how many times have you written
  # the following code while debugging:
  #
  #  use Data::Dumper;
  #  warn Dumper $obj;
  #
  # It can get seriously annoying, so why
  # not just do this ...
  sub dump {
      my $self = shift;
      require Data::Dumper;
      local $Data::Dumper::Maxdepth = shift || 1;
      Data::Dumper::Dumper $self;
  }
  
  sub _real_ref_name {
      my $self = shift;
      return blessed($self);
  }
  
  sub _is_compatible_with {
      my $self = shift;
      my ($other_name) = @_;
  
      return $self->isa($other_name);
  }
  
  sub _can_be_made_compatible_with {
      my $self = shift;
      return !$self->_is_compatible_with(@_)
          && defined($self->_get_compatible_metaclass(@_));
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other_name) = @_;
  
      my $new_metaclass = $self->_get_compatible_metaclass($other_name);
  
      unless ( defined $new_metaclass ) {
          require Moose::Util;
          Moose::Util::throw_exception( CannotMakeMetaclassCompatible => superclass_name => $other_name,
                                                                         class           => $self,
                                      );
      }
  
      # can't use rebless_instance here, because it might not be an actual
      # subclass in the case of, e.g. moose role reconciliation
      $new_metaclass->meta->_force_rebless_instance($self)
          if blessed($self) ne $new_metaclass;
  
      return $self;
  }
  
  sub _get_compatible_metaclass {
      my $self = shift;
      my ($other_name) = @_;
  
      return $self->_get_compatible_metaclass_by_subclassing($other_name);
  }
  
  sub _get_compatible_metaclass_by_subclassing {
      my $self = shift;
      my ($other_name) = @_;
      my $meta_name = blessed($self) ? $self->_real_ref_name : $self;
  
      if ($meta_name->isa($other_name)) {
          return $meta_name;
      }
      elsif ($other_name->isa($meta_name)) {
          return $other_name;
      }
  
      return;
  }
  
  1;
  
  # ABSTRACT: Base class for metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Object - Base class for metaclasses
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a very minimal base class for metaclasses.
  
  =head1 METHODS
  
  This class provides a few methods which are useful in all metaclasses.
  
  =over 4
  
  =item B<< Class::MOP::???->meta >>
  
  This returns a L<Class::MOP::Class> object.
  
  =item B<< $metaobject->dump($max_depth) >>
  
  This method uses L<Data::Dumper> to dump the object. You can pass an
  optional maximum depth, which will set C<$Data::Dumper::Maxdepth>. The
  default maximum depth is 1.
  
  =item B<< $metaclass->throw_error($message) >>
  
  This method calls L<Moose::Util::throw_exception> internally, with an object
  of class Moose::Exception::Legacy.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_OBJECT

$fatpacked{"x86_64-linux-thread-multi/Class/MOP/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_MOP_PACKAGE';
  
  package Class::MOP::Package;
  BEGIN {
    $Class::MOP::Package::AUTHORITY = 'cpan:STEVAN';
  }
  $Class::MOP::Package::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'reftype', 'weaken';
  use Carp         'confess';
  use Devel::GlobalDestruction 'in_global_destruction';
  use Module::Runtime 'module_notional_filename';
  use Package::Stash;
  
  use parent 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  # creation ...
  
  sub initialize {
      my ( $class, @args ) = @_;
  
      unshift @args, "package" if @args % 2;
  
      my %options = @args;
      my $package_name = delete $options{package};
  
      # we hand-construct the class until we can bootstrap it
      if ( my $meta = Class::MOP::get_metaclass_by_name($package_name) ) {
          return $meta;
      } else {
          my $meta = ( ref $class || $class )->_new({
              'package'   => $package_name,
              %options,
          });
          Class::MOP::store_metaclass_by_name($package_name, $meta);
  
          Class::MOP::weaken_metaclass($package_name) if $options{weaken};
  
  
          return $meta;
      }
  }
  
  sub reinitialize {
      my ( $class, @args ) = @_;
  
      unshift @args, "package" if @args % 2;
  
      my %options = @args;
      my $package_name = delete $options{package};
  
      (defined $package_name && $package_name
        && (!blessed $package_name || $package_name->isa('Class::MOP::Package')))
          || throw_exception( MustPassAPackageNameOrAnExistingClassMOPPackageInstance => params => \%options,
                                                                                         class  => $class
                            );
  
      $package_name = $package_name->name
          if blessed $package_name;
  
      Class::MOP::remove_metaclass_by_name($package_name);
  
      $class->initialize($package_name, %options); # call with first arg form for compat
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      my $meta = $class->initialize(@args);
      my $filename = module_notional_filename($meta->name);
      $INC{$filename} = '(set by Moose)'
          unless exists $INC{$filename};
  
      return $meta;
  }
  
  ## ANON packages
  
  {
      # NOTE:
      # this should be sufficient, if you have a
      # use case where it is not, write a test and
      # I will change it.
      my $ANON_SERIAL = 0;
  
      my %ANON_PACKAGE_CACHE;
  
      # NOTE:
      # we need a sufficiently annoying prefix
      # this should suffice for now, this is
      # used in a couple of places below, so
      # need to put it up here for now.
      sub _anon_package_prefix { 'Class::MOP::Package::__ANON__::SERIAL::' }
  
      sub is_anon {
          my $self = shift;
          no warnings 'uninitialized';
          my $prefix = $self->_anon_package_prefix;
          $self->name =~ /^\Q$prefix/;
      }
  
      sub create_anon {
          my ($class, %options) = @_;
  
          my $cache_ok = delete $options{cache};
          $options{weaken} = !$cache_ok unless exists $options{weaken};
  
          my $cache_key;
          if ($cache_ok) {
              $cache_key = $class->_anon_cache_key(%options);
              undef $cache_ok if !defined($cache_key);
          }
  
          if ($cache_ok) {
              if (defined $ANON_PACKAGE_CACHE{$cache_key}) {
                  return $ANON_PACKAGE_CACHE{$cache_key};
              }
          }
  
          my $package_name = $class->_anon_package_prefix . ++$ANON_SERIAL;
  
          my $meta = $class->create($package_name, %options);
  
          if ($cache_ok) {
              $ANON_PACKAGE_CACHE{$cache_key} = $meta;
              weaken($ANON_PACKAGE_CACHE{$cache_key});
          }
  
          return $meta;
      }
  
      sub _anon_cache_key {
          my $class = shift;
          my %options = @_;
          throw_exception( PackagesAndModulesAreNotCachable => class_name => $class,
                                                               params     => \%options,
                                                               is_module  => 0
                         );
      }
  
      sub DESTROY {
          my $self = shift;
  
          return if in_global_destruction(); # it'll happen soon anyway and this just makes things more complicated
  
          $self->_free_anon
              if $self->is_anon;
      }
  
      sub _free_anon {
          my $self = shift;
          my $name = $self->name;
  
          # Moose does a weird thing where it replaces the metaclass for
          # class when fixing metaclass incompatibility. In that case,
          # we don't want to clean out the namespace now. We can detect
          # that because Moose will explicitly update the singleton
          # cache in Class::MOP using store_metaclass_by_name, which
          # means that the new metaclass will already exist in the cache
          # by this point.
          # The other options here are that $current_meta can be undef if
          # remove_metaclass_by_name is called explicitly (since the hash
          # entry is removed first, and then this destructor is called),
          # or that $current_meta can be the same as $self, which happens
          # when the metaclass goes out of scope (since the weak reference
          # in the metaclass cache won't be freed until after this
          # destructor runs).
          my $current_meta = Class::MOP::get_metaclass_by_name($name);
          return if defined($current_meta) && $current_meta ne $self;
  
          my ($first_fragments, $last_fragment) = ($name =~ /^(.*)::(.*)$/);
  
          no strict 'refs';
          # clear @ISA first, to avoid a memory leak
          # see https://rt.perl.org/rt3/Public/Bug/Display.html?id=92708
          @{$name . '::ISA'} = ();
          %{$name . '::'}    = ();
          delete ${$first_fragments . '::'}{$last_fragment . '::'};
  
          Class::MOP::remove_metaclass_by_name($name);
  
          delete $INC{module_notional_filename($name)};
      }
  
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # Need to quote package to avoid a problem with PPI mis-parsing this
          # as a package statement.
          'package' => $params->{package},
  
          # NOTE:
          # because of issues with the Perl API
          # to the typeglob in some versions, we
          # need to just always grab a new
          # reference to the hash in the accessor.
          # Ideally we could just store a ref and
          # it would Just Work, but oh well :\
  
          namespace => \undef,
  
      } => $class;
  }
  
  # Attributes
  
  # NOTE:
  # all these attribute readers will be bootstrapped
  # away in the Class::MOP bootstrap section
  
  sub _package_stash {
      $_[0]->{_package_stash} ||= Package::Stash->new($_[0]->name)
  }
  sub namespace {
      $_[0]->_package_stash->namespace
  }
  
  # Class attributes
  
  # ... these functions have to touch the symbol table itself,.. yuk
  
  sub add_package_symbol {
      my $self = shift;
      $self->_package_stash->add_symbol(@_);
  }
  
  sub remove_package_glob {
      my $self = shift;
      $self->_package_stash->remove_glob(@_);
  }
  
  # ... these functions deal with stuff on the namespace level
  
  sub has_package_symbol {
      my $self = shift;
      $self->_package_stash->has_symbol(@_);
  }
  
  sub get_package_symbol {
      my $self = shift;
      $self->_package_stash->get_symbol(@_);
  }
  
  sub get_or_add_package_symbol {
      my $self = shift;
      $self->_package_stash->get_or_add_symbol(@_);
  }
  
  sub remove_package_symbol {
      my $self = shift;
      $self->_package_stash->remove_symbol(@_);
  }
  
  sub list_all_package_symbols {
      my $self = shift;
      $self->_package_stash->list_all_symbols(@_);
  }
  
  sub get_all_package_symbols {
      my $self = shift;
      $self->_package_stash->get_all_symbols(@_);
  }
  
  1;
  
  # ABSTRACT: Package Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Package - Package Meta Object
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  The Package Protocol provides an abstraction of a Perl 5 package. A
  package is basically namespace, and this module provides methods for
  looking at and changing that namespace's symbol table.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Package->initialize($package_name, %options) >>
  
  This method creates a new C<Class::MOP::Package> instance which
  represents specified package. If an existing metaclass object exists
  for the package, that will be returned instead. No options are valid at the
  package level.
  
  =item B<< Class::MOP::Package->reinitialize($package, %options) >>
  
  This method forcibly removes any existing metaclass for the package
  before calling C<initialize>. In contrast to C<initialize>, you may
  also pass an existing C<Class::MOP::Package> instance instead of just
  a package name as C<$package>.
  
  Do not call this unless you know what you are doing.
  
  =item B<< Class::MOP::Package->create($package, %options) >>
  
  Creates a new C<Class::MOP::Package> instance which represents the specified
  package, and also does some initialization of that package. Currently, this
  just does the same thing as C<initialize>, but is overridden in subclasses,
  such as C<Class::MOP::Class>.
  
  =item B<< Class::MOP::Package->create_anon(%options) >>
  
  Creates a new anonymous package. Valid keys for C<%options> are:
  
  =over 4
  
  =item C<cache>
  
  If this will be C<true> (the default is C<false>), the instance will be cached
  in C<Class::MOP>'s metaclass cache.
  
  =item C<weaken>
  
  If this is C<true> (the default C<true> when L<cache> is C<false>), the instance
  stored in C<Class::MOP>'s metaclass cache will be weakened, so that the
  anonymous package will be garbage collected when the returned instance goes out
  of scope.
  
  =back
  
  =item B<< $metapackage->is_anon >>
  
  Returns true if the package is an anonymous package.
  
  =item B<< $metapackage->name >>
  
  This is returns the package's name, as passed to the constructor.
  
  =item B<< $metapackage->namespace >>
  
  This returns a hash reference to the package's symbol table. The keys
  are symbol names and the values are typeglob references.
  
  =item B<< $metapackage->add_package_symbol($variable_name, $initial_value) >>
  
  This method accepts a variable name and an optional initial value. The
  C<$variable_name> must contain a leading sigil.
  
  This method creates the variable in the package's symbol table, and
  sets it to the initial value if one was provided.
  
  =item B<< $metapackage->get_package_symbol($variable_name) >>
  
  Given a variable name, this method returns the variable as a reference
  or undef if it does not exist. The C<$variable_name> must contain a
  leading sigil.
  
  =item B<< $metapackage->get_or_add_package_symbol($variable_name) >>
  
  Given a variable name, this method returns the variable as a reference.
  If it does not exist, a default value will be generated if possible. The
  C<$variable_name> must contain a leading sigil.
  
  =item B<< $metapackage->has_package_symbol($variable_name) >>
  
  Returns true if there is a package variable defined for
  C<$variable_name>. The C<$variable_name> must contain a leading sigil.
  
  =item B<< $metapackage->remove_package_symbol($variable_name) >>
  
  This will remove the package variable specified C<$variable_name>. The
  C<$variable_name> must contain a leading sigil.
  
  =item B<< $metapackage->remove_package_glob($glob_name) >>
  
  Given the name of a glob, this will remove that glob from the
  package's symbol table. Glob names do not include a sigil. Removing
  the glob removes all variables and subroutines with the specified
  name.
  
  =item B<< $metapackage->list_all_package_symbols($type_filter) >>
  
  This will list all the glob names associated with the current
  package. These names do not have leading sigils.
  
  You can provide an optional type filter, which should be one of
  'SCALAR', 'ARRAY', 'HASH', or 'CODE'.
  
  =item B<< $metapackage->get_all_package_symbols($type_filter) >>
  
  This works much like C<list_all_package_symbols>, but it returns a
  hash reference. The keys are glob names and the values are references
  to the value for that name.
  
  =item B<< Class::MOP::Package->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_MOP_PACKAGE

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR';
  package Class::XSAccessor;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor::Heavy;
  use XSLoader;
  
  our $VERSION = '1.19';
  
  XSLoader::load('Class::XSAccessor', $VERSION);
  
  sub _make_hash {
    my $ref = shift;
  
    if (ref ($ref)) {
      if (ref($ref) eq 'ARRAY') {
        $ref = { map { $_ => $_ } @$ref }
      } 
    } else {
      $ref = { $ref, $ref };
    }
  
    return $ref;
  }
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    # TODO: Refactor. Move more duplicated code to ::Heavy
    my $read_subs      = _make_hash($opts{getters} || {});
    my $set_subs       = _make_hash($opts{setters} || {});
    my $acc_subs       = _make_hash($opts{accessors} || {});
    my $lvacc_subs     = _make_hash($opts{lvalue_accessors} || {});
    my $pred_subs      = _make_hash($opts{predicates} || {});
    my $ex_pred_subs   = _make_hash($opts{exists_predicates} || {});
    my $def_pred_subs  = _make_hash($opts{defined_predicates} || {});
    my $test_subs      = _make_hash($opts{__tests__} || {});
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["test", $test_subs],
                          ["ex_predicate", $ex_pred_subs],
                          ["def_predicate", $def_pred_subs],
                          ["def_predicate", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $hashkey = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $hashkey, \%opts, $subtype->[0]);
      }
    }
  
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $hashkey, $opts, $type) = @_;
  
    croak("Cannot use undef as a hash key for generating an XS $type accessor. (Sub: $subname)")
      if not defined $hashkey;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $hashkey);
    }
    elsif ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $hashkey);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $hashkey, $opts->{chained}||0);
    }
    elsif ($type eq 'def_predicate') {
      newxs_defined_predicate($subname, $hashkey);
    }
    elsif ($type eq 'ex_predicate') {
      newxs_exists_predicate($subname, $hashkey);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      newxs_boolean($subname, 0);
    }
    elsif ($type eq 'test') {
      newxs_test($subname, $hashkey);
    }
    else {
      newxs_accessor($subname, $hashkey, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Class::XSAccessor
      replace     => 1,   # Replace existing methods (if any)
      constructor => 'new',
      getters     => {
        get_foo => 'foo', # 'foo' is the hash key to access
        get_bar => 'bar',
      },
      setters => {
        set_foo => 'foo',
        set_bar => 'bar',
      },
      accessors => {
        foo => 'foo',
        bar => 'bar',
      },
      # "predicates" is an alias for "defined_predicates"
      defined_predicates => {
        defined_foo => 'foo',
        defined_bar => 'bar',
      },
      exists_predicates => {
        has_foo => 'foo',
        has_bar => 'bar',
      },
      lvalue_accessors => { # see below
        baz => 'baz', # ...
      },
      true  => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference, if preferred,
    # which can also help Perl::Tidy to format the statement correctly.
    use Class::XSAccessor {
       # If the name => key values are always identical,
       # the following shorthand can be used.
       accessors => [ 'foo', 'bar' ],
    };
  
  =head1 DESCRIPTION
  
  Class::XSAccessor implements fast read, write and read/write accessors in XS.
  Additionally, it can provide predicates such as C<has_foo()> for testing
  whether the attribute C<foo> exists in the object (which is different from
  "is defined within the object").
  It only works with objects that are implemented as ordinary hashes.
  L<Class::XSAccessor::Array> implements the same interface for objects
  that use arrays for their internal representation.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS). Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless { @_ }, ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Parameters to C<new()> are added to the
  object.
  
  The XS accessor methods are between 3 and 4 times faster than typical
  pure-Perl accessors in some simple benchmarking.
  The lower factor applies to the potentially slightly obscure
  C<sub set_foo_pp {$_[0]-E<gt>{foo} = $_[1]}>, so if you usually
  write clear code, a factor of 3.5 speed-up is a good estimate.
  If in doubt, do your own benchmarking!
  
  The method names may be fully qualified. The example in the synopsis could
  have been written as C<MyClass::get_foo> instead
  of C<get_foo>. This way, methods can be installed in classes other
  than the current class. See also: the C<class> option below.
  
  By default, the setters return the new value that was set,
  and the accessors (mutators) do the same. This behaviour can be changed
  with the C<chained> option - see below. The predicates return a boolean.
  
  Since version 1.01, C<Class::XSAccessor> can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then consider a large class hierarchy
  with interfaces such as L<PPI>. These methods are provided by the C<true>
  and C<false> options - see the synopsis.
  
  C<defined_predicates> check whether a given object attribute is defined.
  C<predicates> is an alias for C<defined_predicates> for compatibility with
  older versions of C<Class::XSAccessor>. C<exists_predicates> checks
  whether the given attribute exists in the object using C<exists>.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, additional options
  can be supplied which modify behaviour. The options are specified as key/value pairs
  in the same manner as the accessor declaration. For example:
  
    use Class::XSAccessor
      getters => {
        get_foo => 'foo',
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. The
  the C<class> option allows the target class to be specified.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 'zip' };
    
    package main;
    my $address = Address->new(zip => 2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably won't work for objects based on I<tied> hashes. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  that's only known at run-time. Note that compiling C code at run-time a la L<Inline::C|Inline::C>
  is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed>. Previously, a small amount of
  memory would leak if C<Class::XSAccessor>-based classes were loaded in a subthread without having
  been loaded in the "main" thread. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation, as of 1.00, the memory will still not be released, in the same situation,
  but it will be recycled when the same class, or a similar class, is loaded again in B<any> thread.
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<Class::XSAccessor::Array>
  
  =item * L<AutoXS>
  
  =back
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_ARRAY';
  package Class::XSAccessor::Array;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor;
  use Class::XSAccessor::Heavy;
  
  our $VERSION = '1.19';
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    my $read_subs      = $opts{getters} || {};
    my $set_subs       = $opts{setters} || {};
    my $acc_subs       = $opts{accessors} || {};
    my $lvacc_subs     = $opts{lvalue_accessors} || {};
    my $pred_subs      = $opts{predicates} || {};
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];  
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["pred_subs", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $array_index = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $array_index, \%opts, $subtype->[0]);
      }
    }
     
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $array_index, $opts, $type) = @_;
  
    croak("Cannot use undef as a array index for generating an XS $type accessor. (Sub: $subname)")
      if not defined $array_index;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $array_index);
    }
    if ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $array_index);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $array_index, $opts->{chained}||0);
    }
    elsif ($type eq 'predicate') {
      newxs_predicate($subname, $array_index);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      Class::XSAccessor::newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      Class::XSAccessor::newxs_boolean($subname, 0);
    }
    else {
      newxs_accessor($subname, $array_index, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Array - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
    
    package MyClassUsingArraysAsInternalStorage;
    use Class::XSAccessor::Array
      constructor => 'new',
      getters => {
        get_foo => 0, # 0 is the array index to access
        get_bar => 1,
      },
      setters => {
        set_foo => 0,
        set_bar => 1,
      },
      accessors => { # a mutator
        buz => 2,
      },
      predicates => { # test for definedness
        has_buz => 2,
      },
      lvalue_accessors => { # see below
        baz => 3,
      },
      true => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference if you prefer it,
    # which can also help PerlTidy to flow the statement correctly.
    use Class::XSAccessor {
      getters => {
        get_foo => 0,
        get_bar => 1,
      },
    };
  
  =head1 DESCRIPTION
  
  The module implements fast XS accessors both for getting at and
  setting an object attribute. Additionally, the module supports
  mutators and simple predicates (C<has_foo()> like tests for definedness
  of an attributes).
  The module works only with objects
  that are implemented as B<arrays>. Using it on hash-based objects is
  bound to make your life miserable. Refer to L<Class::XSAccessor> for
  an implementation that works with hash-based objects.
  
  A simple benchmark showed a significant performance
  advantage over writing accessors in Perl.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS) for you. Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless [], ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Note that any parameters to new() will be
  discarded! If there is a better idiom for array-based objects, let
  me know.
  
  While generally more obscure than hash-based objects,
  objects using blessed arrays as internal representation
  are a bit faster as its somewhat faster to access arrays than hashes.
  Accordingly, this module is slightly faster (~10-15%) than
  L<Class::XSAccessor>, which works on hash-based objects.
  
  The method names may be fully qualified. In the example of the
  synopsis, you could have written C<MyClass::get_foo> instead
  of C<get_foo>. This way, you can install methods in classes other
  than the current class. See also: The C<class> option below.
  
  Since version 1.01, you can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then think of a large class hierarchy
  with interfaces such as PPI. This is implemented as the C<true>
  and C<false> options, see synopsis.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, you can add options
  which modify behaviour. The options are specified as key/value pairs just as the
  accessor declaration. Example:
  
    use Class::XSAccessor::Array
      getters => {
        get_foo => 0,
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor::Array> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor::Array ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. Using
  the C<class> option, you can explicitly specify where the methods
  are to be generated.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 0 };
    
    package main;
    my $address = Address->new(2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably wouldn't work if your objects are I<tied>. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  or array index that's only known at run-time. Note that compiling C code at run-time
  a la Inline::C is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed> that would leak a small amount of
  memory if you loaded C<Class::XSAccessor>-based classes in a subthread that hadn't been loaded
  in the "main" thread before. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation as of 1.00, the memory will not be released again either in the above
  situation. But it will be recycled when the same class or a similar class is loaded
  again in B<any> thread.
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  
  L<AutoXS>
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_ARRAY

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_HEAVY';
  package # hide from PAUSE
      Class::XSAccessor::Heavy;
  
  use 5.008;
  use strict;
  use warnings;
  use Carp;
  
  our $VERSION  = '1.19';
  our @CARP_NOT = qw(
          Class::XSAccessor
          Class::XSAccessor::Array
  );
  
  # TODO Move more duplicated code from XSA and XSA::Array here
  
  
  sub check_sub_existence {
    my $subname = shift;
  
    my $sub_package = $subname;
    $sub_package =~ s/([^:]+)$// or die;
    my $bare_subname = $1;
      
    my $sym;
    {
      no strict 'refs';
      $sym = \%{"$sub_package"};
    }
    no warnings;
    local *s = $sym->{$bare_subname};
    my $coderef = *s{CODE};
    if ($coderef) {
      $sub_package =~ s/::$//;
      Carp::croak("Cannot replace existing subroutine '$bare_subname' in package '$sub_package' with an XS implementation. If you wish to force a replacement, add the 'replace => 1' parameter to the arguments of 'use ".(caller())[0]."'.");
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Heavy - Guts you don't care about
  
  =head1 SYNOPSIS
    
    use Class::XSAccessor!
  
  =head1 DESCRIPTION
  
  Common guts for Class::XSAccessor and Class::XSAccessor::Array.
  No user-serviceable parts inside!
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  L<Class::XSAccessor::Array>
  
  =head1 AUTHOR
  
  Steffen Mueller, E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy, E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
  
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_HEAVY

$fatpacked{"x86_64-linux-thread-multi/JSON/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_JSON_SYCK';
  package JSON::Syck;
  use strict;
  use vars qw( $VERSION @EXPORT_OK @ISA );
  use Exporter;
  use YAML::Syck ();
  
  BEGIN {
      $VERSION   = '1.27';
      @EXPORT_OK = qw( Load Dump LoadFile DumpFile DumpInto );
      @ISA       = 'Exporter';
      *Load      = \&YAML::Syck::LoadJSON;
      *Dump      = \&YAML::Syck::DumpJSON;
  }
  
  sub DumpFile {
      my $file = shift;
      if ( YAML::Syck::_is_glob($file) ) {
          my $err = YAML::Syck::DumpJSONFile( $_[0], $file );
          if ($err) {
              $! = 0 + $err;
              die "Error writing to filehandle $file: $!\n";
          }
      }
      else {
          open( my $fh, '>', $file ) or die "Cannot write to $file: $!";
          my $err = YAML::Syck::DumpJSONFile( $_[0], $fh );
          if ($err) {
              $! = 0 + $err;
              die "Error writing to file $file: $!\n";
          }
          close $fh
            or die "Error writing to file $file: $!\n";
      }
      return 1;
  }
  
  sub LoadFile {
      my $file = shift;
      if ( YAML::Syck::_is_glob($file) ) {
          YAML::Syck::LoadJSON(
              do { local $/; <$file> }
          );
      }
      else {
          if ( !-e $file || -z $file ) {
              die("'$file' is non-existent or empty");
          }
          open( my $fh, '<', $file ) or die "Cannot read from $file: $!";
          YAML::Syck::LoadJSON(
              do { local $/; <$fh> }
          );
      }
  }
  
  sub DumpInto {
      my $bufref = shift;
      ( ref $bufref ) or die "DumpInto not given reference to output buffer\n";
      YAML::Syck::DumpJSONInto( $_[0], $bufref );
      1;
  }
  
  $JSON::Syck::ImplicitTyping  = 1;
  $JSON::Syck::MaxDepth        = 512;
  $JSON::Syck::Headless        = 1;
  $JSON::Syck::ImplicitUnicode = 0;
  $JSON::Syck::SingleQuote     = 0;
  
  1;
  
  __END__
  
  =head1 NAME
  
  JSON::Syck - JSON is YAML (but consider using L<JSON::XS> instead!)
  
  =head1 SYNOPSIS
  
      use JSON::Syck; # no exports by default 
  
      my $data = JSON::Syck::Load($json);
      my $json = JSON::Syck::Dump($data);
  
      # $file can be an IO object, or a filename
      my $data = JSON::Syck::LoadFile($file);
      JSON::Syck::DumpFile($file, $data);
  
      # Dump into a pre-existing buffer
      my $json;
      JSON::Syck::DumpInto(\$json, $data);
  
  =head1 DESCRIPTION
  
  JSON::Syck is a syck implementation of JSON parsing and generation. Because
  JSON is YAML (L<http://redhanded.hobix.com/inspect/yamlIsJson.html>), using
  syck gives you a fast and memory-efficient parser and dumper for JSON data
  representation.
  
  However, a newer module L<JSON::XS>, has since emerged.  It is more flexible,
  efficient and robust, so please consider using it instead of this module.
  
  =head1 DIFFERENCE WITH JSON
  
  You might want to know the difference between the I<JSON> module and
  this one.
  
  Since JSON is a pure-perl module and JSON::Syck is based on libsyck,
  JSON::Syck is supposed to be very fast and memory efficient. See
  chansen's benchmark table at
  L<http://idisk.mac.com/christian.hansen/Public/perl/serialize.pl>
  
  JSON.pm comes with dozens of ways to do the same thing and lots of
  options, while JSON::Syck doesn't. There's only C<Load> and C<Dump>.
  
  Oh, and JSON::Syck doesn't use camelCase method names :-)
  
  =head1 REFERENCES
  
  =head2 SCALAR REFERENCE
  
  For now, when you pass a scalar reference to JSON::Syck, it
  dereferences to get the actual scalar value.
  
  JSON::Syck raises an exception when you pass in circular references.
  
  If you want to serialize self refernecing stuff, you should use
  YAML which supports it.
  
  =head2 SUBROUTINE REFERENCE
  
  When you pass subroutine reference, JSON::Syck dumps it as null.
  
  =head1 UTF-8 FLAGS
  
  By default this module doesn't touch any of utf-8 flags set in
  strings, and assumes UTF-8 bytes to be passed and emit.
  
  However, when you set C<$JSON::Syck::ImplicitUnicode> to 1, this
  module properly decodes UTF-8 binaries and sets UTF-8 flag everywhere,
  as in:
  
    JSON (UTF-8 bytes)   => Perl (UTF-8 flagged)
    JSON (UTF-8 flagged) => Perl (UTF-8 flagged)
    Perl (UTF-8 bytes)   => JSON (UTF-8 flagged)
    Perl (UTF-8 flagged) => JSON (UTF-8 flagged)
  
  By default, JSON::Syck::Dump will only transverse up to 512 levels of
  a datastructure in order to avoid an infinite loop when it is
  presented with an circular reference.
  
  However, you set C<$JSON::Syck::MaxLevels> to a larger value if you
  have very complex structures.
  
  Unfortunately, there's no implicit way to dump Perl UTF-8 flagged data
  structure to utf-8 encoded JSON. To do this, simply use Encode module, e.g.:
  
    use Encode;
    use JSON::Syck qw(Dump);
  
    my $json = encode_utf8( Dump($data) );
  
  Alternatively you can use Encode::JavaScript::UCS to encode Unicode
  strings as in I<%uXXXX> form.
  
    use Encode;
    use Encode::JavaScript::UCS;
    use JSON::Syck qw(Dump);
  
    my $json_unicode_escaped = encode( 'JavaScript-UCS', Dump($data) );
  
  =head1 QUOTING
  
  According to the JSON specification, all JSON strings are to be double-quoted.
  However, when embedding JavaScript in HTML attributes, it may be more
  convenient to use single quotes.
  
  Set C<$JSON::Syck::SingleQuote> to 1 will make both C<Dump> and C<Load> expect
  single-quoted string literals.
  
  =head1 BUGS
  
  Dumping into tied (or other magic variables) with C<DumpInto> might not work
  properly in all cases.
  
  When dumping with C<DumpFile>, some spacing might be wrong and
  C<$JSON::Syck::SingleQuote> might be handled incorrectly.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<YAML::Syck>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  Tatsuhiko Miyagawa E<lt>miyagawa@gmail.comE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005-2009 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  The F<libsyck> code bundled with this library is released by
  "why the lucky stiff", under a BSD-style license.  See the F<COPYING>
  file for details.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
X86_64-LINUX-THREAD-MULTI_JSON_SYCK

$fatpacked{"x86_64-linux-thread-multi/List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_MOREUTILS';
  package List::MoreUtils;
  
  use 5.00503;
  use strict;
  use Exporter   ();
  use DynaLoader ();
  
  use vars qw{ $VERSION @ISA @EXPORT_OK %EXPORT_TAGS };
  BEGIN {
      $VERSION   = '0.33';
      # $VERSION   = eval $VERSION;
      @ISA       = qw{ Exporter DynaLoader };
      @EXPORT_OK = qw{
          any all none notall true false
          firstidx first_index lastidx last_index
          insert_after insert_after_string
          apply indexes
          after after_incl before before_incl
          firstval first_value lastval last_value
          each_array each_arrayref
          pairwise natatime
          mesh zip uniq distinct
          minmax part
      };
      %EXPORT_TAGS = (
          all => \@EXPORT_OK,
      );
  
      # Load the XS at compile-time so that redefinition warnings will be
      # thrown correctly if the XS versions of part or indexes loaded
      eval {
          # PERL_DL_NONLAZY must be false, or any errors in loading will just
          # cause the perl code to be tested
          local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  
          bootstrap List::MoreUtils $VERSION;
          1;
  
      } unless $ENV{LIST_MOREUTILS_PP};
  }
  
  eval <<'END_PERL' unless defined &any;
  
  # Use pure scalar boolean return values for compatibility with XS
  use constant YES => ! 0;
  use constant NO  => ! 1;
  
  sub any (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return YES if $f->();
      }
      return NO;
  }
  
  sub all (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return NO unless $f->();
      }
      return YES;
  }
  
  sub none (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return NO if $f->();
      }
      return YES;
  }
  
  sub notall (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return YES unless $f->();
      }
      return NO;
  }
  
  sub true (&@) {
      my $f     = shift;
      my $count = 0;
      foreach ( @_ ) {
          $count++ if $f->();
      }
      return $count;
  }
  
  sub false (&@) {
      my $f     = shift;
      my $count = 0;
      foreach ( @_ ) {
          $count++ unless $f->();
      }
      return $count;
  }
  
  sub firstidx (&@) {
      my $f = shift;
      foreach my $i ( 0 .. $#_ ) {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastidx (&@) {
      my $f = shift;
      foreach my $i ( reverse 0 .. $#_ ) {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub insert_after (&$\@) {
      my ($f, $val, $list) = @_;
      my $c = -1;
      local *_;
      foreach my $i ( 0 .. $#$list ) {
          $_ = $list->[$i];
          $c = $i, last if $f->();
      }
      @$list = (
          @{$list}[ 0 .. $c ],
          $val,
          @{$list}[ $c + 1 .. $#$list ],
      ) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@) {
      my ($string, $val, $list) = @_;
      my $c = -1;
      foreach my $i ( 0 .. $#$list ) {
          local $^W = 0;
          $c = $i, last if $string eq $list->[$i];
      }
      @$list = (
          @{$list}[ 0 .. $c ],
          $val,
          @{$list}[ $c + 1 .. $#$list ],
      ) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@) {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@) {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do {
          my $x = $lag;
          $lag = $test->();
          $x
      }, @_;
  }
  
  sub after_incl (&@) {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@) {
      my $test = shift;
      my $more = 1;
      grep $more &&= ! $test->(), @_;
  }
  
  sub before_incl (&@) {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do {
          my $x = $lag;
          $lag = ! $test->();
          $x
      }, @_;
  }
  
  sub indexes (&@) {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub lastval (&@) {
      my $test = shift;
      my $ix;
      for ( $ix = $#_; $ix >= 0; $ix-- ) {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub firstval (&@) {
      my $test = shift;
      foreach ( @_ ) {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub pairwise (&\@\@) {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local ( *A, *B ) = @_;
  
      # Localise $a, $b
      my ( $caller_a, $caller_b ) = do {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg.'::a'}, \*{$pkg.'::b'};
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B? $#A : $#B;
  
      # This map expression is also the return value
      local( *$caller_a, *$caller_b );
      map {
          # Assign to $a, $b as refs to caller's array elements
          ( *$caller_a, *$caller_b ) = \( $A[$_], $B[$_] );
  
          # Perform the transformation
          $op->();
      }  0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
      return each_arrayref(@_);
  }
  
  sub each_arrayref {
      my @list  = @_; # The list of references to the arrays
      my $index = 0;  # Which one the caller will get next
      my $max   = 0;  # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach ( @list ) {
          unless ( ref $_ eq 'ARRAY' ) {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if ( @_ ) {
              my $method = shift;
              unless ( $method eq 'index' ) {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0  ||  $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list; 
      }
  }
  
  sub natatime ($@) {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
      }
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
      my $max = -1;
      $max < $#$_ && ( $max = $#$_ ) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max; 
  }
  
  sub uniq (@) {
      my %seen = ();
      grep { not $seen{$_}++ } @_;
  }
  
  sub minmax (@) {
      return unless @_;
      my $min = my $max = $_[0];
  
      for ( my $i = 1; $i < @_; $i += 2 ) {
          if ( $_[$i-1] <= $_[$i] ) {
              $min = $_[$i-1] if $min > $_[$i-1];
              $max = $_[$i]   if $max < $_[$i];
          } else {
              $min = $_[$i]   if $min > $_[$i];
              $max = $_[$i-1] if $max < $_[$i-1];
          }
      }
  
      if ( @_ & 1 ) {
          my $i = $#_;
          if ($_[$i-1] <= $_[$i]) {
              $min = $_[$i-1] if $min > $_[$i-1];
              $max = $_[$i]   if $max < $_[$i];
          } else {
              $min = $_[$i]   if $min > $_[$i];
              $max = $_[$i-1] if $max < $_[$i-1];
          }
      }
  
      return ($min, $max);
  }
  
  sub part (&@) {
      my ($code, @list) = @_;
      my @parts;
      push @{ $parts[ $code->($_) ] }, $_  foreach @list;
      return @parts;
  }
  
  sub _XScompiled {
      return 0;
  }
  
  END_PERL
  die $@ if $@;
  
  # Function aliases
  *first_index = \&firstidx;
  *last_index  = \&lastidx;
  *first_value = \&firstval;
  *last_value  = \&lastval;
  *zip         = \&mesh;
  *distinct    = \&uniq;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils - Provide the stuff missing in List::Util
  
  =head1 SYNOPSIS
  
      use List::MoreUtils qw{
          any all none notall true false
          firstidx first_index lastidx last_index
          insert_after insert_after_string
          apply indexes
          after after_incl before before_incl
          firstval first_value lastval last_value
          each_array each_arrayref
          pairwise natatime
          mesh zip uniq distinct minmax part
      };
  
  =head1 DESCRIPTION
  
  B<List::MoreUtils> provides some trivial but commonly needed functionality on
  lists which is not going to go into L<List::Util>.
  
  All of the below functions are implementable in only a couple of lines of Perl
  code. Using the functions from this module however should give slightly better
  performance as everything is implemented in C. The pure-Perl implementation of
  these functions only serves as a fallback in case the C portions of this module
  couldn't be compiled on this machine.
  
  =over 4
  
  =item any BLOCK LIST
  
  Returns a true value if any item in LIST meets the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
      print "At least one value undefined"
          if any { ! defined($_) } @list;
  
  Returns false otherwise, or if LIST is empty.
  
  =item all BLOCK LIST
  
  Returns a true value if all items in LIST meet the criterion given through
  BLOCK, or if LIST is empty. Sets C<$_> for each item in LIST in turn:
  
      print "All items defined"
          if all { defined($_) } @list;
  
  Returns false otherwise.
  
  =item none BLOCK LIST
  
  Logically the negation of C<any>. Returns a true value if no item in LIST meets
  the criterion given through BLOCK, or if LIST is empty. Sets C<$_> for each item
  in LIST in turn:
  
      print "No value defined"
          if none { defined($_) } @list;
  
  Returns false otherwise.
  
  =item notall BLOCK LIST
  
  Logically the negation of C<all>. Returns a true value if not all items in LIST
  meet the criterion given through BLOCK. Sets C<$_> for each item in LIST in
  turn:
  
      print "Not all values defined"
          if notall { defined($_) } @list;
  
  Returns false otherwise, or if LIST is empty.
  
  =item true BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is true.
  Sets C<$_> for  each item in LIST in turn:
  
      printf "%i item(s) are defined", true { defined($_) } @list;
  
  =item false BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is false.
  Sets C<$_> for each item in LIST in turn:
  
      printf "%i item(s) are not defined", false { defined($_) } @list;
  
  =item firstidx BLOCK LIST
  
  =item first_index BLOCK LIST
  
  Returns the index of the first element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 4, 3, 2, 4, 6);
      printf "item with index %i in list is 4", firstidx { $_ == 4 } @list;
      __END__
      item with index 1 in list is 4
      
  Returns C<-1> if no such item could be found.
  
  C<first_index> is an alias for C<firstidx>.
  
  =item lastidx BLOCK LIST
  
  =item last_index BLOCK LIST
  
  Returns the index of the last element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 4, 3, 2, 4, 6);
      printf "item with index %i in list is 4", lastidx { $_ == 4 } @list;
      __END__
      item with index 4 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<last_index> is an alias for C<lastidx>.
  
  =item insert_after BLOCK VALUE LIST
  
  Inserts VALUE after the first item in LIST for which the criterion in BLOCK is
  true. Sets C<$_> for each item in LIST in turn.
  
      my @list = qw/This is a list/;
      insert_after { $_ eq "a" } "longer" => @list;
      print "@list";
      __END__
      This is a longer list
  
  =item insert_after_string STRING VALUE LIST
  
  Inserts VALUE after the first item in LIST which is equal to STRING. 
  
      my @list = qw/This is a list/;
      insert_after_string "a", "longer" => @list;
      print "@list";
      __END__
      This is a longer list
  
  =item apply BLOCK LIST
  
  Applies BLOCK to each item in LIST and returns a list of the values after BLOCK
  has been applied. In scalar context, the last element is returned.  This
  function is similar to C<map> but will not modify the elements of the input
  list:
  
      my @list = (1 .. 4);
      my @mult = apply { $_ *= 2 } @list;
      print "\@list = @list\n";
      print "\@mult = @mult\n";
      __END__
      @list = 1 2 3 4
      @mult = 2 4 6 8
  
  Think of it as syntactic sugar for
  
      for (my @mult = @list) { $_ *= 2 }
  
  =item before BLOCK LIST
  
  Returns a list of values of LIST upto (and not including) the point where BLOCK
  returns a true value. Sets C<$_> for each element in LIST in turn.
  
  =item before_incl BLOCK LIST
  
  Same as C<before> but also includes the element for which BLOCK is true.
  
  =item after BLOCK LIST
  
  Returns a list of the values of LIST after (and not including) the point
  where BLOCK returns a true value. Sets C<$_> for each element in LIST in turn.
  
      @x = after { $_ % 5 == 0 } (1..9);    # returns 6, 7, 8, 9
  
  =item after_incl BLOCK LIST
  
  Same as C<after> but also inclues the element for which BLOCK is true.
  
  =item indexes BLOCK LIST
  
  Evaluates BLOCK for each element in LIST (assigned to C<$_>) and returns a list
  of the indices of those elements for which BLOCK returned a true value. This is
  just like C<grep> only that it returns indices instead of values:
  
      @x = indexes { $_ % 2 == 0 } (1..10);   # returns 1, 3, 5, 7, 9
  
  =item firstval BLOCK LIST
  
  =item first_value BLOCK LIST
  
  Returns the first element in LIST for which BLOCK evaluates to true. Each
  element of LIST is set to C<$_> in turn. Returns C<undef> if no such element
  has been found.
  
  C<first_val> is an alias for C<firstval>.
  
  =item lastval BLOCK LIST
  
  =item last_value BLOCK LIST
  
  Returns the last value in LIST for which BLOCK evaluates to true. Each element
  of LIST is set to C<$_> in turn. Returns C<undef> if no such element has been
  found.
  
  C<last_val> is an alias for C<lastval>.
  
  =item pairwise BLOCK ARRAY1 ARRAY2
  
  Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a
  new list consisting of BLOCK's return values. The two elements are set to C<$a>
  and C<$b>.  Note that those two are aliases to the original value so changing
  them will modify the input arrays.
  
      @a = (1 .. 5);
      @b = (11 .. 15);
      @x = pairwise { $a + $b } @a, @b;	# returns 12, 14, 16, 18, 20
  
      # mesh with pairwise
      @a = qw/a b c/;
      @b = qw/1 2 3/;
      @x = pairwise { ($a, $b) } @a, @b;	# returns a, 1, b, 2, c, 3
  
  =item each_array ARRAY1 ARRAY2 ...
  
  Creates an array iterator to return the elements of the list of arrays ARRAY1,
  ARRAY2 throughout ARRAYn in turn.  That is, the first time it is called, it
  returns the first element of each array.  The next time, it returns the second
  elements.  And so on, until all elements are exhausted.
  
  This is useful for looping over more than one array at once:
  
      my $ea = each_array(@a, @b, @c);
      while ( my ($a, $b, $c) = $ea->() )   { .... }
  
  The iterator returns the empty list when it reached the end of all arrays.
  
  If the iterator is passed an argument of 'C<index>', then it retuns
  the index of the last fetched set of values, as a scalar.
  
  =item each_arrayref LIST
  
  Like each_array, but the arguments are references to arrays, not the
  plain arrays.
  
  =item natatime EXPR, LIST
  
  Creates an array iterator, for looping over an array in chunks of
  C<$n> items at a time.  (n at a time, get it?).  An example is
  probably a better explanation than I could give in words.
  
  Example:
  
      my @x = ('a' .. 'g');
      my $it = natatime 3, @x;
      while (my @vals = $it->())
      {
          print "@vals\n";
      }
  
  This prints
  
      a b c
      d e f
      g
  
  =item mesh ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  =item zip ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  Returns a list consisting of the first elements of each array, then
  the second, then the third, etc, until all arrays are exhausted.
  
  Examples:
  
      @x = qw/a b c d/;
      @y = qw/1 2 3 4/;
      @z = mesh @x, @y;	    # returns a, 1, b, 2, c, 3, d, 4
  
      @a = ('x');
      @b = ('1', '2');
      @c = qw/zip zap zot/;
      @d = mesh @a, @b, @c;   # x, 1, zip, undef, 2, zap, undef, undef, zot
  
  C<zip> is an alias for C<mesh>.
  
  =item uniq LIST
  
  =item distinct LIST
  
  Returns a new list by stripping duplicate values in LIST. The order of
  elements in the returned list is the same as in LIST. In scalar context,
  returns the number of unique elements in LIST.
  
      my @x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 1 2 3 5 4
      my $x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 5
  
  =item minmax LIST
  
  Calculates the minimum and maximum of LIST and returns a two element list with
  the first element being the minimum and the second the maximum. Returns the
  empty list if LIST was empty.
  
  The C<minmax> algorithm differs from a naive iteration over the list where each
  element is compared to two values being the so far calculated min and max value
  in that it only requires 3n/2 - 2 comparisons. Thus it is the most efficient
  possible algorithm.
  
  However, the Perl implementation of it has some overhead simply due to the fact
  that there are more lines of Perl code involved. Therefore, LIST needs to be
  fairly big in order for C<minmax> to win over a naive implementation. This
  limitation does not apply to the XS version.
  
  =item part BLOCK LIST
  
  Partitions LIST based on the return value of BLOCK which denotes into which
  partition the current value is put.
  
  Returns a list of the partitions thusly created. Each partition created is a
  reference to an array.
  
      my $i = 0;
      my @part = part { $i++ % 2 } 1 .. 8;   # returns [1, 3, 5, 7], [2, 4, 6, 8]
  
  You can have a sparse list of partitions as well where non-set partitions will
  be undef:
  
      my @part = part { 2 } 1 .. 10;	    # returns undef, undef, [ 1 .. 10 ]
  
  Be careful with negative values, though:
  
      my @part = part { -1 } 1 .. 10;
      __END__
      Modification of non-creatable array value attempted, subscript -1 ...
  
  Negative values are only ok when they refer to a partition previously created:
  
      my @idx  = ( 0, 1, -1 );
      my $i    = 0;
      my @part = part { $idx[$++ % 3] } 1 .. 8; # [1, 4, 7], [2, 3, 5, 6, 8]
  
  =back
  
  =head1 EXPORTS
  
  Nothing by default. To import all of this module's symbols, do the conventional
  
      use List::MoreUtils ':all';
  
  It may make more sense though to only import the stuff your program actually
  needs:
  
      use List::MoreUtils qw{ any firstidx };
  
  =head1 ENVIRONMENT
  
  When C<LIST_MOREUTILS_PP> is set, the module will always use the pure-Perl
  implementation and not the XS one. This environment variable is really just
  there for the test-suite to force testing the Perl implementation, and possibly
  for reporting of bugs. I don't see any reason to use it in a production
  environment.
  
  =head1 BUGS
  
  There is a problem with a bug in 5.6.x perls. It is a syntax error to write
  things like:
  
      my @x = apply { s/foo/bar/ } qw{ foo bar baz };
  
  It has to be written as either
  
      my @x = apply { s/foo/bar/ } 'foo', 'bar', 'baz';
  
  or
  
      my @x = apply { s/foo/bar/ } my @dummy = qw/foo bar baz/;
  
  Perl 5.5.x and Perl 5.8.x don't suffer from this limitation.
  
  If you have a functionality that you could imagine being in this module, please
  drop me a line. This module's policy will be less strict than L<List::Util>'s
  when it comes to additions as it isn't a core module.
  
  When you report bugs, it would be nice if you could additionally give me the
  output of your program with the environment variable C<LIST_MOREUTILS_PP> set
  to a true value. That way I know where to look for the problem (in XS,
  pure-Perl or possibly both).
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=List-MoreUtils>
  
  =head1 THANKS
  
  Credits go to a number of people: Steve Purkis for giving me namespace advice
  and James Keenan and Terrence Branno for their effort of keeping the CPAN
  tidier by making L<List::Utils> obsolete. 
  
  Brian McCauley suggested the inclusion of apply() and provided the pure-Perl
  implementation for it.
  
  Eric J. Roode asked me to add all functions from his module C<List::MoreUtil>
  into this one. With minor modifications, the pure-Perl implementations of those
  are by him.
  
  The bunch of people who almost immediately pointed out the many problems with
  the glitchy 0.07 release (Slaven Rezic, Ron Savage, CPAN testers).
  
  A particularly nasty memory leak was spotted by Thomas A. Lowery.
  
  Lars Thegler made me aware of problems with older Perl versions.
  
  Anno Siegel de-orphaned each_arrayref().
  
  David Filmer made me aware of a problem in each_arrayref that could ultimately
  lead to a segfault.
  
  Ricardo Signes suggested the inclusion of part() and provided the
  Perl-implementation.
  
  Robin Huston kindly fixed a bug in perl's MULTICALL API to make the
  XS-implementation of part() work.
  
  =head1 TODO
  
  A pile of requests from other people is still pending further processing in
  my mailbox. This includes:
  
  =over 4
  
  =item * List::Util export pass-through
  
  Allow B<List::MoreUtils> to pass-through the regular L<List::Util>
  functions to end users only need to C<use> the one module.
  
  =item * uniq_by(&@)
  
  Use code-reference to extract a key based on which the uniqueness is
  determined. Suggested by Aaron Crane.
  
  =item * delete_index
  
  =item * random_item
  
  =item * random_item_delete_index
  
  =item * list_diff_hash
  
  =item * list_diff_inboth
  
  =item * list_diff_infirst
  
  =item * list_diff_insecond
  
  These were all suggested by Dan Muey.
  
  =item * listify
  
  Always return a flat list when either a simple scalar value was passed or an
  array-reference. Suggested by Mark Summersault.
  
  =back
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8.4 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_MOREUTILS

$fatpacked{"x86_64-linux-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
    pairmap pairgrep pairfirst pairs pairkeys pairvalues
  );
  our $VERSION    = "1.38";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 $b = any { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 $b = all { BLOCK } @list
  
  Similar to C<any>, except that it requires all elements of the C<@list> to make
  the C<BLOCK> return true. If any element returns false, then it returns false.
  If the C<BLOCK> never returns false or the C<@list> was empty then it returns
  true.
  
  =head2 $b = none { BLOCK } @list
  
  =head2 $b = notall { BLOCK } @list
  
  Similar to C<any> and C<all>, but with the return sense inverted. C<none>
  returns true only if no value in the LIST causes the BLOCK to return true, and
  C<notall> returns true only if not all of the values do.
  
  =head2 $val = first { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 $num = max @list
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 $str = maxstr @list
  
  Similar to C<max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 $num = min @list
  
  Similar to C<max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 $str = minstr @list
  
  Similar to C<min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 $num = product @list
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 $num_or_undef = sum @list
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 $num = sum0 @list
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather than
  C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  =cut
  
  =head2 @kvlist = pairgrep { BLOCK } @kvlist
  
  =head2 $count = pairgrep { BLOCK } @kvlist
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 ( $key, $val ) = pairfirst { BLOCK } @kvlist
  
  =head2 $found = pairfirst { BLOCK } @kvlist
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @list = pairmap { BLOCK } @kvlist
  
  =head2 $count = pairmap { BLOCK } @kvlist
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @pairs = pairs @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of ARRAY references, each containing two items from the given
  list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 @keys = pairkeys @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 @values = pairvalues @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 @values = shuffle @values
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce will return
  an incorrect result. This will show up as test 7 of reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.38";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-thread-multi/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE';
  use strict;
  use warnings;
  package Moose;
  BEGIN {
    $Moose::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::VERSION = '2.1204';
  use 5.008003;
  
  use Scalar::Util 'blessed';
  use Carp         'carp', 'confess';
  use Module::Runtime 'module_notional_filename';
  use Class::Load  'is_class_loaded', 'load_class';
  
  use Moose::Deprecated;
  use Moose::Exporter;
  
  use Class::MOP;
  
  BEGIN {
      die "Class::MOP version $Moose::VERSION required--this is version $Class::MOP::VERSION"
          if $Moose::VERSION && $Class::MOP::VERSION ne $Moose::VERSION;
  }
  
  use Moose::Meta::Class;
  use Moose::Meta::TypeConstraint;
  use Moose::Meta::TypeCoercion;
  use Moose::Meta::Attribute;
  use Moose::Meta::Instance;
  
  use Moose::Object;
  
  use Moose::Meta::Role;
  use Moose::Meta::Role::Composite;
  use Moose::Meta::Role::Application;
  use Moose::Meta::Role::Application::RoleSummation;
  use Moose::Meta::Role::Application::ToClass;
  use Moose::Meta::Role::Application::ToRole;
  use Moose::Meta::Role::Application::ToInstance;
  
  use Moose::Util::TypeConstraints;
  use Moose::Util 'throw_exception';
  
  use Moose::Meta::Attribute::Native;
  
  sub extends {
      my $meta = shift;
  
      unless ( @_ )
      {
          throw_exception( ExtendsMissingArgs => class => $meta );
      }
      # this checks the metaclass to make sure
      # it is correct, sometimes it can get out
      # of sync when the classes are being built
      $meta->superclasses(@_);
  }
  
  sub with {
      Moose::Util::apply_all_roles(shift, @_);
  }
  
  sub throw_error {
      shift;
      Class::MOP::Object->throw_error(@_);
  }
  
  sub has {
      my $meta = shift;
      my $name = shift;
  
      my %context = Moose::Util::_caller_info;
      $context{context} = 'has declaration';
      $context{type} = 'class';
      my @options = ( definition_context => \%context, @_ );
      my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
      $meta->add_attribute( $_, @options ) for @$attrs;
  }
  
  sub before {
      Moose::Util::add_method_modifier(shift, 'before', \@_);
  }
  
  sub after {
      Moose::Util::add_method_modifier(shift, 'after', \@_);
  }
  
  sub around {
      Moose::Util::add_method_modifier(shift, 'around', \@_);
  }
  
  our $SUPER_PACKAGE;
  our $SUPER_BODY;
  our @SUPER_ARGS;
  
  sub super {
      if (@_) {
          carp 'Arguments passed to super() are ignored';
      }
  
      # This check avoids a recursion loop - see
      # t/bugs/super_recursion.t
      return if defined $SUPER_PACKAGE && $SUPER_PACKAGE ne caller();
      return unless $SUPER_BODY; $SUPER_BODY->(@SUPER_ARGS);
  }
  
  sub override {
      my $meta = shift;
      my ( $name, $method ) = @_;
      $meta->add_override_method_modifier( $name => $method );
  }
  
  sub inner {
      my $pkg = caller();
      our ( %INNER_BODY, %INNER_ARGS );
  
      if ( my $body = $INNER_BODY{$pkg} ) {
          my @args = @{ $INNER_ARGS{$pkg} };
          local $INNER_ARGS{$pkg};
          local $INNER_BODY{$pkg};
          return $body->(@args);
      } else {
          return;
      }
  }
  
  sub augment {
      my $meta = shift;
      my ( $name, $method ) = @_;
      $meta->add_augment_method_modifier( $name => $method );
  }
  
  Moose::Exporter->setup_import_methods(
      with_meta => [
          qw( extends with has before after around override augment )
      ],
      as_is => [
          qw( super inner ),
          \&Carp::confess,
          \&Scalar::Util::blessed,
      ],
  );
  
  sub init_meta {
      shift;
      my %args = @_;
  
      my $class = $args{for_class}
          or throw_exception( InitMetaRequiresClass => params => \%args );
  
      my $base_class = $args{base_class} || 'Moose::Object';
      my $metaclass  = $args{metaclass}  || 'Moose::Meta::Class';
      my $meta_name  = exists $args{meta_name} ? $args{meta_name} : 'meta';
  
      throw_exception( MetaclassNotLoaded => class_name => $metaclass )
          unless is_class_loaded($metaclass);
  
      throw_exception( MetaclassMustBeASubclassOfMooseMetaClass => class_name => $metaclass )
          unless $metaclass->isa('Moose::Meta::Class');
  
      # make a subtype for each Moose class
      class_type($class)
          unless find_type_constraint($class);
  
      my $meta;
  
      if ( $meta = Class::MOP::get_metaclass_by_name($class) ) {
          unless ( $meta->isa("Moose::Meta::Class") ) {
              if ( $meta->isa('Moose::Meta::Role') ) {
                  throw_exception( MetaclassIsARoleNotASubclassOfGivenMetaclass => role_name => $class,
                                                                                   metaclass => $metaclass,
                                                                                   role      => $meta
                                 );
              } else {
                  throw_exception( MetaclassIsNotASubclassOfGivenMetaclass => class_name => $class,
                                                                              metaclass  => $metaclass,
                                                                              class      => $meta
                                 );
              }
          }
      } else {
          # no metaclass
  
          # now we check whether our ancestors have metaclass, and if so borrow that
          my ( undef, @isa ) = @{ mro::get_linear_isa($class) };
  
          foreach my $ancestor ( @isa ) {
              my $ancestor_meta = Class::MOP::get_metaclass_by_name($ancestor) || next;
  
              my $ancestor_meta_class = $ancestor_meta->_real_ref_name;
  
              # if we have an ancestor metaclass that inherits $metaclass, we use
              # that. This is like _fix_metaclass_incompatibility, but we can do it now.
  
              # the case of having an ancestry is not very common, but arises in
              # e.g. Reaction
              unless ( $metaclass->isa( $ancestor_meta_class ) ) {
                  if ( $ancestor_meta_class->isa($metaclass) ) {
                      $metaclass = $ancestor_meta_class;
                  }
              }
          }
  
          $meta = $metaclass->initialize($class);
          my $filename = module_notional_filename($meta->name);
          $INC{$filename} = '(set by Moose)'
              unless exists $INC{$filename};
      }
  
      if (defined $meta_name) {
          # also check for inherited non moose 'meta' method?
          my $existing = $meta->get_method($meta_name);
          if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
              Carp::cluck "Moose is overwriting an existing method named "
                        . "$meta_name in class $class with a method "
                        . "which returns the class's metaclass. If this is "
                        . "actually what you want, you should remove the "
                        . "existing method, otherwise, you should rename or "
                        . "disable this generated method using the "
                        . "'-meta_name' option to 'use Moose'.";
          }
          $meta->_add_meta_method($meta_name);
      }
  
      # make sure they inherit from Moose::Object
      $meta->superclasses($base_class)
        unless $meta->superclasses();
  
      return $meta;
  }
  
  # This may be used in some older MooseX extensions.
  sub _get_caller {
      goto &Moose::Exporter::_get_caller;
  }
  
  ## make 'em all immutable
  
  $_->make_immutable(
      inline_constructor => 1,
      constructor_name   => "_new",
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { $_->meta }
      qw(
      Moose::Meta::Attribute
      Moose::Meta::Class
      Moose::Meta::Instance
  
      Moose::Meta::TypeCoercion
      Moose::Meta::TypeCoercion::Union
  
      Moose::Meta::Method
      Moose::Meta::Method::Constructor
      Moose::Meta::Method::Destructor
      Moose::Meta::Method::Overridden
      Moose::Meta::Method::Augmented
  
      Moose::Meta::Role
      Moose::Meta::Role::Attribute
      Moose::Meta::Role::Method
      Moose::Meta::Role::Method::Required
      Moose::Meta::Role::Method::Conflicting
  
      Moose::Meta::Role::Composite
  
      Moose::Meta::Role::Application
      Moose::Meta::Role::Application::RoleSummation
      Moose::Meta::Role::Application::ToClass
      Moose::Meta::Role::Application::ToRole
      Moose::Meta::Role::Application::ToInstance
  );
  
  $_->make_immutable(
      inline_constructor => 0,
      constructor_name   => undef,
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { $_->meta }
      qw(
      Moose::Meta::Method::Accessor
      Moose::Meta::Method::Delegation
      Moose::Meta::Mixin::AttributeCore
  );
  
  1;
  
  # ABSTRACT: A postmodern object system for Perl 5
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose - A postmodern object system for Perl 5
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package Point;
    use Moose; # automatically turns on strict and warnings
  
    has 'x' => (is => 'rw', isa => 'Int');
    has 'y' => (is => 'rw', isa => 'Int');
  
    sub clear {
        my $self = shift;
        $self->x(0);
        $self->y(0);
    }
  
    package Point3D;
    use Moose;
  
    extends 'Point';
  
    has 'z' => (is => 'rw', isa => 'Int');
  
    after 'clear' => sub {
        my $self = shift;
        $self->z(0);
    };
  
  =head1 DESCRIPTION
  
  Moose is an extension of the Perl 5 object system.
  
  The main goal of Moose is to make Perl 5 Object Oriented programming
  easier, more consistent, and less tedious. With Moose you can think
  more about what you want to do and less about the mechanics of OOP.
  
  Additionally, Moose is built on top of L<Class::MOP>, which is a
  metaclass system for Perl 5. This means that Moose not only makes
  building normal Perl 5 objects better, but it provides the power of
  metaclass programming as well.
  
  =head2 New to Moose?
  
  If you're new to Moose, the best place to start is the
  L<Moose::Manual> docs, followed by the L<Moose::Cookbook>. The intro
  will show you what Moose is, and how it makes Perl 5 OO better.
  
  The cookbook recipes on Moose basics will get you up to speed with
  many of Moose's features quickly. Once you have an idea of what Moose
  can do, you can use the API documentation to get more detail on
  features which interest you.
  
  =head2 Moose Extensions
  
  The C<MooseX::> namespace is the official place to find Moose extensions.
  These extensions can be found on the CPAN.  The easiest way to find them
  is to search for them (L<https://metacpan.org/search?q=MooseX::>),
  or to examine L<Task::Moose> which aims to keep an up-to-date, easily
  installable list of Moose extensions.
  
  =head1 TRANSLATIONS
  
  Much of the Moose documentation has been translated into other languages.
  
  =over 4
  
  =item Japanese
  
  Japanese docs can be found at
  L<http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html>. The
  source POD files can be found in GitHub:
  L<http://github.com/jpa/Moose-Doc-JA>
  
  =back
  
  =head1 BUILDING CLASSES WITH MOOSE
  
  Moose makes every attempt to provide as much convenience as possible during
  class construction/definition, but still stay out of your way if you want it
  to. Here are a few items to note when building classes with Moose.
  
  When you C<use Moose>, Moose will set the class's parent class to
  L<Moose::Object>, I<unless> the class using Moose already has a parent
  class. In addition, specifying a parent with C<extends> will change the parent
  class.
  
  Moose will also manage all attributes (including inherited ones) that are
  defined with C<has>. And (assuming you call C<new>, which is inherited from
  L<Moose::Object>) this includes properly initializing all instance slots,
  setting defaults where appropriate, and performing any type constraint checking
  or coercion.
  
  =head1 PROVIDED METHODS
  
  Moose provides a number of methods to all your classes, mostly through the
  inheritance of L<Moose::Object>. There is however, one exception.
  
  =over 4
  
  =item B<meta>
  
  This is a method which provides access to the current class's metaclass.
  
  =back
  
  =head1 EXPORTED FUNCTIONS
  
  Moose will export a number of functions into the class's namespace which
  may then be used to set up the class. These functions all work directly
  on the current class.
  
  =over 4
  
  =item B<extends (@superclasses)>
  
  This function will set the superclass(es) for the current class. If the parent
  classes are not yet loaded, then C<extends> tries to load them.
  
  This approach is recommended instead of C<use L<base>>/C<use L<parent>>, because
  C<use base> actually C<push>es onto the class's C<@ISA>, whereas C<extends> will
  replace it. This is important to ensure that classes which do not have
  superclasses still properly inherit from L<Moose::Object>.
  
  Each superclass can be followed by a hash reference with options. Currently,
  only L<-version|Class::MOP/Class Loading Options> is recognized:
  
      extends 'My::Parent'      => { -version => 0.01 },
              'My::OtherParent' => { -version => 0.03 };
  
  An exception will be thrown if the version requirements are not
  satisfied.
  
  =item B<with (@roles)>
  
  This will apply a given set of C<@roles> to the local class.
  
  Like with C<extends>, each specified role can be followed by a hash
  reference with a L<-version|Class::MOP/Class Loading Options> option:
  
      with 'My::Role'      => { -version => 0.32 },
           'My::Otherrole' => { -version => 0.23 };
  
  The specified version requirements must be satisfied, otherwise an
  exception will be thrown.
  
  If your role takes options or arguments, they can be passed along in the
  hash reference as well.
  
  =item B<has $name|@$names =E<gt> %options>
  
  This will install an attribute of a given C<$name> into the current class. If
  the first parameter is an array reference, it will create an attribute for
  every C<$name> in the list. The C<%options> will be passed to the constructor
  for L<Moose::Meta::Attribute> (which inherits from L<Class::MOP::Attribute>),
  so the full documentation for the valid options can be found there. These are
  the most commonly used options:
  
  =over 4
  
  =item I<is =E<gt> 'rw'|'ro'>
  
  The I<is> option accepts either I<rw> (for read/write) or I<ro> (for read
  only). These will create either a read/write accessor or a read-only
  accessor respectively, using the same name as the C<$name> of the attribute.
  
  If you need more control over how your accessors are named, you can
  use the L<reader|Class::MOP::Attribute/reader>,
  L<writer|Class::MOP::Attribute/writer> and
  L<accessor|Class::MOP::Attribute/accessor> options inherited from
  L<Class::MOP::Attribute>, however if you use those, you won't need the
  I<is> option.
  
  =item I<isa =E<gt> $type_name>
  
  The I<isa> option uses Moose's type constraint facilities to set up runtime
  type checking for this attribute. Moose will perform the checks during class
  construction, and within any accessors. The C<$type_name> argument must be a
  string. The string may be either a class name or a type defined using
  Moose's type definition features. (Refer to L<Moose::Util::TypeConstraints>
  for information on how to define a new type, and how to retrieve type meta-data).
  
  =item I<coerce =E<gt> (1|0)>
  
  This will attempt to use coercion with the supplied type constraint to change
  the value passed into any accessors or constructors. You B<must> supply a type
  constraint, and that type constraint B<must> define a coercion. See
  L<Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion> for an example.
  
  =item I<does =E<gt> $role_name>
  
  This will accept the name of a role which the value stored in this attribute
  is expected to have consumed.
  
  =item I<required =E<gt> (1|0)>
  
  This marks the attribute as being required. This means a value must be
  supplied during class construction, I<or> the attribute must be lazy
  and have either a default or a builder. Note that c<required> does not
  say anything about the attribute's value, which can be C<undef>.
  
  =item I<weak_ref =E<gt> (1|0)>
  
  This will tell the class to store the value of this attribute as a weakened
  reference. If an attribute is a weakened reference, it B<cannot> also be
  coerced. Note that when a weak ref expires, the attribute's value becomes
  undefined, and is still considered to be set for purposes of predicate,
  default, etc.
  
  =item I<lazy =E<gt> (1|0)>
  
  This will tell the class to not create this slot until absolutely necessary.
  If an attribute is marked as lazy it B<must> have a default or builder
  supplied.
  
  =item I<trigger =E<gt> $code>
  
  The I<trigger> option is a CODE reference which will be called after
  the value of the attribute is set. The CODE ref is passed the
  instance itself, the updated value, and the original value if the
  attribute was already set.
  
  You B<can> have a trigger on a read-only attribute.
  
  B<NOTE:> Triggers will only fire when you B<assign> to the attribute,
  either in the constructor, or using the writer. Default and built values will
  B<not> cause the trigger to be fired.
  
  =item I<handles =E<gt> ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE>
  
  The I<handles> option provides Moose classes with automated delegation features.
  This is a pretty complex and powerful option. It accepts many different option
  formats, each with its own benefits and drawbacks.
  
  B<NOTE:> The class being delegated to does not need to be a Moose based class,
  which is why this feature is especially useful when wrapping non-Moose classes.
  
  All I<handles> option formats share the following traits:
  
  You cannot override a locally defined method with a delegated method; an
  exception will be thrown if you try. That is to say, if you define C<foo> in
  your class, you cannot override it with a delegated C<foo>. This is almost never
  something you would want to do, and if it is, you should do it by hand and not
  use Moose.
  
  You cannot override any of the methods found in Moose::Object, or the C<BUILD>
  and C<DEMOLISH> methods. These will not throw an exception, but will silently
  move on to the next method in the list. My reasoning for this is that you would
  almost never want to do this, since it usually breaks your class. As with
  overriding locally defined methods, if you do want to do this, you should do it
  manually, not with Moose.
  
  You do not I<need> to have a reader (or accessor) for the attribute in order
  to delegate to it. Moose will create a means of accessing the value for you,
  however this will be several times B<less> efficient then if you had given
  the attribute a reader (or accessor) to use.
  
  Below is the documentation for each option format:
  
  =over 4
  
  =item C<ARRAY>
  
  This is the most common usage for I<handles>. You basically pass a list of
  method names to be delegated, and Moose will install a delegation method
  for each one.
  
  =item C<HASH>
  
  This is the second most common usage for I<handles>. Instead of a list of
  method names, you pass a HASH ref where each key is the method name you
  want installed locally, and its value is the name of the original method
  in the class being delegated to.
  
  This can be very useful for recursive classes like trees. Here is a
  quick example (soon to be expanded into a Moose::Cookbook recipe):
  
    package Tree;
    use Moose;
  
    has 'node' => (is => 'rw', isa => 'Any');
  
    has 'children' => (
        is      => 'ro',
        isa     => 'ArrayRef',
        default => sub { [] }
    );
  
    has 'parent' => (
        is          => 'rw',
        isa         => 'Tree',
        weak_ref    => 1,
        handles     => {
            parent_node => 'node',
            siblings    => 'children',
        }
    );
  
  In this example, the Tree package gets C<parent_node> and C<siblings> methods,
  which delegate to the C<node> and C<children> methods (respectively) of the Tree
  instance stored in the C<parent> slot.
  
  You may also use an array reference to curry arguments to the original method.
  
    has 'thing' => (
        ...
        handles => { set_foo => [ set => 'foo' ] },
    );
  
    # $self->set_foo(...) calls $self->thing->set('foo', ...)
  
  The first element of the array reference is the original method name, and the
  rest is a list of curried arguments.
  
  =item C<REGEXP>
  
  The regexp option works very similar to the ARRAY option, except that it builds
  the list of methods for you. It starts by collecting all possible methods of the
  class being delegated to, then filters that list using the regexp supplied here.
  
  B<NOTE:> An I<isa> option is required when using the regexp option format. This
  is so that we can determine (at compile time) the method list from the class.
  Without an I<isa> this is just not possible.
  
  =item C<ROLE> or C<ROLETYPE>
  
  With the role option, you specify the name of a role or a
  L<role type|Moose::Meta::TypeConstraint::Role> whose "interface" then becomes
  the list of methods to handle. The "interface" can be defined as; the methods
  of the role and any required methods of the role. It should be noted that this
  does B<not> include any method modifiers or generated attribute methods (which
  is consistent with role composition).
  
  =item C<DUCKTYPE>
  
  With the duck type option, you pass a duck type object whose "interface" then
  becomes the list of methods to handle. The "interface" can be defined as the
  list of methods passed to C<duck_type> to create a duck type object. For more
  information on C<duck_type> please check
  L<Moose::Util::TypeConstraints>.
  
  =item C<CODE>
  
  This is the option to use when you really want to do something funky. You should
  only use it if you really know what you are doing, as it involves manual
  metaclass twiddling.
  
  This takes a code reference, which should expect two arguments. The first is the
  attribute meta-object this I<handles> is attached to. The second is the
  metaclass of the class being delegated to. It expects you to return a hash (not
  a HASH ref) of the methods you want mapped.
  
  =back
  
  =item I<traits =E<gt> [ @role_names ]>
  
  This tells Moose to take the list of C<@role_names> and apply them to the
  attribute meta-object. Custom attribute metaclass traits are useful for
  extending the capabilities of the I<has> keyword: they are the simplest way to
  extend the MOP, but they are still a fairly advanced topic and too much to
  cover here.
  
  See L<Metaclass and Trait Name Resolution> for details on how a trait name is
  resolved to a role name.
  
  Also see L<Moose::Cookbook::Meta::Labeled_AttributeTrait> for a metaclass
  trait example.
  
  =item I<builder> => Str
  
  The value of this key is the name of the method that will be called to obtain
  the value used to initialize the attribute. See the L<builder option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/builder> and/or
  L<Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild> for more
  information.
  
  =item I<default> => SCALAR | CODE
  
  The value of this key is the default value which will initialize the attribute.
  
  NOTE: If the value is a simple scalar (string or number), then it can
  be just passed as is.  However, if you wish to initialize it with a
  HASH or ARRAY ref, then you need to wrap that inside a CODE reference.
  See the L<default option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/default> for more
  information.
  
  =item I<clearer> => Str
  
  Creates a method allowing you to clear the value. See the L<clearer option
  docs in Class::MOP::Attribute|Class::MOP::Attribute/clearer> for more
  information.
  
  =item I<predicate> => Str
  
  Creates a method to perform a basic test to see if a value has been set in the
  attribute. See the L<predicate option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/predicate> for more information.
  
  Note that the predicate will return true even for a C<weak_ref> attribute
  whose value has expired.
  
  =item I<documentation> => $string
  
  An arbitrary string that can be retrieved later by calling C<<
  $attr->documentation >>.
  
  =back
  
  =item B<has +$name =E<gt> %options>
  
  This is variation on the normal attribute creator C<has> which allows you to
  clone and extend an attribute from a superclass or from a role. Here is an
  example of the superclass usage:
  
    package Foo;
    use Moose;
  
    has 'message' => (
        is      => 'rw',
        isa     => 'Str',
        default => 'Hello, I am a Foo'
    );
  
    package My::Foo;
    use Moose;
  
    extends 'Foo';
  
    has '+message' => (default => 'Hello I am My::Foo');
  
  What is happening here is that B<My::Foo> is cloning the C<message> attribute
  from its parent class B<Foo>, retaining the C<is =E<gt> 'rw'> and C<isa =E<gt>
  'Str'> characteristics, but changing the value in C<default>.
  
  Here is another example, but within the context of a role:
  
    package Foo::Role;
    use Moose::Role;
  
    has 'message' => (
        is      => 'rw',
        isa     => 'Str',
        default => 'Hello, I am a Foo'
    );
  
    package My::Foo;
    use Moose;
  
    with 'Foo::Role';
  
    has '+message' => (default => 'Hello I am My::Foo');
  
  In this case, we are basically taking the attribute which the role supplied
  and altering it within the bounds of this feature.
  
  Note that you can only extend an attribute from either a superclass or a role,
  you cannot extend an attribute in a role that composes over an attribute from
  another role.
  
  Aside from where the attributes come from (one from superclass, the other
  from a role), this feature works exactly the same. This feature is restricted
  somewhat, so as to try and force at least I<some> sanity into it. Most options work the same, but there are some exceptions:
  
  =over 4
  
  =item I<reader>
  
  =item I<writer>
  
  =item I<accessor>
  
  =item I<clearer>
  
  =item I<predicate>
  
  These options can be added, but cannot override a superclass definition.
  
  =item I<traits>
  
  You are allowed to B<add> additional traits to the C<traits> definition.
  These traits will be composed into the attribute, but preexisting traits
  B<are not> overridden, or removed.
  
  =back
  
  =item B<before $name|@names|\@names|qr/.../ =E<gt> sub { ... }>
  
  =item B<after $name|@names|\@names|qr/.../ =E<gt> sub { ... }>
  
  =item B<around $name|@names|\@names|qr/.../ =E<gt> sub { ... }>
  
  These three items are syntactic sugar for the before, after, and around method
  modifier features that L<Class::MOP> provides. More information on these may be
  found in L<Moose::Manual::MethodModifiers> and the
  L<Class::MOP::Class documentation|Class::MOP::Class/"Method Modifiers">.
  
  =item B<override ($name, &sub)>
  
  An C<override> method is a way of explicitly saying "I am overriding this
  method from my superclass". You can call C<super> within this method, and
  it will work as expected. The same thing I<can> be accomplished with a normal
  method call and the C<SUPER::> pseudo-package; it is really your choice.
  
  =item B<super>
  
  The keyword C<super> is a no-op when called outside of an C<override> method. In
  the context of an C<override> method, it will call the next most appropriate
  superclass method with the same arguments as the original method.
  
  =item B<augment ($name, &sub)>
  
  An C<augment> method, is a way of explicitly saying "I am augmenting this
  method from my superclass". Once again, the details of how C<inner> and
  C<augment> work is best described in the
  L<Moose::Cookbook::Basics::Document_AugmentAndInner>.
  
  =item B<inner>
  
  The keyword C<inner>, much like C<super>, is a no-op outside of the context of
  an C<augment> method. You can think of C<inner> as being the inverse of
  C<super>; the details of how C<inner> and C<augment> work is best described in
  the L<Moose::Cookbook::Basics::Document_AugmentAndInner>.
  
  =item B<blessed>
  
  This is the C<Scalar::Util::blessed> function. It is highly recommended that
  this is used instead of C<ref> anywhere you need to test for an object's class
  name.
  
  =item B<confess>
  
  This is the C<Carp::confess> function, and exported here for historical
  reasons.
  
  =back
  
  =head1 METACLASS
  
  When you use Moose, you can specify traits which will be applied to your
  metaclass:
  
      use Moose -traits => 'My::Trait';
  
  This is very similar to the attribute traits feature. When you do
  this, your class's C<meta> object will have the specified traits
  applied to it. See L<Metaclass and Trait Name Resolution> for more
  details.
  
  =head2 Metaclass and Trait Name Resolution
  
  By default, when given a trait name, Moose simply tries to load a
  class of the same name. If such a class does not exist, it then looks
  for a class matching
  B<Moose::Meta::$type::Custom::Trait::$trait_name>. The C<$type>
  variable here will be one of B<Attribute> or B<Class>, depending on
  what the trait is being applied to.
  
  If a class with this long name exists, Moose checks to see if it has
  the method C<register_implementation>. This method is expected to
  return the I<real> class name of the trait. If there is no
  C<register_implementation> method, it will fall back to using
  B<Moose::Meta::$type::Custom::Trait::$trait> as the trait name.
  
  The lookup method for metaclasses is the same, except that it looks
  for a class matching B<Moose::Meta::$type::Custom::$metaclass_name>.
  
  If all this is confusing, take a look at
  L<Moose::Cookbook::Meta::Labeled_AttributeTrait>, which demonstrates how to
  create an attribute trait.
  
  =head1 UNIMPORTING FUNCTIONS
  
  =head2 B<unimport>
  
  Moose offers a way to remove the keywords it exports, through the C<unimport>
  method. You simply have to say C<no Moose> at the bottom of your code for this
  to work. Here is an example:
  
      package Person;
      use Moose;
  
      has 'first_name' => (is => 'rw', isa => 'Str');
      has 'last_name'  => (is => 'rw', isa => 'Str');
  
      sub full_name {
          my $self = shift;
          $self->first_name . ' ' . $self->last_name
      }
  
      no Moose; # keywords are removed from the Person package
  
  =head1 EXTENDING AND EMBEDDING MOOSE
  
  To learn more about extending Moose, we recommend checking out the
  "Extending" recipes in the L<Moose::Cookbook>, starting with
  L<Moose::Cookbook::Extending::ExtensionOverview>, which provides an overview of
  all the different ways you might extend Moose. L<Moose::Exporter> and
  L<Moose::Util::MetaRole> are the modules which provide the majority of the
  extension functionality, so reading their documentation should also be helpful.
  
  =head2 The MooseX:: namespace
  
  Generally if you're writing an extension I<for> Moose itself you'll want
  to put your extension in the C<MooseX::> namespace. This namespace is
  specifically for extensions that make Moose better or different in some
  fundamental way. It is traditionally B<not> for a package that just happens
  to use Moose. This namespace follows from the examples of the C<LWPx::>
  and C<DBIx::> namespaces that perform the same function for C<LWP> and C<DBI>
  respectively.
  
  =head1 METACLASS COMPATIBILITY AND MOOSE
  
  Metaclass compatibility is a thorny subject. You should start by
  reading the "About Metaclass compatibility" section in the
  C<Class::MOP> docs.
  
  Moose will attempt to resolve a few cases of metaclass incompatibility
  when you set the superclasses for a class, in addition to the cases that
  C<Class::MOP> handles.
  
  Moose tries to determine if the metaclasses only "differ by roles". This
  means that the parent and child's metaclass share a common ancestor in
  their respective hierarchies, and that the subclasses under the common
  ancestor are only different because of role applications. This case is
  actually fairly common when you mix and match various C<MooseX::*>
  modules, many of which apply roles to the metaclass.
  
  If the parent and child do differ by roles, Moose replaces the
  metaclass in the child with a newly created metaclass. This metaclass
  is a subclass of the parent's metaclass which does all of the roles that
  the child's metaclass did before being replaced. Effectively, this
  means the new metaclass does all of the roles done by both the
  parent's and child's original metaclasses.
  
  Ultimately, this is all transparent to you except in the case of an
  unresolvable conflict.
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  It should be noted that C<super> and C<inner> B<cannot> be used in the same
  method. However, they may be combined within the same class hierarchy; see
  F<t/basics/override_augment_inner_super.t> for an example.
  
  The reason for this is that C<super> is only valid within a method
  with the C<override> modifier, and C<inner> will never be valid within an
  C<override> method. In fact, C<augment> will skip over any C<override> methods
  when searching for its appropriate C<inner>.
  
  This might seem like a restriction, but I am of the opinion that keeping these
  two features separate (yet interoperable) actually makes them easy to use, since
  their behavior is then easier to predict. Time will tell whether I am right or
  not (UPDATE: so far so good).
  
  =back
  
  =head1 GETTING HELP
  
  We offer both a mailing list and a very active IRC channel.
  
  The mailing list is L<mailto:moose@perl.org>. You must be subscribed to send
  a message. To subscribe, send an empty message to
  L<mailto:moose-subscribe@perl.org>
  
  You can also visit us at C<#moose> on L<irc://irc.perl.org/#moose>
  This channel is quite active, and questions at all levels (on Moose-related
  topics ;) are welcome.
  
  =head1 WHAT DOES MOOSE STAND FOR?
  
  Moose doesn't stand for one thing in particular, however, if you want, here
  are a few of our favorites. Feel free to contribute more!
  
  =over 4
  
  =item * Make Other Object Systems Envious
  
  =item * Makes Object Orientation So Easy
  
  =item * Makes Object Orientation Spiffy- Er (sorry ingy)
  
  =item * Most Other Object Systems Emasculate
  
  =item * Moose Often Ovulate Sorta Early
  
  =item * Moose Offers Often Super Extensions
  
  =item * Meta Object Obligates Salivary Excitation
  
  =item * Meta Object Orientation Syntax Extensions
  
  =item * Moo, Only Overengineered, Slow, and Execrable (blame rjbs!)
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item I blame Sam Vilain for introducing me to the insanity that is meta-models.
  
  =item I blame Audrey Tang for then encouraging my meta-model habit in #perl6.
  
  =item Without Yuval "nothingmuch" Kogman this module would not be possible,
  and it certainly wouldn't have this name ;P
  
  =item The basis of the TypeContraints module was Rob Kinyon's idea
  originally, I just ran with it.
  
  =item Thanks to mst & chansen and the whole #moose posse for all the
  early ideas/feature-requests/encouragement/bug-finding.
  
  =item Thanks to David "Theory" Wheeler for meta-discussions and spelling fixes.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://moose.perl.org/>
  
  This is the official web home of Moose. It contains links to our public git
  repository, as well as links to a number of talks and articles on Moose and
  Moose related technologies.
  
  =item the L<Moose manual|Moose::Manual>
  
  This is an introduction to Moose which covers most of the basics.
  
  =item Modern Perl, by chromatic
  
  This is an introduction to modern Perl programming, which includes a section on
  Moose. It is available in print and as a free download from
  L<http://onyxneon.com/books/modern_perl/>.
  
  =item The Moose is flying, a tutorial by Randal Schwartz
  
  Part 1 - L<http://www.stonehenge.com/merlyn/LinuxMag/col94.html>
  
  Part 2 - L<http://www.stonehenge.com/merlyn/LinuxMag/col95.html>
  
  =item Several Moose extension modules in the C<MooseX::> namespace.
  
  See L<https://metacpan.org/search?q=MooseX::> for extensions.
  
  =back
  
  =head2 Books
  
  =over 4
  
  =item The Art of the MetaObject Protocol
  
  I mention this in the L<Class::MOP> docs too, as this book was critical in
  the development of both modules and is highly recommended.
  
  =back
  
  =head2 Papers
  
  =over 4
  
  =item L<http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf>
  
  This paper (suggested by lbr on #moose) was what lead to the implementation
  of the C<super>/C<override> and C<inner>/C<augment> features. If you really
  want to understand them, I suggest you read this.
  
  =back
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception.
  
  Please report any bugs to C<bug-moose@rt.cpan.org>, or through the web
  interface at L<http://rt.cpan.org>. You can also submit a C<TODO> test as a
  pull request at L<https://github.com/moose/Moose>.
  
  You can also discuss feature requests or possible bugs on the Moose mailing
  list (moose@perl.org) or on IRC at L<irc://irc.perl.org/#moose>.
  
  =head1 FEATURE REQUESTS
  
  We are very strict about what features we add to the Moose core, especially
  the user-visible features. Instead we have made sure that the underlying
  meta-system of Moose is as extensible as possible so that you can add your
  own features easily.
  
  That said, occasionally there is a feature needed in the meta-system
  to support your planned extension, in which case you should either
  email the mailing list (moose@perl.org) or join us on IRC at
  L<irc://irc.perl.org/#moose> to discuss. The
  L<Moose::Manual::Contributing> has more detail about how and when you
  can contribute.
  
  =head1 CABAL
  
  There are only a few people with the rights to release a new version
  of Moose. The Moose Cabal are the people to go to with questions regarding
  the wider purview of Moose. They help maintain not just the code
  but the community as well. See the list below under C<AUTHORS>.
  
  =head1 CONTRIBUTORS
  
  Moose is a community project, and as such, involves the work of many, many
  members of the community beyond just the members in the cabal. In particular:
  
  Dave (autarch) Rolsky wrote most of the documentation in L<Moose::Manual>.
  
  John (jgoulah) Goulah wrote L<Moose::Cookbook::Snack::Keywords>.
  
  Jess (castaway) Robinson wrote L<Moose::Cookbook::Snack::Types>.
  
  Aran (bluefeet) Clary Deltac wrote
  L<Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion>.
  
  Anders (Debolaz) Nor Berle contributed L<Test::Moose> and L<Moose::Util>.
  
  Also, the code in L<Moose::Meta::Attribute::Native> is based on code from the
  L<MooseX::AttributeHelpers> distribution, which had contributions from:
  
  Chris (perigrin) Prather
  
  Cory (gphat) Watson
  
  Evan Carroll
  
  Florian (rafl) Ragwitz
  
  Jason May
  
  Jay Hannah
  
  Jesse (doy) Luehrs
  
  Paul (frodwith) Driver
  
  Robert (rlb3) Boone
  
  Robert Buels
  
  Robert (phaylon) Sedlacek
  
  Shawn (Sartak) Moore
  
  Stevan Little
  
  Tom (dec) Lanyon
  
  Yuval Kogman
  
  Finally, these people also contributed various tests, bug fixes,
  documentation, and features to the Moose codebase:
  
  Aankhen
  
  Adam (Alias) Kennedy
  
  Christian (chansen) Hansen
  
  Cory (gphat) Watson
  
  Dylan Hardison (doc fixes)
  
  Eric (ewilhelm) Wilhelm
  
  Evan Carroll
  
  Guillermo (groditi) Roditi
  
  Jason May
  
  Jay Hannah
  
  Jonathan (jrockway) Rockway
  
  Matt (mst) Trout
  
  Nathan (kolibrie) Gray
  
  Paul (frodwith) Driver
  
  Piotr (dexter) Roszatycki
  
  Robert Buels
  
  Robert (phaylon) Sedlacek
  
  Robert (rlb3) Boone
  
  Sam (mugwump) Vilain
  
  Scott (konobi) McWhirter
  
  Shlomi (rindolf) Fish
  
  Tom (dec) Lanyon
  
  Wallace (wreis) Reis
  
  ... and many other #moose folks
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE

$fatpacked{"x86_64-linux-thread-multi/Moose/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_CONFLICTS';
  package # hide from PAUSE
      Moose::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Moose',
      -conflicts => {
          'Catalyst' => '5.90049999',
          'Config::MVP' => '2.200004',
          'Devel::REPL' => '1.003020',
          'Dist::Zilla::Plugin::Git' => '2.016',
          'Fey' => '0.36',
          'Fey::ORM' => '0.42',
          'File::ChangeNotify' => '0.15',
          'HTTP::Throwable' => '0.017',
          'KiokuDB' => '0.51',
          'Markdent' => '0.16',
          'Mason' => '2.18',
          'MooseX::ABC' => '0.05',
          'MooseX::Aliases' => '0.08',
          'MooseX::AlwaysCoerce' => '0.13',
          'MooseX::App' => '1.22',
          'MooseX::Attribute::Deflator' => '2.1.7',
          'MooseX::Attribute::Dependent' => '1.1.0',
          'MooseX::Attribute::Prototype' => '0.10',
          'MooseX::AttributeHelpers' => '0.22',
          'MooseX::AttributeIndexes' => '1.0.0',
          'MooseX::AttributeInflate' => '0.02',
          'MooseX::CascadeClearing' => '0.03',
          'MooseX::ClassAttribute' => '0.26',
          'MooseX::Constructor::AllErrors' => '0.021',
          'MooseX::Declare' => '0.35',
          'MooseX::FollowPBP' => '0.02',
          'MooseX::Getopt' => '0.56',
          'MooseX::HasDefaults' => '0.02',
          'MooseX::InstanceTracking' => '0.04',
          'MooseX::LazyRequire' => '0.06',
          'MooseX::Meta::Attribute::Index' => '0.04',
          'MooseX::Meta::Attribute::Lvalue' => '0.05',
          'MooseX::Method::Signatures' => '0.44',
          'MooseX::MethodAttributes' => '0.22',
          'MooseX::NonMoose' => '0.24',
          'MooseX::Object::Pluggable' => '0.0011',
          'MooseX::POE' => '0.214',
          'MooseX::Params::Validate' => '0.05',
          'MooseX::PrivateSetters' => '0.03',
          'MooseX::Role::Cmd' => '0.06',
          'MooseX::Role::Parameterized' => '1.00',
          'MooseX::Role::WithOverloading' => '0.07',
          'MooseX::Runnable' => '0.03',
          'MooseX::Scaffold' => '0.05',
          'MooseX::SemiAffordanceAccessor' => '0.05',
          'MooseX::SetOnce' => '0.100473',
          'MooseX::Singleton' => '0.25',
          'MooseX::SlurpyConstructor' => '1.1',
          'MooseX::Storage' => '0.42',
          'MooseX::StrictConstructor' => '0.12',
          'MooseX::Traits' => '0.11',
          'MooseX::Types' => '0.19',
          'MooseX::Types::Parameterizable' => '0.05',
          'MooseX::Types::Set::Object' => '0.03',
          'MooseX::Types::Signal' => '1.101930',
          'MooseX::UndefTolerant' => '0.11',
          'PRANG' => '0.14',
          'Pod::Elemental' => '0.093280',
          'Pod::Weaver' => '3.101638',
          'Reaction' => '0.002003',
          'Test::Able' => '0.10',
          'Test::CleanNamespaces' => '0.03',
          'Test::Moose::More' => '0.022',
          'Test::TempDir' => '0.05',
          'namespace::autoclean' => '0.08',
      },
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Conflicts - Provide information on conflicts for Moose
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_CONFLICTS

$fatpacked{"x86_64-linux-thread-multi/Moose/Deprecated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_DEPRECATED';
  package Moose::Deprecated;
  BEGIN {
    $Moose::Deprecated::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Deprecated::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Package::DeprecationManager 0.07 -deprecations => {
      'non-arrayref form of enum'         => '2.1100',
      'non-arrayref form of duck_type'    => '2.1100',
      },
      -ignore => [qr/^(?:Class::MOP|Moose)(?:::)?/],
      ;
  
  1;
  
  # ABSTRACT: Manages deprecation warnings for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Deprecated - Manages deprecation warnings for Moose
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
      use Moose::Deprecated -api_version => $version;
  
  =head1 FUNCTIONS
  
  This module manages deprecation warnings for features that have been
  deprecated in Moose.
  
  If you specify C<< -api_version => $version >>, you can use deprecated features
  without warnings. Note that this special treatment is limited to the package
  that loads C<Moose::Deprecated>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_DEPRECATED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION';
  package Moose::Exception;
  BEGIN {
    $Moose::Exception::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::VERSION = '2.1204';
  use Moose;
  use Devel::StackTrace;
  
  has 'trace' => (
      is            => 'ro',
      isa           => 'Devel::StackTrace',
      builder       => '_build_trace',
      lazy          => 1,
      documentation => "This attribute is read-only and isa L<Devel::StackTrace>. ".
                       'It is lazy & dependent on $exception->message.'
  );
  
  has 'message' => (
      is            => 'ro',
      isa           => 'Str',
      builder       => '_build_message',
      lazy          => 1,
      documentation => "This attribute is read-only and isa Str. ".
                       "It is lazy and has a default value 'Error'."
  );
  
  use overload
      '""' => sub {
          my $self = shift;
          return $self->trace->as_string,
      },
      fallback => 1,
  ;
  
  sub _build_trace {
      my $self = shift;
      Devel::StackTrace->new(
          message => $self->message,
          indent  => 1,
      );
  }
  
  sub _build_message {
      "Error";
  }
  
  sub BUILD {
      my $self = shift;
      $self->trace;
  }
  
  1;
  
  # ABSTRACT: Superclass of all Moose exceptions
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Exception - Superclass of all Moose exceptions
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class contains attributes which are common to all Moose exceptions
  classes.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item B<< $exception->trace >>
  
  This attribute contains the stack trace for the given exception. It
  is read-only and isa L<Devel::StackTrace>. It is lazy & dependent
  on $exception->message.
  
  =item B<< $exception->message >>
  
  This attribute contains the exception message. It is read-only and isa Str.
  It is lazy and has a default value 'Error'. Every subclass of L<Moose::Exception>
  is expected to override _build_message method.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Moose::Manual::Exceptions>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AccessorMustReadWrite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ACCESSORMUSTREADWRITE';
  package Moose::Exception::AccessorMustReadWrite;
  BEGIN {
    $Moose::Exception::AccessorMustReadWrite::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AccessorMustReadWrite::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot define an accessor name on a read-only attribute, accessors are read/write";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ACCESSORMUSTREADWRITE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AddParameterizableTypeTakesParameterizableType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ADDPARAMETERIZABLETYPETAKESPARAMETERIZABLETYPE';
  package Moose::Exception::AddParameterizableTypeTakesParameterizableType;
  BEGIN {
    $Moose::Exception::AddParameterizableTypeTakesParameterizableType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AddParameterizableTypeTakesParameterizableType::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Type must be a Moose::Meta::TypeConstraint::Parameterizable not ".$self->type_name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ADDPARAMETERIZABLETYPETAKESPARAMETERIZABLETYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AddRoleTakesAMooseMetaRoleInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETAKESAMOOSEMETAROLEINSTANCE';
  package Moose::Exception::AddRoleTakesAMooseMetaRoleInstance;
  BEGIN {
    $Moose::Exception::AddRoleTakesAMooseMetaRoleInstance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AddRoleTakesAMooseMetaRoleInstance::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'role_to_be_added' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "Roles must be instances of Moose::Meta::Role";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETAKESAMOOSEMETAROLEINSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AddRoleToARoleTakesAMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETOAROLETAKESAMOOSEMETAROLE';
  package Moose::Exception::AddRoleToARoleTakesAMooseMetaRole;
  BEGIN {
    $Moose::Exception::AddRoleToARoleTakesAMooseMetaRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AddRoleToARoleTakesAMooseMetaRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'role_to_be_added' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "Roles must be instances of Moose::Meta::Role";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETOAROLETAKESAMOOSEMETAROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ApplyTakesABlessedInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_APPLYTAKESABLESSEDINSTANCE';
  package Moose::Exception::ApplyTakesABlessedInstance;
  BEGIN {
    $Moose::Exception::ApplyTakesABlessedInstance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ApplyTakesABlessedInstance::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'param' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "You must pass in an blessed instance";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_APPLYTAKESABLESSEDINSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttachToClassNeedsAClassMOPClassInstanceOrASubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTACHTOCLASSNEEDSACLASSMOPCLASSINSTANCEORASUBCLASS';
  package Moose::Exception::AttachToClassNeedsAClassMOPClassInstanceOrASubclass;
  BEGIN {
    $Moose::Exception::AttachToClassNeedsAClassMOPClassInstanceOrASubclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttachToClassNeedsAClassMOPClassInstanceOrASubclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a Class::MOP::Class instance (or a subclass)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTACHTOCLASSNEEDSACLASSMOPCLASSINSTANCEORASUBCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttributeConflictInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINROLES';
  package Moose::Exception::AttributeConflictInRoles;
  BEGIN {
    $Moose::Exception::AttributeConflictInRoles::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttributeConflictInRoles::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'second_role' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Role '". $self->role->name
      . "' has encountered an attribute conflict"
      . " while being composed into '".$self->second_role->name."'."
      . " This is a fatal error and cannot be disambiguated."
      . " The conflicting attribute is named '".$self->attribute_name."'.";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINROLES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttributeConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINSUMMATION';
  package Moose::Exception::AttributeConflictInSummation;
  BEGIN {
    $Moose::Exception::AttributeConflictInSummation::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttributeConflictInSummation::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::AttributeName';
  
  has 'second_role' => (
      is         => 'ro',
      isa        => 'Moose::Meta::Role',
      required   => 1,
  );
  
  sub _build_message {
      my $self = shift;
  
      my $role1 = $self->role_name;
      my $role2 = $self->second_role->name;
      my $attr_name = $self->attribute_name;
  
      return "We have encountered an attribute conflict with '$attr_name'"
             . " during role composition. "
             . " This attribute is defined in both $role1 and $role2."
             . " This is a fatal error and cannot be disambiguated.";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINSUMMATION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttributeExtensionIsNotSupportedInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEEXTENSIONISNOTSUPPORTEDINROLES';
  package Moose::Exception::AttributeExtensionIsNotSupportedInRoles;
  BEGIN {
    $Moose::Exception::AttributeExtensionIsNotSupportedInRoles::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttributeExtensionIsNotSupportedInRoles::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      "has '+attr' is not supported in roles";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEEXTENSIONISNOTSUPPORTEDINROLES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttributeIsRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEISREQUIRED';
  package Moose::Exception::AttributeIsRequired;
  BEGIN {
    $Moose::Exception::AttributeIsRequired::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttributeIsRequired::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Moose::Util 'throw_exception';
  
  has 'attribute_name' => (
      is         => 'ro',
      isa        => 'Str',
      lazy_build => 1
  );
  
  has 'attribute' => (
      is        => 'ro',
      isa       => 'Class::MOP::Attribute',
      # predicate => 'has_attribute',
      lazy_build => 1
  );
  
  has 'params' => (
      is        => 'ro',
      isa       => 'HashRef',
      predicate => 'has_params',
  );
  
  sub _build_attribute {
      my $self = shift;
      if( $self->has_attribute_name &&
          $self->is_class_name_set ) {
          $self->class->get_attribute( $self->attribute_name );
      }
  }
  
  sub _build_class {
      my $self = shift;
      if( $self->has_attribute ) {
          return $self->attribute->associated_class;
      } elsif( $self->is_class_name_set ) {
          return Class::MOP::class_of( $self->class_name );
      }
  };
  
  sub _build_class_name {
      my $self = shift;
      return $self->class->name;
  }
  
  sub _has_class_or_class_name {
      my $self = shift;
  
      if( $self->has_attribute ) {
          return 1;
      } else {
          return $self->is_class_name_set ||
                 $self->is_class_set;
      }
  }
  
  sub _build_attribute_name {
      my $self = shift;
      if( $self->has_attribute ) {
          return $self->attribute->name;
      } else {
          throw_exception( "NeitherAttributeNorAttributeNameIsGiven" );
      }
  }
  
  after "BUILD" => sub {
      my $self = $_[0];
  
      if( $self->has_attribute_name &&
          $self->has_attribute &&
          ( $self->attribute->name ne $self->attribute_name ) )
      {
          throw_exception( AttributeNamesDoNotMatch => attribute_name => $self->attribute_name,
                                                       attribute      => $self->attribute
                         );
      } elsif( !$self->has_attribute &&
               !$self->is_class_name_set &&
               !$self->is_class_set ) {
          throw_exception( "NeitherClassNorClassNameIsGiven" );
      } elsif( !$self->has_attribute &&
               !$self->has_attribute_name ) {
          throw_exception( "NeitherAttributeNorAttributeNameIsGiven" );
      } elsif( $self->is_class_name_set &&
               $self->has_attribute &&
               ( $self->class_name ne $self->class->name ) ) {
          throw_exception( ClassNamesDoNotMatch => class_name => $self->class_name,
                                                   class      => $self->class,
                         );
      }
  };
  
  sub _build_message {
      my $self = shift;
      "Attribute (".$self->attribute_name.") is required";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEISREQUIRED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEMUSTBEANCLASSMOPMIXINATTRIBUTECOREORSUBCLASS';
  package Moose::Exception::AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass;
  BEGIN {
    $Moose::Exception::AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'attribute' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "Your attribute must be an instance of Class::MOP::Mixin::AttributeCore (or a subclass)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEMUSTBEANCLASSMOPMIXINATTRIBUTECOREORSUBCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttributeNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTENAMESDONOTMATCH';
  package Moose::Exception::AttributeNamesDoNotMatch;
  BEGIN {
    $Moose::Exception::AttributeNamesDoNotMatch::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttributeNamesDoNotMatch::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has attribute_name => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has attribute => (
      is       => 'ro',
      isa      => 'Class::MOP::Attribute',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "attribute_name (".$self-> attribute_name.") does not match attribute->name (".$self->attribute->name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTENAMESDONOTMATCH

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttributeValueIsNotAnObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTANOBJECT';
  package Moose::Exception::AttributeValueIsNotAnObject;
  BEGIN {
    $Moose::Exception::AttributeValueIsNotAnObject::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttributeValueIsNotAnObject::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Attribute';
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Delegation',
      required => 1,
  );
  
  has 'given_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot delegate ".$self->method->name." to "
      .$self->method->delegate_to_method." because the value of "
      . $self->attribute->name . " is not an object (got '".$self->given_value."')";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTANOBJECT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AttributeValueIsNotDefined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTDEFINED';
  package Moose::Exception::AttributeValueIsNotDefined;
  BEGIN {
    $Moose::Exception::AttributeValueIsNotDefined::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AttributeValueIsNotDefined::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Attribute';
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Delegation',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot delegate ".$self->method->name." to "
      .$self->method->delegate_to_method." because the value of "
      . $self->attribute->name . " is not defined";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTDEFINED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/AutoDeRefNeedsArrayRefOrHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_AUTODEREFNEEDSARRAYREFORHASHREF';
  package Moose::Exception::AutoDeRefNeedsArrayRefOrHashRef;
  BEGIN {
    $Moose::Exception::AutoDeRefNeedsArrayRefOrHashRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::AutoDeRefNeedsArrayRefOrHashRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_AUTODEREFNEEDSARRAYREFORHASHREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/BadOptionFormat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BADOPTIONFORMAT';
  package Moose::Exception::BadOptionFormat;
  BEGIN {
    $Moose::Exception::BadOptionFormat::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::BadOptionFormat::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'option_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'option_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "bad accessor/reader/writer/predicate/clearer format, must be a HASH ref";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BADOPTIONFORMAT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/BothBuilderAndDefaultAreNotAllowed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BOTHBUILDERANDDEFAULTARENOTALLOWED';
  package Moose::Exception::BothBuilderAndDefaultAreNotAllowed;
  BEGIN {
    $Moose::Exception::BothBuilderAndDefaultAreNotAllowed::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::BothBuilderAndDefaultAreNotAllowed::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Setting both default and builder is not allowed.";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BOTHBUILDERANDDEFAULTARENOTALLOWED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/BuilderDoesNotExist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERDOESNOTEXIST';
  package Moose::Exception::BuilderDoesNotExist;
  BEGIN {
    $Moose::Exception::BuilderDoesNotExist::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::BuilderDoesNotExist::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      blessed($self->instance)." does not support builder method '".$self->attribute->builder."' for attribute '".$self->attribute->name."'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERDOESNOTEXIST

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/BuilderMethodNotSupportedForAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORATTRIBUTE';
  package Moose::Exception::BuilderMethodNotSupportedForAttribute;
  BEGIN {
    $Moose::Exception::BuilderMethodNotSupportedForAttribute::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::BuilderMethodNotSupportedForAttribute::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      blessed($self->instance)." does not support builder method '". $self->attribute->builder ."' for attribute '" . $self->attribute->name . "'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORATTRIBUTE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/BuilderMethodNotSupportedForInlineAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORINLINEATTRIBUTE';
  package Moose::Exception::BuilderMethodNotSupportedForInlineAttribute;
  BEGIN {
    $Moose::Exception::BuilderMethodNotSupportedForInlineAttribute::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::BuilderMethodNotSupportedForInlineAttribute::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Class';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'builder' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->class_name." does not support builder method '". $self->builder ."' for attribute '" . $self->attribute_name . "'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORINLINEATTRIBUTE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/BuilderMustBeAMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMUSTBEAMETHODNAME';
  package Moose::Exception::BuilderMustBeAMethodName;
  BEGIN {
    $Moose::Exception::BuilderMustBeAMethodName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::BuilderMustBeAMethodName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "builder must be a defined scalar value which is a method name";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMUSTBEAMETHODNAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CallingMethodOnAnImmutableInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGMETHODONANIMMUTABLEINSTANCE';
  package Moose::Exception::CallingMethodOnAnImmutableInstance;
  BEGIN {
    $Moose::Exception::CallingMethodOnAnImmutableInstance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CallingMethodOnAnImmutableInstance::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The '".$self->method_name."' method cannot be called on an immutable instance";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGMETHODONANIMMUTABLEINSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CallingReadOnlyMethodOnAnImmutableInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGREADONLYMETHODONANIMMUTABLEINSTANCE';
  package Moose::Exception::CallingReadOnlyMethodOnAnImmutableInstance;
  BEGIN {
    $Moose::Exception::CallingReadOnlyMethodOnAnImmutableInstance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CallingReadOnlyMethodOnAnImmutableInstance::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The '".$self->method_name."' method is read-only when called on an immutable instance";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGREADONLYMETHODONANIMMUTABLEINSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CanExtendOnlyClasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANEXTENDONLYCLASSES';
  package Moose::Exception::CanExtendOnlyClasses;
  BEGIN {
    $Moose::Exception::CanExtendOnlyClasses::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CanExtendOnlyClasses::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'role' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You cannot inherit from a Moose Role (".$self->role->name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANEXTENDONLYCLASSES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CanOnlyConsumeRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYCONSUMEROLE';
  package Moose::Exception::CanOnlyConsumeRole;
  BEGIN {
    $Moose::Exception::CanOnlyConsumeRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CanOnlyConsumeRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You can only consume roles, ".$self->role_name." is not a Moose role";
  }
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYCONSUMEROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CanOnlyWrapBlessedCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYWRAPBLESSEDCODE';
  package Moose::Exception::CanOnlyWrapBlessedCode;
  BEGIN {
    $Moose::Exception::CanOnlyWrapBlessedCode::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CanOnlyWrapBlessedCode::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'code' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "Can only wrap blessed CODE";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYWRAPBLESSEDCODE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CanReblessOnlyIntoASubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUBCLASS';
  package Moose::Exception::CanReblessOnlyIntoASubclass;
  BEGIN {
    $Moose::Exception::CanReblessOnlyIntoASubclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CanReblessOnlyIntoASubclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      "You may rebless only into a subclass of (".blessed( $self->instance )."), of which (". $self->class->name .") isn't."
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUBCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CanReblessOnlyIntoASuperclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUPERCLASS';
  package Moose::Exception::CanReblessOnlyIntoASuperclass;
  BEGIN {
    $Moose::Exception::CanReblessOnlyIntoASuperclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CanReblessOnlyIntoASuperclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      "You may rebless only into a superclass of (".blessed( $self->instance )."), of which (". $self->class->name .") isn't."
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUPERCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotAddAdditionalTypeCoercionsToUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDADDITIONALTYPECOERCIONSTOUNION';
  package Moose::Exception::CannotAddAdditionalTypeCoercionsToUnion;
  BEGIN {
    $Moose::Exception::CannotAddAdditionalTypeCoercionsToUnion::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotAddAdditionalTypeCoercionsToUnion::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_coercion_union_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeCoercion::Union',
      required => 1
  );
  
  sub _build_message {
      return "Cannot add additional type coercions to Union types";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDADDITIONALTYPECOERCIONSTOUNION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotAddAsAnAttributeToARole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDASANATTRIBUTETOAROLE';
  package Moose::Exception::CannotAddAsAnAttributeToARole;
  BEGIN {
    $Moose::Exception::CannotAddAsAnAttributeToARole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotAddAsAnAttributeToARole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot add a ".$self->attribute_class." as an attribute to a role";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDASANATTRIBUTETOAROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotApplyBaseClassRolesToRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAPPLYBASECLASSROLESTOROLE';
  package Moose::Exception::CannotApplyBaseClassRolesToRole;
  BEGIN {
    $Moose::Exception::CannotApplyBaseClassRolesToRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotApplyBaseClassRolesToRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "You can only apply base class roles to a Moose class, not a role.";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAPPLYBASECLASSROLESTOROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotAssignValueToReadOnlyAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTASSIGNVALUETOREADONLYACCESSOR';
  package Moose::Exception::CannotAssignValueToReadOnlyAccessor;
  BEGIN {
    $Moose::Exception::CannotAssignValueToReadOnlyAccessor::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotAssignValueToReadOnlyAccessor::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::EitherAttributeOrAttributeName';
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot assign a value to a read-only accessor";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTASSIGNVALUETOREADONLYACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotAugmentIfLocalMethodPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTIFLOCALMETHODPRESENT';
  package Moose::Exception::CannotAugmentIfLocalMethodPresent;
  BEGIN {
    $Moose::Exception::CannotAugmentIfLocalMethodPresent::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotAugmentIfLocalMethodPresent::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      "Cannot add an augment method if a local method is already present";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTIFLOCALMETHODPRESENT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotAugmentNoSuperMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTNOSUPERMETHOD';
  package Moose::Exception::CannotAugmentNoSuperMethod;
  BEGIN {
    $Moose::Exception::CannotAugmentNoSuperMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotAugmentNoSuperMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You cannot augment '".$self->method_name."' because it has no super method";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTNOSUPERMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotAutoDerefWithoutIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFWITHOUTISA';
  package Moose::Exception::CannotAutoDerefWithoutIsa;
  BEGIN {
    $Moose::Exception::CannotAutoDerefWithoutIsa::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotAutoDerefWithoutIsa::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot auto-dereference without specifying a type constraint on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFWITHOUTISA

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotAutoDereferenceTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFERENCETYPECONSTRAINT';
  package Moose::Exception::CannotAutoDereferenceTypeConstraint;
  BEGIN {
    $Moose::Exception::CannotAutoDereferenceTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotAutoDereferenceTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Can not auto de-reference the type constraint '" . $self->type_name . "'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFERENCETYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotCalculateNativeType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALCULATENATIVETYPE';
  package Moose::Exception::CannotCalculateNativeType;
  BEGIN {
    $Moose::Exception::CannotCalculateNativeType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotCalculateNativeType::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      "Cannot calculate native type for " . ref $self->instance;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALCULATENATIVETYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotCallAnAbstractBaseMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTBASEMETHOD';
  package Moose::Exception::CannotCallAnAbstractBaseMethod;
  BEGIN {
    $Moose::Exception::CannotCallAnAbstractBaseMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotCallAnAbstractBaseMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->package_name. " is an abstract base class, you must provide a constructor.";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTBASEMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotCallAnAbstractMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTMETHOD';
  package Moose::Exception::CannotCallAnAbstractMethod;
  BEGIN {
    $Moose::Exception::CannotCallAnAbstractMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotCallAnAbstractMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Abstract method";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotCoerceAWeakRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEAWEAKREF';
  package Moose::Exception::CannotCoerceAWeakRef;
  BEGIN {
    $Moose::Exception::CannotCoerceAWeakRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotCoerceAWeakRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a weak reference to a coerced value on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEAWEAKREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotCoerceAttributeWhichHasNoCoercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEATTRIBUTEWHICHHASNOCOERCION';
  package Moose::Exception::CannotCoerceAttributeWhichHasNoCoercion;
  BEGIN {
    $Moose::Exception::CannotCoerceAttributeWhichHasNoCoercion::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotCoerceAttributeWhichHasNoCoercion::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions', 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      my $name = $self->attribute_name;
      my $type = $self->type_name;
  
      return "You cannot coerce an attribute ($name) unless its type ($type) has a coercion";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEATTRIBUTEWHICHHASNOCOERCION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotCreateHigherOrderTypeWithoutATypeParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEHIGHERORDERTYPEWITHOUTATYPEPARAMETER';
  package Moose::Exception::CannotCreateHigherOrderTypeWithoutATypeParameter;
  BEGIN {
    $Moose::Exception::CannotCreateHigherOrderTypeWithoutATypeParameter::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotCreateHigherOrderTypeWithoutATypeParameter::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      "You cannot create a Higher Order type without a type parameter";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEHIGHERORDERTYPEWITHOUTATYPEPARAMETER

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotCreateMethodAliasLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENT';
  package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresent;
  BEGIN {
    $Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresent::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresent::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Method';
  
  has 'role_being_applied' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1
  );
  
  has 'aliased_method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Cannot create a method alias if a local method of the same name exists";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotCreateMethodAliasLocalMethodIsPresentInClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENTINCLASS';
  package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresentInClass;
  BEGIN {
    $Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresentInClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresentInClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Method', 'Moose::Exception::Role::Class';
  
  has 'aliased_method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Cannot create a method alias if a local method of the same name exists";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENTINCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotDelegateLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATELOCALMETHODISPRESENT';
  package Moose::Exception::CannotDelegateLocalMethodIsPresent;
  BEGIN {
    $Moose::Exception::CannotDelegateLocalMethodIsPresent::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotDelegateLocalMethodIsPresent::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      my $self = shift;
      "You cannot overwrite a locally defined method (".$self->method->name.") with a delegation";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATELOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotDelegateWithoutIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATEWITHOUTISA';
  package Moose::Exception::CannotDelegateWithoutIsa;
  BEGIN {
    $Moose::Exception::CannotDelegateWithoutIsa::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotDelegateWithoutIsa::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      "Cannot delegate methods based on a Regexp without a type constraint (isa)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATEWITHOUTISA

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotFindDelegateMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDDELEGATEMETACLASS';
  package Moose::Exception::CannotFindDelegateMetaclass;
  BEGIN {
    $Moose::Exception::CannotFindDelegateMetaclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotFindDelegateMetaclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      my $self = shift;
      "Cannot find delegate metaclass for attribute ".$self->attribute->name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDDELEGATEMETACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotFindType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPE';
  package Moose::Exception::CannotFindType;
  BEGIN {
    $Moose::Exception::CannotFindType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotFindType::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot find type '".$self->type_name."', perhaps you forgot to load it";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotFindTypeGivenToMatchOnType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPEGIVENTOMATCHONTYPE';
  package Moose::Exception::CannotFindTypeGivenToMatchOnType;
  BEGIN {
    $Moose::Exception::CannotFindTypeGivenToMatchOnType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotFindTypeGivenToMatchOnType::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type;
  
      return "Cannot find or parse the type '$type'"
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPEGIVENTOMATCHONTYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotFixMetaclassCompatibility.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFIXMETACLASSCOMPATIBILITY';
  package Moose::Exception::CannotFixMetaclassCompatibility;
  BEGIN {
    $Moose::Exception::CannotFixMetaclassCompatibility::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotFixMetaclassCompatibility::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'superclass' => (
      is       => 'ro',
      isa      => 'Object',
      required => 1
  );
  
  has 'metaclass_type' => (
      is       => 'ro',
      isa      => 'Str',
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      "Can't fix metaclass incompatibility for $class_name because it is not pristine.";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFIXMETACLASSCOMPATIBILITY

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotGenerateInlineConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTGENERATEINLINECONSTRAINT';
  package Moose::Exception::CannotGenerateInlineConstraint;
  BEGIN {
    $Moose::Exception::CannotGenerateInlineConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotGenerateInlineConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'parameterizable_type_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeConstraint::Parameterizable',
      required => 1
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type;
  
      return "Can't generate an inline constraint for $type, since none was defined";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTGENERATEINLINECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotInitializeMooseMetaRoleComposite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINITIALIZEMOOSEMETAROLECOMPOSITE';
  package Moose::Exception::CannotInitializeMooseMetaRoleComposite;
  BEGIN {
    $Moose::Exception::CannotInitializeMooseMetaRoleComposite::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotInitializeMooseMetaRoleComposite::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'role_composite' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Composite',
      required => 1
  );
  
  has 'old_meta' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      'Moose::Meta::Role::Composite instances can only be reinitialized from an existing metaclass instance';
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINITIALIZEMOOSEMETAROLECOMPOSITE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotInlineTypeConstraintCheck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINLINETYPECONSTRAINTCHECK';
  package Moose::Exception::CannotInlineTypeConstraintCheck;
  BEGIN {
    $Moose::Exception::CannotInlineTypeConstraintCheck::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotInlineTypeConstraintCheck::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      'Cannot inline a type constraint check for ' . $self->type_name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINLINETYPECONSTRAINTCHECK

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotLocatePackageInINC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTLOCATEPACKAGEININC';
  package Moose::Exception::CannotLocatePackageInINC;
  BEGIN {
    $Moose::Exception::CannotLocatePackageInINC::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotLocatePackageInINC::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint', 'Moose::Exception::Role::ParamsHash';
  
  has 'INC' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'possible_packages' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'metaclass_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $possible_packages = $self->possible_packages;
      my @inc = @{$self->INC};
  
      return "Can't locate $possible_packages in \@INC (\@INC contains: @INC)."
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTLOCATEPACKAGEININC

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotMakeMetaclassCompatible.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTMAKEMETACLASSCOMPATIBLE';
  package Moose::Exception::CannotMakeMetaclassCompatible;
  BEGIN {
    $Moose::Exception::CannotMakeMetaclassCompatible::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotMakeMetaclassCompatible::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'superclass_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      my $superclass = $self->superclass_name;
  
      return "Can't make $class_name compatible with metaclass $superclass";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTMAKEMETACLASSCOMPATIBLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotOverrideALocalMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEALOCALMETHOD';
  package Moose::Exception::CannotOverrideALocalMethod;
  BEGIN {
    $Moose::Exception::CannotOverrideALocalMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotOverrideALocalMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot add an override of method '".$self->method_name."' because there is a local version of '".$self->method_name."'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEALOCALMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotOverrideBodyOfMetaMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEBODYOFMETAMETHODS';
  package Moose::Exception::CannotOverrideBodyOfMetaMethods;
  BEGIN {
    $Moose::Exception::CannotOverrideBodyOfMetaMethods::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotOverrideBodyOfMetaMethods::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Overriding the body of meta methods is not allowed";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEBODYOFMETAMETHODS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotOverrideLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDELOCALMETHODISPRESENT';
  package Moose::Exception::CannotOverrideLocalMethodIsPresent;
  BEGIN {
    $Moose::Exception::CannotOverrideLocalMethodIsPresent::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotOverrideLocalMethodIsPresent::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      "Cannot add an override method if a local method is already present";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDELOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotOverrideNoSuperMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDENOSUPERMETHOD';
  package Moose::Exception::CannotOverrideNoSuperMethod;
  BEGIN {
    $Moose::Exception::CannotOverrideNoSuperMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotOverrideNoSuperMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You cannot override '".$self->method_name."' because it has no super method";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDENOSUPERMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotRegisterUnnamedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTREGISTERUNNAMEDTYPECONSTRAINT';
  package Moose::Exception::CannotRegisterUnnamedTypeConstraint;
  BEGIN {
    $Moose::Exception::CannotRegisterUnnamedTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotRegisterUnnamedTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      "can't register an unnamed type constraint";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTREGISTERUNNAMEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CannotUseLazyBuildAndDefaultSimultaneously.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTUSELAZYBUILDANDDEFAULTSIMULTANEOUSLY';
  package Moose::Exception::CannotUseLazyBuildAndDefaultSimultaneously;
  BEGIN {
    $Moose::Exception::CannotUseLazyBuildAndDefaultSimultaneously::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CannotUseLazyBuildAndDefaultSimultaneously::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You can not use lazy_build and default for the same attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTUSELAZYBUILDANDDEFAULTSIMULTANEOUSLY

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CircularReferenceInAlso.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CIRCULARREFERENCEINALSO';
  package Moose::Exception::CircularReferenceInAlso;
  BEGIN {
    $Moose::Exception::CircularReferenceInAlso::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CircularReferenceInAlso::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'also_parameter' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'stack' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $also_member = $self->also_parameter;
  
      my @stack = @{$self->stack};
      my $existing_stack = join( ', ', @stack);
  
      return "Circular reference in 'also' parameter to Moose::Exporter between "
             ."$existing_stack and $also_member";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CIRCULARREFERENCEINALSO

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ClassDoesNotHaveInitMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESNOTHAVEINITMETA';
  package Moose::Exception::ClassDoesNotHaveInitMeta;
  BEGIN {
    $Moose::Exception::ClassDoesNotHaveInitMeta::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ClassDoesNotHaveInitMeta::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'traits' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class = $self->class_name;
  
      return "Cannot provide traits when $class does not have an init_meta() method";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESNOTHAVEINITMETA

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ClassDoesTheExcludedRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESTHEEXCLUDEDROLE';
  package Moose::Exception::ClassDoesTheExcludedRole;
  BEGIN {
    $Moose::Exception::ClassDoesTheExcludedRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ClassDoesTheExcludedRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Class';
  
  has 'excluded_role' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The class " . $self->class_name . " does the excluded role '".$self->excluded_role->name."'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESTHEEXCLUDEDROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ClassNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CLASSNAMESDONOTMATCH';
  package Moose::Exception::ClassNamesDoNotMatch;
  BEGIN {
    $Moose::Exception::ClassNamesDoNotMatch::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ClassNamesDoNotMatch::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has class_name => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has class => (
      is       => 'ro',
      isa      => 'Class::MOP::Class',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "class_name (".$self-> class_name.") does not match class->name (".$self->class->name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CLASSNAMESDONOTMATCH

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CloneObjectExpectsAnInstanceOfMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CLONEOBJECTEXPECTSANINSTANCEOFMETACLASS';
  package Moose::Exception::CloneObjectExpectsAnInstanceOfMetaclass;
  BEGIN {
    $Moose::Exception::CloneObjectExpectsAnInstanceOfMetaclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CloneObjectExpectsAnInstanceOfMetaclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass an instance of the metaclass (" .$self->class->name. "), not (".$self->instance.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CLONEOBJECTEXPECTSANINSTANCEOFMETACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CodeBlockMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CODEBLOCKMUSTBEACODEREF';
  package Moose::Exception::CodeBlockMustBeACodeRef;
  BEGIN {
    $Moose::Exception::CodeBlockMustBeACodeRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CodeBlockMustBeACodeRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      "Your code block must be a CODE reference";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CODEBLOCKMUSTBEACODEREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CoercingWithoutCoercions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COERCINGWITHOUTCOERCIONS';
  package Moose::Exception::CoercingWithoutCoercions;
  BEGIN {
    $Moose::Exception::CoercingWithoutCoercions::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CoercingWithoutCoercions::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'type' => (
      is       => 'ro',
      isa      => "Moose::Meta::TypeConstraint",
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot coerce without a type coercion";
  }
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COERCINGWITHOUTCOERCIONS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CoercionAlreadyExists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONALREADYEXISTS';
  package Moose::Exception::CoercionAlreadyExists;
  BEGIN {
    $Moose::Exception::CoercionAlreadyExists::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CoercionAlreadyExists::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'constraint_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "A coercion action already exists for '".$self->constraint_name."'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONALREADYEXISTS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CoercionNeedsTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONNEEDSTYPECONSTRAINT';
  package Moose::Exception::CoercionNeedsTypeConstraint;
  BEGIN {
    $Moose::Exception::CoercionNeedsTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CoercionNeedsTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have coercion without specifying a type constraint on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONNEEDSTYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ConflictDetectedInCheckRoleExclusions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONS';
  package Moose::Exception::ConflictDetectedInCheckRoleExclusions;
  BEGIN {
    $Moose::Exception::ConflictDetectedInCheckRoleExclusions::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ConflictDetectedInCheckRoleExclusions::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'excluded_role' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Conflict detected: " . $self->role->name . " excludes role '" . $self->excluded_role->name . "'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ConflictDetectedInCheckRoleExclusionsInToClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONSINTOCLASS';
  package Moose::Exception::ConflictDetectedInCheckRoleExclusionsInToClass;
  BEGIN {
    $Moose::Exception::ConflictDetectedInCheckRoleExclusionsInToClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ConflictDetectedInCheckRoleExclusionsInToClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  sub _build_message {
      my $self = shift;
      "Conflict detected: " . $self->class->name . " excludes role '" . $self->role->name . "'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONSINTOCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ConstructClassInstanceTakesPackageName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CONSTRUCTCLASSINSTANCETAKESPACKAGENAME';
  package Moose::Exception::ConstructClassInstanceTakesPackageName;
  BEGIN {
    $Moose::Exception::ConstructClassInstanceTakesPackageName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ConstructClassInstanceTakesPackageName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You must pass a package name";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CONSTRUCTCLASSINSTANCETAKESPACKAGENAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CouldNotCreateMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEMETHOD';
  package Moose::Exception::CouldNotCreateMethod;
  BEGIN {
    $Moose::Exception::CouldNotCreateMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CouldNotCreateMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'option_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'option_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not create the '".$self->option_name."' method for " . $self->attribute->name . " because : ".$self->error;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CouldNotCreateWriter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEWRITER';
  package Moose::Exception::CouldNotCreateWriter;
  BEGIN {
    $Moose::Exception::CouldNotCreateWriter::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CouldNotCreateWriter::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::EitherAttributeOrAttributeName', 'Moose::Exception::Role::Instance';
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $attribute_name = $self->attribute_name;
  
      return "Could not create writer for '$attribute_name' "
          . "because $error";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEWRITER

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CouldNotEvalConstructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALCONSTRUCTOR';
  package Moose::Exception::CouldNotEvalConstructor;
  BEGIN {
    $Moose::Exception::CouldNotEvalConstructor::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CouldNotEvalConstructor::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'constructor_method' => (
      is       => 'ro',
      isa      => 'Class::MOP::Method::Constructor',
      required => 1
  );
  
  has 'source' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $source = $self->source;
  
      return "Could not eval the constructor :\n\n$source\n\nbecause :\n\n$error";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALCONSTRUCTOR

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CouldNotEvalDestructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALDESTRUCTOR';
  package Moose::Exception::CouldNotEvalDestructor;
  BEGIN {
    $Moose::Exception::CouldNotEvalDestructor::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CouldNotEvalDestructor::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_destructor_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Destructor',
      required => 1
  );
  
  has 'source' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $source = $self->source;
  
      return "Could not eval the destructor :\n\n$source\n\nbecause :\n\n$error";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALDESTRUCTOR

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CouldNotFindTypeConstraintToCoerceFrom.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTFINDTYPECONSTRAINTTOCOERCEFROM';
  package Moose::Exception::CouldNotFindTypeConstraintToCoerceFrom;
  BEGIN {
    $Moose::Exception::CouldNotFindTypeConstraintToCoerceFrom::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CouldNotFindTypeConstraintToCoerceFrom::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'constraint_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not find the type constraint (".$self->constraint_name.") to coerce from";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTFINDTYPECONSTRAINTTOCOERCEFROM

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CouldNotGenerateInlineAttributeMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTGENERATEINLINEATTRIBUTEMETHOD';
  package Moose::Exception::CouldNotGenerateInlineAttributeMethod;
  BEGIN {
    $Moose::Exception::CouldNotGenerateInlineAttributeMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CouldNotGenerateInlineAttributeMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'option' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str|Moose::Exception',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not generate inline ".$self->option." because : ".$self->error;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTGENERATEINLINEATTRIBUTEMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CouldNotLocateTypeConstraintForUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTLOCATETYPECONSTRAINTFORUNION';
  package Moose::Exception::CouldNotLocateTypeConstraintForUnion;
  BEGIN {
    $Moose::Exception::CouldNotLocateTypeConstraintForUnion::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CouldNotLocateTypeConstraintForUnion::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not locate type constraint (".$self->type_name.") for the union";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTLOCATETYPECONSTRAINTFORUNION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CouldNotParseType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTPARSETYPE';
  package Moose::Exception::CouldNotParseType;
  BEGIN {
    $Moose::Exception::CouldNotParseType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CouldNotParseType::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'position' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type;
      my $length = length($type);
      my $position = $self->position;
  
      return "'$type' didn't parse (parse-pos=$position"
          . " and str-length=$length)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTPARSETYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CreateMOPClassTakesArrayRefOfAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFATTRIBUTES';
  package Moose::Exception::CreateMOPClassTakesArrayRefOfAttributes;
  BEGIN {
    $Moose::Exception::CreateMOPClassTakesArrayRefOfAttributes::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CreateMOPClassTakesArrayRefOfAttributes::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an ARRAY ref of attributes";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFATTRIBUTES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CreateMOPClassTakesArrayRefOfSuperclasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFSUPERCLASSES';
  package Moose::Exception::CreateMOPClassTakesArrayRefOfSuperclasses;
  BEGIN {
    $Moose::Exception::CreateMOPClassTakesArrayRefOfSuperclasses::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CreateMOPClassTakesArrayRefOfSuperclasses::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an ARRAY ref of superclasses";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFSUPERCLASSES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CreateMOPClassTakesHashRefOfMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESHASHREFOFMETHODS';
  package Moose::Exception::CreateMOPClassTakesHashRefOfMethods;
  BEGIN {
    $Moose::Exception::CreateMOPClassTakesHashRefOfMethods::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CreateMOPClassTakesHashRefOfMethods::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an HASH ref of methods";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESHASHREFOFMETHODS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CreateTakesArrayRefOfRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESARRAYREFOFROLES';
  package Moose::Exception::CreateTakesArrayRefOfRoles;
  BEGIN {
    $Moose::Exception::CreateTakesArrayRefOfRoles::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CreateTakesArrayRefOfRoles::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass an ARRAY ref of roles";
  }
  
  1;
  
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESARRAYREFOFROLES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CreateTakesHashRefOfAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFATTRIBUTES';
  package Moose::Exception::CreateTakesHashRefOfAttributes;
  BEGIN {
    $Moose::Exception::CreateTakesHashRefOfAttributes::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CreateTakesHashRefOfAttributes::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass a HASH ref of attributes";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFATTRIBUTES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/CreateTakesHashRefOfMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFMETHODS';
  package Moose::Exception::CreateTakesHashRefOfMethods;
  BEGIN {
    $Moose::Exception::CreateTakesHashRefOfMethods::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::CreateTakesHashRefOfMethods::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass a HASH ref of methods";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFMETHODS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/DefaultToMatchOnTypeMustBeCodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DEFAULTTOMATCHONTYPEMUSTBECODEREF';
  package Moose::Exception::DefaultToMatchOnTypeMustBeCodeRef;
  BEGIN {
    $Moose::Exception::DefaultToMatchOnTypeMustBeCodeRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::DefaultToMatchOnTypeMustBeCodeRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'default_action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'cases_to_be_matched' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $default = $self->default_action;
  
      return "Default case must be a CODE ref, not $default";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DEFAULTTOMATCHONTYPEMUSTBECODEREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/DelegationToAClassWhichIsNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOACLASSWHICHISNOTLOADED';
  package Moose::Exception::DelegationToAClassWhichIsNotLoaded;
  BEGIN {
    $Moose::Exception::DelegationToAClassWhichIsNotLoaded::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::DelegationToAClassWhichIsNotLoaded::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'class_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a class which has not been loaded - ".$self->class_name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOACLASSWHICHISNOTLOADED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/DelegationToARoleWhichIsNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOAROLEWHICHISNOTLOADED';
  package Moose::Exception::DelegationToARoleWhichIsNotLoaded;
  BEGIN {
    $Moose::Exception::DelegationToARoleWhichIsNotLoaded::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::DelegationToARoleWhichIsNotLoaded::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a role which has not been loaded - ".$self->role_name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOAROLEWHICHISNOTLOADED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/DelegationToATypeWhichIsNotAClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOATYPEWHICHISNOTACLASS';
  package Moose::Exception::DelegationToATypeWhichIsNotAClass;
  BEGIN {
    $Moose::Exception::DelegationToATypeWhichIsNotAClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::DelegationToATypeWhichIsNotAClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a type (".$self->attribute->type_constraint->name.") that is not backed by a class";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOATYPEWHICHISNOTACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/DoesRequiresRoleName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DOESREQUIRESROLENAME';
  package Moose::Exception::DoesRequiresRoleName;
  BEGIN {
    $Moose::Exception::DoesRequiresRoleName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::DoesRequiresRoleName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Class',
      required => 1,
  );
  
  sub _build_message {
      "You must supply a role name to does()";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_DOESREQUIRESROLENAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/EnumCalledWithAnArrayRefAndAdditionalArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ENUMCALLEDWITHANARRAYREFANDADDITIONALARGS';
  package Moose::Exception::EnumCalledWithAnArrayRefAndAdditionalArgs;
  BEGIN {
    $Moose::Exception::EnumCalledWithAnArrayRefAndAdditionalArgs::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::EnumCalledWithAnArrayRefAndAdditionalArgs::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'array' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      "enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ENUMCALLEDWITHANARRAYREFANDADDITIONALARGS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/EnumValuesMustBeString.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ENUMVALUESMUSTBESTRING';
  package Moose::Exception::EnumValuesMustBeString;
  BEGIN {
    $Moose::Exception::EnumValuesMustBeString::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::EnumValuesMustBeString::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Enum values must be strings, not ".( defined $self->value ? "'".$self->value."'" : "undef" );
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ENUMVALUESMUSTBESTRING

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ExtendsMissingArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_EXTENDSMISSINGARGS';
  package Moose::Exception::ExtendsMissingArgs;
  BEGIN {
    $Moose::Exception::ExtendsMissingArgs::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ExtendsMissingArgs::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "Must derive at least one class";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_EXTENDSMISSINGARGS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/HandlesMustBeAHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_HANDLESMUSTBEAHASHREF';
  package Moose::Exception::HandlesMustBeAHashRef;
  BEGIN {
    $Moose::Exception::HandlesMustBeAHashRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::HandlesMustBeAHashRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'given_handles' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The 'handles' option must be a HASH reference, not ".$self->given_handles;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_HANDLESMUSTBEAHASHREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/IllegalInheritedOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALINHERITEDOPTIONS';
  package Moose::Exception::IllegalInheritedOptions;
  BEGIN {
    $Moose::Exception::IllegalInheritedOptions::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::IllegalInheritedOptions::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'illegal_options' => (
      is       => 'ro',
      traits   => ['Array'],
      handles  => {
          _join_options => 'join',
      },
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Illegal inherited options => (".$self->_join_options(', ').")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALINHERITEDOPTIONS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/IllegalMethodTypeToAddMethodModifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALMETHODTYPETOADDMETHODMODIFIER';
  package Moose::Exception::IllegalMethodTypeToAddMethodModifier;
  BEGIN {
    $Moose::Exception::IllegalMethodTypeToAddMethodModifier::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::IllegalMethodTypeToAddMethodModifier::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'class_or_object' => (
      is       => 'ro',
      isa      => "Any",
      required => 1,
  );
  
  has 'params' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1,
  );
  
  has 'modifier_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Methods passed to ".$self->modifier_name." must be provided as a list, arrayref or regex, not ".$self->params->[0];
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALMETHODTYPETOADDMETHODMODIFIER

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/IncompatibleMetaclassOfSuperclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INCOMPATIBLEMETACLASSOFSUPERCLASS';
  
  package Moose::Exception::IncompatibleMetaclassOfSuperclass;
  BEGIN {
    $Moose::Exception::IncompatibleMetaclassOfSuperclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::IncompatibleMetaclassOfSuperclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has [qw/superclass_name superclass_meta_type/] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      my $ref_class = ref($self->class);
      my $superclass_name = $self->superclass_name;
      my $supermeta_type = $self->superclass_meta_type;
  
      return "The metaclass of $class_name ($ref_class)" .
             " is not compatible with the metaclass of its superclass, " .
             "$superclass_name ($supermeta_type)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INCOMPATIBLEMETACLASSOFSUPERCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InitMetaRequiresClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INITMETAREQUIRESCLASS';
  package Moose::Exception::InitMetaRequiresClass;
  BEGIN {
    $Moose::Exception::InitMetaRequiresClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InitMetaRequiresClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      "Cannot call init_meta without specifying a for_class";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INITMETAREQUIRESCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InitializeTakesUnBlessedPackageName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INITIALIZETAKESUNBLESSEDPACKAGENAME';
  package Moose::Exception::InitializeTakesUnBlessedPackageName;
  BEGIN {
    $Moose::Exception::InitializeTakesUnBlessedPackageName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InitializeTakesUnBlessedPackageName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "You must pass a package name and it cannot be blessed";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INITIALIZETAKESUNBLESSEDPACKAGENAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InstanceBlessedIntoWrongClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEBLESSEDINTOWRONGCLASS';
  package Moose::Exception::InstanceBlessedIntoWrongClass;
  BEGIN {
    $Moose::Exception::InstanceBlessedIntoWrongClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InstanceBlessedIntoWrongClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      "Objects passed as the __INSTANCE__ parameter must already be blessed into the correct class, but ".$self->instance." is not a " . $self->class->name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEBLESSEDINTOWRONGCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InstanceMustBeABlessedReference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEMUSTBEABLESSEDREFERENCE';
  package Moose::Exception::InstanceMustBeABlessedReference;
  BEGIN {
    $Moose::Exception::InstanceMustBeABlessedReference::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InstanceMustBeABlessedReference::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The __INSTANCE__ parameter must be a blessed reference, not ". $self->instance;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEMUSTBEABLESSEDREFERENCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidArgPassedToMooseUtilMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGPASSEDTOMOOSEUTILMETAROLE';
  package Moose::Exception::InvalidArgPassedToMooseUtilMetaRole;
  BEGIN {
    $Moose::Exception::InvalidArgPassedToMooseUtilMetaRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidArgPassedToMooseUtilMetaRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'argument' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = 'When using Moose::Util::MetaRole, you must pass a Moose class name,'
          . ' role name, metaclass object, or metarole object.';
  
      my $arg = $self->argument;
      my $found = blessed $arg ? $arg : Class::MOP::class_of($arg);
  
      my $error2;
  
      if ( defined $found && blessed $found ) {
          $error2 = " You passed ".$arg.", and we resolved this to a "
              . ( blessed $found )
              . ' object.';
      }
      elsif ( !defined $found ) {
          $error2 = " You passed ".( defined $arg ? $arg : "undef" ).", and this did not resolve to a metaclass or metarole."
              . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
      }
      else {
          $error2 = " You passed an undef."
              . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
      }
  
      $error.$error2;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGPASSEDTOMOOSEUTILMETAROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidArgumentToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTTOMETHOD';
  package Moose::Exception::InvalidArgumentToMethod;
  BEGIN {
    $Moose::Exception::InvalidArgumentToMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidArgumentToMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'argument' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has [qw(type type_of_argument method_name)] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'ordinal' => (
      is        => 'ro',
      isa       => 'Str',
      predicate => 'is_ordinal_set'
  );
  
  has 'argument_noun' => (
      is      => 'ro',
      isa     => 'Str',
      default => 'argument'
  );
  
  sub _build_message {
      my $self = shift;
      my $article = ( $self->type_of_argument =~ /^[aeiou]/ ? 'an ' : 'a ');
      my $arg_noun = $self->argument_noun;
  
      if( $self->is_ordinal_set ) {
          "The ".$self->ordinal." $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument;
      }
      else {
          "The $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument;
      }
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTTOMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidArgumentsToTraitAliases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTSTOTRAITALIASES';
  package Moose::Exception::InvalidArgumentsToTraitAliases;
  BEGIN {
    $Moose::Exception::InvalidArgumentsToTraitAliases::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidArgumentsToTraitAliases::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Scalar::Util qw(reftype);
  
  has 'alias' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $alias = $self->alias;
      my $reftype_alias = reftype($alias);
  
      return "$reftype_alias references are not "
          . "valid arguments to the 'trait_aliases' option";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTSTOTRAITALIASES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidBaseTypeGivenToCreateParameterizedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDBASETYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT';
  package Moose::Exception::InvalidBaseTypeGivenToCreateParameterizedTypeConstraint;
  BEGIN {
    $Moose::Exception::InvalidBaseTypeGivenToCreateParameterizedTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidBaseTypeGivenToCreateParameterizedTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not locate the base type (".$self->type_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDBASETYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidHandleValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHANDLEVALUE';
  package Moose::Exception::InvalidHandleValue;
  BEGIN {
    $Moose::Exception::InvalidHandleValue::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidHandleValue::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'handle_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "All values passed to handles must be strings or ARRAY references, not ".$self->handle_value;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHANDLEVALUE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidHasProvidedInARole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHASPROVIDEDINAROLE';
  package Moose::Exception::InvalidHasProvidedInARole;
  BEGIN {
    $Moose::Exception::InvalidHasProvidedInARole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidHasProvidedInARole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      "Usage: has 'name' => ( key => value, ... )";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHASPROVIDEDINAROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidNameForType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDNAMEFORTYPE';
  package Moose::Exception::InvalidNameForType;
  BEGIN {
    $Moose::Exception::InvalidNameForType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidNameForType::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      $self->name." contains invalid characters for a type name. Names can contain alphanumeric character, ':', and '.'";
  }
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDNAMEFORTYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidRoleApplication.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDROLEAPPLICATION';
  package Moose::Exception::InvalidRoleApplication;
  BEGIN {
    $Moose::Exception::InvalidRoleApplication::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidRoleApplication::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'application' => (
      is       => 'ro',
      isa      => "Any",
      required => 1,
  );
  
  sub _build_message {
      "Role applications must be instances of Moose::Meta::Role::Application::ToClass";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDROLEAPPLICATION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPECONSTRAINT';
  package Moose::Exception::InvalidTypeConstraint;
  BEGIN {
    $Moose::Exception::InvalidTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'registry_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeConstraint::Registry',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      return "No type supplied / type is not a valid type constraint";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidTypeGivenToCreateParameterizedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT';
  package Moose::Exception::InvalidTypeGivenToCreateParameterizedTypeConstraint;
  BEGIN {
    $Moose::Exception::InvalidTypeGivenToCreateParameterizedTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidTypeGivenToCreateParameterizedTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not parse type name (".$self->type_name.") correctly";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/InvalidValueForIs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDVALUEFORIS';
  package Moose::Exception::InvalidValueForIs;
  BEGIN {
    $Moose::Exception::InvalidValueForIs::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::InvalidValueForIs::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "I do not understand this option (is => ".$self->params->{is}.") on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDVALUEFORIS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/IsaDoesNotDoTheRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ISADOESNOTDOTHEROLE';
  package Moose::Exception::IsaDoesNotDoTheRole;
  BEGIN {
    $Moose::Exception::IsaDoesNotDoTheRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::IsaDoesNotDoTheRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot have an isa option and a does option if the isa does not do the does on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ISADOESNOTDOTHEROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/IsaLacksDoesMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ISALACKSDOESMETHOD';
  package Moose::Exception::IsaLacksDoesMethod;
  BEGIN {
    $Moose::Exception::IsaLacksDoesMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::IsaLacksDoesMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot have an isa option which cannot ->does() on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ISALACKSDOESMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/LazyAttributeNeedsADefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_LAZYATTRIBUTENEEDSADEFAULT';
  package Moose::Exception::LazyAttributeNeedsADefault;
  BEGIN {
    $Moose::Exception::LazyAttributeNeedsADefault::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::LazyAttributeNeedsADefault::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::EitherAttributeOrAttributeName';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a lazy attribute (".$self->attribute_name.") without specifying a default value for it";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_LAZYATTRIBUTENEEDSADEFAULT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_LEGACY';
  package Moose::Exception::Legacy;
  BEGIN {
    $Moose::Exception::Legacy::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Legacy::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_LEGACY

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MOPAttributeNewNeedsAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MOPATTRIBUTENEWNEEDSATTRIBUTENAME';
  package Moose::Exception::MOPAttributeNewNeedsAttributeName;
  BEGIN {
    $Moose::Exception::MOPAttributeNewNeedsAttributeName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MOPAttributeNewNeedsAttributeName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must provide a name for the attribute";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MOPATTRIBUTENEWNEEDSATTRIBUTENAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MatchActionMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MATCHACTIONMUSTBEACODEREF';
  package Moose::Exception::MatchActionMustBeACodeRef;
  BEGIN {
    $Moose::Exception::MatchActionMustBeACodeRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MatchActionMustBeACodeRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeConstraint',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $action = $self->action;
  
      return "Match action must be a CODE ref, not $action";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MATCHACTIONMUSTBEACODEREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MessageParameterMustBeCodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MESSAGEPARAMETERMUSTBECODEREF';
  package Moose::Exception::MessageParameterMustBeCodeRef;
  BEGIN {
    $Moose::Exception::MessageParameterMustBeCodeRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MessageParameterMustBeCodeRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "The 'message' parameter must be a coderef";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MESSAGEPARAMETERMUSTBECODEREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MetaclassIsAClassNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISACLASSNOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsAClassNotASubclassOfGivenMetaclass;
  BEGIN {
    $Moose::Exception::MetaclassIsAClassNotASubclassOfGivenMetaclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MetaclassIsAClassNotASubclassOfGivenMetaclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass.' ('.$self->class.
          '). You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.';
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISACLASSNOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MetaclassIsARoleNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISAROLENOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsARoleNotASubclassOfGivenMetaclass;
  BEGIN {
    $Moose::Exception::MetaclassIsARoleNotASubclassOfGivenMetaclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MetaclassIsARoleNotASubclassOfGivenMetaclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->role_name." already has a metaclass, but it does not inherit ".$self->metaclass.' ('.$self->role.
          '). You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.';
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISAROLENOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MetaclassIsNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISNOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsNotASubclassOfGivenMetaclass;
  BEGIN {
    $Moose::Exception::MetaclassIsNotASubclassOfGivenMetaclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MetaclassIsNotASubclassOfGivenMetaclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass.' ('.$self->class.').';
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISNOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MetaclassMustBeASubclassOfMooseMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETACLASS';
  package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaClass;
  BEGIN {
    $Moose::Exception::MetaclassMustBeASubclassOfMooseMetaClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MetaclassMustBeASubclassOfMooseMetaClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->class_name." must be a subclass of Moose::Meta::Class."
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MetaclassMustBeASubclassOfMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETAROLE';
  package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaRole;
  BEGIN {
    $Moose::Exception::MetaclassMustBeASubclassOfMooseMetaRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MetaclassMustBeASubclassOfMooseMetaRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->role_name." must be a subclass of Moose::Meta::Role."
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETAROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MetaclassMustBeDerivedFromClassMOPClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEDERIVEDFROMCLASSMOPCLASS';
  package Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass;
  BEGIN {
    $Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'class_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The metaclass (".$self->class_name.") must be derived from Class::MOP::Class";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEDERIVEDFROMCLASSMOPCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MetaclassNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSNOTLOADED';
  package Moose::Exception::MetaclassNotLoaded;
  BEGIN {
    $Moose::Exception::MetaclassNotLoaded::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MetaclassNotLoaded::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->class_name." must be loaded. (Perhaps you forgot to 'use ".$self->class_name."'?)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSNOTLOADED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MetaclassTypeIncompatible.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSTYPEINCOMPATIBLE';
  package Moose::Exception::MetaclassTypeIncompatible;
  BEGIN {
    $Moose::Exception::MetaclassTypeIncompatible::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MetaclassTypeIncompatible::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has [qw(superclass_name metaclass_type)] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      my $superclass_name = $self->superclass_name;
      my $metaclass_type = $self->metaclass_type;
  
      my $metaclass_type_name = $metaclass_type;
      $metaclass_type_name =~ s/_(?:meta)?class$//;
      $metaclass_type_name =~ s/_/ /g;
  
      my $self_metaclass_type = $self->class->$metaclass_type;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
      my $super_metatype = $super_meta->$metaclass_type;
  
     return "The $metaclass_type metaclass for $class_name"
     . " ($self_metaclass_type) is not compatible with the $metaclass_type_name"
     . " metaclass of its superclass, $superclass_name ($super_metatype)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSTYPEINCOMPATIBLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MethodExpectedAMetaclassObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTEDAMETACLASSOBJECT';
  package Moose::Exception::MethodExpectedAMetaclassObject;
  BEGIN {
    $Moose::Exception::MethodExpectedAMetaclassObject::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MethodExpectedAMetaclassObject::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "The is_needed method expected a metaclass object as its arugment";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTEDAMETACLASSOBJECT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MethodExpectsFewerArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSFEWERARGS';
  package Moose::Exception::MethodExpectsFewerArgs;
  BEGIN {
    $Moose::Exception::MethodExpectsFewerArgs::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MethodExpectsFewerArgs::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has 'maximum_args' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      my $max = $self->maximum_args;
      "Cannot call ".$self->method_name." with ".
          ( $max ? "more than $max" : 'any'). " argument".( $max == 1 ? '' : 's' );
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSFEWERARGS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MethodExpectsMoreArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSMOREARGS';
  package Moose::Exception::MethodExpectsMoreArgs;
  BEGIN {
    $Moose::Exception::MethodExpectsMoreArgs::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MethodExpectsMoreArgs::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'minimum_args' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot call ".$self->method_name." without at least ".$self->minimum_args." argument".($self->minimum_args == 1 ? '' : 's');
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSMOREARGS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MethodModifierNeedsMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODMODIFIERNEEDSMETHODNAME';
  package Moose::Exception::MethodModifierNeedsMethodName;
  BEGIN {
    $Moose::Exception::MethodModifierNeedsMethodName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MethodModifierNeedsMethodName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must pass in a method name";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODMODIFIERNEEDSMETHODNAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MethodNameConflictInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMECONFLICTINROLES';
  package Moose::Exception::MethodNameConflictInRoles;
  BEGIN {
    $Moose::Exception::MethodNameConflictInRoles::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MethodNameConflictInRoles::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'conflict' => (
      traits     => ['Array'],
      is         => 'ro',
      isa        => 'ArrayRef[Moose::Meta::Role::Method::Conflicting]',
      handles    => { conflict_methods_count => 'count',
                      get_method_at          => 'get',
                      get_all_methods        => 'elements',
      },
      required   => 1
  );
  
  sub _get_method_names {
      my $self = shift;
  
      return ( $self->conflict_methods_count == 1 ?
          "'".$self->get_method_at(0)->name."'":
          Moose::Util::english_list( map { q{'} . $_->name . q{'} } $self->get_all_methods ) );
  }
  
  sub _build_message {
      my $self = shift;
      my $count = $self->conflict_methods_count;
      my $roles = $self->get_method_at(0)->roles_as_english_list;
  
      if( $count == 1 )
      {
          "Due to a method name conflict in roles "
          .$roles.", the method ".$self->_get_method_names
          ." must be implemented or excluded by '".$self->class_name."'";
      }
      else
      {
          "Due to method name conflicts in roles "
          .$roles.", the methods ".$self->_get_method_names
          ." must be implemented or excluded by '".$self->class_name."'";
      }
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMECONFLICTINROLES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MethodNameNotFoundInInheritanceHierarchy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTFOUNDININHERITANCEHIERARCHY';
  package Moose::Exception::MethodNameNotFoundInInheritanceHierarchy;
  BEGIN {
    $Moose::Exception::MethodNameNotFoundInInheritanceHierarchy::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MethodNameNotFoundInInheritanceHierarchy::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The method '".$self->method_name."' was not found in the inheritance hierarchy for ".$self->class->name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTFOUNDININHERITANCEHIERARCHY

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MethodNameNotGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTGIVEN';
  package Moose::Exception::MethodNameNotGiven;
  BEGIN {
    $Moose::Exception::MethodNameNotGiven::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MethodNameNotGiven::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must define a method name to find";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTGIVEN

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustDefineAMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEAMETHODNAME';
  package Moose::Exception::MustDefineAMethodName;
  BEGIN {
    $Moose::Exception::MustDefineAMethodName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustDefineAMethodName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      "You must define a method name";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEAMETHODNAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustDefineAnAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEANATTRIBUTENAME';
  package Moose::Exception::MustDefineAnAttributeName;
  BEGIN {
    $Moose::Exception::MustDefineAnAttributeName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustDefineAnAttributeName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must define an attribute name";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEANATTRIBUTENAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustHaveAtLeastOneValueToEnumerate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTHAVEATLEASTONEVALUETOENUMERATE';
  package Moose::Exception::MustHaveAtLeastOneValueToEnumerate;
  BEGIN {
    $Moose::Exception::MustHaveAtLeastOneValueToEnumerate::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustHaveAtLeastOneValueToEnumerate::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must have at least one value to enumerate through";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTHAVEATLEASTONEVALUETOENUMERATE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustPassAHashOfOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAHASHOFOPTIONS';
  package Moose::Exception::MustPassAHashOfOptions;
  BEGIN {
    $Moose::Exception::MustPassAHashOfOptions::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustPassAHashOfOptions::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must pass a hash of options";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAHASHOFOPTIONS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustPassAMooseMetaRoleInstanceOrSubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAMOOSEMETAROLEINSTANCEORSUBCLASS';
  package Moose::Exception::MustPassAMooseMetaRoleInstanceOrSubclass;
  BEGIN {
    $Moose::Exception::MustPassAMooseMetaRoleInstanceOrSubclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustPassAMooseMetaRoleInstanceOrSubclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'role' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a Moose::Meta::Role instance (or a subclass)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAMOOSEMETAROLEINSTANCEORSUBCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustPassAPackageNameOrAnExistingClassMOPPackageInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAPACKAGENAMEORANEXISTINGCLASSMOPPACKAGEINSTANCE';
  package Moose::Exception::MustPassAPackageNameOrAnExistingClassMOPPackageInstance;
  BEGIN {
    $Moose::Exception::MustPassAPackageNameOrAnExistingClassMOPPackageInstance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustPassAPackageNameOrAnExistingClassMOPPackageInstance::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a package name or an existing Class::MOP::Package instance";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAPACKAGENAMEORANEXISTINGCLASSMOPPACKAGEINSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustPassEvenNumberOfArguments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFARGUMENTS';
  package Moose::Exception::MustPassEvenNumberOfArguments;
  BEGIN {
    $Moose::Exception::MustPassEvenNumberOfArguments::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustPassEvenNumberOfArguments::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'args' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1
  );
  
  has 'method_name' => (
      is         => 'ro',
      isa        => 'Str',
      required   => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass an even number of arguments to ".$self->method_name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFARGUMENTS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustPassEvenNumberOfAttributeOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFATTRIBUTEOPTIONS';
  package Moose::Exception::MustPassEvenNumberOfAttributeOptions;
  BEGIN {
    $Moose::Exception::MustPassEvenNumberOfAttributeOptions::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustPassEvenNumberOfAttributeOptions::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'options' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      return 'You must pass an even number of attribute options';
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFATTRIBUTEOPTIONS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustProvideANameForTheAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPROVIDEANAMEFORTHEATTRIBUTE';
  package Moose::Exception::MustProvideANameForTheAttribute;
  BEGIN {
    $Moose::Exception::MustProvideANameForTheAttribute::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustProvideANameForTheAttribute::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must provide a name for the attribute";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPROVIDEANAMEFORTHEATTRIBUTE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSpecifyAtleastOneMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEMETHOD';
  package Moose::Exception::MustSpecifyAtleastOneMethod;
  BEGIN {
    $Moose::Exception::MustSpecifyAtleastOneMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSpecifyAtleastOneMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "Must specify at least one method";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSpecifyAtleastOneRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLE';
  package Moose::Exception::MustSpecifyAtleastOneRole;
  BEGIN {
    $Moose::Exception::MustSpecifyAtleastOneRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSpecifyAtleastOneRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "Must specify at least one role";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSpecifyAtleastOneRoleToApplicant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLETOAPPLICANT';
  package Moose::Exception::MustSpecifyAtleastOneRoleToApplicant;
  BEGIN {
    $Moose::Exception::MustSpecifyAtleastOneRoleToApplicant::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSpecifyAtleastOneRoleToApplicant::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'applicant' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Must specify at least one role to apply to ".$self->applicant;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLETOAPPLICANT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSupplyAClassMOPAttributeInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYACLASSMOPATTRIBUTEINSTANCE';
  package Moose::Exception::MustSupplyAClassMOPAttributeInstance;
  BEGIN {
    $Moose::Exception::MustSupplyAClassMOPAttributeInstance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSupplyAClassMOPAttributeInstance::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute which is a 'Class::MOP::Attribute' instance";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYACLASSMOPATTRIBUTEINSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSupplyADelegateToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYADELEGATETOMETHOD';
  package Moose::Exception::MustSupplyADelegateToMethod;
  BEGIN {
    $Moose::Exception::MustSupplyADelegateToMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSupplyADelegateToMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply a delegate_to_method which is a method name or a CODE reference";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYADELEGATETOMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSupplyAMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMETACLASS';
  package Moose::Exception::MustSupplyAMetaclass;
  BEGIN {
    $Moose::Exception::MustSupplyAMetaclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSupplyAMetaclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass a metaclass instance if you want to inline";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMETACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSupplyAMooseMetaAttributeInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMOOSEMETAATTRIBUTEINSTANCE';
  package Moose::Exception::MustSupplyAMooseMetaAttributeInstance;
  BEGIN {
    $Moose::Exception::MustSupplyAMooseMetaAttributeInstance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSupplyAMooseMetaAttributeInstance::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute which is a 'Moose::Meta::Attribute' instance";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMOOSEMETAATTRIBUTEINSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSupplyAnAccessorTypeToConstructWith.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANACCESSORTYPETOCONSTRUCTWITH';
  package Moose::Exception::MustSupplyAnAccessorTypeToConstructWith;
  BEGIN {
    $Moose::Exception::MustSupplyAnAccessorTypeToConstructWith::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSupplyAnAccessorTypeToConstructWith::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an accessor_type to construct with";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANACCESSORTYPETOCONSTRUCTWITH

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSupplyAnAttributeToConstructWith.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANATTRIBUTETOCONSTRUCTWITH';
  package Moose::Exception::MustSupplyAnAttributeToConstructWith;
  BEGIN {
    $Moose::Exception::MustSupplyAnAttributeToConstructWith::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSupplyAnAttributeToConstructWith::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute to construct with";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANATTRIBUTETOCONSTRUCTWITH

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSupplyArrayRefAsCurriedArguments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYARRAYREFASCURRIEDARGUMENTS';
  package Moose::Exception::MustSupplyArrayRefAsCurriedArguments;
  BEGIN {
    $Moose::Exception::MustSupplyArrayRefAsCurriedArguments::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSupplyArrayRefAsCurriedArguments::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must supply a curried_arguments which is an ARRAY reference";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYARRAYREFASCURRIEDARGUMENTS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/MustSupplyPackageNameAndName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYPACKAGENAMEANDNAME';
  package Moose::Exception::MustSupplyPackageNameAndName;
  BEGIN {
    $Moose::Exception::MustSupplyPackageNameAndName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::MustSupplyPackageNameAndName::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must supply the package_name and name parameters";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYPACKAGENAMEANDNAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NeedsTypeConstraintUnionForTypeCoercionUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEEDSTYPECONSTRAINTUNIONFORTYPECOERCIONUNION';
  package Moose::Exception::NeedsTypeConstraintUnionForTypeCoercionUnion;
  BEGIN {
    $Moose::Exception::NeedsTypeConstraintUnionForTypeCoercionUnion::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NeedsTypeConstraintUnionForTypeCoercionUnion::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'type_coercion_union_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeCoercion::Union',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type_constraint = $self->type;
  
      return "You can only create a Moose::Meta::TypeCoercion::Union for a " .
             "Moose::Meta::TypeConstraint::Union, not a $type_constraint"
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEEDSTYPECONSTRAINTUNIONFORTYPECOERCIONUNION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NeitherAttributeNorAttributeNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERATTRIBUTENORATTRIBUTENAMEISGIVEN';
  package Moose::Exception::NeitherAttributeNorAttributeNameIsGiven;
  BEGIN {
    $Moose::Exception::NeitherAttributeNorAttributeNameIsGiven::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NeitherAttributeNorAttributeNameIsGiven::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give attribute or attribute_name or both";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERATTRIBUTENORATTRIBUTENAMEISGIVEN

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NeitherClassNorClassNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERCLASSNORCLASSNAMEISGIVEN';
  package Moose::Exception::NeitherClassNorClassNameIsGiven;
  BEGIN {
    $Moose::Exception::NeitherClassNorClassNameIsGiven::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NeitherClassNorClassNameIsGiven::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give class or class_name or both";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERCLASSNORCLASSNAMEISGIVEN

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NeitherRoleNorRoleNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERROLENORROLENAMEISGIVEN';
  package Moose::Exception::NeitherRoleNorRoleNameIsGiven;
  BEGIN {
    $Moose::Exception::NeitherRoleNorRoleNameIsGiven::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NeitherRoleNorRoleNameIsGiven::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give role or role_name or both";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERROLENORROLENAMEISGIVEN

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NeitherTypeNorTypeNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERTYPENORTYPENAMEISGIVEN';
  package Moose::Exception::NeitherTypeNorTypeNameIsGiven;
  BEGIN {
    $Moose::Exception::NeitherTypeNorTypeNameIsGiven::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NeitherTypeNorTypeNameIsGiven::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give type or type_name or both";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERTYPENORTYPENAMEISGIVEN

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NoAttributeFoundInSuperClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOATTRIBUTEFOUNDINSUPERCLASS';
  package Moose::Exception::NoAttributeFoundInSuperClass;
  BEGIN {
    $Moose::Exception::NoAttributeFoundInSuperClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NoAttributeFoundInSuperClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Could not find an attribute by the name of '".$self->attribute_name."' to inherit from in ".$self->class->name;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOATTRIBUTEFOUNDINSUPERCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NoBodyToInitializeInAnAbstractBaseClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOBODYTOINITIALIZEINANABSTRACTBASECLASS';
  package Moose::Exception::NoBodyToInitializeInAnAbstractBaseClass;
  BEGIN {
    $Moose::Exception::NoBodyToInitializeInAnAbstractBaseClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NoBodyToInitializeInAnAbstractBaseClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "No body to initialize, " .$self->package_name. " is an abstract base class";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOBODYTOINITIALIZEINANABSTRACTBASECLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NoCasesMatched.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOCASESMATCHED';
  package Moose::Exception::NoCasesMatched;
  BEGIN {
    $Moose::Exception::NoCasesMatched::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NoCasesMatched::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'cases_to_be_matched' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $to_match = $self->to_match;
  
      return "No cases matched for $to_match";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOCASESMATCHED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NoConstraintCheckForTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOCONSTRAINTCHECKFORTYPECONSTRAINT';
  package Moose::Exception::NoConstraintCheckForTypeConstraint;
  BEGIN {
    $Moose::Exception::NoConstraintCheckForTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NoConstraintCheckForTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not compile type constraint '".$self->type_name."' because no constraint check";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOCONSTRAINTCHECKFORTYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NoDestructorClassSpecified.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NODESTRUCTORCLASSSPECIFIED';
  package Moose::Exception::NoDestructorClassSpecified;
  BEGIN {
    $Moose::Exception::NoDestructorClassSpecified::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NoDestructorClassSpecified::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      "The 'inline_destructor' option is present, but no destructor class was specified";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NODESTRUCTORCLASSSPECIFIED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NoImmutableTraitSpecifiedForClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOIMMUTABLETRAITSPECIFIEDFORCLASS';
  package Moose::Exception::NoImmutableTraitSpecifiedForClass;
  BEGIN {
    $Moose::Exception::NoImmutableTraitSpecifiedForClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NoImmutableTraitSpecifiedForClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      my $self = shift;
      "no immutable trait specified for ".$self->class;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOIMMUTABLETRAITSPECIFIEDFORCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/NoParentGivenToSubtype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOPARENTGIVENTOSUBTYPE';
  package Moose::Exception::NoParentGivenToSubtype;
  BEGIN {
    $Moose::Exception::NoParentGivenToSubtype::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::NoParentGivenToSubtype::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "A subtype cannot consist solely of a name, it must have a parent";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_NOPARENTGIVENTOSUBTYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/OnlyInstancesCanBeCloned.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ONLYINSTANCESCANBECLONED';
  package Moose::Exception::OnlyInstancesCanBeCloned;
  BEGIN {
    $Moose::Exception::OnlyInstancesCanBeCloned::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::OnlyInstancesCanBeCloned::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You can only clone instances, (".$self->instance.") is not a blessed instance";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ONLYINSTANCESCANBECLONED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/OperatorIsRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_OPERATORISREQUIRED';
  package Moose::Exception::OperatorIsRequired;
  BEGIN {
    $Moose::Exception::OperatorIsRequired::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::OperatorIsRequired::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "operator is required";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_OPERATORISREQUIRED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/OverrideConflictInComposition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINCOMPOSITION';
  package Moose::Exception::OverrideConflictInComposition;
  BEGIN {
    $Moose::Exception::OverrideConflictInComposition::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::OverrideConflictInComposition::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'role_being_applied' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'two_overrides_found' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1,
      default  => 0
  );
  
  sub _build_message {
      my $self = shift;
  
      if( $self->two_overrides_found ) {
          return "Role '" . $self->role_being_applied->name . "' has encountered an 'override' method conflict " .
                 "during composition (Two 'override' methods of the same name encountered). " .
                 "This is fatal error.";
      }
      else {
          return "Role '".$self->role_being_applied->name."' has encountered an 'override' method conflict ".
                 "during composition (A local method of the same name as been found). ".
                 "This is a fatal error.";
      }
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINCOMPOSITION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/OverrideConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINSUMMATION';
  package Moose::Exception::OverrideConflictInSummation;
  BEGIN {
    $Moose::Exception::OverrideConflictInSummation::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::OverrideConflictInSummation::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'role_application' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Application::RoleSummation',
      required => 1
  );
  
  has 'roles' => (
      traits   => ['Array'],
      is       => 'bare',
      isa      => 'ArrayRef[Moose::Meta::Role]',
      handles  => {
          roles      => 'elements',
      },
      required => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'two_overrides_found' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1,
      default  => 0
  );
  
  sub role_names {
      my $self = shift;
      my @roles = $self->roles;
      my @role_names = map { $_->name } @roles;
      return @role_names;
  }
  
  sub _build_message {
      my $self = shift;
  
      my @roles = $self->role_names;
      my $role_names = join "|", @roles;
  
      if( $self->two_overrides_found ) {
          return "We have encountered an 'override' method conflict ".
                 "during composition (Two 'override' methods of the same name encountered). ".
                 "This is fatal error.";
      }
      else {
          return "Role '$role_names' has encountered an 'override' method conflict " .
                 "during composition (A local method of the same name has been found). This " .
                 "is a fatal error." ;
      }
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINSUMMATION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/PackageDoesNotUseMooseExporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGEDOESNOTUSEMOOSEEXPORTER';
  package Moose::Exception::PackageDoesNotUseMooseExporter;
  BEGIN {
    $Moose::Exception::PackageDoesNotUseMooseExporter::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::PackageDoesNotUseMooseExporter::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'package' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'is_loaded' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $package = $self->package;
      return "Package in also ($package) does not seem to "
             . "use Moose::Exporter"
             . ( $self->is_loaded ? "" : " (is it loaded?)" );
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGEDOESNOTUSEMOOSEEXPORTER

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/PackageNameAndNameParamsNotGivenToWrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGENAMEANDNAMEPARAMSNOTGIVENTOWRAP';
  package Moose::Exception::PackageNameAndNameParamsNotGivenToWrap;
  BEGIN {
    $Moose::Exception::PackageNameAndNameParamsNotGivenToWrap::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::PackageNameAndNameParamsNotGivenToWrap::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'code' => (
      is       => 'ro',
      isa      => 'CodeRef',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply the package_name and name parameters";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGENAMEANDNAMEPARAMSNOTGIVENTOWRAP

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/PackagesAndModulesAreNotCachable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGESANDMODULESARENOTCACHABLE';
  package Moose::Exception::PackagesAndModulesAreNotCachable;
  BEGIN {
    $Moose::Exception::PackagesAndModulesAreNotCachable::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::PackagesAndModulesAreNotCachable::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  has 'is_module' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $is_module = $self->is_module;
  
      if( $is_module ) {
          return "Modules are not cacheable";
      } else {
          return "Packages are not cacheable";
      }
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGESANDMODULESARENOTCACHABLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ParameterIsNotSubtypeOfParent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_PARAMETERISNOTSUBTYPEOFPARENT';
  package Moose::Exception::ParameterIsNotSubtypeOfParent;
  BEGIN {
    $Moose::Exception::ParameterIsNotSubtypeOfParent::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ParameterIsNotSubtypeOfParent::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'type_parameter' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type_parameter = $self->type_parameter;
      my $parent = $self->type->parent->type_parameter;
  
      return "$type_parameter is not a subtype of $parent";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_PARAMETERISNOTSUBTYPEOFPARENT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ReferencesAreNotAllowedAsDefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REFERENCESARENOTALLOWEDASDEFAULT';
  package Moose::Exception::ReferencesAreNotAllowedAsDefault;
  BEGIN {
    $Moose::Exception::ReferencesAreNotAllowedAsDefault::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ReferencesAreNotAllowedAsDefault::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "References are not allowed as default values, you must wrap the default of '".
          $self->attribute_name."' in a CODE reference (ex: sub { [] } and not [])";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REFERENCESARENOTALLOWEDASDEFAULT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RequiredAttributeLacksInitialization.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTELACKSINITIALIZATION';
  package Moose::Exception::RequiredAttributeLacksInitialization;
  BEGIN {
    $Moose::Exception::RequiredAttributeLacksInitialization::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RequiredAttributeLacksInitialization::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "A required attribute must have either 'init_arg', 'builder', or 'default'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTELACKSINITIALIZATION

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RequiredAttributeNeedsADefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTENEEDSADEFAULT';
  package Moose::Exception::RequiredAttributeNeedsADefault;
  BEGIN {
    $Moose::Exception::RequiredAttributeNeedsADefault::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RequiredAttributeNeedsADefault::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a required attribute (".$self->attribute_name.") without a default, builder, or an init_arg";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTENEEDSADEFAULT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RequiredMethodsImportedByClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSIMPORTEDBYCLASS';
  package Moose::Exception::RequiredMethodsImportedByClass;
  BEGIN {
    $Moose::Exception::RequiredMethodsImportedByClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RequiredMethodsImportedByClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  has 'missing_methods' => (
      traits   => ['Array'],
      is       => 'ro',
      isa      => 'ArrayRef[Moose::Meta::Role::Method::Required]',
      handles  => { method_count    => 'count',
                    get_method_at   => 'get',
                    get_all_methods => 'elements',
      },
      required => 1
  );
  
  has 'imported_method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Method::Required',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
  
      my $noun = $self->method_count == 1 ? 'method' : 'methods';
      my $list = Moose::Util::english_list( map { q{'} . $_ . q{'} } $self->get_all_methods );
  
      my ($class, $role, $method) = ($self->class_name,
                                     $self->role->name,
                                     $self->imported_method);
  
      my ($class_quoted, $role_quoted) = ("'".$class."'","'".$role."'");
  
      "$role_quoted requires the $noun $list "
          . "to be implemented by $class_quoted. "
          . "If you imported functions intending to use them as "
          . "methods, you need to explicitly mark them as such, via "
          . "$class->meta->add_method($method"
          . " => \\&$method)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSIMPORTEDBYCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RequiredMethodsNotImplementedByClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSNOTIMPLEMENTEDBYCLASS';
  package Moose::Exception::RequiredMethodsNotImplementedByClass;
  BEGIN {
    $Moose::Exception::RequiredMethodsNotImplementedByClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RequiredMethodsNotImplementedByClass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  has 'missing_methods' => (
      traits     => ['Array'],
      is         => 'ro',
      isa        => 'ArrayRef[Moose::Meta::Role::Method::Required]',
      handles    => { method_count    => 'count',
                      get_method_at   => 'get',
                      get_all_methods => 'elements',
      },
      required   => 1
  );
  
  sub _build_message {
      my $self = shift;
  
      my $noun = $self->method_count == 1 ? 'method' : 'methods';
      my $list = Moose::Util::english_list( map { q{'} . $_ . q{'} } $self->get_all_methods );
      my ($role_name, $class_name) = ($self->role_name, $self->class_name);
  
      return "'$role_name' requires the $noun $list "
          . "to be implemented by '$class_name'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSNOTIMPLEMENTEDBYCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTE';
  package Moose::Exception::Role::Attribute;
  BEGIN {
    $Moose::Exception::Role::Attribute::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::Attribute::VERSION = '2.1204';
  use Moose::Role;
  
  has 'attribute' => (
      is        => 'ro',
      isa       => 'Class::MOP::Attribute',
      predicate => 'is_attribute_set'
  );
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/AttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTENAME';
  package Moose::Exception::Role::AttributeName;
  BEGIN {
    $Moose::Exception::Role::AttributeName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::AttributeName::VERSION = '2.1204';
  use Moose::Role;
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTENAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_CLASS';
  package Moose::Exception::Role::Class;
  BEGIN {
    $Moose::Exception::Role::Class::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::Class::VERSION = '2.1204';
  use Moose::Util 'throw_exception';
  use Moose::Role;
  
  has 'class' => (
      is        => 'rw',
      isa       => 'Class::MOP::Class',
      lazy      => 1,
      builder   => '_build_class',
      predicate => 'is_class_set',
  );
  
  has 'class_name' => (
      is        => 'ro',
      isa       => 'Str',
      lazy      => 1,
      builder   => '_build_class_name',
      predicate => 'is_class_name_set',
  );
  
  sub _build_class {
      my $self = $_[0];
      Class::MOP::class_of( $self->class_name );
  }
  
  sub _build_class_name {
      my $self = $_[0];
      $self->class->name;
  }
  
  sub _has_class_or_class_name {
      my $self = shift;
  
      return ( $self->is_class_name_set || $self->is_class_set );
  }
  
  after "BUILD" => sub {
      my $self = $_[0];
  
      if( !$self->_has_class_or_class_name() )
      {
          throw_exception("NeitherClassNorClassNameIsGiven");
      }
      elsif( $self->is_class_set && $self->is_class_name_set &&
             ( $self->class->name ne $self->class_name ) )
      {
          throw_exception( ClassNamesDoNotMatch => class_name => $self->class_name,
                                                   class      => $self->class,
                         );
      }
  };
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_CLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/EitherAttributeOrAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_EITHERATTRIBUTEORATTRIBUTENAME';
  package Moose::Exception::Role::EitherAttributeOrAttributeName;
  BEGIN {
    $Moose::Exception::Role::EitherAttributeOrAttributeName::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::EitherAttributeOrAttributeName::VERSION = '2.1204';
  use Moose::Util 'throw_exception';
  use Moose::Role;
  
  has 'attribute_name' => (
      is         => 'ro',
      isa        => 'Str',
      lazy_build => 1
  );
  
  has 'attribute' => (
      is        => 'ro',
      isa       => 'Class::MOP::Attribute',
      predicate => 'has_attribute'
  );
  
  has 'params' => (
      is        => 'ro',
      isa       => 'HashRef',
      predicate => 'has_params',
  );
  
  sub _build_attribute_name {
      my $self = shift;
  
      if( !$self->has_attribute )
      {
          throw_exception("NeitherAttributeNorAttributeNameIsGiven");
      }
  
      return $self->attribute->name;
  }
  
  after "BUILD" => sub {
      my $self = $_[0];
  
      if( $self->has_attribute_name &&
          $self->has_attribute &&
          ( $self->attribute->name ne $self->attribute_name ) )
      {
          throw_exception( AttributeNamesDoNotMatch => attribute_name => $self->attribute_name,
                                                       attribute      => $self->attribute
                         );
      }
  };
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_EITHERATTRIBUTEORATTRIBUTENAME

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCE';
  package Moose::Exception::Role::Instance;
  BEGIN {
    $Moose::Exception::Role::Instance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::Instance::VERSION = '2.1204';
  use Moose::Role;
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Object',
      required => 1,
  );
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/InvalidAttributeOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INVALIDATTRIBUTEOPTIONS';
  package Moose::Exception::Role::InvalidAttributeOptions;
  BEGIN {
    $Moose::Exception::Role::InvalidAttributeOptions::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::InvalidAttributeOptions::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INVALIDATTRIBUTEOPTIONS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_METHOD';
  package Moose::Exception::Role::Method;
  BEGIN {
    $Moose::Exception::Role::Method::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::Method::VERSION = '2.1204';
  use Moose::Role;
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method',
      required => 1,
  );
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_METHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/ParamsHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_PARAMSHASH';
  package Moose::Exception::Role::ParamsHash;
  BEGIN {
    $Moose::Exception::Role::ParamsHash::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::ParamsHash::VERSION = '2.1204';
  use Moose::Role;
  
  has 'params' => (
      is       => 'ro',
      isa      => 'HashRef',
      required => 1,
  );
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_PARAMSHASH

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLE';
  package Moose::Exception::Role::Role;
  BEGIN {
    $Moose::Exception::Role::Role::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::Role::VERSION = '2.1204';
  use Moose::Util 'throw_exception';
  use Moose::Role;
  
  has 'role' => (
      is        => 'rw',
      isa       => 'Moose::Meta::Role',
      lazy      => 1,
      builder   => '_build_role',
      predicate => 'is_role_set',
  );
  
  has 'role_name' => (
      is        => 'ro',
      isa       => 'Str',
      lazy      => 1,
      builder   => '_build_role_name',
      predicate => 'is_role_name_set',
  );
  
  sub _build_role {
      my $self = $_[0];
      Class::MOP::class_of( $self->role_name );
  }
  
  sub _build_role_name {
      my $self = $_[0];
      $self->role->name;
  }
  
  after "BUILD" => sub {
      my $self = $_[0];
      if( !( $self->is_role_name_set) && !( $self->is_role_set) )
      {
          throw_exception("NeitherRoleNorRoleNameIsGiven");
      }
  
      if( $self->is_role_name_set &&
          $self->is_role_set &&
          ( $self->role->name ne $self->role_name ) )
      {
          throw_exception( RoleNamesDoNotMatch => role_name => $self->role_name,
                                                  role      => $self->role,
                         );
      }
  };
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/RoleForCreate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATE';
  package Moose::Exception::Role::RoleForCreate;
  BEGIN {
    $Moose::Exception::Role::RoleForCreate::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::RoleForCreate::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'attribute_class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
  
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/RoleForCreateMOPClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATEMOPCLASS';
  package Moose::Exception::Role::RoleForCreateMOPClass;
  BEGIN {
    $Moose::Exception::Role::RoleForCreateMOPClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::RoleForCreateMOPClass::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
  
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATEMOPCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/Role/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_TYPECONSTRAINT';
  package Moose::Exception::Role::TypeConstraint;
  BEGIN {
    $Moose::Exception::Role::TypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::Role::TypeConstraint::VERSION = '2.1204';
  use Moose::Role;
  use Moose::Util qw/throw_exception/;
  use Moose::Util::TypeConstraints qw/find_type_constraint/;
  
  has 'type' => (
      is        => 'rw',
      isa       => 'Moose::Meta::TypeConstraint',
      lazy      => 1,
      builder   => '_build_type',
      predicate => 'is_type_set',
  );
  
  has 'type_name' => (
      is        => 'ro',
      isa       => 'Str',
      lazy      => 1,
      builder   => '_build_type_name',
      predicate => 'is_type_name_set',
  );
  
  sub _build_type {
      my $self = $_[0];
      Moose::Util::TypeConstraints::find_type_constraint( $self->type_name );
  }
  
  sub _build_type_name {
      my $self = $_[0];
      $self->type->name;
  }
  
  after "BUILD" => sub {
      my $self = $_[0];
      if( !( $self->is_type_name_set) && !( $self->is_type_set) )
      {
          throw_exception("NeitherTypeNorTypeNameIsGiven");
      }
  
      if( $self->is_type_name_set &&
          $self->is_type_set &&
          ( $self->type->name ne $self->type_name ) )
      {
          throw_exception( TypeNamesDoNotMatch => type_name => $self->type_name,
                                                  type      => $self->type,
                         );
      }
  };
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_TYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RoleDoesTheExcludedRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLEDOESTHEEXCLUDEDROLE';
  package Moose::Exception::RoleDoesTheExcludedRole;
  BEGIN {
    $Moose::Exception::RoleDoesTheExcludedRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RoleDoesTheExcludedRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'excluded_role' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1
  );
  
  has 'second_role' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The role " . $self->role_name . " does the excluded role '".$self->excluded_role->name."'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLEDOESTHEEXCLUDEDROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RoleExclusionConflict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLEEXCLUSIONCONFLICT';
  package Moose::Exception::RoleExclusionConflict;
  BEGIN {
    $Moose::Exception::RoleExclusionConflict::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RoleExclusionConflict::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'roles' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1,
  );
  
  sub _build_message {
      my $self = shift;
  
      my @roles_array = @{$self->roles};
      my $role_noun = "Role".( @roles_array == 1 ? '' : 's');
      my $all_roles = join(', ', @roles_array);
      my $verb = "exclude".( @roles_array == 1 ? 's' : '' );
      my $role_name = $self->role_name;
  
      return "Conflict detected: $role_noun $all_roles $verb role '$role_name'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLEEXCLUSIONCONFLICT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RoleNameRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIRED';
  package Moose::Exception::RoleNameRequired;
  BEGIN {
    $Moose::Exception::RoleNameRequired::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RoleNameRequired::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must supply a role name to look for";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIRED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RoleNameRequiredForMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIREDFORMOOSEMETAROLE';
  package Moose::Exception::RoleNameRequiredForMooseMetaRole;
  BEGIN {
    $Moose::Exception::RoleNameRequiredForMooseMetaRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RoleNameRequiredForMooseMetaRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "You must supply a role name to look for";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIREDFORMOOSEMETAROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RoleNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMESDONOTMATCH';
  package Moose::Exception::RoleNamesDoNotMatch;
  BEGIN {
    $Moose::Exception::RoleNamesDoNotMatch::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RoleNamesDoNotMatch::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has role_name => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has role => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "role_name (".$self-> role_name.") does not match role->name (".$self->role->name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMESDONOTMATCH

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RolesDoNotSupportAugment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTAUGMENT';
  package Moose::Exception::RolesDoNotSupportAugment;
  BEGIN {
    $Moose::Exception::RolesDoNotSupportAugment::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RolesDoNotSupportAugment::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles cannot support 'augment'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTAUGMENT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RolesDoNotSupportExtends.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTEXTENDS';
  package Moose::Exception::RolesDoNotSupportExtends;
  BEGIN {
    $Moose::Exception::RolesDoNotSupportExtends::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RolesDoNotSupportExtends::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles do not support 'extends' (you can use 'with' to specialize a role)";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTEXTENDS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RolesDoNotSupportInner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTINNER';
  package Moose::Exception::RolesDoNotSupportInner;
  BEGIN {
    $Moose::Exception::RolesDoNotSupportInner::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RolesDoNotSupportInner::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles cannot support 'inner'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTINNER

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RolesDoNotSupportRegexReferencesForMethodModifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTREGEXREFERENCESFORMETHODMODIFIERS';
  package Moose::Exception::RolesDoNotSupportRegexReferencesForMethodModifiers;
  BEGIN {
    $Moose::Exception::RolesDoNotSupportRegexReferencesForMethodModifiers::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RolesDoNotSupportRegexReferencesForMethodModifiers::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'modifier_type' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Roles do not currently support regex references for ".$self->modifier_type." method modifiers";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTREGEXREFERENCESFORMETHODMODIFIERS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RolesInCreateTakesAnArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESINCREATETAKESANARRAYREF';
  package Moose::Exception::RolesInCreateTakesAnArrayRef;
  BEGIN {
    $Moose::Exception::RolesInCreateTakesAnArrayRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RolesInCreateTakesAnArrayRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      my $self = shift;
      "You must pass an ARRAY ref of roles";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESINCREATETAKESANARRAYREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/RolesListMustBeInstancesOfMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESLISTMUSTBEINSTANCESOFMOOSEMETAROLE';
  package Moose::Exception::RolesListMustBeInstancesOfMooseMetaRole;
  BEGIN {
    $Moose::Exception::RolesListMustBeInstancesOfMooseMetaRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::RolesListMustBeInstancesOfMooseMetaRole::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'role' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The list of roles must be instances of Moose::Meta::Role, not ".$self->role;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_ROLESLISTMUSTBEINSTANCESOFMOOSEMETAROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/SingleParamsToNewMustBeHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_SINGLEPARAMSTONEWMUSTBEHASHREF';
  package Moose::Exception::SingleParamsToNewMustBeHashRef;
  BEGIN {
    $Moose::Exception::SingleParamsToNewMustBeHashRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::SingleParamsToNewMustBeHashRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Single parameters to new() must be a HASH ref";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_SINGLEPARAMSTONEWMUSTBEHASHREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/TriggerMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TRIGGERMUSTBEACODEREF';
  package Moose::Exception::TriggerMustBeACodeRef;
  BEGIN {
    $Moose::Exception::TriggerMustBeACodeRef::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::TriggerMustBeACodeRef::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Trigger must be a CODE ref on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TRIGGERMUSTBEACODEREF

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/TypeConstraintCannotBeUsedForAParameterizableType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTCANNOTBEUSEDFORAPARAMETERIZABLETYPE';
  package Moose::Exception::TypeConstraintCannotBeUsedForAParameterizableType;
  BEGIN {
    $Moose::Exception::TypeConstraintCannotBeUsedForAParameterizableType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::TypeConstraintCannotBeUsedForAParameterizableType::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "The " . $self->type_name . " constraint cannot be used, because "
      . $self->type->parent->name . " doesn't subtype or coerce from a parameterizable type."
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTCANNOTBEUSEDFORAPARAMETERIZABLETYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/TypeConstraintIsAlreadyCreated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTISALREADYCREATED';
  package Moose::Exception::TypeConstraintIsAlreadyCreated;
  BEGIN {
    $Moose::Exception::TypeConstraintIsAlreadyCreated::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::TypeConstraintIsAlreadyCreated::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'package_defined_in' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "The type constraint '".$self->type->name."' has already been created in ".$self->type->_package_defined_in." and cannot be created again in ".$self->package_defined_in;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTISALREADYCREATED

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/TypeNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TYPENAMESDONOTMATCH';
  package Moose::Exception::TypeNamesDoNotMatch;
  BEGIN {
    $Moose::Exception::TypeNamesDoNotMatch::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::TypeNamesDoNotMatch::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has type_name => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has type => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeConstraint',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "type_name (".$self-> type_name.") does not match type->name (".$self->type->name.")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TYPENAMESDONOTMATCH

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/TypeParameterMustBeMooseMetaType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TYPEPARAMETERMUSTBEMOOSEMETATYPE';
  package Moose::Exception::TypeParameterMustBeMooseMetaType;
  BEGIN {
    $Moose::Exception::TypeParameterMustBeMooseMetaType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::TypeParameterMustBeMooseMetaType::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      "The type parameter must be a Moose meta type";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_TYPEPARAMETERMUSTBEMOOSEMETATYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/UnableToCanonicalizeHandles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZEHANDLES';
  package Moose::Exception::UnableToCanonicalizeHandles;
  BEGIN {
    $Moose::Exception::UnableToCanonicalizeHandles::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::UnableToCanonicalizeHandles::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'handles' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Unable to canonicalize the 'handles' option with ".$self->handles;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZEHANDLES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/UnableToCanonicalizeNonRolePackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZENONROLEPACKAGE';
  package Moose::Exception::UnableToCanonicalizeNonRolePackage;
  BEGIN {
    $Moose::Exception::UnableToCanonicalizeNonRolePackage::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::UnableToCanonicalizeNonRolePackage::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'handles' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Unable to canonicalize the 'handles' option with ".$self->handles." because its metaclass is not a Moose::Meta::Role";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZENONROLEPACKAGE

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/UnableToRecognizeDelegateMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETORECOGNIZEDELEGATEMETACLASS';
  package Moose::Exception::UnableToRecognizeDelegateMetaclass;
  BEGIN {
    $Moose::Exception::UnableToRecognizeDelegateMetaclass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::UnableToRecognizeDelegateMetaclass::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'delegate_metaclass' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $meta = $self->delegate_metaclass;
  
      return "Unable to recognize the delegate metaclass '$meta'";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETORECOGNIZEDELEGATEMETACLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/UndefinedHashKeysPassedToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNDEFINEDHASHKEYSPASSEDTOMETHOD';
  package Moose::Exception::UndefinedHashKeysPassedToMethod;
  BEGIN {
    $Moose::Exception::UndefinedHashKeysPassedToMethod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::UndefinedHashKeysPassedToMethod::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'hash_keys' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Hash keys passed to ".$self->method_name." must be defined";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNDEFINEDHASHKEYSPASSEDTOMETHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/UnionCalledWithAnArrayRefAndAdditionalArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNIONCALLEDWITHANARRAYREFANDADDITIONALARGS';
  package Moose::Exception::UnionCalledWithAnArrayRefAndAdditionalArgs;
  BEGIN {
    $Moose::Exception::UnionCalledWithAnArrayRefAndAdditionalArgs::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::UnionCalledWithAnArrayRefAndAdditionalArgs::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  has 'array' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      "union called with an array reference and additional arguments";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNIONCALLEDWITHANARRAYREFANDADDITIONALARGS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/UnionTakesAtleastTwoTypeNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNIONTAKESATLEASTTWOTYPENAMES';
  package Moose::Exception::UnionTakesAtleastTwoTypeNames;
  BEGIN {
    $Moose::Exception::UnionTakesAtleastTwoTypeNames::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::UnionTakesAtleastTwoTypeNames::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You must pass in at least 2 type names to make a union";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_UNIONTAKESATLEASTTWOTYPENAMES

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ValidationFailedForInlineTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORINLINETYPECONSTRAINT';
  package Moose::Exception::ValidationFailedForInlineTypeConstraint;
  BEGIN {
    $Moose::Exception::ValidationFailedForInlineTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ValidationFailedForInlineTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'type_constraint_message' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'new_member' => (
      is        => 'ro',
      isa       => 'Bool',
      default   => 0,
      predicate => 'is_a_new_member'
  );
  
  sub _build_message {
      my $self = shift;
  
      my $line1;
  
      if( $self->new_member ) {
          $line1 = "A new member value for ".$self->attribute_name." does not pass its type constraint because: "
      }
      else {
          $line1 = "Attribute (".$self->attribute_name.") does not pass the type constraint because: ";
      }
  
      return $line1 . $self->type_constraint_message;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORINLINETYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/ValidationFailedForTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORTYPECONSTRAINT';
  package Moose::Exception::ValidationFailedForTypeConstraint;
  BEGIN {
    $Moose::Exception::ValidationFailedForTypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::ValidationFailedForTypeConstraint::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => Moose::Util::TypeConstraints->duck_type(["get_message", "name"]),
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error_message = $self->type->get_message($self->value);
  
      if( $self->is_attribute_set )
      {
          my $attribute_name = $self->attribute->name;
          return "Attribute ($attribute_name) does not pass the type constraint because: $error_message";
      }
  
      return $error_message;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORTYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/WrapTakesACodeRefToBless.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_WRAPTAKESACODEREFTOBLESS';
  package Moose::Exception::WrapTakesACodeRefToBless;
  BEGIN {
    $Moose::Exception::WrapTakesACodeRefToBless::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::WrapTakesACodeRefToBless::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'code' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must supply a CODE reference to bless, not (" . ( $self->code ? $self->code : 'undef' ) . ")";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_WRAPTAKESACODEREFTOBLESS

$fatpacked{"x86_64-linux-thread-multi/Moose/Exception/WrongTypeConstraintGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_WRONGTYPECONSTRAINTGIVEN';
  package Moose::Exception::WrongTypeConstraintGiven;
  BEGIN {
    $Moose::Exception::WrongTypeConstraintGiven::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exception::WrongTypeConstraintGiven::VERSION = '2.1204';
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has [qw/required_type given_type attribute_name/] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The type constraint for ".$self->attribute_name." must be a subtype of "
      .$self->required_type." but it's a ".$self->given_type;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_EXCEPTION_WRONGTYPECONSTRAINTGIVEN

$fatpacked{"x86_64-linux-thread-multi/Moose/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_EXPORTER';
  package Moose::Exporter;
  BEGIN {
    $Moose::Exporter::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Exporter::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::Load qw(is_class_loaded);
  use Class::MOP;
  use List::MoreUtils qw( first_index uniq );
  use Moose::Util::MetaRole;
  use Scalar::Util qw(reftype);
  use Sub::Exporter 0.980;
  use Sub::Name qw(subname);
  
  use Moose::Util 'throw_exception';
  
  my %EXPORT_SPEC;
  
  sub setup_import_methods {
      my ( $class, %args ) = @_;
  
      $args{exporting_package} ||= caller();
  
      $class->build_import_methods(
          %args,
          install => [qw(import unimport init_meta)]
      );
  }
  
  # A reminder to intrepid Moose hackers
  # there may be more than one level of exporter
  # don't make doy cry. -- perigrin
  
  sub build_import_methods {
      my ( $class, %args ) = @_;
  
      my $exporting_package = $args{exporting_package} ||= caller();
  
      my $meta_lookup = $args{meta_lookup} || sub { Class::MOP::class_of(shift) };
  
      $EXPORT_SPEC{$exporting_package} = \%args;
  
      my @exports_from = $class->_follow_also($exporting_package);
  
      my $export_recorder = {};
      my $is_reexport     = {};
  
      my $exports = $class->_make_sub_exporter_params(
          [ $exporting_package, @exports_from ],
          $export_recorder,
          $is_reexport,
          $args{meta_lookup}, # so that we don't pass through the default
      );
  
      my $exporter = $class->_make_exporter(
          $exports,
          $is_reexport,
          $meta_lookup,
      );
  
      my %methods;
      $methods{import} = $class->_make_import_sub(
          $exporting_package,
          $exporter,
          \@exports_from,
          $is_reexport,
          $meta_lookup,
      );
  
      $methods{unimport} = $class->_make_unimport_sub(
          $exporting_package,
          $exports,
          $export_recorder,
          $is_reexport,
          $meta_lookup,
      );
  
      $methods{init_meta} = $class->_make_init_meta(
          $exporting_package,
          \%args,
          $meta_lookup,
      );
  
      my $package = Class::MOP::Package->initialize($exporting_package);
      for my $to_install ( @{ $args{install} || [] } ) {
          my $symbol = '&' . $to_install;
          next
              unless $methods{$to_install}
                  && !$package->has_package_symbol($symbol);
          $package->add_package_symbol( $symbol, $methods{$to_install} );
      }
  
      return ( $methods{import}, $methods{unimport}, $methods{init_meta} );
  }
  
  sub _make_exporter {
      my ($class, $exports, $is_reexport, $meta_lookup) = @_;
  
      return Sub::Exporter::build_exporter(
          {
              exports   => $exports,
              groups    => { default => [':all'] },
              installer => sub {
                  my ($arg, $to_export) = @_;
                  my $meta = $meta_lookup->($arg->{into});
  
                  goto &Sub::Exporter::default_installer unless $meta;
  
                  # don't overwrite existing symbols with our magically flagged
                  # version of it if we would install the same sub that's already
                  # in the importer
  
                  my @filtered_to_export;
                  my %installed;
                  for (my $i = 0; $i < @{ $to_export }; $i += 2) {
                      my ($as, $cv) = @{ $to_export }[$i, $i + 1];
  
                      next if !ref($as)
                           && $meta->has_package_symbol('&' . $as)
                           && $meta->get_package_symbol('&' . $as) == $cv;
  
                      push @filtered_to_export, $as, $cv;
                      $installed{$as} = 1 unless ref $as;
                  }
  
                  Sub::Exporter::default_installer($arg, \@filtered_to_export);
  
                  for my $name ( keys %{$is_reexport} ) {
                      no strict 'refs';
                      no warnings 'once';
                      next unless exists $installed{$name};
                      _flag_as_reexport( \*{ join q{::}, $arg->{into}, $name } );
                  }
              },
          }
      );
  }
  
  sub _follow_also {
      my $class             = shift;
      my $exporting_package = shift;
  
      _die_if_cycle_found_in_also_list_for_package($exporting_package);
  
      return uniq( _follow_also_real($exporting_package) );
  }
  
  sub _follow_also_real {
      my $exporting_package = shift;
      my @also              = _also_list_for_package($exporting_package);
  
      return map { $_, _follow_also_real($_) } @also;
  }
  
  sub _also_list_for_package {
      my $package = shift;
  
      if ( !exists $EXPORT_SPEC{$package} ) {
          my $loaded = is_class_loaded($package);
  
          throw_exception( PackageDoesNotUseMooseExporter => package   => $package,
                                                             is_loaded => $loaded
                         );
      }
  
      my $also = $EXPORT_SPEC{$package}{also};
  
      return unless defined $also;
  
      return ref $also ? @$also : $also;
  }
  
  # this is no Tarjan algorithm, but for the list sizes expected,
  # brute force will probably be fine (and more maintainable)
  sub _die_if_cycle_found_in_also_list_for_package {
      my $package = shift;
      _die_if_also_list_cycles_back_to_existing_stack(
          [ _also_list_for_package($package) ],
          [$package],
      );
  }
  
  sub _die_if_also_list_cycles_back_to_existing_stack {
      my ( $also_list, $existing_stack ) = @_;
  
      return unless @$also_list && @$existing_stack;
  
      for my $also_member (@$also_list) {
          for my $stack_member (@$existing_stack) {
              next unless $also_member eq $stack_member;
  
              throw_exception( CircularReferenceInAlso => also_parameter => $also_member,
                                                          stack          => $existing_stack
                             );
          }
  
          _die_if_also_list_cycles_back_to_existing_stack(
              [ _also_list_for_package($also_member) ],
              [ $also_member, @$existing_stack ],
          );
      }
  }
  
  sub _parse_trait_aliases {
      my $class   = shift;
      my ($package, $aliases) = @_;
  
      my @ret;
      for my $alias (@$aliases) {
          my $name;
          if (ref($alias)) {
              reftype($alias) eq 'ARRAY'
                  or throw_exception( InvalidArgumentsToTraitAliases => class_name   => $class,
                                                                        package_name => $package,
                                                                        alias        => $alias
                                    );
              ($alias, $name) = @$alias;
          }
          else {
              ($name = $alias) =~ s/.*:://;
          }
          push @ret, subname "${package}::${name}" => sub () { $alias };
      }
  
      return @ret;
  }
  
  sub _make_sub_exporter_params {
      my $class                = shift;
      my $packages             = shift;
      my $export_recorder      = shift;
      my $is_reexport          = shift;
      my $meta_lookup_override = shift;
  
      my %exports;
      my $current_meta_lookup;
  
      for my $package ( @{$packages} ) {
          my $args = $EXPORT_SPEC{$package}
              or die "The $package package does not use Moose::Exporter\n";
  
          $current_meta_lookup = $meta_lookup_override || $args->{meta_lookup};
          $meta_lookup_override = $current_meta_lookup;
  
          my $meta_lookup = $current_meta_lookup
                         || sub { Class::MOP::class_of(shift) };
  
          for my $name ( @{ $args->{with_meta} } ) {
              my $sub = $class->_sub_from_package( $package, $name )
                  or next;
  
              my $fq_name = $package . '::' . $name;
  
              $exports{$name} = $class->_make_wrapped_sub_with_meta(
                  $fq_name,
                  $sub,
                  $export_recorder,
                  $meta_lookup,
              ) unless exists $exports{$name};
          }
  
          for my $name ( @{ $args->{with_caller} } ) {
              my $sub = $class->_sub_from_package( $package, $name )
                  or next;
  
              my $fq_name = $package . '::' . $name;
  
              $exports{$name} = $class->_make_wrapped_sub(
                  $fq_name,
                  $sub,
                  $export_recorder,
              ) unless exists $exports{$name};
          }
  
          my @extra_exports = $class->_parse_trait_aliases(
              $package, $args->{trait_aliases},
          );
          for my $name ( @{ $args->{as_is} }, @extra_exports ) {
              my ( $sub, $coderef_name );
  
              if ( ref $name ) {
                  $sub = $name;
  
                  my $coderef_pkg;
                  ( $coderef_pkg, $coderef_name )
                      = Class::MOP::get_code_info($name);
  
                  if ( $coderef_pkg ne $package ) {
                      $is_reexport->{$coderef_name} = 1;
                  }
              }
              else {
                  $sub = $class->_sub_from_package( $package, $name )
                      or next;
  
                  $coderef_name = $name;
              }
  
              $export_recorder->{$sub} = 1;
  
              $exports{$coderef_name} = sub { $sub }
                  unless exists $exports{$coderef_name};
          }
      }
  
      return \%exports;
  }
  
  sub _sub_from_package {
      my $sclass  = shift;
      my $package = shift;
      my $name    = shift;
  
      my $sub = do {
          no strict 'refs';
          \&{ $package . '::' . $name };
      };
  
      return $sub if defined &$sub;
  
      Carp::cluck "Trying to export undefined sub ${package}::${name}";
  
      return;
  }
  
  our $CALLER;
  
  sub _make_wrapped_sub {
      my $self            = shift;
      my $fq_name         = shift;
      my $sub             = shift;
      my $export_recorder = shift;
  
      # We need to set the package at import time, so that when
      # package Foo imports has(), we capture "Foo" as the
      # package. This lets other packages call Foo::has() and get
      # the right package. This is done for backwards compatibility
      # with existing production code, not because this is a good
      # idea ;)
      return sub {
          my $caller = $CALLER;
  
          my $wrapper = $self->_curry_wrapper( $sub, $fq_name, $caller );
  
          my $sub = subname( $fq_name => $wrapper );
  
          $export_recorder->{$sub} = 1;
  
          return $sub;
      };
  }
  
  sub _make_wrapped_sub_with_meta {
      my $self            = shift;
      my $fq_name         = shift;
      my $sub             = shift;
      my $export_recorder = shift;
      my $meta_lookup     = shift;
  
      return sub {
          my $caller = $CALLER;
  
          my $wrapper = $self->_late_curry_wrapper(
              $sub, $fq_name,
              $meta_lookup => $caller
          );
  
          my $sub = subname( $fq_name => $wrapper );
  
          $export_recorder->{$sub} = 1;
  
          return $sub;
      };
  }
  
  sub _curry_wrapper {
      my $class   = shift;
      my $sub     = shift;
      my $fq_name = shift;
      my @extra   = @_;
  
      my $wrapper = sub { $sub->( @extra, @_ ) };
      if ( my $proto = prototype $sub ) {
  
          # XXX - Perl's prototype sucks. Use & to make set_prototype
          # ignore the fact that we're passing "private variables"
          &Scalar::Util::set_prototype( $wrapper, $proto );
      }
      return $wrapper;
  }
  
  sub _late_curry_wrapper {
      my $class   = shift;
      my $sub     = shift;
      my $fq_name = shift;
      my $extra   = shift;
      my @ex_args = @_;
  
      my $wrapper = sub {
  
          # resolve curried arguments at runtime via this closure
          my @curry = ( $extra->(@ex_args) );
          return $sub->( @curry, @_ );
      };
  
      if ( my $proto = prototype $sub ) {
  
          # XXX - Perl's prototype sucks. Use & to make set_prototype
          # ignore the fact that we're passing "private variables"
          &Scalar::Util::set_prototype( $wrapper, $proto );
      }
      return $wrapper;
  }
  
  sub _make_import_sub {
      shift;
      my $exporting_package = shift;
      my $exporter          = shift;
      my $exports_from      = shift;
      my $is_reexport       = shift;
      my $meta_lookup       = shift;
  
      return sub {
  
          # I think we could use Sub::Exporter's collector feature
          # to do this, but that would be rather gross, since that
          # feature isn't really designed to return a value to the
          # caller of the exporter sub.
          #
          # Also, this makes sure we preserve backwards compat for
          # _get_caller, so it always sees the arguments in the
          # expected order.
          my $traits;
          ( $traits, @_ ) = _strip_traits(@_);
  
          my $metaclass;
          ( $metaclass, @_ ) = _strip_metaclass(@_);
          $metaclass
              = Moose::Util::resolve_metaclass_alias( 'Class' => $metaclass )
              if defined $metaclass && length $metaclass;
  
          my $meta_name;
          ( $meta_name, @_ ) = _strip_meta_name(@_);
  
          # Normally we could look at $_[0], but in some weird cases
          # (involving goto &Moose::import), $_[0] ends as something
          # else (like Squirrel).
          my $class = $exporting_package;
  
          $CALLER = _get_caller(@_);
  
          # this works because both pragmas set $^H (see perldoc
          # perlvar) which affects the current compilation -
          # i.e. the file who use'd us - which is why we don't need
          # to do anything special to make it affect that file
          # rather than this one (which is already compiled)
  
          strict->import;
          warnings->import;
  
          my $did_init_meta;
          for my $c ( grep { $_->can('init_meta') } $class, @{$exports_from} ) {
  
              # init_meta can apply a role, which when loaded uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              $c->init_meta(
                  for_class => $CALLER,
                  metaclass => $metaclass,
                  meta_name => $meta_name,
              );
              $did_init_meta = 1;
          }
  
          {
              # The metaroles will use Moose::Role, which in turn uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              _apply_metaroles(
                  $CALLER,
                  [$class, @$exports_from],
                  $meta_lookup
              );
          }
  
          if ( $did_init_meta && @{$traits} ) {
  
              # The traits will use Moose::Role, which in turn uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              _apply_meta_traits( $CALLER, $traits, $meta_lookup );
          }
          elsif ( @{$traits} ) {
              throw_exception( ClassDoesNotHaveInitMeta => class_name => $class,
                                                           traits     => $traits
                             );
          }
  
          my ( undef, @args ) = @_;
          my $extra = shift @args if ref $args[0] eq 'HASH';
  
          $extra ||= {};
          if ( !$extra->{into} ) {
              $extra->{into_level} ||= 0;
              $extra->{into_level}++;
          }
  
          $class->$exporter( $extra, @args );
      };
  }
  
  sub _strip_traits {
      my $idx = first_index { ( $_ || '' ) eq '-traits' } @_;
  
      return ( [], @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $traits = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      $traits = [$traits] unless ref $traits;
  
      return ( $traits, @_ );
  }
  
  sub _strip_metaclass {
      my $idx = first_index { ( $_ || '' ) eq '-metaclass' } @_;
  
      return ( undef, @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $metaclass = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      return ( $metaclass, @_ );
  }
  
  sub _strip_meta_name {
      my $idx = first_index { ( $_ || '' ) eq '-meta_name' } @_;
  
      return ( 'meta', @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $meta_name = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      return ( $meta_name, @_ );
  }
  
  sub _apply_metaroles {
      my ($class, $exports_from, $meta_lookup) = @_;
  
      my $metaroles = _collect_metaroles($exports_from);
      my $base_class_roles = delete $metaroles->{base_class_roles};
  
      my $meta = $meta_lookup->($class);
      # for instance, Moose.pm uses Moose::Util::TypeConstraints
      return unless $meta;
  
      Moose::Util::MetaRole::apply_metaroles(
          for => $meta,
          %$metaroles,
      ) if keys %$metaroles;
  
      Moose::Util::MetaRole::apply_base_class_roles(
          for   => $meta,
          roles => $base_class_roles,
      ) if $meta->isa('Class::MOP::Class')
        && $base_class_roles && @$base_class_roles;
  }
  
  sub _collect_metaroles {
      my ($exports_from) = @_;
  
      my @old_style_role_types = map { "${_}_roles" } qw(
          metaclass
          attribute_metaclass
          method_metaclass
          wrapped_method_metaclass
          instance_metaclass
          constructor_class
          destructor_class
          error_class
      );
  
      my %class_metaroles;
      my %role_metaroles;
      my @base_class_roles;
      my %old_style_roles;
  
      for my $exporter (@$exports_from) {
          my $data = $EXPORT_SPEC{$exporter};
  
          if (exists $data->{class_metaroles}) {
              for my $type (keys %{ $data->{class_metaroles} }) {
                  push @{ $class_metaroles{$type} ||= [] },
                       @{ $data->{class_metaroles}{$type} };
              }
          }
  
          if (exists $data->{role_metaroles}) {
              for my $type (keys %{ $data->{role_metaroles} }) {
                  push @{ $role_metaroles{$type} ||= [] },
                       @{ $data->{role_metaroles}{$type} };
              }
          }
  
          if (exists $data->{base_class_roles}) {
              push @base_class_roles, @{ $data->{base_class_roles} };
          }
  
          for my $type (@old_style_role_types) {
              if (exists $data->{$type}) {
                  push @{ $old_style_roles{$type} ||= [] },
                       @{ $data->{$type} };
              }
          }
      }
  
      return {
          (keys(%class_metaroles)
              ? (class_metaroles  => \%class_metaroles)
              : ()),
          (keys(%role_metaroles)
              ? (role_metaroles   => \%role_metaroles)
              : ()),
          (@base_class_roles
              ? (base_class_roles => \@base_class_roles)
              : ()),
          %old_style_roles,
      };
  }
  
  sub _apply_meta_traits {
      my ( $class, $traits, $meta_lookup ) = @_;
  
      return unless @{$traits};
  
      my $meta = $meta_lookup->($class);
  
      my $type = $meta->isa('Moose::Meta::Role') ? 'Role'
               : $meta->isa('Class::MOP::Class') ? 'Class'
               : confess('Cannot determine metaclass type for '
                             . 'trait application. Meta isa '
                             . ref $meta);
  
      my @resolved_traits = map {
          ref $_
              ? $_
              : Moose::Util::resolve_metatrait_alias( $type => $_ )
      } @$traits;
  
      return unless @resolved_traits;
  
      my %args = ( for => $class );
  
      if ( $meta->isa('Moose::Meta::Role') ) {
          $args{role_metaroles} = { role => \@resolved_traits };
      }
      else {
          $args{class_metaroles} = { class => \@resolved_traits };
      }
  
      Moose::Util::MetaRole::apply_metaroles(%args);
  }
  
  sub _get_caller {
  
      # 1 extra level because it's called by import so there's a layer
      # of indirection
      my $offset = 1;
  
      return
            ( ref $_[1] && defined $_[1]->{into} ) ? $_[1]->{into}
          : ( ref $_[1] && defined $_[1]->{into_level} )
          ? caller( $offset + $_[1]->{into_level} )
          : caller($offset);
  }
  
  sub _make_unimport_sub {
      shift;
      my $exporting_package = shift;
      my $exports           = shift;
      my $export_recorder   = shift;
      my $is_reexport       = shift;
      my $meta_lookup       = shift;
  
      return sub {
          my $caller = scalar caller();
          Moose::Exporter->_remove_keywords(
              $caller,
              [ keys %{$exports} ],
              $export_recorder,
              $is_reexport,
          );
      };
  }
  
  sub _remove_keywords {
      shift;
      my $package          = shift;
      my $keywords         = shift;
      my $recorded_exports = shift;
      my $is_reexport      = shift;
  
      no strict 'refs';
  
      foreach my $name ( @{$keywords} ) {
          if ( defined &{ $package . '::' . $name } ) {
              my $sub = \&{ $package . '::' . $name };
  
              # make sure it is from us
              next unless $recorded_exports->{$sub};
  
              if ( $is_reexport->{$name} ) {
                  no strict 'refs';
                  next
                      unless _export_is_flagged(
                              \*{ join q{::} => $package, $name } );
              }
  
              # and if it is from us, then undef the slot
              delete ${ $package . '::' }{$name};
          }
      }
  }
  
  # maintain this for now for backcompat
  # make sure to return a sub to install in the same circumstances as previously
  # but this functionality now happens at the end of ->import
  sub _make_init_meta {
      shift;
      my $class          = shift;
      my $args           = shift;
      my $meta_lookup    = shift;
  
      my %old_style_roles;
      for my $role (
          map {"${_}_roles"}
          qw(
          metaclass
          attribute_metaclass
          method_metaclass
          wrapped_method_metaclass
          instance_metaclass
          constructor_class
          destructor_class
          error_class
          )
          ) {
          $old_style_roles{$role} = $args->{$role}
              if exists $args->{$role};
      }
  
      my %base_class_roles;
      %base_class_roles = ( roles => $args->{base_class_roles} )
          if exists $args->{base_class_roles};
  
      my %new_style_roles = map { $_ => $args->{$_} }
          grep { exists $args->{$_} } qw( class_metaroles role_metaroles );
  
      return unless %new_style_roles || %old_style_roles || %base_class_roles;
  
      return sub {
          shift;
          my %opts = @_;
          $meta_lookup->($opts{for_class});
      };
  }
  
  sub import {
      strict->import;
      warnings->import;
  }
  
  1;
  
  # ABSTRACT: make an import() and unimport() just like Moose.pm
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Exporter - make an import() and unimport() just like Moose.pm
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package MyApp::Moose;
  
    use Moose ();
    use Moose::Exporter;
  
    Moose::Exporter->setup_import_methods(
        with_meta => [ 'has_rw', 'sugar2' ],
        as_is     => [ 'sugar3', \&Some::Random::thing ],
        also      => 'Moose',
    );
  
    sub has_rw {
        my ( $meta, $name, %options ) = @_;
        $meta->add_attribute(
            $name,
            is => 'rw',
            %options,
        );
    }
  
    # then later ...
    package MyApp::User;
  
    use MyApp::Moose;
  
    has 'name';
    has_rw 'size';
    thing;
  
    no MyApp::Moose;
  
  =head1 DESCRIPTION
  
  This module encapsulates the exporting of sugar functions in a
  C<Moose.pm>-like manner. It does this by building custom C<import> and
  C<unimport> methods for your module, based on a spec you provide.
  
  It also lets you "stack" Moose-alike modules so you can export Moose's sugar
  as well as your own, along with sugar from any random C<MooseX> module, as
  long as they all use C<Moose::Exporter>. This feature exists to let you bundle
  a set of MooseX modules into a policy module that developers can use directly
  instead of using Moose itself.
  
  To simplify writing exporter modules, C<Moose::Exporter> also imports
  C<strict> and C<warnings> into your exporter module, as well as into
  modules that use it.
  
  =head1 METHODS
  
  This module provides two public methods:
  
  =over 4
  
  =item B<< Moose::Exporter->setup_import_methods(...) >>
  
  When you call this method, C<Moose::Exporter> builds custom C<import> and
  C<unimport> methods for your module. The C<import> method
  will export the functions you specify, and can also re-export functions
  exported by some other module (like C<Moose.pm>). If you pass any parameters
  for L<Moose::Util::MetaRole>, the C<import> method will also call
  L<Moose::Util::MetaRole::apply_metaroles|Moose::Util::MetaRole/apply_metaroles> and
  L<Moose::Util::MetaRole::apply_base_class_roles|Moose::Util::MetaRole/apply_base_class_roles> as needed, after making
  sure the metaclass is initialized.
  
  The C<unimport> method cleans the caller's namespace of all the exported
  functions. This includes any functions you re-export from other
  packages. However, if the consumer of your package also imports those
  functions from the original package, they will I<not> be cleaned.
  
  Note that if any of these methods already exist, they will not be
  overridden, you will have to use C<build_import_methods> to get the
  coderef that would be installed.
  
  This method accepts the following parameters:
  
  =over 8
  
  =item * with_meta => [ ... ]
  
  This list of function I<names only> will be wrapped and then exported. The
  wrapper will pass the metaclass object for the caller as its first argument.
  
  Many sugar functions will need to use this metaclass object to do something to
  the calling package.
  
  =item * as_is => [ ... ]
  
  This list of function names or sub references will be exported as-is. You can
  identify a subroutine by reference, which is handy to re-export some other
  module's functions directly by reference (C<\&Some::Package::function>).
  
  If you do export some other package's function, this function will never be
  removed by the C<unimport> method. The reason for this is we cannot know if
  the caller I<also> explicitly imported the sub themselves, and therefore wants
  to keep it.
  
  =item * trait_aliases => [ ... ]
  
  This is a list of package names which should have shortened aliases exported,
  similar to the functionality of L<aliased>. Each element in the list can be
  either a package name, in which case the export will be named as the last
  namespace component of the package, or an arrayref, whose first element is the
  package to alias to, and second element is the alias to export.
  
  =item * also => $name or \@names
  
  This is a list of modules which contain functions that the caller
  wants to export. These modules must also use C<Moose::Exporter>. The
  most common use case will be to export the functions from C<Moose.pm>.
  Functions specified by C<with_meta> or C<as_is> take precedence over
  functions exported by modules specified by C<also>, so that a module
  can selectively override functions exported by another module.
  
  C<Moose::Exporter> also makes sure all these functions get removed
  when C<unimport> is called.
  
  =item * meta_lookup => sub { ... }
  
  This is a function which will be called to provide the metaclass
  to be operated upon by the exporter. This is an advanced feature
  intended for use by package generator modules in the vein of
  L<MooseX::Role::Parameterized> in order to simplify reusing sugar
  from other modules that use C<Moose::Exporter>. This function is
  used, for example, to select the metaclass to bind to functions
  that are exported using the C<with_meta> option.
  
  This function will receive one parameter: the class name into which
  the sugar is being exported. The default implementation is:
  
      sub { Class::MOP::class_of(shift) }
  
  Accordingly, this function is expected to return a metaclass.
  
  =back
  
  You can also provide parameters for L<Moose::Util::MetaRole::apply_metaroles|Moose::Util::MetaRole/apply_metaroles>
  and L<Moose::Util::MetaRole::apply_base_class_roles|Moose::Util::MetaRole/apply_base_class_roles>. Specifically, valid parameters
  are "class_metaroles", "role_metaroles", and "base_class_roles".
  
  =item B<< Moose::Exporter->build_import_methods(...) >>
  
  Returns three code refs, one for C<import>, one for C<unimport> and one for
  C<init_meta>.
  
  Accepts the additional C<install> option, which accepts an arrayref of method
  names to install into your exporting package. The valid options are C<import>
  and C<unimport>. Calling C<setup_import_methods> is equivalent
  to calling C<build_import_methods> with C<< install => [qw(import unimport)] >>
  except that it doesn't also return the methods.
  
  The C<import> method is built using L<Sub::Exporter>. This means that it can
  take a hashref of the form C<< { into => $package } >> to specify the package
  it operates on.
  
  Used by C<setup_import_methods>.
  
  =back
  
  =head1 IMPORTING AND init_meta
  
  If you want to set an alternative base object class or metaclass class, see
  above for details on how this module can call L<Moose::Util::MetaRole> for
  you.
  
  If you want to do something that is not supported by this module, simply
  define an C<init_meta> method in your class. The C<import> method that
  C<Moose::Exporter> generates for you will call this method (if it exists). It
  will always pass the caller to this method via the C<for_class> parameter.
  
  Most of the time, your C<init_meta> method will probably just call C<<
  Moose->init_meta >> to do the real work:
  
    sub init_meta {
        shift; # our class name
        return Moose->init_meta( @_, metaclass => 'My::Metaclass' );
    }
  
  =head1 METACLASS TRAITS
  
  The C<import> method generated by C<Moose::Exporter> will allow the
  user of your module to specify metaclass traits in a C<-traits>
  parameter passed as part of the import:
  
    use Moose -traits => 'My::Meta::Trait';
  
    use Moose -traits => [ 'My::Meta::Trait', 'My::Other::Trait' ];
  
  These traits will be applied to the caller's metaclass
  instance. Providing traits for an exporting class that does not create
  a metaclass for the caller is an error.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_EXPORTER

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE';
  use strict;
  use warnings;
  package Moose::Meta::Attribute;
  BEGIN {
    $Moose::Meta::Attribute::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::VERSION = '2.1204';
  use B ();
  use Scalar::Util 'blessed', 'weaken';
  use List::MoreUtils 'any';
  use Try::Tiny;
  use overload     ();
  
  use Moose::Deprecated;
  use Moose::Meta::Method::Accessor;
  use Moose::Meta::Method::Delegation;
  use Moose::Util 'throw_exception';
  use Moose::Util::TypeConstraints ();
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Attribute', 'Moose::Meta::Mixin::AttributeCore';
  
  use Carp 'confess';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  __PACKAGE__->meta->add_attribute('traits' => (
      reader    => 'applied_traits',
      predicate => 'has_applied_traits',
      Class::MOP::_definition_context(),
  ));
  
  # we need to have a ->does method in here to
  # more easily support traits, and the introspection
  # of those traits. We extend the does check to look
  # for metatrait aliases.
  sub does {
      my ($self, $role_name) = @_;
      my $name = try {
          Moose::Util::resolve_metatrait_alias(Attribute => $role_name)
      };
      return 0 if !defined($name); # failed to load class
      return $self->Moose::Object::does($name);
  }
  
  sub _inline_throw_exception {
      my ( $self, $throw_args ) = @_;
      return 'require Moose::Util; Moose::Util::throw_exception('.$throw_args.')';
  }
  
  sub new {
      my ($class, $name, %options) = @_;
      $class->_process_options($name, \%options) unless $options{__hack_no_process_options}; # used from clone()... YECHKKK FIXME ICKY YUCK GROSS
  
      delete $options{__hack_no_process_options};
  
      my %attrs =
          ( map { $_ => 1 }
            grep { defined }
            map { $_->init_arg() }
            $class->meta()->get_all_attributes()
          );
  
      my @bad = sort grep { ! $attrs{$_} }  keys %options;
  
      if (@bad)
      {
          my $s = @bad > 1 ? 's' : '';
          my $list = join "', '", @bad;
  
          my $package = $options{definition_context}{package};
          my $context = $options{definition_context}{context}
                     || 'attribute constructor';
          my $type = $options{definition_context}{type} || 'class';
  
          my $location = '';
          if (defined($package)) {
              $location = " in ";
              $location .= "$type " if $type;
              $location .= $package;
          }
  
          Carp::cluck "Found unknown argument$s '$list' in the $context for '$name'$location";
      }
  
      return $class->SUPER::new($name, %options);
  }
  
  sub interpolate_class_and_new {
      my $class = shift;
      my $name  = shift;
  
      throw_exception( MustPassEvenNumberOfAttributeOptions => attribute_name => $name,
                                                               options        => \@_
                     )
          if @_ % 2 == 1;
  
      my %args = @_;
  
      my ( $new_class, @traits ) = $class->interpolate_class(\%args);
      $new_class->new($name, %args, ( scalar(@traits) ? ( traits => \@traits ) : () ) );
  }
  
  sub interpolate_class {
      my ($class, $options) = @_;
  
      $class = ref($class) || $class;
  
      if ( my $metaclass_name = delete $options->{metaclass} ) {
          my $new_class = Moose::Util::resolve_metaclass_alias( Attribute => $metaclass_name );
  
          if ( $class ne $new_class ) {
              if ( $new_class->can("interpolate_class") ) {
                  return $new_class->interpolate_class($options);
              } else {
                  $class = $new_class;
              }
          }
      }
  
      my @traits;
  
      if (my $traits = $options->{traits}) {
          my $i = 0;
          my $has_foreign_options = 0;
  
          while ($i < @$traits) {
              my $trait = $traits->[$i++];
              next if ref($trait); # options to a trait we discarded
  
              $trait = Moose::Util::resolve_metatrait_alias(Attribute => $trait)
                    || $trait;
  
              next if $class->does($trait);
  
              push @traits, $trait;
  
              # are there options?
              if ($traits->[$i] && ref($traits->[$i])) {
                  $has_foreign_options = 1
                      if any { $_ ne '-alias' && $_ ne '-excludes' } keys %{ $traits->[$i] };
  
                  push @traits, $traits->[$i++];
              }
          }
  
          if (@traits) {
              my %options = (
                  superclasses => [ $class ],
                  roles        => [ @traits ],
              );
  
              if ($has_foreign_options) {
                  $options{weaken} = 0;
              }
              else {
                  $options{cache} = 1;
              }
  
              my $anon_class = Moose::Meta::Class->create_anon_class(%options);
              $class = $anon_class->name;
          }
      }
  
      return ( wantarray ? ( $class, @traits ) : $class );
  }
  
  # ...
  
  # method-generating options shouldn't be overridden
  sub illegal_options_for_inheritance {
      qw(reader writer accessor clearer predicate)
  }
  
  # NOTE/TODO
  # This method *must* be able to handle
  # Class::MOP::Attribute instances as
  # well. Yes, I know that is wrong, but
  # apparently we didn't realize it was
  # doing that and now we have some code
  # which is dependent on it. The real
  # solution of course is to push this
  # feature back up into Class::MOP::Attribute
  # but I not right now, I am too lazy.
  # However if you are reading this and
  # looking for something to do,.. please
  # be my guest.
  # - stevan
  sub clone_and_inherit_options {
      my ($self, %options) = @_;
  
      # NOTE:
      # we may want to extends a Class::MOP::Attribute
      # in which case we need to be able to use the
      # core set of legal options that have always
      # been here. But we allows Moose::Meta::Attribute
      # instances to changes them.
      # - SL
      my @illegal_options = $self->can('illegal_options_for_inheritance')
          ? $self->illegal_options_for_inheritance
          : ();
  
      my @found_illegal_options = grep { exists $options{$_} && exists $self->{$_} ? $_ : undef } @illegal_options;
      (scalar @found_illegal_options == 0)
          || throw_exception( IllegalInheritedOptions => illegal_options => \@found_illegal_options,
                                                         params          => \%options
                            );
  
      $self->_process_isa_option( $self->name, \%options );
      $self->_process_does_option( $self->name, \%options );
  
      # NOTE:
      # this doesn't apply to Class::MOP::Attributes,
      # so we can ignore it for them.
      # - SL
      if ($self->can('interpolate_class')) {
          ( $options{metaclass}, my @traits ) = $self->interpolate_class(\%options);
  
          my %seen;
          my @all_traits = grep { $seen{$_}++ } @{ $self->applied_traits || [] }, @traits;
          $options{traits} = \@all_traits if @all_traits;
      }
  
      # This method can be called on a CMOP::Attribute object, so we need to
      # make sure we can call this method.
      $self->_process_lazy_build_option( $self->name, \%options )
          if $self->can('_process_lazy_build_option');
  
      $self->clone(%options);
  }
  
  sub clone {
      my ( $self, %params ) = @_;
  
      my $class = delete $params{metaclass} || ref $self;
  
      my ( @init, @non_init );
  
      foreach my $attr ( grep { $_->has_value($self) } Class::MOP::class_of($self)->get_all_attributes ) {
          push @{ $attr->has_init_arg ? \@init : \@non_init }, $attr;
      }
  
      my %new_params = ( ( map { $_->init_arg => $_->get_value($self) } @init ), %params );
  
      my $name = delete $new_params{name};
  
      my $clone = $class->new($name, %new_params, __hack_no_process_options => 1 );
  
      foreach my $attr ( @non_init ) {
          $attr->set_value($clone, $attr->get_value($self));
      }
  
      return $clone;
  }
  
  sub _process_options {
      my ( $class, $name, $options ) = @_;
  
      $class->_process_is_option( $name, $options );
      $class->_process_isa_option( $name, $options );
      $class->_process_does_option( $name, $options );
      $class->_process_coerce_option( $name, $options );
      $class->_process_trigger_option( $name, $options );
      $class->_process_auto_deref_option( $name, $options );
      $class->_process_lazy_build_option( $name, $options );
      $class->_process_lazy_option( $name, $options );
      $class->_process_required_option( $name, $options );
  }
  
  sub _process_is_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{is};
  
      ### -------------------------
      ## is => ro, writer => _foo    # turns into (reader => foo, writer => _foo) as before
      ## is => rw, writer => _foo    # turns into (reader => foo, writer => _foo)
      ## is => rw, accessor => _foo  # turns into (accessor => _foo)
      ## is => ro, accessor => _foo  # error, accesor is rw
      ### -------------------------
  
      if ( $options->{is} eq 'ro' ) {
          throw_exception("AccessorMustReadWrite" => attribute_name => $name,
                                                     params         => $options,
                         )
              if exists $options->{accessor};
          $options->{reader} ||= $name;
      }
      elsif ( $options->{is} eq 'rw' ) {
          if ( $options->{writer} ) {
              $options->{reader} ||= $name;
          }
          else {
              $options->{accessor} ||= $name;
          }
      }
      elsif ( $options->{is} eq 'bare' ) {
          return;
          # do nothing, but don't complain (later) about missing methods
      }
      else {
          throw_exception( InvalidValueForIs => attribute_name => $name,
                                                params         => $options,
                         );
      }
  }
  
  sub _process_isa_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{isa};
  
      if ( exists $options->{does} ) {
          if ( try { $options->{isa}->can('does') } ) {
              ( $options->{isa}->does( $options->{does} ) )
                  || throw_exception( IsaDoesNotDoTheRole => attribute_name => $name,
                                                             params         => $options,
                                    );
          }
          else {
              throw_exception( IsaLacksDoesMethod => attribute_name => $name,
                                                     params         => $options,
                             );
          }
      }
  
      # allow for anon-subtypes here ...
      #
      # Checking for Specio explicitly is completely revolting. At some point
      # this needs to be refactored so that Moose core defines a standard type
      # API that all types must implement. Unfortunately, the current core API
      # is _not_ the right API, so we probably need to A) come up with the new
      # API (Specio is a good start); B) refactor the core types to implement
      # that API; C) do duck type checking on type objects.
      if ( blessed( $options->{isa} )
          && $options->{isa}->isa('Moose::Meta::TypeConstraint') ) {
          $options->{type_constraint} = $options->{isa};
      }
      elsif (
          blessed( $options->{isa} )
          && Moose::Util::does_role(
              $options->{isa}, 'Specio::Constraint::Role::Interface'
          )
          ) {
          $options->{type_constraint} = $options->{isa};
      }
      else {
          $options->{type_constraint}
              = Moose::Util::TypeConstraints::find_or_create_isa_type_constraint(
              $options->{isa},
              { package_defined_in => $options->{definition_context}->{package} }
          );
      }
  }
  
  sub _process_does_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{does} && ! exists $options->{isa};
  
      # allow for anon-subtypes here ...
      if ( blessed( $options->{does} )
          && $options->{does}->isa('Moose::Meta::TypeConstraint') ) {
          $options->{type_constraint} = $options->{does};
      }
      else {
          $options->{type_constraint}
              = Moose::Util::TypeConstraints::find_or_create_does_type_constraint(
              $options->{does},
              { package_defined_in => $options->{definition_context}->{package} }
          );
      }
  }
  
  sub _process_coerce_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{coerce};
  
      ( exists $options->{type_constraint} )
          || throw_exception( CoercionNeedsTypeConstraint => attribute_name => $name,
                                                             params         => $options,
                            );
  
      throw_exception( CannotCoerceAWeakRef => attribute_name => $name,
                                               params         => $options,
                     )
          if $options->{weak_ref};
  
      unless ( $options->{type_constraint}->has_coercion ) {
          my $type = $options->{type_constraint}->name;
  
          throw_exception( CannotCoerceAttributeWhichHasNoCoercion => attribute_name => $name,
                                                                      type_name      => $type,
                                                                      params         => $options
                         );
      }
  }
  
  sub _process_trigger_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{trigger};
  
      ( 'CODE' eq ref $options->{trigger} )
          || throw_exception( TriggerMustBeACodeRef => attribute_name => $name,
                                                       params         => $options,
                            );
  }
  
  sub _process_auto_deref_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{auto_deref};
  
      ( exists $options->{type_constraint} )
          || throw_exception( CannotAutoDerefWithoutIsa => attribute_name => $name,
                                                           params         => $options,
                            );
  
      ( $options->{type_constraint}->is_a_type_of('ArrayRef')
        || $options->{type_constraint}->is_a_type_of('HashRef') )
          || throw_exception( AutoDeRefNeedsArrayRefOrHashRef => attribute_name => $name,
                                                                 params         => $options,
                            );
  }
  
  sub _process_lazy_build_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{lazy_build};
  
      throw_exception( CannotUseLazyBuildAndDefaultSimultaneously => attribute_name => $name,
                                                                     params         => $options,
                     )
          if exists $options->{default};
  
      $options->{lazy} = 1;
      $options->{builder} ||= "_build_${name}";
  
      if ( $name =~ /^_/ ) {
          $options->{clearer}   ||= "_clear${name}";
          $options->{predicate} ||= "_has${name}";
      }
      else {
          $options->{clearer}   ||= "clear_${name}";
          $options->{predicate} ||= "has_${name}";
      }
  }
  
  sub _process_lazy_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{lazy};
  
      ( exists $options->{default} || defined $options->{builder} )
          || throw_exception( LazyAttributeNeedsADefault => params         => $options,
                                                            attribute_name => $name,
                            );
  }
  
  sub _process_required_option {
      my ( $class, $name, $options ) = @_;
  
      if (
          $options->{required}
          && !(
              ( !exists $options->{init_arg} || defined $options->{init_arg} )
              || exists $options->{default}
              || defined $options->{builder}
          )
          ) {
          throw_exception( RequiredAttributeNeedsADefault => params         => $options,
                                                             attribute_name => $name,
                         );
      }
  }
  
  sub initialize_instance_slot {
      my ($self, $meta_instance, $instance, $params) = @_;
      my $init_arg = $self->init_arg();
      # try to fetch the init arg from the %params ...
  
      my $val;
      my $value_is_set;
      if ( defined($init_arg) and exists $params->{$init_arg}) {
          $val = $params->{$init_arg};
          $value_is_set = 1;
      }
      else {
          # skip it if it's lazy
          return if $self->is_lazy;
          # and die if it's required and doesn't have a default value
          throw_exception(AttributeIsRequired => attribute  => $self,
                                                 class_name => blessed( $instance ),
                                                 params     => $params
                         )
              if $self->is_required && !$self->has_default && !$self->has_builder;
  
          # if nothing was in the %params, we can use the
          # attribute's default value (if it has one)
          if ($self->has_default) {
              $val = $self->default($instance);
              $value_is_set = 1;
          }
          elsif ($self->has_builder) {
              $val = $self->_call_builder($instance);
              $value_is_set = 1;
          }
      }
  
      return unless $value_is_set;
  
      $val = $self->_coerce_and_verify( $val, $instance );
  
      $self->set_initial_value($instance, $val);
  
      if ( ref $val && $self->is_weak_ref ) {
          $self->_weaken_value($instance);
      }
  }
  
  sub _call_builder {
      my ( $self, $instance ) = @_;
  
      my $builder = $self->builder();
  
      return $instance->$builder()
          if $instance->can( $self->builder );
  
      throw_exception( BuilderDoesNotExist => instance  => $instance,
                                              attribute => $self,
                     );
  }
  
  ## Slot management
  
  sub _make_initializer_writer_callback {
      my $self = shift;
      my ($meta_instance, $instance, $slot_name) = @_;
      my $old_callback = $self->SUPER::_make_initializer_writer_callback(@_);
      return sub {
          $old_callback->($self->_coerce_and_verify($_[0], $instance));
      };
  }
  
  sub set_value {
      my ($self, $instance, @args) = @_;
      my $value = $args[0];
  
      my $attr_name = quotemeta($self->name);
  
      if ($self->is_required and not @args) {
          throw_exception( AttributeIsRequired => attribute  => $self,
                                                  class_name => blessed( $instance ),
                         );
      }
  
      $value = $self->_coerce_and_verify( $value, $instance );
  
      my @old;
      if ( $self->has_trigger && $self->has_value($instance) ) {
          @old = $self->get_value($instance, 'for trigger');
      }
  
      $self->SUPER::set_value($instance, $value);
  
      if ( ref $value && $self->is_weak_ref ) {
          $self->_weaken_value($instance);
      }
  
      if ($self->has_trigger) {
          $self->trigger->($instance, $value, @old);
      }
  }
  
  sub _inline_set_value {
      my $self = shift;
      my ($instance, $value, $tc, $coercion, $message, $for_constructor) = @_;
  
      my $old     = '@old';
      my $copy    = '$val';
      $tc       ||= '$type_constraint';
      $coercion ||= '$type_coercion';
      $message  ||= '$type_message';
  
      my @code;
      if ($self->_writer_value_needs_copy) {
          push @code, $self->_inline_copy_value($value, $copy);
          $value = $copy;
      }
  
      # constructors already handle required checks
      push @code, $self->_inline_check_required
          unless $for_constructor;
  
      push @code, $self->_inline_tc_code($value, $tc, $coercion, $message);
  
      # constructors do triggers all at once at the end
      push @code, $self->_inline_get_old_value_for_trigger($instance, $old)
          unless $for_constructor;
  
      push @code, (
          $self->SUPER::_inline_set_value($instance, $value),
          $self->_inline_weaken_value($instance, $value),
      );
  
      # constructors do triggers all at once at the end
      push @code, $self->_inline_trigger($instance, $value, $old)
          unless $for_constructor;
  
      return @code;
  }
  
  sub _writer_value_needs_copy {
      my $self = shift;
      return $self->should_coerce;
  }
  
  sub _inline_copy_value {
      my $self = shift;
      my ($value, $copy) = @_;
  
      return 'my ' . $copy . ' = ' . $value . ';'
  }
  
  sub _inline_check_required {
      my $self = shift;
  
      return unless $self->is_required;
  
      my $attr_name = quotemeta($self->name);
  
      return (
          'if (@_ < 2) {',
              $self->_inline_throw_exception( "AttributeIsRequired => ".
                                              'attribute_name      => "'.$attr_name.'",'.
                                              'class_name          => $class_name'
              ) . ';',
          '}',
      );
  }
  
  sub _inline_tc_code {
      my $self = shift;
      my ($value, $tc, $coercion, $message, $is_lazy) = @_;
      return (
          $self->_inline_check_coercion(
              $value, $tc, $coercion, $is_lazy,
          ),
          $self->_inline_check_constraint(
              $value, $tc, $message, $is_lazy,
          ),
      );
  }
  
  sub _inline_check_coercion {
      my $self = shift;
      my ($value, $tc, $coercion) = @_;
  
      return unless $self->should_coerce && $self->type_constraint->has_coercion;
  
      if ( $self->type_constraint->can_be_inlined ) {
          return (
              'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                  $value . ' = ' . $coercion . '->(' . $value . ');',
              '}',
          );
      }
      else {
          return (
              'if (!' . $tc . '->(' . $value . ')) {',
                  $value . ' = ' . $coercion . '->(' . $value . ');',
              '}',
          );
      }
  }
  
  sub _inline_check_constraint {
      my $self = shift;
      my ($value, $tc, $message) = @_;
  
      return unless $self->has_type_constraint;
  
      my $attr_name = quotemeta($self->name);
  
      if ( $self->type_constraint->can_be_inlined ) {
          return (
              'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                  'my $msg = do { local $_ = ' . $value . '; '
                  . $message . '->(' . $value . ');'
                  . '};'.
                  $self->_inline_throw_exception( 'ValidationFailedForInlineTypeConstraint => '.
                                                  'type_constraint_message => $msg , '.
                                                  'class_name              => $class_name, '.
                                                  'attribute_name          => "'.$attr_name.'",'.
                                                  'value                   => '.$value
                  ).';',
              '}',
          );
      }
      else {
          return (
              'if (!' . $tc . '->(' . $value . ')) {',
                  'my $msg = do { local $_ = ' . $value . '; '
                  . $message . '->(' . $value . ');'
                  . '};'.
                  $self->_inline_throw_exception( 'ValidationFailedForInlineTypeConstraint => '.
                                                  'type_constraint_message => $msg , '.
                                                  'class_name              => $class_name, '.
                                                  'attribute_name          => "'.$attr_name.'",'.
                                                  'value                   => '.$value
                  ).';',
              '}',
          );
      }
  }
  
  sub _inline_get_old_value_for_trigger {
      my $self = shift;
      my ($instance, $old) = @_;
  
      return unless $self->has_trigger;
  
      return (
          'my ' . $old . ' = ' . $self->_inline_instance_has($instance),
              '? ' . $self->_inline_instance_get($instance),
              ': ();',
      );
  }
  
  sub _inline_weaken_value {
      my $self = shift;
      my ($instance, $value) = @_;
  
      return unless $self->is_weak_ref;
  
      my $mi = $self->associated_class->get_meta_instance;
      return (
          $mi->inline_weaken_slot_value($instance, $self->name),
              'if ref ' . $value . ';',
      );
  }
  
  sub _inline_trigger {
      my $self = shift;
      my ($instance, $value, $old) = @_;
  
      return unless $self->has_trigger;
  
      return '$trigger->(' . $instance . ', ' . $value . ', ' . $old . ');';
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my $env = { };
  
      $env->{'$trigger'} = \($self->trigger)
          if $self->has_trigger;
      $env->{'$attr_default'} = \($self->default)
          if $self->has_default;
  
      if ($self->has_type_constraint) {
          my $tc_obj = $self->type_constraint;
  
          $env->{'$type_constraint'} = \(
              $tc_obj->_compiled_type_constraint
          ) unless $tc_obj->can_be_inlined;
          # these two could probably get inlined versions too
          $env->{'$type_coercion'} = \(
              $tc_obj->coercion->_compiled_type_coercion
          ) if $tc_obj->has_coercion;
          $env->{'$type_message'} = \(
              $tc_obj->has_message ? $tc_obj->message : $tc_obj->_default_message
          );
  
          $env = { %$env, %{ $tc_obj->inline_environment } };
      }
  
      $env->{'$class_name'} = \($self->associated_class->name);
  
      # XXX ugh, fix these
      $env->{'$attr'} = \$self
          if $self->has_initializer && $self->is_lazy;
      # pretty sure this is only going to be closed over if you use a custom
      # error class at this point, but we should still get rid of this
      # at some point
      $env->{'$meta'} = \($self->associated_class);
  
      return $env;
  }
  
  sub _weaken_value {
      my ( $self, $instance ) = @_;
  
      my $meta_instance = Class::MOP::Class->initialize( blessed($instance) )
          ->get_meta_instance;
  
      $meta_instance->weaken_slot_value( $instance, $self->name );
  }
  
  sub get_value {
      my ($self, $instance, $for_trigger) = @_;
  
      if ($self->is_lazy) {
          unless ($self->has_value($instance)) {
              my $value;
              if ($self->has_default) {
                  $value = $self->default($instance);
              } elsif ( $self->has_builder ) {
                  $value = $self->_call_builder($instance);
              }
  
              $value = $self->_coerce_and_verify( $value, $instance );
  
              $self->set_initial_value($instance, $value);
  
              if ( ref $value && $self->is_weak_ref ) {
                  $self->_weaken_value($instance);
              }
          }
      }
  
      if ( $self->should_auto_deref && ! $for_trigger ) {
  
          my $type_constraint = $self->type_constraint;
  
          if ($type_constraint->is_a_type_of('ArrayRef')) {
              my $rv = $self->SUPER::get_value($instance);
              return unless defined $rv;
              return wantarray ? @{ $rv } : $rv;
          }
          elsif ($type_constraint->is_a_type_of('HashRef')) {
              my $rv = $self->SUPER::get_value($instance);
              return unless defined $rv;
              return wantarray ? %{ $rv } : $rv;
          }
          else {
              throw_exception( CannotAutoDereferenceTypeConstraint => type      => $type_constraint,
                                                                      instance  => $instance,
                                                                      attribute => $self
                             );
          }
  
      }
      else {
  
          return $self->SUPER::get_value($instance);
      }
  }
  
  sub _inline_get_value {
      my $self = shift;
      my ($instance, $tc, $coercion, $message) = @_;
  
      my $slot_access = $self->_inline_instance_get($instance);
      $tc           ||= '$type_constraint';
      $coercion     ||= '$type_coercion';
      $message      ||= '$type_message';
  
      return (
          $self->_inline_check_lazy($instance, $tc, $coercion, $message),
          $self->_inline_return_auto_deref($slot_access),
      );
  }
  
  sub _inline_check_lazy {
      my $self = shift;
      my ($instance, $tc, $coercion, $message) = @_;
  
      return unless $self->is_lazy;
  
      my $slot_exists = $self->_inline_instance_has($instance);
  
      return (
          'if (!' . $slot_exists . ') {',
              $self->_inline_init_from_default($instance, '$default', $tc, $coercion, $message, 'lazy'),
          '}',
      );
  }
  
  sub _inline_init_from_default {
      my $self = shift;
      my ($instance, $default, $tc, $coercion, $message, $for_lazy) = @_;
  
      if (!($self->has_default || $self->has_builder)) {
  	throw_exception( LazyAttributeNeedsADefault => attribute => $self );
      }
  
      return (
          $self->_inline_generate_default($instance, $default),
          # intentionally not using _inline_tc_code, since that can be overridden
          # to do things like possibly only do member tc checks, which isn't
          # appropriate for checking the result of a default
          $self->has_type_constraint
              ? ($self->_inline_check_coercion($default, $tc, $coercion, $for_lazy),
                 $self->_inline_check_constraint($default, $tc, $message, $for_lazy))
              : (),
          $self->_inline_init_slot($instance, $default),
          $self->_inline_weaken_value($instance, $default),
      );
  }
  
  sub _inline_generate_default {
      my $self = shift;
      my ($instance, $default) = @_;
  
      if ($self->has_default) {
          my $source = 'my ' . $default . ' = $attr_default';
          $source .= '->(' . $instance . ')'
              if $self->is_default_a_coderef;
          return $source . ';';
      }
      elsif ($self->has_builder) {
          my $builder = B::perlstring($self->builder);
          my $builder_str = quotemeta($self->builder);
          my $attr_name_str = quotemeta($self->name);
          return (
              'my ' . $default . ';',
              'if (my $builder = ' . $instance . '->can(' . $builder . ')) {',
                  $default . ' = ' . $instance . '->$builder;',
              '}',
              'else {',
                  'my $class = ref(' . $instance . ') || ' . $instance . ';',
                  $self->_inline_throw_exception(
                      "BuilderMethodNotSupportedForInlineAttribute => ".
                      'class_name     => $class,'.
                      'attribute_name => "'.$attr_name_str.'",'.
                      'instance       => '.$instance.','.
                      'builder        => "'.$builder_str.'"'
                  ) . ';',
              '}',
          );
      }
      else {
          confess(
              "Can't generate a default for " . $self->name
            . " since no default or builder was specified"
          );
      }
  }
  
  sub _inline_init_slot {
      my $self = shift;
      my ($inv, $value) = @_;
  
      if ($self->has_initializer) {
          return '$attr->set_initial_value(' . $inv . ', ' . $value . ');';
      }
      else {
          return $self->_inline_instance_set($inv, $value) . ';';
      }
  }
  
  sub _inline_return_auto_deref {
      my $self = shift;
  
      return 'return ' . $self->_auto_deref(@_) . ';';
  }
  
  sub _auto_deref {
      my $self = shift;
      my ($ref_value) = @_;
  
      return $ref_value unless $self->should_auto_deref;
  
      my $type_constraint = $self->type_constraint;
  
      my $sigil;
      if ($type_constraint->is_a_type_of('ArrayRef')) {
          $sigil = '@';
      }
      elsif ($type_constraint->is_a_type_of('HashRef')) {
          $sigil = '%';
      }
      else {
          confess(
              'Can not auto de-reference the type constraint \''
            . $type_constraint->name
            . '\''
          );
      }
  
      return 'wantarray '
               . '? ' . $sigil . '{ (' . $ref_value . ') || return } '
               . ': (' . $ref_value . ')';
  }
  
  ## installing accessors
  
  sub accessor_metaclass { 'Moose::Meta::Method::Accessor' }
  
  sub install_accessors {
      my $self = shift;
      $self->SUPER::install_accessors(@_);
      $self->install_delegation if $self->has_handles;
      return;
  }
  
  sub _check_associated_methods {
      my $self = shift;
      unless (
          @{ $self->associated_methods }
          || ($self->_is_metadata || '') eq 'bare'
      ) {
          Carp::cluck(
              'Attribute (' . $self->name . ') of class '
              . $self->associated_class->name
              . ' has no associated methods'
              . ' (did you mean to provide an "is" argument?)'
              . "\n"
          )
      }
  }
  
  sub _process_accessors {
      my $self = shift;
      my ($type, $accessor, $generate_as_inline_methods) = @_;
  
      $accessor = ( keys %$accessor )[0] if ( ref($accessor) || '' ) eq 'HASH';
      my $method = $self->associated_class->get_method($accessor);
  
      if (   $method
          && $method->isa('Class::MOP::Method::Accessor')
          && $method->associated_attribute->name ne $self->name ) {
  
          my $other_attr_name = $method->associated_attribute->name;
          my $name            = $self->name;
  
          Carp::cluck(
              "You are overwriting an accessor ($accessor) for the $other_attr_name attribute"
                  . " with a new accessor method for the $name attribute" );
      }
  
      if (
             $method
          && !$method->is_stub
          && !$method->isa('Class::MOP::Method::Accessor')
          && (  !$self->definition_context
              || $method->package_name eq $self->definition_context->{package} )
          ) {
  
          Carp::cluck(
              "You are overwriting a locally defined method ($accessor) with "
                  . "an accessor" );
      }
  
      if (  !$self->associated_class->has_method($accessor)
          && $self->associated_class->has_package_symbol( '&' . $accessor ) ) {
  
          Carp::cluck(
              "You are overwriting a locally defined function ($accessor) with "
                  . "an accessor" );
      }
  
      $self->SUPER::_process_accessors(@_);
  }
  
  sub remove_accessors {
      my $self = shift;
      $self->SUPER::remove_accessors(@_);
      $self->remove_delegation if $self->has_handles;
      return;
  }
  
  sub install_delegation {
      my $self = shift;
  
      # NOTE:
      # Here we canonicalize the 'handles' option
      # this will sort out any details and always
      # return an hash of methods which we want
      # to delagate to, see that method for details
      my %handles = $self->_canonicalize_handles;
  
      # install the delegation ...
      my $associated_class = $self->associated_class;
      my $class_name = $associated_class->name;
  
      foreach my $handle (sort keys %handles) {
          my $method_to_call = $handles{$handle};
          my $name = "${class_name}::${handle}";
  
          if ( my $method = $associated_class->get_method($handle) ) {
              throw_exception( CannotDelegateLocalMethodIsPresent => attribute => $self,
                                                                     method    => $method,
                             )
  		unless $method->is_stub;
          }
  
          # NOTE:
          # handles is not allowed to delegate
          # any of these methods, as they will
          # override the ones in your class, which
          # is almost certainly not what you want.
  
          # FIXME warn when $handle was explicitly specified, but not if the source is a regex or something
          #cluck("Not delegating method '$handle' because it is a core method") and
          next if $class_name->isa("Moose::Object") and $handle =~ /^BUILD|DEMOLISH$/ || Moose::Object->can($handle);
  
          my $method = $self->_make_delegation_method($handle, $method_to_call);
  
          $self->associated_class->add_method($method->name, $method);
          $self->associate_method($method);
      }
  }
  
  sub remove_delegation {
      my $self = shift;
      my %handles = $self->_canonicalize_handles;
      my $associated_class = $self->associated_class;
      foreach my $handle (keys %handles) {
          next unless any { $handle eq $_ }
                      map { $_->name }
                      @{ $self->associated_methods };
          $self->associated_class->remove_method($handle);
      }
  }
  
  # private methods to help delegation ...
  
  sub _canonicalize_handles {
      my $self    = shift;
      my $handles = $self->handles;
      if (my $handle_type = ref($handles)) {
          if ($handle_type eq 'HASH') {
              return %{$handles};
          }
          elsif ($handle_type eq 'ARRAY') {
              return map { $_ => $_ } @{$handles};
          }
          elsif ($handle_type eq 'Regexp') {
              ($self->has_type_constraint)
                  || throw_exception( CannotDelegateWithoutIsa => attribute => $self );
              return map  { ($_ => $_) }
                     grep { /$handles/ } $self->_get_delegate_method_list;
          }
          elsif ($handle_type eq 'CODE') {
              return $handles->($self, $self->_find_delegate_metaclass);
          }
          elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::DuckType')) {
              return map { $_ => $_ } @{ $handles->methods };
          }
          elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::Role')) {
              $handles = $handles->role;
          }
          else {
              throw_exception( UnableToCanonicalizeHandles => attribute => $self,
                                                              handles   => $handles
                             );
          }
      }
  
      Moose::Util::_load_user_class($handles);
      my $role_meta = Class::MOP::class_of($handles);
  
      (blessed $role_meta && $role_meta->isa('Moose::Meta::Role'))
          || throw_exception( UnableToCanonicalizeNonRolePackage => attribute => $self,
                                                                    handles   => $handles
                            );
  
      return map { $_ => $_ }
          map { $_->name }
          grep { !$_->isa('Class::MOP::Method::Meta') } (
          $role_meta->_get_local_methods,
          $role_meta->get_required_method_list,
          );
  }
  
  sub _get_delegate_method_list {
      my $self = shift;
      my $meta = $self->_find_delegate_metaclass;
      if ($meta->isa('Class::MOP::Class')) {
          return map  { $_->name }  # NOTE: !never! delegate &meta
                 grep { $_->package_name ne 'Moose::Object' && !$_->isa('Class::MOP::Method::Meta') }
                      $meta->get_all_methods;
      }
      elsif ($meta->isa('Moose::Meta::Role')) {
          return $meta->get_method_list;
      }
      else {
          throw_exception( UnableToRecognizeDelegateMetaclass => attribute          => $self,
                                                                 delegate_metaclass => $meta
                         );
      }
  }
  
  sub _find_delegate_metaclass {
      my $self = shift;
      my $class = $self->_isa_metadata;
      my $role = $self->_does_metadata;
  
      if ( $class ) {
  	# make sure isa is actually a class
  	unless ( $self->type_constraint->isa("Moose::Meta::TypeConstraint::Class") ) {
  	    throw_exception( DelegationToATypeWhichIsNotAClass => attribute => $self );
  	}
  
  	# make sure the class is loaded
          unless ( Moose::Util::_is_package_loaded($class) ) {
              throw_exception( DelegationToAClassWhichIsNotLoaded => attribute  => $self,
                                                                     class_name => $class
                             );
          }
          # we might be dealing with a non-Moose class,
          # and need to make our own metaclass. if there's
          # already a metaclass, it will be returned
          return Class::MOP::Class->initialize($class);
      }
      elsif ( $role ) {
          unless ( Moose::Util::_is_package_loaded($role) ) {
              throw_exception( DelegationToARoleWhichIsNotLoaded => attribute => $self,
                                                                    role_name => $role
                             );
          }
  
          return Class::MOP::class_of($role);
      }
      else {
  	throw_exception( CannotFindDelegateMetaclass => attribute => $self );
      }
  }
  
  sub delegation_metaclass { 'Moose::Meta::Method::Delegation' }
  
  sub _make_delegation_method {
      my ( $self, $handle_name, $method_to_call ) = @_;
  
      my @curried_arguments;
  
      ($method_to_call, @curried_arguments) = @$method_to_call
          if 'ARRAY' eq ref($method_to_call);
  
      return $self->delegation_metaclass->new(
          name               => $handle_name,
          package_name       => $self->associated_class->name,
          attribute          => $self,
          delegate_to_method => $method_to_call,
          curried_arguments  => \@curried_arguments,
      );
  }
  
  sub _coerce_and_verify {
      my $self     = shift;
      my $val      = shift;
      my $instance = shift;
  
      return $val unless $self->has_type_constraint;
  
      $val = $self->type_constraint->coerce($val)
          if $self->should_coerce && $self->type_constraint->has_coercion;
  
      $self->verify_against_type_constraint($val, instance => $instance);
  
      return $val;
  }
  
  sub verify_against_type_constraint {
      my $self = shift;
      my $val  = shift;
  
      return 1 if !$self->has_type_constraint;
  
      my $type_constraint = $self->type_constraint;
  
      $type_constraint->check($val)
          || throw_exception( ValidationFailedForTypeConstraint => type      => $type_constraint,
                                                                   value     => $val,
                                                                   attribute => $self,
                            );
  }
  
  package Moose::Meta::Attribute::Custom::Moose;
  BEGIN {
    $Moose::Meta::Attribute::Custom::Moose::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Custom::Moose::VERSION = '2.1204';
  sub register_implementation { 'Moose::Meta::Attribute' }
  1;
  
  # ABSTRACT: The Moose attribute metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute - The Moose attribute metaclass
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Attribute> that provides
  additional Moose-specific functionality.
  
  To really understand this class, you will need to start with the
  L<Class::MOP::Attribute> documentation. This class can be understood
  as a set of additional features on top of the basic feature provided
  by that parent class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Attribute> is a subclass of L<Class::MOP::Attribute>.
  
  =head1 METHODS
  
  Many of the documented below override methods in
  L<Class::MOP::Attribute> and add Moose specific features.
  
  =head2 Creation
  
  =over 4
  
  =item B<< Moose::Meta::Attribute->new($name, %options) >>
  
  This method overrides the L<Class::MOP::Attribute> constructor.
  
  Many of the options below are described in more detail in the
  L<Moose::Manual::Attributes> document.
  
  It adds the following options to the constructor:
  
  =over 8
  
  =item * is => 'ro', 'rw', 'bare'
  
  This provides a shorthand for specifying the C<reader>, C<writer>, or
  C<accessor> names. If the attribute is read-only ('ro') then it will
  have a C<reader> method with the same attribute as the name.
  
  If it is read-write ('rw') then it will have an C<accessor> method
  with the same name. If you provide an explicit C<writer> for a
  read-write attribute, then you will have a C<reader> with the same
  name as the attribute, and a C<writer> with the name you provided.
  
  Use 'bare' when you are deliberately not installing any methods
  (accessor, reader, etc.) associated with this attribute; otherwise,
  Moose will issue a warning when this attribute is added to a
  metaclass.
  
  =item * isa => $type
  
  This option accepts a type. The type can be a string, which should be
  a type name. If the type name is unknown, it is assumed to be a class
  name.
  
  This option can also accept a L<Moose::Meta::TypeConstraint> object.
  
  If you I<also> provide a C<does> option, then your C<isa> option must
  be a class name, and that class must do the role specified with
  C<does>.
  
  =item * does => $role
  
  This is short-hand for saying that the attribute's type must be an
  object which does the named role.
  
  =item * coerce => $bool
  
  This option is only valid for objects with a type constraint
  (C<isa>) that defined a coercion. If this is true, then coercions will be applied whenever
  this attribute is set.
  
  You cannot make both this and the C<weak_ref> option true.
  
  =item * trigger => $sub
  
  This option accepts a subroutine reference, which will be called after
  the attribute is set.
  
  =item * required => $bool
  
  An attribute which is required must be provided to the constructor. An
  attribute which is required can also have a C<default> or C<builder>,
  which will satisfy its required-ness.
  
  A required attribute must have a C<default>, C<builder> or a
  non-C<undef> C<init_arg>
  
  =item * lazy => $bool
  
  A lazy attribute must have a C<default> or C<builder>. When an
  attribute is lazy, the default value will not be calculated until the
  attribute is read.
  
  =item * weak_ref => $bool
  
  If this is true, the attribute's value will be stored as a weak
  reference.
  
  =item * auto_deref => $bool
  
  If this is true, then the reader will dereference the value when it is
  called. The attribute must have a type constraint which defines the
  attribute as an array or hash reference.
  
  =item * lazy_build => $bool
  
  Setting this to true makes the attribute lazy and provides a number of
  default methods.
  
    has 'size' => (
        is         => 'ro',
        lazy_build => 1,
    );
  
  is equivalent to this:
  
    has 'size' => (
        is        => 'ro',
        lazy      => 1,
        builder   => '_build_size',
        clearer   => 'clear_size',
        predicate => 'has_size',
    );
  
  If your attribute name starts with an underscore (C<_>), then the clearer
  and predicate will as well:
  
    has '_size' => (
        is         => 'ro',
        lazy_build => 1,
    );
  
  becomes:
  
    has '_size' => (
        is        => 'ro',
        lazy      => 1,
        builder   => '_build__size',
        clearer   => '_clear_size',
        predicate => '_has_size',
    );
  
  Note the doubled underscore in the builder name. Internally, Moose
  simply prepends the attribute name with "_build_" to come up with the
  builder name.
  
  =item * documentation
  
  An arbitrary string that can be retrieved later by calling C<<
  $attr->documentation >>.
  
  =back
  
  =item B<< $attr->clone(%options) >>
  
  This creates a new attribute based on attribute being cloned. You must
  supply a C<name> option to provide a new name for the attribute.
  
  The C<%options> can only specify options handled by
  L<Class::MOP::Attribute>.
  
  =back
  
  =head2 Value management
  
  =over 4
  
  =item B<< $attr->initialize_instance_slot($meta_instance, $instance, $params) >>
  
  This method is used internally to initialize the attribute's slot in
  the object C<$instance>.
  
  This overrides the L<Class::MOP::Attribute> method to handle lazy
  attributes, weak references, and type constraints.
  
  =item B<get_value>
  
  =item B<set_value>
  
    eval { $point->meta->get_attribute('x')->set_value($point, 'forty-two') };
    if($@) {
      print "Oops: $@\n";
    }
  
  I<Attribute (x) does not pass the type constraint (Int) with 'forty-two'>
  
  Before setting the value, a check is made on the type constraint of
  the attribute, if it has one, to see if the value passes it. If the
  value fails to pass, the set operation dies.
  
  Any coercion to convert values is done before checking the type constraint.
  
  To check a value against a type constraint before setting it, fetch the
  attribute instance using L<Class::MOP::Class/find_attribute_by_name>,
  fetch the type_constraint from the attribute using L<Moose::Meta::Attribute/type_constraint>
  and call L<Moose::Meta::TypeConstraint/check>. See L<Moose::Cookbook::Basics::Company_Subtypes>
  for an example.
  
  =back
  
  =head2 Attribute Accessor generation
  
  =over 4
  
  =item B<< $attr->install_accessors >>
  
  This method overrides the parent to also install delegation methods.
  
  If, after installing all methods, the attribute object has no associated
  methods, it throws an error unless C<< is => 'bare' >> was passed to the
  attribute constructor.  (Trying to add an attribute that has no associated
  methods is almost always an error.)
  
  =item B<< $attr->remove_accessors >>
  
  This method overrides the parent to also remove delegation methods.
  
  =item B<< $attr->inline_set($instance_var, $value_var) >>
  
  This method return a code snippet suitable for inlining the relevant
  operation. It expect strings containing variable names to be used in the
  inlining, like C<'$self'> or C<'$_[1]'>.
  
  =item B<< $attr->install_delegation >>
  
  This method adds its delegation methods to the attribute's associated
  class, if it has any to add.
  
  =item B<< $attr->remove_delegation >>
  
  This method remove its delegation methods from the attribute's
  associated class.
  
  =item B<< $attr->accessor_metaclass >>
  
  Returns the accessor metaclass name, which defaults to
  L<Moose::Meta::Method::Accessor>.
  
  =item B<< $attr->delegation_metaclass >>
  
  Returns the delegation metaclass name, which defaults to
  L<Moose::Meta::Method::Delegation>.
  
  =back
  
  =head2 Additional Moose features
  
  These methods are not found in the superclass. They support features
  provided by Moose.
  
  =over 4
  
  =item B<< $attr->does($role) >>
  
  This indicates whether the I<attribute itself> does the given
  role. The role can be given as a full class name, or as a resolvable
  trait name.
  
  Note that this checks the attribute itself, not its type constraint,
  so it is checking the attribute's metaclass and any traits applied to
  the attribute.
  
  =item B<< Moose::Meta::Class->interpolate_class_and_new($name, %options) >>
  
  This is an alternate constructor that handles the C<metaclass> and
  C<traits> options.
  
  Effectively, this method is a factory that finds or creates the
  appropriate class for the given C<metaclass> and/or C<traits>.
  
  Once it has the appropriate class, it will call C<< $class->new($name,
  %options) >> on that class.
  
  =item B<< $attr->clone_and_inherit_options(%options) >>
  
  This method supports the C<has '+foo'> feature. It does various bits
  of processing on the supplied C<%options> before ultimately calling
  the C<clone> method.
  
  One of its main tasks is to make sure that the C<%options> provided
  does not include the options returned by the
  C<illegal_options_for_inheritance> method.
  
  =item B<< $attr->illegal_options_for_inheritance >>
  
  This returns a blacklist of options that can not be overridden in a
  subclass's attribute definition.
  
  This exists to allow a custom metaclass to change or add to the list
  of options which can not be changed.
  
  =item B<< $attr->type_constraint >>
  
  Returns the L<Moose::Meta::TypeConstraint> object for this attribute,
  if it has one.
  
  =item B<< $attr->has_type_constraint >>
  
  Returns true if this attribute has a type constraint.
  
  =item B<< $attr->verify_against_type_constraint($value) >>
  
  Given a value, this method returns true if the value is valid for the
  attribute's type constraint. If the value is not valid, it throws an
  error.
  
  =item B<< $attr->handles >>
  
  This returns the value of the C<handles> option passed to the
  constructor.
  
  =item B<< $attr->has_handles >>
  
  Returns true if this attribute performs delegation.
  
  =item B<< $attr->is_weak_ref >>
  
  Returns true if this attribute stores its value as a weak reference.
  
  =item B<< $attr->is_required >>
  
  Returns true if this attribute is required to have a value.
  
  =item B<< $attr->is_lazy >>
  
  Returns true if this attribute is lazy.
  
  =item B<< $attr->is_lazy_build >>
  
  Returns true if the C<lazy_build> option was true when passed to the
  constructor.
  
  =item B<< $attr->should_coerce >>
  
  Returns true if the C<coerce> option passed to the constructor was
  true.
  
  =item B<< $attr->should_auto_deref >>
  
  Returns true if the C<auto_deref> option passed to the constructor was
  true.
  
  =item B<< $attr->trigger >>
  
  This is the subroutine reference that was in the C<trigger> option
  passed to the constructor, if any.
  
  =item B<< $attr->has_trigger >>
  
  Returns true if this attribute has a trigger set.
  
  =item B<< $attr->documentation >>
  
  Returns the value that was in the C<documentation> option passed to
  the constructor, if any.
  
  =item B<< $attr->has_documentation >>
  
  Returns true if this attribute has any documentation.
  
  =item B<< $attr->applied_traits >>
  
  This returns an array reference of all the traits which were applied
  to this attribute. If none were applied, this returns C<undef>.
  
  =item B<< $attr->has_applied_traits >>
  
  Returns true if this attribute has any traits applied.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE';
  use strict;
  use warnings;
  package Moose::Meta::Attribute::Native;
  BEGIN {
    $Moose::Meta::Attribute::Native::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::VERSION = '2.1204';
  use Module::Runtime 'require_module';
  
  my @trait_names = qw(Bool Counter Number String Array Hash Code);
  
  for my $trait_name (@trait_names) {
      my $trait_class = "Moose::Meta::Attribute::Native::Trait::$trait_name";
      my $meta = Class::MOP::Class->initialize(
          "Moose::Meta::Attribute::Custom::Trait::$trait_name"
      );
  
      if ($meta->find_method_by_name('register_implementation')) {
          my $class = $meta->name->register_implementation;
          die "An implementation for $trait_name already exists " .
              "(found '$class' when trying to register '$trait_class')"
      }
      $meta->add_method(register_implementation => sub {
          # resolve_metatrait_alias will load classes anyway, but throws away
          # their error message; we WANT to die if there's a problem
          require_module($trait_class);
          return $trait_class;
      });
  }
  
  1;
  
  # ABSTRACT: Delegate to native Perl types
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native - Delegate to native Perl types
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Moose;
  
    has 'mapping' => (
        traits  => ['Hash'],
        is      => 'rw',
        isa     => 'HashRef[Str]',
        default => sub { {} },
        handles => {
            exists_in_mapping => 'exists',
            ids_in_mapping    => 'keys',
            get_mapping       => 'get',
            set_mapping       => 'set',
            set_quantity      => [ set => 'quantity' ],
        },
    );
  
    my $obj = MyClass->new;
    $obj->set_quantity(10);      # quantity => 10
    $obj->set_mapping('foo', 4); # foo => 4
    $obj->set_mapping('bar', 5); # bar => 5
    $obj->set_mapping('baz', 6); # baz => 6
  
    # prints 5
    print $obj->get_mapping('bar') if $obj->exists_in_mapping('bar');
  
    # prints 'quantity, foo, bar, baz'
    print join ', ', $obj->ids_in_mapping;
  
  =head1 DESCRIPTION
  
  Native delegations allow you to delegate to native Perl data
  structures as if they were objects. For example, in the L</SYNOPSIS> you can
  see a hash reference being treated as if it has methods named C<exists()>,
  C<keys()>, C<get()>, and C<set()>.
  
  The delegation methods (mostly) map to Perl builtins and operators. The return
  values of these delegations should be the same as the corresponding Perl
  operation. Any deviations will be explicitly documented.
  
  =head1 API
  
  Native delegations are enabled by passing certain options to C<has> when
  creating an attribute.
  
  =head2 traits
  
  To enable this feature, pass the appropriate name in the C<traits> array
  reference for the attribute. For example, to enable this feature for hash
  reference, we include C<'Hash'> in the list of traits.
  
  =head2 isa
  
  You will need to make sure that the attribute has an appropriate type. For
  example, to use this with a Hash you must specify that your attribute is some
  sort of C<HashRef>.
  
  =head2 handles
  
  This is just like any other delegation, but only a hash reference is allowed
  when defining native delegations. The keys are the methods to be created in
  the class which contains the attribute. The values are the methods provided by
  the associated trait. Currying works the same way as it does with any other
  delegation.
  
  See the docs for each native trait for details on what methods are available.
  
  =head1 TRAITS FOR NATIVE DELEGATIONS
  
  Below are some simple examples of each native trait. More features are
  available than what is shown here; this is just a quick synopsis.
  
  =over
  
  =item Array (L<Moose::Meta::Attribute::Native::Trait::Array>)
  
      has 'queue' => (
          traits  => ['Array'],
          is      => 'ro',
          isa     => 'ArrayRef[Str]',
          default => sub { [] },
          handles => {
              add_item  => 'push',
              next_item => 'shift',
              # ...
          }
      );
  
  =item Bool (L<Moose::Meta::Attribute::Native::Trait::Bool>)
  
      has 'is_lit' => (
          traits  => ['Bool'],
          is      => 'ro',
          isa     => 'Bool',
          default => 0,
          handles => {
              illuminate  => 'set',
              darken      => 'unset',
              flip_switch => 'toggle',
              is_dark     => 'not',
              # ...
          }
      );
  
  =item Code (L<Moose::Meta::Attribute::Native::Trait::Code>)
  
      has 'callback' => (
          traits  => ['Code'],
          is      => 'ro',
          isa     => 'CodeRef',
          default => sub {
              sub {'called'}
          },
          handles => {
              call => 'execute',
              # ...
          }
      );
  
  =item Counter (L<Moose::Meta::Attribute::Native::Trait::Counter>)
  
      has 'counter' => (
          traits  => ['Counter'],
          is      => 'ro',
          isa     => 'Num',
          default => 0,
          handles => {
              inc_counter   => 'inc',
              dec_counter   => 'dec',
              reset_counter => 'reset',
              # ...
          }
      );
  
  =item Hash (L<Moose::Meta::Attribute::Native::Trait::Hash>)
  
      has 'options' => (
          traits  => ['Hash'],
          is      => 'ro',
          isa     => 'HashRef[Str]',
          default => sub { {} },
          handles => {
              set_option => 'set',
              get_option => 'get',
              has_option => 'exists',
              # ...
          }
      );
  
  =item Number (L<Moose::Meta::Attribute::Native::Trait::Number>)
  
      has 'integer' => (
          traits  => ['Number'],
          is      => 'ro',
          isa     => 'Int',
          default => 5,
          handles => {
              set => 'set',
              add => 'add',
              sub => 'sub',
              mul => 'mul',
              div => 'div',
              mod => 'mod',
              abs => 'abs',
              # ...
          }
      );
  
  =item String (L<Moose::Meta::Attribute::Native::Trait::String>)
  
      has 'text' => (
          traits  => ['String'],
          is      => 'ro',
          isa     => 'Str',
          default => q{},
          handles => {
              add_text     => 'append',
              replace_text => 'replace',
              # ...
          }
      );
  
  =back
  
  =head1 COMPATIBILITY WITH MooseX::AttributeHelpers
  
  This feature used to be a separated CPAN distribution called
  L<MooseX::AttributeHelpers>.
  
  When the feature was incorporated into the Moose core, some of the API details
  were changed. The underlying capabilities are the same, but some details of
  the API were changed.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT';
  package Moose::Meta::Attribute::Native::Trait;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::Trait::VERSION = '2.1204';
  use Moose::Role;
  use Module::Runtime 'require_module';
  use List::MoreUtils qw( any uniq );
  use Moose::Deprecated;
  use Moose::Util;
  use Moose::Util::TypeConstraints;
  
  use Moose::Util 'throw_exception';
  
  requires '_helper_type';
  
  before '_process_options' => sub {
      my ( $self, $name, $options ) = @_;
  
      $self->_check_helper_type( $options, $name );
  };
  
  sub _check_helper_type {
      my ( $self, $options, $name ) = @_;
  
      my $type = $self->_helper_type;
  
      $options->{isa} = $type
          unless exists $options->{isa};
  
      my $isa;
      my $isa_name;
  
      if (
          Moose::Util::does_role(
              $options->{isa}, 'Specio::Constraint::Role::Interface'
          )
          ) {
  
          $isa = $options->{isa};
          require Specio::Library::Builtins;
          return if $isa->is_a_type_of( Specio::Library::Builtins::t($type) );
          $isa_name = $isa->name() || $isa->description();
      }
      else {
          $isa = Moose::Util::TypeConstraints::find_or_create_type_constraint(
              $options->{isa} );
          return if $isa->is_a_type_of($type);
          $isa_name = $isa->name();
      }
  
      throw_exception( WrongTypeConstraintGiven => required_type  => $type,
                                                   given_type     => $isa_name,
                                                   attribute_name => $name,
                                                   params         => $options
                     );
  }
  
  before 'install_accessors' => sub { (shift)->_check_handles_values };
  
  sub _check_handles_values {
      my $self = shift;
  
      my %handles = $self->_canonicalize_handles;
  
      for my $original_method ( values %handles ) {
          my $name = $original_method->[0];
  
          my $accessor_class = $self->_native_accessor_class_for($name);
  
          ( $accessor_class && $accessor_class->can('new') )
              || confess
              "$name is an unsupported method type - $accessor_class";
      }
  }
  
  around '_canonicalize_handles' => sub {
      shift;
      my $self    = shift;
      my $handles = $self->handles;
  
      return unless $handles;
  
      unless ( 'HASH' eq ref $handles ) {
         throw_exception( HandlesMustBeAHashRef => instance      => $self,
                                                   given_handles => $handles
                        );
      }
  
      return
          map { $_ => $self->_canonicalize_handles_value( $handles->{$_} ) }
          keys %$handles;
  };
  
  sub _canonicalize_handles_value {
      my $self  = shift;
      my $value = shift;
  
      if ( ref $value && 'ARRAY' ne ref $value ) {
          throw_exception( InvalidHandleValue => instance     => $self,
                                                 handle_value => $value
                         );
      }
  
      return ref $value ? $value : [$value];
  }
  
  around '_make_delegation_method' => sub {
      my $next = shift;
      my ( $self, $handle_name, $method_to_call ) = @_;
  
      my ( $name, @curried_args ) = @$method_to_call;
  
      my $accessor_class = $self->_native_accessor_class_for($name);
  
      die "Cannot find an accessor class for $name"
          unless $accessor_class && $accessor_class->can('new');
  
      return $accessor_class->new(
          name               => $handle_name,
          package_name       => $self->associated_class->name,
          delegate_to_method => $name,
          attribute          => $self,
          is_inline          => 1,
          curried_arguments  => \@curried_args,
          root_types         => [ $self->_root_types ],
      );
  };
  
  sub _root_types {
      return $_[0]->_helper_type;
  }
  
  sub _native_accessor_class_for {
      my ( $self, $suffix ) = @_;
  
      my $role
          = 'Moose::Meta::Method::Accessor::Native::'
          . $self->_native_type . '::'
          . $suffix;
  
      require_module($role);
      return Moose::Meta::Class->create_anon_class(
          superclasses =>
              [ $self->accessor_metaclass, $self->delegation_metaclass ],
          roles => [$role],
          cache => 1,
      )->name;
  }
  
  sub _build_native_type {
      my $self = shift;
  
      for my $role_name ( map { $_->name } $self->meta->calculate_all_roles ) {
          return $1 if $role_name =~ /::Native::Trait::(\w+)$/;
      }
  
      throw_exception( CannotCalculateNativeType => instance => $self );
  }
  
  has '_native_type' => (
      is      => 'ro',
      isa     => 'Str',
      lazy    => 1,
      builder => '_build_native_type',
  );
  
  no Moose::Role;
  no Moose::Util::TypeConstraints;
  
  1;
  
  # ABSTRACT: Shared role for native delegation traits
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait - Shared role for native delegation traits
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 SEE ALSO
  
  Documentation for Moose native traits can be found in
  L<Moose::Meta::Attribute::Native>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native/Trait/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY';
  package Moose::Meta::Attribute::Native::Trait::Array;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Array::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::Trait::Array::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'ArrayRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for ArrayRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Array - Helper trait for ArrayRef attributes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
      package Stuff;
      use Moose;
  
      has 'options' => (
          traits  => ['Array'],
          is      => 'ro',
          isa     => 'ArrayRef[Str]',
          default => sub { [] },
          handles => {
              all_options    => 'elements',
              add_option     => 'push',
              map_options    => 'map',
              filter_options => 'grep',
              find_option    => 'first',
              get_option     => 'get',
              join_options   => 'join',
              count_options  => 'count',
              has_options    => 'count',
              has_no_options => 'is_empty',
              sorted_options => 'sort',
          },
      );
  
      no Moose;
      1;
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for array references.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<ArrayRef>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<count>
  
  Returns the number of elements in the array.
  
    $stuff = Stuff->new;
    $stuff->options( [ "foo", "bar", "baz", "boo" ] );
  
    print $stuff->count_options; # prints 4
  
  This method does not accept any arguments.
  
  =item * B<is_empty>
  
  Returns a boolean value that is true when the array has no elements.
  
    $stuff->has_no_options ? die "No options!\n" : print "Good boy.\n";
  
  This method does not accept any arguments.
  
  =item * B<elements>
  
  Returns all of the elements of the array as an array (not an array reference).
  
    my @option = $stuff->all_options;
    print "@options\n";    # prints "foo bar baz boo"
  
  This method does not accept any arguments.
  
  =item * B<get($index)>
  
  Returns an element of the array by its index. You can also use negative index
  numbers, just as with Perl's core array handling.
  
    my $option = $stuff->get_option(1);
    print "$option\n";    # prints "bar"
  
  If the specified element does not exist, this will return C<undef>.
  
  This method accepts just one argument.
  
  =item * B<pop>
  
  Just like Perl's builtin C<pop>.
  
  This method does not accept any arguments.
  
  =item * B<push($value1, $value2, value3 ...)>
  
  Just like Perl's builtin C<push>. Returns the number of elements in the new
  array.
  
  This method accepts any number of arguments.
  
  =item * B<shift>
  
  Just like Perl's builtin C<shift>.
  
  This method does not accept any arguments.
  
  =item * B<unshift($value1, $value2, value3 ...)>
  
  Just like Perl's builtin C<unshift>. Returns the number of elements in the new
  array.
  
  This method accepts any number of arguments.
  
  =item * B<splice($offset, $length, @values)>
  
  Just like Perl's builtin C<splice>. In scalar context, this returns the last
  element removed, or C<undef> if no elements were removed. In list context,
  this returns all the elements removed from the array.
  
  This method requires at least one argument.
  
  =item * B<first( sub { ... } )>
  
  This method returns the first matching item in the array, just like
  L<List::Util>'s C<first> function. The matching is done with a subroutine
  reference you pass to this method. The subroutine will be called against each
  element in the array until one matches or all elements have been checked.
  Each list element will be available to the sub in C<$_>.
  
    my $found = $stuff->find_option( sub {/^b/} );
    print "$found\n";    # prints "bar"
  
  This method requires a single argument.
  
  =item * B<first_index( sub { ... } )>
  
  This method returns the index of the first matching item in the array, just
  like L<List::MoreUtils>'s C<first_index> function. The matching is done with a
  subroutine reference you pass to this method. The subroutine will be called
  against each element in the array until one matches or all elements have been
  checked. Each list element will be available to the sub in C<$_>.
  
  This method requires a single argument.
  
  =item * B<grep( sub { ... } )>
  
  This method returns every element matching a given criteria, just like Perl's
  core C<grep> function. This method requires a subroutine which implements the
  matching logic; each list element will be available to the sub in C<$_>.
  
    my @found = $stuff->filter_options( sub {/^b/} );
    print "@found\n";    # prints "bar baz boo"
  
  This method requires a single argument.
  
  =item * B<map( sub { ... } )>
  
  This method transforms every element in the array and returns a new array,
  just like Perl's core C<map> function. This method requires a subroutine which
  implements the transformation; each list element will be available to the sub
  in C<$_>.
  
    my @mod_options = $stuff->map_options( sub { $_ . "-tag" } );
    print "@mod_options\n";    # prints "foo-tag bar-tag baz-tag boo-tag"
  
  This method requires a single argument.
  
  =item * B<reduce( sub { ... } )>
  
  This method turns an array into a single value, by passing a function the
  value so far and the next value in the array, just like L<List::Util>'s
  C<reduce> function. The reducing is done with a subroutine reference you pass
  to this method; each list element will be available to the sub in C<$_>.
  
    my $found = $stuff->reduce_options( sub { $_[0] . $_[1] } );
    print "$found\n";    # prints "foobarbazboo"
  
  This method requires a single argument.
  
  =item * B<sort>
  
  =item * B<sort( sub { ... } )>
  
  Returns the elements of the array in sorted order.
  
  You can provide an optional subroutine reference to sort with (as you can with
  Perl's core C<sort> function). However, instead of using C<$a> and C<$b> in
  this subroutine, you will need to use C<$_[0]> and C<$_[1]>.
  
    # ascending ASCIIbetical
    my @sorted = $stuff->sort_options();
  
    # Descending alphabetical order
    my @sorted_options = $stuff->sort_options( sub { lc $_[1] cmp lc $_[0] } );
    print "@sorted_options\n";    # prints "foo boo baz bar"
  
  This method accepts a single argument.
  
  =item * B<sort_in_place>
  
  =item * B<sort_in_place( sub { ... } )>
  
  Sorts the array I<in place>, modifying the value of the attribute.
  
  You can provide an optional subroutine reference to sort with (as you can with
  Perl's core C<sort> function). However, instead of using C<$a> and C<$b>, you
  will need to use C<$_[0]> and C<$_[1]> instead.
  
  This method does not define a return value.
  
  This method accepts a single argument.
  
  =item * B<shuffle>
  
  Returns the elements of the array in random order, like C<shuffle> from
  L<List::Util>.
  
  This method does not accept any arguments.
  
  =item * B<uniq>
  
  Returns the array with all duplicate elements removed, like C<uniq> from
  L<List::MoreUtils>.
  
  This method does not accept any arguments.
  
  =item * B<join($str)>
  
  Joins every element of the array using the separator given as argument, just
  like Perl's core C<join> function.
  
    my $joined = $stuff->join_options(':');
    print "$joined\n";    # prints "foo:bar:baz:boo"
  
  This method requires a single argument.
  
  =item * B<set($index, $value)>
  
  Given an index and a value, sets the specified array element's value.
  
  This method returns the value at C<$index> after the set.
  
  This method requires two arguments.
  
  =item * B<delete($index)>
  
  Removes the element at the given index from the array.
  
  This method returns the deleted value. Note that if no value exists, it will
  return C<undef>.
  
  This method requires one argument.
  
  =item * B<insert($index, $value)>
  
  Inserts a new element into the array at the given index.
  
  This method returns the new value at C<$index>.
  
  This method requires two arguments.
  
  =item * B<clear>
  
  Empties the entire array, like C<@array = ()>.
  
  This method does not define a return value.
  
  This method does not accept any arguments.
  
  =item * B<accessor($index)>
  
  =item * B<accessor($index, $value)>
  
  This method provides a get/set accessor for the array, based on array indexes.
  If passed one argument, it returns the value at the specified index.  If
  passed two arguments, it sets the value of the specified index.
  
  When called as a setter, this method returns the new value at C<$index>.
  
  This method accepts one or two arguments.
  
  =item * B<natatime($n)>
  
  =item * B<natatime($n, $code)>
  
  This method returns an iterator which, on each call, returns C<$n> more items
  from the array, in order, like C<natatime> from L<List::MoreUtils>.
  
  If you pass a coderef as the second argument, then this code ref will be
  called on each group of C<$n> elements in the array until the array is
  exhausted.
  
  This method accepts one or two arguments.
  
  =item * B<shallow_clone>
  
  This method returns a shallow clone of the array reference.  The return value
  is a reference to a new array with the same elements.  It is I<shallow>
  because any elements that were references in the original will be the I<same>
  references in the clone.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native/Trait/Bool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL';
  package Moose::Meta::Attribute::Native::Trait::Bool;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Bool::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::Trait::Bool::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Bool' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Bool attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Bool - Helper trait for Bool attributes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package Room;
    use Moose;
  
    has 'is_lit' => (
        traits  => ['Bool'],
        is      => 'rw',
        isa     => 'Bool',
        default => 0,
        handles => {
            illuminate  => 'set',
            darken      => 'unset',
            flip_switch => 'toggle',
            is_dark     => 'not',
        },
    );
  
    my $room = Room->new();
    $room->illuminate;        # same as $room->is_lit(1);
    $room->darken;            # same as $room->is_lit(0);
    $room->flip_switch;       # same as $room->is_lit(not $room->is_lit);
    return $room->is_dark;    # same as !$room->is_lit
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for boolean values. A boolean is
  a scalar which can be C<1>, C<0>, C<"">, or C<undef>.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Bool>.
  
  =head1 PROVIDED METHODS
  
  None of these methods accept arguments.
  
  =over 4
  
  =item * B<set>
  
  Sets the value to C<1> and returns C<1>.
  
  =item * B<unset>
  
  Set the value to C<0> and returns C<0>.
  
  =item * B<toggle>
  
  Toggles the value. If it's true, set to false, and vice versa.
  
  Returns the new value.
  
  =item * B<not>
  
  Equivalent of 'not C<$value>'.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native/Trait/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE';
  package Moose::Meta::Attribute::Native::Trait::Code;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Code::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::Trait::Code::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'CodeRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for CodeRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Code - Helper trait for CodeRef attributes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package Foo;
    use Moose;
  
    has 'callback' => (
        traits  => ['Code'],
        is      => 'ro',
        isa     => 'CodeRef',
        default => sub {
            sub { print "called" }
        },
        handles => {
            call => 'execute',
        },
    );
  
    my $foo = Foo->new;
    $foo->call;    # prints "called"
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for code references.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<CodeRef>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<execute(@args)>
  
  Calls the coderef with the given args.
  
  =item * B<execute_method(@args)>
  
  Calls the coderef with the instance as invocant and given args.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native/Trait/Counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER';
  package Moose::Meta::Attribute::Native::Trait::Counter;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Counter::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::Trait::Counter::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Num' }
  sub _root_types { 'Num', 'Int' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Int attributes which represent counters
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Counter - Helper trait for Int attributes which represent counters
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package MyHomePage;
    use Moose;
  
    has 'counter' => (
        traits  => ['Counter'],
        is      => 'ro',
        isa     => 'Num',
        default => 0,
        handles => {
            inc_counter   => 'inc',
            dec_counter   => 'dec',
            reset_counter => 'reset',
        },
    );
  
    my $page = MyHomePage->new();
    $page->inc_counter;    # same as $page->counter( $page->counter + 1 );
    $page->dec_counter;    # same as $page->counter( $page->counter - 1 );
  
    my $count_by_twos = 2;
    $page->inc_counter($count_by_twos);
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for counters. A counter can be
  any sort of number (integer or not). The delegation methods allow you to
  increment, decrement, or reset the value.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Num>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<set($value)>
  
  Sets the counter to the specified value and returns the new value.
  
  This method requires a single argument.
  
  =item * B<inc>
  
  =item * B<inc($arg)>
  
  Increases the attribute value by the amount of the argument, or by 1 if no
  argument is given. This method returns the new value.
  
  This method accepts a single argument.
  
  =item * B<dec>
  
  =item * B<dec($arg)>
  
  Decreases the attribute value by the amount of the argument, or by 1 if no
  argument is given. This method returns the new value.
  
  This method accepts a single argument.
  
  =item * B<reset>
  
  Resets the value stored in this slot to its default value, and returns the new
  value.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native/Trait/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH';
  package Moose::Meta::Attribute::Native::Trait::Hash;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Hash::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::Trait::Hash::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'HashRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for HashRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Hash - Helper trait for HashRef attributes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package Stuff;
    use Moose;
  
    has 'options' => (
        traits    => ['Hash'],
        is        => 'ro',
        isa       => 'HashRef[Str]',
        default   => sub { {} },
        handles   => {
            set_option     => 'set',
            get_option     => 'get',
            has_no_options => 'is_empty',
            num_options    => 'count',
            delete_option  => 'delete',
            option_pairs   => 'kv',
        },
    );
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for hash references.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item B<get($key, $key2, $key3...)>
  
  Returns values from the hash.
  
  In list context it returns a list of values in the hash for the given keys. In
  scalar context it returns the value for the last key specified.
  
  This method requires at least one argument.
  
  =item B<set($key =E<gt> $value, $key2 =E<gt> $value2...)>
  
  Sets the elements in the hash to the given values. It returns the new values
  set for each key, in the same order as the keys passed to the method.
  
  This method requires at least two arguments, and expects an even number of
  arguments.
  
  =item B<delete($key, $key2, $key3...)>
  
  Removes the elements with the given keys.
  
  In list context it returns a list of values in the hash for the deleted
  keys. In scalar context it returns the value for the last key specified.
  
  =item B<keys>
  
  Returns the list of keys in the hash.
  
  This method does not accept any arguments.
  
  =item B<exists($key)>
  
  Returns true if the given key is present in the hash.
  
  This method requires a single argument.
  
  =item B<defined($key)>
  
  Returns true if the value of a given key is defined.
  
  This method requires a single argument.
  
  =item B<values>
  
  Returns the list of values in the hash.
  
  This method does not accept any arguments.
  
  =item B<kv>
  
  Returns the key/value pairs in the hash as an array of array references.
  
    for my $pair ( $object->option_pairs ) {
        print "$pair->[0] = $pair->[1]\n";
    }
  
  This method does not accept any arguments.
  
  =item B<elements>
  
  Returns the key/value pairs in the hash as a flattened list..
  
  This method does not accept any arguments.
  
  =item B<clear>
  
  Resets the hash to an empty value, like C<%hash = ()>.
  
  This method does not accept any arguments.
  
  =item B<count>
  
  Returns the number of elements in the hash. Also useful for not empty:
  C<< has_options => 'count' >>.
  
  This method does not accept any arguments.
  
  =item B<is_empty>
  
  If the hash is populated, returns false. Otherwise, returns true.
  
  This method does not accept any arguments.
  
  =item B<accessor($key)>
  
  =item B<accessor($key, $value)>
  
  If passed one argument, returns the value of the specified key. If passed two
  arguments, sets the value of the specified key.
  
  When called as a setter, this method returns the value that was set.
  
  =item B<shallow_clone>
  
  This method returns a shallow clone of the hash reference.  The return value
  is a reference to a new hash with the same keys and values.  It is I<shallow>
  because any values that were references in the original will be the I<same>
  references in the clone.
  
  =back
  
  Note that C<each> is deliberately omitted, due to its stateful interaction
  with the hash iterator. C<keys> or C<kv> are much safer.
  
  =head1 METHODS
  
  =over 4
  
  =item B<meta>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native/Trait/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER';
  package Moose::Meta::Attribute::Native::Trait::Number;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Number::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::Trait::Number::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Num' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Num attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Number - Helper trait for Num attributes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package Real;
    use Moose;
  
    has 'integer' => (
        traits  => ['Number'],
        is      => 'ro',
        isa     => 'Num',
        default => 5,
        handles => {
            set => 'set',
            add => 'add',
            sub => 'sub',
            mul => 'mul',
            div => 'div',
            mod => 'mod',
            abs => 'abs',
        },
    );
  
    my $real = Real->new();
    $real->add(5);    # same as $real->integer($real->integer + 5);
    $real->sub(2);    # same as $real->integer($real->integer - 2);
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for numbers. All of the
  operations correspond to arithmetic operations like addition or
  multiplication.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Num>.
  
  =head1 PROVIDED METHODS
  
  All of these methods modify the attribute's value in place. All methods return
  the new value.
  
  =over 4
  
  =item * B<add($value)>
  
  Adds the current value of the attribute to C<$value>.
  
  =item * B<sub($value)>
  
  Subtracts C<$value> from the current value of the attribute.
  
  =item * B<mul($value)>
  
  Multiplies the current value of the attribute by C<$value>.
  
  =item * B<div($value)>
  
  Divides the current value of the attribute by C<$value>.
  
  =item * B<mod($value)>
  
  Returns the current value of the attribute modulo C<$value>.
  
  =item * B<abs>
  
  Sets the current value of the attribute to its absolute value.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Attribute/Native/Trait/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING';
  package Moose::Meta::Attribute::Native::Trait::String;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::String::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Attribute::Native::Trait::String::VERSION = '2.1204';
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Str' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Str attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::String - Helper trait for Str attributes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package MyHomePage;
    use Moose;
  
    has 'text' => (
        traits  => ['String'],
        is      => 'rw',
        isa     => 'Str',
        default => q{},
        handles => {
            add_text     => 'append',
            replace_text => 'replace',
        },
    );
  
    my $page = MyHomePage->new();
    $page->add_text("foo");    # same as $page->text($page->text . "foo");
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for strings.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Str>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<inc>
  
  Increments the value stored in this slot using the magical string autoincrement
  operator. Note that Perl doesn't provide analogous behavior in C<-->, so
  C<dec> is not available. This method returns the new value.
  
  This method does not accept any arguments.
  
  =item * B<append($string)>
  
  Appends to the string, like C<.=>, and returns the new value.
  
  This method requires a single argument.
  
  =item * B<prepend($string)>
  
  Prepends to the string and returns the new value.
  
  This method requires a single argument.
  
  =item * B<replace($pattern, $replacement)>
  
  Performs a regexp substitution (L<perlop/s>). There is no way to provide the
  C<g> flag, but code references will be accepted for the replacement, causing
  the regex to be modified with a single C<e>. C</smxi> can be applied using the
  C<qr> operator. This method returns the new value.
  
  This method requires two arguments.
  
  =item * B<match($pattern)>
  
  Runs the regex against the string and returns the matching value(s).
  
  This method requires a single argument.
  
  =item * B<chop>
  
  Just like L<perlfunc/chop>. This method returns the chopped character.
  
  This method does not accept any arguments.
  
  =item * B<chomp>
  
  Just like L<perlfunc/chomp>. This method returns the number of characters
  removed.
  
  This method does not accept any arguments.
  
  =item * B<clear>
  
  Sets the string to the empty string (not the value passed to C<default>).
  
  This method does not have a defined return value.
  
  This method does not accept any arguments.
  
  =item * B<length>
  
  Just like L<perlfunc/length>, returns the length of the string.
  
  =item * B<substr>
  
  This acts just like L<perlfunc/substr>. When called as a writer, it returns
  the substring that was replaced, just like the Perl builtin.
  
  This method requires at least one argument, and accepts no more than three.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_CLASS';
  
  package Moose::Meta::Class;
  BEGIN {
    $Moose::Meta::Class::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Class::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP;
  use Carp qw( confess );
  use Data::OptList;
  use List::Util qw( first );
  use List::MoreUtils qw( any all uniq first_index );
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Method::Overridden;
  use Moose::Meta::Method::Augmented;
  use Moose::Meta::Class::Immutable::Trait;
  use Moose::Meta::Method::Constructor;
  use Moose::Meta::Method::Destructor;
  use Moose::Meta::Method::Meta;
  use Moose::Util 'throw_exception';
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Class';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  __PACKAGE__->meta->add_attribute('roles' => (
      reader  => 'roles',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('role_applications' => (
      reader  => '_get_role_applications',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      Class::MOP::Attribute->new('immutable_trait' => (
          accessor => "immutable_trait",
          default  => 'Moose::Meta::Class::Immutable::Trait',
          Class::MOP::_definition_context(),
      ))
  );
  
  __PACKAGE__->meta->add_attribute('constructor_class' => (
      accessor => 'constructor_class',
      default  => 'Moose::Meta::Method::Constructor',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('destructor_class' => (
      accessor => 'destructor_class',
      default  => 'Moose::Meta::Method::Destructor',
      Class::MOP::_definition_context(),
  ));
  
  sub initialize {
      my $class = shift;
      my @args = @_;
      unshift @args, 'package' if @args % 2;
      my %opts = @args;
      my $package = delete $opts{package};
      return Class::MOP::get_metaclass_by_name($package)
          || $class->SUPER::initialize($package,
                  'attribute_metaclass' => 'Moose::Meta::Attribute',
                  'method_metaclass'    => 'Moose::Meta::Method',
                  'instance_metaclass'  => 'Moose::Meta::Instance',
                  %opts,
              );
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{roles} eq 'ARRAY')
          || throw_exception( RolesInCreateTakesAnArrayRef => params => \%options )
              if exists $options{roles};
  
      my $package = delete $options{package};
      my $roles   = delete $options{roles};
  
      my $new_meta = $class->SUPER::create($package, %options);
  
      if ($roles) {
          Moose::Util::apply_all_roles( $new_meta, @$roles );
      }
  
      return $new_meta;
  }
  
  sub _meta_method_class { 'Moose::Meta::Method::Meta' }
  
  sub _anon_package_prefix { 'Moose::Meta::Class::__ANON__::SERIAL::' }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
  
      my $superclass_key = join('|',
          map { $_->[0] } @{ Data::OptList::mkopt($options{superclasses} || []) }
      );
  
      my $roles = Data::OptList::mkopt(($options{roles} || []), {
          moniker  => 'role',
          val_test => sub { ref($_[0]) eq 'HASH' },
      });
  
      my @role_keys;
      for my $role_spec (@$roles) {
          my ($role, $params) = @$role_spec;
          $params = { %$params } if $params;
  
          my $key = blessed($role) ? $role->name : $role;
  
          if ($params && %$params) {
              my $alias    = delete $params->{'-alias'}
                          || delete $params->{'alias'}
                          || {};
              my $excludes = delete $params->{'-excludes'}
                          || delete $params->{'excludes'}
                          || [];
              $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
  
              if (%$params) {
                  warn "Roles with parameters cannot be cached. Consider "
                     . "applying the parameters before calling "
                     . "create_anon_class, or using 'weaken => 0' instead";
                  return;
              }
  
              my $alias_key = join('%',
                  map { $_ => $alias->{$_} } sort keys %$alias
              );
              my $excludes_key = join('%',
                  sort @$excludes
              );
              $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
          }
  
          push @role_keys, $key;
      }
  
      my $role_key = join('|', sort @role_keys);
  
      # Makes something like Super::Class|Super::Class::2=Role|Role::1
      return join('=', $superclass_key, $role_key);
  }
  
  sub reinitialize {
      my $self = shift;
      my $pkg  = shift;
  
      my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
  
      my %existing_classes;
      if ($meta) {
          %existing_classes = map { $_ => $meta->$_() } qw(
              attribute_metaclass
              method_metaclass
              wrapped_method_metaclass
              instance_metaclass
              constructor_class
              destructor_class
          );
      }
  
      return $self->SUPER::reinitialize(
          $pkg,
          %existing_classes,
          @_,
      );
  }
  
  sub add_role {
      my ($self, $role) = @_;
      (blessed($role) && $role->isa('Moose::Meta::Role'))
          || throw_exception( AddRoleTakesAMooseMetaRoleInstance => role_to_be_added => $role,
                                                                    class            => $self
                            );
      push @{$self->roles} => $role;
  }
  
  sub role_applications {
      my ($self) = @_;
  
      return @{$self->_get_role_applications};
  }
  
  sub add_role_application {
      my ($self, $application) = @_;
  
      (blessed($application) && $application->isa('Moose::Meta::Role::Application::ToClass'))
          || throw_exception( InvalidRoleApplication => class       => $self,
                                                        application => $application,
                            );
  
      push @{$self->_get_role_applications} => $application;
  }
  
  sub calculate_all_roles {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ } map { $_->calculate_all_roles } @{ $self->roles };
  }
  
  sub _roles_with_inheritance {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ }
           map { Class::MOP::class_of($_)->can('roles')
                     ? @{ Class::MOP::class_of($_)->roles }
                     : () }
               $self->linearized_isa;
  }
  
  sub calculate_all_roles_with_inheritance {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ }
           map { Class::MOP::class_of($_)->can('calculate_all_roles')
                     ? Class::MOP::class_of($_)->calculate_all_roles
                     : () }
               $self->linearized_isa;
  }
  
  sub does_role {
      my ($self, $role_name) = @_;
  
      (defined $role_name)
          || throw_exception( RoleNameRequired => class => $self );
  
      foreach my $class ($self->class_precedence_list) {
          my $meta = Class::MOP::class_of($class);
          # when a Moose metaclass is itself extended with a role,
          # this check needs to be done since some items in the
          # class_precedence_list might in fact be Class::MOP
          # based still.
          next unless $meta && $meta->can('roles');
          foreach my $role (@{$meta->roles}) {
              return 1 if $role->does_role($role_name);
          }
      }
      return 0;
  }
  
  sub excludes_role {
      my ($self, $role_name) = @_;
  
      (defined $role_name)
          || throw_exception( RoleNameRequired => class => $self );
  
      foreach my $class ($self->class_precedence_list) {
          my $meta = Class::MOP::class_of($class);
          # when a Moose metaclass is itself extended with a role,
          # this check needs to be done since some items in the
          # class_precedence_list might in fact be Class::MOP
          # based still.
          next unless $meta && $meta->can('roles');
          foreach my $role (@{$meta->roles}) {
              return 1 if $role->excludes_role($role_name);
          }
      }
      return 0;
  }
  
  sub new_object {
      my $self   = shift;
      my $params = @_ == 1 ? $_[0] : {@_};
      my $object = $self->SUPER::new_object($params);
  
      $self->_call_all_triggers($object, $params);
  
      $object->BUILDALL($params) if $object->can('BUILDALL');
  
      return $object;
  }
  
  sub _call_all_triggers {
      my ($self, $object, $params) = @_;
  
      foreach my $attr ( $self->get_all_attributes() ) {
  
          next unless $attr->can('has_trigger') && $attr->has_trigger;
  
          my $init_arg = $attr->init_arg;
          next unless defined $init_arg;
          next unless exists $params->{$init_arg};
  
          $attr->trigger->(
              $object,
              (
                    $attr->should_coerce
                  ? $attr->get_read_method_ref->($object)
                  : $params->{$init_arg}
              ),
          );
      }
  }
  
  sub _generate_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return $class . '->Moose::Object::new(@_)'
  }
  
  sub _inline_params {
      my $self = shift;
      my ($params, $class) = @_;
      return (
          'my ' . $params . ' = ',
          $self->_inline_BUILDARGS($class, '@_'),
          ';',
      );
  }
  
  sub _inline_BUILDARGS {
      my $self = shift;
      my ($class, $args) = @_;
  
      my $buildargs = $self->find_method_by_name("BUILDARGS");
  
      if ($args eq '@_'
       && (!$buildargs or $buildargs->body == \&Moose::Object::BUILDARGS)) {
          return (
              'do {',
                  'my $params;',
                  'if (scalar @_ == 1) {',
                      'if (!defined($_[0]) || ref($_[0]) ne \'HASH\') {',
                          $self->_inline_throw_exception(
                              '"SingleParamsToNewMustBeHashRef"'
                          ) . ';',
                      '}',
                      '$params = { %{ $_[0] } };',
                  '}',
                  'elsif (@_ % 2) {',
                      'Carp::carp(',
                          '"The new() method for ' . $class . ' expects a '
                        . 'hash reference or a key/value list. You passed an '
                        . 'odd number of arguments"',
                      ');',
                      '$params = {@_, undef};',
                  '}',
                  'else {',
                      '$params = {@_};',
                  '}',
                  '$params;',
              '}',
          );
      }
      else {
          return $class . '->BUILDARGS(' . $args . ')';
      }
  }
  
  sub _inline_slot_initializer {
      my $self  = shift;
      my ($attr, $idx) = @_;
  
      return (
          '## ' . $attr->name,
          $self->_inline_check_required_attr($attr),
          $self->SUPER::_inline_slot_initializer(@_),
      );
  }
  
  sub _inline_check_required_attr {
      my $self = shift;
      my ($attr) = @_;
  
      return unless defined $attr->init_arg;
      return unless $attr->can('is_required') && $attr->is_required;
      return if $attr->has_default || $attr->has_builder;
  
      return (
          'if (!exists $params->{\'' . $attr->init_arg . '\'}) {',
              $self->_inline_throw_exception(
                  'AttributeIsRequired => '.
                  'params         => $params, '.
                  'class_name     => $class_name, '.
                  'attribute_name => "'.quotemeta($attr->name).'"'
              ).';',
          '}',
      );
  }
  
  # XXX: these two are duplicated from cmop, because we have to pass the tc stuff
  # through to _inline_set_value - this should probably be fixed, but i'm not
  # quite sure how. -doy
  sub _inline_init_attr_from_constructor {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my @initial_value = $attr->_inline_set_value(
          '$instance',
          '$params->{\'' . $attr->init_arg . '\'}',
          '$type_constraint_bodies[' . $idx . ']',
          '$type_coercions[' . $idx . ']',
          '$type_constraint_messages[' . $idx . ']',
          'for constructor',
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_init_attr_from_default {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      return if $attr->can('is_lazy') && $attr->is_lazy;
      my $default = $self->_inline_default_value($attr, $idx);
      return unless $default;
  
      my @initial_value = (
          'my $default = ' . $default . ';',
          $attr->_inline_set_value(
              '$instance',
              '$default',
              '$type_constraint_bodies[' . $idx . ']',
              '$type_coercions[' . $idx . ']',
              '$type_constraint_messages[' . $idx . ']',
              'for constructor',
          ),
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_extra_init {
      my $self = shift;
      return (
          $self->_inline_triggers,
          $self->_inline_BUILDALL,
      );
  }
  
  sub _inline_triggers {
      my $self = shift;
      my @trigger_calls;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
      for my $i (0 .. $#attrs) {
          my $attr = $attrs[$i];
  
          next unless $attr->can('has_trigger') && $attr->has_trigger;
  
          my $init_arg = $attr->init_arg;
          next unless defined $init_arg;
  
          push @trigger_calls,
              'if (exists $params->{\'' . $init_arg . '\'}) {',
                  '$triggers->[' . $i . ']->(',
                      '$instance,',
                      $attr->_inline_instance_get('$instance') . ',',
                  ');',
              '}';
      }
  
      return @trigger_calls;
  }
  
  sub _inline_BUILDALL {
      my $self = shift;
  
      my @methods = reverse $self->find_all_methods_by_name('BUILD');
      my @BUILD_calls;
  
      foreach my $method (@methods) {
          push @BUILD_calls,
              '$instance->' . $method->{class} . '::BUILD($params);';
      }
  
      return @BUILD_calls;
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
  
      my $triggers = [
          map { $_->can('has_trigger') && $_->has_trigger ? $_->trigger : undef }
              @attrs
      ];
  
      # We need to check if the attribute ->can('type_constraint')
      # since we may be trying to immutabilize a Moose meta class,
      # which in turn has attributes which are Class::MOP::Attribute
      # objects, rather than Moose::Meta::Attribute. And
      # Class::MOP::Attribute attributes have no type constraints.
      # However we need to make sure we leave an undef value there
      # because the inlined code is using the index of the attributes
      # to determine where to find the type constraint
  
      my @type_constraints = map {
          $_->can('type_constraint') ? $_->type_constraint : undef
      } @attrs;
  
      my @type_constraint_bodies = map {
          defined $_ ? $_->_compiled_type_constraint : undef;
      } @type_constraints;
  
      my @type_coercions = map {
          defined $_ && $_->has_coercion
              ? $_->coercion->_compiled_type_coercion
              : undef
      } @type_constraints;
  
      my @type_constraint_messages = map {
          defined $_
              ? ($_->has_message ? $_->message : $_->_default_message)
              : undef
      } @type_constraints;
  
      return {
          %{ $self->SUPER::_eval_environment },
          ((any { defined && $_->has_initializer } @attrs)
              ? ('$attrs' => \[@attrs])
              : ()),
          '$triggers' => \$triggers,
          '@type_coercions' => \@type_coercions,
          '@type_constraint_bodies' => \@type_constraint_bodies,
          '@type_constraint_messages' => \@type_constraint_messages,
          ( map { defined($_) ? %{ $_->inline_environment } : () }
                @type_constraints ),
          # pretty sure this is only going to be closed over if you use a custom
          # error class at this point, but we should still get rid of this
          # at some point
          '$meta'  => \$self,
          '$class_name' => \($self->name),
      };
  }
  
  sub superclasses {
      my $self = shift;
      my $supers = Data::OptList::mkopt(\@_);
      foreach my $super (@{ $supers }) {
          my ($name, $opts) = @{ $super };
          Moose::Util::_load_user_class($name, $opts);
          my $meta = Class::MOP::class_of($name);
          throw_exception( CanExtendOnlyClasses => role => $meta )
              if $meta && $meta->isa('Moose::Meta::Role')
      }
      return $self->SUPER::superclasses(map { $_->[0] } @{ $supers });
  }
  
  ### ---------------------------------------------
  
  sub add_attribute {
      my $self = shift;
      my $attr =
          (blessed $_[0] && $_[0]->isa('Class::MOP::Attribute')
              ? $_[0]
              : $self->_process_attribute(@_));
      $self->SUPER::add_attribute($attr);
      # it may be a Class::MOP::Attribute, theoretically, which doesn't have
      # 'bare' and doesn't implement this method
      if ($attr->can('_check_associated_methods')) {
          $attr->_check_associated_methods;
      }
      return $attr;
  }
  
  sub add_override_method_modifier {
      my ($self, $name, $method, $_super_package) = @_;
  
      my $existing_method = $self->get_method($name);
      (!$existing_method)
          || throw_exception( CannotOverrideLocalMethodIsPresent => class  => $self,
                                                                    method => $existing_method,
                            );
      $self->add_method($name => Moose::Meta::Method::Overridden->new(
          method  => $method,
          class   => $self,
          package => $_super_package, # need this for roles
          name    => $name,
      ));
  }
  
  sub add_augment_method_modifier {
      my ($self, $name, $method) = @_;
      my $existing_method = $self->get_method($name);
      throw_exception( CannotAugmentIfLocalMethodPresent => class  => $self,
                                                            method => $existing_method,
                     )
          if( $existing_method );
  
      $self->add_method($name => Moose::Meta::Method::Augmented->new(
          method  => $method,
          class   => $self,
          name    => $name,
      ));
  }
  
  ## Private Utility methods ...
  
  sub _find_next_method_by_name_which_is_not_overridden {
      my ($self, $name) = @_;
      foreach my $method ($self->find_all_methods_by_name($name)) {
          return $method->{code}
              if blessed($method->{code}) && !$method->{code}->isa('Moose::Meta::Method::Overridden');
      }
      return undef;
  }
  
  ## Metaclass compatibility
  
  sub _base_metaclasses {
      my $self = shift;
      my %metaclasses = $self->SUPER::_base_metaclasses;
      for my $class (keys %metaclasses) {
          $metaclasses{$class} =~ s/^Class::MOP/Moose::Meta/;
      }
      return (
          %metaclasses,
      );
  }
  
  sub _fix_class_metaclass_incompatibility {
      my $self = shift;
      my ($super_meta) = @_;
  
      $self->SUPER::_fix_class_metaclass_incompatibility(@_);
  
      if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
          ($self->is_pristine)
              || throw_exception( CannotFixMetaclassCompatibility => class      => $self,
                                                                     superclass => $super_meta
                                );
          my $super_meta_name = $super_meta->_real_ref_name;
          my $class_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass(blessed($self), $super_meta_name);
          my $new_self = $class_meta_subclass_meta_name->reinitialize(
              $self->name,
          );
  
          $self->_replace_self( $new_self, $class_meta_subclass_meta_name );
      }
  }
  
  sub _fix_single_metaclass_incompatibility {
      my $self = shift;
      my ($metaclass_type, $super_meta) = @_;
  
      $self->SUPER::_fix_single_metaclass_incompatibility(@_);
  
      if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
          ($self->is_pristine)
              || throw_exception( CannotFixMetaclassCompatibility => class          => $self,
                                                                     superclass     => $super_meta,
                                                                     metaclass_type => $metaclass_type
                                );
          my $super_meta_name = $super_meta->_real_ref_name;
          my $class_specific_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass($self->$metaclass_type, $super_meta->$metaclass_type);
          my $new_self = $super_meta->reinitialize(
              $self->name,
              $metaclass_type => $class_specific_meta_subclass_meta_name,
          );
  
          $self->_replace_self( $new_self, $super_meta_name );
      }
  }
  
  sub _replace_self {
      my $self      = shift;
      my ( $new_self, $new_class)   = @_;
  
      %$self = %$new_self;
      bless $self, $new_class;
  
      # We need to replace the cached metaclass instance or else when it goes
      # out of scope Class::MOP::Class destroy's the namespace for the
      # metaclass's class, causing much havoc.
      my $weaken = Class::MOP::metaclass_is_weak( $self->name );
      Class::MOP::store_metaclass_by_name( $self->name, $self );
      Class::MOP::weaken_metaclass( $self->name ) if $weaken;
  }
  
  sub _process_attribute {
      my ( $self, $name, @args ) = @_;
  
      @args = %{$args[0]} if scalar @args == 1 && ref($args[0]) eq 'HASH';
  
      if (($name || '') =~ /^\+(.*)/) {
          return $self->_process_inherited_attribute($1, @args);
      }
      else {
          return $self->_process_new_attribute($name, @args);
      }
  }
  
  sub _process_new_attribute {
      my ( $self, $name, @args ) = @_;
  
      $self->attribute_metaclass->interpolate_class_and_new($name, @args);
  }
  
  sub _process_inherited_attribute {
      my ($self, $attr_name, %options) = @_;
  
      my $inherited_attr = $self->find_attribute_by_name($attr_name);
      (defined $inherited_attr)
          || throw_exception( NoAttributeFoundInSuperClass => class          => $self,
                                                              attribute_name => $attr_name,
                                                              params         => \%options
                            );
      if ($inherited_attr->isa('Moose::Meta::Attribute')) {
          return $inherited_attr->clone_and_inherit_options(%options);
      }
      else {
          # NOTE:
          # kind of a kludge to handle Class::MOP::Attributes
          return $inherited_attr->Moose::Meta::Attribute::clone_and_inherit_options(%options);
      }
  }
  
  # reinitialization support
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->SUPER::_restore_metaobjects_from($old_meta);
  
      for my $role ( @{ $old_meta->roles } ) {
          $self->add_role($role);
      }
  
      for my $application ( @{ $old_meta->_get_role_applications } ) {
          $application->class($self);
          $self->add_role_application ($application);
      }
  }
  
  ## Immutability
  
  sub _immutable_options {
      my ( $self, @args ) = @_;
  
      $self->SUPER::_immutable_options(
          inline_destructor => 1,
  
          # Moose always does this when an attribute is created
          inline_accessors => 0,
  
          @args,
      );
  }
  
  sub _fixup_attributes_after_rebless {
      my $self = shift;
      my ($instance, $rebless_from, %params) = @_;
  
      $self->SUPER::_fixup_attributes_after_rebless(
          $instance,
          $rebless_from,
          %params
      );
  
      $self->_call_all_triggers( $instance, \%params );
  }
  
  ## -------------------------------------------------
  
  our $error_level;
  
  sub _inline_throw_exception {
      my ( $self, $throw_args ) = @_;
      return 'Moose::Util::throw_exception('.$throw_args.')';
  }
  
  1;
  
  # ABSTRACT: The Moose metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Class - The Moose metaclass
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Class> that provides
  additional Moose-specific functionality.
  
  To really understand this class, you will need to start with the
  L<Class::MOP::Class> documentation. This class can be understood as a
  set of additional features on top of the basic feature provided by
  that parent class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Class> is a subclass of L<Class::MOP::Class>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Class->initialize($package_name, %options) >>
  
  This overrides the parent's method in order to provide its own
  defaults for the C<attribute_metaclass>, C<instance_metaclass>, and
  C<method_metaclass> options.
  
  These all default to the appropriate Moose class.
  
  =item B<< Moose::Meta::Class->create($package_name, %options) >>
  
  This overrides the parent's method in order to accept a C<roles>
  option. This should be an array reference containing roles
  that the class does, each optionally followed by a hashref of options
  (C<-excludes> and C<-alias>).
  
    my $metaclass = Moose::Meta::Class->create( 'New::Class', roles => [...] );
  
  =item B<< Moose::Meta::Class->create_anon_class >>
  
  This overrides the parent's method to accept a C<roles> option, just
  as C<create> does.
  
  It also accepts a C<cache> option. If this is C<true>, then the anonymous
  class will be cached based on its superclasses and roles. If an
  existing anonymous class in the cache has the same superclasses and
  roles, it will be reused.
  
    my $metaclass = Moose::Meta::Class->create_anon_class(
        superclasses => ['Foo'],
        roles        => [qw/Some Roles Go Here/],
        cache        => 1,
    );
  
  Each entry in both the C<superclasses> and the C<roles> option can be
  followed by a hash reference with arguments. The C<superclasses>
  option can be supplied with a L<-version|Class::MOP/Class Loading
  Options> option that ensures the loaded superclass satisfies the
  required version. The C<role> option also takes the C<-version> as an
  argument, but the option hash reference can also contain any other
  role relevant values like exclusions or parameterized role arguments.
  
  =item B<< $metaclass->new_object(%params) >>
  
  This overrides the parent's method in order to add support for
  attribute triggers.
  
  =item B<< $metaclass->superclasses(@superclasses) >>
  
  This is the accessor allowing you to read or change the parents of
  the class.
  
  Each superclass can be followed by a hash reference containing a
  L<-version|Class::MOP/Class Loading Options> value. If the version
  requirement is not satisfied an error will be thrown.
  
  =item B<< $metaclass->add_override_method_modifier($name, $sub) >>
  
  This adds an C<override> method modifier to the package.
  
  =item B<< $metaclass->add_augment_method_modifier($name, $sub) >>
  
  This adds an C<augment> method modifier to the package.
  
  =item B<< $metaclass->calculate_all_roles >>
  
  This will return a unique array of L<Moose::Meta::Role> instances
  which are attached to this class.
  
  =item B<< $metaclass->calculate_all_roles_with_inheritance >>
  
  This will return a unique array of L<Moose::Meta::Role> instances
  which are attached to this class, and each of this class's ancestors.
  
  =item B<< $metaclass->add_role($role) >>
  
  This takes a L<Moose::Meta::Role> object, and adds it to the class's
  list of roles. This I<does not> actually apply the role to the class.
  
  =item B<< $metaclass->role_applications >>
  
  Returns a list of L<Moose::Meta::Role::Application::ToClass>
  objects, which contain the arguments to role application.
  
  =item B<< $metaclass->add_role_application($application) >>
  
  This takes a L<Moose::Meta::Role::Application::ToClass> object, and
  adds it to the class's list of role applications. This I<does not>
  actually apply any role to the class; it is only for tracking role
  applications.
  
  =item B<< $metaclass->does_role($role) >>
  
  This returns a boolean indicating whether or not the class does the specified
  role. The role provided can be either a role name or a L<Moose::Meta::Role>
  object. This tests both the class and its parents.
  
  =item B<< $metaclass->excludes_role($role_name) >>
  
  A class excludes a role if it has already composed a role which
  excludes the named role. This tests both the class and its parents.
  
  =item B<< $metaclass->add_attribute($attr_name, %params|$params) >>
  
  This overrides the parent's method in order to allow the parameters to
  be provided as a hash reference.
  
  =item B<< $metaclass->constructor_class($class_name) >>
  
  =item B<< $metaclass->destructor_class($class_name) >>
  
  These are the names of classes used when making a class immutable. These
  default to L<Moose::Meta::Method::Constructor> and
  L<Moose::Meta::Method::Destructor> respectively. These accessors are
  read-write, so you can use them to change the class name.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_CLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Class/Immutable/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_CLASS_IMMUTABLE_TRAIT';
  package Moose::Meta::Class::Immutable::Trait;
  BEGIN {
    $Moose::Meta::Class::Immutable::Trait::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Class::Immutable::Trait::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP;
  use Scalar::Util qw( blessed );
  
  use parent 'Class::MOP::Class::Immutable::Trait';
  
  use Moose::Util 'throw_exception';
  
  sub add_role { $_[1]->_immutable_cannot_call }
  
  sub calculate_all_roles {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{calculate_all_roles} ||= [ $self->$orig ] };
  }
  
  sub calculate_all_roles_with_inheritance {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{calculate_all_roles_with_inheritance} ||= [ $self->$orig ] };
  }
  
  sub does_role {
      shift;
      my $self = shift;
      my $role = shift;
  
      (defined $role)
          || throw_exception( RoleNameRequired => class => $self );
  
      $self->{__immutable}{does_role} ||= { map { $_->name => 1 } $self->calculate_all_roles_with_inheritance };
  
      my $name = blessed $role ? $role->name : $role;
  
      return $self->{__immutable}{does_role}{$name};
  }
  
  1;
  
  # ABSTRACT: Implements immutability for metaclass objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Class::Immutable::Trait - Implements immutability for metaclass objects
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class makes some Moose-specific metaclass methods immutable. This
  is deep guts.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_CLASS_IMMUTABLE_TRAIT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_INSTANCE';
  
  package Moose::Meta::Instance;
  BEGIN {
    $Moose::Meta::Instance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Instance::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Instance';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  1;
  
  # ABSTRACT: The Moose Instance metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Instance - The Moose Instance metaclass
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
      # nothing to see here
  
  =head1 DESCRIPTION
  
  This class provides the low level data storage abstractions for
  attributes.
  
  Using this API directly in your own code violates encapsulation, and
  we recommend that you use the appropriate APIs in
  L<Moose::Meta::Class> and L<Moose::Meta::Attribute> instead. Those
  APIs in turn call the methods in this class as appropriate.
  
  At present, this is an empty subclass of L<Class::MOP::Instance>, so
  you should see that class for all API details.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Instance> is a subclass of L<Class::MOP::Instance>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_INSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD';
  package Moose::Meta::Method;
  BEGIN {
    $Moose::Meta::Method::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Method';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  1;
  
  # ABSTRACT: A Moose Method metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method - A Moose Method metaclass
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method> that provides
  additional Moose-specific functionality, all of which is private.
  
  To understand this class, you should read the the L<Class::MOP::Method>
  documentation.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method> is a subclass of L<Class::MOP::Method>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR';
  
  package Moose::Meta::Method::Accessor;
  BEGIN {
    $Moose::Meta::Method::Accessor::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Try::Tiny;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Accessor';
  
  use Moose::Util 'throw_exception';
  
  # multiple inheritance is terrible
  sub new {
      goto &Class::MOP::Method::Accessor::new;
  }
  
  sub _new {
      goto &Class::MOP::Method::Accessor::_new;
  }
  
  sub _error_thrower {
      my $self = shift;
      return $self->associated_attribute
          if ref($self) && defined($self->associated_attribute);
      return $self->SUPER::_error_thrower;
  }
  
  sub _compile_code {
      my $self = shift;
      my @args = @_;
      try {
          $self->SUPER::_compile_code(@args);
      }
      catch {
          throw_exception( CouldNotCreateWriter => attribute      => $self->associated_attribute,
                                                   error          => $_,
                                                   instance       => $self
                         );
      };
  }
  
  sub _eval_environment {
      my $self = shift;
      return $self->associated_attribute->_eval_environment;
  }
  
  sub _instance_is_inlinable {
      my $self = shift;
      return $self->associated_attribute->associated_class->instance_metaclass->is_inlinable;
  }
  
  sub _generate_reader_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_reader_method_inline(@_)
                                    : $self->SUPER::_generate_reader_method(@_);
  }
  
  sub _generate_writer_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_writer_method_inline(@_)
                                    : $self->SUPER::_generate_writer_method(@_);
  }
  
  sub _generate_accessor_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_accessor_method_inline(@_)
                                    : $self->SUPER::_generate_accessor_method(@_);
  }
  
  sub _generate_predicate_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_predicate_method_inline(@_)
                                    : $self->SUPER::_generate_predicate_method(@_);
  }
  
  sub _generate_clearer_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_clearer_method_inline(@_)
                                    : $self->SUPER::_generate_clearer_method(@_);
  }
  
  sub _writer_value_needs_copy {
      shift->associated_attribute->_writer_value_needs_copy(@_);
  }
  
  sub _inline_tc_code {
      shift->associated_attribute->_inline_tc_code(@_);
  }
  
  sub _inline_check_coercion {
      shift->associated_attribute->_inline_check_coercion(@_);
  }
  
  sub _inline_check_constraint {
      shift->associated_attribute->_inline_check_constraint(@_);
  }
  
  sub _inline_check_lazy {
      shift->associated_attribute->_inline_check_lazy(@_);
  }
  
  sub _inline_store_value {
      shift->associated_attribute->_inline_instance_set(@_) . ';';
  }
  
  sub _inline_get_old_value_for_trigger {
      shift->associated_attribute->_inline_get_old_value_for_trigger(@_);
  }
  
  sub _inline_trigger {
      shift->associated_attribute->_inline_trigger(@_);
  }
  
  sub _get_value {
      shift->associated_attribute->_inline_instance_get(@_);
  }
  
  sub _has_value {
      shift->associated_attribute->_inline_instance_has(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for accessors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Accessor - A Moose Method metaclass for accessors
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Accessor> that
  provides additional Moose-specific functionality, all of which is
  private.
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Accessor> documentation.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE';
  package Moose::Meta::Method::Accessor::Native;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Carp qw( confess );
  use Scalar::Util qw( blessed weaken );
  
  use Moose::Role;
  
  use Moose::Util 'throw_exception';
  
  around new => sub {
      my $orig = shift;
      my $class   = shift;
      my %options = @_;
  
      $options{curried_arguments} = []
          unless exists $options{curried_arguments};
  
      throw_exception( MustSupplyArrayRefAsCurriedArguments => params     => \%options,
                                                               class_name => $class
                     )
          unless $options{curried_arguments}
              && ref($options{curried_arguments}) eq 'ARRAY';
  
      my $attr_context = $options{attribute}->definition_context;
      my $desc = 'native delegation method ';
      $desc   .= $options{attribute}->associated_class->name;
      $desc   .= '::' . $options{name};
      $desc   .= " ($options{delegate_to_method})";
      $desc   .= " of attribute " . $options{attribute}->name;
      $options{definition_context} = {
          %{ $attr_context || {} },
          description => $desc,
      };
  
      $options{accessor_type} = 'native';
  
      return $class->$orig(%options);
  };
  
  sub _new {
      my $class = shift;
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless $options, $class;
  }
  
  sub root_types { (shift)->{'root_types'} }
  
  sub _initialize_body {
      my $self = shift;
  
      $self->{'body'} = $self->_compile_code( [$self->_generate_method] );
  
      return;
  }
  
  sub _inline_curried_arguments {
      my $self = shift;
  
      return unless @{ $self->curried_arguments };
  
      return 'unshift @_, @curried;';
  }
  
  sub _inline_check_argument_count {
      my $self = shift;
  
      my @code;
  
      if (my $min = $self->_minimum_arguments) {
          push @code, (
              'if (@_ < ' . $min . ') {',
                  $self->_inline_throw_exception( "MethodExpectsMoreArgs => ".
                                                  'method_name           => "'.$self->delegate_to_method.'",'.
                                                  "minimum_args          => ".$min,
                  ) . ';',
              '}',
          );
      }
  
      if (defined(my $max = $self->_maximum_arguments)) {
          push @code, (
              'if (@_ > ' . $max . ') {',
                  $self->_inline_throw_exception( "MethodExpectsFewerArgs => ".
                                                  'method_name            => "'.$self->delegate_to_method.'",'.
                                                  'maximum_args           => '.$max,
                  ) . ';',
              '}',
          );
      }
  
      return @code;
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access, $for_writer) = @_;
  
      return 'return ' . $self->_return_value($slot_access, $for_writer) . ';';
  }
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { undef }
  
  override _get_value => sub {
      my $self = shift;
      my ($instance) = @_;
  
      return $self->_slot_access_can_be_inlined
          ? super()
          : $instance . '->$reader';
  };
  
  override _inline_store_value => sub {
      my $self = shift;
      my ($instance, $value) = @_;
  
      return $self->_slot_access_can_be_inlined
          ? super()
          : $instance . '->$writer(' . $value . ');';
  };
  
  override _eval_environment => sub {
      my $self = shift;
  
      my $env = super();
  
      $env->{'@curried'} = $self->curried_arguments;
  
      return $env if $self->_slot_access_can_be_inlined;
  
      my $reader = $self->associated_attribute->get_read_method_ref;
      $reader = $reader->body if blessed $reader;
  
      $env->{'$reader'} = \$reader;
  
      my $writer = $self->associated_attribute->get_write_method_ref;
      $writer = $writer->body if blessed $writer;
  
      $env->{'$writer'} = \$writer;
  
      return $env;
  };
  
  sub _slot_access_can_be_inlined {
      my $self = shift;
  
      return $self->is_inline && $self->_instance_is_inlinable;
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY';
  package Moose::Meta::Method::Accessor::Native::Array;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  use Scalar::Util qw( looks_like_number );
  
  sub _inline_check_var_is_valid_index {
      my $self = shift;
      my ($var) = @_;
  
      return (
          'if (!defined(' . $var . ') || ' . $var . ' !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => '.$var.','.
                                              'method_name             => "'.$self->delegate_to_method.'",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "index"',
              ) . ';',
          '}',
      );
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER';
  package Moose::Meta::Method::Accessor::Native::Array::Writer;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::Writer::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::Writer::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer',
       'Moose::Meta::Method::Accessor::Native::Array',
       'Moose::Meta::Method::Accessor::Native::Collection';
  
  sub _inline_coerce_new_values {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Collection::_inline_coerce_new_values(@_);
  }
  
  sub _new_members { '@_' }
  
  sub _copy_old_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{(' . $slot_access . ')} ]';
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Array::accessor;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::accessor::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::accessor::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::set',
       'Moose::Meta::Method::Accessor::Native::Array::get';
  
  sub _inline_process_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_process_arguments(@_);
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_check_arguments(@_);
  }
  
  sub _return_value {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_return_value(@_);
  }
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
              # get
              'if (@_ == 1) {',
                  $self->_inline_check_var_is_valid_index('$_[0]'),
                  $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_return_value($slot_access),
              '}',
              # set
              'else {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 2 }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Array::clear;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::clear::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::clear::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value { '[]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = [];';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/count.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT';
  package Moose::Meta::Method::Accessor::Native::Array::count;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::count::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::count::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/delete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE';
  package Moose::Meta::Method::Accessor::Native::Array::delete;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::delete::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::delete::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '@return = splice @potential, $_[0], 1; '
               . '\@potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = splice @{ (' . $slot_access . ') }, $_[0], 1;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/elements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Array::elements;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::elements::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::elements::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/first.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST';
  package Moose::Meta::Method::Accessor::Native::Array::first;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::first::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::first::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "first",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '&List::Util::first($_[0], @{ (' . $slot_access . ') })';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/first_index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX';
  package Moose::Meta::Method::Accessor::Native::Array::first_index;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::first_index::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::first_index::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "first_index",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '&List::MoreUtils::first_index($_[0], @{ (' . $slot_access . ') })';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET';
  package Moose::Meta::Method::Accessor::Native::Array::get;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::get::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::get::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Array';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[ $_[0] ]';
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/grep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP';
  package Moose::Meta::Method::Accessor::Native::Array::grep;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::grep::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::grep::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "grep",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'grep { $_[0]->() } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/insert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT';
  package Moose::Meta::Method::Accessor::Native::Array::insert;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::insert::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::insert::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { 2 }
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . 'splice @potential, $_[0], 0, $_[1]; '
               . '\@potential; '
           . '})';
  }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return '@_ = ($_[0], $member_coercion->($_[1]));';
  };
  
  sub _new_members { '$_[1]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'splice @{ (' . $slot_access . ') }, $_[0], 0, $_[1];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[ $_[0] ]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/is_empty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Array::is_empty;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::is_empty::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::is_empty::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@{ (' . $slot_access . ') } ? 0 : 1';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/join.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN';
  package Moose::Meta::Method::Accessor::Native::Array::join;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::join::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::join::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "join",'.
                                              'type_of_argument        => "string",'.
                                              'type                    => "Str",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'join $_[0], @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP';
  package Moose::Meta::Method::Accessor::Native::Array::map;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::map::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::map::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "map",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { $_[0]->() } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/natatime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME';
  package Moose::Meta::Method::Accessor::Native::Array::natatime;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::natatime::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::natatime::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!defined($_[0]) || $_[0] !~ /^\d+$/) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "natatime",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "n value"',
              ) . ';',
          '}',
          'if (@_ == 2 && !Params::Util::_CODELIKE($_[1])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[1],'.
                                              'method_name             => "natatime",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",'.
                                              'ordinal                 => "second"',
              ) . ';',
          '}',
      );
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return (
          'my $iter = List::MoreUtils::natatime($_[0], @{ (' . $slot_access . ') });',
          'if ($_[1]) {',
              'while (my @vals = $iter->()) {',
                  '$_[1]->(@vals);',
              '}',
          '}',
          'else {',
              'return $iter;',
          '}',
      );
  }
  
  # Not called, but needed to satisfy the Reader role
  sub _return_value { }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP';
  package Moose::Meta::Method::Accessor::Native::Array::pop;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::pop::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::pop::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } > 1 '
               . '? @{ (' . $slot_access . ') }[0..$#{ (' . $slot_access . ') } - 1] '
               . ': () ]';
  }
  
  sub _inline_capture_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'my $old = ' . $slot_access . '->[-1];';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'pop @{ (' . $slot_access . ') };';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$old';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/push.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH';
  package Moose::Meta::Method::Accessor::Native::Array::push;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::push::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::push::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') }, @_ ]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'push @{ (' . $slot_access . ') }, @_;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/reduce.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE';
  package Moose::Meta::Method::Accessor::Native::Array::reduce;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::reduce::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::reduce::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "reduce",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::reduce { $_[0]->($a, $b) } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET';
  package Moose::Meta::Method::Accessor::Native::Array::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::set::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::set::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '$potential[$_[0]] = $_[1]; '
               . '\@potential; '
           . '})';
  }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return '@_ = ($_[0], $member_coercion->($_[1]));';
  };
  
  sub _new_members { '$_[1]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . '->[$_[0]] = $_[1];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[$_[0]]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shallow_clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Array::shallow_clone;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::shallow_clone::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::shallow_clone::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 0 }
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } ]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::shift;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::shift::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::shift::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } > 1 '
               . '? @{ (' . $slot_access . ') }[1..$#{ (' . $slot_access . ') }] '
               . ': () ]';
  }
  
  sub _inline_capture_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'my $old = ' . $slot_access . '->[0];';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'shift @{ (' . $slot_access . ') };';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$old';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shuffle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE';
  package Moose::Meta::Method::Accessor::Native::Array::shuffle;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::shuffle::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::shuffle::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::shuffle @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/sort.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT';
  package Moose::Meta::Method::Accessor::Native::Array::sort;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::sort::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::sort::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "sort",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$_[0] '
               . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
               . ': sort @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/sort_in_place.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE';
  package Moose::Meta::Method::Accessor::Native::Array::sort_in_place;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::sort_in_place::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::sort_in_place::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "sort_in_place",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ $_[0] '
               . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
               . ': sort @{ (' . $slot_access . ') } ]';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/splice.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE';
  package Moose::Meta::Method::Accessor::Native::Array::splice;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::splice::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::splice::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _adds_members { 1 }
  
  sub _inline_process_arguments {
      return (
          'my $idx = shift;',
          'my $len = @_ ? shift : undef;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          $self->_inline_check_var_is_valid_index('$idx'),
          'if (defined($len) && $len !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $len,'.
                                              'method_name             => "splice",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "length argument"',
              ) . ';',
          '}',
      );
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '@return = defined $len '
                   . '? (splice @potential, $idx, $len, @_) '
                   . ': (splice @potential, $idx); '
                   . '\@potential;'
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return (
          '@return = defined $len',
              '? (splice @{ (' . $slot_access . ') }, $idx, $len, @_)',
              ': (splice @{ (' . $slot_access . ') }, $idx);',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray ? @return : $return[-1]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/uniq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ';
  package Moose::Meta::Method::Accessor::Native::Array::uniq;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::uniq::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::uniq::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::MoreUtils::uniq @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Array/unshift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::unshift;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::unshift::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Array::unshift::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @_, @{ (' . $slot_access . ') } ]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'unshift @{ (' . $slot_access . ') }, @_;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/not.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT';
  package Moose::Meta::Method::Accessor::Native::Bool::not;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Bool::not::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Bool::not::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '!' . $slot_access;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET';
  package Moose::Meta::Method::Accessor::Native::Bool::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Bool::set::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Bool::set::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { 1 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = 1;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/toggle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE';
  package Moose::Meta::Method::Accessor::Native::Bool::toggle;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Bool::toggle::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Bool::toggle::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' ? 0 : 1';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = ' . $slot_access . ' ? 0 : 1;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/unset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET';
  package Moose::Meta::Method::Accessor::Native::Bool::unset;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Bool::unset::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Bool::unset::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { 0 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = 0;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Code/execute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE';
  package Moose::Meta::Method::Accessor::Native::Code::execute;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Code::execute::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Code::execute::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->(@_)';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Code/execute_method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD';
  package Moose::Meta::Method::Accessor::Native::Code::execute_method;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Code::execute_method::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Code::execute_method::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->($self, @_)';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION';
  package Moose::Meta::Method::Accessor::Native::Collection;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Collection::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Collection::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  requires qw( _adds_members );
  
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return (
          '(' . $self->_new_members . ') = map { $member_coercion->($_) }',
                                               $self->_new_members . ';',
      );
  }
  
  sub _tc_member_type_can_coerce {
      my $self = shift;
  
      my $member_tc = $self->_tc_member_type;
  
      return $member_tc && $member_tc->has_coercion;
  }
  
  sub _tc_member_type {
      my $self = shift;
  
      my $tc = $self->associated_attribute->type_constraint;
      while ($tc) {
          return $tc->type_parameter
              if $tc->can('type_parameter');
          $tc = $tc->parent;
      }
  
      return;
  }
  
  sub _writer_value_needs_copy {
      my $self = shift;
  
      return $self->_constraint_must_be_checked
          && !$self->_check_new_members_only;
  }
  
  sub _inline_tc_code {
      my $self = shift;
      my ($value, $tc, $coercion, $message, $is_lazy) = @_;
  
      return unless $self->_constraint_must_be_checked;
  
      if ($self->_check_new_members_only) {
          return unless $self->_adds_members;
  
          return $self->_inline_check_member_constraint($self->_new_members);
      }
      else {
          return (
              $self->_inline_check_coercion($value, $tc, $coercion, $is_lazy),
              $self->_inline_check_constraint($value, $tc, $message, $is_lazy),
          );
      }
  }
  
  sub _check_new_members_only {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      my $tc = $attr->type_constraint;
  
      # If we have a coercion, we could come up with an entirely new value after
      # coercing, so we need to check everything,
      return 0 if $attr->should_coerce && $tc->has_coercion;
  
      # If the parent is our root type (ArrayRef, HashRef, etc), that means we
      # can just check the new members of the collection, because we know that
      # we will always be generating an appropriate collection type.
      #
      # However, if this type has its own constraint (it's Parameteriz_able_,
      # not Paramet_erized_), we don't know what is being checked by the
      # constraint, so we need to check the whole value, not just the members.
      return 1
          if $self->_is_root_type( $tc->parent )
              && ( $tc->isa('Moose::Meta::TypeConstraint::Parameterized')
                   || $tc->isa('Specio::Constraint::Parameterized') );
  
      return 0;
  }
  
  sub _inline_check_member_constraint {
      my $self = shift;
      my ($new_value) = @_;
  
      my $attr_name = $self->associated_attribute->name;
  
      my $check
          = $self->_tc_member_type->can_be_inlined
          ? '! (' . $self->_tc_member_type->_inline_check('$new_val') . ')'
          : ' !$member_tc->($new_val) ';
  
      return (
          'for my $new_val (' . $new_value . ') {',
              "if ($check) {",
                  'my $msg = do { local $_ = $new_val; $member_message->($new_val) };'.
                  $self->_inline_throw_exception( "ValidationFailedForInlineTypeConstraint => ".
                                                  "attribute_name          => '".$attr_name."',".
                                                  'type_constraint_message => $msg,'.
                                                  'class_name              => $class_name,'.
                                                  'value                   => $new_val,'.
                                                  'new_member              => 1',
                  ) . ';',
              '}',
          '}',
      );
  }
  
  sub _inline_get_old_value_for_trigger {
      my $self = shift;
      my ($instance, $old) = @_;
  
      my $attr = $self->associated_attribute;
      return unless $attr->has_trigger;
  
      return (
          'my ' . $old . ' = ' . $self->_has_value($instance),
              '? ' . $self->_copy_old_value($self->_get_value($instance)),
              ': ();',
      );
  }
  
  around _eval_environment => sub {
      my $orig = shift;
      my $self = shift;
  
      my $env = $self->$orig(@_);
  
      my $member_tc = $self->_tc_member_type;
  
      return $env unless $member_tc;
  
      $env->{'$member_tc'} = \( $member_tc->_compiled_type_constraint );
      $env->{'$member_coercion'} = \(
          $member_tc->coercion->_compiled_type_coercion
      ) if $member_tc->has_coercion;
      $env->{'$member_message'} = \(
          $member_tc->has_message
              ? $member_tc->message
              : $member_tc->_default_message
      );
  
      my $tc_env = $member_tc->inline_environment();
  
      $env = { %{$env}, %{$tc_env} };
  
      return $env;
  };
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER';
  package Moose::Meta::Method::Accessor::Native::Counter::Writer;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::Writer::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Counter::Writer::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _constraint_must_be_checked {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      return $attr->has_type_constraint
          && ($attr->type_constraint->name =~ /^(?:Num|Int)$/
           || ($attr->should_coerce && $attr->type_constraint->has_coercion)
             );
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/dec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC';
  package Moose::Meta::Method::Accessor::Native::Counter::dec;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::dec::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Counter::dec::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' - (defined $_[0] ? $_[0] : 1)';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' -= defined $_[0] ? $_[0] : 1;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/inc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC';
  package Moose::Meta::Method::Accessor::Native::Counter::inc;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::inc::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Counter::inc::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' + (defined $_[0] ? $_[0] : 1)';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' += defined $_[0] ? $_[0] : 1;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/reset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET';
  package Moose::Meta::Method::Accessor::Native::Counter::reset;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::reset::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Counter::reset::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      my $attr = $self->associated_attribute;
  
      return '(do { '
               . join(' ', $attr->_inline_generate_default(
                     '$self', '$default_for_reset'
                 )) . ' '
               . '$default_for_reset; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = ' . $self->_potential_value . ';';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET';
  package Moose::Meta::Method::Accessor::Native::Counter::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::set::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Counter::set::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value { '$_[0]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH';
  package Moose::Meta::Method::Accessor::Native::Hash;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  sub _inline_check_var_is_valid_key {
      my $self = shift;
      my ($var) = @_;
  
      return (
          'if (!defined(' . $var . ')) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => '.$var.','.
                                              'method_name             => "'.$self->delegate_to_method.'",'.
                                              'type_of_argument        => "defined value",'.
                                              'type                    => "Defined",'.
                                              'argument_noun           => "key"',
              ) . ';',
          '}',
      );
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER';
  package Moose::Meta::Method::Accessor::Native::Hash::Writer;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::Writer::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::Writer::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer',
       'Moose::Meta::Method::Accessor::Native::Hash',
       'Moose::Meta::Method::Accessor::Native::Collection';
  
  sub _inline_coerce_new_values {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Collection::_inline_coerce_new_values(@_);
  }
  
  sub _new_values { '@values' }
  
  sub _copy_old_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') } }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Hash::accessor;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::accessor::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::accessor::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::set',
       'Moose::Meta::Method::Accessor::Native::Hash::get';
  
  sub _inline_process_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_process_arguments(@_);
  }
  
  sub _inline_check_argument_count {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_argument_count(@_);
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_arguments(@_);
  }
  
  sub _return_value {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_return_value(@_);
  }
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
              # get
              'if (@_ == 1) {',
                  $self->_inline_check_var_is_valid_key('$_[0]'),
                  $slot_access . '->{$_[0]}',
              '}',
              # set
              'else {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 2 }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Hash::clear;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::clear::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::clear::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value { '{}' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = {};';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/count.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT';
  package Moose::Meta::Method::Accessor::Native::Hash::count;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::count::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::count::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/defined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED';
  package Moose::Meta::Method::Accessor::Native::Hash::defined;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::defined::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::defined::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_key('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'defined ' . $slot_access . '->{ $_[0] }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/delete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE';
  package Moose::Meta::Method::Accessor::Native::Hash::delete;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::delete::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::delete::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my %potential = %{ (' . $slot_access . ') }; '
               . '@return = delete @potential{@_}; '
               . '\%potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = delete @{ (' . $slot_access . ') }{@_};';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray ? @return : $return[-1]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/elements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Hash::elements;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::elements::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::elements::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { $_, ' . $slot_access . '->{$_} } '
               . 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/exists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS';
  package Moose::Meta::Method::Accessor::Native::Hash::exists;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::exists::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::exists::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_key('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = shift;
  
      return 'exists ' . $slot_access . '->{ $_[0] }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET';
  package Moose::Meta::Method::Accessor::Native::Hash::get;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::get::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::get::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'for (@_) {',
              $self->_inline_check_var_is_valid_key('$_'),
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@_ > 1 '
               . '? @{ (' . $slot_access . ') }{@_} '
               . ': ' . $slot_access . '->{$_[0]}';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/is_empty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Hash::is_empty;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::is_empty::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::is_empty::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar keys %{ (' . $slot_access . ') } ? 0 : 1';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/keys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS';
  package Moose::Meta::Method::Accessor::Native::Hash::keys;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::keys::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::keys::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/kv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV';
  package Moose::Meta::Method::Accessor::Native::Hash::kv;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::kv::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::kv::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { [ $_, ' . $slot_access . '->{$_} ] } '
               . 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET';
  package Moose::Meta::Method::Accessor::Native::Hash::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::set::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::set::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { undef }
  
  around _inline_check_argument_count => sub {
      my $orig = shift;
      my $self = shift;
  
      return (
          $self->$orig(@_),
          'if (@_ % 2) {',
              $self->_inline_throw_exception( "MustPassEvenNumberOfArguments => ".
                                              "method_name => '".$self->delegate_to_method."',".
                                              'args        => \@_',
              ) . ';',
          '}',
      );
  };
  
  sub _inline_process_arguments {
      my $self = shift;
  
      return (
          'my @keys_idx = grep { ! ($_ % 2) } 0..$#_;',
          'my @values_idx = grep { $_ % 2 } 0..$#_;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'for (@keys_idx) {',
              'if (!defined($_[$_])) {',
                  $self->_inline_throw_exception( "UndefinedHashKeysPassedToMethod => ".
                                                  'hash_keys                       => \@keys_idx,'.
                                                  "method_name                     => '".$self->delegate_to_method."'",
                  ) . ';',
              '}',
          '}',
      );
  }
  
  sub _adds_members { 1 }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      # Is there a simpler way to do this?
      return (
          'my $iter = List::MoreUtils::natatime(2, @_);',
          '@_ = ();',
          'while (my ($key, $val) = $iter->()) {',
              'push @_, $key, $member_coercion->($val);',
          '}',
      );
  };
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') }, @_ }';
  }
  
  sub _new_members { '@_[ @values_idx ]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@{ (' . $slot_access . ') }{ @_[@keys_idx] } = @_[@values_idx];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray '
               . '? @{ (' . $slot_access . ') }{ @_[@keys_idx] } '
               . ': ' . $slot_access . '->{ $_[$keys_idx[0]] }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/shallow_clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Hash::shallow_clone;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::shallow_clone::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::shallow_clone::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 0 }
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') } }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES';
  package Moose::Meta::Method::Accessor::Native::Hash::values;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::values::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Hash::values::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'values %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Number/abs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS';
  package Moose::Meta::Method::Accessor::Native::Number::abs;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::abs::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Number::abs::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'abs(' . $slot_access . ')';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = abs(' . $slot_access . ');';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Number/add.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD';
  package Moose::Meta::Method::Accessor::Native::Number::add;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::add::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Number::add::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' + $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' += $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Number/div.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV';
  package Moose::Meta::Method::Accessor::Native::Number::div;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::div::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Number::div::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' / $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' /= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Number/mod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD';
  package Moose::Meta::Method::Accessor::Native::Number::mod;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::mod::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Number::mod::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' % $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' %= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Number/mul.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL';
  package Moose::Meta::Method::Accessor::Native::Number::mul;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::mul::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Number::mul::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' * $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' *= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Number/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET';
  package Moose::Meta::Method::Accessor::Native::Number::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::set::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Number::set::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value { '$_[0]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Number/sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB';
  package Moose::Meta::Method::Accessor::Native::Number::sub;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::sub::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Number::sub::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' - $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' -= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER';
  package Moose::Meta::Method::Accessor::Native::Reader;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Reader::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Reader::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native';
  
  requires '_return_value';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_reader_core($inv, $slot_access, @_),
          '}',
      );
  }
  
  sub _inline_reader_core {
      my $self = shift;
      my ($inv, $slot_access, @extra) = @_;
  
      return (
          $self->_inline_check_argument_count,
          $self->_inline_process_arguments($inv, $slot_access),
          $self->_inline_check_arguments,
          $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
          $self->_inline_return_value($slot_access),
      );
  }
  
  sub _inline_process_arguments { return }
  
  sub _inline_check_arguments { return }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/append.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND';
  package Moose::Meta::Method::Accessor::Native::String::append;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::append::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::append::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '( ' . $slot_access . ' . $_[0] )';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' .= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/chomp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP';
  package Moose::Meta::Method::Accessor::Native::String::chomp;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::chomp::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::chomp::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '@return = chomp $val; '
               . '$val '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = chomp ' . $slot_access . ';';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/chop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP';
  package Moose::Meta::Method::Accessor::Native::String::chop;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::chop::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::chop::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '@return = chop $val; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = chop ' . $slot_access . ';';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR';
  package Moose::Meta::Method::Accessor::Native::String::clear;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::clear::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::clear::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { '""' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = "";';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/inc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC';
  package Moose::Meta::Method::Accessor::Native::String::inc;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::inc::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::inc::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '$val++; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . '++;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/length.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH';
  package Moose::Meta::Method::Accessor::Native::String::length;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::length::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::length::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'length ' . $slot_access;
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH';
  package Moose::Meta::Method::Accessor::Native::String::match;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::match::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::match::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'type                    => "Str|RegexpRef",'.
                                              'type_of_argument        => "string or regexp reference",'.
                                              'method_name             => "match"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' =~ $_[0]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/prepend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND';
  package Moose::Meta::Method::Accessor::Native::String::prepend;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::prepend::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::prepend::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$_[0] . ' . $slot_access;
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0] . ' . $slot_access . ';';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/replace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE';
  package Moose::Meta::Method::Accessor::Native::String::replace;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::replace::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::replace::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[0],'.
                                              'method_name             => "replace",'.
                                              'ordinal                 => "first",'.
                                              'type_of_argument        => "string or regexp reference",'.
                                              'type                    => "Str|RegexpRef"',
              ) . ';',
          '}',
          'if (!Moose::Util::_STRINGLIKE0($_[1]) && !Params::Util::_CODELIKE($_[1])) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $_[1],'.
                                              'method_name             => "replace",'.
                                              'ordinal                 => "second",'.
                                              'type_of_argument        => "string or code reference",'.
                                              'type                    => "Str|CodeRef"',
              ) . ';',
          '}',
      );
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . 'ref $_[1] '
                   . '? $val =~ s/$_[0]/$_[1]->()/e '
                   . ': $val =~ s/$_[0]/$_[1]/; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return (
          'ref $_[1]',
              '? ' . $slot_access . ' =~ s/$_[0]/$_[1]->()/e',
              ': ' . $slot_access . ' =~ s/$_[0]/$_[1]/;',
       );
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/String/substr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR';
  package Moose::Meta::Method::Accessor::Native::String::substr;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::substr::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::String::substr::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              'if (@_ == 1 || @_ == 2) {',
                  $self->_inline_reader_core($inv, $slot_access),
              '}',
              'elsif (@_ == 3) {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
              'else {',
                  $self->_inline_check_argument_count,
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 3 }
  
  sub _inline_process_arguments {
      my $self = shift;
      my ($inv, $slot_access) = @_;
  
      return (
          'my $offset = shift;',
          'my $length = @_ ? shift : length ' . $slot_access . ';',
          'my $replacement = shift;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      my ($for_writer) = @_;
  
      my @code = (
          'if ($offset !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $offset,'.
                                              'ordinal                 => "first",'.
                                              'type_of_argument        => "integer",'.
                                              'method_name             => "substr",'.
                                              'type                    => "Int"',
              ) . ';',
          '}',
          'if ($length !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                              'argument                => $length,'.
                                              'ordinal                 => "second",'.
                                              'type_of_argument        => "integer",'.
                                              'method_name             => "substr",'.
                                              'type                    => "Int"',
              ) . ';',
          '}',
      );
  
      if ($for_writer) {
          push @code, (
              'if (!Moose::Util::_STRINGLIKE0($replacement)) {',
                  $self->_inline_throw_exception( "InvalidArgumentToMethod => ".
                                                  'argument                => $replacement,'.
                                                  'ordinal                 => "third",'.
                                                  'type_of_argument        => "string",'.
                                                  'method_name             => "substr",'.
                                                  'type                    => "Str"',
                  ) . ';',
              '}',
          );
      }
  
      return @code;
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $potential = ' . $slot_access . '; '
               . '@return = substr $potential, $offset, $length, $replacement; '
               . '$potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = substr ' . $slot_access . ', '
                             . '$offset, $length, $replacement;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access, $for_writer) = @_;
  
      return '$return[0]' if $for_writer;
  
      return 'substr ' . $slot_access . ', $offset, $length';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Accessor/Native/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER';
  package Moose::Meta::Method::Accessor::Native::Writer;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Writer::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Accessor::Native::Writer::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::MoreUtils qw( any );
  use Moose::Util;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native';
  
  requires '_potential_value';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_writer_core($inv, $slot_access),
          '}',
      );
  }
  
  sub _inline_writer_core {
      my $self = shift;
      my ($inv, $slot_access) = @_;
  
      my $potential = $self->_potential_value($slot_access);
      my $old       = '@old';
  
      my @code;
      push @code, (
          $self->_inline_check_argument_count,
          $self->_inline_process_arguments($inv, $slot_access),
          $self->_inline_check_arguments('for writer'),
          $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
      );
  
      if ($self->_return_value($slot_access)) {
          # some writers will save the return value in this variable when they
          # generate the potential value.
          push @code, 'my @return;'
      }
  
      push @code, (
          $self->_inline_coerce_new_values,
          $self->_inline_copy_native_value(\$potential),
          $self->_inline_tc_code($potential, '$type_constraint', '$type_coercion', '$type_message'),
          $self->_inline_get_old_value_for_trigger($inv, $old),
          $self->_inline_capture_return_value($slot_access),
          $self->_inline_set_new_value($inv, $potential, $slot_access),
          $self->_inline_trigger($inv, $slot_access, $old),
          $self->_inline_return_value($slot_access, 'for writer'),
      );
  
      return @code;
  }
  
  sub _inline_process_arguments { return }
  
  sub _inline_check_arguments { return }
  
  sub _inline_coerce_new_values { return }
  
  sub _writer_value_needs_copy {
      my $self = shift;
  
      return $self->_constraint_must_be_checked;
  }
  
  sub _constraint_must_be_checked {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      return $attr->has_type_constraint
          && ( !$self->_is_root_type( $attr->type_constraint )
          || ( $attr->should_coerce && $attr->type_constraint->has_coercion ) );
  }
  
  sub _is_root_type {
      my $self = shift;
      my $type = shift;
  
      if (
          Moose::Util::does_role( $type, 'Specio::Constraint::Role::Interface' ) )
      {
          require Specio::Library::Builtins;
          return
              any { $type->is_same_type_as( Specio::Library::Builtins::t($_) ) }
          @{ $self->root_types };
      }
      else {
          my $name = $type->name;
          return any { $name eq $_ } @{ $self->root_types };
      }
  }
  
  sub _inline_copy_native_value {
      my $self = shift;
      my ($potential_ref) = @_;
  
      return unless $self->_writer_value_needs_copy;
  
      my $code = 'my $potential = ' . ${$potential_ref} . ';';
  
      ${$potential_ref} = '$potential';
  
      return $code;
  }
  
  around _inline_tc_code => sub {
      my $orig = shift;
      my $self = shift;
      my ($value, $tc, $coercion, $message, $for_lazy) = @_;
  
      return unless $for_lazy || $self->_constraint_must_be_checked;
  
      return $self->$orig(@_);
  };
  
  around _inline_check_constraint => sub {
      my $orig = shift;
      my $self = shift;
      my ($value, $tc, $message, $for_lazy) = @_;
  
      return unless $for_lazy || $self->_constraint_must_be_checked;
  
      return $self->$orig(@_);
  };
  
  sub _inline_capture_return_value { return }
  
  sub _inline_set_new_value {
      my $self = shift;
  
      return $self->_inline_store_value(@_)
          if $self->_writer_value_needs_copy
          || !$self->_slot_access_can_be_inlined
          || !$self->_get_is_lvalue;
  
      return $self->_inline_optimized_set_new_value(@_);
  }
  
  sub _get_is_lvalue {
      my $self = shift;
  
      return $self->associated_attribute->associated_class->instance_metaclass->inline_get_is_lvalue;
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
  
      return $self->_inline_store_value(@_);
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access;
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Augmented.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_AUGMENTED';
  package Moose::Meta::Method::Augmented;
  BEGIN {
    $Moose::Meta::Method::Augmented::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Augmented::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my ( $class, %args ) = @_;
  
      # the package can be overridden by roles
      # it is really more like body's compilation stash
      # this is where we need to override the definition of super() so that the
      # body of the code can call the right overridden version
      my $name = $args{name};
      my $meta = $args{class};
  
      my $super = $meta->find_next_method_by_name($name);
  
      (defined $super)
          || throw_exception( CannotAugmentNoSuperMethod => params      => \%args,
                                                            class       => $class,
                                                            method_name => $name
                            );
  
      my $_super_package = $super->package_name;
      # BUT!,... if this is an overridden method ....
      if ($super->isa('Moose::Meta::Method::Overridden')) {
          # we need to be sure that we actually
          # find the next method, which is not
          # an 'override' method, the reason is
          # that an 'override' method will not
          # be the one calling inner()
          my $real_super = $meta->_find_next_method_by_name_which_is_not_overridden($name);
          $_super_package = $real_super->package_name;
      }
  
      my $super_body = $super->body;
  
      my $method = $args{method};
  
      my $body = sub {
          local $Moose::INNER_ARGS{$_super_package} = [ @_ ];
          local $Moose::INNER_BODY{$_super_package} = $method;
          $super_body->(@_);
      };
  
      # FIXME store additional attrs
      $class->wrap(
          $body,
          package_name => $meta->name,
          name         => $name
      );
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for augmented methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Augmented - A Moose Method metaclass for augmented methods
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class implements method augmentation logic for the L<Moose>
  C<augment> keyword.
  
  The augmentation subroutine reference will be invoked explicitly using
  the C<inner> keyword from the parent class's method definition.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Augmented> is a subclass of L<Moose::Meta::Method>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Method::Augmented->new(%options) >>
  
  This constructs a new object. It accepts the following options:
  
  =over 8
  
  =item * class
  
  The metaclass object for the class in which the augmentation is being
  declared. This option is required.
  
  =item * name
  
  The name of the method which we are augmenting. This method must exist
  in one of the class's superclasses. This option is required.
  
  =item * method
  
  The subroutine reference which implements the augmentation. This
  option is required.
  
  =back
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_AUGMENTED

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_CONSTRUCTOR';
  
  package Moose::Meta::Method::Constructor;
  BEGIN {
    $Moose::Meta::Method::Constructor::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Constructor::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Carp ();
  use List::MoreUtils 'any';
  use Scalar::Util 'blessed', 'weaken', 'looks_like_number', 'refaddr';
  use Try::Tiny;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Constructor';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      my $meta = $options{metaclass};
  
      (ref $options{options} eq 'HASH')
          || throw_exception( MustPassAHashOfOptions => params => \%options,
                                                        class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = bless {
          'body'          => undef,
          'package_name'  => $options{package_name},
          'name'          => $options{name},
          'options'       => $options{options},
          'associated_metaclass' => $meta,
          'definition_context' => $options{definition_context},
          '_expected_method_class' => $options{_expected_method_class} || 'Moose::Object',
      } => $class;
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  ## method
  
  sub _initialize_body {
      my $self = shift;
      $self->{'body'} = $self->_generate_constructor_method_inline;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for constructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Constructor - Method Meta Object for constructors
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Constructor> that
  provides additional Moose-specific functionality
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Constructor> documentation as well.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Constructor> is a subclass of
  L<Moose::Meta::Method> I<and> L<Class::MOP::Method::Constructor>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_CONSTRUCTOR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Delegation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_DELEGATION';
  
  package Moose::Meta::Method::Delegation;
  BEGIN {
    $Moose::Meta::Method::Delegation::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Delegation::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Generated';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      ( exists $options{attribute} )
          || throw_exception( MustSupplyAnAttributeToConstructWith => params => \%options,
                                                                      class  => $class
                            );
  
      ( blessed( $options{attribute} )
              && $options{attribute}->isa('Moose::Meta::Attribute') )
          || throw_exception( MustSupplyAMooseMetaAttributeInstance => params => \%options,
                                                                       class  => $class
                            );
  
      ( $options{package_name} && $options{name} )
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      ( $options{delegate_to_method} && ( !ref $options{delegate_to_method} )
              || ( 'CODE' eq ref $options{delegate_to_method} ) )
          || throw_exception( MustSupplyADelegateToMethod => params => \%options,
                                                             class  => $class
                            );
  
      exists $options{curried_arguments}
          || ( $options{curried_arguments} = [] );
  
      ( $options{curried_arguments} &&
          ( 'ARRAY' eq ref $options{curried_arguments} ) )
          || throw_exception( MustSupplyArrayRefAsCurriedArguments => params     => \%options,
                                                                      class_name => $class
                            );
  
      my $self = $class->_new( \%options );
  
      weaken( $self->{'attribute'} );
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless $options, $class;
  }
  
  sub curried_arguments { (shift)->{'curried_arguments'} }
  
  sub associated_attribute { (shift)->{'attribute'} }
  
  sub delegate_to_method { (shift)->{'delegate_to_method'} }
  
  sub _initialize_body {
      my $self = shift;
  
      my $method_to_call = $self->delegate_to_method;
      return $self->{body} = $method_to_call
          if ref $method_to_call;
  
      my $accessor = $self->_get_delegate_accessor;
  
      my $handle_name = $self->name;
  
      # NOTE: we used to do a goto here, but the goto didn't handle
      # failure correctly (it just returned nothing), so I took that
      # out. However, the more I thought about it, the less I liked it
      # doing the goto, and I preferred the act of delegation being
      # actually represented in the stack trace.  - SL
      # not inlining this, since it won't really speed things up at
      # all... the only thing that would end up different would be
      # interpolating in $method_to_call, and a bunch of things in the
      # error handling that mostly never gets called - doy
      $self->{body} = sub {
          my $instance = shift;
          my $proxy    = $instance->$accessor();
  
          if( !defined $proxy ) {
              throw_exception( AttributeValueIsNotDefined => method     => $self,
                                                             instance   => $instance,
                                                             attribute  => $self->associated_attribute,
                             );
          }
          elsif( ref($proxy) && !blessed($proxy) ) {
              throw_exception( AttributeValueIsNotAnObject => method      => $self,
                                                              instance    => $instance,
                                                              attribute   => $self->associated_attribute,
                                                              given_value => $proxy
                             );
          }
  
          unshift @_, @{ $self->curried_arguments };
          $proxy->$method_to_call(@_);
      };
  }
  
  sub _get_delegate_accessor {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      # NOTE:
      # always use a named method when
      # possible, if you use the method
      # ref and there are modifiers on
      # the accessors then it will not
      # pick up the modifiers too. Only
      # the named method will assure that
      # we also have any modifiers run.
      # - SL
      my $accessor = $attr->has_read_method
          ? $attr->get_read_method
          : $attr->get_read_method_ref;
  
      $accessor = $accessor->body if Scalar::Util::blessed $accessor;
  
      return $accessor;
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for delegation methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Delegation - A Moose Method metaclass for delegation methods
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Moose::Meta::Method> for delegation
  methods.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Method::Delegation->new(%options) >>
  
  This creates the delegation methods based on the provided C<%options>.
  
  =over 4
  
  =item I<attribute>
  
  This must be an instance of C<Moose::Meta::Attribute> which this
  accessor is being generated for. This options is B<required>.
  
  =item I<delegate_to_method>
  
  The method in the associated attribute's value to which we
  delegate. This can be either a method name or a code reference.
  
  =item I<curried_arguments>
  
  An array reference of arguments that will be prepended to the argument list for
  any call to the delegating method.
  
  =back
  
  =item B<< $metamethod->associated_attribute >>
  
  Returns the attribute associated with this method.
  
  =item B<< $metamethod->curried_arguments >>
  
  Return any curried arguments that will be passed to the delegated method.
  
  =item B<< $metamethod->delegate_to_method >>
  
  Returns the method to which this method delegates, as passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_DELEGATION

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Destructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_DESTRUCTOR';
  
  package Moose::Meta::Method::Destructor;
  BEGIN {
    $Moose::Meta::Method::Destructor::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Destructor::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Devel::GlobalDestruction ();
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Inlined';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (ref $options{options} eq 'HASH')
          || throw_exception( MustPassAHashOfOptions => params => \%options,
                                                        class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = bless {
          # from our superclass
          'body'                 => undef,
          'package_name'         => $options{package_name},
          'name'                 => $options{name},
          # ...
          'options'              => $options{options},
          'definition_context'   => $options{definition_context},
          'associated_metaclass' => $options{metaclass},
      } => $class;
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  ## accessors
  
  sub options              { (shift)->{'options'}              }
  
  ## method
  
  sub is_needed {
      my $self      = shift;
      my $metaclass = shift;
  
      ( blessed $metaclass && $metaclass->isa('Class::MOP::Class') )
          || throw_exception( MethodExpectedAMetaclassObject => metaclass => $metaclass,
                                                                class     => $self
                            );
  
      return $metaclass->find_method_by_name("DEMOLISHALL");
  }
  
  sub _initialize_body {
      my $self = shift;
      # TODO:
      # the %options should also include a both
      # a call 'initializer' and call 'SUPER::'
      # options, which should cover approx 90%
      # of the possible use cases (even if it
      # requires some adaption on the part of
      # the author, after all, nothing is free)
  
      my $class = $self->associated_metaclass->name;
      my @source = (
          'sub {',
              'my $self = shift;',
              'return ' . $self->_generate_fallback_destructor('$self'),
                  'if Scalar::Util::blessed($self) ne \'' . $class . '\';',
              $self->_generate_DEMOLISHALL('$self'),
              'return;',
          '}',
      );
      warn join("\n", @source) if $self->options->{debug};
  
      my $code = try {
          $self->_compile_code(source => \@source);
      }
      catch {
          my $source = join("\n", @source);
          throw_exception( CouldNotEvalDestructor => method_destructor_object => $self,
                                                     source                   => $source,
                                                     error                    => $_
                         );
      };
  
      $self->{'body'} = $code;
  }
  
  sub _generate_fallback_destructor {
      my $self = shift;
      my ($inv) = @_;
  
      return $inv . '->Moose::Object::DESTROY(@_)';
  }
  
  sub _generate_DEMOLISHALL {
      my $self = shift;
      my ($inv) = @_;
  
      my @methods = $self->associated_metaclass->find_all_methods_by_name('DEMOLISH');
      return unless @methods;
  
      return (
          'local $?;',
          'my $igd = Devel::GlobalDestruction::in_global_destruction;',
          'Try::Tiny::try {',
              (map { $inv . '->' . $_->{class} . '::DEMOLISH($igd);' } @methods),
          '}',
          'Try::Tiny::catch {',
              'die $_;',
          '};',
      );
  }
  
  
  1;
  
  # ABSTRACT: Method Meta Object for destructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Destructor - Method Meta Object for destructors
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Inlined> that
  provides Moose-specific functionality for inlining destructors.
  
  To understand this class, you should read the
  L<Class::MOP::Method::Inlined> documentation as well.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Destructor> is a subclass of
  L<Moose::Meta::Method> I<and> L<Class::MOP::Method::Inlined>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Method::Destructor->new(%options) >>
  
  This constructs a new object. It accepts the following options:
  
  =over 8
  
  =item * package_name
  
  The package for the class in which the destructor is being
  inlined. This option is required.
  
  =item * name
  
  The name of the destructor method. This option is required.
  
  =item * metaclass
  
  The metaclass for the class this destructor belongs to. This is
  optional, as it can be set later by calling C<<
  $metamethod->attach_to_class >>.
  
  =back
  
  =item B<< Moose::Meta;:Method::Destructor->is_needed($metaclass) >>
  
  Given a L<Moose::Meta::Class> object, this method returns a boolean
  indicating whether the class needs a destructor. If the class or any
  of its parents defines a C<DEMOLISH> method, it needs a destructor.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_DESTRUCTOR

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_META';
  
  package Moose::Meta::Method::Meta;
  BEGIN {
    $Moose::Meta::Method::Meta::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Meta::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Meta';
  
  sub _is_caller_mop_internal {
      my $self = shift;
      my ($caller) = @_;
      return 1 if $caller =~ /^Moose(?:::|$)/;
      return $self->SUPER::_is_caller_mop_internal($caller);
  }
  
  # XXX: ugh multiple inheritance
  sub wrap {
      my $class = shift;
      return $class->Class::MOP::Method::Meta::wrap(@_);
  }
  
  sub _make_compatible_with {
      my $self = shift;
      return $self->Class::MOP::Method::Meta::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for C<meta> methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Meta - A Moose Method metaclass for C<meta> methods
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Meta> that
  provides additional Moose-specific functionality, all of which is
  private.
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Meta> documentation.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_META

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Method/Overridden.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_OVERRIDDEN';
  package Moose::Meta::Method::Overridden;
  BEGIN {
    $Moose::Meta::Method::Overridden::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Method::Overridden::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my ( $class, %args ) = @_;
  
      # the package can be overridden by roles
      # it is really more like body's compilation stash
      # this is where we need to override the definition of super() so that the
      # body of the code can call the right overridden version
      my $super_package = $args{package} || $args{class}->name;
  
      my $name = $args{name};
  
      my $super = $args{class}->find_next_method_by_name($name);
  
      (defined $super)
          || throw_exception( CannotOverrideNoSuperMethod => class       => $class,
                                                             params      => \%args,
                                                             method_name => $name
                            );
  
      my $super_body = $super->body;
  
      my $method = $args{method};
  
      my $body = sub {
          local $Moose::SUPER_PACKAGE = $super_package;
          local @Moose::SUPER_ARGS = @_;
          local $Moose::SUPER_BODY = $super_body;
          return $method->(@_);
      };
  
      # FIXME do we need this make sure this works for next::method?
      # subname "${super_package}::${name}", $method;
  
      # FIXME store additional attrs
      $class->wrap(
          $body,
          package_name => $args{class}->name,
          name         => $name
      );
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for overridden methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Overridden - A Moose Method metaclass for overridden methods
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class implements method overriding logic for the L<Moose>
  C<override> keyword.
  
  The overriding subroutine's parent will be invoked explicitly using
  the C<super> keyword from the parent class's method definition.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Method::Overridden->new(%options) >>
  
  This constructs a new object. It accepts the following options:
  
  =over 8
  
  =item * class
  
  The metaclass object for the class in which the override is being
  declared. This option is required.
  
  =item * name
  
  The name of the method which we are overriding. This method must exist
  in one of the class's superclasses. This option is required.
  
  =item * method
  
  The subroutine reference which implements the overriding. This option
  is required.
  
  =back
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_METHOD_OVERRIDDEN

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Mixin/AttributeCore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_MIXIN_ATTRIBUTECORE';
  package Moose::Meta::Mixin::AttributeCore;
  BEGIN {
    $Moose::Meta::Mixin::AttributeCore::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Mixin::AttributeCore::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use parent 'Class::MOP::Mixin::AttributeCore';
  
  __PACKAGE__->meta->add_attribute(
      'isa' => (
          reader => '_isa_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'does' => (
          reader => '_does_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'is' => (
          reader => '_is_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'required' => (
          reader => 'is_required',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'lazy' => (
          reader => 'is_lazy', Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'lazy_build' => (
          reader => 'is_lazy_build',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'coerce' => (
          reader => 'should_coerce',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'weak_ref' => (
          reader => 'is_weak_ref',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'auto_deref' => (
          reader => 'should_auto_deref',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'type_constraint' => (
          reader    => 'type_constraint',
          predicate => 'has_type_constraint',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'trigger' => (
          reader    => 'trigger',
          predicate => 'has_trigger',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'handles' => (
          reader    => 'handles',
          writer    => '_set_handles',
          predicate => 'has_handles',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'documentation' => (
          reader    => 'documentation',
          predicate => 'has_documentation',
          Class::MOP::_definition_context(),
      )
  );
  
  1;
  
  # ABSTRACT: Core attributes shared by attribute metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Mixin::AttributeCore - Core attributes shared by attribute metaclasses
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class implements the core attributes (aka properties) shared by all Moose
  attributes. See the L<Moose::Meta::Attribute> documentation for API details.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_MIXIN_ATTRIBUTECORE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Object/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_OBJECT_TRAIT';
  
  package Moose::Meta::Object::Trait;
  BEGIN {
    $Moose::Meta::Object::Trait::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Object::Trait::VERSION = '2.1204';
  use Scalar::Util qw(blessed);
  
  sub _get_compatible_metaclass {
      my $orig = shift;
      my $self = shift;
      return $self->$orig(@_)
          || $self->_get_compatible_metaclass_by_role_reconciliation(@_);
  }
  
  sub _get_compatible_metaclass_by_role_reconciliation {
      my $self = shift;
      my ($other_name) = @_;
      my $meta_name = blessed($self) ? $self->_real_ref_name : $self;
  
      return unless Moose::Util::_classes_differ_by_roles_only(
          $meta_name, $other_name
      );
  
      return Moose::Util::_reconcile_roles_for_metaclass(
          $meta_name, $other_name
      );
  }
  
  1;
  
  # ABSTRACT: Some overrides for L<Class::MOP::Object> functionality
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Object::Trait - Some overrides for L<Class::MOP::Object> functionality
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This module is entirely private, you shouldn't ever need to interact with
  it directly.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_OBJECT_TRAIT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE';
  package Moose::Meta::Role;
  BEGIN {
    $Moose::Meta::Role::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use Devel::GlobalDestruction 'in_global_destruction';
  
  use Moose::Meta::Class;
  use Moose::Meta::Role::Attribute;
  use Moose::Meta::Role::Method;
  use Moose::Meta::Role::Method::Required;
  use Moose::Meta::Role::Method::Conflicting;
  use Moose::Meta::Method::Meta;
  use Moose::Util qw/throw_exception/;
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Module',
           'Class::MOP::Mixin::HasAttributes',
           'Class::MOP::Mixin::HasMethods';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  ## ------------------------------------------------------------------
  ## NOTE:
  ## I normally don't do this, but I am doing
  ## a whole bunch of meta-programmin' in this
  ## module, so it just makes sense. For a clearer
  ## picture of what is going on in the next
  ## several lines of code, look at the really
  ## big comment at the end of this file (right
  ## before the POD).
  ## - SL
  ## ------------------------------------------------------------------
  
  my $META = __PACKAGE__->meta;
  
  ## ------------------------------------------------------------------
  ## attributes ...
  
  # NOTE:
  # since roles are lazy, we hold all the attributes
  # of the individual role in 'stasis' until which
  # time when it is applied to a class. This means
  # keeping a lot of things in hash maps, so we are
  # using a little of that meta-programmin' magic
  # here and saving lots of extra typin'. And since
  # many of these attributes above require similar
  # functionality to support them, so we again use
  # the wonders of meta-programmin' to deliver a
  # very compact solution to this normally verbose
  # problem.
  # - SL
  
  foreach my $action (
      {
          name        => 'excluded_roles_map',
          attr_reader => 'get_excluded_roles_map' ,
          methods     => {
              add       => 'add_excluded_roles',
              get_keys  => 'get_excluded_roles_list',
              existence => 'excludes_role',
          }
      },
      {
          name        => 'required_methods',
          attr_reader => 'get_required_methods_map',
          methods     => {
              remove     => 'remove_required_methods',
              get_values => 'get_required_method_list',
              existence  => 'requires_method',
          }
      },
  ) {
  
      my $attr_reader = $action->{attr_reader};
      my $methods     = $action->{methods};
  
      # create the attribute
      $META->add_attribute($action->{name} => (
          reader  => $attr_reader,
          default => sub { {} },
          Class::MOP::_definition_context(),
      ));
  
      # create some helper methods
      $META->add_method($methods->{add} => sub {
          my ($self, @values) = @_;
          $self->$attr_reader->{$_} = undef foreach @values;
      }) if exists $methods->{add};
  
      $META->add_method($methods->{get_keys} => sub {
          my ($self) = @_;
          keys %{$self->$attr_reader};
      }) if exists $methods->{get_keys};
  
      $META->add_method($methods->{get_values} => sub {
          my ($self) = @_;
          values %{$self->$attr_reader};
      }) if exists $methods->{get_values};
  
      $META->add_method($methods->{get} => sub {
          my ($self, $name) = @_;
          $self->$attr_reader->{$name}
      }) if exists $methods->{get};
  
      $META->add_method($methods->{existence} => sub {
          my ($self, $name) = @_;
          exists $self->$attr_reader->{$name} ? 1 : 0;
      }) if exists $methods->{existence};
  
      $META->add_method($methods->{remove} => sub {
          my ($self, @values) = @_;
          delete $self->$attr_reader->{$_} foreach @values;
      }) if exists $methods->{remove};
  }
  
  $META->add_attribute(
      'method_metaclass',
      reader  => 'method_metaclass',
      default => 'Moose::Meta::Role::Method',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'required_method_metaclass',
      reader  => 'required_method_metaclass',
      default => 'Moose::Meta::Role::Method::Required',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'conflicting_method_metaclass',
      reader  => 'conflicting_method_metaclass',
      default => 'Moose::Meta::Role::Method::Conflicting',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_class_class',
      reader  => 'application_to_class_class',
      default => 'Moose::Meta::Role::Application::ToClass',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_role_class',
      reader  => 'application_to_role_class',
      default => 'Moose::Meta::Role::Application::ToRole',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_instance_class',
      reader  => 'application_to_instance_class',
      default => 'Moose::Meta::Role::Application::ToInstance',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'applied_attribute_metaclass',
      reader  => 'applied_attribute_metaclass',
      default => 'Moose::Meta::Attribute',
      Class::MOP::_definition_context(),
  );
  
  # More or less copied from Moose::Meta::Class
  sub initialize {
      my $class = shift;
      my @args = @_;
      unshift @args, 'package' if @args % 2;
      my %opts = @args;
      my $package = delete $opts{package};
      return Class::MOP::get_metaclass_by_name($package)
          || $class->SUPER::initialize($package,
                  'attribute_metaclass' => 'Moose::Meta::Role::Attribute',
                  %opts,
              );
  }
  
  sub reinitialize {
      my $self = shift;
      my $pkg  = shift;
  
      my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
  
      my %existing_classes;
      if ($meta) {
          %existing_classes = map { $_ => $meta->$_() } qw(
              attribute_metaclass
              method_metaclass
              wrapped_method_metaclass
              required_method_metaclass
              conflicting_method_metaclass
              application_to_class_class
              application_to_role_class
              application_to_instance_class
              applied_attribute_metaclass
          );
      }
  
      my %options = @_;
      $options{weaken} = Class::MOP::metaclass_is_weak($meta->name)
          if !exists $options{weaken}
          && blessed($meta)
          && $meta->isa('Moose::Meta::Role');
  
      # don't need to remove generated metaobjects here yet, since we don't
      # yet generate anything in roles. this may change in the future though...
      # keep an eye on that
      my $new_meta = $self->SUPER::reinitialize(
          $pkg,
          %existing_classes,
          %options,
      );
      $new_meta->_restore_metaobjects_from($meta)
          if $meta && $meta->isa('Moose::Meta::Role');
      return $new_meta;
  }
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->_restore_metamethods_from($old_meta);
      $self->_restore_metaattributes_from($old_meta);
  
      for my $role ( @{ $old_meta->get_roles } ) {
          $self->add_role($role);
      }
  }
  
  sub add_attribute {
      my $self = shift;
  
      if (blessed $_[0] && ! $_[0]->isa('Moose::Meta::Role::Attribute') ) {
          my $class = ref $_[0];
          throw_exception( CannotAddAsAnAttributeToARole => role            => $self,
                                                            attribute_class => $class
                         );
      }
      elsif (!blessed($_[0]) && defined($_[0]) && $_[0] =~ /^\+(.*)/) {
          throw_exception( AttributeExtensionIsNotSupportedInRoles => attribute_name => $_[0],
                                                                      role           => $self
                         );
      }
  
      return $self->SUPER::add_attribute(@_);
  }
  
  sub _attach_attribute {
      my ( $self, $attribute ) = @_;
  
      $attribute->attach_to_role($self);
  }
  
  sub add_required_methods {
      my $self = shift;
  
      for (@_) {
          my $method = $_;
          if (!blessed($method)) {
              $method = $self->required_method_metaclass->new(
                  name => $method,
              );
          }
          $self->get_required_methods_map->{$method->name} = $method;
      }
  }
  
  sub add_conflicting_method {
      my $self = shift;
  
      my $method;
      if (@_ == 1 && blessed($_[0])) {
          $method = shift;
      }
      else {
          $method = $self->conflicting_method_metaclass->new(@_);
      }
  
      $self->add_required_methods($method);
  }
  
  ## ------------------------------------------------------------------
  ## method modifiers
  
  # NOTE:
  # the before/around/after method modifiers are
  # stored by name, but there can be many methods
  # then associated with that name. So again we have
  # lots of similar functionality, so we can do some
  # meta-programmin' and save some time.
  # - SL
  
  foreach my $modifier_type (qw[ before around after ]) {
  
      my $attr_reader = "get_${modifier_type}_method_modifiers_map";
  
      # create the attribute ...
      $META->add_attribute("${modifier_type}_method_modifiers" => (
          reader  => $attr_reader,
          default => sub { {} },
          Class::MOP::_definition_context(),
      ));
  
      # and some helper methods ...
      $META->add_method("get_${modifier_type}_method_modifiers" => sub {
          my ($self, $method_name) = @_;
          #return () unless exists $self->$attr_reader->{$method_name};
          my $mm = $self->$attr_reader->{$method_name};
          $mm ? @$mm : ();
      });
  
      $META->add_method("has_${modifier_type}_method_modifiers" => sub {
          my ($self, $method_name) = @_;
          # NOTE:
          # for now we assume that if it exists,..
          # it has at least one modifier in it
          (exists $self->$attr_reader->{$method_name}) ? 1 : 0;
      });
  
      $META->add_method("add_${modifier_type}_method_modifier" => sub {
          my ($self, $method_name, $method) = @_;
  
          $self->$attr_reader->{$method_name} = []
              unless exists $self->$attr_reader->{$method_name};
  
          my $modifiers = $self->$attr_reader->{$method_name};
  
          # NOTE:
          # check to see that we aren't adding the
          # same code twice. We err in favor of the
          # first on here, this may not be as expected
          foreach my $modifier (@{$modifiers}) {
              return if $modifier == $method;
          }
  
          push @{$modifiers} => $method;
      });
  
  }
  
  ## ------------------------------------------------------------------
  ## override method modifiers
  
  $META->add_attribute('override_method_modifiers' => (
      reader  => 'get_override_method_modifiers_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  # NOTE:
  # these are a little different because there
  # can only be one per name, whereas the other
  # method modifiers can have multiples.
  # - SL
  
  sub add_override_method_modifier {
      my ($self, $method_name, $method) = @_;
      (!$self->has_method($method_name))
          || throw_exception( CannotOverrideALocalMethod => method_name => $method_name,
                                                            role        => $self
                            );
      $self->get_override_method_modifiers_map->{$method_name} = $method;
  }
  
  sub has_override_method_modifier {
      my ($self, $method_name) = @_;
      # NOTE:
      # for now we assume that if it exists,..
      # it has at least one modifier in it
      (exists $self->get_override_method_modifiers_map->{$method_name}) ? 1 : 0;
  }
  
  sub get_override_method_modifier {
      my ($self, $method_name) = @_;
      $self->get_override_method_modifiers_map->{$method_name};
  }
  
  ## general list accessor ...
  
  sub get_method_modifier_list {
      my ($self, $modifier_type) = @_;
      my $accessor = "get_${modifier_type}_method_modifiers_map";
      keys %{$self->$accessor};
  }
  
  sub _meta_method_class { 'Moose::Meta::Method::Meta' }
  
  ## ------------------------------------------------------------------
  ## subroles
  
  $META->add_attribute('roles' => (
      reader  => 'get_roles',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  sub add_role {
      my ($self, $role) = @_;
      (blessed($role) && $role->isa('Moose::Meta::Role'))
          || throw_exception( AddRoleToARoleTakesAMooseMetaRole => role_to_be_added => $role,
                                                                   role             => $self
                            );
      push @{$self->get_roles} => $role;
      $self->reset_package_cache_flag;
  }
  
  sub calculate_all_roles {
      my $self = shift;
      my %seen;
      grep {
          !$seen{$_->name}++
      } ($self, map {
                    $_->calculate_all_roles
                } @{ $self->get_roles });
  }
  
  sub does_role {
      my ($self, $role) = @_;
      (defined $role)
          || throw_exception( RoleNameRequiredForMooseMetaRole => role => $self );
      my $role_name = blessed $role ? $role->name : $role;
      # if we are it,.. then return true
      return 1 if $role_name eq $self->name;
      # otherwise.. check our children
      foreach my $role (@{$self->get_roles}) {
          return 1 if $role->does_role($role_name);
      }
      return 0;
  }
  
  sub find_method_by_name { (shift)->get_method(@_) }
  
  ## ------------------------------------------------------------------
  ## role construction
  ## ------------------------------------------------------------------
  
  sub apply {
      my ($self, $other, %args) = @_;
  
      (blessed($other))
          || throw_exception( ApplyTakesABlessedInstance => param => $other,
                                                            role  => $self
                            );
  
      my $application_class;
      if ($other->isa('Moose::Meta::Role')) {
          $application_class = $self->application_to_role_class;
      }
      elsif ($other->isa('Moose::Meta::Class')) {
          $application_class = $self->application_to_class_class;
      }
      else {
          $application_class = $self->application_to_instance_class;
      }
  
      Moose::Util::_load_user_class($application_class);
  
      if ( exists $args{'-excludes'} ) {
          # I wish we had coercion here :)
          $args{'-excludes'} = (
              ref $args{'-excludes'} eq 'ARRAY'
              ? $args{'-excludes'}
              : [ $args{'-excludes'} ]
          );
      }
  
      return $application_class->new(%args)->apply($self, $other, \%args);
  }
  
  sub composition_class_roles { }
  
  sub combine {
      my ($class, @role_specs) = @_;
  
      require Moose::Meta::Role::Composite;
  
      my (@roles, %role_params);
      while (@role_specs) {
          my ($role, $params) = @{ splice @role_specs, 0, 1 };
          my $requested_role
              = blessed $role
              ? $role
              : Class::MOP::class_of($role);
  
          my $actual_role = $requested_role->_role_for_combination($params);
          push @roles => $actual_role;
  
          next unless defined $params;
          $role_params{$actual_role->name} = $params;
      }
  
      my $c = Moose::Meta::Role::Composite->new(roles => \@roles);
      return $c->apply_params(\%role_params);
  }
  
  sub _role_for_combination {
      my ($self, $params) = @_;
      return $self;
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{attributes} eq 'HASH')
          || throw_exception( CreateTakesHashRefOfAttributes => params           => \%options,
                                                                attribute_class  => $class
                            )
              if exists $options{attributes};
  
      (ref $options{methods} eq 'HASH')
          || throw_exception( CreateTakesHashRefOfMethods => params           => \%options,
                                                             attribute_class  => $class
                            )
              if exists $options{methods};
  
      (ref $options{roles} eq 'ARRAY')
          || throw_exception( CreateTakesArrayRefOfRoles => params           => \%options,
                                                            attribute_class  => $class
                            )
              if exists $options{roles};
  
      my $package      = delete $options{package};
      my $roles        = delete $options{roles};
      my $attributes   = delete $options{attributes};
      my $methods      = delete $options{methods};
      my $meta_name    = exists $options{meta_name}
                           ? delete $options{meta_name}
                           : 'meta';
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  
      if (defined $attributes) {
          foreach my $attribute_name (keys %{$attributes}) {
              my $attr = $attributes->{$attribute_name};
              $meta->add_attribute(
                  $attribute_name => blessed $attr ? $attr : %{$attr} );
          }
      }
  
      if (defined $methods) {
          foreach my $method_name (keys %{$methods}) {
              $meta->add_method($method_name, $methods->{$method_name});
          }
      }
  
      if ($roles) {
          Moose::Util::apply_all_roles($meta, @$roles);
      }
  
      return $meta;
  }
  
  sub consumers {
      my $self = shift;
      my @consumers;
      for my $meta (Class::MOP::get_all_metaclass_instances) {
          next if $meta->name eq $self->name;
          next unless $meta->isa('Moose::Meta::Class')
                   || $meta->isa('Moose::Meta::Role');
          push @consumers, $meta->name
              if $meta->does_role($self->name);
      }
      return @consumers;
  }
  
  # XXX: something more intelligent here?
  sub _anon_package_prefix { 'Moose::Meta::Role::__ANON__::SERIAL::' }
  
  sub create_anon_role { shift->create_anon(@_) }
  sub is_anon_role     { shift->is_anon(@_)     }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
  
      # XXX fix this duplication (see MMC::_anon_cache_key
      my $roles = Data::OptList::mkopt(($options{roles} || []), {
          moniker  => 'role',
          val_test => sub { ref($_[0]) eq 'HASH' },
      });
  
      my @role_keys;
      for my $role_spec (@$roles) {
          my ($role, $params) = @$role_spec;
          $params = { %$params };
  
          my $key = blessed($role) ? $role->name : $role;
  
          if ($params && %$params) {
              my $alias    = delete $params->{'-alias'}
                          || delete $params->{'alias'}
                          || {};
              my $excludes = delete $params->{'-excludes'}
                          || delete $params->{'excludes'}
                          || [];
              $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
  
              if (%$params) {
                  warn "Roles with parameters cannot be cached. Consider "
                     . "applying the parameters before calling "
                     . "create_anon_class, or using 'weaken => 0' instead";
                  return;
              }
  
              my $alias_key = join('%',
                  map { $_ => $alias->{$_} } sort keys %$alias
              );
              my $excludes_key = join('%',
                  sort @$excludes
              );
              $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
          }
  
          push @role_keys, $key;
      }
  
      # Makes something like Role|Role::1
      return join('|', sort @role_keys);
  }
  
  #####################################################################
  ## NOTE:
  ## This is Moose::Meta::Role as defined by Moose (plus the use of
  ## MooseX::AttributeHelpers module). It is here as a reference to
  ## make it easier to see what is happening above with all the meta
  ## programming. - SL
  #####################################################################
  #
  # has 'roles' => (
  #     metaclass => 'Array',
  #     reader    => 'get_roles',
  #     isa       => 'ArrayRef[Moose::Meta::Role]',
  #     default   => sub { [] },
  #     provides  => {
  #         'push' => 'add_role',
  #     }
  # );
  #
  # has 'excluded_roles_map' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_excluded_roles_map',
  #     isa       => 'HashRef[Str]',
  #     provides  => {
  #         # Not exactly set, cause it sets multiple
  #         'set'    => 'add_excluded_roles',
  #         'keys'   => 'get_excluded_roles_list',
  #         'exists' => 'excludes_role',
  #     }
  # );
  #
  # has 'required_methods' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_required_methods_map',
  #     isa       => 'HashRef[Moose::Meta::Role::Method::Required]',
  #     provides  => {
  #         # not exactly set, or delete since it works for multiple
  #         'set'    => 'add_required_methods',
  #         'delete' => 'remove_required_methods',
  #         'keys'   => 'get_required_method_list',
  #         'exists' => 'requires_method',
  #     }
  # );
  #
  # # the before, around and after modifiers are
  # # HASH keyed by method-name, with ARRAY of
  # # CODE refs to apply in that order
  #
  # has 'before_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_before_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_before_method_modifiers',
  #         'exists' => 'has_before_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_before_method_modifier'
  #     }
  # );
  #
  # has 'after_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_after_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_after_method_modifiers',
  #         'exists' => 'has_after_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_after_method_modifier'
  #     }
  # );
  #
  # has 'around_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_around_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_around_method_modifiers',
  #         'exists' => 'has_around_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_around_method_modifier'
  #     }
  # );
  #
  # # override is similar to the other modifiers
  # # except that it is not an ARRAY of code refs
  # # but instead just a single name->code mapping
  #
  # has 'override_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_override_method_modifiers_map',
  #     isa       => 'HashRef[CodeRef]',
  #     provides  => {
  #         'keys'   => 'get_override_method_modifier',
  #         'exists' => 'has_override_method_modifier',
  #         'add'    => 'add_override_method_modifier', # checks for local method ..
  #     }
  # );
  #
  #####################################################################
  
  
  1;
  
  # ABSTRACT: The Moose Role metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role - The Moose Role metaclass
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Module> that provides
  additional Moose-specific functionality.
  
  Its API looks a lot like L<Moose::Meta::Class>, but internally it
  implements many things differently. This may change in the future.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role> is a subclass of L<Class::MOP::Module>.
  
  =head1 METHODS
  
  =head2 Construction
  
  =over 4
  
  =item B<< Moose::Meta::Role->initialize($role_name) >>
  
  This method creates a new role object with the provided name.
  
  =item B<< Moose::Meta::Role->combine( [ $role => { ... } ], [ $role ], ... ) >>
  
  This method accepts a list of array references. Each array reference
  should contain a role name or L<Moose::Meta::Role> object as its first element. The second element is
  an optional hash reference. The hash reference can contain C<-excludes>
  and C<-alias> keys to control how methods are composed from the role.
  
  The return value is a new L<Moose::Meta::Role::Composite> that
  represents the combined roles.
  
  =item B<< $metarole->composition_class_roles >>
  
  When combining multiple roles using C<combine>, this method is used to obtain a
  list of role names to be applied to the L<Moose::Meta::Role::Composite>
  instance returned by C<combine>. The default implementation returns an empty
  list. Extensions that need to hook into role combination may wrap this method
  to return additional role names.
  
  =item B<< Moose::Meta::Role->create($name, %options) >>
  
  This method is identical to the L<Moose::Meta::Class> C<create>
  method.
  
  =item B<< Moose::Meta::Role->create_anon_role >>
  
  This method is identical to the L<Moose::Meta::Class>
  C<create_anon_class> method.
  
  =item B<< $metarole->is_anon_role >>
  
  Returns true if the role is an anonymous role.
  
  =item B<< $metarole->consumers >>
  
  Returns a list of names of classes and roles which consume this role.
  
  =back
  
  =head2 Role application
  
  =over 4
  
  =item B<< $metarole->apply( $thing, @options ) >>
  
  This method applies a role to the given C<$thing>. That can be another
  L<Moose::Meta::Role>, object, a L<Moose::Meta::Class> object, or a
  (non-meta) object instance.
  
  The options are passed directly to the constructor for the appropriate
  L<Moose::Meta::Role::Application> subclass.
  
  Note that this will apply the role even if the C<$thing> in question already
  C<does> this role.  L<Moose::Util/does_role> is a convenient wrapper for
  finding out if role application is necessary.
  
  =back
  
  =head2 Roles and other roles
  
  =over 4
  
  =item B<< $metarole->get_roles >>
  
  This returns an array reference of roles which this role does. This
  list may include duplicates.
  
  =item B<< $metarole->calculate_all_roles >>
  
  This returns a I<unique> list of all roles that this role does, and
  all the roles that its roles do.
  
  =item B<< $metarole->does_role($role) >>
  
  Given a role I<name> or L<Moose::Meta::Role> object, returns true if this role
  does the given role.
  
  =item B<< $metarole->add_role($role) >>
  
  Given a L<Moose::Meta::Role> object, this adds the role to the list of
  roles that the role does.
  
  =item B<< $metarole->get_excluded_roles_list >>
  
  Returns a list of role names which this role excludes.
  
  =item B<< $metarole->excludes_role($role_name) >>
  
  Given a role I<name>, returns true if this role excludes the named
  role.
  
  =item B<< $metarole->add_excluded_roles(@role_names) >>
  
  Given one or more role names, adds those roles to the list of excluded
  roles.
  
  =back
  
  =head2 Methods
  
  The methods for dealing with a role's methods are all identical in API
  and behavior to the same methods in L<Class::MOP::Class>.
  
  =over 4
  
  =item B<< $metarole->method_metaclass >>
  
  Returns the method metaclass name for the role. This defaults to
  L<Moose::Meta::Role::Method>.
  
  =item B<< $metarole->get_method($name) >>
  
  =item B<< $metarole->has_method($name) >>
  
  =item B<< $metarole->add_method( $name, $body ) >>
  
  =item B<< $metarole->get_method_list >>
  
  =item B<< $metarole->find_method_by_name($name) >>
  
  These methods are all identical to the methods of the same name in
  L<Class::MOP::Package>
  
  =back
  
  =head2 Attributes
  
  As with methods, the methods for dealing with a role's attribute are
  all identical in API and behavior to the same methods in
  L<Class::MOP::Class>.
  
  However, attributes stored in this class are I<not> stored as
  objects. Rather, the attribute definition is stored as a hash
  reference. When a role is composed into a class, this hash reference
  is passed directly to the metaclass's C<add_attribute> method.
  
  This is quite likely to change in the future.
  
  =over 4
  
  =item B<< $metarole->get_attribute($attribute_name) >>
  
  =item B<< $metarole->has_attribute($attribute_name) >>
  
  =item B<< $metarole->get_attribute_list >>
  
  =item B<< $metarole->add_attribute($name, %options) >>
  
  =item B<< $metarole->remove_attribute($attribute_name) >>
  
  =back
  
  =head2 Overload introspection and creation
  
  The methods for dealing with a role's overloads are all identical in API
  and behavior to the same methods in L<Class::MOP::Class>. Note that these are
  not particularly useful (yet), because overloads do not participate in role
  composition.
  
  =over 4
  
  =item B<< $metarole->is_overloaded >>
  
  =item B<< $metarole->get_overloaded_operator($op) >>
  
  =item B<< $metarole->has_overloaded_operator($op) >>
  
  =item B<< $metarole->get_overload_list >>
  
  =item B<< $metarole->get_all_overloaded_operators >>
  
  =item B<< $metarole->add_overloaded_operator($op, $impl) >>
  
  =item B<< $metarole->remove_overloaded_operator($op) >>
  
  =back
  
  =head2 Required methods
  
  =over 4
  
  =item B<< $metarole->get_required_method_list >>
  
  Returns the list of methods required by the role.
  
  =item B<< $metarole->requires_method($name) >>
  
  Returns true if the role requires the named method.
  
  =item B<< $metarole->add_required_methods(@names) >>
  
  Adds the named methods to the role's list of required methods.
  
  =item B<< $metarole->remove_required_methods(@names) >>
  
  Removes the named methods from the role's list of required methods.
  
  =item B<< $metarole->add_conflicting_method(%params) >>
  
  Instantiate the parameters as a L<Moose::Meta::Role::Method::Conflicting>
  object, then add it to the required method list.
  
  =back
  
  =head2 Method modifiers
  
  These methods act like their counterparts in L<Class::MOP::Class> and
  L<Moose::Meta::Class>.
  
  However, method modifiers are simply stored internally, and are not
  applied until the role itself is applied to a class.
  
  =over 4
  
  =item B<< $metarole->add_after_method_modifier($method_name, $method) >>
  
  =item B<< $metarole->add_around_method_modifier($method_name, $method) >>
  
  =item B<< $metarole->add_before_method_modifier($method_name, $method) >>
  
  =item B<< $metarole->add_override_method_modifier($method_name, $method) >>
  
  These methods all add an appropriate modifier to the internal list of
  modifiers.
  
  =item B<< $metarole->has_after_method_modifiers >>
  
  =item B<< $metarole->has_around_method_modifiers >>
  
  =item B<< $metarole->has_before_method_modifiers >>
  
  =item B<< $metarole->has_override_method_modifier >>
  
  Return true if the role has any modifiers of the given type.
  
  =item B<< $metarole->get_after_method_modifiers($method_name) >>
  
  =item B<< $metarole->get_around_method_modifiers($method_name) >>
  
  =item B<< $metarole->get_before_method_modifiers($method_name) >>
  
  Given a method name, returns a list of the appropriate modifiers for
  that method.
  
  =item B<< $metarole->get_override_method_modifier($method_name) >>
  
  Given a method name, returns the override method modifier for that
  method, if it has one.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Moose::Meta::Role->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Application.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION';
  package Moose::Meta::Role::Application;
  BEGIN {
    $Moose::Meta::Role::Application::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Application::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('method_exclusions' => (
      init_arg => '-excludes',
      reader   => 'get_method_exclusions',
      default  => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('method_aliases' => (
      init_arg => '-alias',
      reader   => 'get_method_aliases',
      default  => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my ($class, %params) = @_;
      $class->_new(\%params);
  }
  
  sub is_method_excluded {
      my ($self, $method_name) = @_;
      foreach (@{$self->get_method_exclusions}) {
          return 1 if $_ eq $method_name;
      }
      return 0;
  }
  
  sub is_method_aliased {
      my ($self, $method_name) = @_;
      exists $self->get_method_aliases->{$method_name} ? 1 : 0
  }
  
  sub is_aliased_method {
      my ($self, $method_name) = @_;
      my %aliased_names = reverse %{$self->get_method_aliases};
      exists $aliased_names{$method_name} ? 1 : 0;
  }
  
  sub apply {
      my $self = shift;
  
      $self->check_role_exclusions(@_);
      $self->check_required_methods(@_);
      $self->check_required_attributes(@_);
  
      $self->apply_attributes(@_);
      $self->apply_methods(@_);
  
      $self->apply_override_method_modifiers(@_);
  
      $self->apply_before_method_modifiers(@_);
      $self->apply_around_method_modifiers(@_);
      $self->apply_after_method_modifiers(@_);
  }
  
  sub check_role_exclusions           { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub check_required_methods          { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub check_required_attributes       { throw_exception( "CannotCallAnAbstractMethod" ); }
  
  sub apply_attributes                { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_methods                   { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_override_method_modifiers { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_method_modifiers          { throw_exception( "CannotCallAnAbstractMethod" ); }
  
  sub apply_before_method_modifiers   { (shift)->apply_method_modifiers('before' => @_) }
  sub apply_around_method_modifiers   { (shift)->apply_method_modifiers('around' => @_) }
  sub apply_after_method_modifiers    { (shift)->apply_method_modifiers('after'  => @_) }
  
  1;
  
  # ABSTRACT: A base class for role application
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application - A base class for role application
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is the abstract base class for role applications.
  
  The API for this class and its subclasses still needs some
  consideration, and is intentionally not yet documented.
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<get_method_exclusions>
  
  =item B<is_method_excluded>
  
  =item B<get_method_aliases>
  
  =item B<is_aliased_method>
  
  =item B<is_method_aliased>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_before_method_modifiers>
  
  =item B<apply_after_method_modifiers>
  
  =item B<apply_around_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Application/RoleSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION';
  package Moose::Meta::Role::Application::RoleSummation;
  BEGIN {
    $Moose::Meta::Role::Application::RoleSummation::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Application::RoleSummation::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Role::Composite;
  
  use parent 'Moose::Meta::Role::Application';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('role_params' => (
      reader  => 'role_params',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub get_exclusions_for_role {
      my ($self, $role) = @_;
      $role = $role->name if blessed $role;
      my $excludes_key = exists $self->role_params->{$role}->{'-excludes'} ?
                             '-excludes' : 'excludes';
      if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$excludes_key}) {
          if (ref $self->role_params->{$role}->{$excludes_key} eq 'ARRAY') {
              return $self->role_params->{$role}->{$excludes_key};
          }
          return [ $self->role_params->{$role}->{$excludes_key} ];
      }
      return [];
  }
  
  sub get_method_aliases_for_role {
      my ($self, $role) = @_;
      $role = $role->name if blessed $role;
      my $alias_key = exists $self->role_params->{$role}->{'-alias'} ?
                          '-alias' : 'alias';
      if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$alias_key}) {
          return $self->role_params->{$role}->{$alias_key};
      }
      return {};
  }
  
  sub is_method_excluded {
      my ($self, $role, $method_name) = @_;
      foreach ($self->get_exclusions_for_role($role->name)) {
          return 1 if $_ eq $method_name;
      }
      return 0;
  }
  
  sub is_method_aliased {
      my ($self, $role, $method_name) = @_;
      exists $self->get_method_aliases_for_role($role->name)->{$method_name} ? 1 : 0
  }
  
  sub is_aliased_method {
      my ($self, $role, $method_name) = @_;
      my %aliased_names = reverse %{$self->get_method_aliases_for_role($role->name)};
      exists $aliased_names{$method_name} ? 1 : 0;
  }
  
  sub check_role_exclusions {
      my ($self, $c) = @_;
  
      my %excluded_roles;
      for my $role (@{ $c->get_roles }) {
          my $name = $role->name;
  
          for my $excluded ($role->get_excluded_roles_list) {
              push @{ $excluded_roles{$excluded} }, $name;
          }
      }
  
      foreach my $role (@{$c->get_roles}) {
          foreach my $excluded (keys %excluded_roles) {
              next unless $role->does_role($excluded);
  
              my @excluding = @{ $excluded_roles{$excluded} };
  
              throw_exception( RoleExclusionConflict => roles     => \@excluding,
                                                        role_name => $excluded
                             );
          }
      }
  
      $c->add_excluded_roles(keys %excluded_roles);
  }
  
  sub check_required_methods {
      my ($self, $c) = @_;
  
      my %all_required_methods =
          map { $_->name => $_ }
          map { $_->get_required_method_list }
          @{$c->get_roles};
  
      foreach my $role (@{$c->get_roles}) {
          foreach my $required (keys %all_required_methods) {
  
              delete $all_required_methods{$required}
                  if $role->has_method($required)
                  || $self->is_aliased_method($role, $required);
          }
      }
  
      $c->add_required_methods(values %all_required_methods);
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $c) = @_;
  
      my @all_attributes;
  
      for my $role ( @{ $c->get_roles } ) {
          push @all_attributes,
              map { $role->get_attribute($_) } $role->get_attribute_list;
      }
  
      my %seen;
      foreach my $attr (@all_attributes) {
          my $name = $attr->name;
  
          if ( exists $seen{$name} ) {
              next if $seen{$name}->is_same_as($attr);
  
              my $role1 = $seen{$name}->associated_role->name;
              my $role2 = $attr->associated_role->name;
  
              throw_exception( AttributeConflictInSummation => attribute_name => $name,
                                                               role_name      => $role1,
                                                               second_role    => Class::MOP::class_of($role2)
                             );
          }
  
          $seen{$name} = $attr;
      }
  
      foreach my $attr (@all_attributes) {
          $c->add_attribute( $attr->clone );
      }
  }
  
  sub apply_methods {
      my ($self, $c) = @_;
  
      my @all_methods = map {
          my $role     = $_;
          my $aliases  = $self->get_method_aliases_for_role($role);
          my %excludes = map { $_ => undef } @{ $self->get_exclusions_for_role($role) };
          (
              (map {
                  exists $excludes{$_} ? () :
                  +{
                      role   => $role,
                      name   => $_,
                      method => $role->get_method($_),
                  }
              } map { $_->name }
                grep { !$_->isa('Class::MOP::Method::Meta') }
                     $role->_get_local_methods),
              (map {
                  +{
                      role   => $role,
                      name   => $aliases->{$_},
                      method => $role->get_method($_),
                  }
              } keys %$aliases)
          );
      } @{$c->get_roles};
  
      my (%seen, %conflicts, %method_map);
      foreach my $method (@all_methods) {
          next if $conflicts{$method->{name}};
          my $seen = $seen{$method->{name}};
  
          if ($seen) {
              if ($seen->{method}->body != $method->{method}->body) {
                  $c->add_conflicting_method(
                      name  => $method->{name},
                      roles => [$method->{role}->name, $seen->{role}->name],
                  );
  
                  delete $method_map{$method->{name}};
                  $conflicts{$method->{name}} = 1;
                  next;
              }
          }
  
          $seen{$method->{name}}       = $method;
          $method_map{$method->{name}} = $method->{method};
      }
  
      $c->add_method($_ => $method_map{$_}) for keys %method_map;
  }
  
  sub apply_override_method_modifiers {
      my ($self, $c) = @_;
  
      my @all_overrides = map {
          my $role = $_;
          map {
              +{
                  name   => $_,
                  method => $role->get_override_method_modifier($_),
              }
          } $role->get_method_modifier_list('override');
      } @{$c->get_roles};
  
      my %seen;
      foreach my $override (@all_overrides) {
          if ( $c->has_method($override->{name}) ){
              throw_exception( OverrideConflictInSummation => roles            => $c->get_roles,
                                                              role_application => $self,
                                                              method_name      => $override->{name}
                             );
          }
          if (exists $seen{$override->{name}}) {
              if ( $seen{$override->{name}} != $override->{method} ) {
                  throw_exception( OverrideConflictInSummation => roles               => $c->get_roles,
                                                                  role_application    => $self,
                                                                  method_name         => $override->{name},
                                                                  two_overrides_found => 1
                                 );
              }
          }
          $seen{$override->{name}} = $override->{method};
      }
  
      $c->add_override_method_modifier(
          $_->{name}, $_->{method}
      ) for @all_overrides;
  
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $c) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $role (@{$c->get_roles}) {
          foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
              $c->$add(
                  $method_name,
                  $_
              ) foreach $role->$get($method_name);
          }
      }
  }
  
  1;
  
  # ABSTRACT: Combine two or more roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::RoleSummation - Combine two or more roles
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  Summation composes two traits, forming the union of non-conflicting
  bindings and 'disabling' the conflicting bindings
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<role_params>
  
  =item B<get_exclusions_for_role>
  
  =item B<get_method_aliases_for_role>
  
  =item B<is_aliased_method>
  
  =item B<is_method_aliased>
  
  =item B<is_method_excluded>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Application/ToClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOCLASS';
  package Moose::Meta::Role::Application::ToClass;
  BEGIN {
    $Moose::Meta::Role::Application::ToClass::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Application::ToClass::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use List::MoreUtils 'firstval';
  use Moose::Util  'english_list';
  use Scalar::Util 'weaken', 'blessed';
  
  use parent 'Moose::Meta::Role::Application';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('role' => (
      reader => 'role',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('class' => (
      accessor => 'class',
      Class::MOP::_definition_context(),
  ));
  
  sub apply {
      my ($self, $role, $class) = @_;
  
      # We need weak_ref in CMOP :(
      weaken($self->{role}  = $role);
      weaken($self->{class} = $class);
  
      $self->SUPER::apply($role, $class);
  
      $class->add_role($role);
      $class->add_role_application($self);
  }
  
  sub check_role_exclusions {
      my ($self, $role, $class) = @_;
      if ($class->excludes_role($role->name)) {
          throw_exception( ConflictDetectedInCheckRoleExclusionsInToClass => class => $class,
                                                                             role  => $role
                         );
      }
      foreach my $excluded_role_name ($role->get_excluded_roles_list) {
          if ($class->does_role($excluded_role_name)) {
              throw_exception( ClassDoesTheExcludedRole => role          => $role,
                                                           excluded_role => Class::MOP::class_of($excluded_role_name),
                                                           class         => $class
                             );
          }
      }
  }
  
  sub check_required_methods {
      my ($self, $role, $class) = @_;
  
      my @missing;
      my @is_attr;
  
      # NOTE:
      # we might need to move this down below the
      # the attributes so that we can require any
      # attribute accessors. However I am thinking
      # that maybe those are somehow exempt from
      # the require methods stuff.
      foreach my $required_method ($role->get_required_method_list) {
          my $required_method_name = $required_method->name;
  
          if (!$class->find_method_by_name($required_method_name)) {
  
              next if $self->is_aliased_method($required_method_name);
  
              push @missing, $required_method;
          }
      }
  
      return unless @missing;
  
      my $error = '';
  
      @missing = sort { $a->name cmp $b->name } @missing;
      my @conflicts = grep { $_->isa('Moose::Meta::Role::Method::Conflicting') } @missing;
  
      if (@conflicts) {
          my $conflict = $conflicts[0];
          my $roles = $conflict->roles_as_english_list;
  
          my @same_role_conflicts = grep { $_->roles_as_english_list eq $roles } @conflicts;
  
          throw_exception( MethodNameConflictInRoles => conflict => \@same_role_conflicts,
                                                        class    => $class
                         );
      }
      elsif (@missing) {
          if (my $meth = firstval { $class->name->can($_) } @missing) {
              throw_exception( RequiredMethodsImportedByClass => class           => $class,
                                                                 role            => $role,
                                                                 missing_methods => \@missing,
                                                                 imported_method => $meth
                             );
          }
          else {
              throw_exception( RequiredMethodsNotImplementedByClass => class           => $class,
                                                                       role            => $role,
                                                                       missing_methods => \@missing,
                             );
          }
      }
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $role, $class) = @_;
  
      foreach my $attribute_name ($role->get_attribute_list) {
          # it if it has one already
          if ($class->has_attribute($attribute_name) &&
              # make sure we haven't seen this one already too
              $class->get_attribute($attribute_name) != $role->get_attribute($attribute_name)) {
              next;
          }
          else {
              $class->add_attribute(
                  $role->get_attribute($attribute_name)->attribute_for_class
              );
          }
      }
  }
  
  sub apply_methods {
      my ( $self, $role, $class ) = @_;
  
      foreach my $method ( $role->_get_local_methods ) {
          my $method_name = $method->name;
  
          next if $method->isa('Class::MOP::Method::Meta');
  
          unless ( $self->is_method_excluded($method_name) ) {
  
              my $class_method = $class->get_method($method_name);
  
              next if $class_method && $class_method->body != $method->body;
  
              $class->add_method(
                  $method_name,
                  $method,
              );
          }
  
          next unless $self->is_method_aliased($method_name);
  
          my $aliased_method_name = $self->get_method_aliases->{$method_name};
  
          my $class_method = $class->get_method($aliased_method_name);
  
          if ( $class_method && $class_method->body != $method->body ) {
              throw_exception( CannotCreateMethodAliasLocalMethodIsPresentInClass => aliased_method_name => $aliased_method_name,
                                                                                     method              => $method,
                                                                                     role                => $role,
                                                                                     class               => $class
                             );
          }
  
          $class->add_method(
              $aliased_method_name,
              $method,
          );
      }
  
      # we must reset the cache here since
      # we are just aliasing methods, otherwise
      # the modifiers go wonky.
      $class->reset_package_cache_flag;
  }
  
  sub apply_override_method_modifiers {
      my ($self, $role, $class) = @_;
      foreach my $method_name ($role->get_method_modifier_list('override')) {
          # it if it has one already then ...
          if ($class->has_method($method_name)) {
              next;
          }
          else {
              # if this is not a role, then we need to
              # find the original package of the method
              # so that we can tell the class were to
              # find the right super() method
              my $method = $role->get_override_method_modifier($method_name);
              my ($package) = Class::MOP::get_code_info($method);
              # if it is a class, we just add it
              $class->add_override_method_modifier($method_name, $method, $package);
          }
      }
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $role, $class) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
          $class->$add(
              $method_name,
              $_
          ) foreach $role->$get($method_name);
      }
  }
  
  1;
  
  # ABSTRACT: Compose a role into a class
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToClass - Compose a role into a class
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOCLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Application/ToInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOINSTANCE';
  package Moose::Meta::Role::Application::ToInstance;
  BEGIN {
    $Moose::Meta::Role::Application::ToInstance::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Application::ToInstance::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use List::MoreUtils 'all';
  
  use parent 'Moose::Meta::Role::Application';
  
  __PACKAGE__->meta->add_attribute('rebless_params' => (
      reader  => 'rebless_params',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub apply {
      my ( $self, $role, $object, $args ) = @_;
  
      my $obj_meta = Class::MOP::class_of($object) || 'Moose::Meta::Class';
  
      # This is a special case to handle the case where the object's metaclass
      # is a Class::MOP::Class, but _not_ a Moose::Meta::Class (for example,
      # when applying a role to a Moose::Meta::Attribute object).
      $obj_meta = 'Moose::Meta::Class'
          unless $obj_meta->isa('Moose::Meta::Class');
  
      my $class = $obj_meta->create_anon_class(
          superclasses => [ blessed($object) ],
          roles => [ $role, keys(%$args) ? ($args) : () ],
          cache => (all { $_ eq '-alias' || $_ eq '-excludes' } keys %$args),
      );
  
      $class->rebless_instance( $object, %{ $self->rebless_params } );
  }
  
  1;
  
  # ABSTRACT: Compose a role into an instance
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToInstance - Compose a role into an instance
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<rebless_params>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOINSTANCE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Application/ToRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOROLE';
  package Moose::Meta::Role::Application::ToRole;
  BEGIN {
    $Moose::Meta::Role::Application::ToRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Application::ToRole::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util    'blessed';
  
  use parent 'Moose::Meta::Role::Application';
  
  use Moose::Util 'throw_exception';
  
  sub apply {
      my ($self, $role1, $role2) = @_;
      $self->SUPER::apply($role1, $role2);
      $role2->add_role($role1);
  }
  
  sub check_role_exclusions {
      my ($self, $role1, $role2) = @_;
      if ( $role2->excludes_role($role1->name) ) {
          throw_exception( ConflictDetectedInCheckRoleExclusions => role          => $role2,
                                                                    excluded_role => $role1
                         );
      }
      foreach my $excluded_role_name ($role1->get_excluded_roles_list) {
          if ( $role2->does_role($excluded_role_name) ) {
              throw_exception( RoleDoesTheExcludedRole => role          => $role2,
                                                          excluded_role => Class::MOP::class_of($excluded_role_name),
                                                          second_role   => $role1
                             );
          }
          $role2->add_excluded_roles($excluded_role_name);
      }
  }
  
  sub check_required_methods {
      my ($self, $role1, $role2) = @_;
      foreach my $required_method ($role1->get_required_method_list) {
          my $required_method_name = $required_method->name;
  
          next if $self->is_aliased_method($required_method_name);
  
          $role2->add_required_methods($required_method)
              unless $role2->find_method_by_name($required_method_name);
      }
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $role1, $role2) = @_;
      foreach my $attribute_name ($role1->get_attribute_list) {
          # it if it has one already
          if ($role2->has_attribute($attribute_name) &&
              # make sure we haven't seen this one already too
              $role2->get_attribute($attribute_name) != $role1->get_attribute($attribute_name)) {
  
              my $role2_name = $role2->name;
  
              throw_exception( AttributeConflictInRoles => role           => $role1,
                                                           second_role    => $role2,
                                                           attribute_name => $attribute_name
                             );
          }
          else {
              $role2->add_attribute(
                  $role1->get_attribute($attribute_name)->clone
              );
          }
      }
  }
  
  sub apply_methods {
      my ( $self, $role1, $role2 ) = @_;
      foreach my $method ( $role1->_get_local_methods ) {
  
          my $method_name = $method->name;
  
          next if $method->isa('Class::MOP::Method::Meta');
  
          unless ( $self->is_method_excluded($method_name) ) {
  
              my $role2_method = $role2->get_method($method_name);
              if (   $role2_method
                  && $role2_method->body != $method->body ) {
  
                  # method conflicts between roles used to result in the method
                  # becoming a requirement but now are permitted just like
                  # for classes, hence no code in this branch anymore.
              }
              else {
                  $role2->add_method(
                      $method_name,
                      $method,
                  );
              }
          }
  
          next unless $self->is_method_aliased($method_name);
  
          my $aliased_method_name = $self->get_method_aliases->{$method_name};
  
          my $role2_method = $role2->get_method($aliased_method_name);
  
          if (   $role2_method
              && $role2_method->body != $method->body ) {
  
              throw_exception( CannotCreateMethodAliasLocalMethodIsPresent => aliased_method_name => $aliased_method_name,
                                                                              method              => $method,
                                                                              role                => $role2,
                                                                              role_being_applied  => $role1
                             );
          }
  
          $role2->add_method(
              $aliased_method_name,
              $role1->get_method($method_name)
          );
  
          if ( !$role2->has_method($method_name) ) {
              $role2->add_required_methods($method_name)
                  unless $self->is_method_excluded($method_name);
          }
      }
  }
  
  sub apply_override_method_modifiers {
      my ($self, $role1, $role2) = @_;
      foreach my $method_name ($role1->get_method_modifier_list('override')) {
          # it if it has one already then ...
          if ($role2->has_method($method_name)) {
              # if it is being composed into another role
              # we have a conflict here, because you cannot
              # combine an overridden method with a locally
              # defined one
              throw_exception( OverrideConflictInComposition => role               => $role2,
                                                                role_being_applied => $role1,
                                                                method_name        => $method_name
                             );
          }
          else {
              # if we are a role, we need to make sure
              # we don't have a conflict with the role
              # we are composing into
              if ($role2->has_override_method_modifier($method_name) &&
                  $role1->get_override_method_modifier($method_name) != $role2->get_override_method_modifier($method_name)) {
  
                  throw_exception( OverrideConflictInComposition => role                => $role2,
                                                                    role_being_applied  => $role1,
                                                                    method_name         => $method_name,
                                                                    two_overrides_found => 1
                                 );
              }
              else {
                  # if there is no conflict,
                  # just add it to the role
                  $role2->add_override_method_modifier(
                      $method_name,
                      $role1->get_override_method_modifier($method_name)
                  );
              }
          }
      }
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $role1, $role2) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $method_name ($role1->get_method_modifier_list($modifier_type)) {
          $role2->$add(
              $method_name,
              $_
          ) foreach $role1->$get($method_name);
      }
  }
  
  
  1;
  
  # ABSTRACT: Compose a role into another role
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToRole - Compose a role into another role
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_ATTRIBUTE';
  package Moose::Meta::Role::Attribute;
  BEGIN {
    $Moose::Meta::Role::Attribute::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Attribute::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use List::MoreUtils 'all';
  use Scalar::Util 'blessed', 'weaken';
  
  use parent 'Moose::Meta::Mixin::AttributeCore', 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute(
      'metaclass' => (
          reader => 'metaclass',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'associated_role' => (
          reader => 'associated_role',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      '_original_role' => (
          reader => '_original_role',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'is' => (
          reader => 'is',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'original_options' => (
          reader => 'original_options',
          Class::MOP::_definition_context(),
      )
  );
  
  sub new {
      my ( $class, $name, %options ) = @_;
  
      (defined $name)
          || throw_exception( MustProvideANameForTheAttribute => params => \%options,
                                                                 class  => $class
                            );
  
      my $role = delete $options{_original_role};
  
      return bless {
          name             => $name,
          original_options => \%options,
          _original_role   => $role,
          %options,
      }, $class;
  }
  
  sub attach_to_role {
      my ( $self, $role ) = @_;
  
      ( blessed($role) && $role->isa('Moose::Meta::Role') )
          || throw_exception( MustPassAMooseMetaRoleInstanceOrSubclass => class  => $self,
                                                                          role   => $role
                            );
  
      weaken( $self->{'associated_role'} = $role );
  }
  
  sub original_role {
      my $self = shift;
  
      return $self->_original_role || $self->associated_role;
  }
  
  sub attribute_for_class {
      my $self = shift;
  
      my $metaclass = $self->original_role->applied_attribute_metaclass;
  
      return $metaclass->interpolate_class_and_new(
          $self->name => %{ $self->original_options } );
  }
  
  sub clone {
      my $self = shift;
  
      my $role = $self->original_role;
  
      return ( ref $self )->new(
          $self->name,
          %{ $self->original_options },
          _original_role => $role,
      );
  }
  
  sub is_same_as {
      my $self = shift;
      my $attr = shift;
  
      my $self_options = $self->original_options;
      my $other_options = $attr->original_options;
  
      return 0
          unless ( join q{|}, sort keys %{$self_options} ) eq ( join q{|}, sort keys %{$other_options} );
  
      for my $key ( keys %{$self_options} ) {
          return 0 if defined $self_options->{$key} && ! defined $other_options->{$key};
          return 0 if ! defined $self_options->{$key} && defined $other_options->{$key};
  
          next if all { ! defined } $self_options->{$key}, $other_options->{$key};
  
          return 0 unless $self_options->{$key} eq $other_options->{$key};
      }
  
      return 1;
  }
  
  1;
  
  # ABSTRACT: The Moose attribute metaclass for Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Attribute - The Moose attribute metaclass for Roles
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class implements the API for attributes in roles. Attributes in roles are
  more like attribute prototypes than full blown attributes. While they are
  introspectable, they have very little behavior.
  
  =head1 METHODS
  
  This class provides the following methods:
  
  =over 4
  
  =item B<< Moose::Meta::Role::Attribute->new(...) >>
  
  This method accepts all the options that would be passed to the constructor
  for L<Moose::Meta::Attribute>.
  
  =item B<< $attr->metaclass >>
  
  =item B<< $attr->is >>
  
  Returns the option as passed to the constructor.
  
  =item B<< $attr->associated_role >>
  
  Returns the L<Moose::Meta::Role> to which this attribute belongs, if any.
  
  =item B<< $attr->original_role >>
  
  Returns the L<Moose::Meta::Role> in which this attribute was first
  defined. This may not be the same as the value of C<associated_role()> for
  attributes in a composite role, or when one role consumes other roles.
  
  =item B<< $attr->original_options >>
  
  Returns a hash reference of options passed to the constructor. This is used
  when creating a L<Moose::Meta::Attribute> object from this object.
  
  =item B<< $attr->attach_to_role($role) >>
  
  Attaches the attribute to the given L<Moose::Meta::Role>.
  
  =item B<< $attr->attribute_for_class($metaclass) >>
  
  Given an attribute metaclass name, this method calls C<<
  $metaclass->interpolate_class_and_new >> to construct an attribute object
  which can be added to a L<Moose::Meta::Class>.
  
  =item B<< $attr->clone >>
  
  Creates a new object identical to the object on which the method is called.
  
  =item B<< $attr->is_same_as($other_attr) >>
  
  Compares two role attributes and returns true if they are identical.
  
  =back
  
  In addition, this class implements all informational predicates implements by
  L<Moose::Meta::Attribute> (and L<Class::MOP::Attribute>).
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_ATTRIBUTE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Composite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_COMPOSITE';
  package Moose::Meta::Role::Composite;
  BEGIN {
    $Moose::Meta::Role::Composite::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Composite::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use Moose::Util;
  
  use parent 'Moose::Meta::Role';
  
  use Moose::Util 'throw_exception';
  
  # NOTE:
  # we need to override the ->name
  # method from Class::MOP::Package
  # since we don't have an actual
  # package for this.
  # - SL
  __PACKAGE__->meta->add_attribute('name' => (
      reader => 'name',
      Class::MOP::_definition_context(),
  ));
  
  # NOTE:
  # Again, since we don't have a real
  # package to store our methods in,
  # we use a HASH ref instead.
  # - SL
  __PACKAGE__->meta->add_attribute('_methods' => (
      reader  => '_method_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      'application_role_summation_class',
      reader  => 'application_role_summation_class',
      default => 'Moose::Meta::Role::Application::RoleSummation',
      Class::MOP::_definition_context(),
  );
  
  sub new {
      my ($class, %params) = @_;
  
      # the roles param is required ...
      foreach ( @{$params{roles}} ) {
          unless ( $_->isa('Moose::Meta::Role') ) {
              throw_exception( RolesListMustBeInstancesOfMooseMetaRole => params => \%params,
                                                                          role   => $_,
                                                                          class  => $class
                             );
          }
      }
  
      my @composition_roles = map {
          $_->composition_class_roles
      } @{ $params{roles} };
  
      if (@composition_roles) {
          my $meta = Moose::Meta::Class->create_anon_class(
              superclasses => [ $class ],
              roles        => [ @composition_roles ],
              cache        => 1,
          );
          $class = $meta->name;
      }
  
      # and the name is created from the
      # roles if one has not been provided
      $params{name} ||= (join "|" => map { $_->name } @{$params{roles}});
      $class->_new(\%params);
  }
  
  # This is largely a copy of what's in Moose::Meta::Role (itself
  # largely a copy of Class::MOP::Class). However, we can't actually
  # call add_package_symbol, because there's no package into which to
  # add the symbol.
  sub add_method {
      my ($self, $method_name, $method) = @_;
  
      unless ( defined $method_name && $method_name ) {
          throw_exception( MustDefineAMethodName => instance => $self );
      }
  
      my $body;
      if (blessed($method)) {
          $body = $method->body;
          if ($method->package_name ne $self->name) {
              $method = $method->clone(
                  package_name => $self->name,
                  name         => $method_name
              ) if $method->can('clone');
          }
      }
      else {
          $body = $method;
          $method = $self->wrap_method_body( body => $body, name => $method_name );
      }
  
      $self->_method_map->{$method_name} = $method;
  }
  
  sub get_method_list {
      my $self = shift;
      return keys %{ $self->_method_map };
  }
  
  sub _get_local_methods {
      my $self = shift;
      return values %{ $self->_method_map };
  }
  
  sub has_method {
      my ($self, $method_name) = @_;
  
      return exists $self->_method_map->{$method_name};
  }
  
  sub get_method {
      my ($self, $method_name) = @_;
  
      return $self->_method_map->{$method_name};
  }
  
  sub apply_params {
      my ($self, $role_params) = @_;
      Moose::Util::_load_user_class($self->application_role_summation_class);
  
      $self->application_role_summation_class->new(
          role_params => $role_params,
      )->apply($self);
  
      return $self;
  }
  
  sub reinitialize {
      my ( $class, $old_meta, @args ) = @_;
  
      throw_exception( CannotInitializeMooseMetaRoleComposite => old_meta       => $old_meta,
                                                                 args           => \@args,
                                                                 role_composite => $class
                     )
          if !blessed $old_meta
              || !$old_meta->isa('Moose::Meta::Role::Composite');
  
      my %existing_classes = map { $_ => $old_meta->$_() } qw(
          application_role_summation_class
      );
  
      return $old_meta->meta->clone_object( $old_meta, %existing_classes, @args );
  }
  
  1;
  
  # ABSTRACT: An object to represent the set of roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Composite - An object to represent the set of roles
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  A composite is a role that consists of a set of two or more roles.
  
  The API of a composite role is almost identical to that of a regular
  role.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Composite> is a subclass of L<Moose::Meta::Role>.
  
  =head2 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Role::Composite->new(%options) >>
  
  This returns a new composite role object. It accepts the same
  options as its parent class, with a few changes:
  
  =over 8
  
  =item * roles
  
  This option is an array reference containing a list of
  L<Moose::Meta::Role> object. This is a required option.
  
  =item * name
  
  If a name is not given, one is generated from the roles provided.
  
  =item * apply_params(\%role_params)
  
  Creates a new RoleSummation role application with C<%role_params> and applies
  the composite role to it. The RoleSummation role application class used is
  determined by the composite role's C<application_role_summation_class>
  attribute.
  
  =item * reinitialize($metaclass)
  
  Like C<< Class::MOP::Package->reinitialize >>, but doesn't allow passing a
  string with the package name, as there is no real package for composite roles.
  
  =back
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_COMPOSITE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_METHOD';
  
  package Moose::Meta::Role::Method;
  BEGIN {
    $Moose::Meta::Role::Method::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Method::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is blah blah blah
      # see the comments in CMOP::Method::Meta and CMOP::Method::Wrapped
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method - A Moose Method metaclass for Roles
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is primarily used to mark methods coming from a role
  as being different. Right now it is nothing but a subclass
  of L<Moose::Meta::Method>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_METHOD

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Method/Conflicting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_METHOD_CONFLICTING';
  
  package Moose::Meta::Role::Method::Conflicting;
  BEGIN {
    $Moose::Meta::Role::Method::Conflicting::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Method::Conflicting::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Util;
  
  use parent 'Moose::Meta::Role::Method::Required';
  
  __PACKAGE__->meta->add_attribute('roles' => (
      reader   => 'roles',
      required => 1,
      Class::MOP::_definition_context(),
  ));
  
  sub roles_as_english_list {
      my $self = shift;
      Moose::Util::english_list( map { q{'} . $_ . q{'} } @{ $self->roles } );
  }
  
  1;
  
  # ABSTRACT: A Moose metaclass for conflicting methods in Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method::Conflicting - A Moose metaclass for conflicting methods in Roles
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Method::Conflicting> is a subclass of
  L<Moose::Meta::Role::Method::Required>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Role::Method::Conflicting->new(%options) >>
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 8
  
  =item * name
  
  The method name. This is required.
  
  =item * roles
  
  The list of role names that generated the conflict. This is required.
  
  =back
  
  =item B<< $method->name >>
  
  Returns the conflicting method's name, as provided to the constructor.
  
  =item B<< $method->roles >>
  
  Returns the roles that generated this conflicting method, as provided to the
  constructor.
  
  =item B<< $method->roles_as_english_list >>
  
  Returns the roles that generated this conflicting method as an English list.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_METHOD_CONFLICTING

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/Role/Method/Required.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_METHOD_REQUIRED';
  
  package Moose::Meta::Role::Method::Required;
  BEGIN {
    $Moose::Meta::Role::Method::Required::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::Role::Method::Required::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use overload '""'     => sub { shift->name },   # stringify to method name
               fallback => 1;
  
  use parent 'Class::MOP::Object';
  
  # This is not a Moose::Meta::Role::Method because it has no implementation, it
  # is just a name
  
  __PACKAGE__->meta->add_attribute('name' => (
      reader   => 'name',
      required => 1,
      Class::MOP::_definition_context(),
  ));
  
  sub new { shift->_new(@_) }
  
  1;
  
  # ABSTRACT: A Moose metaclass for required methods in Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method::Required - A Moose metaclass for required methods in Roles
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Method::Required> is a subclass of L<Class::MOP::Object>.
  It is B<not> a subclass of C<Moose::Meta::Role::Method> since it does not
  provide an implementation of the method.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Role::Method::Required->new(%options) >>
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 8
  
  =item * name
  
  The method name. This is required.
  
  =back
  
  =item B<< $method->name >>
  
  Returns the required method's name, as provided to the constructor.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_ROLE_METHOD_REQUIRED

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeCoercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECOERCION';
  
  package Moose::Meta::TypeCoercion;
  BEGIN {
    $Moose::Meta::TypeCoercion::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeCoercion::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Meta::Attribute;
  use Moose::Util::TypeConstraints ();
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('type_coercion_map' => (
      reader  => 'type_coercion_map',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      Moose::Meta::Attribute->new('type_constraint' => (
          reader   => 'type_constraint',
          weak_ref => 1,
          Class::MOP::_definition_context(),
      ))
  );
  
  # private accessor
  __PACKAGE__->meta->add_attribute('compiled_type_coercion' => (
      accessor => '_compiled_type_coercion',
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my $self  = Class::MOP::class_of($class)->new_object(@_);
      $self->compile_type_coercion;
      return $self;
  }
  
  sub compile_type_coercion {
      my $self = shift;
      my @coercion_map = @{$self->type_coercion_map};
      my @coercions;
      while (@coercion_map) {
          my ($constraint_name, $action) = splice(@coercion_map, 0, 2);
          my $type_constraint = ref $constraint_name ? $constraint_name : Moose::Util::TypeConstraints::find_or_parse_type_constraint($constraint_name);
  
          unless ( defined $type_constraint ) {
              throw_exception( CouldNotFindTypeConstraintToCoerceFrom => constraint_name => $constraint_name,
                                                                         instance        => $self
                             );
          }
  
          push @coercions => [
              $type_constraint->_compiled_type_constraint,
              $action
          ];
      }
      $self->_compiled_type_coercion(sub {
          my $thing = shift;
          foreach my $coercion (@coercions) {
              my ($constraint, $converter) = @$coercion;
              if ($constraint->($thing)) {
                  local $_ = $thing;
                  return $converter->($thing);
              }
          }
          return $thing;
      });
  }
  
  sub has_coercion_for_type {
      my ($self, $type_name) = @_;
      my %coercion_map = @{$self->type_coercion_map};
      exists $coercion_map{$type_name} ? 1 : 0;
  }
  
  sub add_type_coercions {
      my ($self, @new_coercion_map) = @_;
  
      my $coercion_map = $self->type_coercion_map;
      my %has_coercion = @$coercion_map;
  
      while (@new_coercion_map) {
          my ($constraint_name, $action) = splice(@new_coercion_map, 0, 2);
  
          if ( exists $has_coercion{$constraint_name} ) {
              throw_exception( CoercionAlreadyExists => constraint_name => $constraint_name,
                                                        instance        => $self
                             );
          }
  
          push @{$coercion_map} => ($constraint_name, $action);
      }
  
      # and re-compile ...
      $self->compile_type_coercion;
  }
  
  sub coerce { $_[0]->_compiled_type_coercion->($_[1]) }
  
  
  1;
  
  # ABSTRACT: The Moose Type Coercion metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeCoercion - The Moose Type Coercion metaclass
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  A type coercion object is basically a mapping of one or more type
  constraints and the associated coercions subroutines.
  
  It's unlikely that you will need to instantiate an object of this
  class directly, as it's part of the deep internals of Moose.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeCoercion->new(%options) >>
  
  Creates a new type coercion object, based on the options provided.
  
  =over 8
  
  =item * type_constraint
  
  This is the L<Moose::Meta::TypeConstraint> object for the type that is
  being coerced I<to>.
  
  =back
  
  =item B<< $coercion->type_coercion_map >>
  
  This returns the map of type constraints to coercions as an array
  reference. The values of the array alternate between type names and
  subroutine references which implement the coercion.
  
  The value is an array reference because coercions are tried in the
  order they are added.
  
  =item B<< $coercion->type_constraint >>
  
  This returns the L<Moose::Meta::TypeConstraint> that was passed to the
  constructor.
  
  =item B<< $coercion->has_coercion_for_type($type_name) >>
  
  Returns true if the coercion can coerce the named type.
  
  =item B<< $coercion->add_type_coercions( $type_name => $sub, ... ) >>
  
  This method takes a list of type names and subroutine references. If
  the coercion already has a mapping for a given type, it throws an
  exception.
  
  Coercions are actually
  
  =item B<< $coercion->coerce($value) >>
  
  This method takes a value and applies the first valid coercion it
  finds.
  
  This means that if the value could belong to more than type in the
  coercion object, the first coercion added is used.
  
  =item B<< Moose::Meta::TypeCoercion->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECOERCION

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeCoercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECOERCION_UNION';
  
  package Moose::Meta::TypeCoercion::Union;
  BEGIN {
    $Moose::Meta::TypeCoercion::Union::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeCoercion::Union::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use parent 'Moose::Meta::TypeCoercion';
  
  use Moose::Util 'throw_exception';
  
  sub compile_type_coercion {
      my $self            = shift;
      my $type_constraint = $self->type_constraint;
  
      (blessed $type_constraint && $type_constraint->isa('Moose::Meta::TypeConstraint::Union'))
       || throw_exception( NeedsTypeConstraintUnionForTypeCoercionUnion => type_coercion_union_object => $self,
                                                                           type_name                  => $type_constraint
                         );
  
      $self->_compiled_type_coercion(
          sub {
              my $value = shift;
  
              foreach my $type ( grep { $_->has_coercion }
                  @{ $type_constraint->type_constraints } ) {
                  my $temp = $type->coerce($value);
                  return $temp if $type_constraint->check($temp);
              }
  
              return $value;
          }
      );
  }
  
  sub has_coercion_for_type { 0 }
  
  sub add_type_coercions {
      my $self = shift;
      throw_exception( CannotAddAdditionalTypeCoercionsToUnion => type_coercion_union_object => $self );
  }
  
  1;
  
  # ABSTRACT: The Moose Type Coercion metaclass for Unions
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeCoercion::Union - The Moose Type Coercion metaclass for Unions
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Moose::Meta::TypeCoercion> that is used for
  L<Moose::Meta::TypeConstraint::Union> objects.
  =head1 METHODS
  
  =over 4
  
  =item B<< $coercion->has_coercion_for_type >>
  
  This method always returns false.
  
  =item B<< $coercion->add_type_coercions >>
  
  This method always throws an error. You cannot add coercions to a
  union type coercion.
  
  =item B<< $coercion->coerce($value) >>
  
  This method will coerce by trying the coercions for each type in the
  union.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECOERCION_UNION

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT';
  
  package Moose::Meta::TypeConstraint;
  BEGIN {
    $Moose::Meta::TypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use overload '0+'     => sub { refaddr(shift) }, # id an object
               '""'     => sub { shift->name },   # stringify to tc name
               bool     => sub { 1 },
               fallback => 1;
  
  use Class::Load qw(load_class);
  use Eval::Closure;
  use Scalar::Util qw(blessed refaddr);
  use Sub::Name qw(subname);
  use Try::Tiny;
  
  use base 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('name'       => (
      reader => 'name',
      Class::MOP::_definition_context(),
  ));
  __PACKAGE__->meta->add_attribute('parent'     => (
      reader    => 'parent',
      predicate => 'has_parent',
      Class::MOP::_definition_context(),
  ));
  
  my $null_constraint = sub { 1 };
  __PACKAGE__->meta->add_attribute('constraint' => (
      reader  => 'constraint',
      writer  => '_set_constraint',
      default => sub { $null_constraint },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('message'   => (
      accessor  => 'message',
      predicate => 'has_message',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_default_message' => (
      accessor  => '_default_message',
      Class::MOP::_definition_context(),
  ));
  
  # can't make this a default because it has to close over the type name, and
  # cmop attributes don't have lazy
  my $_default_message_generator = sub {
      my $name = shift;
      sub {
          my $value = shift;
          # have to load it late like this, since it uses Moose itself
          my $can_partialdump = try {
              # versions prior to 0.14 had a potential infinite loop bug
              require Devel::PartialDump;
              Devel::PartialDump->VERSION(0.14);
              1;
          };
          if ($can_partialdump) {
              $value = Devel::PartialDump->new->dump($value);
          }
          else {
              $value = (defined $value ? overload::StrVal($value) : 'undef');
          }
          return "Validation failed for '" . $name . "' with value $value";
      }
  };
  __PACKAGE__->meta->add_attribute('coercion'   => (
      accessor  => 'coercion',
      predicate => 'has_coercion',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inlined' => (
      init_arg  => 'inlined',
      accessor  => 'inlined',
      predicate => '_has_inlined_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inline_environment' => (
      init_arg => 'inline_environment',
      accessor => '_inline_environment',
      default  => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub parents {
      my $self = shift;
      $self->parent;
  }
  
  # private accessors
  
  __PACKAGE__->meta->add_attribute('compiled_type_constraint' => (
      accessor  => '_compiled_type_constraint',
      predicate => '_has_compiled_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('package_defined_in' => (
      accessor => '_package_defined_in',
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my ($first, @rest) = @_;
      my %args = ref $first ? %$first : $first ? ($first, @rest) : ();
      $args{name} = $args{name} ? "$args{name}" : "__ANON__";
  
      if ( exists $args{message}
        && (!ref($args{message}) || ref($args{message}) ne 'CODE') ) {
          throw_exception( MessageParameterMustBeCodeRef => params => \%args,
                                                            class  => $class
                         );
      }
  
      my $self  = $class->_new(%args);
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
      $self->_default_message($_default_message_generator->($self->name))
          unless $self->has_message;
      return $self;
  }
  
  
  
  sub coerce {
      my $self = shift;
  
      my $coercion = $self->coercion;
  
      unless ($coercion) {
          throw_exception( CoercingWithoutCoercions => type => $self );
      }
  
      return $_[0] if $self->check($_[0]);
  
      return $coercion->coerce(@_);
  }
  
  sub assert_coerce {
      my $self = shift;
  
      my $result = $self->coerce(@_);
  
      $self->assert_valid($result);
  
      return $result;
  }
  
  sub check {
      my ($self, @args) = @_;
      my $constraint_subref = $self->_compiled_type_constraint;
      return $constraint_subref->(@args) ? 1 : undef;
  }
  
  sub validate {
      my ($self, $value) = @_;
      if ($self->_compiled_type_constraint->($value)) {
          return undef;
      }
      else {
          $self->get_message($value);
      }
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->can_be_inlined;
      }
  
      return $self->_has_inlined_type_constraint;
  }
  
  sub _inline_check {
      my $self = shift;
  
      unless ( $self->can_be_inlined ) {
          throw_exception( CannotInlineTypeConstraintCheck => type => $self );
      }
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->_inline_check(@_);
      }
  
      return '( do { ' . $self->inlined->( $self, @_ ) . ' } )';
  }
  
  sub inline_environment {
      my $self = shift;
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->inline_environment;
      }
  
      return $self->_inline_environment;
  }
  
  sub assert_valid {
      my ($self, $value) = @_;
  
      my $error = $self->validate($value);
      return 1 if ! defined $error;
  
      throw_exception( ValidationFailedForTypeConstraint => type          => $self,
                                                            error_message => $error,
                                                            value         => $value
                     );
  }
  
  sub get_message {
      my ($self, $value) = @_;
      my $msg = $self->has_message
          ? $self->message
          : $self->_default_message;
      local $_ = $value;
      return $msg->($value);
  }
  
  ## type predicates ...
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
  
      return 1 if $self == $other;
  
      return unless $self->constraint == $other->constraint;
  
      if ( $self->has_parent ) {
          return unless $other->has_parent;
          return unless $self->parent->equals( $other->parent );
      } else {
          return if $other->has_parent;
      }
  
      return;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
  
      ($self->equals($type) || $self->is_subtype_of($type));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
  
      my $current = $self;
  
      while (my $parent = $current->parent) {
          return 1 if $parent->equals($type);
          $current = $parent;
      }
  
      return 0;
  }
  
  ## compiling the type constraint
  
  sub compile_type_constraint {
      my $self = shift;
      $self->_compiled_type_constraint($self->_actually_compile_type_constraint);
  }
  
  ## type compilers ...
  
  sub _actually_compile_type_constraint {
      my $self = shift;
  
      if ( $self->can_be_inlined ) {
          return eval_closure(
              source      => 'sub { ' . $self->_inline_check('$_[0]') . ' }',
              environment => $self->inline_environment,
          );
      }
  
      my $check = $self->constraint;
      unless ( defined $check ) {
          throw_exception( NoConstraintCheckForTypeConstraint => type => $self );
      }
  
      return $self->_compile_subtype($check)
          if $self->has_parent;
  
      return $self->_compile_type($check);
  }
  
  sub _compile_subtype {
      my ($self, $check) = @_;
  
      # gather all the parent constraints in order
      my @parents;
      foreach my $parent ($self->_collect_all_parents) {
          push @parents => $parent->constraint;
      }
  
      @parents = grep { $_ != $null_constraint } reverse @parents;
  
      unless ( @parents ) {
          return $self->_compile_type($check);
      } else {
          # general case, check all the constraints, from the first parent to ourselves
          my @checks = @parents;
          push @checks, $check if $check != $null_constraint;
          return subname($self->name => sub {
              my (@args) = @_;
              local $_ = $args[0];
              foreach my $check (@checks) {
                  return undef unless $check->(@args);
              }
              return 1;
          });
      }
  }
  
  sub _compile_type {
      my ($self, $check) = @_;
  
      return $check if $check == $null_constraint; # Item, Any
  
      return subname($self->name => sub {
          my (@args) = @_;
          local $_ = $args[0];
          $check->(@args);
      });
  }
  
  ## other utils ...
  
  sub _collect_all_parents {
      my $self = shift;
      my @parents;
      my $current = $self->parent;
      while (defined $current) {
          push @parents => $current;
          $current = $current->parent;
      }
      return @parents;
  }
  
  sub create_child_type {
      my ($self, %opts) = @_;
      my $class = ref $self;
      return $class->new(%opts, parent => $self);
  }
  
  1;
  
  # ABSTRACT: The Moose Type Constraint metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint - The Moose Type Constraint metaclass
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class represents a single type constraint. Moose's built-in type
  constraints, as well as constraints you define, are all stored in a
  L<Moose::Meta::TypeConstraint::Registry> object as objects of this
  class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint> is a subclass of L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint->new(%options) >>
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 8
  
  =item * name
  
  The constraint name. If a name is not provided, it will be set to
  "__ANON__".
  
  =item * parent
  
  A C<Moose::Meta::TypeConstraint> object which is the parent type for
  the type being created. This is optional.
  
  =item * constraint
  
  This is the subroutine reference that implements the actual constraint
  check. This defaults to a subroutine which always returns true.
  
  =item * message
  
  A subroutine reference which is used to generate an error message when
  the constraint fails. This is optional.
  
  =item * coercion
  
  A L<Moose::Meta::TypeCoercion> object representing the coercions to
  the type. This is optional.
  
  =item * inlined
  
  A subroutine which returns a string suitable for inlining this type
  constraint. It will be called as a method on the type constraint object, and
  will receive a single additional parameter, a variable name to be tested
  (usually C<"$_"> or C<"$_[0]">.
  
  This is optional.
  
  =item * inline_environment
  
  A hash reference of variables to close over. The keys are variables names, and
  the values are I<references> to the variables.
  
  =back
  
  =item B<< $constraint->equals($type_name_or_object) >>
  
  Returns true if the supplied name or type object is the same as the
  current type.
  
  =item B<< $constraint->is_subtype_of($type_name_or_object) >>
  
  Returns true if the supplied name or type object is a parent of the
  current type.
  
  =item B<< $constraint->is_a_type_of($type_name_or_object) >>
  
  Returns true if the given type is the same as the current type, or is
  a parent of the current type. This is a shortcut for checking
  C<equals> and C<is_subtype_of>.
  
  =item B<< $constraint->coerce($value) >>
  
  This will attempt to coerce the value to the type. If the type does not
  have any defined coercions this will throw an error.
  
  If no coercion can produce a value matching C<$constraint>, the original
  value is returned.
  
  =item B<< $constraint->assert_coerce($value) >>
  
  This method behaves just like C<coerce>, but if the result is not valid
  according to C<$constraint>, an error is thrown.
  
  =item B<< $constraint->check($value) >>
  
  Returns true if the given value passes the constraint for the type.
  
  =item B<< $constraint->validate($value) >>
  
  This is similar to C<check>. However, if the type I<is valid> then the
  method returns an explicit C<undef>. If the type is not valid, we call
  C<< $self->get_message($value) >> internally to generate an error
  message.
  
  =item B<< $constraint->assert_valid($value) >>
  
  Like C<check> and C<validate>, this method checks whether C<$value> is
  valid under the constraint.  If it is, it will return true.  If it is not,
  an exception will be thrown with the results of
  C<< $self->get_message($value) >>.
  
  =item B<< $constraint->name >>
  
  Returns the type's name, as provided to the constructor.
  
  =item B<< $constraint->parent >>
  
  Returns the type's parent, as provided to the constructor, if any.
  
  =item B<< $constraint->has_parent >>
  
  Returns true if the type has a parent type.
  
  =item B<< $constraint->parents >>
  
  Returns all of the types parents as an list of type constraint objects.
  
  =item B<< $constraint->constraint >>
  
  Returns the type's constraint, as provided to the constructor.
  
  =item B<< $constraint->get_message($value) >>
  
  This generates a method for the given value. If the type does not have
  an explicit message, we generate a default message.
  
  =item B<< $constraint->has_message >>
  
  Returns true if the type has a message.
  
  =item B<< $constraint->message >>
  
  Returns the type's message as a subroutine reference.
  
  =item B<< $constraint->coercion >>
  
  Returns the type's L<Moose::Meta::TypeCoercion> object, if one
  exists.
  
  =item B<< $constraint->has_coercion >>
  
  Returns true if the type has a coercion.
  
  =item B<< $constraint->can_be_inlined >>
  
  Returns true if this type constraint can be inlined. A type constraint which
  subtypes an inlinable constraint and does not add an additional constraint
  "inherits" its parent type's inlining.
  
  =item B<< $constraint->create_child_type(%options) >>
  
  This returns a new type constraint of the same class using the
  provided C<%options>. The C<parent> option will be the current type.
  
  This method exists so that subclasses of this class can override this
  behavior and change how child types are created.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_CLASS';
  package Moose::Meta::TypeConstraint::Class;
  BEGIN {
    $Moose::Meta::TypeConstraint::Class::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::Class::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util 'blessed';
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('class' => (
      reader => 'class',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'Scalar::Util::blessed(' . $val . ')'
               . ' && ' . $val . '->isa(' . B::perlstring($self->class) . ')';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent}
          = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my $class_name = $args{class};
      $args{constraint} = sub { $_[0]->isa($class_name) };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new( \%args );
  
      $self->compile_type_constraint();
  
      return $self;
  }
  
  sub parents {
      my $self = shift;
      return (
          $self->parent,
          map {
              # FIXME find_type_constraint might find a TC named after the class but that isn't really it
              # I did this anyway since it's a convention that preceded TypeConstraint::Class, and it should DWIM
              # if anybody thinks this problematic please discuss on IRC.
              # a possible fix is to add by attr indexing to the type registry to find types of a certain property
              # regardless of their name
              Moose::Util::TypeConstraints::find_type_constraint($_)
                  ||
              __PACKAGE__->new( class => $_, name => "__ANON__" )
          } Class::MOP::class_of($self->class)->superclasses,
      );
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      if (!defined($other)) {
          if (!ref($type_or_name)) {
              return $self->class eq $type_or_name;
          }
          return;
      }
  
      return unless $other->isa(__PACKAGE__);
  
      return $self->class eq $other->class;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      ($self->equals($type_or_name) || $self->is_subtype_of($type_or_name));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name_or_class ) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_class);
  
      if ( not defined $type ) {
          if ( not ref $type_or_name_or_class ) {
              # it might be a class
              my $class = $self->class;
              return 1 if $class ne $type_or_name_or_class
                       && $class->isa( $type_or_name_or_class );
          }
          return;
      }
  
      if ( $type->isa(__PACKAGE__) && $type->class ne $self->class) {
          # if $type_or_name_or_class isn't a class, it might be the TC name of another ::Class type
          # or it could also just be a type object in this branch
          return $self->class->isa( $type->class );
      } else {
          # the only other thing we are a subtype of is Object
          $self->SUPER::is_subtype_of($type);
      }
  }
  
  # This is a bit counter-intuitive, but a child type of a Class type
  # constraint is not itself a Class type constraint (it has no class
  # attribute). This whole create_child_type thing needs some changing
  # though, probably making MMC->new a factory or something.
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  sub get_message {
      my $self = shift;
      my ($value) = @_;
  
      if ($self->has_message) {
          return $self->SUPER::get_message(@_);
      }
  
      $value = (defined $value ? overload::StrVal($value) : 'undef');
      return "Validation failed for '" . $self->name . "' with value $value (not isa " . $self->class . ")";
  }
  
  1;
  
  # ABSTRACT: Class/TypeConstraint parallel hierarchy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Class - Class/TypeConstraint parallel hierarchy
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class represents type constraints for a class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Class> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Class->new(%options) >>
  
  This creates a new class type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with two exceptions. First,
  it requires an additional option, C<class>, which is name of the
  constraint's class.  Second, it automatically sets the parent to the
  C<Object> type.
  
  The constructor also overrides the hand optimized type constraint with
  one it creates internally.
  
  =item B<< $constraint->class >>
  
  Returns the class name associated with the constraint.
  
  =item B<< $constraint->parents >>
  
  Returns all the type's parent types, corresponding to its parent
  classes.
  
  =item B<< $constraint->is_subtype_of($type_name_or_object) >>
  
  If the given type is also a class type, then this checks that the
  type's class is a subclass of the other type's class.
  
  Otherwise it falls back to the implementation in
  L<Moose::Meta::TypeConstraint>.
  
  =item B<< $constraint->create_child_type(%options) >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a
  C<Moose::Meta::TypeConstraint::Class> object!
  
  =item B<< $constraint->get_message($value) >>
  
  This is the same as L<Moose::Meta::TypeConstraint/get_message> except
  that it explicitly says C<isa> was checked. This is to help users deal
  with accidentally autovivified type constraints.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_CLASS

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint/DuckType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_DUCKTYPE';
  package Moose::Meta::TypeConstraint::DuckType;
  BEGIN {
    $Moose::Meta::TypeConstraint::DuckType::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::DuckType::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util 'blessed';
  use List::MoreUtils qw(all);
  use Moose::Util 'english_list';
  
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('methods' => (
      accessor => 'methods',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return $self->parent->_inline_check($val)
           . ' && do {' . "\n"
               . 'my $val = ' . $val . ';' . "\n"
               . '&List::MoreUtils::all(' . "\n"
                   . 'sub { $val->can($_) },' . "\n"
                   . join(', ', map { B::perlstring($_) } @{ $self->methods })
               . ');' . "\n"
           . '}';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent}
          = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my @methods = @{ $args{methods} };
      $args{constraint} = sub {
          my $val = $_[0];
          return all { $val->can($_) } @methods;
      };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new(\%args);
  
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
  
      return $self;
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_methods  = sort @{ $self->methods };
      my @other_methods = sort @{ $other->methods };
  
      return unless @self_methods == @other_methods;
  
      while ( @self_methods ) {
          my $method = shift @self_methods;
          my $other_method = shift @other_methods;
  
          return unless $method eq $other_method;
      }
  
      return 1;
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  sub get_message {
      my $self = shift;
      my ($value) = @_;
  
      if ($self->has_message) {
          return $self->SUPER::get_message(@_);
      }
  
      return $self->SUPER::get_message($value) unless blessed($value);
  
      my @methods = grep { !$value->can($_) } @{ $self->methods };
      my $class = blessed $value;
      $class ||= $value;
  
      return $class
           . " is missing methods "
           . english_list(map { "'$_'" } @methods);
  }
  
  1;
  
  # ABSTRACT: Type constraint for duck typing
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::DuckType - Type constraint for duck typing
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class represents type constraints based on an enumerated list of
  required methods.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::DuckType> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::DuckType->new(%options) >>
  
  This creates a new duck type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with several
  exceptions. First, it requires an additional option, C<methods>. This
  should be an array reference containing a list of required method
  names. Second, it automatically sets the parent to the C<Object> type.
  
  Finally, it ignores any provided C<constraint> option. The constraint
  is generated automatically based on the provided C<methods>.
  
  =item B<< $constraint->methods >>
  
  Returns the array reference of required methods provided to the
  constructor.
  
  =item B<< $constraint->create_child_type >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::DuckType>
  object!
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_DUCKTYPE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ENUM';
  package Moose::Meta::TypeConstraint::Enum;
  BEGIN {
    $Moose::Meta::TypeConstraint::Enum::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::Enum::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('values' => (
      accessor => 'values',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_inline_var_name' => (
      accessor => '_inline_var_name',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'defined(' . $val . ') '
               . '&& !ref(' . $val . ') '
               . '&& $' . $self->_inline_var_name . '{' . $val . '}';
  };
  
  my $var_suffix = 0;
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Str');
      $args{inlined} = $inliner;
  
      if ( scalar @{ $args{values} } < 1 ) {
          throw_exception( MustHaveAtLeastOneValueToEnumerate => params => \%args,
                                                                 class  => $class
                         );
      }
  
      for (@{ $args{values} }) {
          if (!defined($_)) {
              throw_exception( EnumValuesMustBeString => params => \%args,
                                                         class  => $class,
                                                         value  => $_
                             );
          }
          elsif (ref($_)) {
              throw_exception( EnumValuesMustBeString => params => \%args,
                                                         class  => $class,
                                                         value  => $_
                             );
          }
      }
  
      my %values = map { $_ => 1 } @{ $args{values} };
      $args{constraint} = sub { $values{ $_[0] } };
  
      my $var_name = 'enums' . $var_suffix++;;
      $args{_inline_var_name} = $var_name;
      $args{inline_environment} = { '%' . $var_name => \%values };
  
      my $self = $class->SUPER::new(\%args);
  
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
  
      return $self;
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_values  = sort @{ $self->values };
      my @other_values = sort @{ $other->values };
  
      return unless @self_values == @other_values;
  
      while ( @self_values ) {
          my $value = shift @self_values;
          my $other_value = shift @other_values;
  
          return unless $value eq $other_value;
      }
  
      return 1;
  }
  
  sub constraint {
      my $self = shift;
  
      my %values = map { $_ => undef } @{ $self->values };
  
      return sub { exists $values{$_[0]} };
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  1;
  
  # ABSTRACT: Type constraint for enumerated values.
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Enum - Type constraint for enumerated values.
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class represents type constraints based on an enumerated list of
  acceptable values.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Enum> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Enum->new(%options) >>
  
  This creates a new enum type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with several
  exceptions. First, it requires an additional option, C<values>. This
  should be an array reference containing a list of valid string
  values. Second, it automatically sets the parent to the C<Str> type.
  
  Finally, it ignores any provided C<constraint> option. The constraint
  is generated automatically based on the provided C<values>.
  
  =item B<< $constraint->values >>
  
  Returns the array reference of acceptable values provided to the
  constructor.
  
  =item B<< $constraint->create_child_type >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::Enum>
  object!
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ENUM

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint/Parameterizable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE';
  package Moose::Meta::TypeConstraint::Parameterizable;
  BEGIN {
    $Moose::Meta::TypeConstraint::Parameterizable::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::Parameterizable::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use parent 'Moose::Meta::TypeConstraint';
  use Moose::Meta::TypeConstraint::Parameterized;
  use Moose::Util::TypeConstraints ();
  
  use Moose::Util 'throw_exception';
  
  use Carp 'confess';
  
  __PACKAGE__->meta->add_attribute('constraint_generator' => (
      accessor  => 'constraint_generator',
      predicate => 'has_constraint_generator',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inline_generator' => (
      accessor  => 'inline_generator',
      predicate => 'has_inline_generator',
      Class::MOP::_definition_context(),
  ));
  
  sub generate_constraint_for {
      my ($self, $type) = @_;
  
      return unless $self->has_constraint_generator;
  
      return $self->constraint_generator->($type->type_parameter)
          if $type->is_subtype_of($self->name);
  
      return $self->_can_coerce_constraint_from($type)
          if $self->has_coercion
          && $self->coercion->has_coercion_for_type($type->parent->name);
  
      return;
  }
  
  sub _can_coerce_constraint_from {
      my ($self, $type) = @_;
      my $coercion   = $self->coercion;
      my $constraint = $self->constraint_generator->($type->type_parameter);
      return sub {
          local $_ = $coercion->coerce($_);
          $constraint->(@_);
      };
  }
  
  sub generate_inline_for {
      my ($self, $type, $val) = @_;
  
      throw_exception( CannotGenerateInlineConstraint => parameterizable_type_object => $self,
                                                         type                        => $type,
                                                         value                       => $val
                     )
          unless $self->has_inline_generator;
  
      return '( do { ' . $self->inline_generator->( $self, $type, $val ) . ' } )';
  }
  
  sub _parse_type_parameter {
      my ($self, $type_parameter) = @_;
      return Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($type_parameter);
  }
  
  sub parameterize {
      my ($self, $type_parameter) = @_;
  
      my $contained_tc = $self->_parse_type_parameter($type_parameter);
  
      ## The type parameter should be a subtype of the parent's type parameter
      ## if there is one.
  
      if(my $parent = $self->parent) {
          if($parent->can('type_parameter')) {
              unless ( $contained_tc->is_a_type_of($parent->type_parameter) ) {
                  throw_exception( ParameterIsNotSubtypeOfParent => type_parameter => $type_parameter,
                                                                    type           => $self
                                 );
              }
          }
      }
  
      if ( $contained_tc->isa('Moose::Meta::TypeConstraint') ) {
          my $tc_name = $self->name . '[' . $contained_tc->name . ']';
          return Moose::Meta::TypeConstraint::Parameterized->new(
              name               => $tc_name,
              parent             => $self,
              type_parameter     => $contained_tc,
              parameterized_from => $self,
          );
      }
      else {
          confess("The type parameter must be a Moose meta type");
      }
  }
  
  
  1;
  
  # ABSTRACT: Type constraints which can take a parameter (ArrayRef)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Parameterizable - Type constraints which can take a parameter (ArrayRef)
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class represents a parameterizable type constraint. This is a
  type constraint like C<ArrayRef> or C<HashRef>, that can be
  parameterized and made more specific by specifying a contained
  type. For example, instead of just an C<ArrayRef> of anything, you can
  specify that is an C<ArrayRef[Int]>.
  
  A parameterizable constraint should not be used as an attribute type
  constraint. Instead, when parameterized it creates a
  L<Moose::Meta::TypeConstraint::Parameterized> which should be used.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Parameterizable> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  This class is intentionally not documented because the API is
  confusing and needs some work.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint/Parameterized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED';
  package Moose::Meta::TypeConstraint::Parameterized;
  BEGIN {
    $Moose::Meta::TypeConstraint::Parameterized::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::Parameterized::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use Moose::Util::TypeConstraints;
  use Moose::Meta::TypeConstraint::Parameterizable;
  use Moose::Util 'throw_exception';
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('type_parameter' => (
      accessor  => 'type_parameter',
      predicate => 'has_type_parameter',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('parameterized_from' => (
      accessor   => 'parameterized_from',
      predicate  => 'has_parameterized_from',
      Class::MOP::_definition_context(),
  ));
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      return (
          $self->type_parameter->equals( $other->type_parameter )
              and
          $self->parent->equals( $other->parent )
      );
  }
  
  sub compile_type_constraint {
      my $self = shift;
  
      unless ( $self->has_type_parameter ) {
          throw_exception( CannotCreateHigherOrderTypeWithoutATypeParameter => type => $self );
      }
  
      my $type_parameter = $self->type_parameter;
  
      unless ( blessed $type_parameter && $type_parameter->isa('Moose::Meta::TypeConstraint') ) {
          throw_exception( TypeParameterMustBeMooseMetaType => type => $self );
      }
  
      foreach my $type (Moose::Util::TypeConstraints::get_all_parameterizable_types()) {
          if (my $constraint = $type->generate_constraint_for($self)) {
              $self->_set_constraint($constraint);
              return $self->SUPER::compile_type_constraint;
          }
      }
  
      # if we get here, then we couldn't
      # find a way to parameterize this type
      throw_exception( TypeConstraintCannotBeUsedForAParameterizableType => type => $self );
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      return
             $self->has_parameterized_from
          && $self->parameterized_from->has_inline_generator
          && $self->type_parameter->can_be_inlined;
  }
  
  sub inline_environment {
      my $self = shift;
  
      return {
          ($self->has_parameterized_from
              ? (%{ $self->parameterized_from->inline_environment })
              : ()),
          ($self->has_type_parameter
              ? (%{ $self->type_parameter->inline_environment })
              : ()),
      };
  }
  
  sub _inline_check {
      my $self = shift;
  
      return unless $self->can_be_inlined;
  
      return $self->parameterized_from->generate_inline_for( $self->type_parameter, @_ );
  }
  
  sub create_child_type {
      my ($self, %opts) = @_;
      return Moose::Meta::TypeConstraint::Parameterizable->new(%opts, parent=>$self);
  }
  
  1;
  
  # ABSTRACT: Type constraints with a bound parameter (ArrayRef[Int])
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Parameterized - Type constraints with a bound parameter (ArrayRef[Int])
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 METHODS
  
  This class is intentionally not documented because the API is
  confusing and needs some work.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Parameterized> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_REGISTRY';
  
  package Moose::Meta::TypeConstraint::Registry;
  BEGIN {
    $Moose::Meta::TypeConstraint::Registry::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::Registry::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('parent_registry' => (
      reader    => 'get_parent_registry',
      writer    => 'set_parent_registry',
      predicate => 'has_parent_registry',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('type_constraints' => (
      reader  => 'type_constraints',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my $self  = $class->_new(@_);
      return $self;
  }
  
  sub has_type_constraint {
      my ($self, $type_name) = @_;
      ($type_name and exists $self->type_constraints->{$type_name}) ? 1 : 0
  }
  
  sub get_type_constraint {
      my ($self, $type_name) = @_;
      return unless defined $type_name;
      $self->type_constraints->{$type_name}
  }
  
  sub add_type_constraint {
      my ($self, $type) = @_;
  
      unless ( $type && blessed $type && $type->isa('Moose::Meta::TypeConstraint') ) {
          throw_exception( InvalidTypeConstraint => registry_object => $self,
                                                    type            => $type
                         );
      }
  
      $self->type_constraints->{$type->name} = $type;
  }
  
  sub find_type_constraint {
      my ($self, $type_name) = @_;
      return $self->get_type_constraint($type_name)
          if $self->has_type_constraint($type_name);
      return $self->get_parent_registry->find_type_constraint($type_name)
          if $self->has_parent_registry;
      return;
  }
  
  1;
  
  # ABSTRACT: registry for type constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Registry - registry for type constraints
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is a registry that maps type constraint names to
  L<Moose::Meta::TypeConstraint> objects.
  
  Currently, it is only used internally by
  L<Moose::Util::TypeConstraints>, which creates a single global
  registry.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Registry> is a subclass of
  L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Registry->new(%options) >>
  
  This creates a new registry object based on the provided C<%options>:
  
  =over 8
  
  =item * parent_registry
  
  This is an optional L<Moose::Meta::TypeConstraint::Registry>
  object.
  
  =item * type_constraints
  
  This is hash reference of type names to type objects. This is
  optional. Constraints can be added to the registry after it is
  created.
  
  =back
  
  =item B<< $registry->get_parent_registry >>
  
  Returns the registry's parent registry, if it has one.
  
  =item B<< $registry->has_parent_registry >>
  
  Returns true if the registry has a parent.
  
  =item B<< $registry->set_parent_registry($registry) >>
  
  Sets the parent registry.
  
  =item B<< $registry->get_type_constraint($type_name) >>
  
  This returns the L<Moose::Meta::TypeConstraint> object from the
  registry for the given name, if one exists.
  
  =item B<< $registry->has_type_constraint($type_name) >>
  
  Returns true if the registry has a type of the given name.
  
  =item B<< $registry->add_type_constraint($type) >>
  
  Adds a new L<Moose::Meta::TypeConstraint> object to the registry.
  
  =item B<< $registry->find_type_constraint($type_name) >>
  
  This method looks in the current registry for the named type. If the
  type is not found, then this method will look in the registry's
  parent, if it has one.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_REGISTRY

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ROLE';
  package Moose::Meta::TypeConstraint::Role;
  BEGIN {
    $Moose::Meta::TypeConstraint::Role::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::Role::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util 'blessed';
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('role' => (
      reader => 'role',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'Moose::Util::does_role('
               . $val . ', '
               . B::perlstring($self->role)
           . ')';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my $role_name = $args{role};
      $args{constraint} = sub { Moose::Util::does_role( $_[0], $role_name ) };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new( \%args );
  
      $self->compile_type_constraint();
  
      return $self;
  }
  
  sub parents {
      my $self = shift;
      return (
          $self->parent,
          map {
              # FIXME find_type_constraint might find a TC named after the role but that isn't really it
              # I did this anyway since it's a convention that preceded TypeConstraint::Role, and it should DWIM
              # if anybody thinks this problematic please discuss on IRC.
              # a possible fix is to add by attr indexing to the type registry to find types of a certain property
              # regardless of their name
              Moose::Util::TypeConstraints::find_type_constraint($_)
                  ||
              __PACKAGE__->new( role => $_, name => "__ANON__" )
          } @{ Class::MOP::class_of($self->role)->get_roles },
      );
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless defined $other;
      return unless $other->isa(__PACKAGE__);
  
      return $self->role eq $other->role;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      ($self->equals($type) || $self->is_subtype_of($type_or_name));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name_or_role ) = @_;
  
      if ( not ref $type_or_name_or_role ) {
          # it might be a role
          my $class = Class::MOP::class_of($self->role);
          return 1 if defined($class) && $class->does_role( $type_or_name_or_role );
      }
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_role);
  
      return unless defined $type;
  
      if ( $type->isa(__PACKAGE__) ) {
          # if $type_or_name_or_role isn't a role, it might be the TC name of another ::Role type
          # or it could also just be a type object in this branch
          my $class = Class::MOP::class_of($self->role);
          return defined($class) && $class->does_role( $type->role );
      } else {
          # the only other thing we are a subtype of is Object
          $self->SUPER::is_subtype_of($type);
      }
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  1;
  
  # ABSTRACT: Role/TypeConstraint parallel hierarchy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Role - Role/TypeConstraint parallel hierarchy
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class represents type constraints for a role.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Role> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Role->new(%options) >>
  
  This creates a new role type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with two exceptions. First,
  it requires an additional option, C<role>, which is name of the
  constraint's role.  Second, it automatically sets the parent to the
  C<Object> type.
  
  The constructor also overrides the hand optimized type constraint with
  one it creates internally.
  
  =item B<< $constraint->role >>
  
  Returns the role name associated with the constraint.
  
  =item B<< $constraint->parents >>
  
  Returns all the type's parent types, corresponding to the roles that
  its role does.
  
  =item B<< $constraint->is_subtype_of($type_name_or_object) >>
  
  If the given type is also a role type, then this checks that the
  type's role does the other type's role.
  
  Otherwise it falls back to the implementation in
  L<Moose::Meta::TypeConstraint>.
  
  =item B<< $constraint->create_child_type(%options) >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::Role>
  object!
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Meta/TypeConstraint/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_UNION';
  
  package Moose::Meta::TypeConstraint::Union;
  BEGIN {
    $Moose::Meta::TypeConstraint::Union::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Meta::TypeConstraint::Union::VERSION = '2.1204';
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Meta::TypeCoercion::Union;
  
  use List::MoreUtils qw(all);
  use List::Util qw(first);
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('type_constraints' => (
      accessor  => 'type_constraints',
      default   => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my ($class, %options) = @_;
  
      my $name = join '|' => sort { $a cmp $b }
          map { $_->name } @{ $options{type_constraints} };
  
      my $self = $class->SUPER::new(
          name => $name,
          %options,
      );
  
      $self->_set_constraint( $self->_compiled_type_constraint );
  
      return $self;
  }
  
  # XXX - this is a rather gross implementation of laziness for the benefit of
  # MX::Types. If we try to call ->has_coercion on the objects during object
  # construction, this does not work when defining a recursive constraint with
  # MX::Types.
  sub coercion {
      my $self = shift;
  
      return $self->{coercion} if exists $self->{coercion};
  
      # Using any instead of grep here causes a weird error with some corner
      # cases when MX::Types is in use. See RT #61001.
      if ( grep { $_->has_coercion } @{ $self->type_constraints } ) {
          return $self->{coercion} = Moose::Meta::TypeCoercion::Union->new(
              type_constraint => $self );
      }
      else {
          return $self->{coercion} = undef;
      }
  }
  
  sub has_coercion {
      return defined $_[0]->coercion;
  }
  
  sub _actually_compile_type_constraint {
      my $self = shift;
  
      my @constraints = @{ $self->type_constraints };
  
      return sub {
          my $value = shift;
          foreach my $type (@constraints) {
              return 1 if $type->check($value);
          }
          return undef;
      };
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      # This was originally done with all() from List::MoreUtils, but that
      # caused some sort of bizarro parsing failure under 5.10.
      for my $tc ( @{ $self->type_constraints } ) {
          return 0 unless $tc->can_be_inlined;
      }
  
      return 1;
  }
  
  sub _inline_check {
      my $self = shift;
      my $val  = shift;
  
      return '('
                 . (
                    join ' || ', map { '(' . $_->_inline_check($val) . ')' }
                    @{ $self->type_constraints }
                   )
             . ')';
  }
  
  sub inline_environment {
      my $self = shift;
  
      return { map { %{ $_->inline_environment } }
              @{ $self->type_constraints } };
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_constraints  = @{ $self->type_constraints };
      my @other_constraints = @{ $other->type_constraints };
  
      return unless @self_constraints == @other_constraints;
  
      # FIXME presort type constraints for efficiency?
      constraint: foreach my $constraint ( @self_constraints ) {
          for ( my $i = 0; $i < @other_constraints; $i++ ) {
              if ( $constraint->equals($other_constraints[$i]) ) {
                  splice @other_constraints, $i, 1;
                  next constraint;
              }
          }
      }
  
      return @other_constraints == 0;
  }
  
  sub parent {
      my $self = shift;
  
      my ($first, @rest) = @{ $self->type_constraints };
  
      for my $parent ( $first->_collect_all_parents ) {
          return $parent if all { $_->is_a_type_of($parent) } @rest;
      }
  
      return;
  }
  
  sub validate {
      my ($self, $value) = @_;
      my $message;
      foreach my $type (@{$self->type_constraints}) {
          my $err = $type->validate($value);
          return unless defined $err;
          $message .= ($message ? ' and ' : '') . $err
              if defined $err;
      }
      return ($message . ' in (' . $self->name . ')') ;
  }
  
  sub find_type_for {
      my ($self, $value) = @_;
  
      return first { $_->check($value) } @{ $self->type_constraints };
  }
  
  sub is_a_type_of {
      my ($self, $type_name) = @_;
  
      return all { $_->is_a_type_of($type_name) } @{ $self->type_constraints };
  }
  
  sub is_subtype_of {
      my ($self, $type_name) = @_;
  
      return all { $_->is_subtype_of($type_name) } @{ $self->type_constraints };
  }
  
  sub create_child_type {
      my ( $self, %opts ) = @_;
  
      my $constraint
          = Moose::Meta::TypeConstraint->new( %opts, parent => $self );
  
      # if we have a type constraint union, and no
      # type check, this means we are just aliasing
      # the union constraint, which means we need to
      # handle this differently.
      # - SL
      if ( not( defined $opts{constraint} )
          && $self->has_coercion ) {
          $constraint->coercion(
              Moose::Meta::TypeCoercion::Union->new(
                  type_constraint => $self,
              )
          );
      }
  
      return $constraint;
  }
  
  1;
  
  # ABSTRACT: A union of Moose type constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Union - A union of Moose type constraints
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This metaclass represents a union of type constraints. A union takes
  multiple type constraints, and is true if any one of its member
  constraints is true.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Union> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Union->new(%options) >>
  
  This creates a new class type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent. It also requires an
  additional option, C<type_constraints>. This is an array reference
  containing the L<Moose::Meta::TypeConstraint> objects that are the
  members of the union type. The C<name> option defaults to the names
  all of these member types sorted and then joined by a pipe (|).
  
  The constructor sets the implementation of the constraint so that is
  simply calls C<check> on the newly created object.
  
  Finally, the constructor also makes sure that the object's C<coercion>
  attribute is a L<Moose::Meta::TypeCoercion::Union> object.
  
  =item B<< $constraint->type_constraints >>
  
  This returns the array reference of C<type_constraints> provided to
  the constructor.
  
  =item B<< $constraint->parent >>
  
  This returns the nearest common ancestor of all the components of the union.
  
  =item B<< $constraint->check($value) >>
  
  =item B<< $constraint->validate($value) >>
  
  These two methods simply call the relevant method on each of the
  member type constraints in the union. If any type accepts the value,
  the value is valid.
  
  With C<validate> the error message returned includes all of the error
  messages returned by the member type constraints.
  
  =item B<< $constraint->equals($type_name_or_object) >>
  
  A type is considered equal if it is also a union type, and the two
  unions have the same member types.
  
  =item B<< $constraint->find_type_for($value) >>
  
  This returns the first member type constraint for which C<check($value)> is
  true, allowing you to determine which of the Union's member type constraints
  a given value matches.
  
  =item B<< $constraint->is_a_type_of($type_name_or_object) >>
  
  This returns true if all of the member type constraints return true
  for the C<is_a_type_of> method.
  
  =item B<< $constraint->is_subtype_of >>
  
  This returns true if all of the member type constraints return true
  for the C<is_a_subtype_of> method.
  
  =item B<< $constraint->create_child_type(%options) >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_UNION

$fatpacked{"x86_64-linux-thread-multi/Moose/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_OBJECT';
  
  package Moose::Object;
  BEGIN {
    $Moose::Object::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Object::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Carp ();
  use Devel::GlobalDestruction ();
  use MRO::Compat ();
  use Scalar::Util ();
  use Try::Tiny ();
  
  use Moose::Util ();
  
  use if ( not our $__mx_is_compiled ), 'Moose::Meta::Class';
  use if ( not our $__mx_is_compiled ), metaclass => 'Moose::Meta::Class';
  
  sub new {
      my $class = shift;
      my $real_class = Scalar::Util::blessed($class) || $class;
  
      my $params = $real_class->BUILDARGS(@_);
  
      return Class::MOP::Class->initialize($real_class)->new_object($params);
  }
  
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              Moose::Util::throw_exception( "SingleParamsToNewMustBeHashRef" );
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          Carp::carp(
              "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments" );
          return { @_, undef };
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
      # NOTE: we ask Perl if we even
      # need to do this first, to avoid
      # extra meta level calls
      return unless $_[0]->can('BUILD');
      my ($self, $params) = @_;
      foreach my $method (reverse Class::MOP::class_of($self)->find_all_methods_by_name('BUILD')) {
          $method->{code}->execute($self, $params);
      }
  }
  
  sub DEMOLISHALL {
      my $self = shift;
      my ($in_global_destruction) = @_;
  
      # NOTE: we ask Perl if we even
      # need to do this first, to avoid
      # extra meta level calls
      return unless $self->can('DEMOLISH');
  
      my @isa;
      if ( my $meta = Class::MOP::class_of($self ) ) {
          @isa = $meta->linearized_isa;
      } else {
          # We cannot count on being able to retrieve a previously made
          # metaclass, _or_ being able to make a new one during global
          # destruction. However, we should still be able to use mro at
          # that time (at least tests suggest so ;)
          my $class_name = ref $self;
          @isa = @{ mro::get_linear_isa($class_name) }
      }
  
      foreach my $class (@isa) {
          no strict 'refs';
          my $demolish = *{"${class}::DEMOLISH"}{CODE};
          $self->$demolish($in_global_destruction)
              if defined $demolish;
      }
  }
  
  sub DESTROY {
      my $self = shift;
  
      local $?;
  
      # < doy> if the destructor is being called because an exception is thrown, then $@ will be set
      # < doy> but if DEMOLISH does an eval which succeeds, that will clear $@
      # < doy> which is broken
      # < doy> try::tiny implicitly localizes $@ in the try block, which fixes that
      Try::Tiny::try {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
      }
      Try::Tiny::catch {
          die $_;
      };
  
      return;
  }
  
  # support for UNIVERSAL::DOES ...
  BEGIN {
      my $does = UNIVERSAL->can("DOES") ? "SUPER::DOES" : "isa";
      eval 'sub DOES {
          my ( $self, $class_or_role_name ) = @_;
          return $self->'.$does.'($class_or_role_name)
              || $self->does($class_or_role_name);
      }';
  }
  
  # new does() methods will be created
  # as appropriate see Moose::Meta::Role
  sub does {
      my ($self, $role_name) = @_;
      my $class = Scalar::Util::blessed($self) || $self;
      my $meta = Class::MOP::Class->initialize($class);
      (defined $role_name)
          || Moose::Util::throw_exception( DoesRequiresRoleName => class => $meta );
      return 1 if $meta->can('does_role') && $meta->does_role($role_name);
      return 0;
  }
  
  sub dump {
      my $self = shift;
      require Data::Dumper;
      local $Data::Dumper::Maxdepth = shift if @_;
      Data::Dumper::Dumper $self;
  }
  
  1;
  
  # ABSTRACT: The base object for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Object - The base object for Moose
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 DESCRIPTION
  
  This class is the default base class for all Moose-using classes. When
  you C<use Moose> in this class, your class will inherit from this
  class.
  
  It provides a default constructor and destructor, which run all of the
  C<BUILD> and C<DEMOLISH> methods in the inheritance hierarchy,
  respectively.
  
  You don't actually I<need> to inherit from this in order to use Moose,
  but it makes it easier to take advantage of all of Moose's features.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Object->new(%params|$params) >>
  
  This method calls C<< $class->BUILDARGS(@_) >>, and then creates a new
  instance of the appropriate class. Once the instance is created, it
  calls C<< $instance->BUILD($params) >> for each C<BUILD> method in the
  inheritance hierarchy.
  
  =item B<< Moose::Object->BUILDARGS(%params|$params) >>
  
  The default implementation of this method accepts a hash or hash
  reference of named parameters. If it receives a single argument that
  I<isn't> a hash reference it throws an error.
  
  You can override this method in your class to handle other types of
  options passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =item B<< $object->does($role_name) >>
  
  This returns true if the object does the given role.
  
  =item B<< $object->DOES($class_or_role_name) >>
  
  This is a Moose role-aware implementation of L<UNIVERSAL/DOES>.
  
  This is effectively the same as writing:
  
    $object->does($name) || $object->isa($name)
  
  This method will work with Perl 5.8, which did not implement
  C<UNIVERSAL::DOES>.
  
  =item B<< $object->dump($maxdepth) >>
  
  This is a handy utility for C<Data::Dumper>ing an object. By default,
  the maximum depth is 1, to avoid making a mess.
  
  =item B<< $object->DESTROY >>
  
  A default destructor is provided, which calls
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method in the inheritance hierarchy.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_OBJECT

$fatpacked{"x86_64-linux-thread-multi/Moose/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_ROLE';
  use strict;
  use warnings;
  package Moose::Role;
  BEGIN {
    $Moose::Role::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Role::VERSION = '2.1204';
  use Scalar::Util 'blessed';
  use Carp         'croak';
  use Class::Load  'is_class_loaded';
  use Module::Runtime 'module_notional_filename';
  
  use Sub::Exporter;
  
  use Moose       ();
  use Moose::Util 'throw_exception';
  
  use Moose::Exporter;
  use Moose::Meta::Role;
  use Moose::Util::TypeConstraints;
  
  sub extends {
      throw_exception("RolesDoNotSupportExtends");
  }
  
  sub with {
      Moose::Util::apply_all_roles( shift, @_ );
  }
  
  sub requires {
      my $meta = shift;
      throw_exception( MustSpecifyAtleastOneMethod => role => $meta ) unless @_;
      $meta->add_required_methods(@_);
  }
  
  sub excludes {
      my $meta = shift;
      throw_exception( MustSpecifyAtleastOneRole => role => $meta ) unless @_;
      $meta->add_excluded_roles(@_);
  }
  
  sub has {
      my $meta = shift;
      my $name = shift;
      throw_exception( InvalidHasProvidedInARole => role            => $meta,
                                                    attribute_name  => $name
                     )
          if @_ == 1;
      my %context = Moose::Util::_caller_info;
      $context{context} = 'has declaration';
      $context{type} = 'role';
      my %options = ( definition_context => \%context, @_ );
      my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
      $meta->add_attribute( $_, %options ) for @$attrs;
  }
  
  sub _add_method_modifier {
      my $type = shift;
      my $meta = shift;
  
      if ( ref($_[0]) eq 'Regexp' ) {
          throw_exception( RolesDoNotSupportRegexReferencesForMethodModifiers => modifier_type => $type,
                                                                                 role          => $meta
                         );
      }
  
      Moose::Util::add_method_modifier($meta, $type, \@_);
  }
  
  sub before { _add_method_modifier('before', @_) }
  
  sub after  { _add_method_modifier('after',  @_) }
  
  sub around { _add_method_modifier('around', @_) }
  
  # see Moose.pm for discussion
  sub super {
      return unless $Moose::SUPER_BODY;
      $Moose::SUPER_BODY->(@Moose::SUPER_ARGS);
  }
  
  sub override {
      my $meta = shift;
      my ( $name, $code ) = @_;
      $meta->add_override_method_modifier( $name, $code );
  }
  
  sub inner {
      throw_exception("RolesDoNotSupportInner");
  }
  
  sub augment {
      throw_exception("RolesDoNotSupportAugment");
  }
  
  Moose::Exporter->setup_import_methods(
      with_meta => [
          qw( with requires excludes has before after around override )
      ],
      as_is => [
          qw( extends super inner augment ),
          \&Carp::confess,
          \&Scalar::Util::blessed,
      ],
  );
  
  sub init_meta {
      shift;
      my %args = @_;
  
      my $role = $args{for_class};
  
      unless ($role) {
          require Moose;
          throw_exception( InitMetaRequiresClass => params => \%args );
      }
  
      my $metaclass = $args{metaclass} || "Moose::Meta::Role";
      my $meta_name = exists $args{meta_name} ? $args{meta_name} : 'meta';
  
      throw_exception( MetaclassNotLoaded => class_name => $metaclass )
          unless is_class_loaded($metaclass);
  
      throw_exception( MetaclassMustBeASubclassOfMooseMetaRole => role_name => $metaclass )
          unless $metaclass->isa('Moose::Meta::Role');
  
      # make a subtype for each Moose role
      role_type $role unless find_type_constraint($role);
  
      my $meta;
      if ( $meta = Class::MOP::get_metaclass_by_name($role) ) {
          unless ( $meta->isa("Moose::Meta::Role") ) {
              if ( $meta->isa('Moose::Meta::Class') ) {
                  throw_exception( MetaclassIsAClassNotASubclassOfGivenMetaclass => class_name => $role,
                                                                                    metaclass  => $metaclass,
                                                                                    class      => $meta
                                 );
              } else {
                  throw_exception( MetaclassIsNotASubclassOfGivenMetaclass => class_name => $role,
                                                                              metaclass  => $metaclass,
                                                                              class      => $meta
                                 );
              }
          }
      }
      else {
          $meta = $metaclass->initialize($role);
          my $filename = module_notional_filename($meta->name);
          $INC{$filename} = '(set by Moose)'
              unless exists $INC{$filename};
      }
  
      if (defined $meta_name) {
          # also check for inherited non moose 'meta' method?
          my $existing = $meta->get_method($meta_name);
          if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
              Carp::cluck "Moose::Role is overwriting an existing method named "
                        . "$meta_name in role $role with a method "
                        . "which returns the class's metaclass. If this is "
                        . "actually what you want, you should remove the "
                        . "existing method, otherwise, you should rename or "
                        . "disable this generated method using the "
                        . "'-meta_name' option to 'use Moose::Role'.";
          }
          $meta->_add_meta_method($meta_name);
      }
  
      return $meta;
  }
  
  1;
  
  # ABSTRACT: The Moose Role
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Role - The Moose Role
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package Eq;
    use Moose::Role; # automatically turns on strict and warnings
  
    requires 'equal';
  
    sub no_equal {
        my ($self, $other) = @_;
        !$self->equal($other);
    }
  
    # ... then in your classes
  
    package Currency;
    use Moose; # automatically turns on strict and warnings
  
    with 'Eq';
  
    sub equal {
        my ($self, $other) = @_;
        $self->as_float == $other->as_float;
    }
  
    # ... and also
  
    package Comparator;
    use Moose;
  
    has compare_to => (
        is      => 'ro',
        does    => 'Eq',
        handles => 'Eq',
    );
  
    # ... which allows
  
    my $currency1 = Currency->new(...);
    my $currency2 = Currency->new(...);
    Comparator->new(compare_to => $currency1)->equal($currency2);
  
  =head1 DESCRIPTION
  
  The concept of roles is documented in L<Moose::Manual::Roles>. This document
  serves as API documentation.
  
  =head1 EXPORTED FUNCTIONS
  
  Moose::Role currently supports all of the functions that L<Moose> exports, but
  differs slightly in how some items are handled (see L</CAVEATS> below for
  details).
  
  Moose::Role also offers two role-specific keyword exports:
  
  =over 4
  
  =item B<requires (@method_names)>
  
  Roles can require that certain methods are implemented by any class which
  C<does> the role.
  
  Note that attribute accessors also count as methods for the purposes
  of satisfying the requirements of a role.
  
  =item B<excludes (@role_names)>
  
  Roles can C<exclude> other roles, in effect saying "I can never be combined
  with these C<@role_names>". This is a feature which should not be used
  lightly.
  
  =back
  
  =head2 B<unimport>
  
  Moose::Role offers a way to remove the keywords it exports, through the
  C<unimport> method. You simply have to say C<no Moose::Role> at the bottom of
  your code for this to work.
  
  =head1 METACLASS
  
  When you use Moose::Role, you can specify traits which will be applied to your
  role metaclass:
  
      use Moose::Role -traits => 'My::Trait';
  
  This is very similar to the attribute traits feature. When you do
  this, your class's C<meta> object will have the specified traits
  applied to it. See L<Moose/Metaclass and Trait Name Resolution> for more
  details.
  
  =head1 APPLYING ROLES
  
  In addition to being applied to a class using the 'with' syntax (see
  L<Moose::Manual::Roles>) and using the L<Moose::Util> 'apply_all_roles'
  method, roles may also be applied to an instance of a class using
  L<Moose::Util> 'apply_all_roles' or the role's metaclass:
  
     MyApp::Test::SomeRole->meta->apply( $instance );
  
  Doing this creates a new, mutable, anonymous subclass, applies the role to that,
  and reblesses. In a debugger, for example, you will see class names of the
  form C< Moose::Meta::Class::__ANON__::SERIAL::6 >, which means that doing a
  'ref' on your instance may not return what you expect. See L<Moose::Object> for
  'DOES'.
  
  Additional params may be added to the new instance by providing
  'rebless_params'. See L<Moose::Meta::Role::Application::ToInstance>.
  
  =head1 CAVEATS
  
  Role support has only a few caveats:
  
  =over 4
  
  =item *
  
  Roles cannot use the C<extends> keyword; it will throw an exception for now.
  The same is true of the C<augment> and C<inner> keywords (not sure those
  really make sense for roles). All other Moose keywords will be I<deferred>
  so that they can be applied to the consuming class.
  
  =item *
  
  Role composition does its best to B<not> be order-sensitive when it comes to
  conflict resolution and requirements detection. However, it is order-sensitive
  when it comes to method modifiers. All before/around/after modifiers are
  included whenever a role is composed into a class, and then applied in the order
  in which the roles are used. This also means that there is no conflict for
  before/around/after modifiers.
  
  In most cases, this will be a non-issue; however, it is something to keep in
  mind when using method modifiers in a role. You should never assume any
  ordering.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_ROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_UTIL';
  package Moose::Util;
  BEGIN {
    $Moose::Util::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Util::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Module::Runtime 0.014 'use_package_optimistically', 'use_module', 'module_notional_filename';
  use Data::OptList;
  use Params::Util qw( _STRING );
  use Sub::Exporter;
  use Scalar::Util 'blessed';
  use List::Util qw(first);
  use List::MoreUtils qw(any all);
  use overload ();
  use Try::Tiny;
  
  
  my @exports = qw[
      find_meta
      does_role
      search_class_by_role
      ensure_all_roles
      apply_all_roles
      with_traits
      get_all_init_args
      get_all_attribute_values
      resolve_metatrait_alias
      resolve_metaclass_alias
      add_method_modifier
      english_list
      meta_attribute_alias
      meta_class_alias
      throw_exception
  ];
  
  Sub::Exporter::setup_exporter({
      exports => \@exports,
      groups  => { all => \@exports }
  });
  
  # Things that need to ->import from Moose::Util
  # should be loaded after Moose::Util defines ->import
  require Class::MOP;
  
  sub throw_exception {
      my ($class_name, @args_to_exception) = @_;
      my $class = "Moose::Exception::$class_name";
      _load_user_class( $class );
      die $class->new( @args_to_exception );
  }
  
  ## some utils for the utils ...
  
  sub find_meta { Class::MOP::class_of(@_) }
  
  ## the functions ...
  
  sub does_role {
      my ($class_or_obj, $role) = @_;
  
      if (try { $class_or_obj->isa('Moose::Object') }) {
          return $class_or_obj->does($role);
      }
  
      my $meta = find_meta($class_or_obj);
  
      return unless defined $meta;
      return unless $meta->can('does_role');
      return 1 if $meta->does_role($role);
      return;
  }
  
  sub search_class_by_role {
      my ($class_or_obj, $role) = @_;
  
      my $meta = find_meta($class_or_obj);
  
      return unless defined $meta;
  
      my $role_name = blessed $role ? $role->name : $role;
  
      foreach my $class ($meta->class_precedence_list) {
  
          my $_meta = find_meta($class);
  
          next unless defined $_meta;
  
          foreach my $role (@{ $_meta->roles || [] }) {
              return $class if $role->name eq $role_name;
          }
      }
  
      return;
  }
  
  # this can possibly behave in unexpected ways because the roles being composed
  # before being applied could differ from call to call; I'm not sure if or how
  # to document this possible quirk.
  sub ensure_all_roles {
      my $applicant = shift;
      _apply_all_roles($applicant, sub { !does_role($applicant, $_) }, @_);
  }
  
  sub apply_all_roles {
      my $applicant = shift;
      _apply_all_roles($applicant, undef, @_);
  }
  
  sub _apply_all_roles {
      my $applicant = shift;
      my $role_filter = shift;
  
      unless (@_) {
          require Moose;
          throw_exception( MustSpecifyAtleastOneRoleToApplicant => applicant => $applicant );
      }
  
      # If @_ contains role meta objects, mkopt will think that they're values,
      # because they're references.  In other words (roleobj1, roleobj2,
      # roleobj3) will become [ [ roleobj1, roleobj2 ], [ roleobj3, undef ] ]
      # -- this is no good.  We'll preprocess @_ first to eliminate the potential
      # bug.
      # -- rjbs, 2011-04-08
      my $roles = Data::OptList::mkopt( [@_], {
        moniker   => 'role',
        name_test => sub {
          ! ref $_[0] or blessed($_[0]) && $_[0]->isa('Moose::Meta::Role')
        }
      });
  
      my @role_metas;
      foreach my $role (@$roles) {
          my $meta;
  
          if ( blessed $role->[0] ) {
              $meta = $role->[0];
          }
          else {
              &use_module($role->[0], $role->[1] && $role->[1]{-version} ? $role->[1]{-version} : ());
              $meta = find_meta( $role->[0] );
          }
  
          unless ($meta && $meta->isa('Moose::Meta::Role') ) {
              throw_exception( CanOnlyConsumeRole => role_name => $role->[0] );
          }
  
          push @role_metas, [ $meta, $role->[1] ];
      }
  
      if ( defined $role_filter ) {
          @role_metas = grep { local $_ = $_->[0]; $role_filter->() } @role_metas;
      }
  
      return unless @role_metas;
  
      _load_user_class($applicant)
          unless blessed($applicant)
              || Class::MOP::class_of($applicant);
  
      my $meta = ( blessed $applicant ? $applicant : Moose::Meta::Class->initialize($applicant) );
  
      if ( scalar @role_metas == 1 ) {
          my ( $role, $params ) = @{ $role_metas[0] };
          $role->apply( $meta, ( defined $params ? %$params : () ) );
      }
      else {
          Moose::Meta::Role->combine(@role_metas)->apply($meta);
      }
  }
  
  sub with_traits {
      my ($class, @roles) = @_;
      return $class unless @roles;
      return Moose::Meta::Class->create_anon_class(
          superclasses => [$class],
          roles        => \@roles,
          cache        => 1,
      )->name;
  }
  
  # instance deconstruction ...
  
  sub get_all_attribute_values {
      my ($class, $instance) = @_;
      return +{
          map { $_->name => $_->get_value($instance) }
              grep { $_->has_value($instance) }
                  $class->get_all_attributes
      };
  }
  
  sub get_all_init_args {
      my ($class, $instance) = @_;
      return +{
          map { $_->init_arg => $_->get_value($instance) }
              grep { $_->has_value($instance) }
                  grep { defined($_->init_arg) }
                      $class->get_all_attributes
      };
  }
  
  sub resolve_metatrait_alias {
      return resolve_metaclass_alias( @_, trait => 1 );
  }
  
  sub _build_alias_package_name {
      my ($type, $name, $trait) = @_;
      return 'Moose::Meta::'
           . $type
           . '::Custom::'
           . ( $trait ? 'Trait::' : '' )
           . $name;
  }
  
  {
      my %cache;
  
      sub resolve_metaclass_alias {
          my ( $type, $metaclass_name, %options ) = @_;
  
          my $cache_key = $type . q{ } . ( $options{trait} ? '-Trait' : '' );
          return $cache{$cache_key}{$metaclass_name}
              if $cache{$cache_key}{$metaclass_name};
  
          my $possible_full_name = _build_alias_package_name(
              $type, $metaclass_name, $options{trait}
          );
  
          my @possible = ($possible_full_name, $metaclass_name);
          for my $package (@possible) {
              use_package_optimistically($package);
              if ($package->can('register_implementation')) {
                  return $cache{$cache_key}{$metaclass_name} =
                      $package->register_implementation;
              }
              elsif (find_meta($package)) {
                  return $cache{$cache_key}{$metaclass_name} = $package;
              }
          }
  
          throw_exception( CannotLocatePackageInINC => possible_packages => _english_list_or(@possible),
                                                       INC               => \@INC,
                                                       type              => $type,
                                                       metaclass_name    => $metaclass_name,
                                                       params            => \%options
                         );
      }
  }
  
  sub add_method_modifier {
      my ( $class_or_obj, $modifier_name, $args ) = @_;
      my $meta
          = $class_or_obj->can('add_before_method_modifier')
          ? $class_or_obj
          : find_meta($class_or_obj);
      my $code                = pop @{$args};
      my $add_modifier_method = 'add_' . $modifier_name . '_method_modifier';
      if ( my $method_modifier_type = ref( @{$args}[0] ) ) {
          if ( $method_modifier_type eq 'Regexp' ) {
              my @all_methods = $meta->get_all_methods;
              my @matched_methods
                  = grep { $_->name =~ @{$args}[0] } @all_methods;
              $meta->$add_modifier_method( $_->name, $code )
                  for @matched_methods;
          }
          elsif ($method_modifier_type eq 'ARRAY') {
              $meta->$add_modifier_method( $_, $code ) for @{$args->[0]};
          }
          else {
              throw_exception( IllegalMethodTypeToAddMethodModifier => class_or_object => $class_or_obj,
                                                                       modifier_name   => $modifier_name,
                                                                       params          => $args
                             );
          }
      }
      else {
          $meta->$add_modifier_method( $_, $code ) for @{$args};
      }
  }
  
  sub english_list {
      _english_list_and(@_);
  }
  
  sub _english_list_and {
      _english_list('and', \@_);
  }
  
  sub _english_list_or {
      _english_list('or', \@_);
  }
  
  sub _english_list {
      my ($conjunction, $items) = @_;
  
      my @items = sort @$items;
  
      return $items[0] if @items == 1;
      return "$items[0] $conjunction $items[1]" if @items == 2;
  
      my $tail = pop @items;
      my $list = join ', ', @items;
      $list .= ", $conjunction " . $tail;
  
      return $list;
  }
  
  sub _caller_info {
      my $level = @_ ? ($_[0] + 1) : 2;
      my %info;
      @info{qw(package file line)} = caller($level);
      return %info;
  }
  
  sub _create_alias {
      my ($type, $name, $trait, $for) = @_;
      my $package = _build_alias_package_name($type, $name, $trait);
      Class::MOP::Class->initialize($package)->add_method(
          register_implementation => sub { $for }
      );
  }
  
  sub meta_attribute_alias {
      my ($to, $from) = @_;
      $from ||= caller;
      my $meta = Class::MOP::class_of($from);
      my $trait = $meta->isa('Moose::Meta::Role');
      _create_alias('Attribute', $to, $trait, $from);
  }
  
  sub meta_class_alias {
      my ($to, $from) = @_;
      $from ||= caller;
      my $meta = Class::MOP::class_of($from);
      my $trait = $meta->isa('Moose::Meta::Role');
      _create_alias('Class', $to, $trait, $from);
  }
  
  sub _load_user_class {
      my ($class, $opts) = @_;
      &use_package_optimistically(
          $class,
          $opts && $opts->{-version} ? $opts->{-version} : ()
      );
  }
  
  # XXX - this should be added to Params::Util
  sub _STRINGLIKE0 ($) {
      return 1 if _STRING( $_[0] );
      if ( blessed $_[0] ) {
          return overload::Method( $_[0], q{""} );
      }
  
      return 1 if defined $_[0] && $_[0] eq q{};
  
      return 0;
  }
  
  sub _reconcile_roles_for_metaclass {
      my ($class_meta_name, $super_meta_name) = @_;
  
      my @role_differences = _role_differences(
          $class_meta_name, $super_meta_name,
      );
  
      # handle the case where we need to fix compatibility between a class and
      # its parent, but all roles in the class are already also done by the
      # parent
      # see t/metaclasses/metaclass_compat_no_fixing_bug.t
      return $super_meta_name
          unless @role_differences;
  
      return Moose::Meta::Class->create_anon_class(
          superclasses => [$super_meta_name],
          roles        => [map { $_->name } @role_differences],
          cache        => 1,
      )->name;
  }
  
  sub _role_differences {
      my ($class_meta_name, $super_meta_name) = @_;
      my @super_role_metas = map {
          $_->isa('Moose::Meta::Role::Composite')
              ? (@{ $_->get_roles })
              : ($_)
      } $super_meta_name->meta->can('_roles_with_inheritance')
          ? $super_meta_name->meta->_roles_with_inheritance
      : $super_meta_name->meta->can('roles')
          ? @{ $super_meta_name->meta->roles }
      :     ();
      my @role_metas = map {
          $_->isa('Moose::Meta::Role::Composite')
              ? (@{ $_->get_roles })
              : ($_)
      } $class_meta_name->meta->can('_roles_with_inheritance')
          ? $class_meta_name->meta->_roles_with_inheritance
      : $class_meta_name->meta->can('roles')
          ? @{ $class_meta_name->meta->roles }
      :     ();
      my @differences;
      for my $role_meta (@role_metas) {
          push @differences, $role_meta
              unless any { $_->name eq $role_meta->name } @super_role_metas;
      }
      return @differences;
  }
  
  sub _classes_differ_by_roles_only {
      my ( $self_meta_name, $super_meta_name ) = @_;
  
      my $common_base_name
          = _find_common_base( $self_meta_name, $super_meta_name );
  
      return unless defined $common_base_name;
  
      my @super_meta_name_ancestor_names
          = _get_ancestors_until( $super_meta_name, $common_base_name );
      my @class_meta_name_ancestor_names
          = _get_ancestors_until( $self_meta_name, $common_base_name );
  
      return
          unless all { _is_role_only_subclass($_) }
          @super_meta_name_ancestor_names,
          @class_meta_name_ancestor_names;
  
      return 1;
  }
  
  sub _find_common_base {
      my ($meta1, $meta2) = map { Class::MOP::class_of($_) } @_;
      return unless defined $meta1 && defined $meta2;
  
      # FIXME? This doesn't account for multiple inheritance (not sure
      # if it needs to though). For example, if somewhere in $meta1's
      # history it inherits from both ClassA and ClassB, and $meta2
      # inherits from ClassB & ClassA, does it matter? And what crazy
      # fool would do that anyway?
  
      my %meta1_parents = map { $_ => 1 } $meta1->linearized_isa;
  
      return first { $meta1_parents{$_} } $meta2->linearized_isa;
  }
  
  sub _get_ancestors_until {
      my ($start_name, $until_name) = @_;
  
      my @ancestor_names;
      for my $ancestor_name (Class::MOP::class_of($start_name)->linearized_isa) {
          last if $ancestor_name eq $until_name;
          push @ancestor_names, $ancestor_name;
      }
      return @ancestor_names;
  }
  
  sub _is_role_only_subclass {
      my ($meta_name) = @_;
      my $meta = Class::MOP::Class->initialize($meta_name);
      my @parent_names = $meta->superclasses;
  
      # XXX: don't feel like messing with multiple inheritance here... what would
      # that even do?
      return unless @parent_names == 1;
      my ($parent_name) = @parent_names;
      my $parent_meta = Class::MOP::Class->initialize($parent_name);
  
      # only get the roles attached to this particular class, don't look at
      # superclasses
      my @roles = $meta->can('calculate_all_roles')
                      ? $meta->calculate_all_roles
                      : ();
  
      # it's obviously not a role-only subclass if it doesn't do any roles
      return unless @roles;
  
      # loop over all methods that are a part of the current class
      # (not inherited)
      for my $method ( $meta->_get_local_methods ) {
          # always ignore meta
          next if $method->isa('Class::MOP::Method::Meta');
          # we'll deal with attributes below
          next if $method->can('associated_attribute');
          # if the method comes from a role we consumed, ignore it
          next if $meta->can('does_role')
               && $meta->does_role($method->original_package_name);
          # FIXME - this really isn't right. Just because a modifier is
          # defined in a role doesn't mean it isn't _also_ defined in the
          # subclass.
          next if $method->isa('Class::MOP::Method::Wrapped')
               && (
                   (!scalar($method->around_modifiers)
                 || any { $_->has_around_method_modifiers($method->name) } @roles)
                && (!scalar($method->before_modifiers)
                 || any { $_->has_before_method_modifiers($method->name) } @roles)
                && (!scalar($method->after_modifiers)
                 || any { $_->has_after_method_modifiers($method->name) } @roles)
                  );
  
          return 0;
      }
  
      # loop over all attributes that are a part of the current class
      # (not inherited)
      # FIXME - this really isn't right. Just because an attribute is
      # defined in a role doesn't mean it isn't _also_ defined in the
      # subclass.
      for my $attr (map { $meta->get_attribute($_) } $meta->get_attribute_list) {
          next if any { $_->has_attribute($attr->name) } @roles;
  
          return 0;
      }
  
      return 1;
  }
  
  sub _is_package_loaded {
      my ($package) = @_;
      defined $INC{module_notional_filename($package)};
  }
  
  1;
  
  # ABSTRACT: Utilities for working with Moose classes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util - Utilities for working with Moose classes
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    use Moose::Util qw/find_meta does_role search_class_by_role/;
  
    my $meta = find_meta($object) || die "No metaclass found";
  
    if (does_role($object, $role)) {
      print "The object can do $role!\n";
    }
  
    my $class = search_class_by_role($object, 'FooRole');
    print "Nearest class with 'FooRole' is $class\n";
  
  =head1 DESCRIPTION
  
  This module provides a set of utility functions. Many of these
  functions are intended for use in Moose itself or MooseX modules, but
  some of them may be useful for use in your own code.
  
  =head1 EXPORTED FUNCTIONS
  
  =over 4
  
  =item B<find_meta($class_or_obj)>
  
  This method takes a class name or object and attempts to find a
  metaclass for the class, if one exists. It will B<not> create one if it
  does not yet exist.
  
  =item B<does_role($class_or_obj, $role_or_obj)>
  
  Returns true if C<$class_or_obj> does the given C<$role_or_obj>. The role can
  be provided as a name or a L<Moose::Meta::Role> object.
  
  The class must already have a metaclass for this to work. If it doesn't, this
  function simply returns false.
  
  =item B<search_class_by_role($class_or_obj, $role_or_obj)>
  
  Returns the first class in the class's precedence list that does
  C<$role_or_obj>, if any. The role can be either a name or a
  L<Moose::Meta::Role> object.
  
  The class must already have a metaclass for this to work.
  
  =item B<apply_all_roles($applicant, @roles)>
  
  This function applies one or more roles to the given C<$applicant> The
  applicant can be a role name, class name, or object.
  
  The C<$applicant> must already have a metaclass object.
  
  The list of C<@roles> should a list of names or L<Moose::Meta::Role> objects,
  each of which can be followed by an optional hash reference of options
  (C<-excludes> and C<-alias>).
  
  =item B<ensure_all_roles($applicant, @roles)>
  
  This function is similar to C<apply_all_roles>, but only applies roles that
  C<$applicant> does not already consume.
  
  =item B<with_traits($class_name, @role_names)>
  
  This function creates a new class from C<$class_name> with each of
  C<@role_names> applied. It returns the name of the new class.
  
  =item B<get_all_attribute_values($meta, $instance)>
  
  Returns a hash reference containing all of the C<$instance>'s
  attributes. The keys are attribute names.
  
  =item B<get_all_init_args($meta, $instance)>
  
  Returns a hash reference containing all of the C<init_arg> values for
  the instance's attributes. The values are the associated attribute
  values. If an attribute does not have a defined C<init_arg>, it is
  skipped.
  
  This could be useful in cloning an object.
  
  =item B<resolve_metaclass_alias($category, $name, %options)>
  
  =item B<resolve_metatrait_alias($category, $name, %options)>
  
  Resolves a short name to a full class name. Short names are often used
  when specifying the C<metaclass> or C<traits> option for an attribute:
  
      has foo => (
          metaclass => "Bar",
      );
  
  The name resolution mechanism is covered in
  L<Moose/Metaclass and Trait Name Resolution>.
  
  =item B<meta_class_alias($to[, $from])>
  
  =item B<meta_attribute_alias($to[, $from])>
  
  Create an alias from the class C<$from> (or the current package, if
  C<$from> is unspecified), so that
  L<Moose/Metaclass and Trait Name Resolution> works properly.
  
  =item B<english_list(@items)>
  
  Given a list of scalars, turns them into a proper list in English
  ("one and two", "one, two, three, and four"). This is used to help us
  make nicer error messages.
  
  =item B<throw_exception( $class_name, %arguments_to_exception)>
  
  Calls die with an object of Moose::Exception::$class_name, with
  %arguments_to_exception passed as arguments.
  
  =back
  
  =head1 TODO
  
  Here is a list of possible functions to write
  
  =over 4
  
  =item discovering original method from modified method
  
  =item search for origin class of a method or attribute
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_UTIL

$fatpacked{"x86_64-linux-thread-multi/Moose/Util/MetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_UTIL_METAROLE';
  package Moose::Util::MetaRole;
  BEGIN {
    $Moose::Util::MetaRole::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Util::MetaRole::VERSION = '2.1204';
  use strict;
  use warnings;
  use Scalar::Util 'blessed';
  
  use List::MoreUtils qw( all );
  use List::Util qw( first );
  use Moose::Deprecated;
  use Scalar::Util qw( blessed );
  
  use Moose::Util 'throw_exception';
  
  sub apply_metaroles {
      my %args = @_;
  
      my $for = _metathing_for( $args{for} );
  
      if ( $for->isa('Moose::Meta::Role') ) {
          return _make_new_metaclass( $for, $args{role_metaroles}, 'role' );
      }
      else {
          return _make_new_metaclass( $for, $args{class_metaroles}, 'class' );
      }
  }
  
  sub _metathing_for {
      my $passed = shift;
  
      my $found
          = blessed $passed
          ? $passed
          : Class::MOP::class_of($passed);
  
      return $found
          if defined $found
              && blessed $found
              && (   $found->isa('Moose::Meta::Role')
                  || $found->isa('Moose::Meta::Class') );
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  
      throw_exception( InvalidArgPassedToMooseUtilMetaRole => argument => $passed );
  }
  
  sub _make_new_metaclass {
      my $for     = shift;
      my $roles   = shift;
      my $primary = shift;
  
      return $for unless keys %{$roles};
  
      my $new_metaclass
          = exists $roles->{$primary}
          ? _make_new_class( ref $for, $roles->{$primary} )
          : blessed $for;
  
      my %classes;
  
      for my $key ( grep { $_ ne $primary } keys %{$roles} ) {
          my $attr = first {$_}
              map { $for->meta->find_attribute_by_name($_) } (
              $key . '_metaclass',
              $key . '_class'
          );
  
          my $reader = $attr->get_read_method;
  
          $classes{ $attr->init_arg }
              = _make_new_class( $for->$reader(), $roles->{$key} );
      }
  
      my $new_meta = $new_metaclass->reinitialize( $for, %classes );
  
      return $new_meta;
  }
  
  sub apply_base_class_roles {
      my %args = @_;
  
      my $meta = _metathing_for( $args{for} || $args{for_class} );
      throw_exception( CannotApplyBaseClassRolesToRole => params => \%args,
                                                          role   => $meta
                     )
          if $meta->isa('Moose::Meta::Role');
  
      my $new_base = _make_new_class(
          $meta->name,
          $args{roles},
          [ $meta->superclasses() ],
      );
  
      $meta->superclasses($new_base)
          if $new_base ne $meta->name();
  }
  
  sub _make_new_class {
      my $existing_class = shift;
      my $roles          = shift;
      my $superclasses   = shift || [$existing_class];
  
      return $existing_class unless $roles;
  
      my $meta = Class::MOP::Class->initialize($existing_class);
  
      return $existing_class
          if $meta->can('does_role') && all  { $meta->does_role($_) }
                                        grep { !ref $_ } @{$roles};
  
      return Moose::Meta::Class->create_anon_class(
          superclasses => $superclasses,
          roles        => $roles,
          cache        => 1,
      )->name();
  }
  
  1;
  
  # ABSTRACT: Apply roles to any metaclass, as well as the object base class
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util::MetaRole - Apply roles to any metaclass, as well as the object base class
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package MyApp::Moose;
  
    use Moose ();
    use Moose::Exporter;
    use Moose::Util::MetaRole;
  
    use MyApp::Role::Meta::Class;
    use MyApp::Role::Meta::Method::Constructor;
    use MyApp::Role::Object;
  
    Moose::Exporter->setup_import_methods( also => 'Moose' );
  
    sub init_meta {
        shift;
        my %args = @_;
  
        Moose->init_meta(%args);
  
        Moose::Util::MetaRole::apply_metaroles(
            for             => $args{for_class},
            class_metaroles => {
                class       => ['MyApp::Role::Meta::Class'],
                constructor => ['MyApp::Role::Meta::Method::Constructor'],
            },
        );
  
        Moose::Util::MetaRole::apply_base_class_roles(
            for   => $args{for_class},
            roles => ['MyApp::Role::Object'],
        );
  
        return $args{for_class}->meta();
    }
  
  =head1 DESCRIPTION
  
  This utility module is designed to help authors of Moose extensions
  write extensions that are able to cooperate with other Moose
  extensions. To do this, you must write your extensions as roles, which
  can then be dynamically applied to the caller's metaclasses.
  
  This module makes sure to preserve any existing superclasses and roles
  already set for the meta objects, which means that any number of
  extensions can apply roles in any order.
  
  =head1 USAGE
  
  The easiest way to use this module is through L<Moose::Exporter>, which can
  generate the appropriate C<init_meta> method for you, and make sure it is
  called when imported.
  
  =head1 FUNCTIONS
  
  This module provides two functions.
  
  =head2 apply_metaroles( ... )
  
  This function will apply roles to one or more metaclasses for the specified
  class. It will return a new metaclass object for the class or role passed in
  the "for" parameter.
  
  It accepts the following parameters:
  
  =over 4
  
  =item * for => $name
  
  This specifies the class or for which to alter the meta classes. This can be a
  package name, or an appropriate meta-object (a L<Moose::Meta::Class> or
  L<Moose::Meta::Role>).
  
  =item * class_metaroles => \%roles
  
  This is a hash reference specifying which metaroles will be applied to the
  class metaclass and its contained metaclasses and helper classes.
  
  Each key should in turn point to an array reference of role names.
  
  It accepts the following keys:
  
  =over 8
  
  =item class
  
  =item attribute
  
  =item method
  
  =item wrapped_method
  
  =item instance
  
  =item constructor
  
  =item destructor
  
  =item error
  
  =back
  
  =item * role_metaroles => \%roles
  
  This is a hash reference specifying which metaroles will be applied to the
  role metaclass and its contained metaclasses and helper classes.
  
  It accepts the following keys:
  
  =over 8
  
  =item role
  
  =item attribute
  
  =item method
  
  =item required_method
  
  =item conflicting_method
  
  =item application_to_class
  
  =item application_to_role
  
  =item application_to_instance
  
  =item application_role_summation
  
  =item applied_attribute
  
  =back
  
  =back
  
  =head2 apply_base_class_roles( for => $class, roles => \@roles )
  
  This function will apply the specified roles to the object's base class.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_UTIL_METAROLE

$fatpacked{"x86_64-linux-thread-multi/Moose/Util/TypeConstraints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS';
  package Moose::Util::TypeConstraints;
  BEGIN {
    $Moose::Util::TypeConstraints::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Util::TypeConstraints::VERSION = '2.1204';
  use Carp ();
  use List::MoreUtils qw( all any );
  use Scalar::Util qw( blessed reftype );
  use Moose::Exporter;
  use Moose::Deprecated;
  
  ## --------------------------------------------------------
  # Prototyped subs must be predeclared because we have a
  # circular dependency with Moose::Meta::Attribute et. al.
  # so in case of us being use'd first the predeclaration
  # ensures the prototypes are in scope when consumers are
  # compiled.
  
  # dah sugah!
  sub where (&);
  sub via (&);
  sub message (&);
  sub inline_as (&);
  
  ## --------------------------------------------------------
  
  use Moose::Deprecated;
  use Moose::Meta::TypeConstraint;
  use Moose::Meta::TypeConstraint::Union;
  use Moose::Meta::TypeConstraint::Parameterized;
  use Moose::Meta::TypeConstraint::Parameterizable;
  use Moose::Meta::TypeConstraint::Class;
  use Moose::Meta::TypeConstraint::Role;
  use Moose::Meta::TypeConstraint::Enum;
  use Moose::Meta::TypeConstraint::DuckType;
  use Moose::Meta::TypeCoercion;
  use Moose::Meta::TypeCoercion::Union;
  use Moose::Meta::TypeConstraint::Registry;
  
  use Moose::Util 'throw_exception';
  
  Moose::Exporter->setup_import_methods(
      as_is => [
          qw(
              type subtype class_type role_type maybe_type duck_type
              as where message inline_as
              coerce from via
              enum union
              find_type_constraint
              register_type_constraint
              match_on_type )
      ],
  );
  
  ## --------------------------------------------------------
  ## type registry and some useful functions for it
  ## --------------------------------------------------------
  
  my $REGISTRY = Moose::Meta::TypeConstraint::Registry->new;
  
  sub get_type_constraint_registry {$REGISTRY}
  sub list_all_type_constraints    { keys %{ $REGISTRY->type_constraints } }
  
  sub export_type_constraints_as_functions {
      my $pkg = caller();
      no strict 'refs';
      foreach my $constraint ( keys %{ $REGISTRY->type_constraints } ) {
          my $tc = $REGISTRY->get_type_constraint($constraint)
              ->_compiled_type_constraint;
          *{"${pkg}::${constraint}"}
              = sub { $tc->( $_[0] ) ? 1 : undef };    # the undef is for compat
      }
  }
  
  sub create_type_constraint_union {
      _create_type_constraint_union(\@_);
  }
  
  sub create_named_type_constraint_union {
      my $name = shift;
      _create_type_constraint_union($name, \@_);
  }
  
  sub _create_type_constraint_union {
      my $name;
      $name = shift if @_ > 1;
      my @tcs = @{ shift() };
  
      my @type_constraint_names;
  
      if ( scalar @tcs == 1 && _detect_type_constraint_union( $tcs[0] ) ) {
          @type_constraint_names = _parse_type_constraint_union( $tcs[0] );
      }
      else {
          @type_constraint_names = @tcs;
      }
  
      ( scalar @type_constraint_names >= 2 )
          || throw_exception("UnionTakesAtleastTwoTypeNames");
  
      my @type_constraints = map {
          find_or_parse_type_constraint($_)
              || throw_exception( CouldNotLocateTypeConstraintForUnion => type_name => $_ );
      } @type_constraint_names;
  
      my %options = (
        type_constraints => \@type_constraints
      );
      $options{name} = $name if defined $name;
  
      return Moose::Meta::TypeConstraint::Union->new(%options);
  }
  
  
  sub create_parameterized_type_constraint {
      my $type_constraint_name = shift;
      my ( $base_type, $type_parameter )
          = _parse_parameterized_type_constraint($type_constraint_name);
  
      ( defined $base_type && defined $type_parameter )
          || throw_exception( InvalidTypeGivenToCreateParameterizedTypeConstraint => type_name => $type_constraint_name );
  
      if ( $REGISTRY->has_type_constraint($base_type) ) {
          my $base_type_tc = $REGISTRY->get_type_constraint($base_type);
          return _create_parameterized_type_constraint(
              $base_type_tc,
              $type_parameter
          );
      }
      else {
          throw_exception( InvalidBaseTypeGivenToCreateParameterizedTypeConstraint => type_name => $base_type );
      }
  }
  
  sub _create_parameterized_type_constraint {
      my ( $base_type_tc, $type_parameter ) = @_;
      if ( $base_type_tc->can('parameterize') ) {
          return $base_type_tc->parameterize($type_parameter);
      }
      else {
          return Moose::Meta::TypeConstraint::Parameterized->new(
              name   => $base_type_tc->name . '[' . $type_parameter . ']',
              parent => $base_type_tc,
              type_parameter =>
                  find_or_create_isa_type_constraint($type_parameter),
          );
      }
  }
  
  #should we also support optimized checks?
  sub create_class_type_constraint {
      my ( $class, $options ) = @_;
  
  # too early for this check
  #find_type_constraint("ClassName")->check($class)
  #    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
  
      my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
  
      if (my $type = $REGISTRY->get_type_constraint($class)) {
          if (!($type->isa('Moose::Meta::TypeConstraint::Class') && $type->class eq $class)) {
              throw_exception( TypeConstraintIsAlreadyCreated => package_defined_in => $pkg_defined_in,
                                                                 type               => $type
                             );
          }
          else {
              return $type;
          }
      }
  
      my %options = (
          class              => $class,
          name               => $class,
          package_defined_in => $pkg_defined_in,
          %{ $options || {} },    # overrides options from above
      );
  
      $options{name} ||= "__ANON__";
  
      my $tc = Moose::Meta::TypeConstraint::Class->new(%options);
      $REGISTRY->add_type_constraint($tc);
      return $tc;
  }
  
  sub create_role_type_constraint {
      my ( $role, $options ) = @_;
  
  # too early for this check
  #find_type_constraint("ClassName")->check($class)
  #    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
  
      my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
  
      if (my $type = $REGISTRY->get_type_constraint($role)) {
          if (!($type->isa('Moose::Meta::TypeConstraint::Role') && $type->role eq $role)) {
              throw_exception( TypeConstraintIsAlreadyCreated => type               => $type,
                                                                 package_defined_in => $pkg_defined_in
                             );
          }
          else {
              return $type;
          }
      }
  
      my %options = (
          role               => $role,
          name               => $role,
          package_defined_in => $pkg_defined_in,
          %{ $options || {} },
      );
  
      $options{name} ||= "__ANON__";
  
      my $tc = Moose::Meta::TypeConstraint::Role->new(%options);
      $REGISTRY->add_type_constraint($tc);
      return $tc;
  }
  
  sub find_or_create_type_constraint {
      my ( $type_constraint_name, $options_for_anon_type ) = @_;
  
      if ( my $constraint
          = find_or_parse_type_constraint($type_constraint_name) ) {
          return $constraint;
      }
      elsif ( defined $options_for_anon_type ) {
  
          # NOTE:
          # if there is no $options_for_anon_type
          # specified, then we assume they don't
          # want to create one, and return nothing.
  
          # otherwise assume that we should create
          # an ANON type with the $options_for_anon_type
          # options which can be passed in. It should
          # be noted that these don't get registered
          # so we need to return it.
          # - SL
          return Moose::Meta::TypeConstraint->new(
              name => '__ANON__',
              %{$options_for_anon_type}
          );
      }
  
      return;
  }
  
  sub find_or_create_isa_type_constraint {
      my ($type_constraint_name, $options) = @_;
      find_or_parse_type_constraint($type_constraint_name)
          || create_class_type_constraint($type_constraint_name, $options);
  }
  
  sub find_or_create_does_type_constraint {
      my ($type_constraint_name, $options) = @_;
      find_or_parse_type_constraint($type_constraint_name)
          || create_role_type_constraint($type_constraint_name, $options);
  }
  
  sub find_or_parse_type_constraint {
      my $type_constraint_name = normalize_type_constraint_name(shift);
      my $constraint;
  
      if ( $constraint = find_type_constraint($type_constraint_name) ) {
          return $constraint;
      }
      elsif ( _detect_type_constraint_union($type_constraint_name) ) {
          $constraint = create_type_constraint_union($type_constraint_name);
      }
      elsif ( _detect_parameterized_type_constraint($type_constraint_name) ) {
          $constraint
              = create_parameterized_type_constraint($type_constraint_name);
      }
      else {
          return;
      }
  
      $REGISTRY->add_type_constraint($constraint);
      return $constraint;
  }
  
  sub normalize_type_constraint_name {
      my $type_constraint_name = shift;
      $type_constraint_name =~ s/\s//g;
      return $type_constraint_name;
  }
  
  sub _confess {
      my $error = shift;
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      Carp::confess($error);
  }
  
  ## --------------------------------------------------------
  ## exported functions ...
  ## --------------------------------------------------------
  
  sub find_type_constraint {
      my $type = shift;
  
      if ( blessed $type and $type->isa("Moose::Meta::TypeConstraint") ) {
          return $type;
      }
      else {
          return unless $REGISTRY->has_type_constraint($type);
          return $REGISTRY->get_type_constraint($type);
      }
  }
  
  sub register_type_constraint {
      my $constraint = shift;
      throw_exception( CannotRegisterUnnamedTypeConstraint => type => $constraint )
          unless defined $constraint->name;
      $REGISTRY->add_type_constraint($constraint);
      return $constraint;
  }
  
  # type constructors
  
  sub type {
      my $name = shift;
  
      my %p = map { %{$_} } @_;
  
      return _create_type_constraint(
          $name, undef, $p{where}, $p{message},
          $p{inline_as},
      );
  }
  
  sub subtype {
      if ( @_ == 1 && !ref $_[0] ) {
          throw_exception( NoParentGivenToSubtype => name => $_[0] );
      }
  
      # The blessed check is mostly to accommodate MooseX::Types, which
      # uses an object which overloads stringification as a type name.
      my $name = ref $_[0] && !blessed $_[0] ? undef : shift;
  
      my %p = map { %{$_} } @_;
  
      # subtype Str => where { ... };
      if ( !exists $p{as} ) {
          $p{as} = $name;
          $name = undef;
      }
  
      return _create_type_constraint(
          $name, $p{as}, $p{where}, $p{message},
          $p{inline_as},
      );
  }
  
  sub class_type {
      create_class_type_constraint(@_);
  }
  
  sub role_type ($;$) {
      create_role_type_constraint(@_);
  }
  
  sub maybe_type {
      my ($type_parameter) = @_;
  
      register_type_constraint(
          $REGISTRY->get_type_constraint('Maybe')->parameterize($type_parameter)
      );
  }
  
  sub duck_type {
      my ( $type_name, @methods ) = @_;
      if ( ref $type_name eq 'ARRAY' && !@methods ) {
          @methods   = ($type_name);
          $type_name = undef;
      }
      if ( @methods == 1 && ref $methods[0] eq 'ARRAY' ) {
          @methods = @{ $methods[0] };
      }
      else {
          Moose::Deprecated::deprecated(
              feature => 'non-arrayref form of duck_type',
              message => "Passing a list of values to duck_type is deprecated. "
                       . "The method names should be wrapped in an arrayref.",
          );
      }
  
      register_type_constraint(
          create_duck_type_constraint(
              $type_name,
              \@methods,
          )
      );
  }
  
  sub coerce {
      my ( $type_name, @coercion_map ) = @_;
      _install_type_coercions( $type_name, \@coercion_map );
  }
  
  # The trick of returning @_ lets us avoid having to specify a
  # prototype. Perl will parse this:
  #
  # subtype 'Foo'
  #     => as 'Str'
  #     => where { ... }
  #
  # as this:
  #
  # subtype( 'Foo', as( 'Str', where { ... } ) );
  #
  # If as() returns all its extra arguments, this just works, and
  # preserves backwards compatibility.
  sub as { { as => shift }, @_ }
  sub where (&)       { { where       => $_[0] } }
  sub message (&)     { { message     => $_[0] } }
  sub inline_as (&)   { { inline_as   => $_[0] } }
  
  sub from    {@_}
  sub via (&) { $_[0] }
  
  sub enum {
      my ( $type_name, @values ) = @_;
  
      # NOTE:
      # if only an array-ref is passed then
      # you get an anon-enum
      # - SL
      if ( ref $type_name eq 'ARRAY' ) {
          @values == 0
              || throw_exception( EnumCalledWithAnArrayRefAndAdditionalArgs => array => $type_name,
                                                                               args  => \@values
                                );
          @values    = ($type_name);
          $type_name = undef;
      }
      if ( @values == 1 && ref $values[0] eq 'ARRAY' ) {
          @values = @{ $values[0] };
      }
      else {
          Moose::Deprecated::deprecated(
              feature => 'non-arrayref form of enum',
              message => "Passing a list of values to enum is deprecated. "
                       . "Enum values should be wrapped in an arrayref.",
          );
      }
  
      register_type_constraint(
          create_enum_type_constraint(
              $type_name,
              \@values,
          )
      );
  }
  
  sub union {
    my ( $type_name, @constraints ) = @_;
    if ( ref $type_name eq 'ARRAY' ) {
      @constraints == 0
        || throw_exception( UnionCalledWithAnArrayRefAndAdditionalArgs => array => $type_name,
                                                                          args  => \@constraints
                          );
      @constraints = @$type_name;
      $type_name   = undef;
    }
    if ( @constraints == 1 && ref $constraints[0] eq 'ARRAY' ) {
      @constraints = @{ $constraints[0] };
    }
    if ( defined $type_name ) {
      return register_type_constraint(
        create_named_type_constraint_union( $type_name, @constraints )
      );
    }
    return create_type_constraint_union( @constraints );
  }
  
  sub create_enum_type_constraint {
      my ( $type_name, $values ) = @_;
  
      Moose::Meta::TypeConstraint::Enum->new(
          name => $type_name || '__ANON__',
          values => $values,
      );
  }
  
  sub create_duck_type_constraint {
      my ( $type_name, $methods ) = @_;
  
      Moose::Meta::TypeConstraint::DuckType->new(
          name => $type_name || '__ANON__',
          methods => $methods,
      );
  }
  
  sub match_on_type {
      my ($to_match, @cases) = @_;
      my $default;
      if (@cases % 2 != 0) {
          $default = pop @cases;
          (ref $default eq 'CODE')
              || throw_exception( DefaultToMatchOnTypeMustBeCodeRef => to_match            => $to_match,
                                                                       default_action      => $default,
                                                                       cases_to_be_matched => \@cases
                                );
      }
      while (@cases) {
          my ($type, $action) = splice @cases, 0, 2;
  
          unless (blessed $type && $type->isa('Moose::Meta::TypeConstraint')) {
              $type = find_or_parse_type_constraint($type)
                   || throw_exception( CannotFindTypeGivenToMatchOnType => type     => $type,
                                                                           to_match => $to_match,
                                                                           action   => $action
                                     );
          }
  
          (ref $action eq 'CODE')
              || throw_exception( MatchActionMustBeACodeRef => type     => $type,
                                                               action   => $action,
                                                               to_match => $to_match
                                );
  
          if ($type->check($to_match)) {
              local $_ = $to_match;
              return $action->($to_match);
          }
      }
      (defined $default)
          || throw_exception( NoCasesMatched => to_match            => $to_match,
                                                cases_to_be_matched => \@cases
                            );
      {
          local $_ = $to_match;
          return $default->($to_match);
      }
  }
  
  
  ## --------------------------------------------------------
  ## desugaring functions ...
  ## --------------------------------------------------------
  
  sub _create_type_constraint ($$$;$) {
      my $name      = shift;
      my $parent    = shift;
      my $check     = shift;
      my $message   = shift;
      my $inlined   = shift;
  
      my $pkg_defined_in = scalar( caller(1) );
  
      if ( defined $name ) {
          my $type = $REGISTRY->get_type_constraint($name);
  
          ( $type->_package_defined_in eq $pkg_defined_in )
              || throw_exception( TypeConstraintIsAlreadyCreated => package_defined_in => $pkg_defined_in,
                                                                    type               => $type
                                )
              if defined $type;
  
          if( $name !~ /^[\w:\.]+$/ ) {
  	    throw_exception( InvalidNameForType => name => $name );
          }
      }
  
      my %opts = (
          name               => $name,
          package_defined_in => $pkg_defined_in,
  
          ( $check     ? ( constraint => $check )     : () ),
          ( $message   ? ( message    => $message )   : () ),
          ( $inlined   ? ( inlined    => $inlined )   : () ),
      );
  
      my $constraint;
      if (
          defined $parent
          and $parent
          = blessed $parent
          ? $parent
          : find_or_create_isa_type_constraint($parent)
          ) {
          $constraint = $parent->create_child_type(%opts);
      }
      else {
          $constraint = Moose::Meta::TypeConstraint->new(%opts);
      }
  
      $REGISTRY->add_type_constraint($constraint)
          if defined $name;
  
      return $constraint;
  }
  
  sub _install_type_coercions ($$) {
      my ( $type_name, $coercion_map ) = @_;
      my $type = find_type_constraint($type_name);
      ( defined $type )
          || throw_exception( CannotFindType => type_name => $type_name );
  
      if ( $type->has_coercion ) {
          $type->coercion->add_type_coercions(@$coercion_map);
      }
      else {
          my $type_coercion = Moose::Meta::TypeCoercion->new(
              type_coercion_map => $coercion_map,
              type_constraint   => $type
          );
          $type->coercion($type_coercion);
      }
  }
  
  ## --------------------------------------------------------
  ## type notation parsing ...
  ## --------------------------------------------------------
  
  {
  
      # All I have to say is mugwump++ cause I know
      # do not even have enough regexp-fu to be able
      # to have written this (I can only barely
      # understand it as it is)
      # - SL
  
      use re "eval";
  
      my $valid_chars = qr{[\w:\.]};
      my $type_atom   = qr{ (?>$valid_chars+) }x;
      my $ws          = qr{ (?>\s*) }x;
      my $op_union    = qr{ $ws \| $ws }x;
  
      my ($type, $type_capture_parts, $type_with_parameter, $union, $any);
      if (Class::MOP::IS_RUNNING_ON_5_10) {
          my $type_pattern
              = q{  (?&type_atom)  (?: \[ (?&ws)  (?&any)  (?&ws) \] )? };
          my $type_capture_parts_pattern
              = q{ ((?&type_atom)) (?: \[ (?&ws) ((?&any)) (?&ws) \] )? };
          my $type_with_parameter_pattern
              = q{  (?&type_atom)      \[ (?&ws)  (?&any)  (?&ws) \]    };
          my $union_pattern
              = q{ (?&type) (?> (?: (?&op_union) (?&type) )+ ) };
          my $any_pattern
              = q{ (?&type) | (?&union) };
  
          my $defines = qr{(?(DEFINE)
              (?<valid_chars>         $valid_chars)
              (?<type_atom>           $type_atom)
              (?<ws>                  $ws)
              (?<op_union>            $op_union)
              (?<type>                $type_pattern)
              (?<type_capture_parts>  $type_capture_parts_pattern)
              (?<type_with_parameter> $type_with_parameter_pattern)
              (?<union>               $union_pattern)
              (?<any>                 $any_pattern)
          )}x;
  
          $type                = qr{ $type_pattern                $defines }x;
          $type_capture_parts  = qr{ $type_capture_parts_pattern  $defines }x;
          $type_with_parameter = qr{ $type_with_parameter_pattern $defines }x;
          $union               = qr{ $union_pattern               $defines }x;
          $any                 = qr{ $any_pattern                 $defines }x;
      }
      else {
          $type
              = qr{  $type_atom  (?: \[ $ws  (??{$any})  $ws \] )? }x;
          $type_capture_parts
              = qr{ ($type_atom) (?: \[ $ws ((??{$any})) $ws \] )? }x;
          $type_with_parameter
              = qr{  $type_atom      \[ $ws  (??{$any})  $ws \]    }x;
          $union
              = qr{ $type (?> (?: $op_union $type )+ ) }x;
          $any
              = qr{ $type | $union }x;
      }
  
  
      sub _parse_parameterized_type_constraint {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{ $type_capture_parts }x;
          return ( $1, $2 );
      }
  
      sub _detect_parameterized_type_constraint {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{ ^ $type_with_parameter $ }x;
      }
  
      sub _parse_type_constraint_union {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          my $given = shift;
          my @rv;
          while ( $given =~ m{ \G (?: $op_union )? ($type) }gcx ) {
              push @rv => $1;
          }
          ( pos($given) eq length($given) )
              || throw_exception( CouldNotParseType => type     => $given,
                                                       position => pos($given)
                                );
          @rv;
      }
  
      sub _detect_type_constraint_union {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{^ $type $op_union $type ( $op_union .* )? $}x;
      }
  }
  
  ## --------------------------------------------------------
  # define some basic built-in types
  ## --------------------------------------------------------
  
  # By making these classes immutable before creating all the types in
  # Moose::Util::TypeConstraints::Builtin , we avoid repeatedly calling the slow
  # MOP-based accessors.
  $_->make_immutable(
      inline_constructor => 1,
      constructor_name   => "_new",
  
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { Class::MOP::class_of($_) }
      qw(
      Moose::Meta::TypeConstraint
      Moose::Meta::TypeConstraint::Union
      Moose::Meta::TypeConstraint::Parameterized
      Moose::Meta::TypeConstraint::Parameterizable
      Moose::Meta::TypeConstraint::Class
      Moose::Meta::TypeConstraint::Role
      Moose::Meta::TypeConstraint::Enum
      Moose::Meta::TypeConstraint::DuckType
      Moose::Meta::TypeConstraint::Registry
  );
  
  require Moose::Util::TypeConstraints::Builtins;
  Moose::Util::TypeConstraints::Builtins::define_builtins($REGISTRY);
  
  my @PARAMETERIZABLE_TYPES
      = map { $REGISTRY->get_type_constraint($_) } qw[ScalarRef ArrayRef HashRef Maybe];
  
  sub get_all_parameterizable_types {@PARAMETERIZABLE_TYPES}
  
  sub add_parameterizable_type {
      my $type = shift;
      ( blessed $type
              && $type->isa('Moose::Meta::TypeConstraint::Parameterizable') )
          || throw_exception( AddParameterizableTypeTakesParameterizableType => type_name => $type );
  
      push @PARAMETERIZABLE_TYPES => $type;
  }
  
  ## --------------------------------------------------------
  # end of built-in types ...
  ## --------------------------------------------------------
  
  {
      my @BUILTINS = list_all_type_constraints();
      sub list_all_builtin_type_constraints {@BUILTINS}
  }
  
  1;
  
  # ABSTRACT: Type constraint system for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util::TypeConstraints - Type constraint system for Moose
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    use Moose::Util::TypeConstraints;
  
    subtype 'Natural',
        as 'Int',
        where { $_ > 0 };
  
    subtype 'NaturalLessThanTen',
        as 'Natural',
        where { $_ < 10 },
        message { "This number ($_) is not less than ten!" };
  
    coerce 'Num',
        from 'Str',
        via { 0+$_ };
  
    class_type 'DateTimeClass', { class => 'DateTime' };
  
    role_type 'Barks', { role => 'Some::Library::Role::Barks' };
  
    enum 'RGBColors', [qw(red green blue)];
  
    union 'StringOrArray', [qw( String ArrayRef )];
  
    no Moose::Util::TypeConstraints;
  
  =head1 DESCRIPTION
  
  This module provides Moose with the ability to create custom type
  constraints to be used in attribute definition.
  
  =head2 Important Caveat
  
  This is B<NOT> a type system for Perl 5. These are type constraints,
  and they are not used by Moose unless you tell it to. No type
  inference is performed, expressions are not typed, etc. etc. etc.
  
  A type constraint is at heart a small "check if a value is valid"
  function. A constraint can be associated with an attribute. This
  simplifies parameter validation, and makes your code clearer to read,
  because you can refer to constraints by name.
  
  =head2 Slightly Less Important Caveat
  
  It is B<always> a good idea to quote your type names.
  
  This prevents Perl from trying to execute the call as an indirect
  object call. This can be an issue when you have a subtype with the
  same name as a valid class.
  
  For instance:
  
    subtype DateTime => as Object => where { $_->isa('DateTime') };
  
  will I<just work>, while this:
  
    use DateTime;
    subtype DateTime => as Object => where { $_->isa('DateTime') };
  
  will fail silently and cause many headaches. The simple way to solve
  this, as well as future proof your subtypes from classes which have
  yet to have been created, is to quote the type name:
  
    use DateTime;
    subtype 'DateTime', as 'Object', where { $_->isa('DateTime') };
  
  =head2 Default Type Constraints
  
  This module also provides a simple hierarchy for Perl 5 types, here is
  that hierarchy represented visually.
  
    Any
        Item
            Bool
            Maybe[`a]
            Undef
            Defined
                Value
                    Str
                        Num
                            Int
                        ClassName
                        RoleName
                Ref
                    ScalarRef[`a]
                    ArrayRef[`a]
                    HashRef[`a]
                    CodeRef
                    RegexpRef
                    GlobRef
                    FileHandle
                    Object
  
  B<NOTE:> Any type followed by a type parameter C<[`a]> can be
  parameterized, this means you can say:
  
    ArrayRef[Int]    # an array of integers
    HashRef[CodeRef] # a hash of str to CODE ref mappings
    ScalarRef[Int]   # a reference to an integer
    Maybe[Str]       # value may be a string, may be undefined
  
  If Moose finds a name in brackets that it does not recognize as an
  existing type, it assumes that this is a class name, for example
  C<ArrayRef[DateTime]>.
  
  B<NOTE:> Unless you parameterize a type, then it is invalid to include
  the square brackets. I.e. C<ArrayRef[]> will be treated as a new type
  name, I<not> as a parameterization of C<ArrayRef>.
  
  B<NOTE:> The C<Undef> type constraint for the most part works
  correctly now, but edge cases may still exist, please use it
  sparingly.
  
  B<NOTE:> The C<ClassName> type constraint does a complex package
  existence check. This means that your class B<must> be loaded for this
  type constraint to pass.
  
  B<NOTE:> The C<RoleName> constraint checks a string is a I<package
  name> which is a role, like C<'MyApp::Role::Comparable'>.
  
  =head2 Type Constraint Naming
  
  Type name declared via this module can only contain alphanumeric
  characters, colons (:), and periods (.).
  
  Since the types created by this module are global, it is suggested
  that you namespace your types just as you would namespace your
  modules. So instead of creating a I<Color> type for your
  B<My::Graphics> module, you would call the type
  I<My::Graphics::Types::Color> instead.
  
  =head2 Use with Other Constraint Modules
  
  This module can play nicely with other constraint modules with some
  slight tweaking. The C<where> clause in types is expected to be a
  C<CODE> reference which checks its first argument and returns a
  boolean. Since most constraint modules work in a similar way, it
  should be simple to adapt them to work with Moose.
  
  For instance, this is how you could use it with
  L<Declare::Constraints::Simple> to declare a completely new type.
  
    type 'HashOfArrayOfObjects',
        where {
            IsHashRef(
                -keys   => HasLength,
                -values => IsArrayRef(IsObject)
            )->(@_);
        };
  
  For more examples see the F<t/examples/example_w_DCS.t> test
  file.
  
  Here is an example of using L<Test::Deep> and its non-test
  related C<eq_deeply> function.
  
    type 'ArrayOfHashOfBarsAndRandomNumbers',
        where {
            eq_deeply($_,
                array_each(subhashof({
                    bar           => isa('Bar'),
                    random_number => ignore()
                })))
          };
  
  For a complete example see the
  F<t/examples/example_w_TestDeep.t> test file.
  
  =head2 Error messages
  
  Type constraints can also specify custom error messages, for when they fail to
  validate. This is provided as just another coderef, which receives the invalid
  value in C<$_>, as in:
  
    subtype 'PositiveInt',
         as 'Int',
         where { $_ > 0 },
         message { "$_ is not a positive integer!" };
  
  If no message is specified, a default message will be used, which indicates
  which type constraint was being used and what value failed. If
  L<Devel::PartialDump> (version 0.14 or higher) is installed, it will be used to
  display the invalid value, otherwise it will just be printed as is.
  
  =head1 FUNCTIONS
  
  =head2 Type Constraint Constructors
  
  The following functions are used to create type constraints.  They
  will also register the type constraints your create in a global
  registry that is used to look types up by name.
  
  See the L</SYNOPSIS> for an example of how to use these.
  
  =over 4
  
  =item B<< subtype 'Name', as 'Parent', where { } ... >>
  
  This creates a named subtype.
  
  If you provide a parent that Moose does not recognize, it will
  automatically create a new class type constraint for this name.
  
  When creating a named type, the C<subtype> function should either be
  called with the sugar helpers (C<where>, C<message>, etc), or with a
  name and a hashref of parameters:
  
   subtype( 'Foo', { where => ..., message => ... } );
  
  The valid hashref keys are C<as> (the parent), C<where>, C<message>,
  and C<inline_as>.
  
  =item B<< subtype as 'Parent', where { } ... >>
  
  This creates an unnamed subtype and will return the type
  constraint meta-object, which will be an instance of
  L<Moose::Meta::TypeConstraint>.
  
  When creating an anonymous type, the C<subtype> function should either
  be called with the sugar helpers (C<where>, C<message>, etc), or with
  just a hashref of parameters:
  
   subtype( { where => ..., message => ... } );
  
  =item B<class_type ($class, ?$options)>
  
  Creates a new subtype of C<Object> with the name C<$class> and the
  metaclass L<Moose::Meta::TypeConstraint::Class>.
  
    # Create a type called 'Box' which tests for objects which ->isa('Box')
    class_type 'Box';
  
  By default, the name of the type and the name of the class are the same, but
  you can specify both separately.
  
    # Create a type called 'Box' which tests for objects which ->isa('ObjectLibrary::Box');
    class_type 'Box', { class => 'ObjectLibrary::Box' };
  
  =item B<role_type ($role, ?$options)>
  
  Creates a C<Role> type constraint with the name C<$role> and the
  metaclass L<Moose::Meta::TypeConstraint::Role>.
  
    # Create a type called 'Walks' which tests for objects which ->does('Walks')
    role_type 'Walks';
  
  By default, the name of the type and the name of the role are the same, but
  you can specify both separately.
  
    # Create a type called 'Walks' which tests for objects which ->does('MooseX::Role::Walks');
    role_type 'Walks', { role => 'MooseX::Role::Walks' };
  
  =item B<maybe_type ($type)>
  
  Creates a type constraint for either C<undef> or something of the
  given type.
  
  =item B<duck_type ($name, \@methods)>
  
  This will create a subtype of Object and test to make sure the value
  C<can()> do the methods in C<\@methods>.
  
  This is intended as an easy way to accept non-Moose objects that
  provide a certain interface. If you're using Moose classes, we
  recommend that you use a C<requires>-only Role instead.
  
  =item B<duck_type (\@methods)>
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@methods> pair, this will create an unnamed duck type.
  This can be used in an attribute definition like so:
  
    has 'cache' => (
        is  => 'ro',
        isa => duck_type( [qw( get_set )] ),
    );
  
  =item B<enum ($name, \@values)>
  
  This will create a basic subtype for a given set of strings.
  The resulting constraint will be a subtype of C<Str> and
  will match any of the items in C<\@values>. It is case sensitive.
  See the L</SYNOPSIS> for a simple example.
  
  B<NOTE:> This is not a true proper enum type, it is simply
  a convenient constraint builder.
  
  =item B<enum (\@values)>
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@values> pair, this will create an unnamed enum. This
  can then be used in an attribute definition like so:
  
    has 'sort_order' => (
        is  => 'ro',
        isa => enum([qw[ ascending descending ]]),
    );
  
  =item B<union ($name, \@constraints)>
  
  This will create a basic subtype where any of the provided constraints
  may match in order to satisfy this constraint.
  
  =item B<union (\@constraints)>
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@constraints> pair, this will create an unnamed union.
  This can then be used in an attribute definition like so:
  
    has 'items' => (
        is => 'ro',
        isa => union([qw[ Str ArrayRef ]]),
    );
  
  This is similar to the existing string union:
  
    isa => 'Str|ArrayRef'
  
  except that it supports anonymous elements as child constraints:
  
    has 'color' => (
      isa => 'ro',
      isa => union([ 'Int',  enum([qw[ red green blue ]]) ]),
    );
  
  =item B<as 'Parent'>
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a single argument, which is the name of a parent type.
  
  =item B<where { ... }>
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a subroutine reference as an argument. When the type
  constraint is tested, the reference is run with the value to be tested
  in C<$_>. This reference should return true or false to indicate
  whether or not the constraint check passed.
  
  =item B<message { ... }>
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a subroutine reference as an argument. When the type
  constraint fails, then the code block is run with the value provided
  in C<$_>. This reference should return a string, which will be used in
  the text of the exception thrown.
  
  =item B<inline_as { ... }>
  
  This can be used to define a "hand optimized" inlinable version of your type
  constraint.
  
  You provide a subroutine which will be called I<as a method> on a
  L<Moose::Meta::TypeConstraint> object. It will receive a single parameter, the
  name of the variable to check, typically something like C<"$_"> or C<"$_[0]">.
  
  The subroutine should return a code string suitable for inlining. You can
  assume that the check will be wrapped in parentheses when it is inlined.
  
  The inlined code should include any checks that your type's parent types
  do. If your parent type constraint defines its own inlining, you can simply use
  that to avoid repeating code. For example, here is the inlining code for the
  C<Value> type, which is a subtype of C<Defined>:
  
      sub {
          $_[0]->parent()->_inline_check($_[1])
          . ' && !ref(' . $_[1] . ')'
      }
  
  =item B<< type 'Name', where { } ... >>
  
  This creates a base type, which has no parent.
  
  The C<type> function should either be called with the sugar helpers
  (C<where>, C<message>, etc), or with a name and a hashref of
  parameters:
  
    type( 'Foo', { where => ..., message => ... } );
  
  The valid hashref keys are C<where>, C<message>, and C<inlined_as>.
  
  =back
  
  =head2 Type Constraint Utilities
  
  =over 4
  
  =item B<< match_on_type $value => ( $type => \&action, ... ?\&default ) >>
  
  This is a utility function for doing simple type based dispatching similar to
  match/case in OCaml and case/of in Haskell. It is not as featureful as those
  languages, nor does not it support any kind of automatic destructuring
  bind. Here is a simple Perl pretty printer dispatching over the core Moose
  types.
  
    sub ppprint {
        my $x = shift;
        match_on_type $x => (
            HashRef => sub {
                my $hash = shift;
                '{ '
                    . (
                    join ", " => map { $_ . ' => ' . ppprint( $hash->{$_} ) }
                        sort keys %$hash
                    ) . ' }';
            },
            ArrayRef => sub {
                my $array = shift;
                '[ ' . ( join ", " => map { ppprint($_) } @$array ) . ' ]';
            },
            CodeRef   => sub {'sub { ... }'},
            RegexpRef => sub { 'qr/' . $_ . '/' },
            GlobRef   => sub { '*' . B::svref_2object($_)->NAME },
            Object    => sub { $_->can('to_string') ? $_->to_string : $_ },
            ScalarRef => sub { '\\' . ppprint( ${$_} ) },
            Num       => sub {$_},
            Str       => sub { '"' . $_ . '"' },
            Undef     => sub {'undef'},
            => sub { die "I don't know what $_ is" }
        );
    }
  
  Or a simple JSON serializer:
  
    sub to_json {
        my $x = shift;
        match_on_type $x => (
            HashRef => sub {
                my $hash = shift;
                '{ '
                    . (
                    join ", " =>
                        map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                        sort keys %$hash
                    ) . ' }';
            },
            ArrayRef => sub {
                my $array = shift;
                '[ ' . ( join ", " => map { to_json($_) } @$array ) . ' ]';
            },
            Num   => sub {$_},
            Str   => sub { '"' . $_ . '"' },
            Undef => sub {'null'},
            => sub { die "$_ is not acceptable json type" }
        );
    }
  
  The matcher is done by mapping a C<$type> to an C<\&action>. The C<$type> can
  be either a string type or a L<Moose::Meta::TypeConstraint> object, and
  C<\&action> is a subroutine reference. This function will dispatch on the
  first match for C<$value>. It is possible to have a catch-all by providing an
  additional subroutine reference as the final argument to C<match_on_type>.
  
  =back
  
  =head2 Type Coercion Constructors
  
  You can define coercions for type constraints, which allow you to
  automatically transform values to something valid for the type
  constraint. If you ask your accessor to coerce, then Moose will run
  the type-coercion code first, followed by the type constraint
  check. This feature should be used carefully as it is very powerful
  and could easily take off a limb if you are not careful.
  
  See the L</SYNOPSIS> for an example of how to use these.
  
  =over 4
  
  =item B<< coerce 'Name', from 'OtherName', via { ... }  >>
  
  This defines a coercion from one type to another. The C<Name> argument
  is the type you are coercing I<to>.
  
  To define multiple coercions, supply more sets of from/via pairs:
  
    coerce 'Name',
      from 'OtherName', via { ... },
      from 'ThirdName', via { ... };
  
  =item B<from 'OtherName'>
  
  This is just sugar for the type coercion construction syntax.
  
  It takes a single type name (or type object), which is the type being
  coerced I<from>.
  
  =item B<via { ... }>
  
  This is just sugar for the type coercion construction syntax.
  
  It takes a subroutine reference. This reference will be called with
  the value to be coerced in C<$_>. It is expected to return a new value
  of the proper type for the coercion.
  
  =back
  
  =head2 Creating and Finding Type Constraints
  
  These are additional functions for creating and finding type
  constraints. Most of these functions are not available for
  importing. The ones that are importable as specified.
  
  =over 4
  
  =item B<find_type_constraint($type_name)>
  
  This function can be used to locate the L<Moose::Meta::TypeConstraint>
  object for a named type.
  
  This function is importable.
  
  =item B<register_type_constraint($type_object)>
  
  This function will register a L<Moose::Meta::TypeConstraint> with the
  global type registry.
  
  This function is importable.
  
  =item B<normalize_type_constraint_name($type_constraint_name)>
  
  This method takes a type constraint name and returns the normalized
  form. This removes any whitespace in the string.
  
  =item B<create_type_constraint_union($pipe_separated_types | @type_constraint_names)>
  
  =item B<create_named_type_constraint_union($name, $pipe_separated_types | @type_constraint_names)>
  
  This can take a union type specification like C<'Int|ArrayRef[Int]'>,
  or a list of names. It returns a new
  L<Moose::Meta::TypeConstraint::Union> object.
  
  =item B<create_parameterized_type_constraint($type_name)>
  
  Given a C<$type_name> in the form of C<'BaseType[ContainerType]'>,
  this will create a new L<Moose::Meta::TypeConstraint::Parameterized>
  object. The C<BaseType> must already exist as a parameterizable
  type.
  
  =item B<create_class_type_constraint($class, $options)>
  
  Given a class name this function will create a new
  L<Moose::Meta::TypeConstraint::Class> object for that class name.
  
  The C<$options> is a hash reference that will be passed to the
  L<Moose::Meta::TypeConstraint::Class> constructor (as a hash).
  
  =item B<create_role_type_constraint($role, $options)>
  
  Given a role name this function will create a new
  L<Moose::Meta::TypeConstraint::Role> object for that role name.
  
  The C<$options> is a hash reference that will be passed to the
  L<Moose::Meta::TypeConstraint::Role> constructor (as a hash).
  
  =item B<create_enum_type_constraint($name, $values)>
  
  Given a enum name this function will create a new
  L<Moose::Meta::TypeConstraint::Enum> object for that enum name.
  
  =item B<create_duck_type_constraint($name, $methods)>
  
  Given a duck type name this function will create a new
  L<Moose::Meta::TypeConstraint::DuckType> object for that enum name.
  
  =item B<find_or_parse_type_constraint($type_name)>
  
  Given a type name, this first attempts to find a matching constraint
  in the global registry.
  
  If the type name is a union or parameterized type, it will create a
  new object of the appropriate, but if given a "regular" type that does
  not yet exist, it simply returns false.
  
  When given a union or parameterized type, the member or base type must
  already exist.
  
  If it creates a new union or parameterized type, it will add it to the
  global registry.
  
  =item B<find_or_create_isa_type_constraint($type_name)>
  
  =item B<find_or_create_does_type_constraint($type_name)>
  
  These functions will first call C<find_or_parse_type_constraint>. If
  that function does not return a type, a new type object will
  be created.
  
  The C<isa> variant will use C<create_class_type_constraint> and the
  C<does> variant will use C<create_role_type_constraint>.
  
  =item B<get_type_constraint_registry>
  
  Returns the L<Moose::Meta::TypeConstraint::Registry> object which
  keeps track of all type constraints.
  
  =item B<list_all_type_constraints>
  
  This will return a list of type constraint names in the global
  registry. You can then fetch the actual type object using
  C<find_type_constraint($type_name)>.
  
  =item B<list_all_builtin_type_constraints>
  
  This will return a list of builtin type constraints, meaning those
  which are defined in this module. See the L<Default Type Constraints>
  section for a complete list.
  
  =item B<export_type_constraints_as_functions>
  
  This will export all the current type constraints as functions into
  the caller's namespace (C<Int()>, C<Str()>, etc). Right now, this is
  mostly used for testing, but it might prove useful to others.
  
  =item B<get_all_parameterizable_types>
  
  This returns all the parameterizable types that have been registered,
  as a list of type objects.
  
  =item B<add_parameterizable_type($type)>
  
  Adds C<$type> to the list of parameterizable types
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS

$fatpacked{"x86_64-linux-thread-multi/Moose/Util/TypeConstraints/Builtins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS';
  package Moose::Util::TypeConstraints::Builtins;
  BEGIN {
    $Moose::Util::TypeConstraints::Builtins::AUTHORITY = 'cpan:STEVAN';
  }
  $Moose::Util::TypeConstraints::Builtins::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Class::Load qw( is_class_loaded );
  use List::MoreUtils ();
  use Scalar::Util qw( blessed looks_like_number reftype );
  
  sub type { goto &Moose::Util::TypeConstraints::type }
  sub subtype { goto &Moose::Util::TypeConstraints::subtype }
  sub as { goto &Moose::Util::TypeConstraints::as }
  sub where (&) { goto &Moose::Util::TypeConstraints::where }
  sub inline_as (&) { goto &Moose::Util::TypeConstraints::inline_as }
  
  sub define_builtins {
      my $registry = shift;
  
      type 'Any'    # meta-type including all
          => where {1}
          => inline_as { '1' };
  
      subtype 'Item'  # base type
          => as 'Any'
          => inline_as { '1' };
  
      subtype 'Undef'
          => as 'Item'
          => where { !defined($_) }
          => inline_as {
              '!defined(' . $_[1] . ')'
          };
  
      subtype 'Defined'
          => as 'Item'
          => where { defined($_) }
          => inline_as {
              'defined(' . $_[1] . ')'
          };
  
      subtype 'Bool'
          => as 'Item'
          => where { !defined($_) || $_ eq "" || "$_" eq '1' || "$_" eq '0' }
          => inline_as {
              '('
                  . '!defined(' . $_[1] . ') '
                  . '|| ' . $_[1] . ' eq "" '
                  . '|| (' . $_[1] . '."") eq "1" '
                  . '|| (' . $_[1] . '."") eq "0"'
              . ')'
          };
  
      subtype 'Value'
          => as 'Defined'
          => where { !ref($_) }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && !ref(' . $_[1] . ')'
          };
  
      subtype 'Ref'
          => as 'Defined'
          => where { ref($_) }
              # no need to call parent - ref also checks for definedness
          => inline_as { 'ref(' . $_[1] . ')' };
  
      subtype 'Str'
          => as 'Value'
          => where { ref(\$_) eq 'SCALAR' || ref(\(my $val = $_)) eq 'SCALAR' }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && ('
                  . 'ref(\\' . $_[1] . ') eq "SCALAR"'
                  . ' || ref(\\(my $val = ' . $_[1] . ')) eq "SCALAR"'
              . ')'
          };
  
      my $value_type = Moose::Util::TypeConstraints::find_type_constraint('Value');
      subtype 'Num'
          => as 'Str'
          => where {
          my $val = $_;
          ($val =~ /\A[+-]?[0-9]+\z/) ||
          ( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
          (?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
          [0-9]*                                #matches 0-9 zero or more times
          (?:\.[0-9]+)?                         #matches optional .89 or nothing
              (?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
          \z/x );
             }
          => inline_as {
              # the long Str tests are redundant here
          #storing $_[1] in a temporary value,
          #so that $_[1] won't get converted to a string for regex match
          #see t/attributes/numeric_defaults.t for more details
          'my $val = '.$_[1].';'.
          $value_type->_inline_check('$val')
          .' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
          . '$val =~ /\A(?:[+-]?)               #matches optional +- in the beginning
                  (?=[0-9]|\.[0-9])                 #matches previous +- only if there is something like 3 or .3
                  [0-9]*                            #matches 0-9 zero or more times
                  (?:\.[0-9]+)?                     #matches optional .89 or nothing
                  (?:[Ee](?:[+-]?[0-9]+))?          #matches E1 or e1 or e-1 or e+1 etc
                  \z/x ); '
          };
  
      subtype 'Int'
          => as 'Num'
          => where { (my $val = $_) =~ /\A-?[0-9]+\z/ }
          => inline_as {
              $value_type->_inline_check($_[1])
              . ' && (my $val = ' . $_[1] . ') =~ /\A-?[0-9]+\z/'
          };
  
      subtype 'CodeRef'
          => as 'Ref'
          => where { ref($_) eq 'CODE' }
          => inline_as { 'ref(' . $_[1] . ') eq "CODE"' };
  
      subtype 'RegexpRef'
          => as 'Ref'
          => where( \&_RegexpRef )
          => inline_as {
              'Moose::Util::TypeConstraints::Builtins::_RegexpRef(' . $_[1] . ')'
          };
  
      subtype 'GlobRef'
          => as 'Ref'
          => where { ref($_) eq 'GLOB' }
          => inline_as { 'ref(' . $_[1] . ') eq "GLOB"' };
  
      # NOTE: scalar filehandles are GLOB refs, but a GLOB ref is not always a
      # filehandle
      subtype 'FileHandle'
          => as 'Ref'
          => where {
              (ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
           || (blessed($_) && $_->isa("IO::Handle"));
          }
          => inline_as {
              '(ref(' . $_[1] . ') eq "GLOB" '
              . '&& Scalar::Util::openhandle(' . $_[1] . ')) '
              . '|| (Scalar::Util::blessed(' . $_[1] . ') '
              . '&& ' . $_[1] . '->isa("IO::Handle"))'
          };
  
      subtype 'Object'
          => as 'Ref'
          => where { blessed($_) }
          => inline_as { 'Scalar::Util::blessed(' . $_[1] . ')' };
  
      subtype 'ClassName'
          => as 'Str'
          => where { is_class_loaded($_) }
              # the long Str tests are redundant here
          => inline_as { 'Class::Load::is_class_loaded(' . $_[1] . ')' };
  
      subtype 'RoleName'
          => as 'ClassName'
          => where {
              (Class::MOP::class_of($_) || return)->isa('Moose::Meta::Role');
          }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && do {'
                  . 'my $meta = Class::MOP::class_of(' . $_[1] . ');'
                  . '$meta && $meta->isa("Moose::Meta::Role");'
              . '}'
          };
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'ScalarRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'SCALAR' || ref($_) eq 'REF' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      return $check->( ${$_} );
                  };
              },
              inlined => sub {
                  'ref(' . $_[1] . ') eq "SCALAR" '
                    . '|| ref(' . $_[1] . ') eq "REF"'
              },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
                  '(ref(' . $val . ') eq "SCALAR" || ref(' . $val . ') eq "REF") '
                    . '&& ' . $type_parameter->_inline_check('${(' . $val . ')}')
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'ArrayRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'ARRAY' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      foreach my $x (@$_) {
                          ( $check->($x) ) || return;
                      }
                      1;
                      }
              },
              inlined          => sub { 'ref(' . $_[1] . ') eq "ARRAY"' },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
  
                  'do {'
                      . 'my $check = ' . $val . ';'
                      . 'ref($check) eq "ARRAY" '
                          . '&& &List::MoreUtils::all('
                              . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                              . '@{$check}'
                          . ')'
                  . '}';
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'HashRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'HASH' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      foreach my $x ( values %$_ ) {
                          ( $check->($x) ) || return;
                      }
                      1;
                      }
              },
              inlined          => sub { 'ref(' . $_[1] . ') eq "HASH"' },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
  
                  'do {'
                      . 'my $check = ' . $val . ';'
                      . 'ref($check) eq "HASH" '
                          . '&& &List::MoreUtils::all('
                              . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                              . 'values %{$check}'
                          . ')'
                  . '}';
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'Maybe',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Item'),
              constraint           => sub {1},
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      return 1 if not( defined($_) ) || $check->($_);
                      return;
                      }
              },
              inlined          => sub {'1'},
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
                  '!defined(' . $val . ') '
                    . '|| (' . $type_parameter->_inline_check($val) . ')'
              },
          )
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =for pod_coverage_needs_some_pod
  
  =cut
  
X86_64-LINUX-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS

$fatpacked{"x86_64-linux-thread-multi/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
X86_64-LINUX-THREAD-MULTI_PARAMS_UTIL

$fatpacked{"x86_64-linux-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted
  );
  our $VERSION    = "1.38";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 $pkg = blessed( $ref )
  
  If C<$ref> is a blessed reference the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 $addr = refaddr( $ref )
  
  If C<$ref> is reference the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 $type = reftype( $ref )
  
  If C<$ref> is a reference the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken( REF )
  
  The lvalue C<REF> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken( REF )
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  C<weaken()>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 $weak = isweak( $ref )
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 $var = dualvar( $num, $string )
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 $dual = isdual( $var )
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is actually
  implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 $vstring = isvstring( $var )
  
  If C<$var> is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 $isnum = looks_like_number( $var )
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 $fh = openhandle( $fh )
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 $ro = readonly( $var )
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 $code = set_prototype( $code, $prototype )
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 $t = tainted( $var )
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its
  functions so that those without access to a C compiler may still use it.
  However some of the functions are only available when a C compiler was
  available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-thread-multi/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
X86_64-LINUX-THREAD-MULTI_SUB_NAME

$fatpacked{"x86_64-linux-thread-multi/Term/ReadLine/Gnu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TERM_READLINE_GNU';
  #
  #	Gnu.pm --- The GNU Readline/History Library wrapper module
  #
  #	$Id: Gnu.pm 445 2014-03-01 16:14:02Z hayashi $
  #
  #	Copyright (c) 2014 Hiroo Hayashi.  All rights reserved.
  #
  #	This program is free software; you can redistribute it and/or
  #	modify it under the same terms as Perl itself.
  #
  #	Some of documentation strings in this file are cited from the
  #	GNU Readline/History Library Manual.
  
  package Term::ReadLine::Gnu;
  
  =head1 NAME
  
  Term::ReadLine::Gnu - Perl extension for the GNU Readline/History Library
  
  =head1 SYNOPSIS
  
    use Term::ReadLine;
    $term = new Term::ReadLine 'ProgramName';
    while ( defined ($_ = $term->readline('prompt>')) ) {
      ...
    }
  
  =head1 DESCRIPTION
  
  =head2 Overview
  
  This is an implementation of Term::ReadLine using the GNU
  Readline/History Library.
  
  For basic functions object oriented interface is provided. These are
  described in the section L<"Standard Methods"|"Standard Methods"> and
  L<"C<Term::ReadLine::Gnu> Functions"|"C<Term::ReadLine::Gnu> Functions">.
  
  This package also has the interface with the almost all functions and
  variables which are documented in the GNU Readline/History Library
  Manual.  They are documented in the section
  L<"C<Term::ReadLine::Gnu> Functions"|"C<Term::ReadLine::Gnu> Functions">
  and
  L<"C<Term::ReadLine::Gnu> Variables"|"C<Term::ReadLine::Gnu> Variables">
  briefly.  For more detail of the GNU Readline/History Library, see
  'GNU Readline Library Manual' and 'GNU History Library Manual'.
  
  The sample programs under C<eg/> directory and test programs under
  C<t/> directory in the C<Term::ReadLine::Gnu> distribution include
  many example of this module.
  
  =head2 Standard Methods
  
  These methods are standard methods defined by B<Term::ReadLine>.
  
  =cut
  
  use strict;
  use Carp;
  
  # This module can't be loaded directly.
  BEGIN {
      if (not defined $Term::ReadLine::VERSION) {
          croak <<END;
  It is invalid to load Term::ReadLine::Gnu directly.  Please consult
  the Term::ReadLine documentation for more information.
  END
      }
  }
  
  {
      use Exporter ();
      use DynaLoader;
      use vars qw($VERSION @ISA @EXPORT_OK);
  
      $VERSION = '1.21';
  
      # Term::ReadLine::Gnu::AU makes a function in
      # `Term::ReadLine::Gnu::XS' as a method.
      # The namespace of Term::ReadLine::Gnu::AU is searched before ones
      # of other classes
      @ISA = qw(Term::ReadLine::Gnu::AU Term::ReadLine::Stub
  	      Exporter DynaLoader);
  
      @EXPORT_OK = qw(RL_PROMPT_START_IGNORE RL_PROMPT_END_IGNORE
  		    NO_MATCH SINGLE_MATCH MULT_MATCH
  		    ISFUNC ISKMAP ISMACR
  		    UNDO_DELETE UNDO_INSERT UNDO_BEGIN UNDO_END
  		    RL_STATE_NONE RL_STATE_INITIALIZING
  		    RL_STATE_INITIALIZED RL_STATE_TERMPREPPED
  		    RL_STATE_READCMD RL_STATE_METANEXT
  		    RL_STATE_DISPATCHING RL_STATE_MOREINPUT
  		    RL_STATE_ISEARCH RL_STATE_NSEARCH
  		    RL_STATE_SEARCH RL_STATE_NUMERICARG
  		    RL_STATE_MACROINPUT RL_STATE_MACRODEF
  		    RL_STATE_OVERWRITE RL_STATE_COMPLETING
  		    RL_STATE_SIGHANDLER RL_STATE_UNDOING
  		    RL_STATE_INPUTPENDING RL_STATE_TTYCSAVED
  		    RL_STATE_CALLBACK RL_STATE_VIMOTION
  		    RL_STATE_MULTIKEY RL_STATE_VICMDONCE
  		    RL_STATE_DONE);
  
      bootstrap Term::ReadLine::Gnu $VERSION; # DynaLoader
  }
  require Term::ReadLine::Gnu::XS;
  
  #	Global Variables
  
  use vars qw(%Attribs %Features);
  
  # Each variable in the GNU Readline Library is tied to an entry of
  # this hash (%Attribs).  By accessing the hash entry, you can read
  # and/or write the variable in the GNU Readline Library.  See the
  # package definition of Term::ReadLine::Gnu::Var and following code
  # for more details.
  
  # Normal (non-tied) entries
  %Attribs  = (
  	     MinLength => 1,
  	     do_expand => 0,
  	     completion_word => [],
  	     term_set => ['', '', '', ''],
  	    );
  %Features = (
  	     appname => 1, minline => 1, autohistory => 1,
  	     getHistory => 1, setHistory => 1, addHistory => 1,
  	     readHistory => 1, writeHistory => 1,
  	     preput => 1, attribs => 1, newTTY => 1,
  	     tkRunning => Term::ReadLine::Stub->Features->{'tkRunning'},
  	     ornaments => Term::ReadLine::Stub->Features->{'ornaments'},
  	     stiflehistory => 1,
  	    );
  
  sub Attribs { \%Attribs; }
  sub Features { \%Features; }
  
  # keep rl_readline_version value for efficiency
  my $readline_version;
  
  #
  #	GNU Readline/History Library constant definition
  #	These are included in @EXPORT_OK.
  
  # I can define these variables in XS code to use the value defined in
  # readline.h, etc.  But it needs some calling convention change and
  # will cause compatiblity problem. I hope the definition of these
  # constant value will not be changed.
  
  # for non-printing characters in prompt string
  sub RL_PROMPT_START_IGNORE	{ "\001"; }
  sub RL_PROMPT_END_IGNORE	{ "\002"; }
  
  # for rl_filename_quoting_function
  sub NO_MATCH	 { 0; }
  sub SINGLE_MATCH { 1; }
  sub MULT_MATCH   { 2; }
  
  # for rl_generic_bind, rl_function_of_keyseq
  sub ISFUNC	{ 0; }
  sub ISKMAP	{ 1; }
  sub ISMACR	{ 2; }
  
  # for rl_add_undo
  sub UNDO_DELETE	{ 0; }
  sub UNDO_INSERT	{ 1; }
  sub UNDO_BEGIN	{ 2; }
  sub UNDO_END	{ 3; }
  
  # for rl_readline_state
  sub RL_STATE_NONE		{ 0x00000; } # no state; before first call
  sub RL_STATE_INITIALIZING	{ 0x00001; } # initializing
  sub RL_STATE_INITIALIZED	{ 0x00002; } # initialization done
  sub RL_STATE_TERMPREPPED	{ 0x00004; } # terminal is prepped
  sub RL_STATE_READCMD		{ 0x00008; } # reading a command key
  sub RL_STATE_METANEXT		{ 0x00010; } # reading input after ESC
  sub RL_STATE_DISPATCHING	{ 0x00020; } # dispatching to a command
  sub RL_STATE_MOREINPUT		{ 0x00040; } # reading more input in a command function
  sub RL_STATE_ISEARCH		{ 0x00080; } # doing incremental search
  sub RL_STATE_NSEARCH		{ 0x00100; } # doing non-inc search
  sub RL_STATE_SEARCH		{ 0x00200; } # doing a history search
  sub RL_STATE_NUMERICARG		{ 0x00400; } # reading numeric argument
  sub RL_STATE_MACROINPUT		{ 0x00800; } # getting input from a macro
  sub RL_STATE_MACRODEF		{ 0x01000; } # defining keyboard macro
  sub RL_STATE_OVERWRITE		{ 0x02000; } # overwrite mode
  sub RL_STATE_COMPLETING		{ 0x04000; } # doing completion
  sub RL_STATE_SIGHANDLER		{ 0x08000; } # in readline sighandler
  sub RL_STATE_UNDOING		{ 0x10000; } # doing an undo
  # The following RL_STATE_* are defined since TRL 6.0
  sub RL_STATE_INPUTPENDING	{ 0x020000; } #	rl_execute_next called
  sub RL_STATE_TTYCSAVED		{ 0x040000; } #	tty special chars saved
  sub RL_STATE_CALLBACK		{ 0x080000; } #	using the callback interface
  sub RL_STATE_VIMOTION		{ 0x100000; } #	reading vi motion arg
  sub RL_STATE_MULTIKEY		{ 0x200000; } #	reading multiple-key command
  sub RL_STATE_VICMDONCE		{ 0x400000; } #	entered vi command mode at least once
  # The following RL_STATE_* is defined since TRL 6.1
  sub RL_STATE_REDISPLAYING	{ 0x800000; } #	updating terminal display
  # The value was changed since TRL 6.0 and 6.1
  # done; accepted line
  sub RL_STATE_DONE { $readline_version < 0x0600 ? 0x80000 : 
  			($readline_version < 0x0601 ? 0x800000 : 0x1000000); }
  
  #
  #	Methods Definition
  #
  
  =over 4
  
  =item C<ReadLine>
  
  returns the actual package that executes the commands. If you have
  installed this package,  possible value is C<Term::ReadLine::Gnu>.
  
  =cut
  
  sub ReadLine { 'Term::ReadLine::Gnu'; }
  
  =item C<new(NAME,[IN[,OUT]])>
  
  returns the handle for subsequent calls to following functions.
  Argument is the name of the application.  Optionally can be followed
  by two arguments for C<IN> and C<OUT> file handles. These arguments
  should be globs.
  
  =cut
  
  # The origin of this function is Term::ReadLine::Perl.pm by Ilya Zakharevich.
  sub new {
      my $this = shift;		# Package
      my $class = ref($this) || $this;
  
      my $name = shift;
  
      my $self = \%Attribs;
      bless $self, $class;
  
      # set rl_readline_name before .inputrc is read in rl_initialize()
      $Attribs{readline_name} = $name;
  
      # some version of Perl cause segmentation fault, if XS module
      # calls setenv() before the 1st assignment to $ENV{}.
      $ENV{_TRL_DUMMY} = '';
  
      # initialize the GNU Readline Library and termcap library
      $self->initialize();
  
      # enable ornaments to be compatible with perl5.004_05(?)
      unless ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/) {
  	local $^W = 0;		# Term::ReadLine is not warning flag free
  	# Without the next line Term::ReadLine::Stub::ornaments is used.
  	# Why does Term::ReadLine::Gnu::AU selects it at first?!!!
  	# If you know why this happens, please let me know.  Thanks.
  	undef &Term::ReadLine::Gnu::ornaments;
  	$self->ornaments(1);
      }
  
      if (!@_) {
  	my ($IN,$OUT) = $self->findConsole();
  	open(IN,"<$IN")   || croak "Cannot open $IN for read";
  	open(OUT,">$OUT") || croak "Cannot open $OUT for write";
  	# borrowed from Term/ReadLine.pm
  	my $sel = select(OUT);
  	$| = 1;				# for DB::OUT
  	select($sel);
  	$Attribs{instream} = \*IN;
  	$Attribs{outstream} = \*OUT;
      } else {
  	$Attribs{instream} = shift;
  	$Attribs{outstream} = shift;
      }
      $readline_version = $Attribs{readline_version};
  
      $self;
  }
  
  sub DESTROY {}
  
  =item C<readline(PROMPT[,PREPUT])>
  
  gets an input line, with actual C<GNU Readline> support.  Trailing
  newline is removed.  Returns C<undef> on C<EOF>.  C<PREPUT> is an
  optional argument meaning the initial value of input.
  
  The optional argument C<PREPUT> is granted only if the value C<preput>
  is in C<Features>.
  
  C<PROMPT> may include some escape sequences.  Use
  C<RL_PROMPT_START_IGNORE> to begin a sequence of non-printing
  characters, and C<RL_PROMPT_END_IGNORE> to end of such a sequence.
  
  =cut
  
  # to peacify -w
  $Term::ReadLine::registered = $Term::ReadLine::registered;
  
  sub readline {			# should be ReadLine
      my $self = shift;
      my ($prompt, $preput) = @_;
  
      # contributed fix for Perl debugger
      # make sure the outstream fd inside the readline library is
      # in sync (see http://bugs.debian.org/236018)
      $Attribs{outstream} = $Attribs{outstream};
  
      # ornament support (now prompt only)
      $prompt = ${$Attribs{term_set}}[0] . $prompt . ${$Attribs{term_set}}[1];
  
      # `completion_function' support for compatibility with
      # Term:ReadLine::Perl.  Prefer $completion_entry_function, since a
      # program which uses $completion_entry_function should know
      # Term::ReadLine::Gnu and have better completion function using
      # the variable.
      $Attribs{completion_entry_function} = $Attribs{_trp_completion_function}
  	if (!defined $Attribs{completion_entry_function}
  	    && defined $Attribs{completion_function});
  
      # TkRunning support
      if (not $Term::ReadLine::registered and $Term::ReadLine::toloop
  	and defined &Tk::DoOneEvent) {
  	$self->register_Tk;
  	$Attribs{getc_function} = $Attribs{Tk_getc};
      }
  
      # call readline()
      my $line;
      if (defined $preput) {
  	my $saved_startup_hook = $Attribs{startup_hook};
  	$Attribs{startup_hook} = sub {
  	    $self->rl_insert_text($preput);
  	    &$saved_startup_hook
  		if defined $saved_startup_hook;
  	};
  	$line = $self->rl_readline($prompt);
  	$Attribs{startup_hook} = $saved_startup_hook;
      } else {
  	$line = $self->rl_readline($prompt);
      }
      return undef unless defined $line;
  
      # history expansion
      if ($Attribs{do_expand}) {
  	my $result;
  	($result, $line) = $self->history_expand($line);
  	my $outstream = $Attribs{outstream};
  	print $outstream "$line\n" if ($result);
  
  	# return without adding line into history
  	if ($result < 0 || $result == 2) {
  	    return '';		# don't return `undef' which means EOF.
  	}
      }
  
      # add to history buffer
      $self->add_history($line)
  	if (defined $self->{MinLength} && $self->{MinLength} > 0
  	    && length($line) >= $self->{MinLength});
  
      return $line;
  }
  
  =item C<AddHistory(LINE1, LINE2, ...)>
  
  adds the lines to the history of input, from where it can be used if
  the actual C<readline> is present.
  
  =cut
  
  use vars '*addhistory';
  *addhistory = \&AddHistory;	# for backward compatibility
  
  sub AddHistory {
      my $self = shift;
      foreach (@_) {
  	$self->add_history($_);
      }
  }
  
  =item C<IN>, C<OUT>
  
  return the file handles for input and output or C<undef> if
  C<readline> input and output cannot be used for Perl.
  
  =cut
  
  sub IN  { $Attribs{instream}; }
  sub OUT { $Attribs{outstream}; }
  
  =item C<MinLine([MAX])>
  
  If argument C<MAX> is specified, it is an advice on minimal size of
  line to be included into history.  C<undef> means do not include
  anything into history.  Returns the old value.
  
  =cut
  
  sub MinLine {
      my $self = shift;
      my $old_minlength = $self->{MinLength};
      $self->{MinLength} = shift;
      $old_minlength;
  }
  
  # findConsole is defined in ReadLine.pm.
  
  =item C<findConsole>
  
  returns an array with two strings that give most appropriate names for
  files for input and output using conventions C<"E<lt>$in">, C<"E<gt>$out">.
  
  =item C<Attribs>
  
  returns a reference to a hash which describes internal configuration
  (variables) of the package.  Names of keys in this hash conform to
  standard conventions with the leading C<rl_> stripped.
  
  See section "Variables" for supported variables.
  
  =item C<Features>
  
  Returns a reference to a hash with keys being features present in
  current implementation. Several optional features are used in the
  minimal interface: C<appname> should be present if the first argument
  to C<new> is recognized, and C<minline> should be present if
  C<MinLine> method is not dummy.  C<autohistory> should be present if
  lines are put into history automatically (maybe subject to
  C<MinLine>), and C<addHistory> if C<AddHistory> method is not dummy. 
  C<preput> means the second argument to C<readline> method is processed.
  C<getHistory> and C<setHistory> denote that the corresponding methods are 
  present. C<tkRunning> denotes that a Tk application may run while ReadLine
  is getting input.
  
  =cut
  
  # Not tested yet.  How do I use this?
  sub newTTY {
      my ($self, $in, $out) = @_;
      $Attribs{instream}  = $in;
      $Attribs{outstream} = $out;
      my $sel = select($out);
      $| = 1;			# for DB::OUT
      select($sel);
  }
  
  =back
  
  =cut
  
  # documented later
  sub CallbackHandlerInstall {
      my $self = shift;
      my ($prompt, $lhandler) = @_;
  
      $Attribs{_callback_handler} = $lhandler;
  
      # ornament support (now prompt only)
      $prompt = ${$Attribs{term_set}}[0] . $prompt . ${$Attribs{term_set}}[1];
  
      $Attribs{completion_entry_function} = $Attribs{_trp_completion_function}
  	if (!defined $Attribs{completion_entry_function}
  	    && defined $Attribs{completion_function});
  
      $self->rl_callback_handler_install($prompt,
  				       \&Term::ReadLine::Gnu::XS::_ch_wrapper);
  }
  
  
  #
  #	Additional Supported Methods
  #
  
  # Documentation is after '__END__' for efficiency.
  
  # for backward compatibility
  use vars qw(*AddDefun *BindKey *UnbindKey *ParseAndBind *StifleHistory);
  *AddDefun = \&add_defun;
  *BindKey = \&bind_key;
  *UnbindKey = \&unbind_key;
  *ParseAndBind = \&parse_and_bind;
  *StifleHistory = \&stifle_history;
  
  sub SetHistory {
      my $self = shift;
      $self->clear_history();
      $self->AddHistory(@_);
  }
  
  sub GetHistory {
      my $self = shift;
      $self->history_list();
  }
  
  sub ReadHistory {
      my $self = shift;
      ! $self->read_history_range(@_);
  }
  
  sub WriteHistory {
      my $self = shift;
      ! $self->write_history(@_);
  }
  
  #
  #	Access Routines for GNU Readline/History Library Variables
  #
  package Term::ReadLine::Gnu::Var;
  use Carp;
  use strict;
  use vars qw(%_rl_vars);
  
  %_rl_vars
      = (
         rl_line_buffer				=> ['S', 0],
         rl_prompt				=> ['S', 1],
         rl_library_version			=> ['S', 2],
         rl_terminal_name				=> ['S', 3],
         rl_readline_name				=> ['S', 4],
         rl_basic_word_break_characters		=> ['S', 5],
         rl_basic_quote_characters		=> ['S', 6],
         rl_completer_word_break_characters	=> ['S', 7],
         rl_completer_quote_characters		=> ['S', 8],
         rl_filename_quote_characters		=> ['S', 9],
         rl_special_prefixes			=> ['S', 10],
         history_no_expand_chars			=> ['S', 11],
         history_search_delimiter_chars		=> ['S', 12],
         rl_executing_macro			=> ['S', 13], # GRL 4.2
         history_word_delimiters			=> ['S', 14], # GRL 4.2
         rl_display_prompt			=> ['S', 15], # GRL 6.0
         rl_executing_keyseq			=> ['S', 16], # GRL 6.3
  
         rl_point					=> ['I', 0],
         rl_end					=> ['I', 1],
         rl_mark					=> ['I', 2],
         rl_done					=> ['I', 3],
         rl_pending_input				=> ['I', 4],
         rl_completion_query_items		=> ['I', 5],
         rl_completion_append_character		=> ['C', 6],
         rl_ignore_completion_duplicates		=> ['I', 7],
         rl_filename_completion_desired		=> ['I', 8],
         rl_filename_quoting_desired		=> ['I', 9],
         rl_inhibit_completion			=> ['I', 10],
         history_base				=> ['I', 11],
         history_length				=> ['I', 12],
         history_max_entries			=> ['I', 13],
         max_input_history			=> ['I', 13], # before GRL 4.2
         history_write_timestamps			=> ['I', 14], # GRL 5.0
         history_expansion_char			=> ['C', 15],
         history_subst_char			=> ['C', 16],
         history_comment_char			=> ['C', 17],
         history_quotes_inhibit_expansion		=> ['I', 18],
         rl_erase_empty_line			=> ['I', 19], # GRL 4.0
         rl_catch_signals				=> ['I', 20], # GRL 4.0
         rl_catch_sigwinch			=> ['I', 21], # GRL 4.0
         rl_already_prompted			=> ['I', 22], # GRL 4.1
         rl_num_chars_to_read			=> ['I', 23], # GRL 4.1
         rl_dispatching				=> ['I', 24], # GRL 4.2
         rl_gnu_readline_p			=> ['I', 25], # GRL 4.1
         rl_readline_state			=> ['I', 26], # GRL 4.2
         rl_explicit_arg				=> ['I', 27], # GRL 4.2
         rl_numeric_arg				=> ['I', 28], # GRL 4.2
         rl_editing_mode				=> ['I', 29], # GRL 4.2
         rl_attempted_completion_over		=> ['I', 30], # GRL 4.2
         rl_completion_type			=> ['I', 31], # GRL 4.2
         rl_readline_version			=> ['I', 32], # GRL 4.2a
         rl_completion_suppress_append		=> ['I', 33], # GRL 4.3
         rl_completion_quote_character		=> ['C', 34], # GRL 5.0
         rl_completion_suppress_quote		=> ['I', 35], # GRL 5.0
         rl_completion_found_quote		=> ['I', 36], # GRL 5.0
         rl_completion_mark_symlink_dirs		=> ['I', 37], # GRL 4.3
         rl_prefer_env_winsize			=> ['I', 38], # GRL 5.1
         rl_sort_completion_matches		=> ['I', 39], # GRL 6.0
         rl_completion_invoking_key		=> ['C', 40], # GRL 6.0
         rl_executing_key				=> ['I', 41], # GRL 6.3
         rl_key_sequence_length			=> ['I', 42], # GRL 6.3
         rl_change_environment			=> ['I', 43], # GRL 6.3
  
         rl_startup_hook				=> ['F', 0],
         rl_event_hook				=> ['F', 1],
         rl_getc_function				=> ['F', 2],
         rl_redisplay_function			=> ['F', 3],
         rl_completion_entry_function		=> ['F', 4],
         rl_attempted_completion_function		=> ['F', 5],
         rl_filename_quoting_function		=> ['F', 6],
         rl_filename_dequoting_function		=> ['F', 7],
         rl_char_is_quoted_p			=> ['F', 8],
         rl_ignore_some_completions_function	=> ['F', 9],
         rl_directory_completion_hook		=> ['F', 10],
         history_inhibit_expansion_function	=> ['F', 11],
         rl_pre_input_hook			=> ['F', 12], # GRL 4.0
         rl_completion_display_matches_hook	=> ['F', 13], # GRL 4.0
         rl_completion_word_break_hook		=> ['F', 14], # GRL 5.0
         rl_prep_term_function			=> ['F', 15], # GRL 4.2
         rl_deprep_term_function			=> ['F', 16], # GRL 4.2
         rl_directory_rewrite_hook		=> ['F', 17], # GRL 4.2
         rl_filename_rewrite_hook			=> ['F', 18], # GRL 6.1
         rl_signal_event_hook			=> ['F', 19], # GRL 6.3
         rl_input_available_hook			=> ['F', 20], # GRL 6.3
         rl_filename_stat_hook			=> ['F', 21], # GRL 6.3
  
         rl_instream				=> ['IO', 0],
         rl_outstream				=> ['IO', 1],
  
         rl_executing_keymap			=> ['K', 0],
         rl_binding_keymap			=> ['K', 1],
  
         rl_last_func                             => ['LF', 0],
        );
  
  sub TIESCALAR {
      my $class = shift;
      my $name = shift;
      return bless \$name, $class;
  }
  
  sub FETCH {
      my $self = shift;
      confess "wrong type" unless ref $self;
  
      my $name = $$self;
      if (! defined $_rl_vars{$name}) {
  	confess "Term::ReadLine::Gnu::Var::FETCH: Unknown variable name `$name'\n";
  	return undef ;
      }
  
      my ($type, $id) = @{$_rl_vars{$name}};
      if ($type eq 'S') {
  	return _rl_fetch_str($id);
      } elsif ($type eq 'I') {
  	return _rl_fetch_int($id);
      } elsif ($type eq 'C') {
  	return chr(_rl_fetch_int($id));
      } elsif ($type eq 'F') {
  	return _rl_fetch_function($id);
      } elsif ($type eq 'IO') {
  	return _rl_fetch_iostream($id);
      } elsif ($type eq 'K') {
  	return _rl_fetch_keymap($id);
      } elsif ($type eq 'LF') {
          return _rl_fetch_last_func();
      } else {
  	carp "Term::ReadLine::Gnu::Var::FETCH: Illegal type `$type'\n";
  	return undef;
      }
  }
  
  sub STORE {
      my $self = shift;
      confess "wrong type" unless ref $self;
  
      my $name = $$self;
      if (! defined $_rl_vars{$name}) {
  	confess "Term::ReadLine::Gnu::Var::STORE: Unknown variable name `$name'\n";
  	return undef ;
      }
  
      my $value = shift;
      my ($type, $id) = @{$_rl_vars{$name}};
      if ($type eq 'S') {
  	if ($name eq 'rl_line_buffer') {
  	    return _rl_store_rl_line_buffer($value);
  	} else {
  	    return _rl_store_str($value, $id);
  	}
      } elsif ($type eq 'I') {
  	return _rl_store_int($value, $id);
      } elsif ($type eq 'C') {
  	return chr(_rl_store_int(ord($value), $id));
      } elsif ($type eq 'F') {
  	return _rl_store_function($value, $id);
      } elsif ($type eq 'IO') {
  	return _rl_store_iostream($value, $id);
      } elsif ($type eq 'K' || $type eq 'LF') {
  	carp "Term::ReadLine::Gnu::Var::STORE: read only variable `$name'\n";
  	return undef;
      } else {
  	carp "Term::ReadLine::Gnu::Var::STORE: Illegal type `$type'\n";
  	return undef;
      }
  }
  
  package Term::ReadLine::Gnu;
  use Carp;
  use strict;
  
  #
  #	set value of %Attribs
  #
  
  #	Tie all Readline/History variables
  foreach (keys %Term::ReadLine::Gnu::Var::_rl_vars) {
      my $name;
      ($name = $_) =~ s/^rl_//;	# strip leading `rl_'
      tie $Attribs{$name},  'Term::ReadLine::Gnu::Var', $_;
  }
  
  #	add reference to some functions
  {
      my ($name, $fname);
      no strict 'refs';		# allow symbolic reference
      map {
  	($name = $_) =~ s/^rl_//; # strip leading `rl_'
  	$fname = 'Term::ReadLine::Gnu::XS::' . $_;
  	$Attribs{$name} = \&$fname; # symbolic reference
      } qw(rl_getc
  	 rl_redisplay
  	 rl_callback_read_char
  	 rl_display_match_list
  	 rl_filename_completion_function
  	 rl_username_completion_function
  	 list_completion_function
           _trp_completion_function);
      # auto-split subroutine cannot be processed in the map loop above
      use strict 'refs';
      $Attribs{shadow_redisplay} = \&Term::ReadLine::Gnu::XS::shadow_redisplay;
      $Attribs{Tk_getc} = \&Term::ReadLine::Gnu::XS::Tk_getc;
      $Attribs{list_completion_function} = \&Term::ReadLine::Gnu::XS::list_completion_function;
  }
  
  package Term::ReadLine::Gnu::AU;
  use Carp;
  no strict qw(refs vars);
  
  sub AUTOLOAD {
      { $AUTOLOAD =~ s/.*:://; }	# preserve match data
      my $name;
      if (exists $Term::ReadLine::Gnu::XS::{"rl_$AUTOLOAD"}) {
  	$name = "Term::ReadLine::Gnu::XS::rl_$AUTOLOAD";
      } elsif (exists $Term::ReadLine::Gnu::XS::{"$AUTOLOAD"}) {
  	$name = "Term::ReadLine::Gnu::XS::$AUTOLOAD";
      } else {
  	croak "Cannot do `$AUTOLOAD' in Term::ReadLine::Gnu";
      }
      local $^W = 0;		# Why is this line necessary ?
      *$AUTOLOAD = sub { shift; &$name(@_); };
      goto &$AUTOLOAD;
  }
  1;
  __END__
  
  
  =head2 C<Term::ReadLine::Gnu> Functions
  
  All these GNU Readline/History Library functions are callable via
  method interface and have names which conform to standard conventions
  with the leading C<rl_> stripped.
  
  Almost methods have lower level functions in
  C<Term::ReadLine::Gnu::XS> package.  To use them full qualified name
  is required.  Using method interface is preferred.
  
  =over 4
  
  =item Readline Convenience Functions
  
  =over 4
  
  =item Naming Function
  
  =over 4
  
  =item C<add_defun(NAME, FUNC [,KEY=-1])>
  
  Add name to the Perl function C<FUNC>.  If optional argument C<KEY> is
  specified, bind it to the C<FUNC>.  Returns reference to
  C<FunctionPtr>.
  
    Example:
  	# name name `reverse-line' to a function reverse_line(),
  	# and bind it to "\C-t"
  	$term->add_defun('reverse-line', \&reverse_line, ord "\ct");
  
  =back
  
  =item Selecting a Keymap
  
  =over 4
  
  =item C<make_bare_keymap>
  
  	Keymap	rl_make_bare_keymap()
  
  =item C<copy_keymap(MAP)>
  
  	Keymap	rl_copy_keymap(Keymap|str map)
  
  =item C<make_keymap>
  
  	Keymap	rl_make_keymap()
  
  =item C<discard_keymap(MAP)>
  
  	Keymap	rl_discard_keymap(Keymap|str map)
  
  =item C<free_keymap(MAP)>
  
  	void	rl_free_keymap(Keymap|str map)
  
  =item C<get_keymap>
  
  	Keymap	rl_get_keymap()
  
  =item C<set_keymap(MAP)>
  
  	Keymap	rl_set_keymap(Keymap|str map)
  
  =item C<get_keymap_by_name(NAME)>
  
  	Keymap	rl_get_keymap_by_name(str name)
  
  =item C<get_keymap_name(MAP)>
  
  	str	rl_get_keymap_name(Keymap map)
  
  =back
  
  =item Binding Keys
  
  =over 4
  
  =item C<bind_key(KEY, FUNCTION [,MAP])>
  
  	int	rl_bind_key(int key, FunctionPtr|str function,
  			    Keymap|str map = rl_get_keymap())
  
  Bind C<KEY> to the C<FUNCTION>.  C<FUNCTION> is the name added by the
  C<add_defun> method.  If optional argument C<MAP> is specified, binds
  in C<MAP>.  Returns non-zero in case of error.
  
  =item C<bind_key_if_unbound(KEY, FUNCTION [,MAP])>
  
  	int	rl_bind_key_if_unbound(int key, FunctionPtr|str function,
  			    	       Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<unbind_key(KEY [,MAP])>
  
  	int	rl_unbind_key(int key, Keymap|str map = rl_get_keymap())
  
  Bind C<KEY> to the null function.  Returns non-zero in case of error.
  
  =item C<unbind_function(FUNCTION [,MAP])>
  
  	int	rl_unbind_function(FunctionPtr|str function,
  				   Keymap|str map = rl_get_keymap())
  
  =item C<unbind_command(COMMAND [,MAP])>
  
  	int	rl_unbind_command(str command,
  				  Keymap|str map = rl_get_keymap())
  
  =item C<bind_keyseq(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_bind_keyseq(str keyseq, FunctionPtr|str function,
  			       Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<set_key(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_set_key(str keyseq, FunctionPtr|str function,
  			   Keymap|str map = rl_get_keymap())	# GRL 4.2
  
  =item C<bind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_bind_keyseq_if_unbound(str keyseq, FunctionPtr|str function,
  					  Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<generic_bind(TYPE, KEYSEQ, DATA, [,MAP])>
  
  	int	rl_generic_bind(int type, str keyseq,
  				FunctionPtr|Keymap|str data,
  				Keymap|str map = rl_get_keymap())
  
  =item C<parse_and_bind(LINE)>
  
  	void	rl_parse_and_bind(str line)
  
  Parse C<LINE> as if it had been read from the F<~/.inputrc> file and
  perform any key bindings and variable assignments found.  For more
  detail see 'GNU Readline Library Manual'.
  
  =item C<read_init_file([FILENAME])>
  
  	int	rl_read_init_file(str filename = '~/.inputrc')
  
  =back
  
  =item Associating Function Names and Bindings
  
  =over 4
  
  =item C<named_function(NAME)>
  
  	FunctionPtr rl_named_function(str name)
  
  =item C<get_function_name(FUNCTION)>
  
  	str	rl_get_function_name(FunctionPtr function)	# TRG orignal
  
  =item C<function_of_keyseq(KEYMAP [,MAP])>
  
  	(FunctionPtr|Keymap|str data, int type)
  		rl_function_of_keyseq(str keyseq,
  				      Keymap|str map = rl_get_keymap())
  
  =item C<invoking_keyseqs(FUNCTION [,MAP])>
  
  	(@str)	rl_invoking_keyseqs(FunctionPtr|str function,
  				    Keymap|str map = rl_get_keymap())
  
  =item C<function_dumper([READABLE])>
  
  	void	rl_function_dumper(int readable = 0)
  
  =item C<list_funmap_names>
  
  	void	rl_list_funmap_names()
  
  =item C<funmap_names>
  
  	(@str)	rl_funmap_names()
  
  =item C<add_funmap_entry(NAME, FUNCTION)>
  
  	int	rl_add_funmap_entry(char *name, FunctionPtr|str function)
  
  =back
  
  =item Allowing Undoing
  
  =over 4
  
  =item C<begin_undo_group>
  
  	int	rl_begin_undo_group()
  
  =item C<end_undo_group>
  
  	int	rl_end_undo_group()
  
  =item C<add_undo(WHAT, START, END, TEXT)>
  
  	int	rl_add_undo(int what, int start, int end, str text)
  
  =item C<free_undo_list>
  
  	void	rl_free_undo_list()
  
  =item C<do_undo>
  
  	int	rl_do_undo()
  
  =item C<modifying([START [,END]])>
  
  	int	rl_modifying(int start = 0, int end = rl_end)
  
  =back
  
  =item Redisplay
  
  =over 4
  
  =item C<redisplay>
  
  	void	rl_redisplay()
  
  =item C<forced_update_display>
  
  	int	rl_forced_update_display()
  
  =item C<on_new_line>
  
  	int	rl_on_new_line()
  
  =item C<on_new_line_with_prompt>
  
  	int	rl_on_new_line_with_prompt()			# GRL 4.1
  
  =item C<reset_line_state>
  
  	int	rl_reset_line_state()
  
  =item C<crlf>
  
  	int	rl_crlf()
  
  =item C<rl_show_char(C)>
  
  	int	rl_show_char(int c)
  
  =item C<message(FMT[, ...])>
  
  	int	rl_message(str fmt, ...)
  
  =item C<clear_message>
  
  	int	rl_clear_message()
  
  =item C<save_prompt>
  
  	void	rl_save_prompt()
  
  =item C<restore_prompt>
  
  	void	rl_restore_prompt()
  
  =item C<expand_prompt(PROMPT)>
  
  	int	rl_expand_prompt(str prompt)
  
  =item C<set_prompt(PROMPT)>
  
  	int	rl_set_prompt(const str prompt)			# GRL 4.2
  
  =back
  
  =item Modifying Text
  
  =over 4
  
  =item C<insert_text(TEXT)>
  
  	int	rl_insert_text(str text)
  
  =item C<delete_text([START [,END]])>
  
  	int	rl_delete_text(int start = 0, int end = rl_end)
  
  =item C<copy_text([START [,END]])>
  
  	str	rl_copy_text(int start = 0, int end = rl_end)
  
  =item C<kill_text([START [,END]])>
  
  	int	rl_kill_text(int start = 0, int end = rl_end)
  
  =item C<push_macro_input(MACRO)>
  
  	int	rl_push_macro_input(str macro)
  
  =back
  
  =item Character Input
  
  =over 4
  
  =item C<read_key>
  
  	int	rl_read_key()
  
  =item C<getc(STREAM)>
  
  	int	rl_getc(FILE *STREAM)
  
  =item C<stuff_char(C)>
  
  	int	rl_stuff_char(int c)
  
  =item C<execute_next(C)>
  
  	int	rl_execute_next(int c)
  
  =item C<clear_pending_input()>
  
  	int	rl_clear_pending_input()			# GRL 4.2
  
  =item C<set_keyboard_input_timeout(uSEC)>
  
  	int	rl_set_keyboard_input_timeout(int usec)		# GRL 4.2
  
  =back
  
  =item Terminal Management
  
  =over 4
  
  =item C<prep_terminal(META_FLAG)>
  
  	void	rl_prep_terminal(int META_FLAG)
  
  =item C<deprep_terminal()>
  
  	void	rl_deprep_terminal()
  
  =item C<tty_set_default_bindings(KMAP)>
  
  	void	rl_tty_set_default_bindings([Keymap KMAP])	# GRL 4.0
  
  =item C<tty_unset_default_bindings(KMAP)>
  
  	void	rl_tty_unset_default_bindings([Keymap KMAP])	# GRL 5.0
  
  =item C<reset_terminal([TERMINAL_NAME])>
  
  	int	rl_reset_terminal(str terminal_name = getenv($TERM))
  
  =back
  
  =item Utility Functions
  
  =over 4
  
  =item C<save_state(READLINE_STATE)>
  
  	NOT IMPLEMENTED YET!
  	int	rl_save_state(struct readline_state *sp)	# GRL 6.0
  
  =item C<restore_state(READLINE_STATE)>
  
  	NOT IMPLEMENTED YET!
  	int	rl_restore_state(struct readline_state *sp)	# GRL 6.0
  
  =item C<free(MEM)>
  
  	Not implemented since not required for Perl.
  	int	rl_(void *mem)					# GRL 6.0
  
  =item C<replace_line(TEXT [,CLEAR_UNDO])>
  
  	int	rl_replace_line(str text, int clear_undo)	# GRL 4.3
  
  =item C<extend_line_buffer(LEN)>
  
  	Not implemented since not required for Perl.
  	int	rl_extend_line_buffer(int len)
  
  =item C<initialize>
  
  	int	rl_initialize()
  
  =item C<ding>
  
  	int	rl_ding()
  
  =item C<alphabetic(C)>
  
  	int	rl_alphabetic(int C)				# GRL 4.2
  
  =item C<display_match_list(MATCHES [,LEN [,MAX]])>
  
  	void	rl_display_match_list(\@matches, len = $#maches, max) # GRL 4.0
  
  Since the first element of an array @matches as treated as a possible
  completion, it is not displayed.  See the descriptions of
  C<completion_matches()>.
  
  When C<MAX> is ommited, the max length of an item in @matches is used.
  
  =back
  
  =item Miscellaneous Functions
  
  =over 4
  
  =item C<macro_bind(KEYSEQ, MACRO [,MAP])>
  
  	int	rl_macro_bind(const str keyseq, const str macro, Keymap map)
  
  =item C<macro_dumper(READABLE)>
  
  	int	rl_macro_dumper(int readline)
  
  =item C<variable_bind(VARIABLE, VALUE)>
  
  	int	rl_variable_bind(const str variable, const str value)
  
  =item C<variable_value(VARIABLE)>
  
  	str	rl_variable_value(const str variable)		# GRL 5.1
  
  =item C<variable_dumper(READABLE)>
  
  	int	rl_variable_dumper(int readline)
  
  =item C<set_paren_blink_timeout(uSEC)>
  
  	int	rl_set_paren_blink_timeout(usec)		# GRL 4.2
  
  =item C<get_termcap(cap)>
  
  	str	rl_get_termcap(cap)
  
  =item C<clear_history>
  
      void	rl_clear_history()				# GRL 6.3
  
  =back
  
  =item Alternate Interface
  
  =over 4
  
  =item C<callback_handler_install(PROMPT, LHANDLER)>
  
  	void	rl_callback_handler_install(str prompt, pfunc lhandler)
  
  =item C<callback_read_char>
  
  	void	rl_callback_read_char()
  
  =item C<callback_handler_remove>
  
  	void	rl_callback_handler_remove()
  
  =back
  
  =back
  
  =item Readline Signal Handling
  
  =over 4
  
  =item C<cleanup_after_signal>
  
  	void	rl_cleanup_after_signal()			# GRL 4.0
  
  =item C<free_line_state>
  
  	void	rl_free_line_state()				# GRL 4.0
  
  =item C<reset_after_signal>
  
  	void	rl_reset_after_signal()				# GRL 4.0
  
  =item C<echo_signal_char>
  
  	void	rl_echo_signal_char(int sig)			# GRL 6.0
  
  =item C<resize_terminal>
  
  	void	rl_resize_terminal()				# GRL 4.0
  
  =item C<set_screen_size(ROWS, COLS)>
  
  	void	rl_set_screen_size(int ROWS, int COLS)		# GRL 4.2
  
  =item C<get_screen_size()>
  
  	(int rows, int cols)	rl_get_screen_size()		# GRL 4.2
  
  =item C<reset_screen_size()>
  
  	void	rl_reset_screen_size()				# GRL 5.1
  
  =item C<set_signals>
  
  	int	rl_set_signals()				# GRL 4.0
  
  =item C<clear_signals>
  
  	int	rl_clear_signals()				# GRL 4.0
  
  =back
  
  =item Completion Functions
  
  =over 4
  
  =item C<complete_internal([WHAT_TO_DO])>
  
  	int	rl_complete_internal(int what_to_do = TAB)
  
  =item C<completion_mode(FUNCTION)>
  
  	int	rl_completion_mode(FunctionPtr|str function)	# GRL 4.3
  
  =item C<completion_matches(TEXT [,FUNC])>
  
  	(@str)	rl_completion_matches(str text,
  				      pfunc func = filename_completion_function)
  
  =item C<filename_completion_function(TEXT, STATE)>
  
  	str	rl_filename_completion_function(str text, int state)
  
  =item C<username_completion_function(TEXT, STATE)>
  
  	str	rl_username_completion_function(str text, int state)
  
  =item C<list_completion_function(TEXT, STATE)>
  
  	str	list_completion_function(str text, int state)	# TRG original
  
  =back
  
  =item History Functions
  
  =over 4
  
  =item Initializing History and State Management
  
  =over 4
  
  =item C<using_history>
  
  	void	using_history()
  
  =item C<history_get_history_state>
  
  	NOT IMPLEMENTED YET!
  	HISTORY_STATE	*history_get_hitory_state()		# GRL 6.3
  
  =item C<history_set_history_state>
  
  	NOT IMPLEMENTED YET!
  	void	*history_set_hitory_state(HISTORY_STATE *state)	# GRL 6.3
  
  =back
  
  =item History List Management
  
  =over 4
  
  =item C<addhistory(STRING[, STRING, ...])>
  
  	void	add_history(str string)
  
  =item C<add_history_time(STRING)>
  
  	void	add_history_time(str string)			# GRL 5.0
  
  =item C<remove_history(WHICH)>
  
  	str	remove_history(int which)
  
  =item C<free_history(HISTENT)>
  
  	Not implemented since Term::ReadLine::Gnu does not support the
  	member 'data' of HIST_ENTRY structure, remove_history() covers it.
  	histdata_t	free_history_entry(HIST_ENTRY *histent)	# GRL 5.0
  
  =item C<replace_history_entry(WHICH, LINE)>
  
  	str	replace_history_entry(int which, str line)
  
  =item C<clear_history>
  
  	void	clear_history()
  
  =item C<StifleHistory(MAX)>
  
  	int	stifle_history(int max|undef)
  
  stifles the history list, remembering only the last C<MAX> entries.
  If C<MAX> is undef, remembers all entries.  This is a replacement
  of unstifle_history().
  
  =item C<unstifle_history>
  
  	int	unstifle_history()
  
  This is equivalent with 'stifle_history(undef)'.
  
  =item C<SetHistory(LINE1 [, LINE2, ...])>
  
  sets the history of input, from where it can be used if the actual
  C<readline> is present.
  
  =item C<history_is_stifled>
  
  	int	history_is_stifled()
  
  =back
  
  =item Information About the History List
  
  =over 4
  
  =item C<history_list>
  
  	Not implemented since not required for Perl.
  	HIST_ENTRY **history_list()
  
  =item C<where_history>
  
  	int	where_history()
  
  =item C<current_history>
  
  	str	current_history()
  
  =item C<history_get(OFFSET)>
  
  	str	history_get(offset)
  
  =item C<history_get_time(OFFSET)
  
  	time_t	history_get_time(offset)			# GRL 5.0
  
  =item C<history_total_bytes>
  
  	int	history_total_bytes()
  
  =item C<GetHistory>
  
  returns the history of input as a list, if actual C<readline> is present.
  
  =back
  
  =item Moving Around the History List
  
  =over 4
  
  =item C<history_set_pos(POS)>
  
  	int	history_set_pos(int pos)
  
  =item C<previous_history>
  
  	str	previous_history()
  
  =item C<next_history>
  
  	str	next_history()
  
  =back
  
  =item Searching the History List
  
  =over 4
  
  =item C<history_search(STRING [,DIRECTION])>
  
  	int	history_search(str string, int direction = -1)
  
  =item C<history_search_prefix(STRING [,DIRECTION])>
  
  	int	history_search_prefix(str string, int direction = -1)
  
  =item C<history_search_pos(STRING [,DIRECTION [,POS]])>
  
  	int	history_search_pos(str string,
  				   int direction = -1,
  				   int pos = where_history())
  
  =back
  
  =item Managing the History File
  
  =over 4
  
  =item C<ReadHistory([FILENAME [,FROM [,TO]]])>
  
  	int	read_history(str filename = '~/.history',
  			     int from = 0, int to = -1)
  
  	int	read_history_range(str filename = '~/.history',
  				   int from = 0, int to = -1)
  
  adds the contents of C<FILENAME> to the history list, a line at a
  time.  If C<FILENAME> is false, then read from F<~/.history>.  Start
  reading at line C<FROM> and end at C<TO>.  If C<FROM> is omitted or
  zero, start at the beginning.  If C<TO> is omitted or less than
  C<FROM>, then read until the end of the file.  Returns true if
  successful, or false if not.  C<read_history()> is an aliase of
  C<read_history_range()>.
  
  =item C<WriteHistory([FILENAME])>
  
  	int	write_history(str filename = '~/.history')
  
  writes the current history to C<FILENAME>, overwriting C<FILENAME> if
  necessary.  If C<FILENAME> is false, then write the history list to
  F<~/.history>.  Returns true if successful, or false if not.
  
  
  =item C<append_history(NELEMENTS [,FILENAME])>
  
  	int	append_history(int nelements, str filename = '~/.history')
  
  =item C<history_truncate_file([FILENAME [,NLINES]])>
  
  	int	history_truncate_file(str filename = '~/.history',
  				      int nlines = 0)
  
  =back
  
  =item History Expansion
  
  =over 4
  
  =item C<history_expand(LINE)>
  
  	(int result, str expansion) history_expand(str line)
  
  Note that this function returns C<expansion> in scalar context.
  
  =item C<get_history_event(STRING, CINDEX [,QCHAR])>
  
  	(str text, int cindex) = get_history_event(str  string,
  						   int  cindex,
  						   char qchar = '\0')
  
  =item C<history_tokenize(LINE)>
  
  	(@str)	history_tokenize(str line)
  
  =item C<history_arg_extract(LINE, [FIRST [,LAST]])>
  
  	str history_arg_extract(str line, int first = 0, int last = '$')
  
  =back
  
  =back
  
  =back
  
  =head2 C<Term::ReadLine::Gnu> Variables
  
  Following GNU Readline/History Library variables can be accessed by a
  Perl program.  See 'GNU Readline Library Manual' and 'GNU History
  Library Manual' for details of each variable.  You can access them with
  C<Attribs> methods.  Names of keys in this hash conform to standard
  conventions with the leading C<rl_> stripped.
  
  Examples:
  
      $attribs = $term->Attribs;
      $v = $attribs->{library_version};	# rl_library_version
      $v = $attribs->{history_base};	# history_base
  
  =over 4
  
  =item Readline Variables
  
  	str rl_line_buffer
  	int rl_point
  	int rl_end
  	int rl_mark
  	int rl_done
  	int rl_num_chars_to_read (GRL 4.1)
  	int rl_pending_input
  	int rl_dispatching
  	int rl_erase_empty_line (GRL 4.0)
  	str rl_prompt (read only)
  	str rl_display_prompt
  	int rl_already_prompted (GRL 4.1)
  	str rl_library_version (read only)
  	int rl_readline_version (read only)
  	int rl_gnu_readline_p (GRL 4.1, read only)
  	str rl_terminal_name
  	str rl_readline_name
  	filehandle rl_instream
  	filehandle rl_outstream
  	int rl_prefer_env_winsize (GRL 5.1)
  	pfunc rl_last_func (GRL 4.2, read only)
  	pfunc rl_startup_hook
  	pfunc rl_pre_input_hook (GRL 4.0)
  	pfunc rl_event_hook
  	pfunc rl_getc_function
  	pfunc rl_signal_event_hook (GRL 6.3)
  	pfunc rl_input_available_hook (GRL 6.3)
  	pfunc rl_redisplay_function
  	pfunc rl_prep_term_function (GRL 2.1)
  	pfunc rl_deprep_term_function (GRL 2.1)
  	Keymap rl_executing_keymap (read only)
  	Keymap rl_binding_keymap (read only)
  	str rl_executing_macro (GRL 4.2, read only)
  	int rl_executing_key (GRL 6.3, read only)
  	str rl_executing_keyseq (GRL 6.3, read only)
  	int rl_key_sequence_length (read only)
  	int rl_readline_state (GRL 4.2, read only)
  	int rl_explicit_arg (read only)
  	int rl_numeric_arg (read only)
  	int rl_editing_mode (read only)
  
  =item Signal Handling Variables
  
  	int rl_catch_signals (GRL 4.0)
  	int rl_catch_sigwinch (GRL 4.0)
  	int rl_change_environment (GRL 6.3)
  
  =item Completion Variables
  
  	pfunc rl_completion_entry_function
  	pfunc rl_attempted_completion_function
  	pfunc rl_filename_quoting_function
  	pfunc rl_filename_dequoting_function
  	pfunc rl_char_is_quoted_p
  	pfunc rl_ignore_some_completions_function
  	pfunc rl_directory_completion_hook
  	pfunc rl_directory_rewrite_hook (GRL 4.2)
  	pfunc rl_filename_stat_hook (GRL 6.3)
  	pfunc rl_filename_rewrite_hook (GRL 6.1)
  	pfunc rl_completion_display_matches_hook (GRL 4.0)
  	str rl_basic_word_break_characters
  	str rl_basic_quote_characters
  	str rl_completer_word_break_characters
  	pfunc rl_completion_word_break_hook (GRL 5.0)
  	str rl_completer_quote_characters
  	str rl_filename_quote_characters
  	str rl_special_prefixes
  	int rl_completion_query_items
  	int rl_completion_append_character
  	int rl_completion_suppress_append (GRL 4.3)
  	int rl_completion_quote_character (GRL 5.0)
  	int rl_completion_suppress_quote (GRL 5.0)
  	int rl_completion_found_quote (GRL 5.0)
  	int rl_completion_mark_symlink_dirs (GRL 4.3)
  	int rl_ignore_completion_duplicates
  	int rl_filename_completion_desired
  	int rl_filename_quoting_desired
  	int rl_attempted_completion_over
  	int rl_sort_completion_matches (GRL 6.0)
  	int rl_completion_type (read only)
  	int rl_completion_invoking_key (GRL 6.0, read only)
  	int rl_inhibit_completion
  
  =item History Variables
  
  	int history_base (read only)
  	int history_length (read only)
  	int history_max_entries (called `max_input_history', read only)
  	int history_write_timestamps (GRL 5.0)
  	char history_expansion_char
  	char history_subst_char
  	char history_comment_char
  	str history_word_delimiters (GRL 4.2)
  	str history_search_delimiter_chars
  	str history_no_expand_chars
  	int history_quotes_inhibit_expansion
  	pfunc history_inhibit_expansion_function
  
  =item Function References
  
  	rl_getc
  	rl_redisplay
  	rl_callback_read_char
  	rl_display_match_list
  	rl_filename_completion_function
  	rl_username_completion_function
  	list_completion_function
  	shadow_redisplay
  	Tk_getc
  
  =back
  
  =head2 Custom Completion
  
  In this section variables and functions for custom completion is
  described with examples.
  
  Most of descriptions in this section is cited from GNU Readline
  Library manual.
  
  =over 4
  
  =item C<rl_completion_entry_function>
  
  This variable holds reference refers to a generator function for
  C<completion_matches()>.
  
  A generator function is called repeatedly from
  C<completion_matches()>, returning a string each time.  The arguments
  to the generator function are C<TEXT> and C<STATE>.  C<TEXT> is the
  partial word to be completed.  C<STATE> is zero the first time the
  function is called, allowing the generator to perform any necessary
  initialization, and a positive non-zero integer for each subsequent
  call.  When the generator function returns C<undef> this signals
  C<completion_matches()> that there are no more possibilities left.
  
  If the value is undef, built-in C<filename_completion_function> is
  used.
  
  A sample generator function, C<list_completion_function>, is defined
  in Gnu.pm.  You can use it as follows;
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      $attribs->{completion_entry_function} =
  	$attribs->{list_completion_function};
      ...
      $attribs->{completion_word} =
  	[qw(reference to a list of words which you want to use for completion)];
      $term->readline("custom completion>");
  
  See also C<completion_matches>.
  
  =item C<rl_attempted_completion_function>
  
  A reference to an alternative function to create matches.
  
  The function is called with C<TEXT>, C<LINE_BUFFER>, C<START>, and
  C<END>.  C<LINE_BUFFER> is a current input buffer string.  C<START>
  and C<END> are indices in C<LINE_BUFFER> saying what the boundaries of
  C<TEXT> are.
  
  If this function exists and returns null list or C<undef>, or if this
  variable is set to C<undef>, then an internal function
  C<rl_complete()> will call the value of
  C<$rl_completion_entry_function> to generate matches, otherwise the
  array of strings returned will be used.
  
  The default value of this variable is C<undef>.  You can use it as follows;
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      sub sample_completion {
          my ($text, $line, $start, $end) = @_;
          # If first word then username completion, else filename completion
          if (substr($line, 0, $start) =~ /^\s*$/) {
      	    return $term->completion_matches($text,
  					     $attribs->{'username_completion_function'});
          } else {
      	    return ();
          }
      }
      ...
      $attribs->{attempted_completion_function} = \&sample_completion;
  
  =item C<completion_matches(TEXT, ENTRY_FUNC)>
  
  Returns an array of strings which is a list of completions for
  C<TEXT>.  If there are no completions, returns C<undef>.  The first
  entry in the returned array is the substitution for C<TEXT>.  The
  remaining entries are the possible completions.
  
  C<ENTRY_FUNC> is a generator function which has two arguments, and
  returns a string.  The first argument is C<TEXT>.  The second is a
  state argument; it is zero on the first call, and non-zero on
  subsequent calls.  C<ENTRY_FUNC> returns a C<undef> to the caller when
  there are no more matches.
  
  If the value of C<ENTRY_FUNC> is undef, built-in
  C<filename_completion_function> is used.
  
  C<completion_matches> is a Perl wrapper function of an internal
  function C<completion_matches()>.  See also
  C<$rl_completion_entry_function>.
  
  =item C<completion_function>
  
  A variable whose content is a reference to a function which returns a
  list of candidates to complete.
  
  This variable is compatible with C<Term::ReadLine::Perl> and very easy
  to use.
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      $attribs->{completion_function} = sub {
  	my ($text, $line, $start) = @_;
  	return qw(a list of candidates to complete);
      }
  
  =item C<list_completion_function(TEXT, STATE)>
  
  A sample generator function defined by C<Term::ReadLine::Gnu>.
  Example code at C<rl_completion_entry_function> shows how to use this
  function.
  
  =back
  
  =head2 C<Term::ReadLine::Gnu> Specific Features
  
  =over 4
  
  =item C<Term::ReadLine::Gnu> Specific Functions
  
  =over 4
  
  =item C<CallbackHandlerInstall(PROMPT, LHANDLER)>
  
  This method provides the function C<rl_callback_handler_install()>
  with the following addtional feature compatible with C<readline>
  method; ornament feature, C<Term::ReadLine::Perl> compatible
  completion function, histroy expansion, and addition to history
  buffer.
  
  =item C<call_function(FUNCTION, [COUNT [,KEY]])>
  
  	int	rl_call_function(FunctionPtr|str function, count = 1, key = -1)
  
  =item C<rl_get_all_function_names>
  
  Returns a list of all function names.
  
  =item C<shadow_redisplay>
  
  A redisplay function for password input.  You can use it as follows;
  
  	$attribs->{redisplay_function} = $attribs->{shadow_redisplay};
  	$line = $term->readline("password> ");
  
  =item C<rl_filename_list>
  
  Returns candidates of filename to complete.  This function can be used
  with C<completion_function> and is implemented for the compatibility
  with C<Term::ReadLine::Perl>.
  
  =item C<list_completion_function>
  
  See the description of section L<"Custom Completion"|"Custom Completion">.
  
  =back
  
  =item C<Term::ReadLine::Gnu> Specific Variables
  
  =over 4
  
  =item C<do_expand>
  
  When true, the history expansion is enabled.  By default false.
  
  =item C<completion_function>
  
  See the description of section L<"Custom Completion"|"Custom Completion">.
  
  =item C<completion_word>
  
  A reference to a list of candidates to complete for
  C<list_completion_function>.
  
  =back
  
  =item C<Term::ReadLine::Gnu> Specific Commands
  
  =over 4
  
  =item C<history-expand-line>
  
  The equivalent of the Bash C<history-expand-line> editing command.
  
  =item C<operate-and-get-next>
  
  The equivalent of the Korn shell C<operate-and-get-next-history-line>
  editing command and the Bash C<operate-and-get-next>.
  
  This command is bound to C<\C-o> by default for the compatibility with
  the Bash and C<Term::ReadLine::Perl>.
  
  =item C<display-readline-version>
  
  Shows the version of C<Term::ReadLine::Gnu> and the one of the GNU
  Readline Library.
  
  =item C<change-ornaments>
  
  Change ornaments interactively.
  
  =back
  
  =back
  
  =head1 FILES
  
  =over 4
  
  =item F<~/.inputrc>
  
  Readline init file.  Using this file it is possible that you would
  like to use a different set of key bindings.  When a program which
  uses the Readline library starts up, the init file is read, and the
  key bindings are set.
  
  Conditional key binding is also available.  The program name which is
  specified by the first argument of C<new> method is used as the
  application construct.
  
  For example, when your program call C<new> method like this;
  
  	...
  	$term = new Term::ReadLine 'PerlSh';
  	...
  
  your F<~/.inputrc> can define key bindings only for it as follows;
  
  	...
  	$if PerlSh
  	Meta-Rubout: backward-kill-word
  	"\C-x\C-r": re-read-init-file
          "\e[11~": "Function Key 1"
  	$endif
  	...
  
  =back
  
  =head1 EXPORTS
  
  None.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item Term::ReadLine::Gnu Project Home Page
  
  	http://sourceforge.net/projects/perl-trg/
  
  =item GNU Readline Library Manual
  
  =item GNU History Library Manual
  
  =item C<Term::ReadLine>
  
  =item C<Term::ReadLine::Perl> (Term-ReadLine-Perl-xx.tar.gz)
  
  =item F<eg/*> and F<t/*> in the Term::ReadLine::Gnu distribution
  
  =item Works which use Term::ReadLine::Gnu
  
  =over 4
  
  =item Perl Debugger
  
  	perl -d
  
  =item Perl Shell (psh)
  
  	http://gnp.github.io/psh/
  
  The Perl Shell is a shell that combines the interactive nature of a
  Unix shell with the power of Perl.
  
  A programmable completion feature compatible with bash is implemented.
  
  =item SPP (Synopsys Plus Perl)
  
  	http://vlsiweb.stanford.edu/~jsolomon/SPP/
  
  SPP (Synopsys Plus Perl) is a Perl module that wraps around Synopsys'
  shell programs.  SPP is inspired by the original dc_perl written by
  Steve Golson, but it's an entirely new implementation.  Why is it
  called SPP and not dc_perl?  Well, SPP was written to wrap around any
  of Synopsys' shells.
  
  =item PFM (Personal File Manager for Unix/Linux)
  
  	http://p-f-m.sourceforge.net/
  
  Pfm is a terminal-based file manager written in Perl, based on PFM.COM
  for MS-DOS (originally by Paul Culley and Henk de Heer).
  
  =item The soundgrab
  
  	http://brittonkerin.com/soundgrab/soundgrab.html
  
  soundgrab is designed to help you slice up a big long raw audio file
  (by default 44.1 kHz 2 channel signed sixteen bit little endian) and
  save your favorite sections to other files. It does this by providing
  you with a cassette player like command line interface.
  
  =item PDL (The Perl Data Language)
  
  	http://pdl.perl.org/
  
  PDL (``Perl Data Language'') gives standard Perl the ability to
  compactly store and speedily manipulate the large N-dimensional data
  arrays which are the bread and butter of scientific computing.
  
  =item PIQT (Perl Interactive DBI Query Tool)
  
  	http://piqt.sourceforge.net/
  
  PIQT is an interactive query tool using the Perl DBI database
  interface. It supports ReadLine, provides a built in scripting language
  with a Lisp like syntax, an online help system, and uses wrappers to
  interface to the DBD modules.
  
  =item vshnu (the New Visual Shell)
  
  	http://www.cs.indiana.edu/~kinzler/vshnu/
  
  A visual shell and CLI shell supplement.
  
  =item Distributions which depend on Term::ReadLine::Gnu on CPAN
  
  	https://metacpan.org/requires/distribution/Term-ReadLine-Gnu
  
  =back
  
  If you know any other works which can be listed here, please let me
  know.
  
  =back
  
  =head1 AUTHOR
  
  Hiroo Hayashi C<E<lt>hiroo.hayashi@computer.orgE<gt>>
  
  C<http://www.perl.org/CPAN/authors/Hiroo_HAYASHI/>
  
  =head1 TODO
  
  GTK+ support in addition to Tk.
  
  =head1 BUGS
  
  C<rl_add_defun()> can define up to 16 functions.
  
  Ornament feature works only on prompt strings.  It requires very hard
  hacking of C<display.c:rl_redisplay()> in GNU Readline library to
  ornament input line.
  
  Some readline function and variable are not tested yet.  Your
  contribution is welcome.  See C<t/readline.t>XS for details.
  
  =cut
X86_64-LINUX-THREAD-MULTI_TERM_READLINE_GNU

$fatpacked{"x86_64-linux-thread-multi/Term/ReadLine/Gnu/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TERM_READLINE_GNU_XS';
  #!/usr/local/bin/perl
  #
  #	XS.pm : perl function definition for Term::ReadLine::Gnu
  #
  #	$Id: XS.pm 438 2014-02-03 14:40:47Z hayashi $
  #
  #	Copyright (c) 2008 Hiroo Hayashi.  All rights reserved.
  #
  #	This program is free software; you can redistribute it and/or
  #	modify it under the same terms as Perl itself.
  
  package Term::ReadLine::Gnu::XS;
  
  use Carp;
  use strict;
  use AutoLoader 'AUTOLOAD';
  
  use vars qw($VERSION);
  $VERSION='1.17';	# added for CPAN
  
  # make aliases
  use vars qw(%Attribs);
  *Attribs = \%Term::ReadLine::Gnu::Attribs;
  
  use vars qw(*read_history);
  *read_history = \&read_history_range;
  
  # alias for 8 characters limitation imposed by AutoSplit
  use vars qw(*rl_unbind_key *rl_unbind_function *rl_unbind_command
  	    *history_list *history_arg_extract);
  *rl_unbind_key = \&unbind_key;
  *rl_unbind_function = \&unbind_function;
  *rl_unbind_command = \&unbind_command;
  *history_list = \&hist_list;
  *history_arg_extract = \&hist_arg_extract;
  
  # For backward compatibility.  Using these name (*_in_map) is deprecated.
  use vars qw(*rl_unbind_function_in_map *rl_unbind_command_in_map);
  *rl_unbind_function_in_map = \&unbind_function;
  *rl_unbind_command_in_map  = \&unbind_command;
  
  rl_add_defun('history-expand-line',	 \&history_expand_line);
  # bind operate-and-get-next to \C-o by default for the compatibility
  # with bash and Term::ReadLine::Perl
  rl_add_defun('operate-and-get-next',	 \&operate_and_get_next, ord "\co");
  rl_add_defun('display-readline-version', \&display_readline_version);
  rl_add_defun('change-ornaments',	 \&change_ornaments);
  
  # for ornaments()
  
  # Prompt-start, prompt-end, command-line-start, command-line-end
  #     -- zero-width beautifies to emit around prompt and the command line.
  # string encoded:
  my $rl_term_set = ',,,';
  
  # These variables are used by completion functions.  Don't use for
  # other purpose.
  my $_i;
  my @_matches;
  my @_tstrs;
  my $_tstrs_init = 0;
  
  1;
  
  # Uncomment the following line to enable AutoSplit.  If you are using
  # AutoLoader.pm distributed with Perl 5.004 or earlier, you must
  # update AutoLoader.pm due to its bug.
  
  #__END__
  
  
  #
  #	Readline Library function wrappers
  #
  
  # Convert keymap name to Keymap if the argument is not reference to Keymap
  sub _str2map ($) {
      return ref $_[0] ? $_[0]
  	: (rl_get_keymap_by_name($_[0]) || carp "unknown keymap name \`$_[0]\'\n");
  }
  
  # Convert function name to Function if the argument is not reference
  # to Function
  sub _str2fn ($) {
      return ref $_[0] ? $_[0]
  	: (rl_named_function($_[0]) || carp "unknown function name \`$_[0]\'\n");
  }
  
  sub rl_copy_keymap ($)    { return _rl_copy_keymap(_str2map($_[0])); }
  sub rl_discard_keymap ($) { return _rl_discard_keymap(_str2map($_[0])); }
  sub rl_set_keymap ($)     { return _rl_set_keymap(_str2map($_[0])); }
  
  # rl_bind_key
  sub rl_bind_key ($$;$) {
      if (defined $_[2]) {
  	return _rl_bind_key($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_key($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_bind_key_if_unbound
  sub rl_bind_key_if_unbound ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_key_if_unbound() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_key_if_unbound($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_key_if_unbound($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_unbind_key
  sub unbind_key ($;$) {
      if (defined $_[1]) {
  	return _rl_unbind_key($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_key($_[0]);
      }
  }
  
  # rl_unbind_function
  sub unbind_function ($;$) {
      # libreadline.* in Debian GNU/Linux 2.0 tells wrong value as '2.1-bash'
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 2.2) {
  	carp "rl_unbind_function() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[1]) {
  	return _rl_unbind_function($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_function($_[0]);
      }
  }
  
  # rl_unbind_command
  sub unbind_command ($;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 2.2) {
  	carp "rl_unbind_command() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[1]) {
  	return _rl_unbind_command($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_command($_[0]);
      }
  }
  
  # rl_bind_keyseq
  sub rl_bind_keyseq ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_keyseq() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_keyseq($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_keyseq($_[0], _str2fn($_[1]));
      }
  }
  
  sub rl_set_key ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_set_key() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_set_key($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_set_key($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_bind_keyseq_if_unbound
  sub rl_bind_keyseq_if_unbound ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_keyseq_if_unbound() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_keyseq_if_unbound($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_keyseq_if_unbound($_[0], _str2fn($_[1]));
      }
  }
  
  sub rl_macro_bind ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if (defined $_[2]) {
  	return _rl_macro_bind($_[0], $_[1], _str2map($_[2]));
      } else {
  	return _rl_macro_bind($_[0], $_[1]);
      }
  }
  
  sub rl_generic_bind ($$$;$) {
      if      ($_[0] == Term::ReadLine::Gnu::ISFUNC) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_function($_[1], _str2fn($_[2]), _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_function($_[1], _str2fn($_[2]));
  	}
      } elsif ($_[0] == Term::ReadLine::Gnu::ISKMAP) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_keymap($_[1], _str2map($_[2]), _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_keymap($_[1], _str2map($_[2]));
  	}
      } elsif ($_[0] == Term::ReadLine::Gnu::ISMACR) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_macro($_[1], $_[2], _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_macro($_[1], $_[2]);
  	}
      } else {
  	carp("Term::ReadLine::Gnu::rl_generic_bind: invalid \`type\'\n");
      }
  }
  
  sub rl_call_function ($;$$) {
      if (defined $_[2]) {
  	return _rl_call_function(_str2fn($_[0]), $_[1], $_[2]);
      } elsif (defined $_[1]) {
  	return _rl_call_function(_str2fn($_[0]), $_[1]);
      } else {
  	return _rl_call_function(_str2fn($_[0]));
      }
  }
  
  sub rl_invoking_keyseqs ($;$) {
      if (defined $_[1]) {
  	return _rl_invoking_keyseqs(_str2fn($_[0]), _str2map($_[1]));
      } else {
  	return _rl_invoking_keyseqs(_str2fn($_[0]));
      }
  }
  
  sub rl_add_funmap_entry ($$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_add_funmap_entry() is not supported.  Ignored\n";
  	return;
      }
      return _rl_add_funmap_entry($_[0], _str2fn($_[1]));
  }
  
  sub rl_tty_set_default_bindings (;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_tty_set_default_bindings() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[0]) {
  	return _rl_tty_set_defaut_bindings(_str2map($_[1]));
      } else {
  	return _rl_tty_set_defaut_bindings();
      }
  }
  
  sub rl_tty_unset_default_bindings (;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_tty_unset_default_bindings() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[0]) {
  	return _rl_tty_unset_defaut_bindings(_str2map($_[1]));
      } else {
  	return _rl_tty_unset_defaut_bindings();
      }
  }
  
  sub rl_message {
      my $fmt = shift;
      my $line = sprintf($fmt, @_);
      _rl_message($line);
  }
  
  sub rl_completion_mode {
      # libreadline.* in Debian GNU/Linux 2.0 tells wrong value as '2.1-bash'
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.3) {
  	carp "rl_completion_mode() is not supported.  Ignored\n";
  	return;
      }
      return _rl_completion_mode(_str2fn($_[0]));
  }
  
  #
  #	for compatibility with Term::ReadLine::Perl
  #
  sub rl_filename_list {
      my ($text) = @_;
  
      # lcd : lowest common denominator
      my ($lcd, @matches) = rl_completion_matches($text,
  						\&rl_filename_completion_function);
      return @matches ? @matches : $lcd;
  }
  
  #
  #	History Library function wrappers
  #
  # history_list
  sub hist_list () {
      my ($i, $history_base, $history_length, @d);
      $history_base   = $Attribs{history_base};
      $history_length = $Attribs{history_length};
      for ($i = $history_base; $i < $history_base + $history_length; $i++) {
  	push(@d, history_get($i));
      }
      @d;
  }
  
  # history_arg_extract
  sub hist_arg_extract ( ;$$$ ) {
      my ($line, $first, $last) = @_;
      $line  = $_      unless defined $line;
      $first = 0       unless defined $first;
      $last  = ord '$' unless defined $last; # '
      $first = ord '$' if defined $first and $first eq '$'; # '
      $last  = ord '$' if defined $last  and $last  eq '$'; # '
      &_history_arg_extract($line, $first, $last);
  }
  
  sub get_history_event ( $$;$ ) {
      _get_history_event($_[0], $_[1], defined $_[2] ? ord $_[2] : 0);
  }
  
  #
  #	Ornaments
  #
  
  # This routine originates in Term::ReadLine.pm.
  
  # Debian GNU/Linux discourages users from using /etc/termcap.  A
  # subroutine ornaments() defined in Term::ReadLine.pm uses
  # Term::Caps.pm which requires /etc/termcap.
  
  # This module calls termcap (or its compatible) library, which the GNU
  # Readline Library already uses, instead of Term::Caps.pm.
  
  # Some terminals do not support 'ue' (underline end).
  use vars qw(%term_no_ue);
  %term_no_ue = ( kterm => 1 );
  
  sub ornaments {
      return $rl_term_set unless @_;
      $rl_term_set = shift;
      $rl_term_set ||= ',,,';
      $rl_term_set = $term_no_ue{$ENV{TERM}} ? 'us,me,,' : 'us,ue,,'
  	if $rl_term_set eq '1';
      my @ts = split /,/, $rl_term_set, 4;
      my @rl_term_set
  	= map {
  	    # non-printing characters must be informed to readline
  	    my $t;
  	    ($_ and $t = tgetstr($_))
  		? (Term::ReadLine::Gnu::RL_PROMPT_START_IGNORE
  		   . $t
  		   . Term::ReadLine::Gnu::RL_PROMPT_END_IGNORE)
  		    : '';
  	} @ts;
      $Attribs{term_set} = \@rl_term_set;
      return $rl_term_set;
  }
  
  #
  #	a sample custom function
  #
  
  # The equivalent of the Bash shell M-^ history-expand-line editing
  # command.
  
  # This routine was borrowed from bash.
  sub history_expand_line {
      my ($count, $key) = @_;
      my ($expanded, $new_line) = history_expand($Attribs{line_buffer});
      if ($expanded > 0) {
    	rl_modifying(0, $Attribs{end}); # save undo information
    	$Attribs{line_buffer} = $new_line;
      } elsif ($expanded < 0) {
    	my $OUT = $Attribs{outstream};
    	print $OUT "\n$new_line\n";
    	rl_on_new_line();
      }				# $expanded == 0 : no change
  }
  
  # The equivalent of the Korn shell C-o operate-and-get-next-history-line
  # editing command. 
  
  # This routine was borrowed from bash.
  sub operate_and_get_next {
      my ($count, $key) = @_;
  
      my $saved_history_line_to_use = -1;
      my $old_rl_startup_hook;
  
      # Accept the current line.
      rl_call_function('accept-line', 1, $key);
  
      # Find the current line, and find the next line to use. */
      my $where = where_history();
      if ((history_is_stifled()
  	 && ($Attribs{history_length} >= $Attribs{max_input_history}))
  	|| ($where >= $Attribs{history_length} - 1)) {
  	$saved_history_line_to_use = $where;
      } else {
  	$saved_history_line_to_use = $where + 1;
      }
      $old_rl_startup_hook = $Attribs{startup_hook};
      $Attribs{startup_hook} = sub {
  	if ($saved_history_line_to_use >= 0) {
  	    rl_call_function('previous-history',
  			     $Attribs{history_length}
  			     - $saved_history_line_to_use,
  			     0);
  	    $Attribs{startup_hook} = $old_rl_startup_hook;
  	    $saved_history_line_to_use = -1;
  	}
      };
  }
  
  sub display_readline_version {	# show version
      my($count, $key) = @_;	# ignored in this function
      my $OUT = $Attribs{outstream};
      print $OUT
  	("\nTerm::ReadLine::Gnu version: $Term::ReadLine::Gnu::VERSION");
      print $OUT
  	("\nGNU Readline Library version: $Attribs{library_version}\n");
      rl_on_new_line();
  }
  
  # sample function of rl_message()
  sub change_ornaments {
      my($count, $key) = @_;	# ignored in this function
      rl_save_prompt;
      rl_message("[S]tandout, [U]nderlining, [B]old, [R]everse, [V]isible bell: ");
      my $c = chr rl_read_key;
      if ($c =~ /s/i) {
  	ornaments('so,me,,');
      } elsif ($c =~ /u/i) {
  	ornaments('us,me,,');
      } elsif ($c =~ /b/i) {
  	ornaments('md,me,,');
      } elsif ($c =~ /r/i) {
  	ornaments('mr,me,,');
      } elsif ($c =~ /v/i) {
  	ornaments('vb,,,');
      } else {
  	rl_ding;
      }
      rl_restore_prompt;
      rl_clear_message;
  }
  
  #
  #	for tkRunning
  #
  sub Tk_getc {
      &Term::ReadLine::Tk::Tk_loop
  	if $Term::ReadLine::toloop && defined &Tk::DoOneEvent;
      my $FILE = $Attribs{instream};
      return rl_getc($FILE);
  }
  
  # redisplay function for secret input like password
  # usage:
  #	$a->{redisplay_function} = $a->{shadow_redisplay};
  #	$line = $t->readline("password> ");
  sub shadow_redisplay {
      @_tstrs = _tgetstrs() unless $_tstrs_init;
      # remove prompt start/end mark from prompt string
      my $prompt = $Attribs{prompt}; my $s;
      $s = Term::ReadLine::Gnu::RL_PROMPT_START_IGNORE; $prompt =~ s/$s//g;
      $s = Term::ReadLine::Gnu::RL_PROMPT_END_IGNORE;   $prompt =~ s/$s//g;
      my $OUT = $Attribs{outstream};
      my $oldfh = select($OUT); $| = 1; select($oldfh);
      print $OUT ($_tstrs[0],	# carriage return
  		$_tstrs[1],	# clear to EOL
  		$prompt, '*' x length($Attribs{line_buffer}));
      print $OUT ($_tstrs[2]	# cursor left
  		x (length($Attribs{line_buffer}) - $Attribs{point}));
      $oldfh = select($OUT); $| = 0; select($oldfh);
  }
  
  sub _tgetstrs {
      my @s = (tgetstr('cr'),	# carriage return
  	     tgetstr('ce'),	# clear to EOL
  	     tgetstr('le'));	# cursor left
      warn <<"EOM" unless (defined($s[0]) && defined($s[1]) && defined($s[2]));
  Your terminal 'TERM=$ENV{TERM}' does not support enough function.
  Check if your environment variable 'TERM' is set correctly.
  EOM
      # suppress warning "Use of uninitialized value in print at ..."
      $s[0] = $s[0] || ''; $s[1] = $s[1] || ''; $s[2] = $s[2] || '';
      $_tstrs_init = 1;
      return @s;
  }
  
  # callback handler wrapper function for CallbackHandlerInstall method
  sub _ch_wrapper {
      my $line = shift;
  
      if (defined $line) {
  	if ($Attribs{do_expand}) {
  	    my $result;
  	    ($result, $line) = history_expand($line);
  	    my $outstream = $Attribs{outstream};
  	    print $outstream "$line\n" if ($result);
  
  	    # return without adding line into history
  	    if ($result < 0 || $result == 2) {
  		return '';	# don't return `undef' which means EOF.
  	    }
  	}
  
  	# add to history buffer
  	add_history($line) 
  	    if ($Attribs{MinLength} > 0
  		&& length($line) >= $Attribs{MinLength});
      }
      &{$Attribs{_callback_handler}}($line);
  }
  
  #
  #	List Completion Function
  #
  sub list_completion_function ( $$ ) {
      my($text, $state) = @_;
  
      $_i = $state ? $_i + 1 : 0;	# clear counter at the first call
      my $cw = $Attribs{completion_word};
      for (; $_i <= $#{$cw}; $_i++) {
  	return $cw->[$_i] if ($cw->[$_i] =~ /^\Q$text/);
      }
      return undef;
  }
  
  #
  #	wrapper completion function of 'completion_function'
  #	for compatibility with Term::ReadLine::Perl
  #
  sub _trp_completion_function ( $$ ) {
      my($text, $state) = @_;
  
      my $cf;
      return undef unless defined ($cf = $Attribs{completion_function});
  
      if ($state) {
  	$_i++;
      } else {
  	# the first call
  	$_i = 0;		# clear index
  	@_matches = &$cf($text,
  			 $Attribs{line_buffer},
  			 $Attribs{point} - length($text));
  	# return here since $#_matches is 0 instead of -1 when
  	# @_matches = undef
  	return undef unless defined $_matches[0];
      }
  
      return $_matches[$_i];
  }
  
  1;
  
  __END__
X86_64-LINUX-THREAD-MULTI_TERM_READLINE_GNU_XS

$fatpacked{"x86_64-linux-thread-multi/Test/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TEST_MOOSE';
  package Test::Moose;
  BEGIN {
    $Test::Moose::AUTHORITY = 'cpan:STEVAN';
  }
  $Test::Moose::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Sub::Exporter;
  use Test::Builder;
  
  use List::MoreUtils 'all';
  use Moose::Util 'does_role', 'find_meta';
  
  my @exports = qw[
      meta_ok
      does_ok
      has_attribute_ok
      with_immutable
  ];
  
  Sub::Exporter::setup_exporter({
      exports => \@exports,
      groups  => { default => \@exports }
  });
  
  ## the test builder instance ...
  
  my $Test = Test::Builder->new;
  
  ## exported functions
  
  sub meta_ok ($;$) {
      my ($class_or_obj, $message) = @_;
  
      $message ||= "The object has a meta";
  
      if (find_meta($class_or_obj)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub does_ok ($$;$) {
      my ($class_or_obj, $does, $message) = @_;
  
      $message ||= "The object does $does";
  
      if (does_role($class_or_obj, $does)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub has_attribute_ok ($$;$) {
      my ($class_or_obj, $attr_name, $message) = @_;
  
      $message ||= "The object does has an attribute named $attr_name";
  
      my $meta = find_meta($class_or_obj);
  
      if ($meta->find_attribute_by_name($attr_name)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub with_immutable (&@) {
      my $block = shift;
      my $before = $Test->current_test;
      my $passing_before = (Test::Builder->VERSION < 1.005 ? 0 : $Test->history->pass_count) || 0;
  
      $block->(0);
      Class::MOP::class_of($_)->make_immutable for @_;
      $block->(1);
  
      my $num_tests = $Test->current_test - $before;
      my $all_passed = Test::Builder->VERSION < 1.005
          ? all { $_ } ($Test->summary)[-$num_tests..-1]
          : $num_tests == $Test->history->pass_count - $passing_before;
      return $all_passed;
  }
  
  1;
  
  # ABSTRACT: Test functions for Moose specific features
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Moose - Test functions for Moose specific features
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    use Test::More plan => 1;
    use Test::Moose;
  
    meta_ok($class_or_obj, "... Foo has a ->meta");
    does_ok($class_or_obj, $role, "... Foo does the Baz role");
    has_attribute_ok($class_or_obj, $attr_name, "... Foo has the 'bar' attribute");
  
  =head1 DESCRIPTION
  
  This module provides some useful test functions for Moose based classes. It
  is an experimental first release, so comments and suggestions are very welcome.
  
  =head1 EXPORTED FUNCTIONS
  
  =over 4
  
  =item B<meta_ok ($class_or_object)>
  
  Tests if a class or object has a metaclass.
  
  =item B<does_ok ($class_or_object, $role, ?$message)>
  
  Tests if a class or object does a certain role, similar to what C<isa_ok>
  does for the C<isa> method.
  
  =item B<has_attribute_ok($class_or_object, $attr_name, ?$message)>
  
  Tests if a class or object has a certain attribute, similar to what C<can_ok>
  does for the methods.
  
  =item B<with_immutable { CODE } @class_names>
  
  Runs B<CODE> (which should contain normal tests) twice, and make each
  class in C<@class_names> immutable in between the two runs.
  
  The B<CODE> block is called with a single boolean argument indicating whether
  or not the classes have been made immutable yet.
  
  =back
  
  =head1 TODO
  
  =over 4
  
  =item Convert the Moose test suite to use this module.
  
  =item Here is a list of possible functions to write
  
  =over 4
  
  =item immutability predicates
  
  =item anon-class predicates
  
  =item discovering original method from modified method
  
  =item attribute metaclass predicates (attribute_isa?)
  
  =back
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Test::More>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_TEST_MOOSE

$fatpacked{"x86_64-linux-thread-multi/YAML/Dumper/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_DUMPER_SYCK';
  package YAML::Dumper::Syck;
  use strict;
  
  sub new { $_[0] }
  sub dump { shift; YAML::Syck::Dump( $_[0] ) }
  
  1;
X86_64-LINUX-THREAD-MULTI_YAML_DUMPER_SYCK

$fatpacked{"x86_64-linux-thread-multi/YAML/Loader/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_LOADER_SYCK';
  package YAML::Loader::Syck;
  use strict;
  
  sub new { $_[0] }
  sub load { shift; YAML::Syck::Load( $_[0] ) }
  
  1;
X86_64-LINUX-THREAD-MULTI_YAML_LOADER_SYCK

$fatpacked{"x86_64-linux-thread-multi/YAML/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_SYCK';
  package YAML::Syck;
  
  # See documentation after the __END__ mark.
  
  use strict;
  use vars qw(
    @ISA @EXPORT @EXPORT_OK $VERSION
    $Headless $SortKeys $SingleQuote
    $ImplicitBinary $ImplicitTyping $ImplicitUnicode
    $UseCode $LoadCode $DumpCode
    $DeparseObject $LoadBlessed
  );
  use 5.006;
  use Exporter;
  
  BEGIN {
      $VERSION   = '1.27';
      @EXPORT    = qw( Dump Load DumpFile LoadFile );
      @EXPORT_OK = qw( DumpInto );
      @ISA       = qw( Exporter );
  
      $SortKeys    = 1;
      $LoadBlessed = 1;
  
      local $@;
      eval {
          require XSLoader;
          XSLoader::load( __PACKAGE__, $VERSION );
          1;
      } or do {
          require DynaLoader;
          push @ISA, 'DynaLoader';
          __PACKAGE__->bootstrap($VERSION);
      };
  
  }
  
  use constant QR_MAP => {
      ''   => sub { qr{$_[0]} },
      x    => sub { qr{$_[0]}x },
      i    => sub { qr{$_[0]}i },
      s    => sub { qr{$_[0]}s },
      m    => sub { qr{$_[0]}m },
      ix   => sub { qr{$_[0]}ix },
      sx   => sub { qr{$_[0]}sx },
      mx   => sub { qr{$_[0]}mx },
      si   => sub { qr{$_[0]}si },
      mi   => sub { qr{$_[0]}mi },
      ms   => sub { qr{$_[0]}sm },
      six  => sub { qr{$_[0]}six },
      mix  => sub { qr{$_[0]}mix },
      msx  => sub { qr{$_[0]}msx },
      msi  => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub __qr_helper {
      if ( $_[0] =~ /\A  \(\?  ([ixsm]*)  (?:-  (?:[ixsm]*))?  : (.*) \)  \z/x ) {
          my $sub = QR_MAP()->{$1} || QR_MAP()->{''};
          &$sub($2);
      }
      else {
          qr/$_[0]/;
      }
  }
  
  sub Dump {
      $#_
        ? join( '', map { YAML::Syck::DumpYAML($_) } @_ )
        : YAML::Syck::DumpYAML( $_[0] );
  }
  
  sub Load {
      if (wantarray) {
          my ($rv) = YAML::Syck::LoadYAML( $_[0] );
          @{$rv};
      }
      else {
          @_ = $_[0];
          goto &YAML::Syck::LoadYAML;
      }
  }
  
  sub _is_glob {
      my $h = shift;
  
      return 1 if ( ref($h) eq 'GLOB' );
      return 1 if ( ref( \$h ) eq 'GLOB' );
      return 1 if ( ref($h) =~ m/^IO::/ );
  
      return;
  }
  
  sub DumpFile {
      my $file = shift;
      if ( _is_glob($file) ) {
          for (@_) {
              my $err = YAML::Syck::DumpYAMLFile( $_, $file );
              if ($err) {
                  $! = 0 + $err;
                  die "Error writing to filehandle $file: $!\n";
              }
          }
      }
      else {
          open( my $fh, '>', $file ) or die "Cannot write to $file: $!";
          for (@_) {
              my $err = YAML::Syck::DumpYAMLFile( $_, $fh );
              if ($err) {
                  $! = 0 + $err;
                  die "Error writing to file $file: $!\n";
              }
          }
          close $fh
            or die "Error writing to file $file: $!\n";
      }
      return 1;
  }
  
  sub LoadFile {
      my $file = shift;
      if ( _is_glob($file) ) {
          Load(
              do { local $/; <$file> }
          );
      }
      else {
          if ( !-e $file || -z $file ) {
              die("'$file' is empty or non-existent");
          }
          open( my $fh, '<', $file ) or die "Cannot read from $file: $!";
          Load(
              do { local $/; <$fh> }
          );
      }
  }
  
  sub DumpInto {
      my $bufref = shift;
      ( ref $bufref ) or die "DumpInto not given reference to output buffer\n";
      YAML::Syck::DumpYAMLInto( $_, $bufref ) for @_;
      1;
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME 
  
  YAML::Syck - Fast, lightweight YAML loader and dumper
  
  =head1 SYNOPSIS
  
      use YAML::Syck;
  
      # Set this for interoperability with other YAML/Syck bindings:
      # e.g. Load('Yes') becomes 1 and Load('No') becomes ''.
      $YAML::Syck::ImplicitTyping = 1;
  
      $data = Load($yaml);
      $yaml = Dump($data);
  
      # $file can be an IO object, or a filename
      $data = LoadFile($file);
      DumpFile($file, $data);
  
      # A string with multiple YAML streams in it
      $yaml = Dump(@data);
      @data = Load($yaml);
  
      # Dumping into a pre-existing output buffer
      my $yaml;
      DumpInto(\$yaml, @data);
  
  =head1 DESCRIPTION
  
  This module provides a Perl interface to the B<libsyck> data serialization
  library.  It exports the C<Dump> and C<Load> functions for converting
  Perl data structures to YAML strings, and the other way around.
  
  B<NOTE>: If you are working with other language's YAML/Syck bindings
  (such as Ruby), please set C<$YAML::Syck::ImplicitTyping> to C<1> before
  calling the C<Load>/C<Dump> functions.  The default setting is for
  preserving backward-compatibility with C<YAML.pm>.
  
  =head1 Differences Between YAML::Syck and YAML
  
  =head2 Error handling
  
  Some calls are designed to die rather than returning YAML. You should wrap
  your calls in eval to assure you do not get unexpected results.
  
  =head1 FLAGS
  
  =head2 $YAML::Syck::Headless
  
  Defaults to false.  Setting this to a true value will make C<Dump> omit the
  leading C<---\n> marker.
  
  =head2 $YAML::Syck::SortKeys
  
  Defaults to false.  Setting this to a true value will make C<Dump> sort
  hash keys.
  
  =head2 $YAML::Syck::SingleQuote
  
  Defaults to false.  Setting this to a true value will make C<Dump> always emit
  single quotes instead of bare strings.
  
  =head2 $YAML::Syck::ImplicitTyping
  
  Defaults to false.  Setting this to a true value will make C<Load> recognize
  various implicit types in YAML, such as unquoted C<true>, C<false>, as well as
  integers and floating-point numbers.  Otherwise, only C<~> is recognized to
  be C<undef>.
  
  =head2 $YAML::Syck::ImplicitUnicode
  
  Defaults to false.  For Perl 5.8.0 or later, setting this to a true value will
  make C<Load> set Unicode flag on for every string that contains valid UTF8
  sequences, and make C<Dump> return a unicode string.
  
  Regardless of this flag, Unicode strings are dumped verbatim without escaping;
  byte strings with high-bit set will be dumped with backslash escaping.
  
  However, because YAML does not distinguish between these two kinds of strings,
  so this flag will affect loading of both variants of strings.
  
  If you want to use LoadFile or DumpFile with unicode, you are required to open
  your own file in order to assure it's UTF8 encoded:
  
    open(my $fh, ">:encoding(UTF-8)", "out.yml");
    DumpFile($fh, $hashref);
  
  =head2 $YAML::Syck::ImplicitBinary
  
  Defaults to false.  For Perl 5.8.0 or later, setting this to a true value will
  make C<Dump> generate Base64-encoded C<!!binary> data for all non-Unicode
  scalars containing high-bit bytes.
  
  =head2 $YAML::Syck::UseCode / $YAML::Syck::LoadCode / $YAML::Syck::DumpCode
  
  These flags control whether or not to try and eval/deparse perl source code;
  each of them defaults to false.
  
  Setting C<$YAML::Syck::UseCode> to a true value is equivalent to setting
  both C<$YAML::Syck::LoadCode> and C<$YAML::Syck::DumpCode> to true.
  
  =head2 $YAML::Syck::LoadBlessed
  
  Defaults to true. Setting to false will block YAML::Syck from doing ANY
  blessing. This is an interface change since 1.21. The variable name was
  misleading, implying that no blessing would happen when in fact it did.
  
  Prior to 1.22, setting this to a false value only prevented C<Load> from
  blessing tag names that did not begin with C<!!perl> or C<!perl>;.
  
  =head1 BUGS
  
  Dumping Glob/IO values do not work yet.
  
  Dumping of Tied variables is unsupported.
  
  Dumping into tied (or other magic variables) with C<DumpInto> might not work
  properly in all cases.
  
  =head1 CAVEATS
  
  This module implements the YAML 1.0 spec.  To deal with data in YAML 1.1, 
  please use the C<YAML::XS> module instead.
  
  The current implementation bundles libsyck source code; if your system has a
  site-wide shared libsyck, it will I<not> be used.
  
  Tag names such as C<!!perl/hash:Foo> is blessed into the package C<Foo>, but
  the C<!hs/foo> and C<!!hs/Foo> tags are blessed into C<hs::Foo>.  Note that
  this holds true even if the tag contains non-word characters; for example,
  C<!haskell.org/Foo> is blessed into C<haskell.org::Foo>.  Please use
  L<Class::Rebless> to cast it into other user-defined packages. You can also
  set the LoadBlessed flag false to disable all blessing.
  
  This module has L<a lot of known
  issues|https://rt.cpan.org/Public/Dist/Display.html?Name=YAML-Syck>
  and has only been semi-actively maintained since 2007. If you
  encounter an issue with it probably won't be fixed unless you L<offer
  up a patch|http://github.com/toddr/YAML-Syck> in Git that's ready for
  release.
  
  There are still good reasons to use this module, such as better
  interoperability with other syck wrappers (like Ruby's), or some edge
  case of YAML's syntax that it handles better. It'll probably work
  perfectly for you, but if it doesn't you may want to look at
  L<YAML::XS>, or perhaps at looking another serialization format like
  L<JSON>.
  
  =head1 SEE ALSO
  
  L<YAML>, L<JSON::Syck>
  
  L<http://www.yaml.org/>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005-2009 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  The F<libsyck> code bundled with this library is released by
  "why the lucky stiff", under a BSD-style license.  See the F<COPYING>
  file for details.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
X86_64-LINUX-THREAD-MULTI_YAML_SYCK

$fatpacked{"x86_64-linux-thread-multi/metaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_METACLASS';
  
  package metaclass;
  BEGIN {
    $metaclass::AUTHORITY = 'cpan:STEVAN';
  }
  $metaclass::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Module::Runtime 'use_package_optimistically';
  use Class::Load  'load_class';
  use Scalar::Util 'blessed';
  use Try::Tiny;
  
  use Class::MOP;
  
  use Moose::Util 'throw_exception';
  
  sub import {
      my ( $class, @args ) = @_;
  
      unshift @args, "metaclass" if @args % 2 == 1;
      my %options = @args;
  
      my $meta_name = exists $options{meta_name} ? $options{meta_name} : 'meta';
      my $metaclass = delete $options{metaclass};
  
      unless ( defined $metaclass ) {
          $metaclass = "Class::MOP::Class";
      } else {
          use_package_optimistically($metaclass);
      }
  
      ($metaclass->isa('Class::MOP::Class'))
          || throw_exception( MetaclassMustBeDerivedFromClassMOPClass => class_name => $metaclass );
  
      # make sure the custom metaclasses get loaded
      foreach my $key (grep { /_(?:meta)?class$/ } keys %options) {
          unless ( ref( my $class = $options{$key} ) ) {
              use_package_optimistically($class)
          }
      }
  
      my $package = caller();
  
      # create a meta object so we can install &meta
      my $meta = $metaclass->initialize($package => %options);
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  }
  
  1;
  
  # ABSTRACT: a pragma for installing and using Class::MOP metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  metaclass - a pragma for installing and using Class::MOP metaclasses
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    package MyClass;
  
    # use Class::MOP::Class
    use metaclass;
  
    # ... or use a custom metaclass
    use metaclass 'MyMetaClass';
  
    # ... or use a custom metaclass
    # and custom attribute and method
    # metaclasses
    use metaclass 'MyMetaClass' => (
        'attribute_metaclass' => 'MyAttributeMetaClass',
        'method_metaclass'    => 'MyMethodMetaClass',
    );
  
    # ... or just specify custom attribute
    # and method classes, and Class::MOP::Class
    # is the assumed metaclass
    use metaclass (
        'attribute_metaclass' => 'MyAttributeMetaClass',
        'method_metaclass'    => 'MyMethodMetaClass',
    );
  
    # if we'd rather not install a 'meta' method, we can do this
    use metaclass meta_name => undef;
    # or if we'd like it to have a different name,
    use metaclass meta_name => 'my_meta';
  
  =head1 DESCRIPTION
  
  This is a pragma to make it easier to use a specific metaclass
  and a set of custom attribute and method metaclasses. It also
  installs a C<meta> method to your class as well, unless C<undef>
  is passed to the C<meta_name> option.
  
  Note that if you are using Moose, you most likely do B<not> want
  to be using this - look into L<Moose::Util::MetaRole> instead.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_METACLASS

$fatpacked{"x86_64-linux-thread-multi/oose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_OOSE';
  package oose;
  BEGIN {
    $oose::AUTHORITY = 'cpan:STEVAN';
  }
  $oose::VERSION = '2.1204';
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  BEGIN {
      my $package;
      sub import {
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              Moose::Util::_load_user_class($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moose;use Moose::Util::TypeConstraints;\n/; }
  }
  
  1;
  
  # ABSTRACT: syntactic sugar to make Moose one-liners easier
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  oose - syntactic sugar to make Moose one-liners easier
  
  =head1 VERSION
  
  version 2.1204
  
  =head1 SYNOPSIS
  
    # create a Moose class on the fly ...
    perl -Moose=Foo -e 'has bar => ( is=>q[ro], default => q[baz] ); print Foo->new->bar' # prints baz
  
    # loads an existing class (Moose or non-Moose)
    # and re-"opens" the package definition to make
    # debugging/introspection easier
    perl -Moose=+My::Class -e 'print join ", " => __PACKAGE__->meta->get_method_list'
  
    # also loads Moose::Util::TypeConstraints to allow subtypes etc
    perl -Moose=Person -e'subtype q[ValidAge] => as q[Int] => where { $_ > 0 && $_ < 78 }; has => age ( isa => q[ValidAge], is => q[ro]); Person->new(age => 90)'
  
  =head1 DESCRIPTION
  
  oose.pm is a simple source filter that adds
  C<package $name; use Moose; use Moose::Util::TypeConstraints;>
  to the beginning of your script and was entirely created because typing
  C<perl -e'package Foo; use Moose; ...'> was annoying me.
  
  =head1 INTERFACE
  
  oose provides exactly one method and it's automatically called by perl:
  
  =over 4
  
  =item B<import($package)>
  
  Pass a package name to import to be used by the source filter. The
  package defaults to C<Class> if none is given.
  
  =back
  
  =head1 DEPENDENCIES
  
  You will need L<Filter::Simple> and eventually L<Moose>
  
  =head1 INCOMPATIBILITIES
  
  None reported. But it is a source filter and might have issues there.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_OOSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use FindBin::libs;
use App::Rad qw(MoreHelp);
use App::Rad::Plugin::MoreHelp;

App::Rad->run();
use 5.014;
use strict;
use warnings;
use Data::Dumper;
use Sort::Naturally;
use Moo;
use App::Pipeline::Lite4::Command::viewpipeline;
use App::Pipeline::Lite4::Command::viewgraph;
use App::Pipeline::Lite4::Command::viewsystemconfig;
use App::Pipeline::Lite4::Command::new;
use App::Pipeline::Lite4::Command::run;
use App::Pipeline::Lite4::Command::file;
use App::Pipeline::Lite4::Command::symlink;

sub setup {
     my $c = shift;
     #$c->register( "setup", \&_setup, "setup pipelite" );
     $c->register_commands( {
         new => "create a new pipeline",          
         vp => "view pipeline",
         vg => "view pipeline graph",
         #vd => "view datasource",
         #vc => "view config",
         vsc => "view system config",
         #vl => "view log",
         #ve => "view error",
         run => "run pipeline",
         file => "get files",
         symlink => "symlink files"
         } );
}

sub _setup {
     
}

sub new {
     my $c = shift;
     my $desc = 'new PIPELINE_DIR';
     my %options = (
         'output_dir|d=s' => 'Sets output directory location'
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv }  == 0;
     App::Pipeline::Lite4::Command::new->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show "new" : IMPLEMENT !!!# 
}

sub vp {
     my $c = shift;
     my $desc = 'vc (view pipeline) [OPTIONS] PIPELINE_DIR';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vp -e vim. Overrides config file setting if exists.'
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     App::Pipeline::Lite4::Command::viewpipeline->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show the config file : IMPLEMENT !!!#
}

sub vg {
     my $c = shift;
     my $desc = 'vc (view pipeline graph) [OPTIONS] PIPELINE_DIR';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vp -e vim. Overrides config file setting if exists.'
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     App::Pipeline::Lite4::Command::viewgraph->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show the config file : IMPLEMENT !!!#
}

#sub vc {
#     my $c = shift;
#     my $desc = 'vc (view config) [OPTIONS] PIPELINE_DIR';
#     my %options = (
#         'editor|e=s' => 'Sets the editor e.g. plite vc -e vim. Overrides config file setting if exists.'
#     );
#     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
#     return join ' ', "Argument: ", $c->argv->flatten;      # else show the config file
#}

sub vsc {
     my $c = shift;
     my $desc = 'vsc (view system config) [OPTIONS]';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vc -e vim. Overrides config file setting if exists.',
         #'output_dir|o=s'         => "output file",
     );
     #return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     #print Dumper $c->options;
     App::Pipeline::Lite4::Command::viewsystemconfig->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      # else show the config file
}

sub ve {
     
}

sub vd {
     
}

sub vl {
    
}

sub run {
     my $c = shift;
     my $desc = 'run (run pipeline) [OPTIONS] PIPELINE';
     my %options = (
         'datasource|d=s' => 'Provides a path name to a datasource.',
         'smoke_test|m'   => 'Runs pipeline with out dispatching jobs',
         'run|r=i'        => 'Run on this run number',
         'steps|s=s'      => 'Run only these steps',
         'jobs|j=s'       => "Only run these jobs. Corresponds to rows in datasource. e.g --jobs '1,5,7-21' "
         # IN ORDER OF USEFULNESS: 
         # 'jobs|j=s'  => 'Run only on these job numbers (corresponds to rows in the datasource)'
         # 'run|r=i'   => 'Run on this run number',
         # 'steps|s=s' => 'Run only these steps'
         # '' 'output_dir|o=s'         => "output file",
     );
     
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;       
     $c->getopt( keys %options );   
     App::Pipeline::Lite4::Command::run->new->execute($c->options, $c->argv);
}

sub file {
     my $c = shift;
     my $desc = 'file (get pipeline output files) [OPTIONS] PIPELINE';
     my %options = (
     'run_num|r=i'  => 'run_num',
     'stats|s'      => 'Show stats (size and mtime)',
     'step_name|t'     => 'Show step name in header',
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;       
     $c->getopt( keys %options );   
     App::Pipeline::Lite4::Command::file->new->execute($c->options, $c->argv);
}

sub symlink {
    my $c = shift;
    my $desc = 'symlink (creates dir of symlinks) [OPTIONS] PIPELINE';
    my %options = (
           #'datasource|d=s' => 'Provides a path name to a datasource.',
          'run_num|r=i'  => 'run_num',
          'id_field|f=s'   => 'Field in the datasource that will be the file prefix',
          'step_and_fname|s=s' => 'Step and filename in format STEP#FILENAME (required)',
          'path|p=s' => 'Path of directory, which will be created if it does not exist',
          'name|n=s' => 'Replaces filename with new name'
          );  
      $c->getopt( keys %options );
      return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
      App::Pipeline::Lite4::Command::symlink->new->execute($c->options, $c->argv);
}

sub _options_str {
    my $options = shift;
    my $options_str;
    foreach my $key ( nsort keys %$options ){
       my ($longform,$shortform) = $key =~ /(.+)\|([a-z]+)/;
       $options_str .= "\t-$shortform --$longform\t" . $options->{$key} . "\n";  
    }
    return $options_str; 
}

sub _usage {
    my $cmd = shift;
    my $options_str = _options_str( shift);
    my $usage = <<USAGE
    
Usage: plite $cmd
     $options_str
USAGE
;
    return $usage;
}
