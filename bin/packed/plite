#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Pipeline/Lite4.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4';
  use strict;
  use warnings;
  package App::Pipeline::Lite4;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  use Types::Path::Tiny qw/Path AbsPath/;
  extends 'App::Pipeline::Lite4::Base';
  use App::Pipeline::Lite4::Util;
  use App::Pipeline::Lite4::Parser; 
  use App::Pipeline::Lite4::Resolver;
  use App::Pipeline::Lite4::Grapher;
  use File::Copy;
  use Data::Dumper;
  has smoke_test => ( isa => 'Bool', is => 'rw', default => sub {0} ); 
  has external_dispatcher => ( isa => 'Path::Tiny|Undef', is => 'rw', 
                                lazy_build => 1 );
  
  sub _build_external_dispatcher {
      my $self = shift;  
        
      my $dispatcher = $self->config->{_}->{dispatcher}; #check local config 
      
      # if does not exist, check system config    
      $dispatcher = $self->system_config->{_}->{dispatcher} 
                                 unless defined( $dispatcher);
      
      defined($dispatcher) ?  path($dispatcher) : undef;    
  }
  
  sub util {
      my $self = shift;
      # give back object with utilities
      return App::Pipeline::Lite4::Util->new(  pipeline_dir => $self->pipeline_dir);
  }
  
  sub symlink {
      my $self      = shift;
      my $opt       = shift; # this is the options  with the id_field,symlinkdir if required
      #my $pipeline_file = shift;
      my $id_field = $opt->{id_field};
      
      my $STEP_AND_FNAME = $opt->{step_and_fname}; 
      
      my ($STEP,$FNAME);
      if( defined $STEP_AND_FNAME ){
        ($STEP,$FNAME) = split '#', $STEP_AND_FNAME;
      }
      
      my $parser = App::Pipeline::Lite4::Parser->new(
          pipeline_dir => $self->pipeline_dir,
       );
      
      $parser->preparse(  $self->pipeline_file, 
                          $self->pipeline_preparse_file ); 
      
      $parser->parse(  $self->pipeline_preparse_file, 
                       $self->pipeline_parse_file  );
      #warn "WORKING WITH DATASOURCE: " .    $self->datasource_file;
        
      my $resolver = App::Pipeline::Lite4::Resolver->new (                      
                         pipeline_dir         => $self->pipeline_dir,
                         #datasource_file     => $self->datasource_resolved_file,
                         #datasource_file      => defined( $opt->{datasource} ) ? $opt->{datasource} : $self->datasource_file,
                         datasource_file     => $self->datasource_file,
                         current_run_num      => defined( $self->run_num ) ? $self->run_num : undef,
                         step_filter_str      => defined( $self->step_filter_str) ? $self->step_filter_str : undef,
                         job_filter_str       => defined( $self->job_filter_str) ? $self->job_filter_str : undef,
                         #run_num_dep         => defined( $self->run_num_dep ) ? $self->run_num_dep : undef
                         );   
                         
      #warn Dumper $resolver->pipeline_datasource;                                          
      $resolver->resolve($self->pipeline_parse_file,$self->pipeline_resolved_file);
          
      my $datasource = $resolver->pipeline_datasource;
      
      # read resolved file YAML
      my $resolved_file_yaml = $self->pipeline_resolved_file->slurp;
      my $resolved_pipeline  = Load($resolved_file_yaml);
      my $output_run_dir = path( $self->output_dir, "run" . $self->run_num );
     
      foreach my $job_num (keys %$resolved_pipeline){
          my $job = $resolved_pipeline->{$job_num};         
          foreach my $step (keys %$job) {
              my $job_ids;   # A job_id is a label attached to each job based on the values in a column (specified by id_field) of the datasource
  
              if (defined ($STEP_AND_FNAME) ){
                 next unless $step eq $STEP;
              }
  
              my $symlink_dir = path($resolver->symlink_dir, $step, $self->run_num);
              $symlink_dir->mkpath;
              my $condition = $job->{$step}->{condition};                   
              if(defined($condition) && $condition eq 'groupby'){
                 my $condition_params = $job->{$step}->{condition_params};
                 $job_ids = $self->_get_job_ids($id_field,$datasource,$condition_params);
                 my $num_jobs = scalar @$job_ids;
                 #warn "groupby step in symlink";
                 next if $job_num >= $num_jobs ;
              }else{
                 # get the job ids  
                 $job_ids = $self->_get_job_ids($id_field,$datasource,undef);
              }
              
              if( defined $STEP_AND_FNAME ){
                  my $file_path = path($output_run_dir,"job$job_num",$step,$FNAME);  
                  if( $file_path->exists ) {
                      my $path_to_link = $file_path;
                      $self->_symlink_paths($job_num, $path_to_link,$job_ids,$symlink_dir,$opt->{name});
                  }else{
                      warn "path $file_path does not exist - SYMLINK NOT MADE";
                  }
                  next;
              }
  
              my $outputfiles = $job->{$step}->{outputfiles};
              foreach my $outputfile ( @$outputfiles ){
                 # warn "OUTPUTFILE: ", $outputfile,"\n";           
                 my  $outputfile_path = path($output_run_dir,"job$job_num",$step,$outputfile);  
                 # warn "LOOKING FOR $outputfile_path";          
                 if( $outputfile_path->exists ) {
                 #    warn "FOUND: ", $outputfile_path;
                 #    my $symlink_path = path($symlink_dir,$job_ids->[$job_num]);
                 #    warn "SYMLINK $outputfile_path $symlink_path";
                    my $path_to_link = $outputfile_path;
                    $self->_symlink_paths($job_num, $path_to_link,$job_ids,$symlink_dir,$opt->{name});
                 }            
               }
           
              my $placeholders= $job->{$step}->{placeholders};
              foreach my $placeholder ( @$placeholders ){
                  my $path_to_link;
                  # warn "PLACEHOLDER: ", $placeholder,"\n";
                  my ($file ) = $placeholder =~ /$step\.(.+)/;
                  if( defined $file ){           
              
                     my  $file_path = path($output_run_dir,"job$job_num",$step,$file);    
                     #  warn "Looking for $file in $file_path";        
                     if( $file_path->exists ) {
                         #warn "FOUND: ", $file_path;     
                         my $path_to_link = $file_path; 
                         $self->_symlink_paths($job_num,$path_to_link,$job_ids,$symlink_dir,$opt->{name});        
                     }
                  }else{
                        #warn "no file in $placeholder";
                  }
           }
         }
      }   
  }
   
  sub _symlink_paths {
      my $self = shift;
      my $job_num = shift;
      my $path_to_link =shift;
      my $job_ids =shift;
      my $symlink_dir = shift;
      my $name = shift;
      
      if(defined $path_to_link){
               my $id =$job_ids->[$job_num];
               my $new_basename = "$id-".$path_to_link->basename;
               if( defined( $name )){
                  $new_basename = "$id$name" ;                                
                }     
               my $symlink_path = path($symlink_dir,$new_basename);        
               #my $symlink_path = path($symlink_dir,$job_ids->[$job_num],$file_path);
               print STDERR " SYMLINK $path_to_link $symlink_path\n";    
               CORE::symlink $path_to_link, $symlink_path;       
           }  
  } 
   
  sub _get_job_ids {
      my $self = shift;
      my $id_field = shift;  
      my $datasource = shift;
      my $groupby_fields = shift;
      
      my @job_ids ;
      if(defined $groupby_fields){
          my $groupby_field = $groupby_fields->[0];  # only one group by supported at the moment
          if( $groupby_field eq $id_field){      
              $datasource = $datasource->group([$groupby_field],[$id_field],[sub { $_[0] } ],["$id_field-group"] );
          }else{
              $datasource = $datasource->group([$groupby_field],[$id_field],[sub { join("-",@_) } ],["$id_field-group"] );
          }        
          #$self->logger->debug("Symlink - grouped datasource looks like " . $datasource->tsv );
          $id_field = "$id_field-group";
      }
     
      if( ! defined( $id_field) ){
             warn "No ID field defined. Prepending job numbers " ;
             @job_ids = map {"job$_"} (0 .. $datasource->nofRow -1 );
      }elsif( $datasource->hasCol($id_field) ){
             @job_ids = $datasource->col($id_field);
      }else{
             warn "No matching ID field in datasource. Prepending job numbers";
             @job_ids = map {"job$_"} (0 .. $datasource->nofRow -1 );
      }    
      return \@job_ids;  
  }
   
  
  sub run_pipeline {
      my $self = shift;   
      my $pipeline_file = shift; 
  
     # RESOLVE DATASOURCE HERE
  
      my $parser = App::Pipeline::Lite4::Parser->new(
          pipeline_dir => $self->pipeline_dir,
       );
      
      $parser->preparse(  $self->pipeline_file, 
                          $self->pipeline_preparse_file ); 
      
      $parser->parse(  $self->pipeline_preparse_file, 
                       $self->pipeline_parse_file  );
      #warn "WORKING WITH DATASOURCE: " .    $self->datasource_file;
        
      my $resolver = App::Pipeline::Lite4::Resolver->new (                      
                         pipeline_dir         => $self->pipeline_dir,
                         #datasource_file      => $self->datasource_resolved_file,
                         datasource_file      => $self->datasource_file,
                         current_run_num      => defined( $self->run_num ) ? $self->run_num : undef,
                         step_filter_str      => defined( $self->step_filter_str) ? $self->step_filter_str : undef,
                         job_filter_str       => defined( $self->job_filter_str) ? $self->job_filter_str : undef,
                         #run_num_dep          => defined( $self->run_num_dep ) ? $self->run_num_dep : undef
                         );   
                         
     #warn Dumper $resolver->pipeline_datasource;                                       
     
     $resolver->resolve($self->pipeline_parse_file,$self->pipeline_resolved_file); 
     
     
      my $grapher = App::Pipeline::Lite4::Grapher->new ( 
                         pipeline_dir    => $self->pipeline_dir,
                         datasource_file => $self->datasource_file,
                         );     
                                           
      $grapher->add_dependents(  $self->pipeline_resolved_file, 
                                 $self->pipeline_graph_file );                
       
      # copy stuff over to settings directory
      my $run_num = $resolver->current_run_num;
      $self->copy_pipeline_files_to_run_settings_dir($run_num); 
       
      if ( ! $self->smoke_test ) { 
     
        if( defined( $self->external_dispatcher ) ) {       
           $self->external_dispatch( $self->external_dispatcher );            
        } else {
            print "\n*** dispatcher not defined - see config file ***\n";
            # warn using local dispatch option
            #print "\n***\n\nUsing built in dispatcher\n\n***\n";
            #my $dispatcher = App::Pipeline::Lite4::Dispatcher->new( 
            #             pipeline_graph_file => $self->pipeline_graph_file,
            #             logfile => $self->logfile );                                      
            #$dispatcher->dispatch;    
       }
     }else{      
       $self->logger->debug("Smoke Test!");    
     }
     
  }
  
  sub external_dispatch {
     # TYPE  Path::Tiny :$dispatcher_exe )  {
      my $self=shift;
      my $dispatcher_exe=shift;
      
      my $pipeline_graph_file = $self->pipeline_graph_file->absolute;
      
      my $pipeline_dir = $self->pipeline_dir->absolute->stringify;
      ouch 'App_Pipeline_Lite4_Error', "Dispatcher does not exist at $dispatcher_exe" 
       unless $dispatcher_exe->exists;
      
       my $dispatcher_path_str = $dispatcher_exe->absolute->stringify;     
      ouch  'App_Pipeline_Lite4_Error', "Dispatcher app is not executable" 
        unless ( -x $dispatcher_path_str);  
        
      #my $dispatcher_cmd =  qq{ $dispatcher_path_str  $pipeline_dir };
      my $dispatcher_cmd =  qq{ $dispatcher_path_str  $pipeline_graph_file };
      system( $dispatcher_cmd );    
  }
  
  
  sub copy_pipeline_files_to_run_settings_dir  {
     
     my $self = shift;
     my $run_num = shift;
     $self->new_run_settings_dir($run_num)->mkpath unless $self->new_run_settings_dir($run_num)->exists;  
     
     copy( $self->pipeline_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy pipeline file to run settings directory";
     
     copy( $self->pipeline_graph_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy graph file to run settings directory";
      
     copy( $self->datasource_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy datasource file to run settings directory"; 
       
     #make a standardised version to the pipeline name 
     copy( $self->datasource_file->stringify , path( $self->run_settings_dir($run_num), $self->pipeline_name . ".datasource" )->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy datasource file to run settings directory"; 
      
     #copy( $self->datasource_resolved_file->stringify , $self->run_settings_dir($run_num)->stringify )
     #  or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy resolved datasource file to run settings directory"; 
       
     if( $self->software_ini_file->exists){ 
         copy( $self->software_ini_file->stringify , $self->run_settings_dir($run_num)->stringify )
           or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy software ini file to run settings directory";
     }
  }
  
  
  
  1;
APP_PIPELINE_LITE4

$fatpacked{"App/Pipeline/Lite4/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_BASE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Base;
  use Moo;
  use MooX::late;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  use Config::Tiny;
  use Ouch;
  use File::HomeDir; 
  use Data::Table;
  use App::Pipeline::Lite4::Logger; 
  use List::Util qw(max);
  
  has pipeline_dir  => ( isa => Path,  is => 'rw', coerce => 1, trigger  => \&_pipeline_dir_trigger);
  has use_relative_paths  => (isa => 'Bool', is => 'rw', default => sub {0});
  has pipeline_name    => ( isa => 'Str', is => 'rw', lazy_build => 1);
  has pipeline_file    => ( isa => Path, is => 'rw',  lazy_build => 1);
  has logfile          => ( isa => Path, is => 'rw', lazy_build => 1);
  has logconf          => ( isa => 'HashRef|Undef', is => 'rw', lazy_build => 1);
  has logconffile      => ( isa => Path, is => 'rw',  lazy_build => 1);
  has logger           => ( isa => 'App::Pipeline::Lite4::Logger', lazy_build=>1);
  has system_logfile   => ( isa => Path, is => 'rw',  lazy_build => 1);
  has system_logger    => ( isa => 'App::Pipeline::Lite4::Logger', lazy_build=>1);
  # config locations
  
  has config           => ( isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has config_file      => ( isa => Path, is => 'rw', coerce => 1, lazy_build => 1);
  has system_config      => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 ); 
  has system_config_file => ( isa => Path, is => 'rw', coerce => 1, lazy_build => 1);
  
  =cut
  has logconffile      => ( isa => Path, is => 'rw',  lazy_build => 1);
  =cut
  
  has output_dir       => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build => 1 );
  has input_dir        => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has input_ini        => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has input_ini_file   => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has sys_dir          => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has software_dir     => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has software_ini      => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has software_ini_file => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  
  has test_data_file   => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
  has datasource_file  => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
  has datasource_resolved_file  => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
   
  has pipeline_preparse_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_parse_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_resolved_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_graph_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 );
  has pipeline_submission_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 );
  has pipeline_datasource  => ( isa => 'Data::Table', is => 'rw', lazy_build =>1 ); #used in util.
  
  has symlink_dir => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build => 1 );
  has output_run_name => (  isa => 'Str', is => 'rw', default => sub {return 'run'} );
  has output_job_name => (  isa => 'Str', is => 'rw', default => sub {return 'job'} );
  has run_settings_name => ( isa => 'Str', is => 'rw', default => sub {return 'settings'});
  
  has run_num => ( isa => 'Str', is => 'rw'); 
  has job_filter_str  => ( isa => 'Str|Undef', is => 'rw');
  has step_filter_str => ( isa => 'Str|Undef', is => 'rw');
  has argument_str    => ( isa => 'Str|Undef', is => 'rw'  );
  
  
  sub _pipeline_dir_trigger {
      my $self = shift;
      return if $self->pipeline_dir->is_absolute;
      if ($self->use_relative_paths){
          warn "USING RELATIVE PATHS";
          warn "The pipeline_dir is relative " if $self->pipeline_dir->is_relative;
          warn "But the pipeline_dir is absolute" if $self->pipeline_dir->is_absolute;
      } else {
         $self->pipeline_dir( $self->pipeline_dir->absolute );
      }
  }
  
  sub _build_pipeline_name {
      my $self = shift;
      return $self->pipeline_dir->basename; 
  }
  
  sub _build_pipeline_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.pipeline' ); 
  }
  
  sub _build_pipeline_preparse_file {
      my $self = shift;
      return path(   $self->sys_dir,  $self->pipeline_name . '.preparse.yaml') ; 
  }
  
  sub _build_pipeline_parse_file {
      my $self = shift;
      return path(   $self->sys_dir, $self->pipeline_name . '.parse.yaml') ; 
  }
  
  sub _build_pipeline_resolved_file {
      my $self = shift;
      return path(   $self->sys_dir, $self->pipeline_name . '.resolved.yaml') ; 
  }
  
  sub _build_pipeline_graph_file {
      my $self = shift;
      return path(  $self->sys_dir,  $self->pipeline_name . '.graph.yaml') ; 
  }
  
  sub _build_pipeline_submission_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.submissions.txt') ; 
  }
  
  sub _build_pipeline_datasource {
      my $self = shift;
      my $datasourcefile = path( $self->datasource_file )->absolute;  
      ouch 'badfile', "Need to provide datasource file location\n" unless defined( $datasourcefile);
      #my $t =  App::Pipeline::Lite2::Datasource->new( datasource_file => $datasourcefile );         
      my $t = Data::Table::fromTSV( $datasourcefile->stringify );
  }
  
  sub _build_logfile {
      my $self = shift;
      #return file($self->pipeline_dir, $self->pipeline_name .".log")->stringify;
      #this should be able to be set system/user wide
      my $tmp_dir = "/tmp/";
      return path($tmp_dir, $self->pipeline_name .".log") #->stringify;
  }
  
  sub _build_system_logfile {
      my $self = shift;
      #return file($self->pipeline_dir, $self->pipeline_name .".log")->stringify;
      #this should be able to be set system/user wide
      my $sys_log_dir = File::HomeDir->my_data;
      return path($sys_log_dir, "plite.log"); #->stringify;
  }
  
  sub _build_software_ini_file {
     my $self = shift;  
     my $file = path($self->software_dir, 'software.ini');
     return $file;
  }
  
  sub _build_software_ini {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->software_ini_file->exists;
      my $conf = $cf->read( $self->software_ini_file->absolute->stringify ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_logger {
      my $self = shift;   
      my $logger = App::Pipeline::Lite4::Logger->new( logfile => $self->logfile) ;    
      return $logger; 
  }
  
  sub _build_system_logger {
      my $self = shift;
      my $logger = App::Pipeline::Lite4::Logger->new( logfile => $self->system_logfile) ;    
      return $logger;
  }
  
  sub _build_logconf {
      my $self = shift;
      # open YAML config file
       my $logconf_yaml =  $self->logconffile->stat
        ? $self->logconffile->slurp
        : return undef;
      my $logconfig = Load($logconf_yaml);
      return $logconfig;
  }
  
  sub _build_logconffile {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.log.conf' );
  }
  
  sub _build_config_file {
     my $self = shift;  
     my $file = path($self->pipeline_dir, $self->pipeline_name.'.ini');
     #print "config file is $file\n";
     #$file->touch;
     return $file;
  }
  
  sub _build_config {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->config_file->exists;
      my $conf = $cf->read( $self->config_file ) 
         or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_system_config {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->system_config_file->exists;
      my $conf = $cf->read( $self->system_config_file ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_system_config_file {
     my $self = shift;  
     my $system_config_dir = File::HomeDir->my_dist_config('App-Pipeline-Lite4', { create => 1 });
     my $system_config_file = path($system_config_dir, 'config.ini');
     #print "config file is $file\n";
     #$file->touch;
     return $system_config_file;
  }
  
  sub _build_output_dir {
      my $self = shift;
      my $output_dir = $self->config->{_}->{output_dir}; 
      return path($output_dir) if(defined( $output_dir)) ;
      return path( $self->pipeline_dir, 'output'  ); 
  }
  
  sub _build_input_dir {
      my $self = shift;
      my $input_dir = $self->config->{_}->{input_dir}; 
      return path($input_dir) if(defined( $input_dir)) ;
      return path( $self->pipeline_dir, 'input'  ); 
  }
  
  sub _build_input_ini_file {
     my $self = shift;  
     my $file = path($self->input_dir, 'input.ini');
     return $file;
  }
  
  sub _build_input_ini {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->input_ini_file->exists;
      my $conf = $cf->read( $self->input_ini_file->absolute->stringify ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  
  
  sub _build_symlink_dir {
      my $self = shift;
      my $symlink_dir = $self->config->{_}->{symlink_dir}; 
      return path($symlink_dir) if(defined( $symlink_dir)) ;
      return path( $self->pipeline_dir, 'symlink'  ); 
  }
  
  
  sub _build_software_dir {
      my $self = shift;
      my $software_dir = $self->config->{_}->{software_dir}; 
      return path($software_dir) if(defined( $software_dir)) ;
      return path( $self->pipeline_dir, 'software'  ); 
  }
  
  sub _build_sys_dir {
      my $self = shift;
      my $sys_dir = $self->config->{_}->{sys_dir}; 
      return path($sys_dir) if(defined( $sys_dir)) ;    
      my $sys_path= path( $self->pipeline_dir, 'sys'  ); 
      mkdir $sys_path unless $sys_path->exists; #while old systems catch up
      return $sys_path;
  }
  
  sub _build_datasource_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.datasource');
  }
  
  sub _build_datasource_resolved_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.resolved.datasource');
  }
  
  sub _build_test_data_file {
      my $self = shift;
      return path( $self->pipeline_dir, 'test_data', 'test.txt'  ); 
  }
  
  sub run_dir  {
      my $self = shift;
      ## Num $run_num
      my $run_num = shift;
      return path( $self->output_dir, $self->output_run_name . $run_num );
  }
  
  sub run_settings_dir   {
     my $self = shift;
     #Num $run_num
     my $run_num = shift;   
     my $settings_dir = path($self->run_dir($run_num), $self->run_settings_name );
     if( $settings_dir->exists){
        my $num_runs = scalar $settings_dir->children; 
        return path($settings_dir, $num_runs);
     }else{
        return path($settings_dir, 1);
     }
  }
  
  sub last_run_num {
      my $self=shift;
      #read in files in data directory
      #order by run number
      # - if none then run number is 1.
      my $run_num = max map { if( $_ =~ /run([0-9]+)/){$1}else{} } $self->output_dir->children;
      $run_num = 0 unless (defined $run_num);    
      return $run_num;   
  }
  
  sub new_run_settings_dir { 
     my $self = shift;
     #(Num $run_num){
     # this should generate a new settings 
     #dir taking into account reruns
     my $run_num = shift;   
     my $settings_dir = path($self->run_dir($run_num), $self->run_settings_name );
     
     if( $settings_dir->exists){
        my $num_runs = scalar $settings_dir->children + 1; 
        return path($settings_dir, $num_runs);
     }else{
        return path($settings_dir, 1);
     }  
  }
  
  sub datasource_from_run {
      my $self = shift;
      my $run_num = shift;
      my $settings_path = $self->run_settings_dir($run_num);   
      my $datasource_path = path($settings_path, $self->datasource_file->basename );
      return $datasource_path;
  }
  
  #sub _reconfigure {
  #    my $self = shift;
  #    my $old  = shift;
  #    my $new  = shift;
  #    return if( ! path($old)->exists)
  #    mv path($old)-> ;
  #}
  
  
  
  1;
APP_PIPELINE_LITE4_BASE

$fatpacked{"App/Pipeline/Lite4/Command/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_FILE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::file;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  use Number::Bytes::Human qw(format_bytes);
  use Time::Piece;
  use Data::Table;
  sub execute {
      my ($self, $opt, $args) = @_;
   
      
      eval {
         
         # set show steps if stats
         $opt->{step_name} = 1 if $opt->{stats};
          
         # Default is to get the latest run and the latest datasource
     
        my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
        my $run_num = $resolver->_last_run_number;           
         if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
         }
        
        #get datasource from settings directory and set to datasource file
        $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
        my $datasource = $resolver->pipeline_datasource;
        #print $datasource->tsv;
         
        # Go through each job  
            # create a hash based on steps 
            #  $steps{step}{filename}{jobnum}
            #  then  at the end  
        my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
   
        my $iter = $output_run_dir->iterator( { recurse => 1 } );
        my %step_hash;
        my %jobs;
        while( my $path = $iter->() ){        
          next unless $path->is_file;
          next if(  $path->basename =~ m{/?(out|err)$} ); 
          next unless $path =~ /job/; #removes setting directory and other things that are not jobs
          
          #print $path . "\n";
          my ($job, $step,$name)  = $path->stringify =~ m{(job[0-9]+)/(.+)/(.+)$};
          #my ($step) = $path->stringify =~ m{job[0-9]+/(.+)/} ;
          #print join " ", $job, $step, $name .  "\n";
          if( $opt->{stats} ){
             my $time = localtime($path->stat->mtime)->datetime;
             $step_hash{$step}{$name}{$job} = format_bytes( $path->stat->size) . "," . "[$time]";
          }else{
            $step_hash{$step}{$name}{$job} = $path;
          } 
          $jobs{$job} =1;
        }  
       
        #print header
        
        my @row;
        my $header;
        foreach my $step (nsort keys %step_hash){
          my $names = $step_hash{$step};
          foreach my $name (nsort keys %$names){
             if( $opt->{step_name} ){
               push @row,  $step."-".$name;
             }else{
               push @row,  $name;
             }
          }
        }
        
        #print join "\t", @row; print "\n";
        $header = [@row];
        
        my @table_data;
        foreach my $job (nsort keys %jobs){  
            @row = ();
            # go through each step and if the name doesn't have this job then put in some null character          
            foreach my $step (nsort keys %step_hash){
                my $names = $step_hash{$step};
                foreach my $name (nsort keys %$names){
                    if( exists $names->{$name}->{$job} ){                  
                     push @row,  $names->{$name}->{$job} 
                  }else{
                    push @row,"-";
                  }
                                   
                }
            }
            #print join "\t", @row; print "\n";
            push @table_data, [@row];
         }
         
        my $t = Data::Table->new(\@table_data, $header, 0);
        $datasource->colMerge($t, {renameCol => 1 } );
        print $datasource->tsv;
         
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( kiss 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER' ){
         print "\n*** There is something to fix before this pipeline can dispatch ***\n";
         print "\n", bleep(), "\n\n"; 
         print "This might be fixed by:\n
               - giving the placeholder a value (e.g. treating as an argument) via --args
               - fixing an error in the placeholder name
               - creating values for this placeholder in the datasource
          \n";
      }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  
  1;
APP_PIPELINE_LITE4_COMMAND_FILE

$fatpacked{"App/Pipeline/Lite4/Command/new.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_NEW';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::new;
  use Moo;
  use MooX::late;
  use Ouch;
  use App::Pipeline::Lite4::SetupPipeline;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      # get pipeline directory
      # get pipelite object    
      eval {        
          my $App_Pipeline_Lite_Setup = App::Pipeline::Lite4::SetupPipeline->new( pipeline_dir => $args->[0]); 
          $App_Pipeline_Lite_Setup->output_dir( dir( $opt->{output_dir} ) ) if defined($opt->{output_dir});      
          if( defined $opt->{based_on}){
               $App_Pipeline_Lite_Setup->create_pipeline_directory( based_on => $opt->{based_on} ); # this needs to be written in setup            
          }else{
               $App_Pipeline_Lite_Setup->create_pipeline_directory();
          }        
      };
      
      if( kiss 'App_Pipeline_Lite2_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_NEW

$fatpacked{"App/Pipeline/Lite4/Command/run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_RUN';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::run;
  use Moo;
  use Ouch;
  use Path::Tiny;
  use App::Pipeline::Lite4;
  sub execute {
      my ($self, $opt, $args) = @_;
      
      eval {
          # Initiate
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          # Get options
          my $desc ="smoke-test";
          $desc = $App_Pipeline_Lite->util->ask_for_description
          unless defined $opt->{smoke_test};
          my $step_filter = $opt->{steps} // "*";
          my $job_filter  = $opt->{jobs} // "*";
          my $run_num =  $App_Pipeline_Lite->last_run_num + 1;
          $run_num = $opt->{run_num} if defined($opt->{run_num});
          my $run_info = join " ", "run" . "[ $run_num ]", "[ step-filter: " . $step_filter  . " ]", "[ job-filter: " . $job_filter . " ]";
          
          #Set Options
          $App_Pipeline_Lite->util->append_description( $run_info, $desc ); # Write Options to log
          
          $App_Pipeline_Lite->smoke_test(1) if defined($opt->{smoke_test});
          $App_Pipeline_Lite->step_filter_str($step_filter) if defined $opt->{steps};
          $App_Pipeline_Lite->job_filter_str( $job_filter ) if defined $opt->{jobs};
          
          $App_Pipeline_Lite->run_num($run_num);
          
          # Get datasource from datasource if supplied, otherwise from runnum
          if( defined $opt->{datasource} ) {
              # pre check that file exists
              my $datasource_path = $opt->{datasource};
              ouch 'App_Pipeline_Lite4_Error', "The datasource path ($datasource_path) is not a file" unless path( $datasource_path)->is_file ;
              $App_Pipeline_Lite->datasource_file( $datasource_path )  ;
          } elsif( defined $opt->{run_num}){
              my $datasource_path = $App_Pipeline_Lite->datasource_from_run($run_num);
              ouch 'App_Pipeline_Lite4_Error', "The datasource path ($datasource_path) defined by run_num is not a file" unless path( $datasource_path)->is_file ;
              $App_Pipeline_Lite->datasource_file($datasource_path);
          }
          
          # Run the pipeline
          $App_Pipeline_Lite->run_pipeline;
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( kiss 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER' ){
         print "\n*** There is something to fix before this pipeline can dispatch ***\n";
         print "\n", bleep(), "\n\n"; 
         print "This might be fixed by:\n
               - giving the placeholder a value (e.g. treating as an argument) via --args
               - fixing an error in the placeholder name
               - creating values for this placeholder in the datasource
          \n";
     }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_RUN

$fatpacked{"App/Pipeline/Lite4/Command/symdir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMDIR';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symdir;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
   sub execute {
      my ($self, $opt, $args) = @_;
      
       # get pipeline directory
       # get pipelite object 
      
       eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
     
          my ($step,$filename) = split '#', $opt->{step_and_fname} ;
          
          # get the datasource  
          my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
          my $run_num = $resolver->_last_run_number;           
          if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
           }
        
          #get datasource from settings directory and set to datasource file
          $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
          my $datasource = $resolver->pipeline_datasource;
                  
          my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
          my @jobs =  grep { /job/ } $output_run_dir->children
          print "@jobs\n"; 
          #my $iter = $output_run_dir->iterator( { recurse => 1 } );
          #my %step_hash;
          #my %jobs;
          #while( my $path = $iter->() ){        
          #  next unless $path->is_file;
          #  next if(  $path->basename =~ m{/?(out|err)$} ); 
          #  next unless $path =~ /job/; #removes setting directory and other things that are not jobs
          #}
          
          
          # parse the step name and filename
          # check that the field exists
          # go through each job directory and make the link
          # if a file doesn't exist warn. 
          # make a datasource for the symlink files
              
       };
      
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_SYMDIR

$fatpacked{"App/Pipeline/Lite4/Command/symlink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMLINK';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symlink;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
       eval {
          my $id_field = $opt->{id_field};
          my $pipeline_dir =       path($args->[0]);
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Requires step_and_filename argument"
             unless ( defined( $opt->{step_and_fname} ) );
          my ($step,$filename) = split '#', $opt->{step_and_fname} ;
          
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Something went wrong specifying the step and filename" 
             unless ( defined($step) and defined($filename));
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Something went wrong specifying the step and filename" 
             if( $step eq '' or $filename eq '');
          
          # get the datasource  
          my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
          my $run_num = $resolver->_last_run_number;           
          if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
          }
          
          my $datasource;
          if( defined( $opt->{datasource} )){
            $resolver->datasource_file($opt->{datasource} );
            $datasource = $resolver->pipeline_datasource;
          }else{
            #get datasource from settings directory and set to datasource file
            $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
            $datasource = $resolver->pipeline_datasource;
          }
           
          my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
          my @jobs = nsort grep { /job/ } $output_run_dir->children;
  
          my @job_ids = map {$_->basename} @jobs;
          if( ! defined( $id_field) ){
             warn "No ID field defined. Prepending job numbers " 
          }elsif( $datasource->hasCol($id_field) ){
             @job_ids = $datasource->col($id_field);
          }else{
             warn "No matching ID field in datasource. Prepending job numbers"
          }
          
          #default path
          my $symlink_dir = path($resolver->symlink_dir, $step, $run_num);
          $symlink_dir = $opt->{path} if defined($opt->{path});
          $symlink_dir->mkpath;
          my @table_data;
          foreach my $job (@jobs){
            my $path = path($job,$step,$filename);
            my $id = shift @job_ids;
            if( $path->exists){
               my $new_basename = "$id-".$path->basename;
               if( defined( $opt->{name} )){
                  my $name = $opt->{name};
                  $new_basename = "$id$name" ;                                
               }             
               my $new_path = path($symlink_dir,$new_basename);
               symlink $path, $new_path->absolute;  
               print "symlinked $path to $new_path\n";
               push @table_data, [$new_path];
            }else{
               warn "path $path does not exist";
               push @table_data, ["-"];
            }
          }
          
          my $t = Data::Table->new(\@table_data, [$filename], 0);
          $datasource->colMerge($t);
          my $datasource_tsv = $datasource->tsv;
          my $datasource_path = path($symlink_dir,$pipeline_dir->basename . ".datasource");
          $datasource_path->spew($datasource_tsv);
          # parse the step name and filename
          # check that the field exists
          # go through each job directory and make the link
          # if a file doesn't exist warn. 
          # make a datasource for the symlink files            
       };
      
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( kiss  'App_Pipeline_Lite_CMD_ERROR') {
         print bleep(), "\n";       
       }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_SYMLINK

$fatpacked{"App/Pipeline/Lite4/Command/symlink2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMLINK2';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symlink2;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
       eval {
          my $pipeline_dir =   path($args->[0]);
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);      
          my $run_num = $App_Pipeline_Lite->last_run_num;
          if(defined $opt->{run_num}){     
             $run_num = $opt->{run_num};
          }
          $App_Pipeline_Lite->run_num($run_num);        
          my $datasource_path = $App_Pipeline_Lite->datasource_from_run($run_num);
          $App_Pipeline_Lite->datasource_file($datasource_path);
          if(defined $opt->{datasource} ){
              $App_Pipeline_Lite->datasource_file($opt->{datasource});
          }
          $App_Pipeline_Lite->symlink($opt);       
       };
       
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( kiss  'App_Pipeline_Lite_CMD_ERROR') {
         print bleep(), "\n";       
       }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }    
  1;
APP_PIPELINE_LITE4_COMMAND_SYMLINK2

$fatpacked{"App/Pipeline/Lite4/Command/viewconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWCONFIG';
  # use strict;
  # use warnings;
  # package App::Pipeline::Lite4::Command::viewconfig;
  # use Moo;
  # use Ouch;
  # use App::Pipeline::Lite4;
  
  # # sub execute {
      # my ($self, $opt, $args) = @_;
      
  # #     # get pipeline directory
      # # get pipelite object 
      
  # #     eval {
          # my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
  # #         if(defined $opt->{editor}){
                  # $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          # }                             
          # $App_Pipeline_Lite->util->view_file_with_editor( 
                                # $App_Pipeline_Lite->pipeline_file->absolute->stringify);
          
  # #     };
      
  # #     if( kiss 'App_Pipeline_Lite4_Error') {
         # print bleep(), "\n"; 
      # } elsif ( hug ) {
         # print 'An error occurred, check logs: ', $@ ;
      # }
  # }
  #1;
APP_PIPELINE_LITE4_COMMAND_VIEWCONFIG

$fatpacked{"App/Pipeline/Lite4/Command/viewgraph.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWGRAPH';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewgraph;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      
      # get pipeline directory
      # get pipelite object 
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          if(defined $opt->{editor}){
                  $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          }                             
          $App_Pipeline_Lite->util->view_file_with_editor( 
                                $App_Pipeline_Lite->pipeline_graph_file->absolute->stringify);
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWGRAPH

$fatpacked{"App/Pipeline/Lite4/Command/viewpipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWPIPELINE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewpipeline;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      
      # get pipeline directory
      # get pipelite object 
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          if(defined $opt->{editor}){
                  $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          }                             
          $App_Pipeline_Lite->util->view_file_with_editor( 
                                $App_Pipeline_Lite->pipeline_file->absolute->stringify);
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWPIPELINE

$fatpacked{"App/Pipeline/Lite4/Command/viewsystemconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWSYSTEMCONFIG';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewsystemconfig;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
        
      
      eval {       
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new;
          my $App_Pipeline_Lite_Util = App::Pipeline::Lite4::Util->new; 
          if(defined $opt->{editor}){               
                  $App_Pipeline_Lite_Util->set_editor( $opt->{editor});
          }                             
          $App_Pipeline_Lite_Util->view_file_with_editor( $App_Pipeline_Lite->system_config_file );
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWSYSTEMCONFIG

$fatpacked{"App/Pipeline/Lite4/Grapher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_GRAPHER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Grapher;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  #use List::AllUtils qw(min any); can't use as get kick ups about requiring versions > 1.32
  use List::Util qw(min reduce);
  use Data::Compare;
  use Data::Dumper;
  use App::Pipeline::Lite4::Util;
  extends 'App::Pipeline::Lite4::Base';
  has pipeline_step_struct_with_dependents => ( isa => 'HashRef', is => 'rw' );
  
  sub add_dependents {
     my $self=shift;
     # Path::Tiny :$yaml_infile,
     my $yaml_infile = shift;  
     # Path::Tiny :$yaml_outfile
     my $yaml_outfile = shift;
     $self->pipeline_resolved_file($yaml_infile);
     $self->_add_dependents;
     $yaml_outfile->spew( Dump( $self->pipeline_step_struct_with_dependents ) );
  }
  
  #method _add_dependents {    
  sub _add_dependents {
      my $self = shift;
      my $resolved_file_yaml = $self->pipeline_resolved_file->slurp;
      my $resolved_pipeline = Load($resolved_file_yaml); 
      
      my $lowest_job_num = min keys $resolved_pipeline;
      my $num_of_jobs    = scalar keys $resolved_pipeline;
      
     # my $valid_steps = $self->valid_steps( $resolved_pipeline);
      my $valid_steps = $self->valid_steps_hash( $resolved_pipeline);
      
      foreach my $job_num (keys %$resolved_pipeline){
          my $job = $resolved_pipeline->{$job_num};
          foreach my $step (keys %$job) {
             $job->{$step}->{dependents} = [];
             if( defined($job->{$step}->{placeholders})) {
                $self->_add_dependents_for_step_via_placeholder( 
                          $job->{$step}, #step
                          $step, #step_name 
                          $job_num,
                          $lowest_job_num,  
                          $num_of_jobs, 
                          $valid_steps 
                          );
             }
             
             if( defined( $job->{$step}->{after}) ) {
                 $self->_add_dependents_for_step_via_after_condition( 
                          $job->{$step}, #step
                          $step,   #sep_name
                          $job_num, 
                          $lowest_job_num, 
                          $num_of_jobs, 
                          $valid_steps );  
             }           
          }
      }
      $self->pipeline_step_struct_with_dependents($resolved_pipeline);
  }
  
  sub _add_dependents_for_step_via_placeholder {
  # TYPE (  HashRef :$step, Str :$step_name, Num :$job_num, Num :$lowest_job_num, 
  # TYPE Num :$num_of_jobs, ArrayRef :$valid_steps ) {
       my ($self,$step,$step_name,$job_num, $lowest_job_num, 
           $num_of_jobs,$valid_steps_hash  ) = @_;
       
       $self->logger->debug( "Valid Steps: " . Dumper $valid_steps_hash );
       my $rgx1 = qr{^([\w\-]+)\.{0,1}};
       my $rgx2 = qr{^jobs\.([\w\-]+)\.{0,1}};      
       my $rgx3 = qr{groupbyebyebye}; # should not match anything
       if( defined( $step->{condition} ) ){         
         if(  $step->{condition} eq 'groupby'){
           my $params = $step->{condition_params};     
           my $params_str = join '\.', @$params;
           my $rgx3_str = '^groupby\.' . $params_str . '\.' . '([\w\-]+)\.{0,1}';
           $rgx3 = qr{$rgx3_str};
         }
       } 
       #warn "REGEX3 $rgx3";     
       my $placeholders = $step->{placeholders};
       my $dependents   = $step->{dependents};
       
       my @valid_steps = keys %$valid_steps_hash;
       foreach my $placeholder (@$placeholders){                                    
           my ($placeholder_step_name) = $placeholder =~ $rgx2;#/^(\w+)\.{0,1}/; # =~ /step([0-9]+)/;
           ($placeholder_step_name) = $placeholder =~ $rgx3 unless defined($placeholder_step_name);
           ($placeholder_step_name) = $placeholder =~ $rgx1 unless defined($placeholder_step_name);
            
           # warn "GOT STEP NAME: $placeholder_step_name from $placeholder";
           $self->logger->debug("step $step_name: placeholder step name - $placeholder_step_name (from $placeholder)");  
           next unless defined($placeholder_step_name);
           
           ### I want 'any' unfortunately any isn't in recent version of List::Util and List::MoreUtils is XS and not core
           my $code = sub { my $k = shift; return 1 if( $placeholder_step_name eq $k ); return 0;   };
           my $next = reduce { $a || $code->(local $_ = $b)  } 0,  @valid_steps;
           next unless $next;
           
           # DO THIS WHEN List::Util qw(any) works for most Perls  
           #next unless any { $placeholder_step_name eq $_ } @$valid_steps; # if we have filtered steps this is important, and also takes care of the 0 datasource step
           ########################################################
           
                  
               my ($existing_dependents, $this_step_name) = (0,0);
               
               ## Actually want List::Util qw(any)
               my $codeA = sub { my $k = shift; return 1 if( "$job_num.$placeholder_step_name"  eq $k ); return 0;   };
               $existing_dependents = reduce { $a || $codeA->(local $_ = $b)  } 0,  @$dependents;
               
               # DO THIS WHEN List::Util qw(any) works for most Perls  
               #$existing_dependents =  any { $_ eq "$job_num.$placeholder_step_name"  }  @$dependents;
               ##############################################################################
               $this_step_name = 1 if( $placeholder_step_name eq $step_name);                                   
               if ( defined $step->{condition} ) {
                   # only defined condition is 'once' so far
                   # the 'any' code above will skip adding the same dependent jobs if a placeholder with the same step name occurs multiple times. 
                   # it works because it sets $existing_dependents true if any of the job numbers is present                
                   #---
                   if( $step->{condition} eq 'once'){ 
                       # now a once condition referencing another step with a once condition only needs to put down the minimal job number
                       # remember we are looking at the placeholder and trying to determine dependencies,
                       # the valid steps hash, tells us what condition the step of that placeholder is, so we can 
                       # adjust for once or groupby steps
                       if( defined $valid_steps_hash->{$placeholder_step_name}->{condition} ){             
                           if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'once' ){
                             push(@$dependents, "$lowest_job_num.$placeholder_step_name") unless ( $this_step_name or $existing_dependents) ; 
                           }
                       }else {
                           for my $i ( $lowest_job_num .. ( $num_of_jobs -1 )){
                              push(@$dependents, "$i.$placeholder_step_name") unless ( $this_step_name or $existing_dependents) ;                                               
                           }
                    
                       }
                     }
                     if ( $step->{condition} eq 'groupby'  ){
                         
                         #we take the job number and get the group we need
                         my $util = App::Pipeline::Lite4::Util->new;
                         my $params = $step->{condition_params};
                         #warn "PARAMS: ", Dumper $params;
                         my $groupby_hash = $util->datasource_groupby2( $self->pipeline_datasource, @$params );
                         my $groupby_ids  = $util->datasource_groupby2_order($self->pipeline_datasource, @$params);
                         #my @groupby_ids = sort keys %$groupby_hash;
                         #warn "GRAPHER JOBNUM: $job_num";
                         #warn "GRAPHER GROUPID: @groupby_ids";
                         #warn "gRAPHER CMD", $step->{cmd};
                         #warn "STEP",  Dumper $step;
                         my $group_id = $groupby_ids->[$job_num]; 
                         #warn "GRAPHER GROUPID: $group_id";
                         my $job_ids = $groupby_hash->{$group_id};
                         
                         
                         # if we are referring to a step that is a groupby step, then we only need to 
                         # put int dependencies that refer to the jobs generated by that step - i.e. only up to job 4 rather
                         # than job 10 for example, as it won't exist 
                         
                         if( defined $valid_steps_hash->{$placeholder_step_name}->{condition} ){             
                           if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'groupby' ){
                               # different conditions will have different numbers, 
                               # we can only refer to a groupby with the same condition  
                               # and then we only put in the job number, 
                               my $placeholder_step_params = $valid_steps_hash->{$placeholder_step_name}->{condition_params};
                               #my $comp = Array::Compare->new; 
                               if( ! Compare( $placeholder_step_params, $params  ) ){
                                  ouch 'App_Pipeline4_Error', "One groupby statement depends on another groupby statement with a different groupby field(s)";
                               }else{
                                  
                                  push(@$dependents, "$job_num.$placeholder_step_name") 
                                     unless ( $this_step_name or $existing_dependents or ($job_num >= scalar(@$groupby_ids)) ); 
                               } 
                           }
                           #do something for once here
                          }else{
                         
                             foreach my $job_id (@$job_ids){  
                                push( @$dependents, "$job_id.$placeholder_step_name" ) unless ( $this_step_name or $existing_dependents) ;
                             }
                         }
                     } 
                   
               }else{                 
                   #$existing_dependents =  any { $_ eq "$job_num.$placeholder_step_name"  }  @$dependents;
                   #$this_step_name = 1 if( $placeholder_step_name eq $step_name);  
                   if( defined ( $valid_steps_hash->{$placeholder_step_name}->{condition} ) ){                     
                       if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'once'){
                            push( @$dependents, "$lowest_job_num.$placeholder_step_name")
                                unless ($this_step_name or $existing_dependents) ; 
                       }
                       
                    }else{
                      push( @$dependents, "$job_num.$placeholder_step_name")
                        unless ($this_step_name or $existing_dependents) ;
                   }
               }       
           #}         
       }
  }
  =cut To implement
  sub _add_dependents_for_step_via_after_condition {
      #TYPE: HashRef :$step, Str :$step_name, Num :$job_num, 
      #TYPE: Num :$lowest_job_num, Num :$num_of_jobs, ArrayRef :$valid_steps )
        my ($self,$step,$step_name,$job_num, $lowest_job_num, 
           $num_of_jobs,$valid_steps_hash  ) = @_;
        foreach my $after_step_name ($step->{after}->flatten){
          # if($after_step_num > $step) {
             # ouch 'steperror', "Need to ensure that a step does not define steps to run after that are future steps"; 
          # } 
          
         # if ( $after_step_num < $step_num ) { 
              my $dependents = $step->{dependents};  
               $self->logger->debug("step $step_name: placeholder step num - $after_step_name");                         
               if ( defined $step->{condition} ) { # only 'once' is the only thing that can occur from the condition key                
                   for my $i ( $lowest_job_num .. ( $num_of_jobs -1 )){
                       push( @$dependents, "$i.$after_step_name");                                               
                   }
               }else{
                   ouch 'App_Pipeline4_Error', "The after condition of step $step_name refers to its own step"
                     if( $after_step_name eq $step_name );
                  
                   push(@$dependents, "$job_num.$after_step_name")
                     unless any { $_ eq "$job_num.$after_step_name"  }  @$dependents ;
               }       
         #  }                    
                     
      }
  }
  =cut
  
  ####DEPRECATED## REMOVE
  sub valid_steps {
    #TYPE: ( HashRef :$resolved_pipeline ) {
    my $self = shift;    
    my $resolved_pipeline = shift;  
    # run through the first job.  
    my ($a_job);
    my @jobs = keys %$resolved_pipeline;
    my ($min_job_num) = sort {$a <=> $b} @jobs;
    $a_job =  $resolved_pipeline->{$min_job_num}; 
    my @step_names =  keys %$a_job;
    warn "@step_names";
    return \@step_names;    
  } 
  ############
  
  
  sub valid_steps_hash {
    #TYPE: ( HashRef :$resolved_pipeline ) {
    my $self = shift;    
    my $resolved_pipeline = shift;  
    # run through the first job.  
    my ($a_job);
    my @jobs = keys %$resolved_pipeline;
    my ($min_job_num) = sort {$a <=> $b} @jobs;
    $a_job =  $resolved_pipeline->{$min_job_num}; 
    my @step_names =  keys %$a_job;
    my %valid_step_hash;
    foreach my $step (keys %$a_job){
       $valid_step_hash{$step}->{condition} = $a_job->{$step}->{condition};
       $valid_step_hash{$step}->{condition_params} = $a_job->{$step}->{condition_params};   
    }
    
    return \%valid_step_hash;
  } 
  
  1;
APP_PIPELINE_LITE4_GRAPHER

$fatpacked{"App/Pipeline/Lite4/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_LOGGER';
  package App::Pipeline::Lite4::Logger;
  use Moo;
  use MooX::late;
  use Path::Tiny;
  use Time::Piece;
  use Devel::StackTrace;
  has logfile => ( isa => 'Path::Tiny|Undef', is => 'rw' );
  has system_logfile => ( isa => 'Path::Tiny|Undef', is => 'rw' );
  sub log {
      my $self  = shift;
      my $level = shift;
      my $msg   = shift; 
      
      my $t = localtime;  
      my $trace = Devel::StackTrace->new();
      
      my $frame = $trace->frame(1);
      my $package = $frame->package;
      my $app_caller = "unknown";
      
      while ( my $frame = $trace->prev_frame() ) {
         if ( $frame->package =~ /Command\:\:(.+)/ ) {
            $app_caller = $1;
            last;
         }
      }
      
      my $log_msg = "[" . $level . "] " . "[ $app_caller -> $package ] " . " [ " . $t->strftime . " ] " . $msg;         
      my $append_log = $self->logfile->opena; #( $level =~ /sys/ ) ? $self->system_logfile->opena : $self->logfile->opena;
      print $append_log $log_msg, "\n";
  }
  
  sub debug {
     my $self = shift;
     my $msg  = shift;
     $self->log("debug",$msg) ;
  }
  
  sub info {
     my $self = shift;
     my $msg  = shift;
     $self->log("info",$msg) ;
  }
  
  
  1;
APP_PIPELINE_LITE4_LOGGER

$fatpacked{"App/Pipeline/Lite4/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_PACKER';
  package App::Pipeline::Lite4::Packer;
  use Moo;
  use App::FatPacker;
  use Path::Tiny;
  # thieve from Carton fatpacking (MIYAGAWA)
  
  sub fatpack_plite {
      my $self = shift;
      my $dir = path(shift);
      my $file = $dir->child('plite');
      
      my $fatpacked = $self->do_fatpack($file);     
      my $executable = path($dir,'packed')->child('plite');
      warn "... Bundling $executable\n";   
      $executable->spew($fatpacked);
      chmod 0755, $executable;
  }
  
  sub do_fatpack {
      my ($self, $file) = @_;
      my $packer = App::FatPacker->new;
   
      my @modules = split /\r?\n/, $packer->trace(args => [$file]); #, use => $self->required_modules);
      @modules = grep { !/main.pm/ } @modules;
      @modules = grep { !/XS.pm/ } @modules;
      @modules = grep { !/Moose/ } @modules;
      print join "\n", @modules, "\n"; 
      my @packlists = $packer->packlists_containing(\@modules);
      $packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute, \@packlists);
   
      my $fatpacked = do {
          local $SIG{__WARN__} = sub {};
          $packer->fatpack_file($file);
      };
   
      # HACK: File::Spec bundled into arch in < 5.16, but is loadable as pure-perl
      #use Config;
      #$fatpacked =~ s/\$fatpacked{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;
      
      $fatpacked;
  }
  1;
APP_PIPELINE_LITE4_PACKER

$fatpacked{"App/Pipeline/Lite4/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_PARSER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Parser ;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  use SHARYANTO::String::Util qw(trim rtrim);
  
  extends 'App::Pipeline::Lite4::Base';
  
  has append_err_str => ( isa => 'Bool' , is => 'rw', default => sub { 1;} );
  has prepend_cwd_str => ( isa => 'Bool' , is => 'rw', default => sub { 1;} );
  
  #has append  => (isa => 'Str', is =>'rw', default=> sub {''} );
  #has prepend =>  (isa => 'Str', is =>'rw', default=> sub {''} );
  
  has append => (isa => 'Str|Undef', is =>'rw', lazy_build => 1 );
  has prepend =>  (isa => 'Str|Undef', is =>'rw', lazy_build =>1  );
  
  sub get_step_name { 
      #TYPE( :$str) 
     my $str = shift;
     my ($name) = $str =~ /^([\w\-]+)\./;
     return $name;
  }
  
  sub get_step_condition {
      my $str = shift;
     #TYPE: :$str 
    
     my ($condition) = $str =~ /^[\w\-]+\.([\w\-]+)\.*/;
     return $condition;
  }
  
  sub _build_append {
      my $self = shift;
      my $append_str = $self->config->{_}->{append}; #check local config 
      
      # if does not exist, check system config    
      $append_str = $self->system_config->{_}->{append} 
                                 unless defined( $append_str);
      $append_str = " " . $append_str . " "; #make sure there is a space between commands
      defined($append_str) ?  $append_str : undef;  
  }
  
   sub _build_prepend {
      my $self = shift;
      my $prepend_str = $self->config->{_}->{prepend}; #check local config 
      
      # if does not exist, check system config    
      $prepend_str = $self->system_config->{_}->{prepend} 
                                 unless defined( $prepend_str);
      $prepend_str = " " . $prepend_str . " " if defined($prepend_str); #make sure there is a space between commands
      defined($prepend_str) ?  $prepend_str : undef;  
  }
  
  
  sub preparse {
      my $self = shift;       
      my $pipeline_file = shift // $self->pipeline_file; # TYPE: Path::Class::File :$pipeline_file = $self->pipeline_file,   
      my $yaml_outfile = shift // $self->pipeline_preparse_file;     # TYPE: Path::Class::File :$yaml_outfile = $self->pipeline_preparse_file 
      # parse the current steps in the pipeline 
      my $step_hash = parse_pipeline_to_step_hash( $pipeline_file );       
      # append other stuff here first, and then err string
      # <---     
      $self->append_err_str_to_cmd( $step_hash  )
        if  ( $self->append_err_str );      
       # prepend other stuff here first, and then cwd string
       # <---   
      $self->prepend_str_to_cmd($step_hash, $self->prepend ) 
        if  ( defined $self->prepend);  
      $self->prepend_cwd_str_to_cmd($step_hash ) 
        if  ( $self->prepend_cwd_str);        
      $yaml_outfile->spew( Dump($step_hash) );
  };
  
  sub parse {
      # TYPE: Path::Class::File :$yaml_infile, 
      # TYPE: Path::Class::File :$yaml_outfile  
    my $self= shift;
    my $yaml_infile  =shift;
    my $yaml_outfile =shift;  
    my $step_hash_yaml = $yaml_infile->slurp;
    my $step_hash    = Load($step_hash_yaml); 
    my $step_struct  = pipeline_step_hash_to_step_struct( $step_hash );
    $yaml_outfile->spew( Dump($step_struct) );  
  };
  
  sub append_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $str = shift;
    my $append_str_func   = sub { my $step_name = shift // 'default'; return $str};
    # concat_to_cmd knows to provide step name to the coderef
    my $appended_step_hash = $self->concat_to_cmd($step_hash, $append_str_func, 'APPEND');
  }
  
  # yes this is a specific case of above - look to refactor
  sub append_err_str_to_cmd {  
      my $self = shift;
      #TYPE: HashRef $step_hash 
      my $step_hash = shift;  
      my $append_str_func   =  sub { my $step_name = shift // 'default'; return " 2>[% $step_name.err %]" };
      # concat_to_cmd knows to provide step name to this coderef
      my $appended_step_hash = $self->concat_to_cmd($step_hash, $append_str_func, 'APPEND');  
  }
  
  sub prepend_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $str = shift;
    my $prepend_str_func   = sub { my $step_name = shift // 'default'; return $str};
    # concat_to_cmd knows to provide step name to the coderef
    my $prepended_step_hash = $self->concat_to_cmd($step_hash, $prepend_str_func, 'PREPEND');
  }
  
  # yes this is a specific case of above - look to refactor
  sub prepend_cwd_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $prepend_str_func   = sub { my $step_name = shift // 'default'; return "cd [% $step_name %]; "};
    # concat_to_cmd knows to provide step name to the coderef
    my $prepended_step_hash = $self->concat_to_cmd($step_hash, $prepend_str_func, 'PREPEND');
  }
  
  # requires a coderef that returns a string, which can be used to 
  # parameterise a step name
  sub concat_to_cmd {
      my $self = shift;
      #TYPE: HashRef $step_hash 
      my $step_hash = shift;
      my $concat_string_code = shift;
      my $type_of_concat = shift; #APPEND or PREPEND
      foreach my $step ( keys %$step_hash) {
         my $step_name =  get_step_name( $step);
         $step_name = trim( $step_name ) ;
         $step_hash->{$step} = rtrim( $step_hash->{$step} );           
         my $concat_str = $concat_string_code->($step_name);
         my $step_cond = get_step_condition( $step);
         if( defined($step_cond) ){
             if($step_cond eq 'once'){              
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step}  = $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;                             
             }
             
              if($step_cond eq 'groupby'){              
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step}  = $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;                             
             }
             
         } else {
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step} =  $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;
         }
     } 
     return $step_hash;
  }
  
  
  =func parse_pipeline_file_to_step_hash
    A step hash has a key such as "1." and value "some_cmd -h MOREOPTIONS ARGS ..."
  =cut
  sub parse_pipeline_to_step_hash   {
      # TYPE:  Path::Tiny $file
      my $file = shift;
      # Each Step Starts with X. or X.[condition], then a space, where X is the step name
      # Can be multiline but cannot start with X. on a line
      my @pipeline_file_contents = $file->lines;
      my %stephash;
      my $stepname;
      my $not_started=1;
      foreach my $line (@pipeline_file_contents) {        
          if ( $not_started && $line =~ /^\s+$/){next;} #allow blank lines at top of pipeline description
          if ( $line =~ /^#/){ next; }  
          my $C = qr{^[\w\-]+\.};
          my $D = qr{^[\w\-]+\.output};
          my $E = qr{^[\w\-]+\.once};
          my $F = qr{^[\w\-]+\.mem};       
          my $G = qr{^[\w\-]+\.after};
          my $H = qr{^[\w\-]+\.queue};
          my $I = qr{^[\w\-]+\.cores};
          my $J = qr{^[\w\-]+\.groupby\.[\w\-]+};
          my $K = qr{^[\w\-]+\.groupby\.[\w\-]+\.[\w\-]+};
              
          my $N = qr{\s(.+)};
          my $O = qr{\s+};
          my $rg = qr{        
              ($C|$D|$E|$F|$G|$H|$I|$J|$K)$N      
          }x;
          my $rg_whitespace = qr{        
              ($C|$D|$E|$F|$G|$H|$I|$J|$K)$O      
          }x;
         
          if( $line =~ $rg) {
              $not_started = 0;          
              $stepname = $1;            
              my $steptext = $2;
              $stephash{$stepname}  = $steptext;            
          }elsif($line =~ $rg_whitespace){ # step has white space after it
              $not_started = 0;
              $stepname = $1;
              $stephash{$stepname} = ""
          }elsif($line =~ /$C/){    # if the line matches as the first part of a step, yet is not a fully valid step then there is a misspelling or invalidity
              ouch 'App_Pipeline_Lite4_Error', "This step does not have a valid condition (is it misspelt?)\n ==> $line";
          }else{
              $stephash{$stepname} .= $line; 
          }    
      }
      return {%stephash};  
  }
  
  #takes step hash and parses it to more processed structure
  sub pipeline_step_hash_to_step_struct {
      #   TYPE: Path::Tiny :$yamlfile ) {
      my $step_hash = shift;
      my %step_struct;
      foreach my $step ( keys %$step_hash ){  
              
             my $step_name = get_step_name( $step);
             my $step_condition = get_step_condition( $step);
             
             if( !defined($step_condition) ) {
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = undef; # change to 'none'?
             } 
                        
             elsif( $step_condition eq 'output' ) {
                 my @files = $step_hash->{$step} =~ /(\[\%.+?\%\]\S+|\S+)/g; #my @files = split(/\s/, $step_hash->{$step}); 
                 $step_struct{$step_name}->{outputfiles} = \@files; #$step_hash->{$step};
             }
                        
             elsif( $step_condition eq 'once' ) {
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = 'once';
             }
             
             elsif ( $step_condition eq 'mem' ) { 
               $step_struct{$step_name}->{mem} = trim( $step_hash->{$step} );
             }
                    
             elsif ( $step_condition eq 'after' ) { 
               my @after = split(/\s/, $step_hash->{$step}); 
               $step_struct{$step_name}->{after} = \@after ;
             }
             
             elsif ( $step_condition eq 'queue' ) { 
               $step_struct{$step_name}->{queue} =trim( $step_hash->{$step} );
             }
             
             elsif ( $step_condition eq 'cores' ) { 
               $step_struct{$step_name}->{cores} =trim( $step_hash->{$step} );
             }
             elsif( $step_condition eq 'groupby' ) {         
               my @condition_params = split( /\./,$step);            
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = $step_condition;
               my @params = @condition_params[2 .. $#condition_params];
               $step_struct{$step_name}->{condition_params} = \@params;
             }
             
             # get placeholders
             if( ! exists( $step_struct{$step_name}->{placeholders} ) ){$step_struct{$step_name}->{placeholders} = undef;}#initialise to undef
             if( ( ! defined $step_condition) or ($step_condition eq 'once') or ($step_condition eq 'output') or ($step_condition eq 'groupby') ){
               #my (@placeholders) = ( $step_hash->{$step} =~ /\[\%\s+([a-z0-9\.]+)\s\%\]/g );
               my (@placeholders) = ( $step_hash->{$step} =~ /\[\%\s+([\w\-\.]+)\s+\%\]/g ); #\w is alphanumeric plus _, added more spaces at end. Consider /\[\%\s+([a-z0-9_][\w\.]+)\s+\%\]/g enforcing lower case start.
               if ( @placeholders >= 1){ 
                  $step_struct{$step_name}->{placeholders} = \@placeholders;
               }; 
             }   
  
      }
      return \%step_struct;
  }
  
  1;
APP_PIPELINE_LITE4_PARSER

$fatpacked{"App/Pipeline/Lite4/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_RESOLVER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Resolver ;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  use YAML::Any;
  use List::Util qw(max reduce);
  use Data::Table;
  use Data::Dumper;
  use App::Pipeline::Lite4::Template::TinyMod;
  use App::Pipeline::Lite4::Util;
  use Storable qw(dclone);
  extends 'App::Pipeline::Lite4::Base';
  
  has placeholder_hash     => ( isa =>'HashRef', is => 'rw', default => sub {return {}});
  has current_run_num => ( isa => 'Num|Undef', is => 'rw');
  has current_run_dir => (isa => Path, is =>'rw', lazy_build => 1);
  has pipeline_step_struct => ( isa => 'HashRef' , is => 'rw', lazy_build => 1 );
  has pipeline_step_struct_resolved => ( isa => 'HashRef' , is => 'rw', default => sub {{}}  );
  has run_num_dep  => ( isa => 'Num|Undef', is => 'rw');
  has tot_jobs => ( isa => 'Num', is => 'ro', lazy_build => 1);
  has job_filter => ( isa  => 'ArrayRef|Undef', is =>'rw', lazy_build => 1 );
  has step_filter => ( isa => 'ArrayRef|Undef' , is => 'rw', lazy_build =>1 );
  
  sub _build_pipeline_step_struct {
       my $self = shift;
       my $yaml = $self->pipeline_parse_file->slurp;
       return Load($yaml);
  }
  
  sub _build_current_run_dir {
      my $self = shift;
      return  path( $self->output_dir, $self->output_run_name . ($self->current_run_num) );
  }
  
  sub _build_tot_jobs {
      my $self = shift;
      return $self->pipeline_datasource->lastRow + 1;
  }
  
  sub _build_job_filter  {
      my $self= shift;
  
      #check the jobs don't exceed the datasource
      my $ds_rows = $self->pipeline_datasource->nofRow;
  
      if( defined $self->job_filter_str ) {
          #my @jobs_to_keep = $self->job_filter_str->split('\s+');
          #return \@jobs_to_keep;
          my $jobs = $self->_parse_job_filter_str($self->job_filter_str);
          my $max_job = max( @$jobs );
          #$self->logger->debug("Check max job filter row with number of datasource rows: ($ds_rows) ");
          $self->logger->debug("Check max of jobs in job filter: ( @$jobs max = $max_job)
                                 with num of datasource rows: ($ds_rows) ");
          #jobs start from 0
          ouch 'App_Pipeline_Lite4_ERROR', "max job in filter exceeds datasource row." if $max_job >= $ds_rows ;
  
          return $jobs;
      } else {
          return undef;
      }
  }
  
  sub _parse_job_filter_str {
      my $self = shift;
      my $job_filter_str = shift;
      my @job_filters = split ',', $job_filter_str;
      my @jobs;
      foreach my $job_filter (@job_filters){
          if($job_filter =~ '-'){
             my @pair = split '-', $job_filter;
             push @jobs, $pair[0] .. $pair[1];
          }else{
             push @jobs, $job_filter;
          }
  
      }
      return [ App::Pipeline::Lite4::Util::uniq( @jobs ) ];
  }
  
  
  sub _build_step_filter {
      my $self = shift;
      if( defined $self->step_filter_str ) {
          #my ($start_step, $end_step) = $self->step_filter_str =~ /([0-9]+)\-([0-9]+)/;
          my @steps;
          #if(defined($start_step) and defined($end_step)){
          #   @steps = $start_step .. $end_step;
          #   return \@steps;
          #} else {
             @steps = split '\s+', $self->step_filter_str;
             return \@steps;
          #}
      } else {
          return undef;
      }
  }
  
  #does this only need to be done on a per job basis.
  sub _step_filter_on_resolved_step_struct  {
          my $self = shift;
          my $steps = $self->step_filter;
          #warn "@$steps";
          my $resolved_step_struct = $self->pipeline_step_struct_resolved;
          $self->logger->debug( "Steps to keep: @$steps\n");
          foreach my $step_struct (values %$resolved_step_struct) {
              foreach my $step_name ( keys %$step_struct) {
                 $self->logger->debug( "Checking $step_name against filter\n" );
  
                 #### WE WANT ANY####
                 my $code = sub { my $k = shift; return 1 if( $step_name eq $k ); return 0;   };
                 my $dont_delete = reduce { $a || $code->(local $_ = $b)  } 0,  @$steps;
  
                 #delete $step_struct->{$step_name} unless any{ ($step_name eq $_) } any{ ($step_name eq $_) } @$steps;
                 #######
  
                 delete $step_struct->{$step_name} unless $dont_delete; #any{ ($step_name eq $_) } @$steps;
              }
          }
          #the run number must be set to the last run. otherwise we could end up with dependency issues.
          #this might not be good enough, e.g. we may have run a smoke_test - this creates output directories
          #my $last_run_num = App::Pipeline::Lite1::Resolver->new( output_dir => $self->output_dir)->_last_run_number;
          #$self->run_num($last_run_num) unless defined($self->run_num); #the user has already assigned a run number we use this
          #$self->logger->debug("Set run number to " . $self->run_num);
  }
  
  sub _job_filter_on_resolved_step_struct   {
       my $self=shift;
       my $jobs_to_keep= $self->job_filter;
  
       my $resolved_step_struct = $self->pipeline_step_struct_resolved;
       $self->logger->debug( "Jobs to keep: @$jobs_to_keep\n");
  
       $self->logger->debug( "RESOLVED STEP STRUCT BEFORE FILTER: " . Dumper($resolved_step_struct)  );
  
  
       foreach my $job_num (keys %$resolved_step_struct) {
  
            #### WE WANT ANY####
                 my $code = sub { my $k = shift; return 1 if( $job_num eq $k ); return 0;   };
                 my $dont_delete = reduce { $a || $code->(local $_ = $b)  } 0,  @$jobs_to_keep;
            #delete $resolved_step_struct->{$job_num} unless any { ($job_num == $_) } @$jobs_to_keep;
            #######
  
           delete $resolved_step_struct->{$job_num} unless $dont_delete;
       }
  
       $self->logger->debug( "RESOLVED STEP STRUCT AFTER FILTER: " . Dumper($resolved_step_struct)  );
  }
  
  sub resolve {
     my $self = shift;
     # TYPE: ( Path::Class::File :$yaml_infile,  Path::Class::File :$yaml_outfile )
     my $yaml_infile  = shift;
     my $yaml_outfile = shift;
     $self->pipeline_parse_file($yaml_infile); #sets the path to yaml file produced by parser step
     $self->_resolve;
     $yaml_outfile->spew( Dump( $self->pipeline_step_struct_resolved ) );
  }
  
  
  =method _resolve
      The resolver takes something like this: 
      {'count-all' => {
                      'condition' => 'once',
                      'placeholders' => [
                                          'count-all',
                                          'jobs.datasource.filename',
                                          'count-all.sum',
                                          'count-all.err'
                                        ],
                      'cmd' => 'cd [% count-all %]; wc -l [% jobs.datasource.filename %] > [% count-all.sum %] 2>[% count-all.err %]'
                    },
      }
      
      and converts it to something like this(showing just job3 (starting from job0):
      
      {'3' => {    
                
                'count-all' => {
                                      'condition' => 'once',
                                      'placeholders' => [
                                                          'count-all',
                                                          'jobs.datasource.filename',
                                                          'count-all.sum',
                                                          'count-all.err'
                                                        ],
                                      'cmd' => 'cd /home/user/Desktop/plite-test-once-condition/test-pipeline1/output/run3/job3/count-all; wc -l /home/user/Desktop/plite-test-once-conditio
  n/data/sample4 /home/user/Desktop/plite-test-once-condition/data/sample5 /home/user/Desktop/plite-test-once-condition/data/sample6 /home/user/Desktop/plite-test-once-condition/data/sample
  7 > /home/user/Desktop/plite-test-once-condition/test-pipeline1/output/run3/job3/count-all/sum 2>/home/user/Desktop/plite-test-once-condition/test-pipeline1/output/run3/job3/count-all/er
  r'
                                    },
                     }
        }
  
  
  =cut
  
  sub _resolve {
      my $self = shift;
      #$self->clear_pipeline_step_struct_resolved;
      $self->current_run_num( $self->_last_run_number + 1 ) unless defined( $self->current_run_num);
  
      foreach my $row ( 0 .. $self->pipeline_datasource->lastRow ) {
           $self->logger->log("debug", "=== Job $row  ===");
           $self->_add_data_source_to_placeholder_hash( $row);
           
  
           # add globals to placeholder hash
           ##$self->_add_dir_to_placeholder_hash ( dir_name => 'global', dir_path => dir( $self->output_dir , 'run' . ($self->current_run_num) ));
           # add data dir to placeholder hash
           ##$self->_add_dir_to_placeholder_hash ( dir_name => 'data', dir_path => dir( $self->output_dir->parent ) );
  
           # add in the output files expected for each step to the placeholder hash
           
           #$self->_add_steps_in_step_struct_to_placeholder_hash($row);
           $self->_add_steps_in_step_struct_to_placeholder_hash2($row);
           $self->_create_directory_structure_from_placeholder_hash;
  
           # add software to placeholder hash - MUST GO AFTER CREATE DIRECTORY
           # OTHERWISE DIRECTORIES WILL BE MADE FOR SOFTWARE
           $self->_add_software_to_placeholder_hash;
  
           # add input file directory to placeholder hash - MUST GO AFTER CREATE DIRECTORY
           # OTHERWISE DIRECTORIES WILL BE MADE FOR INPUT 
           $self->_add_input_files_to_placeholder_hash;
  
           # add in the output files expected for each step to the placeholder hash
           $self->_add_expected_output_files_to_placeholder_hash( $row);
           $self->_add_expected_output_files_to_jobs_in_placeholder_hash;
           #warn Dumper $self->placeholder_hash;
  
           # validate placeholders against placeholder hash
           $self->_validate_placeholder_hash_with_placeholders;
           # interpolate the cmds in each step and add to new resolved_step_struct
           $self->_interpolate_cmd_in_step_struct_to_resolved_step_struct( $row);
           $self->_step_filter_on_resolved_step_struct if defined $self->step_filter_str;
           $self->_job_filter_on_resolved_step_struct if defined $self->job_filter_str;
           $self->_once_condition_filter_on_resolved_step_struct;
           $self->_groupby_condition_filter_on_resolved_step_struct;
           #warn Dumper $self->pipeline_step_struct_resolved;
           $self->placeholder_hash({});
      }
      #$self->logger->log( "info", "Final Resolved Step Struct: \n" . Dumper $self->pipeline_step_struct_resolved );
  }
  
  
  =method _add_data_source_to_placeholder_hash
     Reads the data source as specified in $self->pipeline_datasource and
     parses a specified row of the datasource to the placeholder_hash
  =cut
  sub _add_data_source_to_placeholder_hash{
        #TYPE:  Num :$datasource_row
        my $self = shift;
        my $datasource_row = shift;
        my $t = $self->pipeline_datasource;
        my @header = $t->header;
        for my $i (0 .. $t->lastCol ) {
           #print $header[$i], " ", $t->col($i), "\n";    
           my @datasource_rows = $t->col($i);
           $self->logger->log( "debug", "Datasource col $i : ".$header[$i] . " =>  $datasource_rows[$datasource_row]");
           #adds in the datasource reference here, so that we can deal specially with datasource stuff later in create_directory_structure
           $self->_placeholder_hash_add_item( "datasource." . $header[$i],  $datasource_rows[$datasource_row]  );
  
      }
  }
  
  
  sub _add_software_to_placeholder_hash {
      my $self = shift;
      return unless defined $self->software_dir;
      my $dir = $self->software_dir;
      return unless $dir->exists;
      my @software = $dir->children;
  
      #add to placeholder;
      for my $i (0 .. $#software) {
         $self->_placeholder_hash_add_item( "software.".$software[$i]->basename, $software[$i]->stringify )
          unless $software[$i]->stringify eq $self->software_ini_file->stringify;
      }
  
      # we then need to add the software in in the software.ini file
      return unless defined $self->software_ini;
      return unless $self->software_ini_file->exists;
      foreach my $software_name ( keys %{ $self->software_ini->{_} }  ) {
          $self->_placeholder_hash_add_item(  "software.$software_name", $self->software_ini->{_}->{$software_name} );
      }
  }
  
  
  sub _add_input_files_to_placeholder_hash {
     my $self = shift;
     # read folder called input add to the placeholder hash
     # can add folders to input directory and it will pick the names
     return unless defined $self->input_dir;
     my $dir = $self->input_dir;
     return unless $dir->stat;
  
     ouch 'App_Pipeline_Lite4_ERROR', "The input directory $dir does not exist" unless $dir->stat;
  
     my @files;
  
     my $iter = $dir->iterator( { recurse => 1 } );
     while( my $path = $iter->() ){
          next unless( $path->is_file || $path->is_dir);
          push( @files, $path);
     }
      #add to placeholder;
      for my $i (0 .. $#files) {
         $self->_placeholder_hash_add_item( "input.".$files[$i]->basename, $files[$i]->stringify )
          unless $files[$i]->stringify eq $self->input_ini_file->stringify;;
      }
      
      # we then need to add the input files in the input.ini file
      return unless defined $self->input_ini;
      return unless $self->input_ini_file->exists;
      foreach my $input_name ( keys %{ $self->input_ini->{_} }  ) {
          $self->_placeholder_hash_add_item(  "input.$input_name", $self->input_ini->{_}->{$input_name} );
      }
      
  }
  
  # placeholder hash is where we have {step0}{file1} = value
  # currently we leave it for the groupby case, so that we just have a long key that still matched fine
  # probably we should have the step and its field names as one key
  # {groupby}{cmp.hmr}{file.name} = /outputdir/job../hmr/file.name
  sub _placeholder_hash_add_item{
     #TYPE: ( Str :$keystr, Str :$value)
     my $self   = shift;
     my $keystr = shift;
     my $value  = shift;
     my @keystr = split('\.', $keystr);
     if( $keystr[0] eq 'jobs'){
  	  @keystr = ( $keystr[0], $keystr[1], join('.', @keystr[2 .. $#keystr]  ) );
  	}else {
        @keystr = ( $keystr[0], join('.', @keystr[1 .. $#keystr]  ) );
  	}
     if (@keystr == 2){
      $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] } = $value ;
      $self->logger->log("debug", " _placeholder_hash_add_item:  Adding @keystr and $value. Value from hash: " . $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] });
  
     }
      if (@keystr == 3){
         $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] }{ $keystr[2] } = $value;
     }
  }
  
  
  =method 
  This function gives the grouping index when there is a job filter present. To see why we need to do this
  consider the following example of how where we want our groupby jobs to end up - i.e. for 3 groups we want
  them to have their output in the first 3 jobs. In the following example, we have filtered all of group A
  jobs. So there will be nothing in job0.
  
  The group order is set by a alphanumeric sort of the group names.
  
  Grp  jobid  jobs-executed   jobs-in-output
    A  0                            ( nothing in job0)
    B  1 -->   x             1 ---> (group 2 in job1 by sorting order)
    A  2                     5 ---> (group 3 in job2 by sorting order)
    A  3  
    B  4 -->   x
    C  5 -->   x 
  
  So we have to construct job_ids to group numbers:
  
    [ 0 --> 1, 1 --> 2, 2 --> 1, 3 --> 1, 4 --> 2, 5 --> 3 ]
  
  Then we have to do filter out non executed jobs (using the job filter that lists all the jobs to be executed)
    
     [  1 --> 2, 4 --> 2, 5 --> 3 ]
   
  Finally we have to uniq the values and collapse them:
  
    [  1 --> 2, 4 --> 3, 5 --> 0]
  
  The 5 --> 0 is the third run that is executed , and it is given a default group_idx of zero, because we don't actually
  care about how this is executed and it should be pruned in the groupby pruning step. 
  Now we have a hash that gives back the right group_idx for a particular run.
  Of course we require the correct behaviour in the groupby pruning to see this work properly.   
  =cut 
  
  sub get_grouping_indexes{
      my $self=shift;
      my $job_filter = shift;
      my $job_map_hash = shift;
      my $JOB_NUM = shift;
      my @grouped_jobs = sort keys %$job_map_hash;
      my %job_group_order_hash ;
      my $group_order = 0;
      #my $util = App::Pipeline::Lite4::Util->new;            
        
      my %job_filter_hash = map{ $_ => 1 } @$job_filter;
      
      # construct hash [ job_num -> group_order] e.g { 0 -> 0 , 1 -> 0, 2 -> 0, 3 -> 1, 4 -> 1  }
      foreach my $grouped_jobs (@grouped_jobs){
          my $jobs_in_group = $job_map_hash->{$grouped_jobs};
          foreach my $job_in_group (@$jobs_in_group){
              $job_group_order_hash{$job_in_group} = $group_order;
          }
          $group_order++;
      }
      # leave only the executed jobs
      foreach my $job (keys %job_group_order_hash){
          unless( exists( $job_filter_hash{$job} ) ){
              delete $job_group_order_hash{$job};
          }
      }
      my @sorted_groups_in_job_filter = sort {$a<=>$b} values(%job_group_order_hash);
      my @groups_in_job_filter = App::Pipeline::Lite4::Util::uniq( @sorted_groups_in_job_filter );
      #warn Dumper @groups_in_job_filter;
      my %job_group_order_exec_hash;
      my $i=0;
      foreach my $job ( sort{ $a <=> $b} keys %job_group_order_hash){
          if(defined $groups_in_job_filter[$i]){
              $job_group_order_exec_hash{$job} = $groups_in_job_filter[$i];
          }else{ # higher jobs just get the first group
              $job_group_order_exec_hash{$job} = 0; 
          }
          $i++;
      }
      #warn Dumper "job exec group: ";
      #warn Dumper %job_group_order_exec_hash;
      # if JOB_NUM is executed
      if( exists( $job_group_order_exec_hash{$JOB_NUM} ) ){
          return $job_group_order_exec_hash{$JOB_NUM};
      }else{
          return 0;
      }    
  }
  
  
  =method 
  # For a placeholder such as [% step1.myfilename %], this function generates a full pathname that will be substituted for this placeholder
  # ( e.g  "/home/user/pipelineA/output/run1/step1/myfilename")
  #
  #  Each job can have one to multiple steps. Each step can have several placeholders. This function handles (for any particular job) 
  #  transforming (resolving) the placeholder into actual pathname(s). 
  #  There are currently three placeholder cases:
  #     1. stepX.fileY  --> gets resolved to a single pathname
  #     2. jobs.stepX.fileY  --> gets resolved to a list of pathnames 
  #     3. groupby.groupby-field.stepX.fileY --> gets resolved to a list of pathname(s) dependent on the groupby field
  #
  #  Specifics:
  #  case 1: 
  #    a) Can have a "once condition" - meaning that the step commands will only be executed in one of the jobs(i.e. once).
  #       A job number has to be chosen for this one execution, and the rule is that it's the minimum job number. 
  #       This means generally when executing over a datasource, only the first job - job0 will contain the  
  #       outputs from a step with a once condition.
  
  Essential to remember that this function is being called for every job in the datasource:
  Grp  jobid  jobs-executed   
    A  0 -->             
    B  1 -->   x            
    A  2 -->                 
    A  3 --> 
    B  4 -->   x
    C  5 -->   x 
  Jobs are then filtered later to determine what actually gets executed. See the _resolve function.
  
  Currently we do not support properly groupby under job filtering. Some work towards this is in the get_grouping_indexes function.
  
  The way it seems like this might work is:
     1. Resolve the right groupby paths - and put them in the first g jobs (g the number of groups)
        This would entail running the first four jobs on groupby steps. This seems a little messy because the job filtering function will
        remove jobs that are not specified to run.  We would have to add an exception to the appropriate job purging function, to ensure that
        group by steps are saved.
      
  =cut
  
  =method 
      clean up of _add_steps_in_step_struct_to_placeholder_hash
      we will handle three types of steps here:
        * Normal Steps
        * Groupby Steps
        * Once Steps
        
      Under each of these steps we need to handle the placeholders differently
        *Normal Steps:
           - steps that originated from previous step types:
               Normal Step Placeholder  - fine
               Once Step Placeholder    - fine
               Groupby Step Placeholder - not fine - in future it might be possible to refer to a groupby class
           - jobs. placeholder        - fine
           - groupby placeholder      - fine?  - should not be fine
        *Groupby Steps
           - steps that originated from previous step types:
               Normal Step Placeholder  - not fine 
               Once Step Placeholder    - fine
               Groupby Step Placeholder - fine under certain circumstances
           - jobs. placeholder        - fine
           - groupby placeholder      - fine with condition 
          
  =cut
  =method
   Remember this is essentially just adding to a **placeholder_hash** 
   which looks like:
     'step1' => {
            'filename' => '/path/to/filename'
            'err'      => '/path/to/err'
     }
     'step2' => {
     }
     ...
  
    This placeholder_hash is being built for each row in the datasource(see _resolve), then added to the  pipeline_step_struct_resolved
    hash. Then it is cleaned out, and the next row is processed. So this function here is being called once per datasource 
    row and then adding each time to placeholder_hash.
  =cut 
  sub _add_steps_in_step_struct_to_placeholder_hash2 {
      #TYPES: ( Num :$job_num ){
      my $self    = shift;
      my $JOB_NUM = shift;
      my $step_struct = $self->pipeline_step_struct; # we have placeholders parsed for each step
  
      #warn "JOB_NUM $JOB_NUM";
      foreach my $step_name (keys %$step_struct ){
          $self->logger->log( "debug", "Processing Pipeline to placeholder hash step " . $step_name);
          my $placeholders = $step_struct->{$step_name}->{placeholders};
          next unless defined($placeholders);
          
          # NORMAL STEPS (NO CONDITIONS)
          if( !defined( $step_struct->{$step_name}->{condition} ) ){
              $self->_add_NORMALSTEP_in_step_struct_to_placeholder_hash($step_name, $JOB_NUM);
          }elsif( $step_struct->{$step_name}->{condition} eq 'once' ){ 
          # ONCE STEPS 
              $self->_add_ONCESTEP_in_step_struct_to_placeholder_hash($step_name, $JOB_NUM);
          }elsif ( $step_struct->{$step_name}->{condition} eq 'groupby'){ 
          # GROUPBY STEPS    
              $self->_add_GROUPBYSTEP_in_step_struct_to_placeholder_hash($step_name,$JOB_NUM);
          }else{
              $self->logger->log( "debug", 
               "$step_name did not match any of normal, once, or groupby. This means it's placeholders are not added into the system");
          }
          
      }
  }
  
  sub _add_ONCESTEP_in_step_struct_to_placeholder_hash {
      my $self = shift;
      my $step_name = shift;
      my $JOB_NUM = shift;
      my $step_struct = $self->pipeline_step_struct;
      my $placeholders = $step_struct->{$step_name}->{placeholders};
      #next unless defined($placeholders);
      
      foreach my $placeholder ( @$placeholders ) {
          my $placeholder_resolved_str;
          # normal steps of type stepx.file1 or whatever
          # these can still come from several types of other steps 
          my $placeholder_step_form = $self->_placeholder_step_form($placeholder, $step_name);
          my ($placeholder_step_name) = $self->_parse_steppath_placeholder($placeholder);
          if ( $placeholder_step_form eq 'step.path' ){ 
              my $placeholder_step_condition = $step_struct->{$placeholder_step_name}->{condition};          
              if( !defined ( $placeholder_step_condition )){ 
                  ouch 'App_Pipeline_Lite4_ERROR', 
                    "Placeholder $placeholder in step $step_name references a normal step (not .once or .groupby) and is inconsistent with 
                      a .once step.";                
              }elsif ( $placeholder_step_condition eq 'once' ) {
                  my $min_job = 0;
                  my $jobs = $self->job_filter;
                  ($min_job) = sort {$a <=> $b} @$jobs if defined($jobs);
                  $placeholder_resolved_str=$self->_resolve_steppath_step_placeholder($placeholder,$placeholder_step_name, $min_job);
              }elsif ( $placeholder_step_condition eq 'groupby' ){
                  ouch 'App_Pipeline_Lite4_ERROR', 
                    "Placeholder $placeholder in step $step_name references a groupby step and is inconsistent with 
                      a .once step.";  
              }else{
                  ouch 'App_Pipeline_Lite4_ERROR',"The form of $step_name referenced by the placeholder $placeholder is not recognised by the system";
              }         
          }elsif ( $placeholder_step_form eq 'jobs' ){ 
              # the step_name is purely for logging purposes
              $placeholder_resolved_str=$self->_resolve_jobs_step_placeholder($placeholder, $step_name,   $JOB_NUM);
          }elsif ( $placeholder_step_form eq 'groupby' ){ 
              # ouch
              ouch 'App_Pipeline_Lite4_ERROR',"A groupby placeholder exists in the .once step $step_name .";
          }elsif ( $placeholder_step_form eq 'input' ){
              # no need to do anything
          }else{
              ouch 'App_Pipeline_Lite4_ERROR',"The form of the placeholder $placeholder in $step_name is not recognised by the system";
          }
          
          if( defined( $placeholder_resolved_str ) ){
               $self->_placeholder_hash_add_item( $placeholder, $placeholder_resolved_str); #in order key,value
               $self->logger->debug("step $step_name. Generated file location for placeholder $placeholder as $placeholder_resolved_str");
          }
      }
  }
  sub _add_GROUPBYSTEP_in_step_struct_to_placeholder_hash {
      my $self = shift;
      my $step_name = shift;
      my $JOB_NUM = shift;
      my $step_struct = $self->pipeline_step_struct;
      my $placeholders = $step_struct->{$step_name}->{placeholders};
      #next unless defined($placeholders);
      
      foreach my $placeholder ( @$placeholders ) {
          my $placeholder_resolved_str;
          # normal steps of type stepx.file1 or whatever
          # these can still come from several types of other steps 
          my $placeholder_step_form = $self->_placeholder_step_form($placeholder);
          my ($placeholder_step_name) = $self->_parse_steppath_placeholder($placeholder);
          if ( $placeholder_step_form eq 'step.path' ){ 
              my $placeholder_step_condition = $step_struct->{$placeholder_step_name}->{condition};          
              if( !defined ( $placeholder_step_condition )){    
                   ouch 'App_Pipeline_Lite4_ERROR', 
                    "Placeholder $placeholder in step $step_name references a normal step ($placeholder_step_name is not a .once or .groupby step) and is inconsistent with 
                      a .groupby step.";                       
              }elsif ( $placeholder_step_condition eq 'once' ) {
                  my $min_job = 0;
                  my $jobs = $self->job_filter;
                  ($min_job) = sort {$a <=> $b} @$jobs if defined($jobs);
                  $placeholder_resolved_str=$self->_resolve_steppath_step_placeholder($placeholder,$placeholder_step_name, $min_job);
              }elsif ( $placeholder_step_condition eq 'groupby' ){ 
                  # any step.path placeholders in this step will come under this condition as well (since it's a groupby)
                  # for other steps, so long as it's a step that has the same groupby field as this step
                  my $this_step_groupby_field = $step_struct->{$step_name}->{condition_params}->[0];
                  my $placeholder_step_groupby_field = $step_struct->{$placeholder_step_name}->{condition_params}->[0];
                  ouch 'App_Pipeline_Lite4_ERROR', "step $step_name has placeholders that refer to different groupby criteria" if $this_step_groupby_field ne $placeholder_step_groupby_field;
                  $placeholder_resolved_str = $self->_resolve_steppath_step_placeholder($placeholder,$placeholder_step_name, $JOB_NUM); 
              }          
          }elsif ( $placeholder_step_form eq 'jobs' ){ 
              # the step_name in this method is purely for logging purposes
              $placeholder_resolved_str=$self->_resolve_jobs_step_placeholder($placeholder, $step_name, $JOB_NUM);
          }elsif ( $placeholder_step_form eq 'groupby' ){ 
              $placeholder_resolved_str=$self->_resolve_groupby_step_placeholder($placeholder, $step_name, $JOB_NUM);
          }elsif ( $placeholder_step_form eq 'input' ){
              # no need to do anything
          }else{
              ouch 'App_Pipeline_Lite4_ERROR',"The form of the placeholder $placeholder in $step_name is not recognised by the system";
          }
          if( defined( $placeholder_resolved_str ) ){
               $self->_placeholder_hash_add_item( $placeholder, $placeholder_resolved_str); #in order key,value
               $self->logger->debug("step $step_name. Generated file location for placeholder $placeholder as $placeholder_resolved_str");
          }
      }
  }
  
  
  =method
    In a normal step - one without a condition like once of groupby 
    we need to look at each placeholder and consider the kind of step its
    has come from.
      The [% step.path %] form placeholder could refer to a step that is: 
        a) normal
           i)   with the same step we are currently processing
           ii)  references a different step         
        b) groupby 
        c) once
        
        
      We then have to look at  other placeholer forms such as:
      [% jobs...    %]
      [% groupby....%]
      
      We only need to process a-i) above in the a) category because the other steps will already resolve and add
      the placeholder to the placeholder_hash
      
      In the c category we have to ensure that we refer to only minimum/job0 job 
      
  =cut
  sub _add_NORMALSTEP_in_step_struct_to_placeholder_hash {
      my $self = shift;
      my $step_name = shift;
      my $JOB_NUM = shift;
      my $step_struct = $self->pipeline_step_struct;
      my $placeholders = $step_struct->{$step_name}->{placeholders};
      #next unless defined($placeholders);
      
      foreach my $placeholder ( @$placeholders ) {
          my $placeholder_resolved_str;
          # normal steps of type stepx.file1 or whatever
          # these can still come from several types of other steps 
          my $placeholder_step_form = $self->_placeholder_step_form($placeholder);
          my ($placeholder_step_name) = $self->_parse_steppath_placeholder($placeholder);
          if ( $placeholder_step_form eq 'step.path' ){ 
              my $placeholder_step_condition;
              if( exists $step_struct->{$placeholder_step_name} ){
                  # we need to test whether it exists, otherwise, due to autovivication, suddenly we will
                  # have create a step in our $step_struct e.g. datasource or input, which are both 
                  # of the form step.path - but shouldn't be added to the step_struct (nothing should be added to this)
                  $placeholder_step_condition = $step_struct->{$placeholder_step_name}->{condition};          
              }
              if( !defined ( $placeholder_step_condition )){
                  if( $placeholder_step_name eq $step_name){
                      # we only need to worry about the step.path that have the step name the same as this current step 
                      # the other placeholders will be added either on other steps, or in the case of a datasource added
                      # by it's own method
                      $placeholder_resolved_str = $self->_resolve_steppath_step_placeholder($placeholder,$placeholder_step_name, $JOB_NUM);
                  }
              }elsif ( $placeholder_step_condition eq 'once' ) {
                  my $min_job = 0;
                  my $jobs = $self->job_filter;
                  ($min_job) = sort {$a <=> $b} @$jobs if defined($jobs);
                  $placeholder_resolved_str=$self->_resolve_steppath_step_placeholder($placeholder,$placeholder_step_name, $min_job);
              }elsif ( $placeholder_step_condition eq 'groupby' ){
                  ouch 'App_Pipeline_Lite4_ERROR',"A placeholder $placeholder in $step_name references .groupby step when $step_name is not a .groupby step.";
              }
             
          }elsif ( $placeholder_step_form eq 'jobs' ){ 
              # the $step_name in this function is purely for logging purposes in the method
              $placeholder_resolved_str=$self->_resolve_jobs_step_placeholder($placeholder, $step_name,$JOB_NUM);
          }elsif ( $placeholder_step_form eq 'groupby' ){ 
              ouch 'App_Pipeline_Lite4_ERROR',"A groupby placeholder exists in the step $step_name when it is not a .groupby step.";
          }elsif ( $placeholder_step_form eq 'input' ){
              # no need to do anything
          }else{
              ouch 'App_Pipeline_Lite4_ERROR',"The form of the placeholder $placeholder in $step_name is not recognised by the system";
          }
          if( defined( $placeholder_resolved_str ) ){
               $self->_placeholder_hash_add_item( $placeholder, $placeholder_resolved_str); #in order key,value
               $self->logger->debug("step $step_name. Generated file location for placeholder $placeholder as $placeholder_resolved_str");
          }
      }
  }
  
  # we can have steps of 
  #  * step.path
  #  * groupby.field.step.path 
  #  * jobs.step.path 
  sub _parse_steppath_placeholder {
      my $self = shift;
      my $placeholder = shift;
      my $placeholder_rgx = qr/^([\w\-]+)(\.(.+))*$/; 
      my @steppath;
      if( @steppath= $placeholder =~ $placeholder_rgx ){
          return @steppath;
      }
  }
  
  sub _parse_jobs_placeholder {
      my $self = shift;
      my $placeholder = shift;
      my $jobs_placeholder_rgx = qr/jobs\.([\w\-]+)\.(.+)$/; 
      my @steppath;
      if( @steppath= $placeholder =~ $jobs_placeholder_rgx ){
          return @steppath;
      }
  }
  
  sub _placeholder_step_form {
      my $self = shift;
      my $placeholder = shift;
      #my $step_name   = shift;
     
      my $jobs_placeholder_rgx = qr/jobs\.([\w\-]+)\.(.+)$/;
      if($placeholder =~ $jobs_placeholder_rgx){
          return "jobs";    
      }
      
      if( $placeholder =~ /groupby/ ){  
          return "groupby";
      }
      
      if( $placeholder =~ /^input/ ){  
          return "input";
      }
      
      # if it's not a jobs or groupby placeholder it's of the form step.path    
      my $placeholder_rgx = qr/^([\w\-]+)(\.(.+))*$/;
      
      if( $placeholder =~ $placeholder_rgx ){
          return "step.path";
      }
  }
  
   #==== case 1. stepX.fileY ====
  #resolves placeholders of the form of step.path
  sub _resolve_steppath_step_placeholder {
      my $self = shift;
      my $placeholder = shift;
      my $step_name   = shift;
      my $JOB_NUM     = shift;
      my $placeholder_resolved_str;
      my @output_run_dir;
              
     
      $self->logger->debug("step $step_name. Processing $placeholder");
      my $placeholder_rgx = qr/^($step_name)(\.(.+))*$/;
      @output_run_dir = $placeholder =~ $placeholder_rgx ;
      $self->logger->debug("step $step_name. Got " . Dumper(@output_run_dir) . " from $placeholder");
      # we don't want [1] - the dot, so @output_run_dir is 2 length array
      @output_run_dir = @output_run_dir[0,2];
      if( defined $output_run_dir[1] ){ 
            $placeholder_resolved_str = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;                  
      }elsif (  defined $output_run_dir[0]  ) {
             #case where only the step name exists
             pop @output_run_dir; # remove last entry because if second element is not defined array = ("stepname",undef) 
             $placeholder_resolved_str = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;
             #warn "PLACEHOLDER", $placeholder;
             #warn "OUTPUT RUN DIR (NORMAL PLCHOLDER) ". Dumper @output_run_dir;
             #warn "OUTPUTFILES(NORMAL PLCHOLDER) ".$output_files;
      }
      $self->logger->debug("step $step_name. Extracted a run dir from: @output_run_dir. Full path is $placeholder_resolved_str ");
      return $placeholder_resolved_str;
  }
  
  #==== case 2. jobs.[stepX|datasource].[fileY|datasource_column] ====
  # To resolve this form of placeholder we need to generate a list of resolved placeholder paths over ALL jobs 
  sub _resolve_jobs_step_placeholder {
      my $self = shift;
      my $placeholder = shift;
      my $step_name   = shift;
      my $JOB_NUM     = shift;
      my $placeholder_resolved_str;
      my @output_run_dir;
      my $jobs_placeholder_rgx = qr/jobs\.([\w\-]+)\.(.+)$/;
      @output_run_dir=$placeholder =~ $jobs_placeholder_rgx;
      my @placeholder_resolved_paths; # all the placeholder resolved paths
      my $num_of_jobs = $self->tot_jobs;
      for my $job_num ( 0 .. $num_of_jobs -1 ) {
           if( $output_run_dir[0] eq 'datasource' ) {
               my $t = $self->pipeline_datasource;
               my @datasource_rows = $t->col( $output_run_dir[1] );
               push(  @placeholder_resolved_paths,$datasource_rows[$job_num] );
           }else{
               push(  @placeholder_resolved_paths,
                      $self->_generate_file_output_location(
                              $job_num, \@output_run_dir)->stringify );
          }
      }
      # JOB FILTER: If we are running with specific job numbers, then we want only those paths associated
      #             with those job numbers.
      my $job_filter = $self->job_filter;
      @placeholder_resolved_paths =  @placeholder_resolved_paths[@$job_filter] if defined ( $job_filter );
      $placeholder_resolved_str = join ' ',  @placeholder_resolved_paths;
      $self->logger->debug("step $step_name. Extracted a run dir from: @output_run_dir. Full path is $placeholder_resolved_str");
      return $placeholder_resolved_str;
  }
  
  sub _resolve_groupby_step_placeholder {
      my $self = shift;
      my $placeholder = shift;
      my $step_name   = shift;
      my $JOB_NUM     = shift;
      my $placeholder_resolved_str;
      #my @output_run_dir;
      if( $placeholder =~ /groupby/ ){  
          my $groupby_placeholder_rgx;
          # get the datasource
          my $col_names = $self->pipeline_datasource->{header};
          #warn "WORKING WITH DATASOURCE: " . $self->datasource_file; #warn "DATASOURCE: " . Dumper $self->pipeline_datasource;
          my $col_names_rgx_str = join "|", @$col_names;
          my $groupby_placeholder_rgx_str = 'groupby\.('.$col_names_rgx_str . ')\.(' . $col_names_rgx_str . ')*\.*([\w\-]+)\.(.+)$';
          #warn "PLACEHOLDER $placeholder"; #warn "PLACEHOLDER RGX:", $groupby_placeholder_rgx_str;
          $groupby_placeholder_rgx = qr/$groupby_placeholder_rgx_str/;
          my @output_run_dir = $placeholder =~  $groupby_placeholder_rgx;
          #warn "PLACEHOLDER PARTS:", Dumper @output_run_dir;
          # Allows two groupby fields, here we check if the second groupby field is present
          my @group_names;
          if ( defined $output_run_dir[1] ){
              @group_names = @output_run_dir[0,1];
              @output_run_dir = @output_run_dir[2 .. $#output_run_dir];
          }else{
              @group_names = $output_run_dir[0 ];
              @output_run_dir = @output_run_dir[2 .. $#output_run_dir];
          }
          # warn "OUTPUTDIR @output_run_dir";
          if ( ! defined $output_run_dir[0] ){
              ouch 'App_Pipeline_Lite4_ERROR', "The groupby placeholder has a group name that does not exist in the datasource";
          }
  
          #warn "OUTPUTDIR", "@output_run_dir";#warn "GROUP NAMES: @group_names";
          my $util = App::Pipeline::Lite4::Util->new;            
          my $job_map_hash = $util->datasource_groupby2( $self->pipeline_datasource, @group_names );
          # This gives a hash e.g.: {groupA=> [0,1,2,3], groupB=>[4,5,6]}
          #warn Dumper $job_map_hash;
                              
          my $job_filter = $self->job_filter;
          my %job_filter_hash = map{ $_ => 1 } @$job_filter if defined($job_filter);
                 
          # order the groupnames - so that we always have the same groups in the same jobs
          my @grouped_jobs = sort keys %$job_map_hash;
          my $grouped_job_idx;               
          $grouped_job_idx = ($JOB_NUM <= $#grouped_jobs) ? $JOB_NUM : 0;
                 
          # if there is a job filter then we have to get the right group index 
          if( defined $job_filter){
              $grouped_job_idx = $self->get_grouping_indexes($job_filter,$job_map_hash,$JOB_NUM); 
          }
               
          # resolve for this placeholder the set of paths corresponding to the particular group associated with this JOB_NUM                             
          my $grouped_jobs_id = $grouped_jobs[ $grouped_job_idx ];
          my @placeholder_resolved_paths;
          my $jobs = $job_map_hash->{$grouped_jobs_id};
                 
          for my $job_num ( @$jobs){
              if( defined($job_filter) ){ 
                  #skip adding into @placeholder_resolved_paths if job is in job filter
                  next unless exists($job_filter_hash{$job_num} );
              }
              if( $output_run_dir[0] eq 'datasource' ) {
                  my $t = $self->pipeline_datasource;
                  my @datasource_rows = $t->col( $output_run_dir[1] );
                  push( @placeholder_resolved_paths,$datasource_rows[$job_num] );
              }else{
                  push( @placeholder_resolved_paths, $self->_generate_file_output_location($job_num, \@output_run_dir)->stringify );
             }  
          }
          $placeholder_resolved_str = join ' ', @placeholder_resolved_paths;
          #warn "STEPFILES: $output_files";
          return $placeholder_resolved_str;
      }
  }
  
  
  
  =method _create_directory_structure_from_placeholder_hash
    At the moment we  allow directory with 'dir' in the name
    to be created as a directory - e.g. for this scenario
    e.g. 1. some_app --output-dir [ step1.dir ]
    Where some_app requires a pre-existing directory for storing it's output
    We could resolve this issue without using this.
    By doing:
    1. mkdir [% step1.outputdir %]; some_app --output-dir [% step1.outputdir %]
    So it's debatable whether we want automatic creation of directories with 'dir' in the name,
    but will leave for backwards compatability
    THE DIR BEHAVIOUR SHOULD BE DEPRECATED
  =cut
  
  sub _create_directory_structure_from_placeholder_hash {
      my $self = shift;
      $self->logger->debug("Creating directory structure from placeholder hash...");
      # run over hash
      my $placeholder_hash = $self->placeholder_hash;
      $self->logger->debug(Dumper($placeholder_hash));
      foreach my $step (keys %$placeholder_hash ){
         next if( ($step eq 'step0') or ($step eq 'datasource')); # we don't create any directories from the source step values. (which could be filenames)
         next if( ($step eq 'groupby')); # don't make directory on a groupby
         foreach my $param (keys $placeholder_hash->{$step} ){
             if ($param =~ /dir/) {
                 my $dir = path( $placeholder_hash->{$step}->{$param} );
                 #make_path($dir->stringify);
                 $dir->mkpath;
                 $self->logger->debug("Making directory: $dir" );
             } else {
                my $file = path( $placeholder_hash->{$step}->{$param} );
                #make_path($file->parent->stringify);
                $file->parent->mkpath;
                $self->logger->debug("Making directory (step $step): " . $file->parent->stringify );
  
             }
         }
      }
  }
  
  # processing the "X.output file1 file2 .."  lines
  sub _add_expected_output_files_to_placeholder_hash {
       # TYPE: ( Num :$job_num )
       my $self = shift;
       my $job_num = shift;
       my $step_struct = $self->pipeline_step_struct; # we have outputfiles parsed for each step
       foreach my $step_name (keys %$step_struct ){
          $self->logger->debug( "Processing expected output file for Step: " . $step_name);
          $self->logger->debug("Make filepaths and placeholder hash entry for stated outputs of step $step_name");
          my $file_num = 1;
          $self->logger->debug("So far there are " . ($file_num - 1) . " file(s) registered as outputs for this step");
          my $outputfiles = $step_struct->{$step_name}->{outputfiles};
          if( defined( $outputfiles) ) {
              foreach my $outputfile ( @$outputfiles ) {
                    #output_path_in_run_dir should be output_path_in_job_dir
                    #check whether the file_path is absolute, if its absolute then we don't generate anything for it
                   # if($step_name =~ /^[1-9][0-9]*[a-z]*$/){
                   #   my $file_path = $self->_generate_file_output_location( $job_num, ['step'. $step_name , $outputfile] );
                   #   $self->placeholder_hash->{"step$step_name"}{"output$file_num"}=$file_path->stringify;
                   #   $self->logger->debug( "Made step$step_name output$file_num : " . $file_path->stringify);
                   #   $file_num++;
                   # }else{
                      my $file_path = $self->_generate_file_output_location( $job_num, [ $step_name , $outputfile] );
                      $self->placeholder_hash->{"$step_name"}{"output$file_num"}=$file_path->stringify;
                      $self->logger->debug( "Made $step_name output$file_num : " . $file_path->stringify);
                      $file_num++;
                   # }
              }
          }
       }
  }
  
  sub _add_expected_output_files_to_jobs_in_placeholder_hash {
      my $self = shift;
      #get the expected output files
      my $step_struct = $self->pipeline_step_struct;
      my $placeholder_hash = $self->placeholder_hash;
      return if( ! exists $placeholder_hash->{jobs} );
      my $jobs = $placeholder_hash->{jobs};
      foreach my $step (keys %$jobs){
         next if $step eq 'datasource';
         my $filenames_and_paths = $jobs->{$step};
         my @filenames = keys %$filenames_and_paths;
         foreach my $filename (@filenames){
           my ($output_num) = $filename =~ /output([0-9]+)/;
           next unless defined( $output_num);
           my $outputfiles = $step_struct->{$step}->{outputfiles};
           my $name_of_output_file  = $outputfiles->[$output_num-1];
           $filenames_and_paths->{$filename}  =~ s/output$output_num/$name_of_output_file/g;
         }
      }
  }
  
  =method _validate_placeholder_with_placeholders
  
     What happens if you add a non existant placeholder e.g. [% step0.fil %] ?
     The parser has parsed out this placeholder - so it is part of the step_struct placeholders for each step
     But, it won't have a corresponding value in the placeholder hash, since it not of the right form.
     Not having a value, might be desired behaviour for somethings (this could be warned),
     But not existing in the hash is an error.
  
  =cut
  
  sub _validate_placeholder_hash_with_placeholders {
     my $self = shift;
     #foreach step check that we have the right stuff in the placeholder hash
      my $step_struct = $self->pipeline_step_struct;
      my %problem_placeholders;
      foreach my $step_name ( keys %$step_struct) {
         my $placeholders = $step_struct->{$step_name}->{placeholders};
         $self->logger->debug( "Validating Step: " . $step_name);
          foreach my $placeholder (@$placeholders) {
             #if($placeholder =~ /^datasource\./){
             #   ($placeholder ) = $placeholder =~ /datasource\.(.+)$/;
             #}
             #ouch 'App_Pipeline_Lite2_Error', "Check the placeholder $placeholder - it is incorrectly named."
             #  . Dumper ($self->placeholder_hash)
             #  unless $self->_placeholder_hash_check_item_exists( keystr => $placeholder );
             $problem_placeholders{ $placeholder } = 1  unless $self->_placeholder_hash_check_item_exists(  $placeholder );;
          }
      }
      my @problem_placeholders = keys %problem_placeholders;
      my $problem_placeholders = join "\n", @problem_placeholders ;
      ouch 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER', "Check the placeholders:\n$problem_placeholders\n"
               if @problem_placeholders > 0;
  
  }
  
  sub _interpolate_cmd_in_step_struct_to_resolved_step_struct {
      # ( Num :$job_num ) {
      my $self = shift;
      my $job_num = shift;
      my $step_struct = $self->pipeline_step_struct;
      $self->logger->debug("Step struct has : " . Dumper( $step_struct ));
      $self->logger->debug("Placeholder hash has : " . Dumper ( $self->placeholder_hash ) );
      my %output_hash;
      my $interpolated_cmd;
      my $interpolated_output;
      my $new_step_struct = dclone($step_struct);
      my $tt = App::Pipeline::Lite4::Template::TinyMod->new;
      foreach my $step ( keys %$step_struct) {
         my $cmd = $step_struct->{$step}->{cmd};
         $interpolated_cmd = $tt->_process($self->placeholder_hash, $cmd);
         $new_step_struct->{$step}->{cmd} =$interpolated_cmd;
         $interpolated_cmd = '';
  
         #also do for output line
  
         if( exists $step_struct->{$step}->{outputfiles} ){
             my $output_files = $step_struct->{$step}->{outputfiles};
              $new_step_struct->{$step}->{outputfiles} = [];
             foreach my $output (@$output_files){
                 $interpolated_output = $tt->_process($self->placeholder_hash, $output);
                 my $outputfiles = $new_step_struct->{$step}->{outputfiles};
                 push(@$outputfiles, $interpolated_output); #CHECK THIS IN TEST
                 $interpolated_output = '';
             }
         }
      }
      $self->pipeline_step_struct_resolved->{$job_num} = $new_step_struct;
  }
  
  
  sub _placeholder_hash_check_item_exists{
      # TYPE: Str :$keystr
      my $self = shift;
      my $keystr = shift;
      my @keystr = ();
      @keystr = split('\.', $keystr) if ($keystr =~ /\./);
      return exists $self->placeholder_hash->{ $keystr } if( @keystr == 0);
  
      if( $keystr[0] eq 'jobs'){
  	  @keystr = ( $keystr[0], $keystr[1], join('.', @keystr[2 .. $#keystr]  ) );
  	}else {
        @keystr = ( $keystr[0], join('.', @keystr[1 .. $#keystr]  ) );
  	}
  
      return exists $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] } if @keystr == 2;
      return exists $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] }{ $keystr[2] } if @keystr == 3;
  }
  
  sub _once_condition_filter_on_resolved_step_struct {
     my $self = shift;
     my $resolved_step_struct = $self->pipeline_step_struct_resolved;
     my @keys = sort {$a <=> $b } keys %$resolved_step_struct;
     shift @keys; #remove the lowest job
     $self->logger->debug("Deleting once steps in these steps: @keys");
     foreach my $job_num (@keys){
         my $job = $resolved_step_struct->{$job_num};
         foreach my $step (keys %$job) {
            next unless ( exists  $job->{$step}->{condition}  );
            next unless ( defined $job->{$step}->{condition}  );
            if ( $job->{$step}->{condition} eq 'once') {
                  $self->logger->debug("Deleting once step in $job_num");
                  delete $job->{$step};
            }
         }
     }
  }
  
  sub _groupby_condition_filter_on_resolved_step_struct {
      my $self = shift;
      my $resolved_step_struct = $self->pipeline_step_struct_resolved;
      my @keys = sort {$a <=> $b } keys %$resolved_step_struct;
      # need to get the number of jobs to shift off.
      my $util = App::Pipeline::Lite4::Util->new;
  
      #shift @keys for 0 .. $num_grouped_jobs - 1; #remove the X lowest jobs depending on the step groupby clause
      $self->logger->debug("Consider deleting groupby steps in these steps: @keys");
      foreach my $job_num (@keys){
         my $job = $resolved_step_struct->{$job_num};
         foreach my $step (keys %$job) {
            next unless ( exists  $job->{$step}->{condition}  );
            next unless ( defined $job->{$step}->{condition}  );
            if ( $job->{$step}->{condition} eq 'groupby') {
                  my $params = $job->{$step}->{condition_params};
                  my $num_grouped_jobs = $util->datasource_groupby2_num_groups($self->pipeline_datasource, @$params);
                  if( $job_num >= $num_grouped_jobs){
                      $self->logger->debug("Deleting groupby step $step in $job_num");
                      delete $job->{$step};
                  }
            }
         }
     }
  }
  
  
  
  sub _generate_file_output_location {
     # TYPE:( :$job_num, :$output_path_in_run_dir )
     my ($self, $job_num, $output_path_in_run_dir) = @_;
     if ( defined $self->run_num_dep ) {
        my $steps = $self->step_filter;
  
        #### WE WANT ANY####
        my $code = sub { my $k = shift; return 1 if( $output_path_in_run_dir->[0] eq $k ); return 0;   };
        my $valid_step = reduce { $a || $code->(local $_ = $b)  } 0,  @$steps;
        # my $valid_step = any{ ($output_path_in_run_dir->[0] =~ $_) } @$steps;
        ###############
  
        if ( !$valid_step ) {
         my $alt_run_dir = path( $self->output_dir, $self->output_run_name . ($self->run_num_dep) );
         return path( $alt_run_dir , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
        }
     }
     return path( $self->current_run_dir , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
     # return file( $self->output_dir, 'run' . ($self->current_run_num) , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
  }
  
  =method _run_number
     Provides the last run number by looking at previous run directory numbers
  =cut
  ## THIS IS IN BASE NOW - REMOVE
  sub _last_run_number {
      my $self=shift;
      #read in files in data directory
      #order by run number
      # - if none then run number is 1.
      my $run_num = max map { if( $_ =~ /run([0-9]+)/){$1}else{} } $self->output_dir->children;
      $run_num = 0 unless (defined $run_num);
      return $run_num;
  }
  1;
APP_PIPELINE_LITE4_RESOLVER

$fatpacked{"App/Pipeline/Lite4/SetupPipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_SETUPPIPELINE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::SetupPipeline ;
  use Moo;
  use MooX::late;
  
  extends 'App::Pipeline::Lite4::Base';
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
   
  sub create_pipeline_directory {
      my $self=shift;
      my $based_on = shift; # PARAMETER TYPE: ( Path::Tiny $based_on? ) i.e. optional 
      
      my $dir             = $self->pipeline_dir;
      my $output_dir      = $self->output_dir;
      my $input_dir       = $self->input_dir;
      my $pipeline_file   = $self->pipeline_file;
      my $test_data_file  = $self->test_data_file;
      my $datasource_file = $self->datasource_file;
      my $software_dir    = $self->software_dir;
      my $sys_dir         = $self->sys_dir;
      ouch 'App_Pipeline_Lite4_Error', "That pipeline already exists."  if $dir->exists;
      $dir->mkpath();  
      $output_dir->mkpath();
      $input_dir->mkpath();
      $software_dir->mkpath();
      $sys_dir->mkpath();
      
      #set output file and read to config file
      $self->config->{_}->{output_dir} = $output_dir->absolute->stringify;
      $self->config->{_}->{input_dir}  = $input_dir->absolute->stringify;
  
      $self->config->write($self->config_file->absolute->stringify); 
      
      #create a small pipeline file and a dummy test data directory
   
      $pipeline_file->spew("seq. seq [% datasource.N %] | egrep -v '[% datasource.filter %]' > [% seq.filterseq.txt %]");
      $test_data_file->parent->mkpath();
      #$test_data_file->spew("line1\nline2\nline3");    
  my $ds = "N\tfilter\tgroup\tname
  12\t5|6\tA\tjames
  15\t7|8\tB\tnozomi
  16\t9|10\tA\tryan
  20\t12|13\tB\ttiffiny";
       
      #create a small datasource file
      #my $datasource = "step0.file1\n" . $test_data_file->absolute->stringify;
      $datasource_file->spew($ds);
      $self->create_logfile_config;
  }
  
  
  sub create_logfile_config {
     my $self = shift; 
     my $default = 
     { 
       file => {
                filename => defined($self->logfile) ? $self->logfile : "/tmp/".__PACKAGE__.".log",
                maxlevel => "debug",
                minlevel => "warning",
                message_layout => "%T [%L] [%p] line %l: %m",
              }
     };
     my $conf_yaml  = Dump($default);
     $self->logconffile->spew($conf_yaml);  
  }
  1;
APP_PIPELINE_LITE4_SETUPPIPELINE

$fatpacked{"App/Pipeline/Lite4/Template/TinyMod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_TEMPLATE_TINYMOD';
  package App::Pipeline::Lite4::Template::TinyMod;
  
  # Load overhead: 40k
  
  #use 5.00503;
  use strict;
  
  $Template::Tiny::VERSION = '1.12';
  
  # Evaluatable expression
  my $EXPR = qr/ [a-z_\-][\-\w.]* /xs;
  
  # Opening [% tag including whitespace chomping rules
  my $LEFT = qr/
  	(?:
  		(?: (?:^|\n) [ \t]* )? \[\%\-
  		|
  		\[\% \+?
  	) \s*
  /xs;
  
  # Closing %] tag including whitespace chomping rules
  my $RIGHT  = qr/
  	\s* (?:
  		\+? \%\]
  		|
  		\-\%\] (?: [ \t]* \n )?
  	)
  /xs;
  
  sub new {
  	bless { @_[1..$#_] }, $_[0];
  }
  
  sub _process {
  	my ($self, $stash, $text) = @_;
      # Resolve expressions
  
  	$text =~ s/
  		$LEFT ( $EXPR ) $RIGHT
  	/
  		eval {
  			$self->_expression($stash, $1)
  			. '' # Force stringification
  		}
  	/gsex;
  	return $text;
  }
  
  
  sub _expression {
  	my $cursor = $_[1];
  	
  	my @path   = split /\./, $_[2];
  	if( $path[0] eq 'jobs'){
  	  @path = ( $path[0], $path[1], join('.', @path[2 .. $#path]  ) ); 
  	}else {
        @path = ( $path[0], join('.', @path[1 .. $#path]  ) );
  	}
  	
  	foreach ( @path ) {
  		# Support for private keys
  		return undef if substr($_, 0, 1) eq '_';
  
  		# Split by data type
  		my $type = ref $cursor;
  		
  		#if ( $type eq 'ARRAY' ) {
  		#	return '' unless /^(?:0|[0-9]\d*)\z/;
  		#	$cursor = $cursor->[$_];
  		#} elsif ( $type eq 'HASH' ) {
  		#	$cursor = $cursor->{$_};
  		#} elsif ( $type ) {
  		#	$cursor = $cursor->$_();
  		#} else {
  		#	return '';
  		#}
  		if ( $type eq 'HASH' ) {
  			$cursor = $cursor->{$_};
  	    }else {
  		  return '';	
          }
  		
  	}
  	return $cursor;
  }
APP_PIPELINE_LITE4_TEMPLATE_TINYMOD

$fatpacked{"App/Pipeline/Lite4/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_UTIL';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Util ;
  use Moo;
  use Term::UI;
  use Term::ReadLine; 
  use Path::Tiny;
  use Time::Piece;
  use Data::Dumper;
  use List::Util qw(reduce);
  extends 'App::Pipeline::Lite4::Base';
   
  use Ouch;
  
  sub view_file_with_editor {
      my $self = shift; 
      my $filename = shift; # PARAMETER TYPE: ( Path::Tiny $filename ) 
      
      my $editor = $self->system_config->{_}->{editor} ; #check system config first     
      ouch 'App_Pipeline_Lite4_Error', "No pipeline editor set, try --editor EDITOR.  (e.g. --editor vim)" unless defined($editor);    
      my $cmd = qq{$editor $filename};
      
      eval {
        system($cmd);
      };
      
      if ( hug ) {
        ouch 'App_Pipeline_Lite4_Error', "Viewing the file with the editor '$editor' did not work. Perhaps set something different in system config.";    
      }
  }
  
  sub set_editor  {
      my $self = shift;
      my $editor = shift; # TYPE: ( Str $editor  )
      $self->system_config->{_}->{editor}  = $editor;
      $self->system_config->write($self->system_config_file);
      $self->system_logger->log( "info", "Set $editor as default editor");
  }
  
  sub ask_for_description {
    #( Num $run_num ) {
    my $self = shift;  
    my $term = Term::ReadLine->new('describe-run');
      
    my $print_me = <<PRINTME;
       
       *************
        Description
       -------------    
  PRINTME
      
      my $bool = $term->ask_yn(
              prompt => "Do you want to describe this run?"            
              );
            
     if($bool) {
       my $desc = $term->get_reply(
              print_me => $print_me,
              prompt => "Enter description: ",
       ); 
     }  
  }
  
  sub append_description {
    my $self         = shift;  
    my $run_info     = shift // "";
    my $message      = shift // "";
    my $append_file  = $self->pipeline_submission_file;
    my $t = localtime;
    my $run_desc = join "\t", $t->datetime, $run_info, $message;
    $run_desc .= "\n";
    my $path = path($append_file)->append($run_desc); 
  }
  
  sub uniq {
    my %seen;
    return grep { !$seen{$_}++ } @_;
  }
  
  =function all
    This function is pulled from  List::Util documentation
    use:
     Need to create a code reference with the condition
     $util->any( sub { $_[0] > 1 },  (1,2,3) ) 
       you can use the $_ instead of $_[0]
     $util->any( sub { $_ > 1 } , (1,2,3))
  =cut
  sub any {
    my $code = shift;
    my @list = @_;
    my $foo = reduce { $a || $code->(local $_ = $b) } 0, @list;
  }
  
  
  sub datasource_groupby {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    while( my $row = $next->() ){ 
      #warn Dumper $row;   
      push( @{ $group_hash{ $row->{$groupby_field} } }, $i );  
      $i++;
    }
    return \%group_hash; 
  }
  #the idea is to only offer a groupby one attribute, if more than one
  #is required then the datasource should be given an extra column and
  # the two column mergedin to a specific column
  # the exception is for grouptransby which will work with two columns in general I think.
  # for testing purposes we have this here.
  =cut
  sub datasource_groupby2 {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    while( my $row = $next->() ){ 
      #warn Dumper $row;
      
      if( defined($groupby_field1) and defined( $groupby_field2 )){    
          push( @{ $group_hash{$row->{$groupby_field1} .'-' . $row->{$groupby_field2} } } , $i );  
      }elsif( defined($groupby_field1 ) ){
          push( @{ $group_hash{ $row->{$groupby_field1} } }, $i );   
      }else{
          ouch "App_Pipeline_Lite4_Error","No groupby fields to group by";
      }
        
      $i++;
    }
    return \%group_hash; 
  }
  =cut
  sub datasource_groupby2 {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my $grouphash_and_order_array = datasource_groupby2main($datasource_table,$groupby_field1,$groupby_field2);
    return $grouphash_and_order_array->[0];
  }
  
  
  sub datasource_groupby2main {
    #my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    my @group_array;
    my @group_array_unique;
    while( my $row = $next->() ){ 
      #warn Dumper $row;
      if( defined($groupby_field1) and defined( $groupby_field2 )){    
          push( @{ $group_hash{$row->{$groupby_field1} .'-' . $row->{$groupby_field2} } } , $i );  
          push( @group_array, $row->{$groupby_field1} .'-' . $row->{$groupby_field2});
      }elsif( defined($groupby_field1 ) ){
          push( @{ $group_hash{ $row->{$groupby_field1} } }, $i );   
          push( @group_array, $row->{$groupby_field1} );
      }else{
          ouch "App_Pipeline_Lite4_Error","No groupby fields to group by";
      }
        
      $i++;
    }
    @group_array_unique = uniq( @group_array);
    return [ \%group_hash, \@group_array_unique]; 
  }
  
  
  # this gives back group ids in an ordering that
  # is ordered by first instance of group in the datasource
  sub datasource_groupby2_order {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my $grouphash_and_order_array = datasource_groupby2main($datasource_table,$groupby_field1,$groupby_field2);
    return $grouphash_and_order_array->[1];
  }
  
   
  
  sub datasource_groupby2_num_groups {
    my $self = shift;
    my @args = @_;
    #warn "DATASOURC ARGS ," , Dumper @args;
    my $groupby_hash = $self->datasource_groupby2(@args);
    return scalar keys %$groupby_hash;  
  }
  
  sub groupby_placeholder_regex_get_step {
    my $self       = shift;
    my $datasource = shift;
    my $groupby_fields  = shift;
  
    my $col_names = $datasource->{header};
    my $col_names_rgx_str = join "|", @$col_names;               
    my $groupby_placeholder_rgx_str = 'groupby\.('.$col_names_rgx_str . ')\.(' . $col_names_rgx_str . ')*\.*(.+)$';
    
  }
  
  1;
APP_PIPELINE_LITE4_UTIL

$fatpacked{"App/Rad.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD';
  package App::Rad;
  use 5.006;
  use App::Rad::Help;
  use Carp                ();
  use warnings;
  use strict;
  
  our $VERSION = '1.05';
  {
  
  #========================#
  #   INTERNAL FUNCTIONS   #
  #========================#
  
  my @OPTIONS = ();
  
  sub _init {
      my $c = shift;
  
      # instantiate references for the first time
      $c->{'_ARGV'    } = [];
      $c->{'_options'} = {};
      $c->{'_stash'  } = {};
      $c->{'_config' } = {};
      $c->{'_plugins'} = [];
  
      # this internal variable holds
      # references to all special
      # pre-defined control functions
      $c->{'_functions'} = {
          'setup'        => \&setup,
          'pre_process'  => \&pre_process,
          'post_process' => \&post_process,
          'default'      => \&default,
          'invalid'      => \&invalid,
          'teardown'     => \&teardown,
      };
      
      #load extensions
      App::Rad::Help->load($c);
      foreach (@OPTIONS) {
          if ($_ eq 'include') {
              eval 'use App::Rad::Include; App::Rad::Include->load($c)';
              Carp::croak 'error loading "include" extension.' if ($@);
          }
          elsif ($_ eq 'exclude') {
              eval 'use App::Rad::Exclude; App::Rad::Exclude->load($c)';
              Carp::croak 'error loading "exclude" extension.' if ($@);
          }
          elsif ($_ eq 'debug') {
              $c->{'debug'} = 1;
          }
          else {
          	$c->load_plugin($_);
          }
  	}
  	
      # tiny cheat to avoid doing a lot of processing
      # when not in debug mode. If needed, I'll create
      # an actual is_debugging() method or something
      if ($c->{'debug'}) {
          $c->debug('initializing: default commands are: '
              . join ( ', ', $c->commands() )
          );
      }
  }
  
  sub import {
      my $class = shift;
      @OPTIONS  = @_;
  }
  
  sub load_plugin {
      my $c      = shift;
      my $plugin = shift;
  	my $class  = ref $c;
  
      my $plugin_fullname = '';    
  	if ($plugin =~ s{^\+}{} ) {
  		$plugin_fullname = $plugin;
  	}
      else {
          $plugin_fullname = "App::Rad::Plugin::$plugin";
      }
  	eval "use $plugin_fullname ()";
      Carp::croak "error loading plugin '$plugin_fullname': $@\n"
          if $@;
      my %methods = _get_subs_from($plugin_fullname);
  
      Carp::croak "No methods found for plugin '$plugin_fullname'\n"
  		unless keys %methods > 0;
  
  	no strict 'refs';
  	foreach my $method (keys %methods) {
          # don't add plugin's internal methods
          next if substr ($method, 0, 1) eq '_';
  
  		*{"$class\::$method"} = $methods{$method};
  		$c->debug("-- method '$method' added [$plugin_fullname]");
  
          # fill $c->plugins()
          push @{ $c->{'_plugins'} }, $plugin;
  	}
  }
  
  # this function browses a file's
  # symbol table (usually 'main') and maps
  # each function to a hash
  #
  # FIXME: if I create a sub here (Rad.pm) and
  # there is a global variable with that same name
  # inside the user's program (e.g.: sub ARGV {}),
  # the name will appear here as a command. It really 
  # shouldn't...
  sub _get_subs_from {
      my $package = shift || 'main';
      $package .= '::';
      
      my %subs = ();
  
      no strict 'refs';
      while (my ($key, $value) = ( each %{*{$package}} )) {
          local (*SYMBOL) = $value;
          if ( defined $value && defined *SYMBOL{CODE} ) {
              $subs{$key} = $value;
          }
      }
      return %subs;
  }
  
  
  # overrides our pre-defined control
  # functions with any available
  # user-defined ones
  sub _register_functions {
      my $c = shift;
      my %subs = _get_subs_from('main');
  
      # replaces only if the function is
      # in 'default', 'pre_process' or 'post_process'
      foreach ( keys %{$c->{'_functions'}} ) {
          if ( defined $subs{$_} ) {
              $c->debug("overriding $_ with user-defined function.");
              $c->{'_functions'}->{$_} = $subs{$_};
          }
      }
  }
  
  # retrieves command line arguments
  # to be executed by the main program
  sub _get_input {
      my $c = shift;
  
      my $cmd = (defined ($ARGV[0]) and substr($ARGV[0], 0, 1) ne '-')
              ? shift @ARGV
              : ''
              ;
  
      @{$c->argv} = @ARGV;
      $c->{'cmd'} = $cmd;
  
      $c->debug('received command: ' . $c->{'cmd'});
      $c->debug('received parameters: ' . join (' ', @{$c->argv} ));
  
      $c->_tinygetopt();
  }
  
  # stores arguments passed to a
  # command via --param[=value] or -p
  sub _tinygetopt {
      my $c = shift;
  
      my @argv = ();
      foreach ( @{$c->argv} ) {
  
          # single option (could be grouped)
          if ( m/^\-([^\-\=]+)$/o) {
              my @args = split //, $1;
              foreach (@args) {
  				if ($c->options->{$_}) {
  					$c->options->{$_}++;
  				}
  				else {
  					$c->options->{$_} = 1;
  				}
              }
          }
          # long option: --name or --name=value
          elsif (m/^\-\-([^\-\=]+)(?:\=(.+))?$/o) {
              $c->options->{$1} = defined $2 ? $2 
  			                  : 1
                                ;
          }
          else {
              push @argv, $_;
          }
      }
      @{$c->argv} = @argv;
  }
  
  
  #========================#
  #     PUBLIC METHODS     #
  #========================#
  
  sub load_config {
      require App::Rad::Config;
      App::Rad::Config::load_config(@_);
  }
  
  
  #TODO: this code probably could use some optimization
  sub register_commands {
      my $c = shift;
      my %help_for_sub = ();
      my %rules = ();
  
      # process parameters
      foreach my $item (@_) {
          if ( ref ($item) ) {
              Carp::croak '"register_commands" may receive only HASH references'
                  unless ref ($item) eq 'HASH';
              foreach my $params (keys %{$item}) {
                  if ($params eq '-ignore_prefix'
                   or $params eq '-ignore_suffix'
                   or $params eq '-ignore_regexp'
                  ) {
                      $rules{$params} = $item->{$params};
                  }
                  else {
                      $help_for_sub{$params} = $item->{$params};
                  }
              }
          }
          else {
              $help_for_sub{$item} = undef; # no help text
          }
      }
  
      my %subs = _get_subs_from('main');
  
      foreach (keys %help_for_sub) {
  
          # we only add the sub to the commands
          # list if it's *not* a control function
          if ( not defined $c->{'_functions'}->{$_} ) {
  
              # user want to register a valid (existant) sub
              if ( exists $subs{$_} ) {
                  $c->debug("registering $_ as a command.");
                  $c->{'_commands'}->{$_}->{'code'} = $subs{$_};
                  App::Rad::Help->register_help($c, $_, $help_for_sub{$_});
              }
              else {
                  Carp::croak "'$_' does not appear to be a valid sub. Registering seems impossible.\n";
              }
          }
      }
  
      # no parameters, or params+rules: try to register everything
      if ((!%help_for_sub) or %rules) {
          foreach my $subname (keys %subs) {
  
              # we only add the sub to the commands
              # list if it's *not* a control function
              if ( not defined $c->{'_functions'}->{$subname} ) {
  
                  if ( $rules{'-ignore_prefix'} ) {  
                      next if ( substr ($subname, 0, length($rules{'-ignore_prefix'}))
                             eq $rules{'-ignore_prefix'}
                              );
                  }
                  if ( $rules{'-ignore_suffix'} ) {
                      next if ( substr ($subname, 
                                        length($subname) - length($rules{'-ignore_suffix'}),
                                        length($rules{'-ignore_suffix'})
                                       )
                                eq $rules{'-ignore_suffix'}
                              );
                  }
                  if ( $rules{'-ignore_regexp'} ) {
                      my $re = $rules{'-ignore_regexp'};
                      next if $subname =~ m/$re/o;
                  }
  
                  # avoid duplicate registration
                  if ( !exists $help_for_sub{$subname} ) {
                      $c->{'_commands'}->{$subname}->{'code'} = $subs{$subname};
                      App::Rad::Help->register_help($c, $subname, undef);
                  }
              }
          }
      }
  }
  
  
  sub register_command { return register(@_) }
  sub register {
      my ($c, $command_name, $coderef, $helptext) = @_;
      $c->debug("got: " . ref $coderef);
      return undef
          unless ( (ref $coderef) eq 'CODE' );
  
      $c->debug("registering $command_name as a command.");
      $c->{'_commands'}->{$command_name}->{'code'} = $coderef;
      App::Rad::Help->register_help($c, $command_name, $helptext);
      return $command_name;
  }
  
  sub unregister_command { return unregister(@_) }
  sub unregister {
      my ($c, $command_name) = @_;
  
      if ( $c->{'_commands'}->{$command_name} ) {
          delete $c->{'_commands'}->{$command_name};
      }
      else {
          return undef;
      }
  }
  
  
  sub create_command_name {
      my $id = 0;
      foreach (commands()) {
          if ( m/^cmd(\d+)$/ ) {
              $id = $1 if ($1 > $id);
          }
      }
      return 'cmd' . ($id + 1);
  }
  
  
  sub commands {
      return ( keys %{$_[0]->{'_commands'}} );
  }
  
  
  sub is_command {
      my ($c, $cmd) = @_;
      return (defined $c->{'_commands'}->{$cmd}
              ? 1
              : 0
             );
  }
  
  sub command :lvalue { cmd(@_) }
  sub cmd :lvalue {
      $_[0]->{'cmd'};
  }
  
  
  sub run {
      my $class = shift;
      my $c = {};
      bless $c, $class;
  
      $c->_init();
  
      # first we update the control functions
      # with any overriden value
      $c->_register_functions();
  
      # then we run the setup to register
      # some commands
      $c->{'_functions'}->{'setup'}->($c);
  
      # now we get the actual input from
      # the command line (someone using the app!)
      $c->_get_input();
  
      # run the specified command
      $c->execute();
  
      # that's it. Tear down everything and go home :)
      $c->{'_functions'}->{'teardown'}->($c);
  
      return 0;
  }
  
  # run operations 
  # in a shell-like environment
  #sub shell {
  #    my $class = shift;
  #    App::Rad::Shell::shell($class);
  #}
  
  sub execute {
      my ($c, $cmd) = @_;
  
      # given command has precedence
      if ($cmd) {
          $c->{'cmd'} = $cmd;
      }
      else {
          $cmd = $c->{'cmd'};  # now $cmd always has the called cmd
      }
  
      $c->debug('calling pre_process function...');
      $c->{'_functions'}->{'pre_process'}->($c);
  
      $c->debug("executing '$cmd'...");
  
      # valid command, run it
      if ($c->is_command($c->{'cmd'}) ) {
          $c->{'output'} = $c->{'_commands'}->{$cmd}->{'code'}->($c);
      }
      # no command, run default()
      elsif ( $cmd eq '' ) {
          $c->debug('no command detected. Falling to default');
          $c->{'output'} = $c->{'_functions'}->{'default'}->($c);
      }
      # invalid command, run invalid()
      else {
          $c->debug("'$cmd' is not a valid command. Falling to invalid.");
          $c->{'output'} = $c->{'_functions'}->{'invalid'}->($c);
      }
  
      # 3: post-process the result
      # from the command
      $c->debug('calling post_process function...');
      $c->{'_functions'}->{'post_process'}->($c);
  
      $c->debug('reseting output');
      $c->{'output'} = undef;
  }
  
  sub argv    { return $_[0]->{'_ARGV'}     }
  sub options { return $_[0]->{'_options'} }
  sub stash   { return $_[0]->{'_stash'}   }   
  sub config  { return $_[0]->{'_config'}  }
  
  # $c->plugins is sort of "read-only" externally
  sub plugins { 
      my @plugins = @{$_[0]->{'_plugins'}};
      return @plugins;
  }
  
  
  sub getopt {
      require Getopt::Long;
      Carp::croak "Getopt::Long needs to be version 2.36 or above"
          unless $Getopt::Long::VERSION >= 2.36;
  
      my ($c, @options) = @_;
  
      # reset values from tinygetopt
      $c->{'_options'} = {};
  
      my $parser = new Getopt::Long::Parser;
      $parser->configure( qw(bundling) );
  
      my @tARGV = @ARGV; # we gotta stick to our API
      my $ret = $parser->getoptions($c->{'_options'}, @options);
      @{$c->argv} = @ARGV;
      @ARGV = @tARGV;
  
      return $ret;
  }
  
  sub debug {
      if (shift->{'debug'}) {
          print "[debug]   @_\n";
      }
  }
  
  # gets/sets the output (returned value)
  # of a command, to be post processed
  sub output {
      my ($c, @msg) = @_;
      if (@msg) {
          $c->{'output'} = join(' ', @msg);
      }
      else {
          return $c->{'output'};
      }
  }
  
  
  #=========================#
  #     CONTROL FUNCTIONS   #
  #=========================#
  
  sub setup { $_[0]->register_commands( {-ignore_prefix => '_'} ) }
  
  sub teardown {}
  
  sub pre_process {}
  
  sub post_process {
      my $c = shift;
  
      if ($c->output()) {
          print $c->output() . $/;
      }
  }
  
  
  sub default {
      my $c = shift;
      return $c->{'_commands'}->{'help'}->{'code'}->($c);
  }
  
  
  sub invalid {
      my $c = shift;
      return $c->{'_functions'}->{'default'}->($c);
  }
  
  
  }
  42; # ...and thus ends thy module  ;)
  __END__
  
  =head1 NAME
  
  App::Rad - Rapid (and easy!) creation of command line applications
  
  =head1 VERSION
  
  Version 1.04
  
  =head1 SYNOPSIS
  
  This is your smallest working application (let's call it I<myapp.pl>)
  
      use App::Rad;
      App::Rad->run();
  
  That's it, your program already works and you can use it directly via the command line (try it!)
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          help    show syntax and available commands
  
  Next, start creating your own functions (e.g.) inside I<myapp.pl>:
  
      sub hello {
          return "Hello, World!";
      }
  
  And now your simple command line program I<myapp.pl> has a 'hello' command!
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          hello
          help    show syntax and available commands
  
  
     [user@host]$ ./myapp.pl hello
     Hello, World!
  
  You could easily add a customized help message for your command through the 'Help()' attribute:
  
      sub hello 
      :Help(give a nice compliment)
      {
          return "Hello, World!";
      }
  
  And then, as expected:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          hello   give a nice compliment
          help    show syntax and available commands
  
  
  App::Rad also lets you expand your applications, providing a lot of flexibility for every command, with embedded help, argument and options parsing, configuration file, default behavior, and much more:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup {
          my $c = shift;
  
          $c->register_commands( {
                  foo => 'expand your foo!',
                  bar => 'have a drink! arguments: --drink=DRINK',
              });
      }
  
      sub foo {
          my $c = shift;
          $c->load_config('myapp.conf');
  
          return 'foo expanded to ' . baz() * $c->config->{'myfoo'};
      }
  
      # note that 'baz' was not registered as a command,
      # so it can't be called from the outside.
      sub baz { rand(10) }
  
      sub bar {
          my $c = shift;
          if ( $c->options->{'drink'} ) {
              return 'you asked for a ' . $c->options->{'drink'};
          }
          else {
              return 'you need to ask for a drink';
          }
      }
  
          
  
  You can try on the command line:
  
     [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          bar 	have a drink! arguments: --drink=DRINK
          foo 	expand your foo!
          help	show syntax and available commands
  
  
     [user@host]$ ./myapp.pl bar --drink=martini
      you asked for a martini
  
  
  =head1 WARNING
  
  This module is very young, likely to change in strange ways and to have some bugs (please report if you find any!). I will try to keep the API stable, but even that is subject to change (let me know if you find anything annoying or have a wishlist). You have been warned!
  
  
  =head1 DESCRIPTION
  
  App::Rad aims to be a simple yet powerful framework for developing your command-line applications. It can easily transform your Perl I<one-liners> into reusable subroutines than can be called directly by the user of your program.
  
  It also tries to provide a handy interface for your common command-line tasks. B<If you have a feature request to easen out your tasks even more, please drop me an email or a RT feature request.>
  
  =head2 Extending App::Rad - Plugins!
  
  App::Rad plugins can be loaded by naming them as arguments to the C<< use App::Rad >> statement. Just ommit the C<< App::Rad::Plugin >> prefix from the plugin name. For example:
  
     use App::Rad  qw(My::Module);
  
  will load the C<< App::Rad::Plugin::My::Module >> plugin for you!
  
  Developers are B<strongly> encouraged to publish their App::Rad plugins under the C<< App::Rad::Plugin >> namespace. But, if your plugin start with a name other than that, you can fully qualify the name by using an unary plus sign:
  
    use App::Rad  qw(
            My::Module
            +Fully::Qualified::Plugin::Name
    );
  
  Note that plugins are loaded in the order in which they appear.
  
  B<Please refer to the actual plugin documentation for specific usage>. And check out L<< App::Rad::Plugin >> if you want to create your own plugins.
  
  
  =head1 INSTANTIATION
  
  These are the main execution calls for the application. In your App::Rad programs, the B<*ONLY*> thing your script needs to actually (and actively) call is one of the instantiation (or dispatcher) methods. Leave all the rest to your subs. Currently, the only available dispatcher is run():
  
  =head2 run()
  
  You'll be able to access all of your program's commands directly through the command line, as shown in the synopsis.
  
  
  =head1 BUILT-IN COMMANDS
  
  This module comes with the following default commands. You are free to override them as you see fit.
  
  
  =head2 help
  
  Shows help information for your program. This built-in function displays the program name and all available commands (including the ones you added yourself) if a user types the 'help' command, or no command at all, or any command that does not exist (as they'd fall into the 'default' control function which (by default) calls 'help').
  
  You can also display specific embedded help for your commands, either explicitly registering them with C<< $c->register() >> or C<< $c->register_commands() >> inside C<< $c->setup() >> (see respective sections below) or with the Help() attribute:
  
      use App::Rad;
      App::Rad->run();
      
      sub mycmd 
      :Help(display a nice welcome message) 
      {
          return "Welcome!";
      }
  
  the associated help text would go like this:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
  
      Available Commands:
          help 	show syntax and available commands
          mycmd	display a nice welcome message
      
  
  =head1 OTHER BUILT IN COMMANDS (OPT-IN)
  
  The 'include' and 'exclude' commands below let the user include and exclude commands to your program and, as this might be dangerous when the user is not yourself, you have to opt-in on them:
  
     use App::Rad qw(include);  # add the 'include' command
     use App::Rad qw(exclude);  # add the 'exclude' command
  
  though you'll probably want to set them both:
  
     use App::Rad qw(include exclude);
  
  
  =head2 include I<[command_name]> I<-perl_params> I<'your subroutine code'>
  
  Includes the given subroutine into your program on-the-fly, just as you would writing it directly into your program.
  
  Let's say you have your simple I<'myapp.pl'> program that uses App::Rad sitting on your system quietly. One day, perhaps during your sysadmin's tasks, you create a really amazing one-liner to solve a really hairy problem, and want to keep it for posterity (reusability is always a good thing!). 
  
  For instance, to change a CSV file in place, adding a column on position #2 containing the line number, you might do something like this (this is merely illustrative, it's not actually the best way to do it):
  
      $ perl -i -paF, -le 'splice @F,1,0,$.; $_=join ",",@F' somesheet.csv
  
  And you just found out that you might use this other times. What do you do? App::Rad to the rescue!
  
  In the one-liner above, just switch I<'perl'> to I<'myapp.pl include SUBNAME'> and remove the trailing parameters (I<somesheet.csv>):
  
      $ myapp.pl include addcsvcol -i -paF, -le 'splice @F,1,0,$.; $_=join ",",@F'
  
  That's it! Now myapp.pl has the 'addcsvcol' command (granted, not the best name) and you can call it directly whenever you want:
  
      $ myapp.pl addcsvcol somesheet.csv
  
  App::Rad not only transforms and adjusts your one-liner so it can be used inside your program, but also automatically formats it with Perl::Tidy (if you have it). This is what the one-liner above would look like inside your program:
  
      sub addcsvcol {
          my $c = shift;
      
          local ($^I) = "";
          local ($/)  = "\n";
          local ($\)  = "\n";
        LINE: while ( defined( $_ = <ARGV> ) ) {
              chomp $_;
              our (@F) = split( /,/, $_, 0 );
              splice @F, 1, 0, $.;
              $_ = join( ',', @F );
          }
          continue {
              die "-p destination: $!\n" unless print $_;
          }
      }
  
  With so many arguments (-i, -p, -a -F,, -l -e), this is about as bad as it gets. And still one might find this way easier to document and mantain than a crude one-liner stored in your ~/.bash_history or similar.
  
  B<Note:> If you don't supply a name for your command, App::Rad will make one up for you (cmd1, cmd2, ...). But don't do that, as you'll have a hard time figuring out what that specific command does.
  
  B<Another Note: App::Rad tries to adjust the command to its interface, but please keep in mind this module is still in its early stages so it's not guaranteed to work every time. *PLEASE* let me know via email or RT bug request if your one-liner was not correctly translated into an App::Rad command. Thanks!>
  
  
  =head2 exclude I<command_name>
  
  Removes the requested function from your program. Note that this will delete the actual code from your program, so be *extra* careful. It is strongly recommended that you do not use this command and either remove the subroutine yourself or add the function to your excluded list inside I<setup()>.
  
  Note that built-in commands such as 'help' cannot be removed via I<exclude>. They have to be added to your excluded list inside I<setup()>.
  
  
  
  =head1 ROLLING YOUR OWN COMMANDS
  
  Creating a new command is as easy as writing any sub inside your program. Some names ("setup", "default", "invalid", "pre_process", "post_process" and "teardown") are reserved for special purposes (see the I<Control Functions> section of this document). App::Rad provides a nice interface for reading command line input and writing formatted output:
  
  
  =head2 The Controller
  
  Every command (sub) you create receives the controller object "C<< $c >>" (sometimes referred as "C<< $self >>" in other projects) as an argument. The controller is the main interface to App::Rad and has several methods to easen your command manipulation and execution tasks.
  
  
  =head2 Reading arguments
  
  When someone types in a command, she may pass some arguments to it. Those arguments can be accessed in four different ways, depending on what you want. This way it's up to you to control which and how many arguments (if at all) you want to receive and/or use. They are:
  
  =head3 @ARGV
  
  Perl's @ARGV array has all the arguments passed to your command, without the command name (use C<< $c->cmd >> for this) and without any processing (even if you explicitly use C<< $c->getopt >>, which will change $c->argv instead, see below). Since the command itself won't be in the @ARGV parameters, you can use it in each command as if they were stand-alone programs.
  
  =head3 $c->options
  
  App::Rad lets you automatically retrieve any POSIX syntax command line options (I<getopt-style>) passed to your command via the $c->options method. This method returns a hash reference with keys as given parameters and values as... well... values. The 'options' method automatically supports two simple argument structures:
  
  Extended (long) option. Translates C<< --parameter or --parameter=value >> into C<< $c->options->{parameter} >>. If no value is supplied, it will be set to 1.
  
  Single-letter option. Translates C<< -p >> into C<< $c->options->{p} >>.
  
  Single-letter options can be nested together, so C<-abc> will be parsed into C<< $c->options->{a} >>, C<< $c->options->{b} >> and C<< $c->options{c} >>, while C<--abc> will be parsed into C<< $c->options->{abc} >>. We could, for instance, create a dice-rolling command like this:
  
      sub roll {
          my $c = shift;
  
          my $value = 0;
          for ( 1..$c->options->{'times'} ) {
              $value += ( int(rand ($c->options->{'faces'}) + 1));
          }
          return $value;
      }
  
  And now you can call your 'roll' command like:
  
      [user@host]$ ./myapp.pl roll --faces=6 --times=2
  
  Note that App::Rad does not control which arguments can or cannot be passed: they are all parsed into C<< $c->options >> and it's up to you to use whichever you want. For a more advanced use and control, see the C<< $c->getopt >> method below.
  
  Also note that single-letter options will be set to 1. However, if a user types them more than once, the value will be incremented accordingly. For example, if a user calls your program like so:
  
     [user@host]$ ./myapp.pl some_command -vvv
  
  or
  
     [user@host]$ ./myapp.pl some_command -v -v -v
  
  then, in both cases, C<< $c->options->{v} >> will be set to 3. This will let you easily keep track of how many times any given option was chosen, and still let you just check for definedness if you don't care about that. 
  
  
  =head3 $c->argv
  
  The array reference C<< $c->argv >> contains every argument passed to your command that have B<not> been parsed into C<< $c->options >>. This is usually a list of every provided argument that didn't start with a dash (-), unless you've called C<< $c->getopt >> and used something like 'param=s' (again, see below).
  
  =head3 $c->getopt (Advanced Getopt usage)
  
  App::Rad is also smoothly integrated with Getopt::Long, so you can have even more flexibility and power while parsing your command's arguments, such as aliases and types. Call the C<< $c->getopt() >> method anytime inside your commands (or just once in your "pre_process" function to always have the same interface) passing a simple array with your options, and refer back to $c->options to see them. For instance: 
  
      sub roll {
          my $c = shift;
  
          $c->getopt( 'faces|f=i', 'times|t=i' )
              or $c->execute('usage') and return undef;
  
          # and now you have $c->options->{'faces'} 
          # and $c->options->{'times'} just like above.
      }
  
  This becomes very handy for complex or feature-rich commands. Please refer to the Getopt::Long module for more usage examples.
  
  
  B<< So, in order to manipulate and use any arguments, remember: >>
  
  =over 6
  
  =item * The given command name does not appear in the argument list;
  
  =item * All given arguments are in C<< @ARGV >>
  
  =item * Automatically processed arguments are in C<< $c->options >>
  
  =item * Non-processed arguments (the ones C<< $c->options >> didn't catch) are in $c->argv
  
  =item * You can use C<< $c->getopt >> to have C<< Getopt::Long >> parse your arguments (it will B<not> change C<< @ARGV >>)
  
  =back
  
  
  =head2 Sharing Data: C<< $c->stash >>
  
  The "stash" is a universal hash for storing data among your Commands:
  
      $c->stash->{foo} = 'bar';
      $c->stash->{herculoids} = [ qw(igoo tundro zok gloop gleep) ];
      $c->stash->{application} = { name => 'My Application' };
  
  You can use it for more granularity and control over your program. For instance, you can email the output of a command if (and only if) something happened:
  
      sub command {
          my $c = shift;
          my $ret = do_something();
  
          if ( $ret =~ /critical error/ ) {
              $c->stash->{mail} = 1;
          }
          return $ret;
      }
  
      sub post_process {
          my $c = shift;
  
          if ( $c->stash->{mail} ) {
              # send email alert...
          }
          else {
              print $c->output . "\n";
          }
      }
  
  
  
  =head2 Returning output
  
  Once you're through, return whatever you want to give as output for your command:
  
      my $ret = "Here's the list: ";
      $ret .= join ', ', 1..5;
      return $ret;
      
      # this prints "Here's the list: 1, 2, 3, 4, 5"
  
  App::Rad lets you post-process the returned value of every command, so refrain from printing to STDOUT directly whenever possible as it will give much more power to your programs. See the I<post_process()> control function further below in this document.
  
  
  =head1 HELPER METHODS
  
  App::Rad's controller comes with several methods to help you manage your application easily. B<If you can think of any other useful command that is not here, please drop me a line or RT request>.
  
  
  =head2 $c->execute( I<COMMAND_NAME> )
  
  Runs the given command. If no command is given, runs the one stored in C<< $c->cmd >>. If the command does not exist, the 'default' command is ran instead. Each I<execute()> call also invokes pre_process and post_process, so you can easily manipulate income and outcome of every command.
  
  
  =head2 $c->cmd
  
  Returns a string containing the name of the command (that is, the first argument of your program), that will be called right after pre_process.
  
  
  =head3 $c->command
  
  Alias for C<< $c->cmd >>. This longer form is discouraged and may be removed in future versions, as one may confuse it with the C<< $c->commands() >> method, explained below. You have been warned.
  
  
  =head2 $c->commands()
  
  Returns a list of available commands (I<functions>) inside your program
  
  
  =head2 $c->is_command ( I<COMMAND_NAME> )
  
  Returns 1 (true) if the given I<COMMAND_NAME> is available, 0 (false) otherwise.
  
  
  =head2 $c->create_command_name()
  
  Returns a valid name for a command (i.e. a name slot that's not been used by your program). This goes in the form of 'cmd1', 'cmd2', etc., so don't use unless you absolutely have to. App::Rad, for instance, uses this whenever you try to I<include> (see below) a new command but do not supply a name for it.
  
  
  =head2 $c->load_config( I<< FILE (FILE2, FILE3, ...) >> )
  
  This method lets you easily load into your program one or more configuration files written like this:
  
      # comments and blank lines are discarded
      key1 value1
      key2:value2
      key3=value3
      key5           # stand-alone attribute (and inline-comment)
  
  
  =head2 $c->config
  
  Returns a hash reference with any loaded config values (see C<< $c->load_config() >> above).
  
  
  =head2 $c->register ( I<NAME>, I<CODEREF> [, I<INLINE_HELP> ])
  
  Registers a coderef as a callable command. Note that you don't have to call this in order to register a sub inside your program as a command, run() will already do this for you - and if you don't want some subroutines to be issued as commands you can always use C<< $c->register_commands() >> (note the plural) inside setup(). This is just an interface to dinamically include commands in your programs. The function returns the command name in case of success, undef otherwise.
  
  It is also very useful for creating aliases for your commands:
  
      sub setup {
          my $c = shift;
          $c->register_commands();
  
          $c->register('myalias', \&command);
      }
  
      sub command { return "Hi!" }
  
  and, on the command line:
  
      [user@host]$ ./myapp.pl command
      Hi!
  
      [user@host]@ ./myapp.pl myalias
      Hi!
  
  The last parameter is optional and lets you add inline help to your command:
  
      $c->register('cmd_name', \&cmd_func, 'display secret of life');
  
  =head3 $c->register_command ( I<NAME>, I<CODEREF> [, I<INLINE_HELP> ] )
  
  Longer alias for C<< $c->register() >>. It's use is disencouraged as one may confuse it with C<register_commands> (note the plural) below. Plus you type more :)
  As such, this method may be removed in future versions. You have been warned!
  
  =head2 $c->register_commands()
  
  This method, usually called during setup(), tells App::Rad to register subroutines as valid commands. If called without any parameters, it will register B<all> subroutines in your main program as valid commands (note that the default behavior of App::Rad is to ignore subroutines starting with an underscore '_'). You can easily change this behavior using some of the options below:
  
  =head3 Adding single commands
  
      $c->register_commands( qw/foo bar baz/ );
  
  The code above will register B<only> the subs C<foo>, C<bar> and C<baz> as commands. Other subroutines will B<not> be valid commands, so they can be used as internal subs for your program. You can change this behavior with the bundled options - see 'Adding several commands' and 'Putting it all together' below.
  
  =head3 Adding single commands (with inline help)
  
      $c->register_commands(
              {
                  dos2unix => 'convert text files from DOS to Unix format',
                  unix2dos => 'convert text files from Unix to DOS format',
              }
      );
  
  You can pass a hash reference containing commands as keys and a small help string as their values. The code above will register B<only> the subs C<dos2unix> and C<unix2dos>, and the default help for your program will become something like this:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          dos2unix    convert text files from DOS to Unix format
          help        show syntax and available commands
          unix2dos    convert text files from Unix to DOS format
  
  
  =head3 Adding several commands
  
  You can pass a hash reference as an argument, letting you choose which subroutines to add as commands. The following keys may be used (note the dash preceding each key):
  
  =over 4
  
  =item * C<< -ignore_prefix >>: subroutine names starting with the given string won't be added as commands
  
  =item * C<< -ignore_suffix >>: subroutine names ending with the given string won't be added as commands
  
  =item * C<< -ignore_regexp >>: subroutine names matching the given regular expression (as a string) won't be added as commands
  
  =back
  
  For example:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup { 
          my $c = shift; 
          $c->register_commands( { -ignore_prefix => '_' } );
      }
  
      sub foo  {}  # will become a command
      sub bar  {}  # will become a command
      sub _baz {}  # will *NOT* become a command
  
  This way you can easily segregate between commands and helper functions, making your code even more reusable without jeopardizing the command line interface (As of version 1.04, ignoring commands with underscore '_' prefixes is also the default App::Rad behavior).
  
  
  =head3 Putting it all together
  
  You can combine some of the options above to have even more flexibility:
  
      $c->register_commands(
              'foo',
              { -ignore_suffix => 'foo' },
              { bar => 'all your command line are belong to us' },
      );
  
  The code above will register as commands all subs with names B<not> ending in 'foo', but it B<will> register the 'foo' sub as well. It will also give the 'bar' command the help string. This behavior is handy for registering several commands and having a few exceptions, or to add your commands and only have inline help for a few of them (as you see fit).
  
  You don't have to worry about the order of your elements passed, App::Rad will figure them out for you in a DWIM fashion.
  
      # this does the same as the code above
      $c->register_commands(
              { bar => 'all your command line are belong to us' },
              'foo',
              { -ignore_suffix => 'foo' },
      );
  
  You can even bundle the hash reference to include your C<< cmd => help >> and special keys:
  
      # this behaves the same way as the code above:
      $c->register_commands(
          'foo',
          { 
              -ignore_suffix => 'foo',
              bar => 'all your command line are belong to us',
          }
      );
  
  
  =head2 $c->unregister_command ( I<NAME> )
  
  Longer alias for C<< $c->unregister() >>. The use of the shorter form is encouraged, and this alias may be removed in future versions. You have been warned.
  
  
  =head3 $c->unregister ( I<NAME> )
  
  Unregisters a given command name so it's not available anymore. Note that the subroutine will still be there to be called from inside your program - it just won't be accessible via command line anymore.
  
  
  =head2 $c->debug( I<MESSAGE> )
  
  Will print the given message on screen only if the debug flag is enabled:
  
      use App::Rad  qw( debug );
  
  Note that, if debug is enabled, App::Rad itself will print several debug messages stating its current flow, so you can easily find out where everything is happening.
  
  
  =head2 $c->plugins()
  
  Returns a list of all loaded plugins, in the order in which they were loaded.
  
  
  =head2 $c->load_plugin( I<PLUGIN NAME> )
  
  This method will dinamically load the given plugin. The plugin needs to be under the C<< App::Rad::Plugin >> namespace, and the name should be relative to this path (i.e. $c->load_plugin('MyPlugin') will try to load 'App::Rad::Plugin::MyPlugin'). If you want to load a plugin by its fully qualified name, you need to prepend a plus sign to the name ('+Fully::Qualified::Plugin::Name'). B<This is an internal method> and you really should refrain from using it. Instead, plugins should be loaded as parameters to the C<< use App::Rad >> statement, as explained above.
  
  
  =head1 CONTROL FUNCTIONS (to possibly override)
  
  App::Rad implements some control functions which are expected to be overridden by implementing them in your program. They are as follows:
  
  =head2 setup()
  
  This function is responsible for setting up what your program can and cannot do, plus everything you need to set before actually running any command (connecting to a database or host, check and validate things, download a document, whatever). Note that, if you override setup(), you B<< *must* >> call C<< $c->register_commands() >> or at least C<< $c->register() >> so your subs are classified as valid commands (check $c->register_commands() above for more information).
  
  Another interesting thing you can do with setup is to manipulate the command list. For instance, you may want to be able to use the C<include> and C<exclude> commands, but not let them available for all users. So instead of writing:
  
      use App::Rad qw(include exclude);
      App::Rad->run();
  
  you can write something like this:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup {
          my $c = shift;
          $c->register_commands();
  
          # EUID is 'root'
          if ( $> == 0 ) {
              $c->register('include', \&App::Rad::include);
              $c->register('exclude', \&App::Rad::exclude);
          }
      }
  
  to get something like this:
  
      [user@host]$ myapp.pl help
      Usage: myapp.pl command [arguments]
  
      Available Commands:
         help
  
      [user@host]$ sudo myapp.pl help
      Usage: myapp.pl command [arguments]
  
      Available Commands:
         exclude
         help
         include
  
  
  
  =head2 default()
  
  If no command is given to your application, it will fall in here. Please note that invalid (non-existant) command will fall here too, but you can change this behavior with the invalid() function below (although usually you don't want to).
  
  Default's default (grin) is just an alias for the help command.
  
      sub default {
          my $c = shift;
  
          # will fall here if the given
          # command isn't valid.
      }
  
  You are free (and encouraged) to change the default behavior to whatever you want. This is rather useful for when your program will only do one thing, and as such it receives only parameters instead of command names. In those cases, use the "C<< default() >>" sub as your main program's sub and parse the parameters with C<< $c->argv >> and C<< $c->getopt >> as you would in any other command.
  
  =head2 invalid()
  
  This is a special function to provide even more flexibility while creating your command line applications. This is called when the user requests a command that does not exist. The built-in C<< invalid() >> will simply redirect itself to C<< default() >> (see above), so usually you just have to worry about this when you want to differentiate between "no command given" (with or without getopt-like arguments) and "invalid command given" (with or without getopt-like arguments).
  
  =head2 teardown()
  
  If implemented, this function is called automatically after your application runs. It can be used to clean up after your operations, removing temporary files, disconnecting a database connection established in the setup function, logging, sending data over a network, or even storing state information via Storable or whatever.
  
  
  =head2 pre_process()
  
  If implemented, this function is called automatically right before the actual wanted command is called. This way you have an optional pre-run hook, which permits functionality to be added, such as preventing some commands to be run from a specific uid (e.g. I<root>): 
  
      sub pre_process {
          my $c = shift;
  
          if ( $c->cmd eq 'some_command' and $> != 0 ) {
              $c->cmd = 'default'; # or some standard error message
          }
      }
      
  
  =head2 post_process()
  
  If implemented, this function is called automatically right after the requested function returned. It receives the Controller object right after a given command has been executed (and hopefully with some output returned), so you can manipulate it at will. In fact, the default "post_process" function is as goes:
  
      sub post_process {
          my $c = shift;
  
          if ( $c->output() ) {
              print $c->output() . "\n";
          }
      }
  
  You can override this function to include a default header/footer for your programs (either a label or perhaps a "Content-type: " string), parse the output in any ways you see fit (CPAN is your friend, as usual), etc.
  
  
  
  =head1 IMPORTANT NOTE ON PRINTING INSIDE YOUR COMMANDS
  
  B<The post_process() function above is why your application should *NEVER* print to STDOUT>. Using I<print> (or I<say>, in 5.10) to send output to STDOUT is exclusively the domain of the post_process() function. Breaking this rule is a common source of errors. If you want your functions to be interactive (for instance) and print everything themselves, you should disable post-processing in setup(), or create an empty post_process function or make your functions return I<undef> (so I<post_process()> will only add a blank line to the output).
  
  
  =head1 DIAGNOSTICS
  
  If you see a '1' printed on the screen after a command is issued, it's probably because that command is returning a "true" value instead of an output string. If you don't want to return the command output for post processing(you'll loose some nice features, though) you can return undef or make post_process() empty.
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  App::Rad requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  App::Rad depends only on 5.8 core modules (Carp for errors, Getopt::Long for "$c->getopt", Attribute::Handlers for "help" and O/B::Deparse for the "include" command).
  
  If you have Perl::Tidy installed, the "include" command will tidy up your code before inclusion.
  
  The test suite depends on Test::More, FindBin and File::Temp, also core modules.
  
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  
  =head1 BUGS AND LIMITATIONS
  
  Please report any bugs or feature requests to 
  C<bug-app-easy at rt.cpan.org>, or through the web interface at 
  L<http://rt.cpan.org/garu/ReportBug.html?Queue=App-Rad>.  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
  
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc App::Rad
  
  Although this Module comes without any warraties whatsoever (see DISCLAIMER below), I try really hard to provide some quality assurance for the users. This means I not only try to close all reported bugs in the minimum amount of time but I also try to find some on my own.
  
  This version of App::Rad comes with 183 tests and I keep my eye constantly on CPAN Testers L<http://www.cpantesters.org/show/App-Rad.html> to ensure it passes all of them, in all platforms. You can send me your own App::Rad tests if you feel I'm missing something and I'll hapilly add them to the distribution.
  
  Since I take user's feedback very seriously, I really hope you send me any wishlist/TODO you'd like App::Rad to have (please try to send them via RT so other people can give their own suggestions).
  
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/garu/Bugs.html?Dist=App-Rad>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/App-Rad>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/App-Rad>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/App-Rad>
  
  =back
  
  =head2 IRC
  
     #app-rad  on irc.perl.org
  
  
  =head1 TODO
  
  This is a small list of features I plan to add in the near future (in no particular order). Feel free to contribute with your wishlist and comentaries!
  
  =over 4
  
  =item * Shell-like environment
  
  =item * Loadable commands (in an external container file)
  
  =item * Modularized commands (similar to App::Cmd::Commands ?)
  
  =item * app-starter
  
  =item * command inclusion by prefix, suffix and regexp (feature request by fco)
  
  =item * command inclusion and exclusion also by attributes
  
  =item * some extra integration, maybe IPC::Cmd and IO::Prompt
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 CONTRIBUTORS
  
  (in alphabetical order)
  
  Ben Hengst
  
  Fernando Correa
  
  Flavio Glock
  
  Thanks to everyone for contributing! Please let me know if I've skipped your name by accident.
  
  
  =head1 ACKNOWLEDGEMENTS
  
  This module was inspired by Kenichi Ishigaki's presentation I<"Web is not the only one that requires frameworks"> during YAPC::Asia::2008 and the modules it exposed (mainly App::Cmd and App::CLI).
  
  Also, many thanks to CGI::App(now Titanium)'s Mark Stosberg and all the Catalyst developers, as some of App::Rad's functionality was taken from those (web) frameworks.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD

$fatpacked{"App/Rad/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_CONFIG';
  package App::Rad::Config;
  
  sub load_config {
      my ($c, @files) = (@_);
  
      foreach my $filename (@files) {
  
          $c->debug("loading configuration from $filename");
          open my $CONFIG, '<', $filename
              or Carp::croak "error opening $filename: $!\n";
  
          while (<$CONFIG>) {
              chomp;
              s/#.*//;
              s/^\s+//;
              s/\s+$//;
              next unless length;
  
              if ( m/^([^\=\:\s]+)        # key
                  (?:                     # (value is optional)
                     (?:\s*[\=\:]\s*|\s+) # separator ('=', ':' or whitespace)
                     (.+)                 # value
                  )?
                  /x
              ) {
                  $c->config->{$1} = $2;
              }
          }
          close $CONFIG;
      }
  }
  
  42;
APP_RAD_CONFIG

$fatpacked{"App/Rad/Exclude.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_EXCLUDE';
  package App::Rad::Exclude;
  use Carp qw/carp croak/;
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('exclude', \&exclude, 'completely erase command from your program');
  }
  
  # removes given sub from the
  # main program
  sub _remove_code_from_file {
      my $sub = shift;
  
      #TODO: I really should be using PPI
      #if the user has it installed...
      open my $fh, '+<', $0
          or croak "error updating file $0: $!\n";
  
  #    flock($fh, LOCK_EX) or carp "could not lock file $0: $!\n";
  
      my @file = <$fh>;
      my $ret = _remove_code_from_array(\@file, $sub);
  
      # TODO: only change the file if it's eval'd without errors
      seek ($fh, 0, 0) or croak "error seeking file $0: $!\n";
      print $fh @file or croak "error writing to file $0: $!\n";
      truncate($fh, tell($fh)) or croak "error truncating file $0: $!\n";
  
      close $fh;
  
      return $ret;
  }
  
  sub _remove_code_from_array {
      my $file_array_ref = shift;
      my $sub = shift;
  
      my $index = 0;
      my $open_braces = 0;
      my $close_braces = 0;
      my $sub_start = 0;
      while ( $file_array_ref->[$index] ) {
          if ($file_array_ref->[$index] =~ m/\s*sub\s+$sub(\s+|\s*\{)/) {
              $sub_start = $index;
          }
          if ($sub_start) {
              # in order to see where the sub ends, we'll
              # try to count the number of '{' against
              # the number of '}' available
  
              #TODO:I should use an actual LR parser or
              #something. This would be greatly enhanced
              #and much less error-prone, specially for
              #nested symbols in the same line.
              $open_braces++ while $file_array_ref->[$index] =~ m/\{/g;
              $close_braces++ while $file_array_ref->[$index] =~ m/\}/g;
              if ( $open_braces > 0 ) {
                  if ( $close_braces > $open_braces ) {
                      croak "Error removing $sub: could not parse $0 correctly.";
                  }
                  elsif ( $open_braces == $close_braces ) {
                      # remove lines from array
                      splice (@{$file_array_ref}, $sub_start, ($index + 1 - $sub_start));
                      last;
                  }
              }
          }
      }
      continue {
          $index++;
      }
  
      if ($sub_start == 0) {
          return "Error finding '$sub' command. Built-in?";
      }
      else {
          return "Command '$sub' successfuly removed.";
      }
  }
  
  sub exclude {
      my $c = shift;
      if ( $c->argv->[0] ) {
          if ( $c->is_command( $c->argv->[0] ) ) {
              return _remove_code_from_file($c->argv->[0]);
          }
          else {
              return $c->argv->[0] . ' is not an available command';
          }
      }
      else {
          return "Sintax: $0 exclude command_name"
      }
  }
  
  42;
  __END__
  =head1 NAME
  
  App::Rad::Exclude - 'exclude' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.01
  
  =head1 SYNOPSIS
  
  'exclude' is an opt-in command for you App::Rad programs (myapp.pl):
  
      use App::Rad qw(exclude);  # add the 'exclude' command
      App::Rad->run();
      
      sub mycmd {
          print "hello, world\n";
      }
      
  and now you can permanently remove a command from your application
  
      [user@host]$ myapp.pl exclude mycmd
      
  Note that this B<*will*> edit the program's source code and try to remove the command (subroutine) automatically, so use it with extreme caution.
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately. Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 exclude
  
  Removes given command (subroutine) from your App::Rad program.
  
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * Carp, which is core in Perl 5.8.
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_EXCLUDE

$fatpacked{"App/Rad/Help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_HELP';
  package App::Rad::Help;
  use Attribute::Handlers;
  use strict;
  use warnings;
  
  our $VERSION = '0.03';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('help', \&help, 'show syntax and available commands');
  }
  
  # shows specific help commands
  # TODO: context specific help, 
  # such as "myapp.pl help command"
  sub help {
      my $c = shift;
      return usage() . "\n\n" . helpstr($c);
  }
  
  sub usage {
      return "Usage: $0 command [arguments]";
  }
  
  sub helpstr {
      my $c = shift;
      
      my $string = "Available Commands:\n";
  
      # get length of largest command name
      my $len = 0;
      foreach ( sort $c->commands() ) {
          $len = length($_) if (length($_) > $len);
      }
  
      # format help string
      foreach ( sort $c->commands() ) {
          $string .= sprintf "    %-*s\t%s\n", $len, $_, 
                             defined ($c->{'_commands'}->{$_}->{'help'})
                             ? $c->{'_commands'}->{$_}->{'help'}
                             : ''
                             ;
                  ;
      }
      return $string;
  }
      
  
  {
  my %help_attr = ();
  sub UNIVERSAL::Help :ATTR(CODE) {
       my ($package, $symbol, $ref, $attr, $data, $phase, $filename, $linenum) = @_;
  
      if ($package eq 'main') {
          # If data is a single word, it is received as an array ref. Don't ask.
          $data = join(' ', @$data) if ref($data) eq 'ARRAY';
          $help_attr{ *{$symbol}{NAME} } = $data;
      }
  }
  
  sub register_help {
      my ($self, $c, $cmd, $helptext) = @_;
  
      if ((not defined $helptext) && (defined $help_attr{$cmd})) {
          $helptext = $help_attr{$cmd};
      }
  
      # we do $helptext // undef as it would issue a warning otherwise
      $c->{'_commands'}->{$cmd}->{'help'} = defined $helptext
                                          ? $helptext
                                          : undef
                                          ;
  }
  
  }
  42;
  __END__
  
  =head1 NAME
  
  App::Rad::Help - 'help' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.02
  
  =head1 SYNOPSIS
  
  you can add inline help for your App::Rad commands via C<< $c->register() >> or C<< $c->register_commands() >>:
  
      use App::Rad;
      App::Rad->run();
      
      sub setup {
          my $c = shift;
          
          $c->register_commands( {
                  foo => 'expand your foo!',
                  bar => 'have a drink! arguments: --drink=DRINK',
              });
              
          $c->register('baz', \&baz, 'do your thing');
      }
      
  you can also do it with the attribute 'Help' in your subs
  
      sub my_command :Help(this is my command) {
          ...
      }
      
      sub another_cmd
      :Help(yet another command)
      {
          ...
      }
      
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately (unless, perhaps, you want to use one of its methods to customize your own 'help' command). Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 help
  
  Show help text
  
  =head2 register_help
  
  Associates help text with command
  
  =head2 usage
  
  Prints usage string. Default is "Usage: $0 command [arguments]", where $0 is your program's name.
  
  =head2 helpstr
  
  Prints a help string with all available commands and their help description.
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * Attribute::Handlers, which is core as of Perl 5.8.
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 ACKNOWLEDGEMENTS
  
  The attribute handling was *much* easened because of the nice C<< Attribute::Handlers >> module. So many thanks to Damian Conway, Rafael Garcia-Suarez and Steffen Mueller.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_HELP

$fatpacked{"App/Rad/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_INCLUDE';
  package App::Rad::Include;
  use Carp qw/carp croak/;
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('include', \&include, 'include one-liner as a command');
  }
  
  # translates one-liner into
  # a complete, readable code
  sub _get_oneliner_code {
      return _sanitize( _deparse($_[0]) );
  }
  
  
  #TODO: option to do it saving a backup file
  # (behavior probably set via 'setup')
  # inserts the string received
  # (hopefully code) inside the
  # user's program file as a 'sub'
  sub _insert_code_in_file {
      my ($command_name, $code_text) = @_;
  
      my $sub =<<"EOSUB";
  sub $command_name {
  $code_text
  }
  EOSUB
  
      # tidy up the code, if Perl::Tidy is available
      eval "use Perl::Tidy ()";
      if (! $@) {
          my $new_code = '';
          Perl::Tidy::perltidy( argv => '', source => \$sub, destination => \$new_code );
          $sub = $new_code;
      }
  
  #TODO: flock
  #    eval {
  #        use 'Fcntl qw(:flock)';
  #    }
  #    if ($@) {
  #        carp 'Could not load file locking module';
  #    }
  
      #TODO: I really should be using PPI
      #if the user has it installed...
      #or at least a decent parser
      open my $fh, '+<', $0
          or croak "error updating file $0: $!\n";
  
  #    flock($fh, LOCK_EX) or carp "could not lock file $0: $!\n";
  
      my @file = <$fh>;
      _insert_code_into_array(\@file, $sub);
  
      # TODO: only change the file if
      # it's eval'd without errors
      seek ($fh, 0, 0) or croak "error seeking file $0: $!\n";
      print $fh @file or croak "error writing to file $0: $!\n";
      truncate($fh, tell($fh)) or croak "error truncating file $0: $!\n";
  
      close $fh;
  }
  
  
  sub _insert_code_into_array {
      my ($file_array_ref, $sub) = @_;
      my $changed = 0;
  
      $sub = "\n\n" . $sub . "\n\n";
  
      my $line_id = 0;
      while ( $file_array_ref->[$line_id] ) {
  
          # this is a very rudimentary parser. It assumes a simple
          # vanilla application as shown in the main example, and
          # tries to include the given subroutine just after the
          # App::Rad->run(); call.
          next unless $file_array_ref->[$line_id] =~ /App::Rad->run/;
  
          # now we add the sub (hopefully in the right place)
          splice (@{$file_array_ref}, $line_id + 1, 0, $sub);
          $changed = 1;
          last;
      }
      continue {
          $line_id++;
      }
      if ( not $changed ) {
          croak "error finding 'App::Rad->run' call. $0 does not seem a valid App::Rad application.\n";
      }
  }
  
  
  # deparses one-liner into a working subroutine code
  sub _deparse {
  
      my $arg_ref = shift;
  
      # create array of perl command-line 
      # parameters passed to this one-liner
      my @perl_args = ();
      while ( $arg_ref->[0] =~ m/^-/o ) {
          push @perl_args, (shift @{$arg_ref});
      }
  
      #TODO: I don't know if "O" and
      # "B::Deparse" can actually run the same way as
      # a module as it does via -MO=Deparse.
      # and while I can't figure out how to use B::Deparse
      # to do exactly what it does via 'compile', I should
      # at least catch the stderr buffer from qx via 
      # IPC::Cmd's run(), but that's another TODO
      my $deparse = join ' ', @perl_args;
      my $code = $arg_ref->[0];
      my $body = qx{perl -MO=Deparse $deparse '$code'};
      return $body;
  }
  
  
  # tries to adjust a subroutine into
  # App::Rad's API for commands
  sub _sanitize {
      my $code = shift;
  
      # turns BEGIN variables into local() ones
      $code =~ s{(?:local\s*\(?\s*)?(\$\^I|\$/|\$\\)}
                {local ($1)}g;
  
      # and then we just strip any BEGIN blocks
      $code =~ s{BEGIN\s*\{\s*(.+)\s*\}\s*$}
                {$1}mg;
  
      my $codeprefix =<<'EOCODE';
  my $c = shift;
  
  EOCODE
      $code = $codeprefix . $code;
  
      return $code;
  }
  
  
  # includes a one-liner as a command.
  # TODO: don't let the user include
  # a control function!!!!
  sub include {
      my $c = shift;
  
      my @args = @ARGV;
  
      if( @args < 3 ) {
          return "Sintax: $0 include [name] -perl_params 'code'.\n";
      }
  
      # figure out the name of
      # the command to insert.
      # Either the user chose it already
      # or we choose it for the user
      my $command_name = '';
      if ( $args[0] !~ m/^-/o ) {
          $command_name = shift @args;
  
          # don't let the user add a command
          # that already exists
          if ( $c->is_command($command_name) ) {
              return "Command '$command_name' already exists. Please remove it first with '$0 exclude $command_name";
          }
      }
      else {
          $command_name = $c->create_command_name();
      }
      $c->debug("including command '$command_name'...");
  
      my $code_text = _get_oneliner_code(\@args);
  
      _insert_code_in_file($command_name, $code_text);
  
      # turns code string into coderef so we
      # can register it (just in case the user
      # needs to run it right away)
      my $code_ref = sub { eval $code_text};
      $c->register($command_name, $code_ref);
  
      return; 
  }
  
  42;
  __END__
  =head1 NAME
  
  App::Rad::Include - 'include' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.01
  
  =head1 SYNOPSIS
  
  'include' is an opt-in command for you App::Rad programs (myapp.pl):
  
      use App::Rad qw(include);  # add the 'include' command
      App::Rad->run();
      
  and now you can turn your one-liners (e.g:)
  
      [user@host]$ perl -i -pe 's/\r//' file.txt
  
  into nice scalable commands, simply replacing 'perl' for 'yourapp include <NAME>'
  
      [user@host]$ myapp.pl include dos2unix -i -pe 's/\r//'
      
  and there you go, a brand new 'dos2unix' command:
  
      [user@host]$ myapp.pl dos2unix file.txt
  
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately. Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 include
  
  Translates perl one-liner into self-contained command (subroutine) and adds it to your App::Rad program.
  
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * O, which is core in Perl 5.8.
  
  =item * B::Deparse, also core in 5.8.
  
  =item * Perl::Tidy (optional)
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 ACKNOWLEDGEMENTS
  
  The one-liner conversion and beautification was *much* easened because of the nice C<< O >> , C<< B::Deparse >> and C<< Perl::Tidy >> modules. So many thanks to Malcolm Beattie, Nicholas Clark, Stephen McCamant, Steve Hancock, and everyone that helped those projects.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_INCLUDE

$fatpacked{"App/Rad/Plugin/MoreHelp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_PLUGIN_MOREHELP';
  package App::Rad::Plugin::MoreHelp;
  use strict;
  use warnings;
  
  our $VERSION = '0.0001'; # VERSION
  
  sub more_help {
      my ($c, $msg) = @_;
      $c->register(help => sub { App::Rad::Help::help($c) . "\n$msg" },
          'show syntax and available commands');
  }
  
  # ABSTRACT: App::Rad plugin for providing extra help info.
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Rad::Plugin::MoreHelp - App::Rad plugin for providing extra help info.
  
  =head1 VERSION
  
  version 0.0001
  
  =head1 SYNOPSIS
  
      use App::Rad qw(MoreHelp);
  
      sub setup {
          my $c = shift;
          $c->more_help('This string gets appended to the main help message.');
      }
  
      App::Rad->run();
  
  =head1 DESCRIPTION
  
  This is an L<App::Rad> plugin for providing extra help info.
  It provides a C<more_help> method which can be used to provide extra info
  that will be appended to to bottom of the help message.
  
  =head1 METHODS
  
  =head2 more_help
  
      $c->more_help('This string gets appended to the help message.');
  
  =head1 AUTHOR
  
  Naveed Massjouni <naveedm9@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Naveed Massjouni.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_RAD_PLUGIN_MOREHELP

$fatpacked{"Config/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_TINY';
  package Config::Tiny;
  
  # If you thought Config::Simple was small...
  
  use strict;
  our $VERSION = '2.20'; # Also change version # in t/02.main.t.
  BEGIN {
  	require 5.008001;
  	$Config::Tiny::errstr  = '';
  }
  
  # Create an empty object
  sub new { bless {}, shift }
  
  # Create an object from a file
  sub read {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $file  = shift or return $class->_error('No file name provided');
  
  	# Slurp in the file.
  
  	my $encoding = shift;
  	$encoding    = $encoding ? "<:$encoding" : '<';
  	local $/     = undef;
  
  	open( CFG, $encoding, $file ) or return $class->_error( "Failed to open file '$file' for reading: $!" );
  	my $contents = <CFG>;
  	close( CFG );
  
  	return $class -> _error("Reading from '$file' returned undef") if (! defined $contents);
  
  	return $class->read_string( $contents );
  }
  
  # Create an object from a string
  sub read_string {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $self  = bless {}, $class;
  	return undef unless defined $_[0];
  
  	# Parse the file
  	my $ns      = '_';
  	my $counter = 0;
  	foreach ( split /(?:\015{1,2}\012|\015|\012)/, shift ) {
  		$counter++;
  
  		# Skip comments and empty lines
  		next if /^\s*(?:\#|\;|$)/;
  
  		# Remove inline comments
  		s/\s\;\s.+$//g;
  
  		# Handle section headers
  		if ( /^\s*\[\s*(.+?)\s*\]\s*$/ ) {
  			# Create the sub-hash if it doesn't exist.
  			# Without this sections without keys will not
  			# appear at all in the completed struct.
  			$self->{$ns = $1} ||= {};
  			next;
  		}
  
  		# Handle properties
  		if ( /^\s*([^=]+?)\s*=\s*(.*?)\s*$/ ) {
  			$self->{$ns}->{$1} = $2;
  			next;
  		}
  
  		return $self->_error( "Syntax error at line $counter: '$_'" );
  	}
  
  	$self;
  }
  
  # Save an object to a file
  sub write {
  	my $self     = shift;
  	my $file     = shift or return $self->_error('No file name provided');
  	my $encoding = shift;
  	$encoding    = $encoding ? ">:$encoding" : '>';
  
  	# Write it to the file
  	my $string = $self->write_string;
  	return undef unless defined $string;
  	open( CFG, $encoding, $file ) or return $self->_error(
  		"Failed to open file '$file' for writing: $!"
  		);
  	print CFG $string;
  	close CFG;
  
  	return 1;
  }
  
  # Save an object to a string
  sub write_string {
  	my $self = shift;
  
  	my $contents = '';
  	foreach my $section ( sort { (($b eq '_') <=> ($a eq '_')) || ($a cmp $b) } keys %$self ) {
  		# Check for several known-bad situations with the section
  		# 1. Leading whitespace
  		# 2. Trailing whitespace
  		# 3. Newlines in section name
  		return $self->_error(
  			"Illegal whitespace in section name '$section'"
  		) if $section =~ /(?:^\s|\n|\s$)/s;
  		my $block = $self->{$section};
  		$contents .= "\n" if length $contents;
  		$contents .= "[$section]\n" unless $section eq '_';
  		foreach my $property ( sort keys %$block ) {
  			return $self->_error(
  				"Illegal newlines in property '$section.$property'"
  			) if $block->{$property} =~ /(?:\012|\015)/s;
  			$contents .= "$property=$block->{$property}\n";
  		}
  	}
  
  	$contents;
  }
  
  # Error handling
  sub errstr { $Config::Tiny::errstr }
  sub _error { $Config::Tiny::errstr = $_[1]; undef }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Config::Tiny - Read/Write .ini style files with as little code as possible
  
  =head1 SYNOPSIS
  
  	# In your configuration file
  	rootproperty=blah
  
  	[section]
  	one=twp
  	three= four
  	Foo =Bar
  	empty=
  
  	# In your program
  	use Config::Tiny;
  
  	# Create a config
  	my $Config = Config::Tiny->new;
  
  	# Open the config
  	$Config = Config::Tiny->read( 'file.conf' );
  	$Config = Config::Tiny->read( 'file.conf', 'utf8' ); # Neither ':' nor '<:' prefix!
  	$Config = Config::Tiny->read( 'file.conf', 'encoding(iso-8859-1)');
  
  	# Reading properties
  	my $rootproperty = $Config->{_}->{rootproperty};
  	my $one = $Config->{section}->{one};
  	my $Foo = $Config->{section}->{Foo};
  
  	# Changing data
  	$Config->{newsection} = { this => 'that' }; # Add a section
  	$Config->{section}->{Foo} = 'Not Bar!';     # Change a value
  	delete $Config->{_};                        # Delete a value or section
  
  	# Save a config
  	$Config->write( 'file.conf' );
  	$Config->write( 'file.conf', 'utf8' ); # Neither ':' nor '>:' prefix!
  
  	# Shortcuts
  	my($rootproperty) = $$Config{_}{rootproperty};
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  	my($config) = Config::Tiny -> read_string("[init]\nalpha=bet");
  	my($value)  = $$config{init}{alpha}; # $value is 'bet'.
  
  =head1 DESCRIPTION
  
  C<Config::Tiny> is a Perl class to read and write .ini style configuration
  files with as little code as possible, reducing load time and memory
  overhead.
  
  Most of the time it is accepted that Perl applications use a lot
  of memory and modules.
  
  The C<*::Tiny> family of modules is specifically intended to provide an ultralight alternative to the
  standard modules.
  
  This module is primarily for reading human written files, and anything we write shouldn't need to have
  documentation/comments. If you need something with more power move up to L<Config::Simple>, L<Config::General>
  or one of the many other C<Config::*> modules.
  
  Lastly, L<Config::Tiny> does B<not> preserve your comments, whitespace, or the order of your config file.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 CONFIGURATION FILE SYNTAX
  
  Files are the same format as for MS Windows C<*.ini> files. For example:
  
  	[section]
  	var1=value1
  	var2=value2
  
  If a property is outside of a section at the beginning of a file, it will
  be assigned to the C<"root section">, available at C<$Config-E<gt>{_}>.
  
  Lines starting with C<'#'> or C<';'> are considered comments and ignored,
  as are blank lines.
  
  When writing back to the config file, all comments, custom whitespace,
  and the ordering of your config file elements is discarded. If you need
  to keep the human elements of a config when writing back, upgrade to
  something better, this module is not for you.
  
  =head1 METHODS
  
  =head2 errstr()
  
  Returns a string representing the most recent error, or the empty string.
  
  You can also retrieve the error message from the C<$Config::Tiny::errstr> variable.
  
  =head2 new()
  
  The constructor C<new> creates and returns an empty C<Config::Tiny> object.
  
  =head2 read($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<read> constructor reads a config file, $filename, and returns a new
  C<Config::Tiny> object containing the properties in the file.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '<' or '<:'.
  
  Returns the object on success, or C<undef> on error.
  
  When C<read> fails, C<Config::Tiny> sets an error message internally
  you can recover via C<Config::Tiny-E<gt>errstr>. Although in B<some>
  cases a failed C<read> will also set the operating system error
  variable C<$!>, not all errors do and you should not rely on using
  the C<$!> variable.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 read_string($string)
  
  The C<read_string> method takes as argument the contents of a config file
  as a string and returns the C<Config::Tiny> object for it.
  
  =head2 write($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<write> method generates the file content for the properties, and
  writes it to disk to the filename specified.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '>' or '>:'.
  
  Returns true on success or C<undef> on error.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 write_string()
  
  Generates the file content for the object and returns it as a string.
  
  =head1 FAQ
  
  =head2 Why can't I put comments at the ends of lines?
  
  Because a line like:
  
  	key=value # A comment
  
  Sets key to 'value # A comment' :-(.
  
  This conforms to the syntax discussed in L</CONFIGURATION FILE SYNTAX>.
  
  =head2 Why can't I omit the '=' signs?
  
  E.g.:
  
  	[Things]
  	my =
  	list =
  	of =
  	things =
  
  Instead of:
  
  	[Things]
  	my
  	list
  	of
  	things
  
  Because the use of '=' signs is a type of mandatory documentation. It indicates that that section contains 4 items,
  and not 1 odd item split over 4 lines.
  
  =head2 Why do I have to assign the result of a method call to a variable?
  
  This question comes from RT#85386.
  
  Yes, the syntax may seem odd, but you don't have to call both new() and read_string().
  
  Try:
  
  	perl -MData::Dumper -MConfig::Tiny -E 'my $c=Config::Tiny->read_string("one=s"); say Dumper $c'
  
  Or:
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  Or even, a bit ridiculously:
  
  	my($value) = ${Config::Tiny -> read_string('alpha=bet')}{_}{alpha}; # $value is 'bet'.
  
  =head1 CAVEATS
  
  =head2 Unsupported Section Headers
  
  Some edge cases in section headers are not supported, and additionally may not
  be detected when writing the config file.
  
  Specifically, section headers with leading whitespace, trailing whitespace,
  or newlines anywhere in the section header, will not be written correctly
  to the file and may cause file corruption.
  
  =head2 Setting an option more than once
  
  C<Config::Tiny> will only recognize the first time an option is set in a
  config file. Any further attempts to set the same option later in the config
  file are ignored.
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Maintanence from V 2.15: Ron Savage L<http://savage.net.au/>.
  
  =head1 ACKNOWLEGEMENTS
  
  Thanks to Sherzod Ruzmetov E<lt>sherzodr@cpan.orgE<gt> for
  L<Config::Simple>, which inspired this module by being not quite
  "simple" enough for me :).
  
  =head1 SEE ALSO
  
  See, amongst many: L<Config::Simple> and L<Config::General>.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 COPYRIGHT
  
  Copyright 2002 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
CONFIG_TINY

$fatpacked{"Data/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_COMPARE';
  # Data::Compare - compare perl data structures
  # Author: Fabien Tassin <fta@sofaraway.org>
  # updated by David Cantrell <david@cantrell.org.uk>
  # Copyright 1999-2001 Fabien Tassin <fta@sofaraway.org>
  # portions Copyright 2003 - 2013 David Cantrell
  
  package Data::Compare;
  
  use strict;
  use warnings;
  
  use vars qw(@ISA @EXPORT $VERSION $DEBUG %been_there);
  use Exporter;
  use Carp;
  use Scalar::Util qw(tainted);
  use File::Find::Rule;
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(Compare);
  $VERSION = 1.24;
  $DEBUG   = $ENV{PERL_DATA_COMPARE_DEBUG} || 0;
  
  my %handler;
  
  use Cwd;
  
  sub import {
    register_plugins() unless tainted getcwd();
    __PACKAGE__->export_to_level(1, @EXPORT);
  }
  
  # finds and registers plugins
  sub register_plugins {
    foreach my $file (
      File::Find::Rule->file()->name('*.pm')->in(
        map { "$_/Data/Compare/Plugins" }
        grep { -d "$_/Data/Compare/Plugins" }
        @INC
      )
    ) {
      # all of this just to avoid loading the same plugin twice and
      # generating a pile of warnings. Grargh!
      $file =~ s!.*(Data/Compare/Plugins/.*)\.pm$!$1!;
      $file =~ s!/!::!g;
      # ignore badly named example from earlier version, oops
      next if($file eq 'Data::Compare::Plugins::Scalar-Properties');
      my $requires = eval "require $file";
      next if($requires eq '1'); # already loaded this plugin?
  
      # not an arrayref? bail
      if(ref($requires) ne 'ARRAY') {
        warn("$file isn't a valid Data::Compare plugin (didn't return arrayref)\n");
        return;
      }
      # coerce into arrayref of arrayrefs if necessary
      if(ref((@{$requires})[0]) ne 'ARRAY') { $requires = [$requires] }
  
      # register all the handlers
      foreach my $require (@{$requires}) {
        my($handler, $type1, $type2, $cruft) = reverse @{$require};
        $type2 = $type1 unless(defined($type2));
        ($type1, $type2) = sort($type1, $type2);
        if(!defined($type1) || ref($type1) ne '' || !defined($type2) || ref($type2) ne '') {
          warn("$file isn't a valid Data::Compare plugin (invalid type)\n");
        } elsif(defined($cruft)) {
          warn("$file isn't a valid Data::Compare plugin (extra data)\n");
        } elsif(ref($handler) ne 'CODE') {
          warn("$file isn't a valid Data::Compare plugin (no coderef)\n");
        } else {
          $handler{$type1}{$type2} = $handler;
        }
      }
    }
  }
  
  sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my $self = {};
    bless $self, $class;
    $self->{'x'} = shift;
    $self->{'y'} = shift;
    return $self;
  }
  
  sub Cmp {
    my $self = shift;
  
    croak "Usage: DataCompareObj->Cmp(x, y)" unless $#_ == 1 || $#_ == -1;
    my $x = shift || $self->{'x'};
    my $y = shift || $self->{'y'};
  
    return Compare($x, $y);
  }
  
  sub Compare {
    croak "Usage: Data::Compare::Compare(x, y, [opts])\n" unless $#_ == 1 || $#_ == 2;
  
    my $x = shift;
    my $y = shift;
    my $opts = shift || {};
    my($xparent, $xpos, $yparent, $ypos) = map {
      $opts->{$_} || ''
    } qw(xparent xpos yparent ypos);
  
    my $rval = '';
  
    if(!exists($opts->{recursion_detector})) {
      %been_there = ();
      $opts->{recursion_detector} = 0;
    }
    $opts->{recursion_detector}++;
  
    warn "Yaroo! deep recursion!\n" if($opts->{recursion_detector} == 99);
    
    if(
      (ref($x) && exists($been_there{"$x-$xpos-$xparent"}) && $been_there{"$x-$xpos-$xparent"} > 1) ||
      (ref($y) && exists($been_there{"$y-$ypos-$yparent"}) && $been_there{"$y-$ypos-$yparent"} > 1)
    ) {
      $opts->{recursion_detector}--;
      return 1; # we bail as soon as possible, so if we've *not* bailed and have got here, say we're OK and go to the next sub-structure
    } else {
      $been_there{"$x-$xpos-$xparent"}++ if(ref($x));
      $been_there{"$y-$ypos-$yparent"}++ if(ref($y));
  
      $opts->{ignore_hash_keys} = { map {
        ($_, 1)
      } @{$opts->{ignore_hash_keys}} } if(ref($opts->{ignore_hash_keys}) eq 'ARRAY');
  
      my $refx = ref $x;
      my $refy = ref $y;
  
      if(exists($handler{$refx}) && exists($handler{$refx}{$refy})) {
        $rval = &{$handler{$refx}{$refy}}($x, $y, $opts);
      } elsif(exists($handler{$refy}) && exists($handler{$refy}{$refx})) {
        $rval = &{$handler{$refy}{$refx}}($x, $y, $opts);
      }
  
      elsif(!$refx && !$refy) { # both are scalars
        if(defined $x && defined $y) { # both are defined
          $rval = $x eq $y;
        } else { $rval = !(defined $x || defined $y); }
      }
      elsif ($refx ne $refy) { # not the same type
        $rval = 0;
      }
      elsif ($x == $y) { # exactly the same reference
        $rval = 1;
      }
      elsif ($refx eq 'SCALAR' || $refx eq 'REF') {
        $rval = Compare(${$x}, ${$y}, $opts);
      }
      elsif ($refx eq 'ARRAY') {
        if ($#{$x} == $#{$y}) { # same length
          my $i = -1;
          $rval = 1;
          for (@$x) {
            $i++;
            $rval = 0 unless Compare($x->[$i], $y->[$i], { %{$opts}, xparent => $x, xpos => $i, yparent => $y, ypos => $i});
          }
        }
        else {
          $rval = 0;
        }
      }
      elsif ($refx eq 'HASH') {
        my @kx = grep { !$opts->{ignore_hash_keys}->{$_} } keys %$x;
        my @ky = grep { !$opts->{ignore_hash_keys}->{$_} } keys %$y; # heh, KY
        $rval = 1;
        $rval = 0 unless scalar @kx == scalar @ky;
  
        for (@kx) {
          next unless defined $x->{$_} || defined $y->{$_};
          $rval = 0 unless defined $y->{$_} && Compare($x->{$_}, $y->{$_}, { %{$opts}, xparent => $x, xpos => $_, yparent => $y, ypos => $_});
        }
      }
      elsif($refx eq 'Regexp') {
        $rval = Compare($x.'', $y.'', $opts);
      }
      elsif ($refx eq 'CODE') {
        $rval = 0;
      }
      elsif ($refx eq 'GLOB') {
        $rval = 0;
      }
      else { # a package name (object blessed)
        my ($type) = "$x" =~ m/^$refx=(\S+)\(/;
        if ($type eq 'HASH') {
          my %x = %$x;
          my %y = %$y;
          $rval = Compare(\%x, \%y, { %{$opts}, xparent => $xparent, xpos => $xpos, yparent => $yparent, ypos => $ypos});
          $been_there{\%x."-$xpos-$xparent"}--; # decrement count for temp structures
          $been_there{\%y."-$ypos-$yparent"}--;
        }
        elsif ($type eq 'ARRAY') {
          my @x = @$x;
          my @y = @$y;
          $rval = Compare(\@x, \@y, { %{$opts}, xparent => $xparent, xpos => $xpos, yparent => $yparent, ypos => $ypos});
          $been_there{\@x."-$xpos-$xparent"}--;
          $been_there{\@y."-$ypos-$yparent"}--;
        }
        elsif ($type eq 'SCALAR' || $type eq 'REF') {
          my $x = ${$x};
          my $y = ${$y};
          $rval = Compare($x, $y, $opts);
          # $been_there{\$x}--;
          # $been_there{\$y}--;
        }
        elsif ($type eq 'GLOB') {
          $rval = 0;
        }
        elsif ($type eq 'CODE') {
          $rval = 0;
        }
        else {
          croak "Can't handle $type type.";
          $rval = 0;
        }
      }
    }
    $opts->{recursion_detector}--;
    return $rval;
  }
  
  sub plugins {
    return { map { (($_ eq '') ? '[scalar]' : $_, [map { $_ eq '' ? '[scalar]' : $_ } keys %{$handler{$_}}]) } keys %handler };
  }
  
  sub plugins_printable {
    my $r = "The following comparisons are available through plugins\n\n";
    foreach my $key (sort keys %handler) {
      foreach(sort keys %{$handler{$key}}) {
        $r .= join(":\t", map { $_ eq '' ? '[scalar]' : $_ } ($key, $_))."\n";
      }
    }
    return $r;
  }
  
  1;
  
  =head1 NAME
  
  Data::Compare - compare perl data structures
  
  =head1 SYNOPSIS
  
      use Data::Compare;
  
      my $h1 = { 'foo' => [ 'bar', 'baz' ],  'FOO' => [ 'one', 'two' ] };
      my $h2 = { 'foo' => [ 'bar', 'barf' ], 'FOO' => [ 'one', 'two' ] };
      my @a1 = ('one', 'two');
      my @a2 = ('bar', 'baz');
      my %v = ( 'FOO', \@a1, 'foo', \@a2 );
  
      # simple procedural interface
      print 'structures of $h1 and \%v are ',
        Compare($h1, \%v) ? "" : "not ", "identical.\n";
  
      print 'structures of $h1 and $h2 are ',
        Compare($h1, $h2, { ignore_hash_keys => [qw(foo)] }) ? '' : 'not ',
        "close enough to identical.\n";
  
      # OO usage
      my $c = new Data::Compare($h1, \%v);
      print 'structures of $h1 and \%v are ',
        $c->Cmp ? "" : "not ", "identical.\n";
      # or
      my $c = new Data::Compare;
      print 'structures of $h and \%v are ',
        $c->Cmp($h1, \%v) ? "" : "not ", "identical.\n";
  
  =head1 DESCRIPTION
  
  Compare two perl data structures recursively. Returns 0 if the
  structures differ, else returns 1.
  
  A few data types are treated as special cases:
  
  =over 4
  
  =item Scalar::Properties objects
  
  This has been moved into a plugin, although functionality remains the
  same as with the previous version.  Full documentation is in
  L<Data::Compare::Plugins::Scalar::Properties>.
  
  =item Compiled regular expressions, eg qr/foo/
  
  These are stringified before comparison, so the following will match:
  
      $r = qr/abc/i;
      $s = qr/abc/i;
      Compare($r, $s);
  
  and the following won't, despite them matching *exactly* the same text:
  
      $r = qr/abc/i;
      $s = qr/[aA][bB][cC]/;
      Compare($r, $s);
  
  Sorry, that's the best we can do.
  
  =item CODE and GLOB references
  
  These are assumed not to match unless the references are identical - ie,
  both are references to the same thing.
  
  =back
  
  You may also customise how we compare structures by supplying options in
  a hashref as a third parameter to the C<Compare()> function.  This is not
  yet available through the OO-ish interface.  These options will be in
  force for the *whole* of your comparison, so will apply to structures
  that are lurking deep down in your data as well as at the top level, so
  beware!
  
  =over 4
  
  =item ignore_hash_keys
  
  an arrayref of strings. When comparing two hashes, any keys mentioned in
  this list will be ignored.
  
  =back
  
  =head1 CIRCULAR STRUCTURES
  
  Comparing a circular structure to itself returns true:
  
      $x = \$y;
      $y = \$x;
      Compare([$x, $y], [$x, $y]);
  
  And on a sort-of-related note, if you try to compare insanely deeply nested
  structures, the module will spit a warning.  For this to affect you, you need to go
  around a hundred levels deep though, and if you do that you have bigger
  problems which I can't help you with ;-)
  
  =head1 PLUGINS
  
  The module takes plug-ins so you can provide specialised routines for
  comparing your own objects and data-types.  For details see
  L<Data::Compare::Plugins>.
  
  Plugins are *not* available when running in "taint" mode.  You may
  also make it not load plugins by providing an empty list as the
  argument to import() - ie, by doing this:
  
      use Data::Compare ();
  
  A couple of functions are provided to examine what goodies have been
  made available through plugins:
  
  =over 4
  
  =item plugins
  
  Returns a structure (a hash ref) describing all the comparisons made
  available through plugins.
  This function is *not* exported, so should be called as Data::Compare::plugins().
  It takes no parameters.
  
  =item plugins_printable
  
  Returns formatted text
  
  =back
  
  =head1 EXPORTS
  
  For historical reasons, the Compare() function is exported.  If you
  don't want this, then pass an empty list to import() as explained
  under PLUGINS.  If you want no export but do want plugins, then pass
  the empty list, and then call the register_plugins class method:
  
      use Data::Compare ();
      Data::Compare->register_plugins;
  
  or you could call it as a function if that floats your boat.
  
  =head1 SOURCE CODE REPOSITORY
  
  L<git://github.com/DrHyde/perl-modules-Data-Compare.git>
  
  =head1 BUGS
  
  Plugin support is not quite finished (see the TODO file for details) but
  is usable.  The missing bits are bells and whistles rather than core
  functionality.
  
  Please report any other bugs either by email to David Cantrell (see below
  for address) or using rt.cpan.org:
  
  L<https://rt.cpan.org/Ticket/Create.html?Queue=Data-Compare>
  
  =head1 AUTHOR
  
  Fabien Tassin E<lt>fta@sofaraway.orgE<gt>
  
  Portions by David Cantrell E<lt>david@cantrell.org.ukE<gt>
  
  =head1 COPYRIGHT and LICENCE
  
  Copyright (c) 1999-2001 Fabien Tassin. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Some parts copyright 2003 - 2013 David Cantrell.
  
  Seeing that Fabien seems to have disappeared, David Cantrell has become
  a co-maintainer so he can apply needed patches.  The licence, of course,
  remains the same.  As the "perl licence" is "Artistic or GPL, your choice",
  you can find them as the files ARTISTIC.txt and GPL2.txt in the
  distribution.
  
  =head1 SEE ALSO
  
  perl(1), perlref(1)
  
  =cut
DATA_COMPARE

$fatpacked{"Data/Compare/Plugins/Scalar/Properties.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_COMPARE_PLUGINS_SCALAR_PROPERTIES';
  package Data::Compare::Plugins::Scalar::Properties;
  
  use strict;
  use vars qw($VERSION);
  use Data::Compare;
  
  $VERSION = 1.0;
  
  sub register {
      return [
          ['Scalar::Properties', \&sp_scalar_compare],
          ['', 'Scalar::Properties', \&sp_scalar_compare],
      ];
  }
  
  # note that when S::Ps are involved we can't use Data::Compare's default
  # Compare function, so we use eq to check that values are the same.  But
  # we *do* use D::C::Compare whenever possible.
  
  # Compare a S::P and a scalar, or if we figure out that we've got two
  # S::Ps, call sp_sp_compare instead
  
  sub sp_scalar_compare {
      my($scalar, $sp) = @_;
  
      # we don't care what order the two params are, so swap if necessary
      ($scalar, $sp) = ($sp, $scalar) if(ref($scalar));
  
      # got two S::Ps?
      return sp_sp_compare($scalar, $sp) if(ref($scalar));
  
      # we've really got a scalar and an S::P, so just compare values
      return 1 if($scalar eq $sp);
      return 0;
  }
  
  # Compare two S::Ps
  
  sub sp_sp_compare {
      my($sp1, $sp2) = @_;
  
      # first check the values
      return 0 unless($sp1 eq $sp2);
      
      # now check that we have all the same properties
      return 0 unless(Data::Compare::Compare([sort $sp1->get_props()], [sort $sp2->get_props()]));
  
      # and that all properties have the same values
      return 0 if(
          grep { !Data::Compare::Compare(eval "\$sp1->$_()", eval "\$sp2->$_()") } $sp1->get_props()
      );
  
      # if we get here, all is tickety-boo
      return 1;
  }
  
  register();
  
  =head1 NAME
  
  Data::Compare::Plugin::Scalar::Properties - plugin for Data::Compare to
  handle Scalar::Properties objects.
  
  =head1 DESCRIPTION
  
  Enables Data::Compare to Do The Right Thing for Scalar::Properties
  objects.
  
  =over 4
  
  =item comparing a Scalar::Properties object and an ordinary scalar
  
  If you compare
  a scalar and a Scalar::Properties, then they will be considered the same
  if the two values are the same, regardless of the presence of properties.
  
  =item comparing two Scalar::Properties objects
  
  If you compare two Scalar::Properties objects, then they will only be
  considered the same if the values and the properties match.
  
  =back
  
  =head1 AUTHOR
  
  Copyright (c) 2004 David Cantrell. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Data::Compare>
  
  =cut
DATA_COMPARE_PLUGINS_SCALAR_PROPERTIES

$fatpacked{"Data/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_TABLE';
  package Data::Table;
  BEGIN { die "Your perl version is old, see README for instructions" if $] < 5.005; }
  
  use strict;
  use vars qw($VERSION %DEFAULTS);
  use Carp;
  use Data::Dumper;
  
  $VERSION = '1.70';
  %DEFAULTS = (
    "CSV_DELIMITER"=>',', # controls how to read/write CSV file
    "CSV_QUALIFIER"=>'"',
    "OS"=>0,
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    # this controls how to read and write CSV/TSV file
    "ENCODING"=>'UTF-8'
    # default encoding for fromFile, fromCSV, fromTSV
  );
  %Data::Table::TSV_ESC = ( '0'=>"\0", 'n'=>"\n", 't'=>"\t", 'r'=>"\r", 'b'=>"\b",
                "'"=>"'", '"'=>"\"", '\\'=>"\\" );
  %Data::Table::TSV_ENC = ( "\0"=>'0', "\n"=>'n', "\t"=>'t', "\r"=>'r', "\b"=>'b',
                "'"=>"'", "\""=>'"', "\\"=>'\\' );
  use constant ROW_BASED => 0;
  use constant COL_BASED => 1;
  use constant NUMBER => 0;
  use constant STRING => 1;
  use constant ASC => 0;
  use constant DESC => 1;
  use constant INNER_JOIN => 0;
  use constant LEFT_JOIN => 1;
  use constant RIGHT_JOIN => 2;
  use constant FULL_JOIN => 3;
  use constant OS_UNIX => 0;
  use constant OS_PC => 1;
  use constant OS_MAC => 2;
  
  sub new {
    my ($pkg, $data, $header, $type, $enforceCheck) = @_;
    my $class = ref($pkg) || $pkg;
    $type = 0 unless defined($type); 
    $header=[] unless defined($header);
    $data=[] unless defined($data);
    $enforceCheck = 1 unless defined($enforceCheck);
    confess "new Data::Table: Size of data does not match header\n"
      if (($type && (scalar @$data) && $#{$data} != $#{$header}) ||
          (!$type && (scalar @$data) && $#{$data->[0]} != $#{$header}));
    my $colHash = checkHeader($header);
    if ($enforceCheck && scalar @$data > 0) {
      my $size=scalar @{$data->[0]};
      for (my $j =1; $j<scalar @$data; $j++) {
        confess "Inconsistent array size at data[$j]" unless (scalar @{$data->[$j]} == $size);
      }
    } elsif (scalar @$data == 0) {
      $type = 0;
    }
    my $self={ data=>$data, header=>$header, type=>$type, colHash=>$colHash, OK=>[], MATCH=>[]};
    return bless $self, $class;
  }
  
  sub checkHeader {
    my $header = shift;
    my $colHash = {};
    for (my $i = 0; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      #warn "Column name: $elm at column ".($i+1)." is an integer, using an integer column name will mask the corresponding column index!" if ($elm =~ /^\d+$/);
      confess "Undefined column name (empty or all space) at column ".($i+1) unless $elm;
      #confess "Header name ".$colHash->{$elm}." appears more than once" if defined($colHash->{$elm});
      if (defined($colHash->{$elm})) {
        confess "Header name ($elm) appears more than once: in column ".($colHash->{$elm}+1)." and column ".($i+1).".";
      }
      $colHash->{$elm} = $i;
    }
    return $colHash;
  }
  
  # translate a column name into its position in the header
  # (also in column-based table)
  sub colIndex {
    my ($self, $colID) = @_;
    return $self->{colHash}->{$colID} if exists $self->{colHash}->{$colID};
    return $colID if $colID =~ /^\d+$/;
    return -1;
    #if ($colID =~ /\D/) {
    #  my $i = $self->{colHash}->{$colID};
    #  return -1 unless defined($i);
    #  return $i;
    #}
    #return $colID; # assume an index already
  }
  
  sub hasCol {
    my ($self, $col) = @_;
    return $self->colIndex($col) >= 0;
  }
  
  sub nofCol {
    my $self = shift;
    return scalar @{$self->{header}};
  }
  
  sub isEmpty {
    my $self  = shift;
    return $self->nofCol == 0;
  }
  
  sub nofRow {
    my $self = shift;
    return 0 if (scalar @{$self->{data}} == 0);
    return ($self->{type})?
      scalar @{$self->{data}->[0]} : scalar @{$self->{data}};
  }
  
  sub lastRow {
    my $self = shift;
    return $self->nofRow - 1;
  }
  
  sub lastCol {
    my $self = shift;
    return $self->nofCol - 1;
  }
  
  sub colName {
    my ($self, $colNumericIndex) = @_;
    return ($self->header())[$colNumericIndex];
  }
  
  sub iterator {
    my ($self, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{reverse} = 0 unless exists $arg{reverse};
    my $current_row = $arg{reverse} ? $self->lastRow : 0;
  
    return sub {
      my $rowIdx = shift;
      if (defined $rowIdx) { # return row index for previously returned record
        my $prevRow = $arg{reverse} ? $current_row+1 : $current_row-1;
        return ($prevRow<0 or $prevRow > $self->nofRow-1)? undef: $prevRow;
      }
      return undef if $current_row < 0 or $current_row > $self->nofRow - 1;
      my $oldRow = $current_row;
      $arg{reverse} ? $current_row-- : $current_row++;
      return $self->rowHashRef($oldRow);
    }
  }
  
  # still need to consider quotes and comma in string
  # need to get csv specification
  sub csvEscape {
    my ($s, $arg_ref) = @_;
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    $delimiter = $arg_ref->{'delimiter'} if (defined($arg_ref) && defined($arg_ref->{'delimiter'}));
    $qualifier = $arg_ref->{'qualifier'} if (defined($arg_ref) && defined($arg_ref->{'qualifier'}));
    return '' unless defined($s);
    my $qualifier2 = $qualifier;
    $qualifier2 = substr($qualifier, 1, 1) if length($qualifier)>1; # in case qualifier is a special symbol for regular expression
    $s =~ s/$qualifier/$qualifier2$qualifier2/g;
    if ($s =~ /[$qualifier$delimiter\r\n]/) { return "$qualifier2$s$qualifier2"; }
    return $s;
  }
  
  sub tsvEscape {
    my $s = shift;
    #my %ESC = ( "\0"=>'0', "\n"=>'n', "\t"=>'t', "\r"=>'r', "\b"=>'b',
    #            "'"=>"'", "\""=>'"', "\\"=>'\\' );
    ## what about \f? MySQL treats \f as f.
    return "\\N" unless defined($s);
    $s =~ s/([\0\\\b\r\n\t"'])/\\$Data::Table::TSV_ENC{$1}/g;
    return $s;
  }
  
  # output table in CSV format
  sub csv {
    my ($self, $header, $arg_ref)=@_;
    my ($status, @t);
    my $s = '';
    my ($OS, $fileName_or_handler) = ($Data::Table::DEFAULTS{OS}, undef);
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    if (defined($arg_ref)) {
      $delimiter = $arg_ref->{'delimiter'} if defined($arg_ref->{'delimiter'});
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $fileName_or_handler = $arg_ref->{'file'} if defined($arg_ref->{'file'});
    }
    my $delimiter2 = $delimiter; $delimiter2 = substr($delimiter, 1, 1) if length($delimiter)>1;
    my $endl = ($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    $header=1 unless defined($header);
    $s=join($delimiter2, map {csvEscape($_, {delimiter=>$delimiter, qualifier=>$qualifier})} @{$self->{header}}) . $endl if $header;
  ######  $self->rotate if $self->{type};
    if ($self->{data}) {
      $self->rotate() if ($self->{type});
      my $data=$self->{data};
      for (my $i=0; $i<=$#{$data}; $i++) {
        $s .= join($delimiter2, map {csvEscape($_, {delimiter=>$delimiter, qualifier=>$qualifier})} @{$data->[$i]}) . $endl;
      }
    }
    if (defined($fileName_or_handler)) {
      my $OUT;
      my $isFileHandler = ref($fileName_or_handler) ne '';
      if ($isFileHandler) {
        $OUT = $fileName_or_handler;
      } else {
        open($OUT, "> $fileName_or_handler") or confess "Cannot open $fileName_or_handler to write.\n";
        binmode $OUT;
      }
      print $OUT $s;
      close($OUT) unless $isFileHandler;
    }
    return $s;
  }
  
  # output table in TSV format
  sub tsv {
    my ($self, $header, $arg_ref)=@_;
    my ($status, @t);
    my $s = '';
    my ($OS, $fileName_or_handler, $transform_element) = ($Data::Table::DEFAULTS{OS}, undef, 1);
    if (defined($arg_ref)) {
      $OS = $arg_ref->{'OS'} if (defined($arg_ref->{'OS'}));
      $fileName_or_handler = $arg_ref->{'file'} if (defined($arg_ref->{'file'}));
      $transform_element = $arg_ref->{'transform_element'} if (defined($arg_ref->{'transform_element'}));
    }
    my $endl = ($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    $header=1 unless defined($header);
    if ($header) {
      if ($transform_element) {
        $s=join("\t", map {tsvEscape($_)} @{$self->{header}}) . $endl;
      } else {
        $s=join("\t",@{$self->{header}}) . $endl;
      }
    }
  ######  $self->rotate if $self->{type};
    if ($self->{data}) {
      $self->rotate() if ($self->{type});
      my $data=$self->{data};
      for (my $i=0; $i<=$#{$data}; $i++) {
        if ($transform_element) {
          $s .= join("\t", map {tsvEscape($_)} @{$data->[$i]}) . $endl;
        } else {
          $s .= join("\t", @{$data->[$i]}) . $endl;
        }
      }
    }
    if (defined($fileName_or_handler)) {
      my $OUT;
      my $isFileHandler = ref($fileName_or_handler) ne '';
      if ($isFileHandler) {
        $OUT = $fileName_or_handler;
      } else {
        open($OUT, "> $fileName_or_handler") or confess "Cannot open $fileName_or_handler to write.\n";
        binmode $OUT;
      }
      print $OUT $s;
      close($OUT) unless $isFileHandler;;
    }
    return $s;
  }
  
  # output table in HTML format
  sub html {
    my ($self, $colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td, $portrait) = @_;
    my ($s, $s_tr, $s_td, $s_th) = ("", "tr", "", "th");
    my $key;
    $tag_tbl = { class => "data_table" } unless (ref $tag_tbl eq 'HASH');
    $tag_tr = {} unless (ref $tag_tr eq 'HASH');
    $tag_th = {} unless (ref $tag_th eq 'HASH');
    $tag_td = {} unless (ref $tag_td eq 'HASH');
    $portrait = 1 unless defined($portrait);
  
    $s = "<table";
    foreach $key (keys %$tag_tbl) {
      $s .= " $key=\"$tag_tbl->{$key}\"";
    }
    $s .= ">\n";
    $s .= "<thead>\n" if ($portrait);
    my $header=$self->{header};
    my $l_colorByClass = 0;
    my @BG_COLOR=("#D4D4BF","#ECECE4","#CCCC99");
    my @CELL_CLASSES=("data_table_odd","data_table_even","data_table_header");
    if (ref($colorArrayRef_or_classHashRef) eq "HASH") {
      $l_colorByClass = 1;
      $CELL_CLASSES[1]=$colorArrayRef_or_classHashRef->{even} if defined($colorArrayRef_or_classHashRef->{even});
      $CELL_CLASSES[0]=$colorArrayRef_or_classHashRef->{odd} if defined($colorArrayRef_or_classHashRef->{odd});
      $CELL_CLASSES[2]=$colorArrayRef_or_classHashRef->{header} if defined($colorArrayRef_or_classHashRef->{header});
    } elsif ((ref($colorArrayRef_or_classHashRef) eq "ARRAY") && (scalar @$colorArrayRef_or_classHashRef==3)) {
      @BG_COLOR=@$colorArrayRef_or_classHashRef;
    }
    foreach $key (keys %$tag_tr) {
      $s_tr .= " $key=\"$tag_tr->{$key}\"";
    }
    foreach $key (keys %$tag_th) {
      $s_th .= " $key=\"$tag_th->{$key}\"";
    }
    if ($portrait) {
      $s .= "<$s_tr ".($l_colorByClass? ("class=\"".$CELL_CLASSES[2]."\""):("bgcolor=\"".$BG_COLOR[2]."\""))."><$s_th>".
        join("</th><$s_th>", @$header) . "</th></tr>\n";
      $s .= "</thead>\n";
      $self->rotate() if $self->{type};
      my $data=$self->{data};
      $s .= "<tbody>\n";
      for (my $i=0; $i<=$#{$data}; $i++) {
        $s .= "<$s_tr ".($l_colorByClass? ("class=\"".$CELL_CLASSES[$i%2]."\""):("bgcolor=\"".$BG_COLOR[$i%2]."\"")).">";
        for (my $j=0; $j<=$#{$header}; $j++) {
          my $s_td = $tag_td->{$j} || $tag_td->{$header->[$j]};
          $s .= defined($s_td)? "<td $s_td>":"<td>";
          $s .= (defined($data->[$i][$j]) && $data->[$i][$j] ne '')?$data->[$i][$j]:"&nbsp;";
          $s .= "</td>";
        }
        $s .= "</tr>\n";
      }
      $s .= "</tbody>\n";
    } else {
      $self->rotate() unless $self->{type};
      my $data=$self->{data};
      for (my $i = 0; $i <= $#{$header}; $i++) {
        $s .= "<$s_tr><$s_th ".($l_colorByClass? ("class=\"".$CELL_CLASSES[2]."\""):("bgcolor=\"".$BG_COLOR[2]."\"")).">".
              $header->[$i] . "</th>";
        my $s_td = $tag_td->{$i} || $tag_td->{$header->[$i]};
        for (my $j=0; $j<=$#{$data->[0]}; $j++) {
          $s .= defined($s_td)? "<td $s_td":"<td";
          $s .= ($l_colorByClass?(" class=\"".$CELL_CLASSES[$j%2]."\""):(" bgcolor=\"".$BG_COLOR[$j%2]."\"")).">";
          $s .= (defined($data->[$i][$j]) && $data->[$i][$j] ne '')?$data->[$i][$j]:'&nbsp;';
          $s .= "</td>";
        }
        $s .= "</tr>\n";
      }
    }
    $s .= "</table>\n";
    return $s;
  }
  
  # output table in HTML format, with table orientation rotated,
  # so that each HTML table row is a column in the table
  # This is useful for a slim table (few columns but many rows)
  sub html2 {
    my ($self, $colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td) = @_;
    return $self->html($colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td, 0);
  }
  
  # apply a $fun to each elm in a col 
  # function only has access to one element per row
  sub colMap {
    my ($self, $colID, $fun) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    my $ref = $self->{data}->[$c];
    my @tmp = map {scalar $fun->($_)} @$ref;
    $self->{data}->[$c] = \@tmp;
    return 1;
  } 
  
  # apply a $fun to each row in the table
  # function has access to all elements in that row
  sub colsMap {
    my ($self, $fun) = @_;
    $self->rotate() if $self->{type};
    map {&$fun} @{$self->{data}};
    return 1;
  }
  
  sub addRow {
    my ($self, $rowRef, $rowIdx, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{addNewCol} = 0 unless exists $arg{addNewCol};
  
    my $numRow=$self->nofRow();
    my @t;
    my $myRowRef = $rowRef;
  
    if ($arg{addNewCol}) {
      if (ref $myRowRef eq 'HASH') {
        foreach my $key (keys %$myRowRef) {
          next if $self->colIndex($key) >= 0;
          my @col = (undef) x $self->nofRow;
          $self->addCol(\@col, $key);
        }
      } elsif (ref $myRowRef eq 'ARRAY') {
        for (my $i=$self->nofCol; $i< scalar @$myRowRef; $i++) {
          my @col = (undef) x $self->nofRow;
          $self->addCol(\@col, "col".($i+1));
        }
      }
    }
  
    if (ref $myRowRef eq 'HASH') {
      if ($self->isEmpty) {
        my $i = 0;
        foreach my $s (keys %$myRowRef) {
          push @{$self->{header}}, $s;
          $self->{colHash}->{$s} = $i++;
        }
      }
      my @one = ();
      my @header = $self->header;
      for (my $i=0; $i< scalar @header; $i++) {
        $one[$i] = $myRowRef->{$header[$i]};
      }
      $myRowRef = \@one;
    } elsif (ref $myRowRef eq 'ARRAY') {
      confess "addRow: size of added row does not match those in the table\n"
  	if scalar @$myRowRef != $self->nofCol();
    } else {
      confess "addRow: parameter rowRef has to be either an array_ref or a hash_ref\n";
    }
    $rowIdx=$numRow unless defined($rowIdx);
    return undef unless defined $self->checkNewRow($rowIdx);
    $self->rotate() if $self->{type};
    my $data=$self->{data};
    if ($rowIdx == 0) {
      unshift @$data, $myRowRef;
    } elsif ($rowIdx == $numRow) {
      push @$data, $myRowRef;
     } else {
      @t = splice @$data, $rowIdx;
      push @$data, $myRowRef, @t;
    }
    return 1;
  }
  
  sub delRow {
    my ($self, $rowIdx ) = @_;
    return undef unless defined $self->checkOldRow($rowIdx);
    $self->rotate() if $self->{type};
    my $data=$self->{data};
    my @dels=splice(@$data, $rowIdx, 1);
    return shift @dels;
  }                                                                               
  
  sub delRows {
    my ($self, $rowIdcsRef) = @_;
    my $rowIdx;
    $self->rotate() if $self->{type};
    my @dels = @{$self->{data}}[@$rowIdcsRef];
    my @indices = sort { $b <=> $a } @$rowIdcsRef;
    #my @dels=();
    foreach $rowIdx (@indices) {
      #push @dels, $self->delRow($rowIdx);
      $self->delRow($rowIdx);
    }
    return @dels;
  }   
  
  # append a column to the table, input is a referenceof_array
  
  sub addCol {
    my ($self, $colRef, $colName, $colIdx) = @_;
    my $numCol=$self->nofCol();
    my @t;
    if (!defined($colRef) || ref($colRef) eq '') {
      # fill the new column with $colRef as the default value
      my @col = ($colRef) x $self->nofRow;
      $colRef = \@col;
    } else {
      confess "addCol: size of added col does not match rows in the table\n" 
      if @$colRef != $self->nofRow() and $numCol > 0; 
    }
    $colIdx=$numCol unless defined($colIdx);
    return undef unless defined $self->checkNewCol($colIdx, $colName);
    $self->rotate() unless $self->{type};
    my $data=$self->{data};
    my $header=$self->{header};
    if ($colIdx == 0) {
      unshift @$header, $colName;
    } elsif ($colIdx == $numCol) {
      push @$header, $colName;
    } else {
      @t = splice @$header, $colIdx;
      push @$header, $colName, @t;
    }
  
    if ($colIdx == 0) {
      unshift @$data, $colRef;
    } elsif ($colIdx == $numCol) {
      push @$data, $colRef;
    } else {
      @t = splice @$data, $colIdx;
      push @$data, $colRef, @t;
    }
  
    for (my $i = 0; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      $self->{colHash}->{$elm} = $i;
    }
    return 1;
  }
  
  sub delCol {
    my ($self, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    my $header=$self->{header};
    my $name=$self->{header}->[$c];
    splice @$header, $c, 1;
    my $data=$self->{data};
    my @dels=splice @$data, $c, 1;
    delete $self->{colHash}->{$name};
    for (my $i = $c; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      $self->{colHash}->{$elm} = $i;
    }
    return shift @dels;
  }                                                                               
  
  sub delCols {
    my ($self, $colIDsRef) = @_;
    my $idx;
    my @indices = map { $self->colIndex($_) } @$colIDsRef;
    $self->rotate() unless $self->{type};
    my @dels = @{$self->{data}}[@indices];
    @indices = sort { $b <=> $a } @indices;
    #my @dels=();
    foreach my $colIdx (@indices) {
      $self->delCol($colIdx);
    }
    return @dels;
  }  
  
  
  sub rowRef {
    my ($self, $rowIdx) = @_;
    return undef unless defined $self->checkOldRow($rowIdx);
    $self->rotate if $self->{type};
    return $self->{data}->[$rowIdx];
  }
  
  sub rowRefs {
    my ($self, $rowIdcsRef) = @_;
    $self->rotate if $self->{type};
    return $self->{data} unless defined $rowIdcsRef;
    my @ones = ();
    my $rowIdx;
    foreach $rowIdx (@$rowIdcsRef) {
      push @ones, $self->rowRef($rowIdx);
    }
    return \@ones;
  }
  
  sub row {
    my ($self, $rowIdx) = @_;
    my $data = $self->{data};
    return undef unless defined $self->checkOldRow($rowIdx);
    if ($self->{type}) {
      my @one=(); 
      for (my $i = 0; $i < scalar @$data; $i++) {
        push @one, $data->[$i]->[$rowIdx];
      }
      return @one;
    } else {
      return @{$data->[$rowIdx]};
    }
  }
  
  sub rowHashRef {
    my ($self, $rowIdx) = @_;
    my $data = $self->{data};
    return undef unless defined $self->checkOldRow($rowIdx);
    my $header=$self->{header};
    my $one = {};
    for (my $i = 0; $i < scalar @$header; $i++) {
      $one->{$header->[$i]} = ($self->{type})?
        $self->{data}->[$i]->[$rowIdx]:$self->{data}->[$rowIdx]->[$i];
    }
    return $one;
  }
  
  sub colRef {
    my ($self, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    return $self->{data}->[$c];
  }
  
  sub colRefs {
    my ($self, $colIDsRef) = @_;
    $self->rotate unless $self->{type};
    return $self->{data} unless defined $colIDsRef;
    my @ones = ();
    my $colID;
    foreach $colID (@$colIDsRef) {
      push @ones, $self->colRef($colID);
    }
    return \@ones;
  }
  
  sub col {
    my ($self, $colID) = @_;
    my $data = $self->{data};
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    if (!$self->{type}) {
      my @one=();
      for (my $i = 0; $i < scalar @$data; $i++) {
        push @one, $data->[$i]->[$c];
      }
      return @one;
    } else {
      return () unless ref($data->[$c]) eq "ARRAY";
      return @{$data->[$c]};
    }
  }
  
  sub rename {
    my ($self, $colID, $name) = @_;
    my $oldName;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $oldName=$self->{header}->[$c];
    return if ($oldName eq $name);
    return undef unless defined $self->checkNewCol($c, $name);
    $self->{header}->[$c]=$name;
    $self->{colHash}->{$oldName}=undef;
    $self->{colHash}->{$name}=$c;
    return 1;
  }
  
  sub replace{
    my ($self, $oldColID, $newColRef, $newName) = @_;
    my $oldName;
    my $c=$self->checkOldCol($oldColID);
    return undef unless defined $c;
    $oldName=$self->{header}->[$c];
    $newName=$oldName unless defined($newName);
    unless ($oldName eq $newName) {
    	return undef unless defined $self->checkNewCol($c, $newName);
    }
    confess "New column size ".(scalar @$newColRef)." must be ".$self->nofRow() unless (scalar @$newColRef==$self->nofRow());
    $self->rename($c, $newName);
    $self->rotate() unless $self->{type};
    my $old=$self->{data}->[$c];
    $self->{data}->[$c]=$newColRef;
    return $old;
  }
  
  sub swap{
    my ($self, $colID1, $colID2) = @_;
    my $c1=$self->checkOldCol($colID1);
    return undef unless defined $c1;
    my $c2=$self->checkOldCol($colID2);
    return undef unless defined $c2;
    my $name1=$self->{header}->[$c1];
    my $name2=$self->{header}->[$c2];
  
    $self->{header}->[$c1]=$name2;
    $self->{header}->[$c2]=$name1;
    $self->{colHash}->{$name1}=$c2;
    $self->{colHash}->{$name2}=$c1;
    $self->rotate() unless $self->{type};
    my $data1=$self->{data}->[$c1];
    my $data2=$self->{data}->[$c2];
    $self->{data}->[$c1]=$data2;
    $self->{data}->[$c2]=$data1;
    return 1;
  }
  
  sub moveCol {
    my ($self, $colID, $colIdx, $newColName) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    confess "New column location out of bound!" unless ($colIdx >= 0 && $colIdx < $self->nofCol);
    return if $c == $colIdx;
    my $colName = $self->{header}->[$c];
    my $col = $self->delCol($colID);
    $self->addCol($col, $colName, $colIdx);
    $self->rename($colIdx, $newColName) if defined $newColName;
    return 1;
  }
  
  sub checkOldRow {
    my ($self, $rowIdx) = @_;
    my $maxIdx=$self->nofRow()-1;
    unless (defined $rowIdx) {
  	print STDERR " Invalid row index\n";
  	return undef;
    }
    if ($rowIdx<0 || $rowIdx>$maxIdx) {
  	print STDERR  "Row index out of range [0..$maxIdx]" ;
  	return undef;
    }
    return $rowIdx;
  }
  
  sub checkNewRow {
    my ($self, $rowIdx) = @_;
    my $maxIdx=$self->nofRow()-1;
    unless (defined $rowIdx) {
  	print STDERR "Invalid row index: $rowIdx \n";
  	return undef;
    } 
    $maxIdx+=1;
    if ($rowIdx<0 || $rowIdx>$maxIdx) {
    	print STDERR  "Row index out of range [0..$maxIdx]" ;
  	return undef;
    }
    return $rowIdx;
  }
  
  sub checkOldCol {
    my ($self, $colID) = @_;
    my $c=$self->colIndex($colID);
    if ($c < 0) {
    	print STDERR "Invalid column $colID";
  	return undef;
    } 
    return $c;
  }
  
  sub checkNewCol {
    my ($self, $colIdx, $colName) = @_;
    my $numCol=$self->nofCol();
    unless (defined $colIdx) { 
        	print STDERR "Invalid column index $colIdx";
        	return undef;
    }	
    if ($colIdx<0 || $colIdx>$numCol) {
        	print STDERR "Column index $colIdx out of range [0..$numCol]";
    	return undef;
    }	
    if (defined $self->{colHash}->{$colName} ) {
  	print STDERR "Column name $colName already exists" ;
  	return undef;
    }
    unless ($colName =~ /\D/) { 
      	print STDERR "Invalid column name $colName" ;
  	return undef;
    }
    return $colIdx;
  }
  
  sub elm {
    my ($self, $rowIdx, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    return undef unless defined $self->checkOldRow($rowIdx);
    return ($self->{type})?
      $self->{data}->[$c]->[$rowIdx]:
      $self->{data}->[$rowIdx]->[$c];
  }
  
  sub elmRef {
    my ($self, $rowIdx, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    return undef unless defined $self->checkOldRow($rowIdx);
    return ($self->{type})?
      \$self->{data}->[$c]->[$rowIdx]:
      \$self->{data}->[$rowIdx]->[$c];
  }
  
  sub setElm {
    my ($self, $rowIdx, $colID, $val) = @_;
    $rowIdx = [$rowIdx] if ref($rowIdx) eq '';
    $colID = [$colID] if ref($colID) eq '';
    foreach my $col (@$colID) {
      my $c=$self->checkOldCol($col);
      return undef unless defined $c;
      foreach my $row (@$rowIdx) {
        return undef unless defined $self->checkOldRow($row);
        if ($self->{type}) {
          $self->{data}->[$c]->[$row]=$val;
        } else {
          $self->{data}->[$row]->[$c]=$val;
        }
      }
    }
    return 1;
  }
  
  # convert the internal structure of a table between row-based and column-based
  sub rotate {
    my $self=shift;
    my $newdata=[];
    my $data=$self->{data};
    $self->{type} = ($self->{type})?0:1;
    if ($self->{type} && scalar @$data == 0) {
      for (my $i=0; $i < $self->nofCol; $i++) {
        $newdata->[$i] = [];
      }
    } else {
      for (my $i=$#{$data->[0]}; $i>=0; $i--) {
        for (my $j=$#{$data}; $j>=0;  $j--) {
          $newdata->[$i][$j]=$data->[$j][$i];
        }
      }
    }
    $self->{data}=$newdata;
    return 1;
  }
  
  sub header {
    my ($self, $header) = @_;
    unless (defined($header)) {
      return @{$self->{header}};
    } else {
      if (scalar @$header != scalar @{$self->{header}}) {
        confess "Header array should have size ".(scalar @{$self->{header}});
      } else {
        my $colHash = checkHeader($header);
        $self->{header} = $header;
        $self->{colHash} = $colHash;
      }
    }
  }
  
  sub type {
    my $self=shift;
    return $self->{type};
  }
  
  sub data {
    my $self=shift;
    return $self->{data};
  }
  
  #  $t->sort(colID1, type1, order1, colID2, type2, order2, ... );
  #  where
  #    colID is a column index (integer) or name (string),
  #    type is 0 for numerical and 1 for others
  #    order is 0 for ascending and 1 for descending
  #    Sorting is done with priority of colname1, colname2, ...
  
  sub sort_v0 {
    my $self = shift;
    my ($str, $i) = ("", 0);
    my @cols = ();
    while (scalar @_) {
      my $c = shift;
      my $col = $self->checkOldCol($c);
      return undef unless defined $col;
      push @cols, $col;
      my $op = '<=>';
      $op = 'cmp' if shift;  				# string 
      $str .=(shift)?  "(\$b->[$i] $op \$a->[$i]) || " :
        "(\$a->[$i] $op \$b->[$i]) || " ;
      $i++;
    }
    substr($str, -3) = "";  	# removes ||  from the end of $str
    $self->rotate() if $self->{type};
    # construct a pre-ordered array
    my $fun = sub { my ($cols, $data) = @_;
    		  my @ext;
    		  @ext = map {$data->[$_]} @$cols;
    		  push @ext, $data;
    		  return \@ext;
  		};
    my @preordered = map {&$fun(\@cols, $_)} @{$self->{data}};
    $self->{data} = [ map {$_->[$i]} eval "sort {$str} \@preordered;" ];
    return 1;
  } 
    
  sub sort {
      my $self = shift;
      my @cols = @_;
      confess "Parameters be in groups of three!\n" if ($#cols % 3 != 2);
      foreach (0 .. ($#cols/3)) {
        my $col = $self->checkOldCol($cols[$_*3]);
        return undef unless defined $col;
        $cols[$_*3]=$col;
      }
      my @subs=();
      for (my $i=0; $i<=$#cols; $i+=3) {
        my $mysub;
        if ($cols[$i+1] == 0) {
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $_[1] <=> $_[0]:1):(defined($_[0])?-1:0)} : sub {defined($_[1])?(defined($_[0])? $_[0] <=> $_[1]:-1):(defined($_[0])?1:0)});
        } elsif ($cols[$i+1] == 1) {
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $_[1] cmp $_[0]:1):(defined($_[0])?-1:0)} : sub {defined($_[1])?(defined($_[0])? $_[0] cmp $_[1]:-1):(defined($_[0])?1:0)});
        } elsif (ref $cols[$i+1] eq 'CODE') {
          my $predicate=$cols[$i+1];
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $predicate->($_[1],$_[0]) : 1): (defined($_[0])?-1:0)} : 
                                 sub {defined($_[1])?(defined($_[0])? $predicate->($_[0],$_[1]) : -1): (defined($_[0])?1:0)} );
        } else {
          confess "Sort method should be 0 (numerical), 1 (other type), or a subroutine reference!\n";
        }
        push @subs, $mysub;
      }
      my $func = sub {
        my $res = 0;
        foreach (0 .. ($#cols/3)) {
          $res ||= $subs[$_]->($a->[$cols[$_*3]], $b->[$cols[$_*3]]);
          return $res unless $res==0;
        }
        return $res;
      };
      $self->rotate() if $self->{type};
      $self->{data} = [sort $func @{$self->{data}}];
      return 1;
  }
  
  # return rows as sub table in which
  # a pattern $pattern is matched 
  sub match_pattern {
    my ($self, $pattern, $countOnly) = @_;
    my @data=();
    $countOnly=0 unless defined($countOnly);
    my $cnt=0;
    $self->rotate() if $self->{type};
    @Data::Table::OK= eval "map { $pattern?1:0; } \@{\$self->{data}};";
    my @ok = @Data::Table::OK;
  	$self->{OK} = \@ok;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($self->{OK}->[$i]) {
        push @data, $self->{data}->[$i] unless $countOnly;
        $cnt++;
        $self->{OK}->[$i] = 1;
        $Data::Table::OK[$i] = 1;
      } else {
        # in case sometimes eval results is '' instead of 0
        $self->{OK}->[$i] = 0;
        $Data::Table::OK[$i] = 0;
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#ok;
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  # return rows as sub table in which
  # a pattern $pattern is matched
  # each row is passed to the patern as a hash, where column names are keys
  sub match_pattern_hash {
    my ($self, $pattern, $countOnly) = @_;
    my @data=();
    $countOnly=0 unless defined($countOnly);
    my $cnt=0;
    $self->rotate() if $self->{type};
    @Data::Table::OK = ();
    for (my $i=0; $i<$self->nofRow(); $i++) {
      local %_ = %{$self->rowHashRef($i)};
      $Data::Table::OK[$i] = eval "$pattern?1:0";
    }
    #@Data::Table::OK= eval "map { $pattern?1:0; } \@{\$self->{data}};";
    my @ok = @Data::Table::OK;
    $self->{OK} = \@ok;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($self->{OK}->[$i]) {
        push @data, $self->{data}->[$i] unless $countOnly;
        $cnt++;
        $self->{OK}->[$i] = 1;
        $Data::Table::OK[$i] = 1;
      } else {
        # in case sometimes eval results is '' instead of 0
        $self->{OK}->[$i] = 0;
        $Data::Table::OK[$i] = 0;
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#ok;
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  # return rows as sub table in which 
  # a string elm in an array @$s is matched 
  sub match_string {
    my ($self, $s, $caseIgn, $countOnly) = @_;
    confess unless defined($s);
    $countOnly=0 unless defined($countOnly);
    my @data=();
    my $r;
    $self->rotate() if $self->{type};
    @Data::Table::OK=();
    $self->{OK} = [];
    $caseIgn=0 unless defined($caseIgn);
  
    ### comment out next line if your perl version < 5.005 ###
    $r = ($caseIgn)?qr/$s/i : qr/$s/;
    my $cnt=0;
  
    foreach my $row_ref (@{$self->data}) {
      push @Data::Table::OK, 0;
      push @{$self->{OK}}, 0;
      foreach my $elm (@$row_ref) {
        next unless defined($elm);
          
          ### comment out the next line if your perl version < 5.005
        if ($elm =~ /$r/) {
          ### uncomment the next line if your perl version < 5.005
  	# if ($elm =~ /$s/ || ($elm=~ /$s/i && $caseIgn)) {
  
          push @data, $row_ref unless $countOnly;
          $Data::Table::OK[$#Data::Table::OK]=1;
          $self->{OK}->[$#{$self->{OK}}]=1;
          $cnt++;
          last;
        }
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#{$self->{OK}};
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  	
  sub rowMask {
    my ($self, $OK, $c) = @_;
    confess unless defined($OK);
    $c = 0 unless defined ($c);
    my @data=();
    $self->rotate() if $self->{type};
    my $data0=$self->data;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($c) {
        push @data, $data0->[$i] unless $OK->[$i];
      } else {
        push @data, $data0->[$i] if $OK->[$i];
      }
    }
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  sub rowMerge {
    my ($self, $tbl, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{byName} =0 unless exists $arg{byName};
    $arg{addNewCol} = 0 unless exists $arg{addNewCol};
    if ($self->isEmpty && !$tbl->isEmpty) {
      my @header = $tbl->header;
      my $i = 0;
      foreach my $s (@header) {
        push @{$self->{header}}, $s;
        $self->{colHash}->{$s} = $i++;
      }
    }
    if ($arg{byName} == 0 && $arg{addNewCol} == 0) {
      confess "Tables must have the same number of columns" unless ($self->nofCol()==$tbl->nofCol());
    } else {
      if ($arg{addNewCol}) {
        unless ($arg{byName}) { # add extra column by index
          if ($self->nofCol < $tbl->nofCol) {
            my @header = $tbl->header;
            my $nCols = $self->nofCol();
            my $nRows = $self->nofRow();
            for (my $i = $nCols; $i<@header; $i++) {
              my @one = (undef) x $nRows;
              $self->addCol(\@one, $header[$i]);
            }
          } elsif ($self->nofCol > $tbl->nofCol) {
            my @header = $self->header;
            my %h = ();
            my @header2 = $tbl->header;
            map {$h{$_} = 1} @header2;
            my $nCols = $tbl->nofCol();
            my $nRows = $tbl->nofRow();
            for (my $i = $nCols; $i<$self->nofCol; $i++) {
              my @one = (undef) x $nRows;
              # make sure new col name is unique
              my $s = $header[$i];
              my $cnt = 2;
              while (exists $h{$s}) {
                $s = $header[$i]."_".$cnt ++;
              }
              $tbl->addCol(\@one, $s);
              $h{$s} = 1;
            }
          }
        } else {
          my @header = $tbl->header;
          my $nRows = $self->nofRow();
          foreach my $col (@header) {
            if ($self->colIndex($col) < 0) {
              my @one = (undef) x $nRows;
              $self->addCol(\@one, $col);
            }
          }
        }
      }
    }
    $self->rotate() if $self->{type};
    $tbl->rotate() if $tbl->{type};
    my $data=$self->{data};
    if ($arg{byName} == 0) {
      push @$data, @{$tbl->{data}};
    } else {
      my @header = $self->header;
      my $nCols = scalar @header;
      my @colIndex = map { $tbl->colIndex($_) } @header;
      foreach my $rowRef (@{$tbl->{data}}) {
        my @one = ();
        for (my $j=0; $j< $nCols; $j++) {
          $one[$j] = $colIndex[$j]>=0 ? $rowRef->[$colIndex[$j]]:undef;
        }
        push @$data, \@one;
      }
    }
    return 1;
  }
  
  sub colMerge {
    my ($self, $tbl, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{renameCol} =0 unless exists $arg{renameCol};
    confess "Tables must have the same number of rows" unless ($self->isEmpty || $self->nofRow()==$tbl->nofRow());
    my $col;
    my %h = ();
  	map {$h{$_} = 1} @{$self->{header}};
    my @header2 = ();
    foreach $col ($tbl->header) {
      my $s = $col;
      if (exists $h{$s}) {
        confess "Duplicate column $col in two tables" unless $arg{renameCol};
        my $cnt = 2;
        while (exists $h{$s}) {
          $s = $col ."_". $cnt++;
        }
      }
      $h{$s} = 1;
      push @header2, $s;
    }
    $self->rotate() unless $self->{type};
    $tbl->rotate() unless $tbl->{type};
    my $i = $self->nofCol();
    for my $s (@header2) {
      push @{$self->{header}}, $s;
      $self->{colHash}->{$s} = $i++;
    }
    my $data=$self->{data};
    for ($i=0; $i<$tbl->nofCol(); $i++) {
      push @$data, $tbl->{data}->[$i];
    }
    return 1;
  }
  
  sub subTable {
    my ($self, $rowIdcsRef, $colIDsRef, $arg_ref) = @_;
    my @newdata=();
    my @newheader=();
    # to avoid the side effect of modifying $colIDsRef, 4/30/2012
    my $useRowMask = 0;
    $useRowMask = $arg_ref->{useRowMask} if defined $arg_ref->{useRowMask};
    my @rowIdcs = ();
    @rowIdcs = defined $rowIdcsRef ? @$rowIdcsRef : 0..($self->nofRow()-1) unless $useRowMask;
    my @colIDs = defined $colIDsRef ? @$colIDsRef : 0..($self->nofCol()-1);
    ##$rowIdcsRef = [0..($self->nofRow()-1)] unless defined $rowIdcsRef;
    #$colIDsRef = [0..($self->nofCol()-1)] unless defined $colIDsRef; 
    for (my $i = 0; $i < scalar @colIDs; $i++) {
      $colIDs[$i]=$self->checkOldCol($colIDs[$i]);
      #return undef unless defined $colIDsRef;
      push @newheader, $self->{header}->[$colIDs[$i]];
    }
    if ($useRowMask) {
      my @OK = @$rowIdcsRef;
      my $n = $self->nofRow;
      for (my $i = 0; $i < $n; $i++) {
        push @rowIdcs, $i if $OK[$i];
      }
    }
    if ($self->{type}) {
      for (my $i = 0; $i < scalar @colIDs; $i++) {
        my @one=();
        for (my $j = 0; $j < scalar @rowIdcs; $j++) {
  	      return undef unless defined $self->checkOldRow($rowIdcs[$j]);
          push @one, $self->{data}->[$colIDs[$i]]->[$rowIdcs[$j]];
        }
        push @newdata, \@one;
      }
    } else {
      for (my $i = 0; $i < scalar @rowIdcs; $i++) {
        return undef unless defined $self->checkOldRow($rowIdcs[$i]);	
        my @one=();
        for (my $j = 0; $j < scalar @colIDs; $j++) {
          push @one, $self->{data}->[$rowIdcs[$i]]->[$colIDs[$j]];
        }
        push @newdata, \@one;
      }
    }
    return new Data::Table(\@newdata, \@newheader, $self->{type});
  }
  
  sub reorder {
    my ($self, $colIDsRef, $arg_ref) = @_;
    return unless defined $colIDsRef;
    $arg_ref = {keepRest => 1} unless defined $arg_ref;
    my @newdata=();
    my @newheader=();
    my @colIDs = ();
    my %inNew = ();
    for (my $i = 0; $i < scalar @$colIDsRef; $i++) {
      my $idx = $self->checkOldCol($colIDsRef->[$i]);
      confess "Invalide column $colIDsRef->[$i]" unless defined $idx;
      $colIDs[$i] = $idx;
      $inNew{$idx} = 1;
      #return undef unless defined $colIDsRef;
      push @newheader, $self->{header}->[$idx];
    }
    if ($arg_ref->{keepRest}) {
      for (my $i = 0; $i<$self->nofCol; $i++) {
        unless (exists $inNew{$i}) {
          push @colIDs, $i;
          push @newheader, $self->{header}->[$i];
        }
      }
    }
    
    if ($self->{type}) {
      for (my $i = 0; $i < scalar @colIDs; $i++) {
        push @newdata, $self->{data}->[$colIDs[$i]];
      }
    } else {
      my $n = $self->nofRow;
      for (my $i = 0; $i < $n; $i++) {
        my @one=();
        for (my $j = 0; $j < scalar @colIDs; $j++) {
          push @one, $self->{data}->[$i]->[$colIDs[$j]];
        }
        push @newdata, \@one;
      }
    }
    $self->{header} = \@newheader;
    $self->{colHash} = ();
    for (my $i = 0; $i < scalar @colIDs; $i++) {
      $self->{colHash}->{$newheader[$i]} = $i;
    }
    $self->{data} = \@newdata;
  }
  
  sub clone {
    my $self = shift;
    my $data = $self->{data};
    my @newheader = @{$self->{header}};
    my @newdata = ();
    for (my $i = 0; $i < scalar @{$data}; $i++) {
      my @one=();
      for (my $j = 0; $j < scalar @{$data->[$i]}; $j++) {
        push @one, $data->[$i]->[$j];
      }
      push @newdata, \@one;
    }
    return new Data::Table(\@newdata, \@newheader, $self->{type});
  }
  
  sub fromCSVi {
    my $self = shift;
    return fromCSV(@_);
  }
  
  sub getOneLine {
    my ($fh, $linebreak, $qualifier) = @_;
    my $s = '';
    $qualifier = '' unless defined $qualifier;
    local($/) = $linebreak;
    return <$fh> unless $qualifier;
    while (my $s2 = <$fh>) {
      $s .= $s2;
      my @S = ($s =~ /$qualifier/g);
      return $s if (scalar @S % 2 == 0);
    }
    return $s;
  }
  
  sub fromCSV {
    my ($name_or_handler, $includeHeader, $header, $arg_ref) = @_;
    $includeHeader = 1 unless defined($includeHeader);
    my ($OS, $delimiter, $qualifier, $skip_lines, $skip_pattern, $encoding) = ($Data::Table::DEFAULTS{OS}, $Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER}, 0, undef, $Data::Table::DEFAULTS{ENCODING});
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    # OS: 0 for UNIX (\n as linebreak), 1 for Windows (\r\n as linebreak)
    ###   2 for MAC  (\r as linebreak)
    if (defined($arg_ref)) {
      $delimiter = $arg_ref->{'delimiter'} if defined($arg_ref->{'delimiter'});
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $skip_lines = $arg_ref->{'skip_lines'} if (defined($arg_ref->{'skip_lines'}) && $arg_ref->{'skip_lines'}>0);
      $skip_pattern = $arg_ref->{'skip_pattern'} if defined($arg_ref->{'skip_pattern'});
      $encoding = $arg_ref->{'encoding'} if defined($arg_ref->{'encoding'});
    }
    my @header;
    my $givenHeader = 0;
    if (defined($header) && ref($header) eq 'ARRAY') {
      $givenHeader = 1;
      @header= @$header;
    }
    my $SRC=openFileWithEncoding($name_or_handler, $encoding);
    my @data = ();
    my $oldRowDelimiter=$/;
    my $newRowDelimiter=($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    my $n_endl = length($newRowDelimiter);
    $/=$newRowDelimiter;
    my $s;
    for (my $i=0; $i<$skip_lines; $i++) {
      #$s=<$SRC>;
      $s = getOneLine($SRC, $newRowDelimiter, $qualifier);
    }
    #$s=<$SRC>;
    $s = getOneLine($SRC, $newRowDelimiter, $qualifier);
    if (defined($skip_pattern)) { while (defined($s) && $s =~ /$skip_pattern/) { $s = getOneLine($SRC, $newRowDelimiter, $qualifier); }}
    #{ $s = <$SRC> }; }
    if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
    # $_=~ s/$newRowDelimiter$//;
    unless ($s) {
      #confess "Empty data file" unless $givenHeader;
      return undef unless $givenHeader;
      $/=$oldRowDelimiter;
      return new Data::Table(\@data, \@header, 0);
    }
    my $one;
    if ($s =~ /$delimiter$/) { # if the line ends by ',', the size of @one will be incorrect
                # due to the tailing of split function in perl
      $s .= ' '; # e.g., split $s="a," will only return a list of size 1.
      $one = parseCSV($s, undef, {delimiter=>$delimiter, qualifier=>$qualifier});
      $one->[$#{@$one}]=undef;
    } else {
      $one = parseCSV($s, undef, {delimiter=>$delimiter, qualifier=>$qualifier});
    }
    #print join("|", @$one), scalar @$one, "\n";
    my $size = scalar @$one;
    unless ($givenHeader) {
      if ($includeHeader) {
        @header = @$one;
      } else {
        @header = map {"col$_"} (1..$size); # name each column as col1, col2, .. etc
      }
    }
    push @data, $one unless ($includeHeader);
  
    #while($s = <$SRC>) {
    while($s = getOneLine($SRC, $newRowDelimiter, $qualifier)) {
      next if (defined($skip_pattern) && $s =~ /$skip_pattern/);
      if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
      # $_=~ s/$newDelimiter$//;
      my $one = parseCSV($s, $size, {delimiter=>$delimiter, qualifier=>$qualifier});
      confess "Inconsistent column number at data entry: ".($#data+1) unless ($size==scalar @$one);
      push @data, $one;
    }
    close($SRC);
    $/=$oldRowDelimiter;
    return new Data::Table(\@data, \@header, 0);
  }
  
  # Idea: use \ as the escape char to encode a CSV string,
  # replace \ by \\ and comma inside a field by \c.
  # A comma inside a field must have odd number of " in front of it,
  # therefore it can be distinguished from comma used as the deliminator.
  # After escape, and split by comma, we unescape each field string.
  #
  # This parser will never be crashed by any illegal CSV format,
  # it always return an array!
  sub parseCSV {
    my ($s, $size, $arg_ref)=@_;
    $size = 0 unless defined $size;
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    $delimiter = $arg_ref->{'delimiter'} if (defined($arg_ref) && defined($arg_ref->{'delimiter'}));
    $qualifier = $arg_ref->{'qualifier'} if (defined($arg_ref) && defined($arg_ref->{'qualifier'}));
    my $delimiter2 = $delimiter; $delimiter2 = substr($delimiter, 1, 1) if length($delimiter)>1;
    my $qualifier2 = $qualifier; $qualifier2 = substr($qualifier, 1, 1) if length($qualifier)>1;
    # $s =~ s/\n$//; # chop" # assume extra characters has been cleaned before
    if (-1==index $s, $qualifier) {
      if ($size == 0) {
        my $s2 = $s;
        $s2 =~ s/$delimiter//g;
        $size = length($s)-length($s2)+1;
      }
      return [split /$delimiter/, $s , $size];
    }
    $s =~ s/\\/\\\\/g; # escape \ => \\
    my $n = length($s);
    my ($q, $i)=(0, 0);
    while ($i < $n) {
      my $ch=substr($s, $i, 1);
      $i++;
      if ($ch eq $delimiter2 && ($q%2)) {
        substr($s, $i-1, 1)='\\c'; # escape , => \c if it's not a deliminator
        $i++;
        $n++;
      } elsif ($ch eq $qualifier2) {
        $q++;
      }
    }
    $s =~ s/(^$qualifier)|($qualifier\s*$)//g; # get rid of boundary ", then restore "" => "
    $s =~ s/$qualifier\s*$delimiter/$delimiter2/g;
    $s =~ s/$delimiter\s*$qualifier/$delimiter2/g;
    $s =~ s/$qualifier$qualifier/$qualifier2/g;
    if ($size == 0) {
      my $s2 = $s;
      $s2 =~ s/$delimiter//g;
      $size = length($s)-length($s2)+1;
    }
    my @parts=split(/$delimiter/, $s, $size);
    @parts = map {$_ =~ s/(\\c|\\\\)/$1 eq '\c'?$delimiter2:'\\'/eg; $_ } @parts;
  #  my @parts2=();
  #  foreach $s2 (@parts) {
  #    $s2 =~ s/\\c/,/g;   # restore \c => ,
  #    $s2 =~ s/\\\\/\\/g; # restore \\ => \
  #    push @parts2, $s2;
  #  }
    return \@parts;
  }
  
  sub transformElement {
    my $one = shift;
    for (my $i=0; $i < scalar @$one; $i++) {
      next unless defined($one->[$i]);
      if ($one->[$i] eq "\\N") {
        $one->[$i]=undef;
      } else {
        $one->[$i] =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g;
      }
    }
    return $one;
  }
  
  sub fromTSVi {
    my $self = shift;
    return fromTSV(@_);
  }
  
  sub fromTSV {
    my ($name_or_handler, $includeHeader, $header, $arg_ref) = @_;
    my ($OS, $skip_lines, $skip_pattern, $transform_element, $encoding) = ($Data::Table::DEFAULTS{OS}, 0, undef, 1, $Data::Table::DEFAULTS{ENCODING});
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    # OS: 0 for UNIX (\n as linebreak), 1 for Windows (\r\n as linebreak)
    ###   2 for MAC  (\r as linebreak)
    $skip_lines = $arg_ref->{'skip_lines'} if (defined($arg_ref) && defined($arg_ref->{'skip_lines'}) && $arg_ref->{'skip_lines'}>0);
    $skip_pattern = $arg_ref->{'skip_pattern'} if defined($arg_ref->{'skip_pattern'});
    $transform_element = $arg_ref->{'transform_element'} if (defined($arg_ref->{'transform_element'}));
    $encoding = $arg_ref->{'encoding'} if (defined($arg_ref->{'encoding'}));
    #my %ESC = ( '0'=>"\0", 'n'=>"\n", 't'=>"\t", 'r'=>"\r", 'b'=>"\b",
    #            "'"=>"'", '"'=>"\"", '\\'=>"\\" );
    ## what about \f? MySQL treats \f as f.
  
    $includeHeader = 1 unless defined($includeHeader);
    $OS=0 unless defined($OS);
   
    my @header;
    my $givenHeader = 0;
    if (defined($header) && ref($header) eq 'ARRAY') {
      $givenHeader = 1;
      @header= @$header;
    }
    my $SRC=openFileWithEncoding($name_or_handler, $encoding);
    my @data = ();
    my $oldRowDelimiter=$/;
    my $newRowDelimiter=($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    my $n_endl = length($newRowDelimiter);
    $/=$newRowDelimiter;
    my $s;
    for (my $i=0; $i<$skip_lines; $i++) {
      $s=<$SRC>;
    }
    $s=<$SRC>;
    if (defined($skip_pattern)) { while (defined($s) && $s =~ /$skip_pattern/) { $s = <$SRC> }; }
    if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
    # $_=~ s/$newRowDelimiter$//;
    unless ($s) {
      confess "Empty data file" unless $givenHeader;
      $/=$oldRowDelimiter;
      return new Data::Table(\@data, \@header, 0);
    }
    #chop;
    my $one;
    if ($s =~ /\t$/) { # if the line ends by ',', the size of @$one will be incorrect
                # due to the tailing of split function in perl
      $s .= ' '; # e.g., split $s="a," will only return a list of size 1.
      @$one = split(/\t/, $s);
      $one->[$#{@$one}]='';
    } else {
      @$one = split(/\t/, $s);
    }
    # print join("|", @$one), scalar @$one, "\n";
    my $size = scalar @$one;
    unless ($givenHeader) {
      if ($includeHeader) {
        if ($transform_element) {
          @header = map { $_ =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g; $_ } @$one;
        } else {
          @header = @$one;
        }
      } else {
        @header = map {"col$_"} (1..$size); # name each column as col1, col2, .. etc
      }
    }
    unless ($includeHeader) {
      transformElement($one) if $transform_element;
      push @data, $one;
    }
    while($s = <$SRC>) {
      #chop;
      # $_=~ s/$newRowDelimiter$//;
      next if (defined($skip_pattern) && $s =~ /$skip_pattern/);
      if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
      my @one = split(/\t/, $s, $size);
      transformElement(\@one) if $transform_element;
      #for (my $i=0; $i < $size; $i++) {
      #  next unless defined($one[$i]);
      #  if ($one[$i] eq "\\N") {
      #    $one[$i]=undef;
      #  } else {
      #    $one[$i] =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g;
      #  }
      #}
      confess "Inconsistent column number at data entry: ".($#data+1) unless ($size==scalar @one);
      push @data, \@one;
    }
    close($SRC);
    $/=$oldRowDelimiter;
    return new Data::Table(\@data, \@header, 0);
  }
  
  sub fromSQLi {
    my $self = shift;
    return fromSQL(@_);
  }
  
  sub fromSQL {
    my ($dbh, $sql, $vars) = @_;
    my ($sth, $header, $t);
    if (ref $sql eq 'DBI::st') {
      $sth = $sql;
    } else {
      $sth = $dbh->prepare($sql) or confess "Preparing: , ".$dbh->errstr;
    }
    my @vars=() unless defined $vars;
    $sth->execute(@$vars) or confess "Executing: ".$dbh->errstr;
  #  $Data::Table::ID = undef;
  #  $Data::Table::ID = $sth->{'mysql_insertid'};
    if ($sth->{NUM_OF_FIELDS}) {
      $header=$sth->{'NAME'};
      $t = new Data::Table($sth->fetchall_arrayref(), $header, 0);
    } else {
      $t = undef;
    }
    $sth->finish;
    return $t;
  }
  
  sub join {
    my ($self, $tbl, $type, $cols1, $cols2, $arg_ref) = @_;
    my $n1 = scalar @$cols1;
    my %arg= ( renameCol => 0, matchNULL => 0, NULLasEmpty => 0);
    $arg{renameCol} = $arg_ref->{renameCol} if exists $arg_ref->{renameCol};
    $arg{matchNULL} = $arg_ref->{matchNULL} if exists $arg_ref->{matchNULL};
    $arg{NULLasEmpty} = $arg_ref->{NULLasEmpty} if exists $arg_ref->{NULLasEmpty};
    #%arg = %$arg_ref if defined $arg_ref;
    # default cols2 to cols1 if not specified
    if (!defined($cols2) && $n1>0) {
      $cols2 = [];
      foreach my $c (@$cols1) {
        push @$cols2, $c;
      }
    }
    my $n2 = scalar @$cols2;
    confess "The number of join columns must be the same: $n1 != $n2" unless $n1==$n2;
    confess "At least one join column must be specified" unless $n1;
    my ($i, $j, $k);
    my @cols3 = ();
    for ($i = 0; $i < $n1; $i++) {
      $cols1->[$i]=$self->checkOldCol($cols1->[$i]);
      confess "Unknown column ". $cols1->[$i] unless defined($cols1->[$i]);
      $cols2->[$i]=$tbl->checkOldCol($cols2->[$i]);
      confess "Unknown column ". $cols2->[$i] unless defined($cols2->[$i]);
      $cols3[$cols2->[$i]]=1;
    }
    my @cols4 = (); # the list of remaining columns
    my @header2 = ();
    for ($i = 0; $i < $tbl->nofCol; $i++) {
      unless (defined($cols3[$i])) {
        push @cols4, $i;
        push @header2, $tbl->{header}->[$i];
      }
    }
  
    $self->rotate() if $self->{type};
    $tbl->rotate() if $tbl->{type};
    my $data1 = $self->{data};
    my $data2 = $tbl->{data};
    my %H=();
    my $key;
    my @subRow;
    for ($i = 0; $i < $self->nofRow; $i++) {
      @subRow = @{$data1->[$i]}[@$cols1];
      my @S = map {tsvEscape($_)} @subRow;
      map { $_ = '' if $_ eq '\\N' } @S if $arg{NULLasEmpty};
      $key = join("\t", @S);
      unless (defined($H{$key})) {
        $H{$key} = [[$i], []];
      } else {
        push @{$H{$key}->[0]}, $i;
      }
    }
    for ($i = 0; $i < $tbl->nofRow; $i++) {
      @subRow = @{$data2->[$i]}[@$cols2];
      # we intentionally make the second table undef keys to be '\\N\\N',
      # so that they are different from the first table undef keys
      # avoid NULL == NULL in the join
      my @S = map {tsvEscape($_)} @subRow;
      map { $_ = ($arg{NULLasEmpty})? '':($arg{matchNULL} ? $_ : '\\N\\N') if $_ eq '\\N' } @S;
      #if ($j>= @S) {
      $key = join("\t", @S);
      #} else {
      #  $key = $arg{matchNULL} ? '\\N' : '\\N\\N';
      #}
      unless (defined($H{$key})) {
        $H{$key} = [[], [$i]];
      } else {
        push @{$H{$key}->[1]}, $i;
      }
    }
  # $type
  # 0: inner join
  # 1: left outer join
  # 2: right outer join
  # 3: full outer join
    my @ones = ();
    my @null1 = ();
    my @null2 = ();
    my @null3 = ();
    $null1[$self->nofCol-1]=undef;
    $null3[$self->nofCol-1]=undef;
    if ($#cols4>=0) { $null2[$#cols4]=undef; }
    foreach $key (keys %H) {
      my ($rows1, $rows2) = @{$H{$key}};
      my $nr1 = scalar @$rows1;
      my $nr2 = scalar @$rows2;
      next if ($nr1 == 0 && ($type == 0 || $type == 1));
      next if ($nr2 == 0 && ($type == 0 || $type == 2));
      if ($nr2 == 0 && ($type == 1 || $type == 3)) {
        for ($i = 0; $i < $nr1; $i++) {
          push @ones, [$self->row($rows1->[$i]), @null2];
        }
        next;
      }
      if ($nr1 == 0 && ($type == 2 || $type == 3)) {
        for ($j = 0; $j < $nr2; $j++) {
          my @row2 = $tbl->row($rows2->[$j]);
          for ($k = 0; $k< scalar @$cols1; $k++) {
            $null3[$cols1->[$k]] = $row2[$cols2->[$k]];
          }
          if ($#cols4>=0) {
            push @ones, [@null3, @row2[@cols4]];
          } else {
            push @ones, [@null3];
          } 
        }
        next;
      }
      for ($i = 0; $i < $nr1; $i++) {
        for ($j = 0; $j < $nr2; $j++) {
          my @row2 = $tbl->row($rows2->[$j]);
          push @ones, [$self->row($rows1->[$i]), @row2[@cols4]];
        }
      }
    }
    if ($arg{renameCol}) {
      my %h = ();
      map {$h{$_} = 1} @{$self->{header}};
      for (my $i=0; $i<@header2; $i++) {
        my $s = $header2[$i];
        my $cnt = 2;
        while (exists $h{$s}) {
          $s = $header2[$i] ."_". $cnt++;
        }
        $header2[$i] = $s;
        $h{$s} = 1;
      }
    }
    my $header = [@{$self->{header}}, @header2];
    return new Data::Table(\@ones, $header, 0);
  }
  
  sub melt {
    my ($self, $keyCols, $variableCols, $arg_ref) = @_;
    confess "key columns have to be specified!" unless defined($keyCols) && ref($keyCols) eq "ARRAY";
    my $variableColName = 'variable';
    my $valueColName = 'value';
    my $skip_NULL = 1;
    my $skip_empty = 0;
    $variableColName = $arg_ref->{'variableColName'} if (defined($arg_ref) && defined($arg_ref->{'variableColName'}));
    $valueColName = $arg_ref->{'valueColName'} if (defined($arg_ref) && defined($arg_ref->{'valueColName'}));
    $skip_NULL = $arg_ref->{'skip_NULL'} if (defined($arg_ref) && defined($arg_ref->{'skip_NULL'}));
    $skip_empty= $arg_ref->{'skip_empty'} if (defined($arg_ref) && defined($arg_ref->{'skip_empty'}));
    my @X = ();
    my %X = ();
    foreach my $x (@$keyCols) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $X{$x_idx} = 1;
    }
    my @Y = ();
    my %Y = ();
    unless (defined($variableCols)) {
      $variableCols = [];
      foreach my $x (0 .. $self->nofCol-1) {
        next if $X{$x};
        push @$variableCols, $x;
      }
    }
    unless (scalar @$variableCols) {
      confess "Variable columns have to be specified!";
    }
    foreach my $y (@$variableCols) {
      my $y_idx = $self->checkOldCol($y);
      confess "Unknown column ". $y unless defined($y_idx);
      push @Y, $y_idx;
      $Y{$y_idx} = 1;
    }
  
    my @newHeader = ();
    my @header = $self->header;
    for (my $i=0; $i<= $#X; $i++) {
      push @newHeader, $header[$X[$i]];
    }
    push @newHeader, $variableColName;
    push @newHeader, $valueColName;
    my @newRows = ();
    for (my $i=0; $i<$self->nofRow; $i++) {
      my $row = $self->rowRef($i);
      my @key = @$row[@X];
      foreach my $y (@Y) {
        next if (!defined($row->[$y]) && $skip_NULL);
        next if ($row->[$y] eq '' && $skip_empty);
        my @one = @key;
        push @one, $header[$y], $row->[$y];
        push @newRows, \@one;
      }
    }
    return new Data::Table(\@newRows, \@newHeader, 0);
  }
  
  sub cast {
    my ($self, $colsToGroupBy, $colToSplit, $colToSplitIsStringOrNumeric, $colToCalculate, $funToApply) = @_;
    #$colToSplit = 'variable' unless defined $colToSplit;
    #$colToCalculate = 'value' unless defined $colToCalculate;
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    my $tmpColName = '_calcColumn';
    my $cnt = 2;
    my $s = $tmpColName;
    while ($self->hasCol($s)) {
      $s = $tmpColName."_".$cnt++;
    }
    $tmpColName = $s;
    my %grpBy = ();
    map {$grpBy{$_} = 1} @$colsToGroupBy;
    my @grpBy = @$colsToGroupBy;
    confess "colToSplit cannot be contained in the list of colsToGroupBy!" if defined $colToSplit and $grpBy{$colToSplit};
    push @grpBy, $colToSplit if defined $colToSplit;
    my $t = $self->group(\@grpBy, [$colToCalculate], [$funToApply], [$tmpColName], 0);
    $t = $t->pivot($colToSplit, $colToSplitIsStringOrNumeric, $tmpColName, $colsToGroupBy);
    return $t;
  }
  
  sub each_group {
    my ($self, $colsToGroupBy, $funToApply) = @_;
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    confess "colsToGroupBy has to be specified!" unless defined($colsToGroupBy) && ref($colsToGroupBy) eq "ARRAY";
    confess "funToApply has to be a reference to CODE!" unless ref($funToApply) eq "CODE";
    unless (scalar @$colsToGroupBy) { # all rows are treated as one group
      $funToApply->($self->clone, 0 .. $self->nofRow - 1);
      return;
    }
    my @X = ();
    my %grpBy = ();
    foreach my $x (@$colsToGroupBy) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $grpBy{$x_idx} = 1;
    }
    my %X = ();
    for (my $i=0; $i<$self->nofRow; $i++) {
      my $myRow = $self->rowRef($i);
      #my @val = ();
      #foreach my $x (@X) {
      #  push @val, defined($myRow->[$x])?$myRow->[$x]:"";
      #}
      my @val = map {tsvEscape($_)} @{$myRow}[@X];
      my $myKey = CORE::join("\t", @val);
      push @{$X{$myKey}}, $i;
    }
    foreach my $myKey ( sort {$a cmp $b} keys %X) {
      $funToApply->($self->subTable($X{$myKey}, undef), $X{$myKey});
    }
  }
  
  sub group {
    my ($self, $colsToGroupBy, $colsToCalculate, $funsToApply, $newColNames, $keepRestCols) = @_;
    $keepRestCols = 1 unless defined($keepRestCols);
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    confess "colsToGroupBy has to be specified!" unless defined($colsToGroupBy) && ref($colsToGroupBy) eq "ARRAY";
    my @X = ();
    my %grpBy = ();
    foreach my $x (@$colsToGroupBy) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $grpBy{$x_idx} = 1;
    }
    my @Y = ();
    my %Y= ();
    if (defined($colsToCalculate)) {
      foreach my $y (@$colsToCalculate) {
        my $y_idx = $self->checkOldCol($y);
        confess "Unknown column ". $y unless defined($y_idx);
        push @Y, $y_idx;
        $Y{$y_idx} = 1;
      }
    }
    if (scalar @Y) {
      confess "The size of colsToCalculate, funcsToApply and newColNames should be the same!\n"
        unless (scalar @Y == scalar @$funsToApply && scalar @Y == scalar @$newColNames);
    }
  
    my @header = ();
    my @X_name = ();
    my $cnt = 0;
    my $i;
    for ($i=0; $i<$self->nofCol; $i++) {
      if ($grpBy{$i} || ($keepRestCols && !defined($Y{$i}))) {
        push @X_name, $i;
        push @header, $self->{header}->[$i];
        $cnt += 1;
      }
    }
    if (defined($newColNames)) {
      foreach my $y (@$newColNames) {
        push @header, $y;
        $cnt += 1;
      }
    }
    my @ones = ();
    my %X = ();
    my %val = ();
    my %rowIdx = ();
    my $idx = 0;
    for ($i=0; $i<$self->nofRow; $i++) {
      my @row = ();
      my $myRow = $self->rowRef($i);
      my $myKey = '(all)';
      if (@X) {
        # if colsToGroupBy is not specified, all rows has myKey = '(all)', therefore treated as one group
        my @val = map {tsvEscape($_)} @{$myRow}[@X];
        #foreach my $x (@X) {
        #  push @val, defined($myRow->[$x])?$myRow->[$x]:"";
        #}
        $myKey = CORE::join("\t", @val);
      }
      if (scalar @Y) {
        my %Y = ();
        foreach my $y (@Y) {
          next if defined($Y{$y});
          $Y{$y} = 1;
          if (defined($val{$y}->{$myKey})) {
            push @{$val{$y}->{$myKey}}, $myRow->[$y];
          } else {
            $val{$y}->{$myKey} = [$myRow->[$y]];
          }
        }
      }
      next if defined($X{$myKey});
      $X{$myKey} = 1;
      foreach my $j (@X_name) {
        push @row, $myRow->[$j];
      }
      $row[$cnt-1] = undef if (scalar @row < $cnt);
      push @ones, \@row;
      $rowIdx{$myKey} = $idx++;
    }
  
    if (scalar @Y) {
      $cnt -= scalar @Y;
      for($i=0; $i<scalar @Y; $i++) {
        foreach my $s (keys %X) {
          if (ref($funsToApply->[$i]) eq "CODE") {
            $ones[$rowIdx{$s}]->[$cnt+$i] = $funsToApply->[$i]->(@{$val{$Y[$i]}->{$s}});
          } else {
            $ones[$rowIdx{$s}]->[$cnt+$i] = scalar @{$val{$Y[$i]}->{$s}};
            #confess "The ${i}th element in the function array is not a valid reference!\n";
          }
        }
      }
    }
  
    return new Data::Table(\@ones, \@header, 0);
  }
  
  sub pivot {
    my ($self, $colToSplit, $colToSplitIsStringOrNumeric, $colToFill, $colsToGroupBy, $keepRestCols) = @_;
    $keepRestCols = 0 unless defined($keepRestCols);
    $colToSplitIsStringOrNumeric = 0 unless defined($colToSplitIsStringOrNumeric);
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    my $y = undef;
    $y = $self->checkOldCol($colToSplit) if defined $colToSplit;
    my $y_name = defined($y)?$self->{header}->[$y]:undef;
    confess "Unknown column ". $colToSplit if (!defined($y) && defined($colToSplit));
    my $z = undef;
    $z = $self->checkOldCol($colToFill) if defined($colToFill);
    my $z_name = defined($z)?$self->{header}->[$z]:undef;
    confess "Unknown column ". $colToFill if (!defined($z) && defined($colToFill));
    #confess "Cannot take colToFill, if colToSplit is 'undef'" if (defined($z) && !defined($y));
    my @X = ();
    if (defined($colsToGroupBy)) {
      foreach my $x (@$colsToGroupBy) {
        my $x_idx = $self->checkOldCol($x);
        confess "Unknown column ". $x unless defined($x_idx);
        push @X, $self->{header}->[$x_idx];
      }
    }
    my (@Y, %Y);
  
    if (defined($colToSplit)) {
      @Y = $self->col($y);
      %Y = ();
      foreach my $val (@Y) {
        $val = "NULL" unless defined($val);
        $Y{$val} = 1;
      }
    } else {
      @Y = ('(all)') x $self->nofCol;
      %Y = ('(all)' => 1);
      $colToSplitIsStringOrNumeric = 1;
    }
    if ($colToSplitIsStringOrNumeric == 0) {
      foreach my $y (keys %Y) {
        if ($y =~ /\D/) {
          $colToSplitIsStringOrNumeric = 1;
          last;
        }
      }
    }
    if ($colToSplitIsStringOrNumeric) {
      @Y = sort { $a cmp $b } (keys %Y);
    } else {
      @Y = sort { $a <=> $b } (keys %Y);
    }
  
    my @header = ();
    my $i;
    my @X_name = ();
  
    if (!$keepRestCols) {
      foreach my $x (@X) {
        push @X_name, $x;
      }
    } else {
      for ($i=0; $i<$self->nofCol; $i++) {
        next if ((defined($y) && $i==$y) || (defined($z) && $i==$z));
        push @X_name, $self->{header}->[$i];
      }
    }
    my $cnt = 0;
    for ($i=0; $i < @X_name; $i++) {
      my $s = $X_name[$i];
      while (defined($Y{$s})) {
        $s = "_".$s;
      }
      push @header, $s;
      $Y{$s} = $cnt++;
    }
  
    #if (defined($y)) {
      foreach my $val (@Y) {
        push @header, ($colToSplitIsStringOrNumeric?"":"$y_name=") . $val;
        $Y{$val} = $cnt++;
      }
    #}
  
    my @ones = ();
    my %X = ();
    my $rowIdx = 0;
    for ($i=0; $i<$self->nofRow; $i++) {
      my @row = ();
      my $myRow = $self->rowHashRef($i);
      my $myKey = '(all)'; # set to '' to work with total agreegation (group all rows into one)
      if (scalar @X) {
        my @val = ();
        foreach my $x (@X) {
          push @val, tsvEscape($myRow->{$x});
        }
        $myKey = CORE::join("\t", @val);
      }
      unless (defined($X{$myKey})) {
        foreach my $s (@X_name) {
          push @row, $myRow->{$s};
        }
        for (my $j = scalar @row; $j<$cnt; $j++) {
          $row[$j] = undef;
        }
        #$row[$cnt-1] = undef if (scalar @row < $cnt);
      }
      #if (defined($y)) {
        my $val = defined($y) ? $myRow->{$y_name} : "(all)";
        $val = "NULL" unless defined($val);
        if (!defined($X{$myKey})) {
          $row[$Y{$val}] = defined($z)?$myRow->{$z_name}: $row[$Y{$val}]+1;
        } else {
          $ones[$X{$myKey}][$Y{$val}] = defined($z)?$myRow->{$z_name}: $ones[$X{$myKey}][$Y{$val}]+1;
        }
      #}
      unless (defined($X{$myKey})) {
        push @ones, \@row;
        $X{$myKey} = $rowIdx++;
      }
    }
    return new Data::Table(\@ones, \@header, 0);
  }
  
  sub fromFileGuessOS {
    my ($name, $arg_ref) = @_;
    my @OS=("\n", "\r\n", "\r");
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    my $qualifier = '';
    my $encoding = $Data::Table::DEFAULTS{ENCODING};
    $qualifier = $arg_ref->{qualifier} if (defined($arg_ref) && exists $arg_ref->{qualifier});
    $encoding = $arg_ref->{encoding} if (defined($arg_ref) && exists $arg_ref->{encoding});
    my ($len, $os)=(-1, -1);
    my $SRC=openFileWithEncoding($name, $encoding);
    #local($/)="\n";
    my $s = getOneLine($SRC, "\n", $qualifier); #<$SRC>;
    close($SRC);
    #$s =~ s/\n$//;
    #my $myLen=length($s);
    #$s =~ s/\r$//;
    if ($s =~ /\r\n$/) {
      return 1;
    } elsif ($s =~ /\n$/) {
      return 0;
    } elsif ($s =~ /\r/) {
      return 2;
    }
    return 0;
    #if (length($s) == $myLen) {
    #  return 0;
    #} elsif (length($s) == $myLen - 1) {
    #  return 1;
    #} else {
    #  return 2;
    #}
  #  for (my $i=0; $i<@OS; $i++) {
  #    open($SRC, $name) or confess "Cannot open $name to read";
  #    binmode $SRC;
  #    local($/)=$OS[$i];
  #    my $s = <$SRC>;
  #    #print ">> $i => ". (length($s)-length($OS[$i]))."\n";
  #    my $myLen=length($s)-length($OS[$i]);
  #    if ($len<0 || ($myLen>0 && $myLen<$len)) {
  #      $len=length($s)-length($OS[$i]);
  #      $os=$i;
  #    }
  #    close($SRC);
  #  }
  #  # find the OS linebreak that gives the shortest first line
  #  return $os;
  }
  
  sub openFileWithEncoding {
    my ($name_or_handler, $encoding) = @_;
    my $isFileHandler=ref($name_or_handler) ne "";
    my $SRC;
    if ($isFileHandler) {
      $SRC = $name_or_handler; # a file handler
    } else {
      open($SRC, $name_or_handler) or confess "Cannot open $name_or_handler to read";
    }
    # check if Perl version is recent enough to support encoding
    $encoding ='' if (!$^V or $^V lt v5.8.1);
    if ($encoding) {
      $encoding='UTF-8' if ($encoding =~ /^utf-?8$/i);
      binmode($SRC, ":encoding($encoding)");
    } else {
      binmode $SRC;
    }
    return $SRC;
  }
  
  sub fromFileGetTopLines {
    my ($name, $os, $numLines, $arg_ref) = @_;
    $os = fromFileGuessOS($name) unless defined($os);
    $numLines = 2 unless defined($numLines);
    my @OS=("\n", "\r\n", "\r"); 
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    my $encoding = $Data::Table::DEFAULTS{ENCODING};
    $encoding = $arg_ref->{encoding} if (defined($arg_ref) && exists $arg_ref->{encoding});
    my @lines=();
    my $SRC = openFileWithEncoding($name, $encoding);
    local($/)=$OS[$os];
    my $n_endl = length($OS[$os]);
    my $cnt=0;
    while(my $line = <$SRC>) {
      $cnt++;
      for (1..$n_endl) { chop($line); }
      push @lines, $line;
      last if ($numLines>0 && $cnt>=$numLines);
    }
    close($SRC);
    return @lines;
  }
  
  sub fromFileIsHeader {
    my ($s, $delimiter, $allowNumericHeader) = @_;
    $delimiter=$Data::Table::DEFAULTS{'CSV_DELIMITER'} unless defined($delimiter);
    return 0 if (!defined($s) || $s eq "" || $s=~ /$delimiter$/);
    my $fields=parseCSV($s, 0, {delimiter=>$delimiter});
    my $allNumbers = 1;
    foreach my $name (@$fields) {
      return 0 unless $name;
      #next if $name=~/[^0-9.eE\-+]/;
      return 0 if $name=~/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/ && !$allowNumericHeader;
      # modified, so that we allow some columns to be numeric, but not all columns
      $allNumbers = 0 unless $name =~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/;
    }
    #return 0 if $allNumbers;
    return 1;
  }
  
  sub fromFileGuessDelimiter {
    my $s_line= shift;
    my @DELIMITER=(",","\t",":");
    my $numCol=-1; my $i=-1;
    return $Data::Table::DEFAULTS{CSV_DELIMITER} unless @$s_line;
    for (my $d=0; $d<@DELIMITER; $d++) {
      my $colFound=-1;
      foreach my $line (@$s_line) {
        unless (defined($line)) {
          return $Data::Table::DEFAULTS{CSV_DELIMITER};
        } else {
          my $header = parseCSV($line, 0, {delimiter=>$DELIMITER[$d]});
          if ($colFound<0) {
            $colFound = scalar @$header;
          } elsif ($colFound != scalar @$header) {
            $colFound = -1;
            last;
          }
        }
      }
      next if $colFound<0;
      if ($colFound>$numCol) {
        $numCol=$colFound; $i=$d;
      }
    }
    return ($i<0)?$Data::Table::DEFAULTS{CSV_DELIMITER}:$DELIMITER[$i];
  }
  
  sub fromFile {
    my ($name, $arg_ref) = @_;
    my $linesChecked = 2;
    my $os = undef;
    my $hasHeader = undef;
    my $delimiter = undef;
    my $format = undef;
    my $qualifier = $Data::Table::DEFAULTS{CSV_QUALIFIER};
    my $allowNumericHeader = 0;
    my $encoding=$Data::Table::DEFAULTS{ENCODING};
  
    if (defined($arg_ref)) {
      $linesChecked = $arg_ref->{'linesChecked'} if defined($arg_ref->{'linesChecked'});
      $os = $arg_ref->{'OS'};
      $hasHeader = $arg_ref->{'has_header'};
      $delimiter = $arg_ref->{'delimiter'};
      $format = $arg_ref->{'format'};
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $allowNumericHeader = $arg_ref->{'allowNumericHeader'};
      $encoding = $arg_ref->{'encoding'};
    }
  
    $qualifier = '' if ($format and uc($format) eq 'TSV');
    unless (defined($os)) {
      $os = fromFileGuessOS($name, {qualifier=>$qualifier, encoding=>$encoding});
      $arg_ref->{'OS'}=$os;
    }
    my @S = fromFileGetTopLines($name, $os, $linesChecked, {encoding=>$encoding});
    return undef unless scalar @S;
    unless (defined($delimiter)) {
      $delimiter = fromFileGuessDelimiter(\@S);
      $arg_ref->{'delimiter'} = $delimiter;
    }
    unless (defined($hasHeader)) {
      $hasHeader = fromFileIsHeader($S[0], $delimiter, $allowNumericHeader);
    }
    my $t = undef;
    #print ">>>". join("\n", @S)."\n";
    #print "OS=$os, hasHeader=$hasHeader, delimiter=$delimiter\n";
    if ($delimiter eq "\t") {
      $t=fromTSV($name, $hasHeader, undef, $arg_ref);
    } else {
      $t=fromCSV($name, $hasHeader, undef, $arg_ref);
    }
    return $t;
  }
  
  ## interface to GD::Graph
  # use GD::Graph::points;
  # $graph = GD::Graph::points->new(400, 300);
  # $graph->plot([$t->colRef(1), $t->colRef(2)]);
   
  1;
  
  __END__
  
  
  =head1 NAME
  
  Data::Table - Data type related to database tables, spreadsheets, CSV/TSV files, HTML table displays, etc.
  
  =head1 SYNOPSIS
  
    News: The package now includes "Perl Data::Table Cookbook" (PDF), which may serve as a better learning material.
    To download the free Cookbook, visit https://sites.google.com/site/easydatabase/
    
    # some cool ways to use Table.pm
    use Data::Table;
    
    $header = ["name", "age"];
    $data = [
      ["John", 20],
      ["Kate", 18],
      ["Mike", 23]
    ];
    $t = new Data::Table($data, $header, 0);	# Construct a table object with
  					# $data, $header, $type=0 (consider 
  					# $data as the rows of the table).
    print $t->csv;                        # Print out the table as a csv file.
  
    $t = Data::Table::fromCSV("aaa.csv");       # Read a csv file into a table object
    ### Since version 1.51, a new method fromFile can automatically guess the correct file format
    # either CSV or TSV file, file with or without a column header line
    # e.g.
    #   $t = Data::Table::fromFile("aaa.csv");
    # is equivalent.
    print $t->html;                       # Display a 'portrait' HTML TABLE on web. 
  
    use DBI;
    $dbh= DBI->connect("DBI:mysql:test", "test", "") or die $DBI::errstr;
    my $minAge = 10;
    $t = Data::Table::fromSQL($dbh, "select * from mytable where age >= ?", [$minAge]);
  					# Construct a table form an SQL 
  					# database query.
  
    $t->sort("age", 0, 0);                # Sort by col 'age',numerical,ascending
    print $t->html2;                      # Print out a 'landscape' HTML Table.  
  
    $row = $t->delRow(2);			# Delete the third row (index=2).
    $t->addRow($row, 4);			# Add the deleted row back as fifth row. 
    @rows = $t->delRows([0..2]);		# Delete three rows (row 0 to 2).
    $col = $t->delCol("age");		# Delete column 'age'.
    $t->addCol($col, "age",2);		# Add column 'age' as the third column
    @cols = $t->delCols(["name","phone","ssn"]); 
  					# Delete 3 columns at the same time. 
  
    $name =  $t->elm(2,"name");	        # Element access
    $t2=$t->subTable([1, 3..4],['age', 'name']);	
  					# Extract a sub-table 
  
    $t->rename("Entry", "New Entry");	# Rename column 'Entry' by 'New Entry'
    $t->replace("Entry", [1..$t->nofRow()], "New Entry");	
  					# Replace column 'Entry' by an array of
  					# numbers and rename it as 'New Entry'
    $t->swap("age","ssn");		# Swap the positions of column 'age' 
  					# with column 'ssn' in the table.
  
    $t->colMap('name', sub {return uc});  # Map a function to a column 
    $t->sort('age',0,0,'name',1,0);	# Sort table first by the numerical 
  					# column 'age' and then by the 
  					# string column 'name' in ascending
  					# order
    $t2=$t->match_pattern('$_->[0] =~ /^L/ && $_->[3]<0.2'); 
  					# Select the rows that matched the 
  					# pattern specified 
    $t2=$t->match_pattern_hash('$_{"Amino acid"} =~ /^L-a/ && $_{"Grams \"(a.a.)\""}<0.2'));
            # use column name in the pattern, method added in 1.62
    $t2=$t->match_string('John');		# Select the rows that matches 'John'   
  					# in any column
  
    $t2=$t->clone();			# Make a copy of the table.
    $t->rowMerge($t2);			# Merge two tables
    $t->colMerge($t2);
  
    $t = new Data::Table(                 # create an employ salary table
      [
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Peter', 'male', 'HR', 85000],
        ['Mary', 'female', 'HR', 80000],
        ['Nancy', 'female', 'IT', 55000],
        ['Jack', 'male', 'IT', 88000],
        ['Susan', 'female', 'HR', 92000]
      ],
      ['Name', 'Sex', 'Department', 'Salary'], 0);
    
    sub average {  # this is an subroutine calculate mathematical average, ignore NULL
      my @data = @_;
      my ($sum, $n) = (0, 0);
      foreach $x (@data) {
        next unless $x;
        $sum += $x; $n++;
      }
      return ($n>0)?$sum/$n:undef;
    }
    
    $t2 = $t->group(["Department","Sex"],["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"]);
    # For each (Department,Sex) pair, calculate the number of employees and average salary
    $t2 = $t2->pivot("Sex", 0, "Average Salary", ["Department"]);
    # Show average salary information in a Department by Sex spreadsheet
  
  =head1 ABSTRACT
  
  This perl package uses perl5 objects to make it easy for
  manipulating spreadsheet data among disk files, database, and Web
  publishing.
  
  A table object contains a header and a two-dimensional array of scalars.
  Four class methods Data::fromFile, Data::Table::fromCSV, Data::Table::fromTSV, and Data::Table::fromSQL allow users
  to create a table object from a CSV/TSV file or a database SQL selection in a snap.
  
  Table methods provide basic access, add, delete row(s) or column(s) operations, as well as more advanced sub-table extraction, table sorting,
  record matching via keywords or patterns, table merging, and web publishing.   
  Data::Table class also provides a straightforward interface to other
  popular Perl modules such as DBI and GD::Graph.
  
  The most updated version of the Perl Data::Table Cookbook is available at
   https://sites.google.com/site/easydatabase/
  
  We use Data::Table instead of Table, because Table.pm has already been used inside PerlQt module in CPAN.
  
  =head1 INTRODUCTION
  
  =over 4
  
  A table object has three data members:
  
  =item 1. $data:
  
  a reference to an array of array-references.
  It's basically a reference to a two-dimensional array.
  
  =item 2. $header:
  
  a reference to a string array. The array contains all the column names.
  
  =item 3. $type = 1 or 0.
  
  1 means that @$data is an array of table columns (fields) (column-based);
  0 means that @$data is an array of table rows (records) (row-based);
  
  =back
  
  Row-based/Column-based are two internal implementations for a table object.
  E.g., if a spreadsheet consists of two columns lastname and age.
  In a row-based table, $data = [ ['Smith', 29], ['Dole', 32] ].
  In a column-based table, $data = [ ['Smith', 'Dole'], [29, 32] ].
  
  Two implementations have their pros and cons for different operations.
  Row-based implementation is better for sorting and pattern matching,
  while column-based one is better for adding/deleting/swapping columns.
  
  Users only need to specify the implementation type of the table upon its
  creation via Data::Table::new, and can forget about it afterwards.
  Implementation type of a table should be considered volatile, because
  methods switch table objects from one type into another internally.
  Be advised that row/column/element references gained via table::rowRef,
  table::rowRefs, table::colRef, table::colRefs, or table::elmRef may
  become stale after other method calls afterwards.
  
  For those who want to inherit from the Data::Table class, internal method
  table::rotate is used to switch from one implementation type into another.
  There is an additional internal assistant data structure called
  colHash in our current implementation. This hash
  table stores all column names and their corresponding column index number as
  key-value pairs for fast conversion. This gives users an option to use
  column name wherever a column ID is expected, so that user don't have to use
  table::colIndex all the time. E.g., you may say
  $t->rename('oldColName', 'newColName')
  instead of $t->rename($t->colIndex('oldColName'), 'newColIdx').
  
  =head1 DESCRIPTION
  
  =head2 Field Summary
  
  =over 4
  
  =item data refto_arrayof_refto_array
  
  contains a two-dimensional spreadsheet data.
  
  =item header refto_array
  
  contains all column names.
  
  =item type 0/1
  
  0 is row-based, 1 is column-based, describe the orientation of @$data.
  
  =back
  
  =head2 Package Variables
  
  =over 4
  
  =item $Data::Table::VERSION
  
  =item @Data::Table::OK
  
  see table::match_string, table::match_pattern, and table::match_pattern_hash
  Since 1.62, we recommend you to use $table->{OK} instead, which is a local array reference.
  
  =item @Data::Table::MATCH
  
  see table::match_string, table::match_pattern, and table::match_pattern_hash
  Since 1.67, we return the matched row indices in an array.  Data::Table::MATCH is this array reference.
  Here is an example of setting a max price of 20 to all items with UnitPrice > 20.
  
      $t_product->match_pattern_hash('$_{UnitPrice} > 20');
      $t_product->setElm($t_product->{MATCH}, 'UnitPrice', 20);
  
  =item %Data::Table::DEFAULTS
  
  Store default settings, currently it contains CSV_DELIMITER (set to ','), CSV_QUALIFER (set to '"'), and OS (set to 0).
  see table::fromCSV, table::csv, table::fromTSV, table::tsv for details.
  
  =back
  
  =head2 Class Methods
  
  Syntax: return_type method_name ( [ parameter [ = default_value ]] [, parameter [ = default_value ]] )
  
  If method_name starts with table::, this is an instance method, it can be used as $t->method( parameters ), where $t is a table reference.
  
  If method_name starts with Data::Table::, this is a class method, it should be called as
    Data::Table::method, e.g., $t = Data::Table::fromCSV("filename.csv").
  
  Conventions for local variables:
  
    colID: either a numerical column index or a column name;
    rowIdx: numerical row index;
    rowIDsRef: reference to an array of column IDs;
    rowIdcsRef: reference to an array of row indices;
    rowRef, colRef: reference to an array of scalars;
    data: ref_to_array_of_ref_to_array of data values;
    header: ref to array of column headers;
    table: a table object, a blessed reference.
  
  =head2 Table Creation
  
  =over 4
  
  =item table Data::Table::new ( $data = [], $header = [], $type = 0, $enforceCheck = 1)
  
  create a new table.
  It returns a table object upon success, undef otherwise.
  $data: points to the spreadsheet data.
  $header: points to an array of column names. Before version 1.69, a column name must have at least one non-digit character. Since verison 1.69, this is relaxed. Although integer and numeric column names can now be accepted, when accessing a column by integer, it is first interpreted as a column name.
  $type: 0 or 1 for row-based/column-based spreadsheet. 
  $enforceCheck: 1/0 to turn on/off initial checking on the size of each row/column to make sure the data arguement indeed points to a valid structure.
  In 1.63, we introduce constants Data::Table::ROW_BASED and Data::Table::COL_BASED as synonyms for $type.  To create an empty Data::Table, use new Data::Table([], [], Data::Table::ROW_BASED);
  
  =item table table::subTable ($rowIdcsRef, $colIDsRef, $arg_ref)
  
  create a new table, which is a subset of the original.
  It returns a table object.
  $rowIdcsRef: points to an array of row indices (or a true/false row mask array).
  $colIDsRef: points to an array of column IDs.
  The function make a copy of selected elements from the original table. 
  Undefined $rowIdcsRef or $colIDsRef is interpreted as all rows or all columns.
  The elements in $colIDsRef may be modified as a side effect before version 1.62, fixed in 1.62.
  If $arg_ref->{useRowMask} is set to 1, $rowIdcsRef is a true/false row mask array, where rows marked as TRUE will be returned.  Row mask array is typically the Data::Table::OK set by match_string/match_pattern/match_pattern_hash methods.
  
  =item table table::clone
  
  make a clone of the original.
  It return a table object, equivalent to table::subTable(undef,undef).
  
  =item table Data::Table::fromCSV ($name_or_handler, $includeHeader = 1, $header = ["col1", ... ], {OS=>$Data::Table::DEFAULTS{'OS'}, delimiter=>$Data::Table::DEFAULTS{'CSV_DELIMITER'}, qualifier=>$Data::Table::DEFAULTS{'CSV_QUALIFIER'}, skip_lines=>0, skip_pattern=>undef, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a CSV file.
  return a table object.
  $name_or_handler: the CSV file name or an already opened file handler. If a handler is used, it's not closed upon return. To read from STDIN, use Data::Table::fromCSV(\*STDIN, 1).
  $includeHeader: 0 or 1 to ignore/interpret the first line in the file as column names,
  If it is set to 0, the array in $header is used. If $header is not supplied, the default column names are "col1", "col2", ...
  optional named argument OS specifies under which operating system the CSV file was generated. 0 for UNIX, 1 for PC and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used, which defaults to UNIX. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  
  optional name argument delimiter and qualifier let user replace comma and double-quote by other meaningful single characters. <b>Exception</b>: if the delimiter or the qualifier is a special symbol in regular expression, you must escape it by '\'. For example, in order to use pipe symbol as the delimiter, you must specify the delimiter as '\|'.
  
  optional name argument skip_lines let you specify how many lines in the csv file should be skipped, before the data are interpretted.
  
  optional name argument skip_pattern let you specify a regular expression. Lines that match the regular expression will be skipped.
  
  optional name argument encoding let you specify an encoding method of the csv file.  This option is added to fromCSV, fromTSV, fromFile since version 1.69.
  
  The following example reads a DOS format CSV file and writes a MAC format:
  
    $t = Data::Table:fromCSV('A_DOS_CSV_FILE.csv', 1, undef, {OS=>1});
    $t->csv(1, {OS=>2, file=>'A_MAC_CSV_FILE.csv'});
    open(SRC, 'A_DOS_CSV_FILE.csv') or die "Cannot open A_DOS_CSV_FILE.csv to read!";
    $t = Data::Table::fromCSV(\*SRC, 1);
    close(SRC);
  
  The following example reads a non-standard CSV file with : as the delimiter, ' as the qaulifier
  
    my $s="col_A:col_B:col_C\n1:2, 3 or 5:3.5\none:'one:two':'double\", single'''";
    open my $fh, "<", \$s or die "Cannot open in-memory file\n";
    my $t_fh=Data::Table::fromCSV($fh, 1, undef, {delimiter=>':', qualifier=>"'"});
    close($fh);
    print $t_fh->csv;
    # convert to the standard CSV (comma as the delimiter, double quote as the qualifier)
    # col_A,col_B,col_C
    # 1,"2, 3 or 5",3.5
    # one,one:two,"double"", single'"
    print $t->csv(1, {delimiter=>':', qualifier=>"'"}); # prints the csv file use the original definition
  
  The following example reads bbb.csv file (included in the package) by skipping the first line (skip_lines=>1), then treats any line that starts with '#' (or space comma) as comments (skip_pattern=>'^\s*#'), use ':' as the delimiter.
  
    $t = Data::Table::fromCSV("bbb.csv", 1, undef, {skip_lines=>1, delimiter=>':', skip_pattern=>'^\s*#'});
  
  Use the optional name argument encoding to specify file encoding method.
    $t = Data::Table::fromCSV("bbb.csv", 1, undef, {encoding=>'UTF-8'});
  
  =item table table::fromCSVi ($name, $includeHeader = 1, $header = ["col1", ... ])
  
  Same as Data::Table::fromCSV. However, this is an instant method (that's what 'i' stands for), which can be inherited.
  
  =item table Data::Table::fromTSV ($name, $includeHeader = 1, $header = ["col1", ... ], {OS=>$Data::Table::DEFAULTS{'OS'}, skip_lines=>0, skip_pattern=>undef, transform_element=>1, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a TSV file.
  return a table object.
  $name: the TSV file name or an already opened file handler. If a handler is used, it's not closed upon return.  To read from STDIN, use Data::Table::fromTSV(\*STDIN, 1).
  $includeHeader: 0 or 1 to ignore/interpret the first line in the file as column names,
  If it is set to 0, the array in $header is used. If $header is not supplied, the default column names are "col1", "col2", ...
  optional named argument OS specifies under which operating system the TSV file was generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used, which defaults to UNIX. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.  <b>Exception</b>: if the delimiter or the qualifier is a special symbol in regular expression, you must escape it by '\'. For example, in order to use pipe symbol as the delimiter, you must specify the delimiter as '\|'.
  
  optional name argument skip_lines let you specify how many lines in the csv file should be skipped, before the data are interpretted.
  
  optional name argument skip_pattern let you specify a regular expression. Lines that match the regular expression will be skipped.
  
  optional name argument transform_element let you switch on/off \t to tab, \N to undef (etc.) transformation. See TSV FORMAT for details. However, elements are always transformed when export table to tsv format, because not escaping an element containing a tab will be disasterous.
  
  optional name arugment encoding enables one to provide an encoding method when open the tsv file.
  
  See similar examples under Data::Table::fromCSV;
  
  Note: read "TSV FORMAT" section for details.
  
  =item table table::fromTSVi ($name, $includeHeader = 1, $header = ["col1", ... ])
  
  Same as Data::Table::fromTSV. However, this is an instant method (that's what 'i' stands for), which can be inherited.
  
  =item table Data::Table::fromFile ($file_name, $arg_ref = {linesChecked=>2, allowNumericHeader=>0, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a text file.
  return a table object.
  $file_name: the file name (cannot take a file handler).
  linesChecked: the first number of lines used for guessing the input format. The delimiter will have to produce the same number of columns for these lines. By default only check the first 2 lines, 0 means all lines in the file.
  $arg_ref can take additional parameters, such as OS, has_header, delimiter, transform_element, etc. Encoding allows one to specify encoding methods used to open the file, which defaults to UTF-8.
  
  fromFile is added after version 1.51. It relies on the following new methods to automatically figure out the correct file format in order to call fromCSV or fromTSV internally:
  
    fromFileGuessOS($file_name, {encoding=>'UTF-8'})
      returns integer, 0 for UNIX, 1 for PC, 2 for MAC
    fromFileGetTopLines($file_name, $os, $lineNumber, {encoding=>'UTF-8'}) # $os defaults to fromFileGuessOS($file_name), if not specified
      returns an array of strings, each string represents each row with linebreak removed.
    fromFileGuessDelimiter($lineArrayRef)       # guess delimiter from ",", "\t", ":";
      returns the guessed delimiter string.
    fromFileIsHeader($line_concent, $delimiter, $allowNumericHeader) # $delimiter defaults to $Data::Table::DEFAULTS{'CSV_DELIMITER'}
      returns 1 or 0.
  
  It first ask fromFileGuessOS to figure out which OS (UNIX, PC or MAC) generated the input file. The fetch the first linesChecked lines using fromFileGetTopLines. It then guesses the best delimiter using fromFileGuessDelimiter, then it checks if the first line looks like a column header row using fromFileIsHeader. Since fromFileGuessOS and fromFileGetTopLines needs to open/close the input file, these methods can only take file name, not file handler. If user specify formatting parameters in $arg_ref, the routine will skip the corresponding guess work. At the end, fromFile simply calls either fromCSV or fromTSV with $arg_ref forwarded. So if you call fromFile({transform_element=>0}) on a TSV file, transform_elment will be passed onto fromTSV calls internally.
  
  fromFileGuessOS finds the linebreak that gives shortest first line (in the priority of UNIX, PC, MAC upon tie).
  fromFileGuessDelimiter works based on the assumption that the correct delimiter will produce equal number of columns for the given rows. If multiple matches, it chooses the delimiter that gives maximum number of columns. If none matches, it returns the default delimiter.
  fromFileIsHeader works based on the assumption that no column header can be empty or numeric values.  However, if we allow numeric column names (especially integer column names), set {allowNumericHeader => 1}
  
  =item table Data::Table::fromSQL ($dbh, $sql, $vars)
  
  create a table from the result of an SQL selection query.
  It returns a table object upon success or undef otherwise.
  $dbh: a valid database handler. 
  Typically $dbh is obtained from DBI->connect, see "Interface to Database" or DBI.pm.
  $sql: an SQL query string or a DBI::st object (starting in version 1.61).
  $vars: optional reference to an array of variable values, 
  required if $sql contains '?'s which need to be replaced 
  by the corresponding variable values upon execution, see DBI.pm for details.
  Hint: in MySQL, Data::Table::fromSQL($dbh, 'show tables from test') will also create a valid table object.
  
  Data::Table::fromSQL now can take DBI::st instead of a SQL string. This is introduced, so that variable binding (such as CLOB/BLOB) can be done outside the method, for example:
  
    $sql = 'insert into test_table (id, blob_data) values (1, :val)';
    $sth = $dbh->prepare($sql);
    $sth->bind_param(':val', $blob, {ora_type => SQLT_BIN});
    Data::Table::fromSQL($dbh, $sth);
  
  =item table Data::Table::fromSQLi ($dbh, $sql, $vars)
  
  Same as Data::Table::fromSQL. However, this is an instant method (that's what 'i' stands for), whic
  h can be inherited.
  
  =back
  
  =head2 Table Access and Properties
  
  =over 4
  
  =item int table::colIndex ($colID)
  
  translate a column name into its numerical position, the first column has index 0 as in as any perl array.
  return -1 for invalid column names.
  
  Since 1.69, we allow integer to be used as a column header.  The integer $colID will first be checked against column names, if matched, the corresponding column index is returned. E.g., if column name for the 3rd column is "1", colIndex(1) will return 2 instead of 1! In such case, if one need to access the second column, one has to access it by column name, i.e., $t->col(($t->header)[1]).
  
  =item int table::nofCol
  
  return number of columns.
  
  =item int table::nofRow
  
  return number of rows.
  
  =item int table::lastCol
  
  return the index of the last columns, i.e., nofCol - 1.
  
  =item int table::lastRow
  
  return the index of the last rows, i.e., nofRow - 1; This is syntax sugar.
  
     # these two are equivalent
     foreach my $i (0 .. $t->lastRow)
     foreach my $i (0 .. $t->nofRow - 1)
  
  =item bool table::isEmpty
  
  return whether the table has any column, introduced in 1.63.
  
  =item bool table::hasCol($colID)
  
  returns whether the colID is a table column, introduced in 1.63.
  
  =item bool table::colName($colNumericIndex)
  
  returns the column name for a numeric column index, notice the first column has an index of 0. Introduced in 1.68.
  
  =item scalar table::elm ($rowIdx, $colID)
  
  return the value of a table element at [$rowIdx, $colID],
  undef if $rowIdx or $colID is invalid. 
  
  =item refto_scalar table::elmRef ($rowIdx, $colID)
  
  return the reference to a table element at [$rowIdx, $colID], to allow possible modification.
  It returns undef for invalid $rowIdx or $colID. 
  
  =item array table::header ($header)
  
  Without argument, it returns an array of column names.
  Otherwise, use the new header.
  
  =item int table::type
  
  return the implementation type of the table (row-based/column-based) at the time,
  be aware that the type of a table should be considered as volatile during method calls.
  
  =back
  
  =head2 Table Formatting
  
  =over 4
  
  =item string table::csv ($header, {OS=>$Data::Table::DEFAULTS{'OS'}, file=>undef, delimiter=>$Data::Table::DEFAULTS{'CSV_DELIMITER'}, qualifier=>$Data::Table::DEFAULTS{'CSV_QAULIFIER'}})
  
  return a string corresponding to the CSV representation of the table.
  $header controls whether to print the header line, 1 for yes, 0 for no.
  optional named argument OS specifies for which operating system the CSV file is generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  if 'file' is given, the csv content will be written into it, besides returning the string.
  One may specify custom delimiter and qualifier if the other than default are desired.
  
  =item string table::tsv
  
  return a string corresponding to the TSV representation of the table.
  $header controls whether to print the header line, 1 for yes, 0 for no.
  optional named argument OS specifies for which operating system the TSV file is generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  if 'file' is given, the tsv content will be written into it, besides returning the string.
  
  Note: read "TSV FORMAT" section for details.
  
  =item string table::html ($colorArrayRef_or_colorHashRef = ["#D4D4BF","#ECECE4","#CCCC99"], 
  			  $tag_tbl = {border => '1'},
                            $tag_tr  = {align => 'left'},
                            $tag_th  = {align => 'center'},
                            $tag_td  = {col3 => 'align="right" valign="bottom"', 4 => 'align="left"'},
                            $l_portrait = 1
                          )
  
  return a string corresponding to a 'Portrait/Landscape'-style html-tagged table.
  $colorArrayRef_or_colorHashRef: If a hash reference is provided, it will take three CSS class names for odd data rows, even data rows and for the header row.  The default hash is {even=>"data_table_even", odd=>"data_table_odd", header=>"data_table_header").
  If a hash reference is not found, a reference to an array of three color strings is expected to provided for backgrounds for even-row records, odd-row records, and -der row, respectively.  A default color array ("#D4D4BF","#ECECE4","#CCCC99") will be used if $colors isn't defined. 
  
  Before version 1.59, the parameter can only accept an array reference. 
  
  $tag_tbl: a reference to a hash that specifies any legal attributes such as name, border,
  id, class, etc. for the TABLE tag.
  
  $tag_tr: a reference to a hash that specifies any legal attributes for the TR tag.
  
  $tag_th: a reference to a hash that specifies any legal attributes for the TH tag.
  
  $tag_td: a reference to a hash that specifies any legal attributes for the TD tag.
  
  Notice $tag_tr and $tag_th controls all the rows and columns of the whole table. The keys of the hash are the attribute names in these cases. However, $tag_td is column specific, i.e., you should specify TD attributes for every column separately.
  The key of %$tag_td are either column names or column indices, the value is the full string to be inserted into the TD tag. E.g., $tag_td  = {col3 => 'align=right valign=bottom} only change the TD tag in "col3" to be &lt;TD align=right valign=bottom&gt;.
  
  $portrait controls the layout of the table. The default is 1, i.e., the table is shown in the
  "Portrait" style, like in Excel. 0 means "Landscape". Since version 1.59, tbody and thead tags are added to the portrait mode output.
  
  Attention: You will have to escape HTML-Entities yourself (for example '<' as '&lt;'), if you have characters in you table which need to be escaped. You can do this for example with the escapeHTML-function from CGI.pm (or the HTML::Entities module).
  
    use CGI qw(escapeHTML);
    [...]
    $t->colMap($columnname, sub{escapeHTML($_)}); # for every column, where HTML-Entities occur.
  
  =item string table::html2 ($colors = ["#D4D4BF","#ECECE4","#CCCC99"],
  		 	   $specs = {'name' => '', 'border' => '1', ...})
  
  This method is deprecated. It's here for compatibility. It now simple call html method with $portrait = 0, see previous description.
  
  return a string corresponding to a "Landscape" html-tagged table.
  This is useful to present a table with many columns, but very few entries.
  Check the above table::html for parameter descriptions.
  
  =back
  
  =head2 Table Operations
  
  =over 4
  
  =item int table::setElm ($rowIdx, $colID, $val)
  
  modify the value of a table element at [$rowIdx, $colID] to a new value $val.
  It returns 1 upon success, undef otherwise. 
  In 1.68, setElm can manipulate multiple elements, i.e., $rowIdx and $colIdx can be references to an index array, and setElm() will modifies all cells defined by the grid.
  
      $t->setElm([0..2], ['ColA', 'ColB'], 'new value');
      $t->setElm(0, [1..2], 'new value');
  
      # puts a limit on the price of all expensive items
      $t_product->match_pattern_hash('$_{UnitPrice} > 20');
      $t_product->setElm($t_product->{MATCH}, 'UnitPrice', 20);
  
  =item int table::addRow ($rowRef, $rowIdx = table::nofRow, $arg_ref = {addNewCol => 0})
  
  add a new row ($rowRef may point to the actual list of scalars, or it can be a hash_ref (supported since version 1.60)).  If $rowRef points to a hash, the method will lookup the value of a field by ts column name: $rowRef->{colName}, if not found, undef is used for that field.
  The new row will be referred as $rowIdx as the result. E.g., addRow($aRow, 0) will put the new row as the very first row. By default, it appends a row to the end.
  In 1.67, we support {addNewCol => 1}, if specified, a new column will be automatically created for each new element encountered in the $rowRef.
  
      # automatically add a new column "aNewColumn" to $t, in order to hold the new value
      $t->addRow({anExistingColumn => 123, aNewColumn => "XYZ"}, undef, {addNewCol => 1});
      # $t only had one column, after this call, it will contain a new column 'col2', in order to hold the new value
      $t->addRow([123, "XYZ"], undef, {addNewCol => 1});
  
  It returns 1 upon success, undef otherwise.
  
  =item refto_array table::delRow ( $rowIdx )
  
  delete a row at $rowIdx. It will the reference to the deleted row.
  
  =item refto_array table::delRows ( $rowIdcsRef )
  
  delete rows in @$rowIdcsRef. It will return an array of deleted rows in the same order of $rowIdcsRef upon success.
  upon success.
  
  =item int table::addCol ($colRef, $colName, $colIdx = numCol)
  
  add a new column ($colRef points to the actual data), the new column will be referred as $colName or $colIdx as the result. E.g., addCol($aCol, 'newCol', 0) will put the new column as the very first column.
  By default, append a column to the end.
  It will return 1 upon success or undef otherwise.
  In 1.68, $colRef can be a scalar, which is the default value that can be used to create the new column.  E.g., to create a new column with default value of undef, 0, 'default', respectively, one can do:
  
     $t->addCol(undef, 'NewCol');
     $t->addCol(0, 'NewIntCol');
     $t->addCol('default', 'NewStringCol');
  
  
  =item refto_array table::delCol ($colID)
  
  delete a column at $colID
  return the reference to the deleted column.
  
  =item arrayof_refto_array table::delCols ($colIDsRef)
  
  delete a list of columns, pointed by $colIDsRef. It will
  return an array of deleted columns in the same order of $colIDsRef  upon success.
  
  =item refto_array table::rowRef ($rowIdx)
  
  return a reference to the row at $rowIdx
  upon success or undef otherwise.
  
  =item refto_arrayof_refto_array table::rowRefs ($rowIdcsRef)
  
  return a reference to array of row references upon success, undef otherwise.
  
  =item array table::row ($rowIdx)
  
  return a copy of the row at $rowIdx 
  upon success or undef otherwise.
  
  =item refto_hash table::rowHashRef ($rowIdx)
  
  return a reference to a hash, which contains a copy of the row at $rowIdx,
  upon success or undef otherwise. The keys in the hash are column names, and
  the values are corresponding elements in that row. The hash is a copy, therefore modifying the hash values doesn't change the original table.
  
  =item refto_array table::colRef ($colID)
  
  return a reference to the column at $colID
  upon success.
  
  =item refto_arrayof_refto_array table::colRefs ($colIDsRef)
  
  return a reference to array of column references upon success.
  
  =item array table::col ($colID)
  
  return a copy to the column at $colID
  upon success or undef otherwise.
  
  =item int table::rename ($colID, $newName)
  
  rename the column at $colID to a $newName 
  (the newName must be valid, 
  and should not be identical to any other existing column names).
  It returns 1 upon success
  or undef otherwise.
  
  =item refto_array table::replace ($oldColID, $newColRef, $newName)
  
  replace the column at $oldColID by the array pointed by $newColRef, and renamed it to $newName. $newName is optional if you don't want to rename the column.
  It returns 1 upon success or undef otherwise.
  
  =item int table::swap ($colID1, $colID2)
  
  swap two columns referred by $colID1 and $colID2.
  It returns 1 upon success or undef otherwise.
  
  =item int table::moveCol($colID, $colIdx, $newColName)
  
  move column referred by $colID to a new location $colIdx.
  If $newColName is specified, the column will be renamed as well.
  It returns 1 upon success or undef otherwise.
  
  =item int table::reorder($colIDRefs, $arg_ref)
  
  Rearrange the columns according to the order specified in $colIDRef.  Columns not specified in the reference array will be appended to the end!
  If one would like to drop columns not specified, set $arg_ref to {keepRest => 0}.
  reorder() changes the table itself, while subTable(undef, $colIDRefs) will return a new table.  reorder() might also runs faster than subTable, as elements may not need to be copied.
  
  =item int table::colMap ($colID, $fun)
  
  foreach element in column $colID, map a function $fun to it.
  It returns 1 upon success or undef otherwise.
  This is a handy way to format a column. E.g. if a column named URL contains URL strings, colMap("URL", sub {"<a href='$_'>$_</a>"}) before html() will change each URL into a clickable hyper link while displayed in a web browser.
  
  =item int table::colsMap ($fun)
  
  foreach row in the table, map a function $fun to it.
  It can do whatever colMap can do and more.
  It returns 1 upon success or undef otherwise.
  colMap function only give $fun access to the particular element per row, while colsMap give $fun full access to all elements per row. E.g. if two columns named duration and unit (["2", "hrs"], ["30", "sec"]). colsMap(sub {$_->[0] .= " (".$_->[1].")"; } will change each row into (["2 hrs", "hrs"], ["30 sec", "sec"]).
  As show, in the $func, a column element should be referred as $_->[$colIndex].
  
  =item int table::sort($colID1, $type1, $order1, $colID2, $type2, $order2, ... )
  
  sort a table in place.
  First sort by column $colID1 in $order1 as $type1, then sort by $colID2 in $order2 as $type2, ...
  $type is 0 for numerical and 1 for others;
  $order is 0 for ascending and 1 for descending;
  
  In 1.62, instead of memorize these numbers, you can use constants instead (notice constants do not start with '$').
    Data::Table::NUMBER
    Data::Table::STRING
    Data::Table::ASC
    Data::Table::DESC
  
  Sorting is done in the priority of colID1, colID2, ...
  It returns 1 upon success or undef otherwise. 
  Notice the table is rearranged as a result! This is different from perl's list sort, which returns a sorted copy while leave the original list untouched, 
  the authors feel inplace sorting is more natural.
  
  table::sort can take a user supplied operator, this is useful when neither numerical nor alphabetic order is correct.
  
    $Well=["A_1", "A_2", "A_11", "A_12", "B_1", "B_2", "B_11", "B_12"];
    $t = new Data::Table([$Well], ["PlateWell"], 1);
    $t->sort("PlateWell", 1, 0);
    print join(" ", $t->col("PlateWell"));
    # prints: A_1 A_11 A_12 A_2 B_1 B_11 B_12 B_2
    # in string sorting, "A_11" and "A_12" appears before "A_2";
    my $my_sort_func = sub {
      my @a = split /_/, $_[0];
      my @b = split /_/, $_[1];
      my $res = ($a[0] cmp $b[0]) || (int($a[1]) <=> int($b[1]));
    };
    $t->sort("PlateWell", $my_sort_func, 0);
    print join(" ", $t->col("PlateWell"));
    # prints the correct order: A_1 A_2 A_11 A_12 B_1 B_2 B_11 B_12
  
  =item table table::match_pattern ($pattern, $countOnly)
  
  return a new table consisting those rows evaluated to be true by $pattern 
  upon success or undef otherwise. If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK (should use $t->{OK} after 1.62) stores a true/false array for the original table rows. Using it, users can find out what are the rows being selected/unselected.
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  
  In the $pattern string, a column element should be referred as $_->[$colIndex]. E.g., match_pattern('$_->[0]>3 && $_->[1]=~/^L') retrieve all the rows where its first column is greater than 3 and second column starts with letter 'L'. Notice it only takes colIndex, column names are not acceptable here!
  
  =item table table::match_pattern_hash ($pattern, $countOnly)
  
  return a new table consisting those rows evaluated to be true by $pattern
  upon success or undef otherwise. If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK stores a reference to a true/false array for the original table rows. Using it, users can find out what are the rows being selected/unselected.
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  
  In the $pattern string, a column element should be referred as ${column_name}.
  match_pattern_hash() is added in 1.62. The difference between this method and match_pattern is each row is fed to the pattern as a hash %_.
  In the case of match_pattern, each row is fed as an array ref $_.  The pattern for match_pattern_hash() becomes much cleaner.
  
  If a table has two columns: Col_A as the 1st column and Col_B as the 2nd column, a filter "Col_A>2 AND Col_B<2" is written before as
  	$t->match_pattern('$_->[0] > 2 && $_->[1] <2');
  where we need to figure out $t->colIndex('Col_A') is 0 and $t->colIndex('Col_B') is 1, in order to build the pattern.
  Now you can use column name directly in the pattern:
  	$t->match_pattern_hash('$_{Col_A} >2 && $_{Col_B} <2');
  This method creates $t->{OK}, as well as @Data::Table::OK, same as match_pattern().
  
  =item table table::match_string ($s, $caseIgnore, $countOnly)
  
  return a new table consisting those rows contains string $s in any of its fields upon success, undef otherwise. if $caseIgnore evaluated to true, case will is be ignored (s/$s/i). If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK stores a reference to a true/false array for the original table rows. 
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  Using it, users can find out what are the rows being selected/unselected.
  The $s string is actually treated as a regular expression and 
  applied to each row element, therefore one can actually specify several keywords 
  by saying, for instance, match_string('One|Other').
  
  =item table table::rowMask($mask, $complement)
  
  mask is reference to an array, where elements are evaluated to be true or false. The size of the mask must be equal to the nofRow of the table. return a new table consisting those rows where the corresponding mask element is true (or false, when complement is set to true).
  
  E.g., $t1=$tbl->match_string('keyword'); $t2=$tbl->rowMask(\@Data::Table::OK, 1) creates two new tables. $t1 contains all rows match 'keyword', while $t2 contains all other rows.
  
  mask is reference to an array, where elements are evaluated to be true or false. The size of the mask must be equal to the nofRow of the table. return
   a new table consisting those rows where the corresponding mask element is true (or false, when complement is set to true).
  
  E.g., $t1=$tbl->match_string('keyword'); $t2=$tbl->rowMask(\@Data::Table::OK, 1) creates two new tables. $t1 contains all rows match 'keyword', while 
  $t2 contains all other rows.
  
  =item table table::iterator({$reverse => 0})
  
  Returns a reference to a enumerator routine, which enables one to loop through each table row. If $reverse is set to 1, it will enumerate backward.  The convenience here is each row is fetch as a rowHashRef, so one can easily access row elements by name.
  
      my $next = $t_product->iterator();
      while (my $row = $next->()) {
        # have access to a row as a hash reference, access row number by &$next(1);
        $t_product->setElm($next->(1), 'ProductName', 'New! '.$row->{ProductName});
      }
  
  In this example, each $row is fetched as a hash reference, so one can access the elements by $row->{colName}.
  Be aware that the elements in the hash is a copy of the original table elements, so modifying $row->{colName} does not modify the original table.  If table modification is intended, one needs to obtain the row index of the returned row.  $next->(1) call with a non-empty argument returns the row index of the record that was previously fetched with $next->().  In this example, one uses the row index to modify the original table.
  
  =item table table::each_group($colsToGroupBy, $funsToApply)
  
  Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first (keys sorted as string). Then for each group, subroutines $funToAppy is applied to corresponding rows.
  $funToApply are passed with two parameters ($tableRef, $rowIDsRef). All rows sharing the key are passed in as a Data::Table object (with all columns and in the order of ascending row index) in the first parameter.
  The second optional parameter contains an array of row indices of the group members.  Since all rows in the passed-in table contains the same keys, the key value can be obtained from its first table row.
  
  =item table table::group($colsToGroupBy, $colsToCalculate, $funsToApply, $newColNames, $keepRestCols)
  
  Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first. Then for each group, an array of subroutines (in $funsToAppy) are applied to corresponding columns and yield a list of new columns (specified in $newColNames).
  
  $colsToGroupBy, $colsToCalculate are references to array of colIDs. $funsToApply is a reference to array of subroutine references. $newColNames are a
  reference to array of new column name strings. If specified, the size of arrays pointed by $colsToCalculate, $funsToApply and $newColNames should be i
  dentical. A column may be used more than once in $colsToCalculate. 
  
  $keepRestCols is default to 1 (was introduced as 0 in 1.64, changed to 1 in 1.66 for backward compatibility) introduced in 1.64), otherwise, the remaining columns are returned with the first encountered value of that group.
  
  E.g., an employee salary table $t contains the following columns: Name, Sex, Department, Salary. (see examples in the SYNOPSIS)
  
    $t2 = $t->group(["Department","Sex"],["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"], 0);
  
  Department, Sex are used together as the primary key columns, a new column "Nof Employee" is created by counting the number of employee names in each group, a new column "Average Salary" is created by averaging the Salary data falled into each group. As the result, we have the head count and average salary information for each (Department, Sex) pair. With your own functions (such as sum, product, average, standard deviation, etc), group method is very handy for accounting purpose.
  If primary key columns are not defined, all records will be treated as one group.
  
    $t2 = $t->group(undef,["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"], 0);
  
  The above statement will output the total number of employees and their average salary as one line.
  
  =item table table::pivot($colToSplit, $colToSplitIsStringOrNumeric, $colToFill, $colsToGroupBy, $keepRestCols)
  
  Every unique values in a column (specified by $colToSplit) become a new column. undef value become "NULL".  $colToSplitIsStringOrNumeric is set to numeric (0 or Data::Table:NUMBER), the new column names are prefixed by "oldColumnName=". The new cell element is filled by the value specified by $colToFill (was 1/0 before version 1.63).
  
  Note: yes, it seems I made an incompatible change in version 1.64, where $colToSplitIsStringOrNumber used to be $colToSplitIsNumeric, where 0 meant STRING and 1 meant NUMBER.  Now it is opposite.  However, I also added auto-type detection code, that this parameter essentially is auto-guessed and most old code should behave the same as before.
  
  When primary key columns are specified by $colsToGroupBy, all records sharing the same primary key collapse into one row, with values in $colToFill filling the corresponding new columns. If $colToFill is not specified, a cell is filled with the number of records fall into that cell.
  
  $colToSplit and $colToFill are colIDs. $colToSplitIsNumeric is 1/0. $colsToGroupBy is a reference to array of colIDs. $keepRestCols is 1/0, by default is 0. If $keepRestCols is off, only primary key columns and new columns are exported, otherwise, all the rest columns are exported as well.
  
  E.g., applying pivot method to the resultant table of the example of the group method.
  
    $t2->pivot("Sex", 0, "Average Salary",["Department"]);
  
  This creates a 2x3 table, where Departments are use as row keys, Sex (female and male) become two new columns. "Average Salary" values are used to fill the new table elements. Used together with group method, pivot method is very handy for accounting type of analysis.
  If $colsToGroupBy is left as undef, all rows are treated as one group.  If $colToSplit is left as undef, the method will generate a column named "(all)" that matches all records share the corresponding primary key.
  
  =item table table::melt($keyCols, $variableCols, $arg_ref)
  
  The idea of melt() and cast() are taken from Hadley Wickham's Reshape package in R language.
  A table is first melt() into a tall-skiny format, where measurements are stored in the format of a variable-value pair per row.
  Such a format can then be easily cast() into various contingency tables.
  
  One needs to specify the columns consisting of primary keys, columns that are consider as variable columns.  The output variable column is named 'variable' unless specified by $arg_ref{variableColName}.  The output value column is named 'value', unless specified in $arg_ref{valueColName}.  By default NULL values are not output, unless $arg_ref{skip_NULL} is set to false.  By default empty string values are kept, unless one sets skip_empty to `.
  
    For each object (id), we measure variable x1 and x2 at two time points
    $t = new Data::Table([[1,1,5,6], [1,2,3,5], [2,1,6,1], [2,2,2,4]], ['id','time','x1','x2'], Data::Table::ROW_BASED);
    # id	time	x1	x2
    # 1	1	5	6
    # 1	2	3	5
    # 2	1	6	1
    # 2	2	2	4
  
    # melting a table into a tall-and-skinny table
    $t2 = $t->melt(['id','time']);
    #id      time    variable        value
    # 1       1       x1      5
    # 1       1       x2      6
    # 1       2       x1      3
    # 1       2       x2      5
    # 2       1       x1      6
    # 2       1       x2      1
    # 2       2       x1      2
    # 2       2       x2      4
    
    # casting the table, &average is a method to calculate mean
    # for each object (id), we calculate average value of x1 and x2 over time
    $t3 = $t2->cast(['id'],'variable',Data::Table::STRING,'value', \&average);
    # id      x1      x2
    # 1       4       5.5
    # 2       4       2.5
   
  
  =item table table::cast($colsToGroupBy, $colToSplit, $colToSplitIsStringOrNumeric, $colToCalculate, $funToApply)
  
  see melt(), as melt() and cast() are meant to use together.
  
  The table has been melten before.  cast() group the table according to primary keys specified in $colsToGroupBy. For each group of objects sharing the same id,
  it further groups values (specified by $colToCalculate) according to unique variable names (specified by $colToSplit).  Then it applies subroutine $funToApply to obtain an aggregate value.
  For the output, each unique primary key will be a row, each unique variable name will become a column, the cells are the calculated aggregated value.
  
  If $colsToGroupBy is undef, all rows are treated as within the same group.  If $colToSplit is undef, a new column "(all)" is used to hold the results.
  
    $t = new Data::Table( # create an employ salary table
      [
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Peter', 'male', 'HR', 85000],
        ['Mary', 'female', 'HR', 80000],
        ['Nancy', 'female', 'IT', 55000],
        ['Jack', 'male', 'IT', 88000],
        ['Susan', 'female', 'HR', 92000]
      ],
      ['Name', 'Sex', 'Department', 'Salary'], Data::Table::ROW_BASED);
  
    # get a Department x Sex contingency table, get average salary across all four groups
    print $t->cast(['Department'], 'Sex', Data::Table::STRING, 'Salary', \&average)->csv(1);
    Department,female,male
    IT,55000,73600
    HR,86000,85000
    # get average salary for each department
    print $t->cast(['Department'], undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    Department,(all)
    IT,70500
    HR,85666.6666666667
  
    # get average salary for each gender
    print $t->cast(['Sex'], undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    Sex,(all)
    male,75500
    female,75666.6666666667
    
    # get average salary for all records
    print $t->cast(undef, undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    (all)
    75555.5555555556
  
  =back
  
  =head2 Table-Table Manipulations
  
  =over 4
  
  =item int table::rowMerge ($tbl, $argRef)
  
  Append all the rows in the table object $tbl to the original rows.
  Before 1.62, the merging table $tbl must have the same number of columns as the original, as well as the columns are in exactly the same order.
  It returns 1 upon success, undef otherwise.
  The table object $tbl should not be used afterwards, since it becomes part of
  the new table.
  
  Since 1.62, you may provide {byName =>1, addNewCol=>1} as $argRef.  If byName is set to 1, the columns in in $tbl do not need to be in the same order as they are in the first table, instead the column name is used for the matching.  If addNewCol is set to 1, if $tbl contains a new column name that does not already exist in the first table, this new column will be automatically added to the resultant table.  Typically, you want to specify there two options simultaneously.
  
  =item int table::colMerge ($tbl, $argRef)
  
  Append all the columns in table object $tbl to the original columns. 
  Table $tbl must have the same number of rows as the original.
  It returns 1 upon success, undef otherwise.
  Table $tbl should not be used afterwards, since it becomes part of
  the new table.
  
  Since 1.62, you can specify {renameCol => 1} as $argRef. This is to auto fix any column name collision.  If $tbl contains a column that already exists in the first table, it will be renamed (by a suffix _2) to avoid the collision.
  
  =item table table::join ($tbl, $type, $cols1, $cols2, $argRef)
  
  Join two tables. The following join types are supported (defined by $type):
  
  0: inner join
  1: left outer join
  2: right outer join
  3: full outer join
  
  In 1.62, instead of memorize these numbers, you can use constants instead (notice constants do not start with '$').
    Data::Table::INNER_JOIN
    Data::Table::LEFT_JOIN
    Data::Table::RIGHT_JOIN
    Data::Table::FULL_JOIN
  
  $cols1 and $cols2 are references to array of colIDs, where rows with the same elements in all listed columns are merged. As the result table, columns listed in $cols2 are deleted, before a new table is returned.
  
  The implementation is hash-join, the running time should be linear with respect to the sum of number of rows in the two tables (assume both tables fit in memory).
  
  If the non-key columns of the two tables share the same name, the routine will fail, as the result table cannot contain two columns of the same name.  In 1.62, one can specify {renameCol=>1} as $argRef, so that the second column will be automatically renamed (with suffix _2) to avoid collision.
  
  If you would like to treat the NULLs in the key columns as empty string, set {NULLasEmpty => 1}.  If you do not want to treat NULLs as empty strings, but you still like the NULLs in two tables to be considered as equal (but not equal to ''), set {matchNULL => 1}.  Obviously if NULLasEmpty is set to 1, matchNULL will have no effect.
  
  =back
  
  =head2 Internal Methods
  
  All internal methods are mainly implemented for used by 
  other methods in the Table class. Users should avoid using them.
  Nevertheless, they are listed here for developers who 
  would like to understand the code and may derive a new class from Data::Table.
  
  =over 4
  
  =item int table::rotate
  
  convert the internal structure of a table between row-based and column-based.
  return 1 upon success, undef otherwise.
  
  =item string csvEscape($string, {delimiter=>, qualifier})
  
  Encode a scalar into a CSV-formatted field.
  
  optional named arguments: delimiter and qualifier, in case user wants to use characters other than the defaults. 
  The default delimiter and qualifier is taken from $Data::Table::DEFAULTS{'CSV_DELIMITER'} (defaults to ',') and $Data::Table::DEFAULTS{'CSV_QUALIFIER'} (defaults to '"'), respectively.
  
  Please note that this function only escape one element in a table. To escape the whole table row, you need to
    join($delimiter, map {csvEscape($_)} @row . $endl;
  $endl refers to End-of-Line, which you may or may not want to add, and it is OS-dependent. Therefore, csvEscape method is kept to the simplest form as an element transformer.
  
  =item refto_array parseCSV($string)
  
  Break a CSV encoded string to an array of scalars (check it out, we did it the cool way).
  
  optional argument size: specify the expected number of fields after csv-split.
  optional named arguments: delimiter and qualifier, in case user wants to use characters other than the defaults.
  respectively. The default delimiter and qualifier is taken from $Data::Table::DEFAULTS{'CSV_DELIMITER'} (defaults to ',') and $Data::Table::DEFAULTS{'CSV_QUALIFIER'} (defaults to '"'), respectively.
  
  =item string tsvEscape($rowRef)
  
  Encode a scalar into a TSV-formatted string.
  
  =back
  
  =head1 TSV FORMAT
  
  There is no standard for TSV format as far as we know. CSV format can't handle binary data very well, therefore, we choose the TSV format to overcome this limitation.
  
  We define TSV based on MySQL convention.
  
    "\0", "\n", "\t", "\r", "\b", "'", "\"", and "\\" are all escaped by '\' in the TSV file.
    (Warning: MySQL treats '\f' as 'f', and it's not escaped here)
    Undefined values are represented as '\N'.
  
  However, you can switch off this transformation by setting {transform_element => 0} in the fromTSV or tsv method.
  Before if a cell reads 'A line break is \n', it is read in as 'A link break is [return]' in memory. When use tsv method to export, it is transformed back to 'A line break is \n'. However, if it is exported as a csv, the [return] will break the format. Now if transform_element is set to 0, the cell is stored as 'A line break is \n' in memory, so that csv export will be correct. However, do remember to set {transform_element => 0} in tsv export method, otherwise, the cell will become 'A line break is \\n'. Be aware that trasform_element controls column headers as well.
  
  =head1 INTERFACE TO OTHER SOFTWARES
  
  Spreadsheet is a very generic type, therefore Data::Table class provides an easy
  interface between databases, web pages, CSV/TSV files, graphics packages, etc.
  
  Here is a summary (partially repeat) of some classic usages of Data::Table.
  
  =head2 Interface to Database and Web
  
    use DBI;
  
    $dbh= DBI->connect("DBI:mysql:test", "test", "") or die $DBI::errstr;
    my $minAge = 10;
    $t = Data::Table::fromSQL($dbh, "select * from mytable where age >= ?", [$minAge]);
    print $t->html;
  
  =head2 Interface to CSV/TSV
  
    $t = fromFile("mydata.csv"); # after version 1.51
    $t = fromFile("mydata.tsv"); # after version 1.51
  
    $t = fromCSV("mydata.csv");
    $t->sort(1,1,0);
    print $t->csv;
  
    Same for TSV
  
  =head2 Interface to Excel XLS/XLSX
  
  Read in two tables from NorthWind.xls file, writes them out to XLSX format.  See Data::Table::Excel module for details.
  
    use Data::Table::Excel;
  
    my ($tableObjects, $tableNames)=xls2tables("NorthWind.xls");
    $t_category = $tableObjects[0];
    $t_product = $tableObjects[1];
  
    tables2xlsx("NorthWind.xlsx", [$t_category, $t_product]);
  
  =head2 Interface to Graphics Package
  
    use GD::Graph::points;
  
    $graph = GD::Graph::points->new(400, 300);
    $t2 = $t->match('$_->[1] > 20 && $_->[3] < 35.7');
    my $gd = $graph->plot($t->colRefs([0,2]));
    open(IMG, '>mygraph.png') or die $!;
    binmode IMG;
    print IMG $gd->png;
    close IMG;
  
  =head1 AUTHOR
  
  Copyright 1998-2008, Yingyao Zhou & Guangzhou Zou. All rights reserved.
  
  It was first written by Zhou in 1998, significantly improved and maintained by Zou since 1999. The authors thank Tong Peng and Yongchuang Tao for valuable suggestions. We also thank those who kindly reported bugs, some of them are acknowledged in the "Changes" file.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please send bug reports and comments to: easydatabase at gmail dot com. When sending
  bug reports, please provide the version of Table.pm, the version of
  Perl.
  
  =head1 SEE ALSO
  
    DBI, GD::Graph, Data::Table::Excel.
  
  =cut
  
DATA_TABLE

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.12';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  $Devel::StackTrace::VERSION = '1.31';
  BEGIN {
    $Devel::StackTrace::AUTHORITY = 'cpan:DROLSKY';
  }
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      # Backwards compatibility - this parameter was renamed to no_refs
      # ages ago.
      $p{no_refs} = delete $p{no_object_refs}
          if exists $p{no_object_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data();
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      # We exclude this method by starting one frame back.
      my $x = 1;
      while (
          my @c
          = $self->{no_args}
          ? caller( $x++ )
          : do {
              package    # the newline keeps dzil from adding a version here
                  DB;
              @DB::args = ();
              caller( $x++ );
          }
          ) {
  
          my @args;
  
          unless ( $self->{no_args} ) {
              @args = @DB::args;
  
              if ( $self->{no_refs} ) {
                  @args = map { ref $_ ? $self->_ref_to_string($_) : $_ } @args;
              }
          }
  
          push @{ $self->{raw} },
              {
              caller => \@c,
              args   => \@args,
              };
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      local $@;
      local $SIG{__DIE__};
  
      my $str = eval { $ref . '' };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next unless $filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub { 1 };
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          local $@;
          local $SIG{__DIE__};
  
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless eval { @{ $self->{ignore_package} } };
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $p    = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $p,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames();
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames();
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  }
  
  sub frames {
      my $self = shift;
  
      if (@_) {
          die
              "Devel::StackTrace->frames() can only take Devel::StackTrace::Frame args\n"
              if grep { !$_->isa('Devel::StackTrace::Frame') } @_;
  
          $self->{frames} = \@_;
      }
      else {
          $self->_make_frames() if $self->{raw};
      }
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames() )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames() );
  }
  
  sub as_string {
      my $self = shift;
      my $p    = shift;
  
      my $st    = '';
      my $first = 1;
      foreach my $f ( $self->frames() ) {
          $st .= $f->as_string( $first, $p ) . "\n";
          $first = 0;
      }
  
      return $st;
  }
  
  {
      package
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 1.31
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new();
  
    print $trace->as_string(); # like carp
  
    # from top (most recent) of stack to bottom.
    while ( my $frame = $trace->next_frame() ) {
        print "Has args\n" if $frame->hasargs();
    }
  
    # from bottom (least recent) of stack to top.
    while ( my $frame = $trace->prev_frame() ) {
        print "Sub: ", $frame->subroutine(), "\n";
    }
  
  =head1 DESCRIPTION
  
  The C<Devel::StackTrace> module contains two classes, C,Devel::StackTrace> and
  L<Devel::StackTrace::Frame>. These objects encapsulate the information that
  can retrieved via Perl's C<caller()> function, as well as providing a simple
  interface to this data.
  
  The C<Devel::StackTrace> object contains a set of C<Devel::StackTrace::Frame>
  objects, one for each level of the stack. The frames contain all the data
  available from C<caller()>.
  
  This code was created to support my L<Exception::Class::Base> class (part of
  L<Exception::Class>) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top' and
  'bottom'. In this context, the 'top' frame on the stack is the most recent
  frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new();  # top frame is here.
    }
  
  =head1 METHODS
  
  This class provide the following methods:
  
  =head2 Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 4
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the
  call to its constructor.
  
  However, you may want to filter out some frames with more granularity
  than 'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data
  for each frame. This is a hash reference with two keys, "caller", and
  "args", both of which are array references. The "caller" key is the
  raw data as returned by Perl's C<caller()> function, and the "args"
  key are the subroutine arguments found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or
  false if it should be skipped.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on
  the stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages
  (or is the same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package'
  parameter, meaning that the Devel::StackTrace package is B<ALWAYS>
  ignored. However, if you create a subclass of Devel::StackTrace it
  will not be ignored.
  
  =item * no_refs => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store
  references internally when generating stacktrace frames. This lets
  your objects go out of scope.
  
  Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * no_args => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store caller
  arguments in stack trace frames at all.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef()> to get
  the underlying string representation of an object, instead of
  respecting the object's stringification overloading. If you would
  prefer to see the overloaded representation of objects in stack
  traces, then set this parameter to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for each
  subroutine call. Setting this parameter causes truncates each subroutine
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess()>.
  
  =back
  
  =head2 $trace->next_frame()
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going
  down. If this method hasn't been called before it returns the first frame. It
  returns C<undef> when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<< $trace->next_frame() >> or C<<
  $trace->prev_frame() >> will work properly.
  
  =head2 $trace->prev_frame()
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going up. If
  this method hasn't been called before it returns the last frame. It returns
  undef when it reaches the top of the stack and then resets its pointer so the
  next call to C<< $trace->next_frame() >> or C<< $trace->prev_frame() >> will
  work properly.
  
  =head2 $trace->reset_pointer
  
  Resets the pointer so that the next call to C<< $trace->next_frame() >> or C<<
  $trace->prev_frame() >> will start at the top or bottom of the stack, as
  appropriate.
  
  =head2 $trace->frames()
  
  When this method is called with no arguments, it returns a list of
  L<Devel::StackTrace::Frame> objects. They are returned in order from top (most
  recent) to bottom.
  
  This method can also be used to set the object's frames if you pass it a list
  of L<Devel::StackTrace::Frame> objects.
  
  This is useful if you want to filter the list of frames in ways that are more
  complex than can be handled by the C<< $trace->filter_frames() >> method:
  
    $stacktrace->frames( my_filter( $stacktrace->frames() ) );
  
  =head2 $trace->frame($index)
  
  Given an index, this method returns the relevant frame, or undef if there is
  no frame at that index. The index is exactly like a Perl array. The first
  frame is 0 and negative indexes are allowed.
  
  =head2 $trace->frame_count()
  
  Returns the number of frames in the trace object.
  
  =head2 $trace->as_string(\%p)
  
  Calls C<< $frame->as_string() >> on each frame from top to bottom, producing
  output quite similar to the Carp module's cluck/confess methods.
  
  The optional C<\%p> parameter only has one option. The C<max_arg_length>
  parameter truncates each subroutine argument's string representation if it is
  longer than this number of characters.
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AStackTrace
  or via email at bug-devel-stacktrace@rt.cpan.org.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  $Devel::StackTrace::Frame::VERSION = '1.31';
  BEGIN {
    $Devel::StackTrace::Frame::AUTHORITY = 'cpan:DROLSKY';
  }
  
  use strict;
  use warnings;
  
  # Create accessor routines
  BEGIN {
      no strict 'refs';
      foreach my $f (
          qw( package filename line subroutine hasargs
          wantarray evaltext is_require hints bitmask args )
          ) {
          next if $f eq 'args';
          *{$f} = sub { my $s = shift; return $s->{$f} };
      }
  }
  
  {
      my @fields = (
          qw( package filename line subroutine hasargs wantarray
              evaltext is_require hints bitmask )
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@fields} = @{ shift() };
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          $self->{args} = shift;
  
          $self->{respect_overload} = shift;
  
          $self->{max_arg_length} = shift;
  
          $self->{message} = shift;
  
          $self->{indent} = shift;
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
      my $p     = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked.  All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  $_ = "undef", next unless defined $_;
  
                  # hack!
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
  
                  local $SIG{__DIE__};
                  local $@;
  
                  eval {
                      my $max_arg_length
                          = exists $p->{max_arg_length}
                          ? $p->{max_arg_length}
                          : $self->{max_arg_length};
  
                      if ( $max_arg_length
                          && length $_ > $max_arg_length ) {
                          substr( $_, $max_arg_length ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 1.31
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =for Pod::Coverage new
  
  =head1 METHODS
  
  See Perl's C<caller()> documentation for more information on what these
  methods return.
  
  =head2 $frame->package()
  
  =head2 $frame->filename()
  
  =head2 $frame->line()
  
  =head2 $frame->subroutine()
  
  =head2 $frame->hasargs()
  
  =head2 $frame->wantarray()
  
  =head2 $frame->evaltext()
  
  Returns undef if the frame was not part of an eval.
  
  =head2 $frame->is_require()
  
  Returns undef if the frame was not part of a require.
  
  =head2 $frame->args()
  
  Returns the arguments passed to the frame.  Note that any arguments
  that are references are returned as references, not copies.
  
  =head2 $frame->hints()
  
  =head2 $frame->bitmask()
  
  =head2 $frame->as_string()
  
  Returns a string containing a description of the frame.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE_FRAME

$fatpacked{"Devel/TypeTiny/Perl56Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL56COMPAT';
  package Devel::TypeTiny::Perl56Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  
  #### B doesn't provide perlstring() in 5.6. Monkey patch it.
  
  use B ();
  
  unless (exists &B::perlstring)
  {
  	my $d;
  	*B::perlstring = sub {
  		no warnings 'uninitialized';
  		require Data::Dumper;
  		$d ||= 'Data::Dumper'->new([])->Indent(0)->Purity(0)->Pad('')->Useqq(1)->Terse(1)->Freezer('')->Toaster('');
  		my $perlstring = $d->Values([''.shift])->Dump;
  		($perlstring =~ /^"/) ? $perlstring : qq["$perlstring"];
  	};
  }
  
  push @B::EXPORT_OK, 'perlstring';
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl56Compat - shims to allow Type::Tiny to run on Perl 5.6.x
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<B> to export a
  C<perlstring> function, as this was only added in Perl 5.8.0.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL56COMPAT

$fatpacked{"Devel/TypeTiny/Perl58Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL58COMPAT';
  package Devel::TypeTiny::Perl58Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  
  #### re doesn't provide is_regexp in Perl < 5.10
  
  eval 'require re';
  
  unless (exists &re::is_regexp)
  {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object($_[0])->MAGIC->TYPE eq 'r' };
  	};
  }
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl58Compat - shims to allow Type::Tiny to run on Perl 5.8.x
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<re> to provide a
  C<is_regexp> function, as this was only added in Perl 5.9.5.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL58COMPAT

$fatpacked{"Error/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY';
  package Error::TypeTiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::VERSION   = '0.038';
  }
  
  use overload
  	q[""]    => sub { $_[0]->to_string },
  	q[bool]  => sub { 1 },
  	fallback => 1,
  ;
  
  our %CarpInternal;
  $CarpInternal{$_}++ for qw(
  	Eval::TypeTiny
  	Eval::TypeTiny::Sandbox
  	Exporter::Tiny
  	Test::TypeTiny
  	Type::Coercion
  	Type::Coercion::Union
  	Error::TypeTiny
  	Type::Library
  	Type::Params
  	Type::Registry
  	Types::Standard
  	Types::Standard::_Stringable
  	Types::TypeTiny
  	Type::Tiny
  	Type::Tiny::Class
  	Type::Tiny::Duck
  	Type::Tiny::Enum
  	Type::Tiny::Intersection
  	Type::Tiny::Role
  	Type::Tiny::Union
  	Type::Utils
  );
  
  sub new
  {
  	my $class = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	return bless \%params, $class;
  }
  
  sub throw
  {
  	my $class = shift;
  	
  	my ($level, @caller, %ctxt) = 0;
  	while (
  		defined scalar caller($level) and $CarpInternal{scalar caller($level)}
  	) { $level++ };
  	if ( ((caller($level - 1))[1]||"") =~ /^parameter validation for '(.+?)'$/ )
  	{
  		my ($pkg, $func) = ($1 =~ m{^(.+)::(\w+)$});
  		$level++ if caller($level) eq ($pkg||"");
  	}
  	@ctxt{qw/ package file line /} = caller($level);
  	
  	my $stack = undef;
  	if (our $StackTrace)
  	{
  		require Devel::StackTrace;
  		$stack = "Devel::StackTrace"->new(
  			ignore_package => [ keys %CarpInternal ],
  		);
  	}
  	
  	die(
  		our $LastError = $class->new(
  			context     => \%ctxt,
  			stack_trace => $stack,
  			@_,
  		)
  	);
  }
  
  sub message     { $_[0]{message} ||= $_[0]->_build_message };
  sub context     { $_[0]{context} };
  sub stack_trace { $_[0]{stack_trace} };
  
  sub to_string
  {
  	my $e = shift;
  	my $c = $e->context;
  	my $m = $e->message;
  	
  	$m =~ /\n\z/s ? $m :
  	$c            ? sprintf("%s at %s line %s.\n", $m, $c->{file}||'file?', $c->{line}||'NaN') :
  	sprintf("%s\n", $m);
  }
  
  sub _build_message
  {
  	return 'An exception has occurred';
  }
  
  sub croak
  {
  	my ($fmt, @args) = @_;
  	@_ = (
  		__PACKAGE__,
  		message => sprintf($fmt, @args),
  	);
  	goto \&throw;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny - exceptions for Type::Tiny and friends
  
  =head1 SYNOPSIS
  
     use Data::Dumper;
     use Try::Tiny;
     use Types::Standard qw(Str);
     
     try {
        Str->assert_valid(undef);
     }
     catch {
        my $exception = shift;
        warn "Encountered Error: $exception";
        warn Dumper($exception->explain)
           if $exception->isa("Error::TypeTiny::Assertion");
     };
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  When Type::Tiny and its related modules encounter an error, they throw an
  exception object. These exception objects inherit from Error::TypeTiny.
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< throw(%attributes) >>
  
  Constructs an exception and passes it to C<die>.
  
  Automatically populates C<context> and C<stack_trace> if appropriate.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<message>
  
  The error message.
  
  =item C<context>
  
  Hashref containing the package, file and line that generated the error.
  
  =item C<stack_trace>
  
  A more complete stack trace. This feature requires L<Devel::StackTrace>;
  use the C<< $StackTrace >> package variable to switch it on.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<to_string>
  
  Returns the message, followed by the context if it is set.
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< Error::TypeTiny::croak($format, @args) >>
  
  Functional-style shortcut to C<throw> method. Takes an C<sprintf>-style
  format string and optional arguments to construct the C<message>.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to call C<to_string>.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< %Error::TypeTiny::CarpInternal >>
  
  Serves a similar purpose to C<< %Carp::CarpInternal >>.
  
  =item C<< $Error::TypeTiny::StackTrace >>
  
  Boolean to toggle stack trace generation.
  
  =item C<< $Error::TypeTiny::LastError >>
  
  A reference to the last exception object thrown.
  
  =back
  
  =head1 CAVEATS
  
  Although Error::TypeTiny objects are thrown for errors produced by
  Type::Tiny, that doesn't mean every time you use Type::Tiny you'll get
  Error::TypeTinys whenever you want.
  
  For example, if you use a Type::Tiny type constraint in a Moose attribute,
  Moose will not call the constraint's C<assert_valid> method (which throws
  an exception). Instead it will call C<check> and C<get_message> (which do
  not), and will C<confess> an error message of its own. (The C<< $LastError >>
  package variable may save your bacon.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>,
  L<Error::TypeTiny::WrongNumberOfParameters>.
  
  L<Try::Tiny>, L<Try::Tiny::ByClass>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY

$fatpacked{"Error/TypeTiny/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_ASSERTION';
  package Error::TypeTiny::Assertion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Error::TypeTiny::Assertion::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Assertion::VERSION   = '0.038';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub type               { $_[0]{type} };
  sub value              { $_[0]{value} };
  sub varname            { $_[0]{varname} ||= '$_' };
  sub attribute_step     { $_[0]{attribute_step} };
  sub attribute_name     { $_[0]{attribute_name} };
  
  sub has_type           { defined $_[0]{type} }; # sic
  sub has_attribute_step { exists $_[0]{attribute_step} };
  sub has_attribute_name { exists $_[0]{attribute_name} };
  
  sub new
  {
  	my $class = shift;
  	my $self  = $class->SUPER::new(@_);
  	
  	if (ref $Method::Generate::Accessor::CurrentAttribute)
  	{
  		require B;
  		my %d = %{$Method::Generate::Accessor::CurrentAttribute};
  		$self->{attribute_name} = $d{name} if defined $d{name};
  		$self->{attribute_step} = $d{step} if defined $d{step};
  		
  		if (defined $d{init_arg})
  		{
  			$self->{varname} = sprintf('$args->{%s}', B::perlstring($d{init_arg}));
  		}
  		elsif (defined $d{name})
  		{
  			$self->{varname} = sprintf('$self->{%s}', B::perlstring($d{name}));
  		}
  	}
  	
  	return $self;
  }
  
  sub message
  {
  	my $e = shift;
  	$e->varname eq '$_'
  		? $e->SUPER::message
  		: sprintf('%s (in %s)', $e->SUPER::message, $e->varname);
  }
  
  sub _build_message
  {
  	my $e = shift;
  	$e->has_type
  		? sprintf('%s did not pass type constraint "%s"', Type::Tiny::_dd($e->value), $e->type)
  		: sprintf('%s did not pass type constraint', Type::Tiny::_dd($e->value))
  }
  
  *to_string = sub
  {
  	my $e = shift;
  	my $msg = $e->message;
  	
  	my $c = $e->context;
  	$msg .= sprintf(" at %s line %s", $c->{file}||'file?', $c->{line}||'NaN') if $c;
  	
  	my $explain = $e->explain;
  	return $msg unless @{ $explain || [] };
  	
  	$msg .= "\n";
  	for my $line (@$explain) {
  		$msg .= "    $line\n";
  	}
  	
  	return $msg;
  } if $] >= 5.008;
  
  sub explain
  {
  	my $e = shift;
  	return undef unless $e->has_type;
  	$e->type->validate_explain($e->value, $e->varname);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Assertion - exception when a value fails a type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This exception is thrown when a value fails a type constraint assertion.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type>
  
  The type constraint that was checked against. Weakened links are involved,
  so this may end up being C<undef>.
  
  =item C<value>
  
  The value that was tested.
  
  =item C<varname>
  
  The name of the variable that was checked, if known. Defaults to C<< '$_' >>.
  
  =item C<attribute_name>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will tell you which attribute (if
  your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =item C<attribute_step>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will contain either C<< "isa check" >>
  or C<< "coercion" >> to indicate which went wrong (if your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_type>, C<has_attribute_name>, C<has_attribute_step>
  
  Predicate methods.
  
  =item C<message>
  
  Overridden to add C<varname> to the message if defined.
  
  =item C<explain>
  
  Attempts to explain why the value did not pass the type constraint. Returns
  an arrayref of strings providing step-by-step reasoning; or returns undef if
  no explanation is possible.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_ASSERTION

$fatpacked{"Error/TypeTiny/Compilation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_COMPILATION';
  package Error::TypeTiny::Compilation;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::Compilation::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Compilation::VERSION   = '0.038';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub code        { $_[0]{code} };
  sub environment { $_[0]{environment} ||= {} };
  sub errstr      { $_[0]{errstr} };
  
  sub _build_message
  {
  	my $self = shift;
  	sprintf("Failed to compile source because: %s", $self->errstr);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Compilation - exception for Eval::TypeTiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Thrown when compiling a closure fails. Common causes are problems with
  inlined type constraints, and syntax errors when coercions are given as
  strings of Perl code.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<code>
  
  The Perl source code being compiled.
  
  =item C<environment>
  
  Hashref of variables being closed over.
  
  =item C<errstr>
  
  Error message from Perl compiler.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_COMPILATION

$fatpacked{"Error/TypeTiny/WrongNumberOfParameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS';
  package Error::TypeTiny::WrongNumberOfParameters;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::WrongNumberOfParameters::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::WrongNumberOfParameters::VERSION   = '0.038';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub minimum    { $_[0]{minimum} };
  sub maximum    { $_[0]{maximum} };
  sub got        { $_[0]{got} };
  
  sub has_minimum { exists $_[0]{minimum} };
  sub has_maximum { exists $_[0]{maximum} };
  
  sub _build_message
  {
  	my $e = shift;
  	if ($e->has_minimum and $e->has_maximum and $e->minimum == $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	elsif ($e->has_minimum and $e->has_maximum and $e->minimum < $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d to %d",
  			$e->got,
  			$e->minimum,
  			$e->maximum,
  		);
  	}
  	elsif ($e->has_minimum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected at least %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	else
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d",
  			$e->got,
  		);
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::WrongNumberOfParameters - exception for Type::Params
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Thrown when a Type::Params compiled check is called with the wrong number
  of parameters.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<minimum>
  
  The minimum expected number of parameters.
  
  =item C<maximum>
  
  The maximum expected number of parameters.
  
  =item C<got>
  
  The number of parameters actually passed to the compiled check.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_minimum>, C<has_maximum>
  
  Predicate methods.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS

$fatpacked{"Eval/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_TYPETINY';
  package Eval::TypeTiny;
  
  use strict;
  
  BEGIN {
  	*HAS_LEXICAL_SUBS = ($] >= 5.018) ? sub(){!!1} : sub(){!!0};
  };
  
  {
  	my $hlv;
  	sub HAS_LEXICAL_VARS () {
  		$hlv = !! eval { require Devel::LexAlias } unless defined $hlv;
  		return $hlv;
  	}
  }
  
  sub _clean_eval
  {
  	local $@;
  	local $SIG{__DIE__};
  	my $r = eval $_[0];
  	my $e = $@;
  	return ($r, $e);
  }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  our @EXPORT    = qw( eval_closure );
  our @EXPORT_OK = qw( HAS_LEXICAL_SUBS HAS_LEXICAL_VARS );
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  use warnings;
  
  sub eval_closure
  {
  	my (%args) = @_;
  	my $src    = ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source};
  	
  	$args{alias}  = 0 unless defined $args{alias};
  	$args{line}   = 1 unless defined $args{line};
  	$args{description} =~ s/[^\w .:-\[\]\(\)\{\}\']//g if defined $args{description};
  	$src = qq{#line $args{line} "$args{description}"\n$src} if defined $args{description} && !($^P & 0x10);
  	$args{environment} ||= {};
  	
  #	for my $k (sort keys %{$args{environment}})
  #	{
  #		next if $k =~ /^\$/ && ref($args{environment}{$k}) =~ /^(SCALAR|REF)$/;
  #		next if $k =~ /^\@/ && ref($args{environment}{$k}) eq q(ARRAY);
  #		next if $k =~ /^\%/ && ref($args{environment}{$k}) eq q(HASH);
  #		
  #		require Error::TypeTiny;
  #		Error::TypeTiny::croak("Expected a variable name and ref; got %s => %s", $k, $args{environment}{$k});
  #	}
  	
  	my $sandpkg   = 'Eval::TypeTiny::Sandbox';
  	my $alias     = exists($args{alias}) ? $args{alias} : 0;
  	my @keys      = sort keys %{$args{environment}};
  	my $i         = 0;
  	my $source    = join "\n" => (
  		"package $sandpkg;",
  		"sub {",
  		map(_make_lexical_assignment($_, $i++, $alias), @keys),
  		$src,
  		"}",
  	);
  	
  	_manufacture_ties() if $alias && !HAS_LEXICAL_VARS;
  	
  	my ($compiler, $e) = _clean_eval($source);
  	if ($e)
  	{
  		chomp $e;
  		require Error::TypeTiny::Compilation;
  		"Error::TypeTiny::Compilation"->throw(
  			code        => (ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source}),
  			errstr      => $e,
  			environment => $args{environment},
  		);
  	}
  	
  	my $code = $compiler->(@{$args{environment}}{@keys});
  	undef($compiler);
  
  	if ($alias && HAS_LEXICAL_VARS) {
  		Devel::LexAlias::lexalias($code, $_, $args{environment}{$_}) for grep !/^\&/, @keys;
  	}
  	
  	return $code;
  }
  
  my $tmp;
  sub _make_lexical_assignment
  {
  	my ($key, $index, $alias) = @_;
  	my $name = substr($key, 1);
  	
  	if (HAS_LEXICAL_SUBS and $key =~ /^\&/) {
  		$tmp++;
  		my $tmpname = '$__LEXICAL_SUB__'.$tmp;
  		return
  			"no warnings 'experimental::lexical_subs';".
  			"use feature 'lexical_subs';".
  			"my $tmpname = \$_[$index];".
  			"my sub $name { goto $tmpname };";
  	}
  	
  	if (!$alias) {
  		my $sigil = substr($key, 0, 1);
  		return "my $key = $sigil\{ \$_[$index] };";
  	}
  	elsif (HAS_LEXICAL_VARS) {
  		return "my $key;";
  	}
  	else {
  		my $tieclass = {
  			'@' => 'Eval::TypeTiny::_TieArray',
  			'%' => 'Eval::TypeTiny::_TieHash',
  			'$' => 'Eval::TypeTiny::_TieScalar',
  		}->{ substr($key, 0, 1) };
  		
  		return sprintf(
  			'tie(my(%s), "%s", $_[%d]);',
  			$key,
  			$tieclass,
  			$index,
  		);
  	}
  }
  
  { my $tie; sub _manufacture_ties { $tie ||= eval <<'FALLBACK'; } }
  no warnings qw(void once uninitialized numeric);
  
  {
  	package #
  		Eval::TypeTiny::_TieArray;
  	require Tie::Array;
  	our @ISA = qw( Tie::StdArray );
  	sub TIEARRAY {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(@$self) and return tied(@$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(@$self) and tied(@$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied @{$_[0]} },
  		q[""]    => sub { '' . tied @{$_[0]} },
  		q[0+]    => sub { 0  + tied @{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieHash;
  	require Tie::Hash;
  	our @ISA = qw( Tie::StdHash );
  	sub TIEHASH {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(%$self) and return tied(%$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(%$self) and tied(%$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied %{$_[0]} },
  		q[""]    => sub { '' . tied %{$_[0]} },
  		q[0+]    => sub { 0  + tied %{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieScalar;
  	require Tie::Scalar;
  	our @ISA = qw( Tie::StdScalar );
  	sub TIESCALAR {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied($$self) and return tied($$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied($$self) and tied($$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied ${$_[0]} },
  		q[""]    => sub { '' . tied ${$_[0]} },
  		q[0+]    => sub { 0  + tied ${$_[0]} },
  		fallback => 1,
  	;
  }
  
  1;
  FALLBACK
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas coderefs
  
  =head1 NAME
  
  Eval::TypeTiny - utility to evaluate a string of Perl code in a clean environment
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This module is used by Type::Tiny to compile coderefs from strings of
  Perl code, and hashrefs of variables to close over.
  
  =head2 Functions
  
  This module exports one function, which works much like the similarly named
  function from L<Eval::Closure>:
  
  =over
  
  =item C<< eval_closure(source => $source, environment => \%env, %opt) >>
  
  =back
  
  =head2 Constants
  
  The following constants may be exported, but are not by default.
  
  =over
  
  =item C<< HAS_LEXICAL_SUBS >>
  
  Boolean indicating whether Eval::TypeTiny has support for lexical subs.
  (This feature requires Perl 5.18.)
  
  =item C<< HAS_LEXICAL_VARS >>
  
  Don't worry; closing over lexical variables in the closures is always
  supported! However, if this constant is true, it means that
  L<Devel::LexAlias> is available, which makes them slightly faster than
  the fallback solution which uses tied variables. (This only makes any
  difference when the C<< alias => 1 >> option is used.)
  
  =back
  
  =head1 EVALUATION ENVIRONMENT
  
  The evaluation is performed in the presence of L<strict>, but the absence of
  L<warnings>. (This is different to L<Eval::Closure> which enables warnings for
  compiled closures.)
  
  The L<feature> pragma is not active in the evaluation environment, so the
  following will not work:
  
     use feature qw(say);
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { say for @_ }',
     );
     $say_all->("Hello", "World");
  
  The L<feature> pragma does not "carry over" into the stringy eval. It is
  of course possible to import pragmas into the evaluated string as part of the
  string itself:
  
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { use feature qw(say); say for @_ }',
     );
     $say_all->("Hello", "World");
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Eval::Closure>, L<Error::TypeTiny::Compilation>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EVAL_TYPETINY

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  
  sub import
  {
  	my $class       = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	my @args        = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts        = mkopt(\@args);
  	
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	my @want;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		$name =~ /^[:-](.+)$/
  			? push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts))
  			: push(@want, $opt);
  	}
  	
  	$class->_exporter_validate_opts($global_opts);
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	
  	for my $wanted (@want)
  	{
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  # Called once per import, passed the "global" import options. Expected to
  # validate the import options and carp or croak if there are problems. Can
  # also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts
  {
  	1;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return map [$_ => $value], $tags->{$name}->($class, @_)
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return map [$_ => $value], @{$tags->{$name}}
  		if exists $tags->{$name};
  	
  	return map [$_ => $value], @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"}
  		if $name eq 'all';
  	
  	return map [$_ => $value], @{"$class\::EXPORT"}
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	_croak("Could not find sub '$name' to export in package '$class'");
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name = $value->{-as} || $name;
  	unless (ref($name) eq q(SCALAR))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return $installer->($globals, [$name, $sym]) if $installer;
  	return ($$name = $sym)                       if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym)               if ref($into) eq q(HASH);
  	
  	require B;
  	for (grep ref, $into->can($name))
  	{
  		my $stash = B::svref_2object($_)->STASH;
  		next unless $stash->can("NAME");
  		$stash->NAME eq $into
  			and _croak("Refusing to overwrite local sub '$name' with export from $class");
  	}
  	
  	no strict qw(refs);
  	*{"$into\::$name"} = $sym;
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { my $n = shift; ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installler >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  Exporter::Tiny performs most of its internal duties (including resolution
  of tag names to sub names, resolution of sub names to coderefs, and
  installation of coderefs into the target package) as method calls, which
  means they can be overridden to provide interesting behaviour.
  
  =head2 Utility Functions
  
  These are really for internal use, but can be exported if you need them.
  
  =over
  
  =item C<< mkopt(\@array) >>
  
  Similar to C<mkopt> from L<Data::OptList>. It doesn't support all the
  fancy options that Data::OptList does (C<moniker>, C<require_unique>,
  C<must_be> and C<name_test>) but runs about 50% faster.
  
  =item C<< mkopt_hash(\@array) >>
  
  Similar to C<mkopt_hash> from L<Data::OptList>. See also C<mkopt>.
  
  =back
  
  =head1 TIPS AND TRICKS IMPORTING FROM EXPORTER::TINY
  
  For the purposes of this discussion we'll assume we have a module called
  C<< MyUtils >> which exports one function, C<< frobnicate >>. C<< MyUtils >>
  inherits from Exporter::Tiny.
  
  Many of these tricks may seem familiar from L<Sub::Exporter>. That is
  intentional. Exporter::Tiny doesn't attempt to provide every feature of
  Sub::Exporter, but where it does it usually uses a fairly similar API.
  
  =head2 Basic importing
  
     # import "frobnicate" function
     use MyUtils "frobnicate";
  
     # import all functions that MyUtils offers
     use MyUtils -all;
  
  =head2 Renaming imported functions
  
     # call it "frob"
     use MyUtils "frobnicate" => { -as => "frob" };
  
     # call it "my_frobnicate"
     use MyUtils "frobnicate" => { -prefix => "my_" };
  
     # call it "frobnicate_util"
     use MyUtils "frobnicate" => { -suffix => "_util" };
  
     # import it twice with two different names
     use MyUtils
        "frobnicate" => { -as => "frob" },
        "frobnicate" => { -as => "frbnct" };
  
  =head2 Lexical subs
  
     {
        use Sub::Exporter::Lexical lexical_installer => { -as => "lex" };
        use MyUtils { installer => lex }, "frobnicate";
        
        frobnicate(...);  # ok
     }
     
     frobnicate(...);  # not ok
  
  =head2 Import functions into another package
  
     use MyUtils { into => "OtherPkg" }, "frobnicate";
     
     OtherPkg::frobincate(...);
  
  =head2 Import functions into a scalar
  
     my $func;
     use MyUtils "frobnicate" => { -as => \$func };
     
     $func->(...);
  
  =head2 Import functions into a hash
  
  OK, Sub::Exporter doesn't do this...
  
     my %funcs;
     use MyUtils { into => \%funcs }, "frobnicate";
     
     $funcs{frobnicate}->(...);
  
  =head1 TIPS AND TRICKS EXPORTING USING EXPORTER::TINY
  
  Simple configuration works the same as L<Exporter>; inherit from this module,
  and use the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables to list subs to export.
  
  =head2 Generators
  
  Exporter::Tiny has always allowed exported subs to be generated (like
  L<Sub::Exporter>), but until version 0.025 did not have an especially nice
  API for it.
  
  Now, it's easy. If you want to generate a sub C<foo> to export, list it in
  C<< @EXPORT >> or C<< @EXPORT_OK >> as usual, and then simply give your
  exporter module a class method called C<< _generate_foo >>.
  
     push @EXPORT_OK, 'foo';
     
     sub _generate_foo {
        my $class = shift;
        my ($name, $args, $globals) = @_;
        
        return sub {
           ...;
        }
     }
  
  You can also generate tags:
  
     my %constants = (FOO => 1, BAR => 2);
     use constant \%constants;
     
     $EXPORT_TAGS{constants} = sub {
        my $class = shift;
        my ($name, $args, $globals) = @_;
        
        return keys(%constants);
     };
  
  =head2 Overriding Internals
  
  An important difference between L<Exporter> and Exporter::Tiny is that
  the latter calls all its internal functions as I<< class methods >>. This
  means that your subclass can I<< override them >> to alter their behaviour.
  
  The following methods are available to be overridden. Despite being named
  with a leading underscore, they are considered public methods. (The underscore
  is there to avoid accidentally colliding with any of your own function names.)
  
  =over
  
  =item C<< _exporter_validate_opts($globals) >>
  
  This method is called once each time C<import> is called. It is passed a
  reference to the global options hash. (That is, the optional leading hashref
  in the C<use> statement, where the C<into> and C<installer> options can be
  provided.)
  
  You may use this method to munge the global options, or validate them,
  throwing an exception or printing a warning.
  
  The default implementation does nothing interesting.
  
  =item C<< _exporter_expand_tag($name, $args, $globals) >>
  
  This method is called to expand an import tag (e.g. C<< ":constants" >>).
  It is passed the tag name (minus the leading ":"), an optional hashref
  of options (like C<< { -prefix => "foo_" } >>), and the global options
  hashref.
  
  It is expected to return a list of ($name, $args) arrayref pairs. These
  names can be sub names to export, or further tag names (which must have
  their ":"). If returning tag names, be careful to avoid creating a tag
  expansion loop!
  
  The default implementation uses C<< %EXPORT_TAGS >> to expand tags, and
  provides fallbacks for the C<< :default >> and C<< :all >> tags.
  
  =item C<< _exporter_expand_sub($name, $args, $globals) >>
  
  This method is called to translate a sub name to a hash of name => coderef
  pairs for exporting to the caller. In general, this would just be a hash with
  one key and one value, but, for example, L<Type::Library> overrides this
  method so that C<< "+Foo" >> gets expanded to:
  
     (
        Foo         => sub { $type },
        is_Foo      => sub { $type->check(@_) },
        to_Foo      => sub { $type->assert_coerce(@_) },
        assert_Foo  => sub { $type->assert_return(@_) },
     )
  
  The default implementation checks that the name is allowed to be exported
  (using the C<_exporter_permitted_regexp> method), gets the coderef using
  the generator if there is one (or by calling C<< can >> on your exporter
  otherwise) and calls C<_exporter_fail> if it's unable to generate or
  retrieve a coderef.
  
  =item C<< _exporter_permitted_regexp($globals) >>
  
  This method is called to retrieve a regexp for validating the names of
  exportable subs. If a sub doesn't match the regexp, then the default
  implementation of C<_exporter_expand_sub> will refuse to export it. (Of
  course, you may override the default C<_exporter_expand_sub>.)
  
  The default implementation of this method assembles the regexp from
  C<< @EXPORT >> and C<< @EXPORT_OK >>.
  
  =item C<< _exporter_fail($name, $args, $globals) >>
  
  Called by C<_exporter_expand_sub> if it can't find a coderef to export.
  
  The default implementation just throws an exception. But you could emit
  a warning instead, or just ignore the failed export.
  
  If you don't throw an exception then you should be aware that this
  method is called in list context, and any list it returns will be treated
  as an C<_exporter_expand_sub>-style hash of names and coderefs for
  export.
  
  =item C<< _exporter_install_sub($name, $args, $globals, $coderef) >>
  
  This method actually installs the exported sub into its new destination.
  Its return value is ignored.
  
  The default implementation handles sub renaming (i.e. the C<< -as >>,
  C<< -prefix >> and C<< -suffix >> functions. This method does a lot of
  stuff; if you need to override it, it's probably a good idea to just
  pre-process the arguments and then call the super method rather than
  trying to handle all of it yourself.
  
  =back
  
  =head1 HISTORY
  
  L<Type::Library> had a bunch of custom exporting code which poked coderefs
  into its caller's stash. It needed this to be something more powerful than
  most exporters so that it could switch between exporting Moose, Mouse and
  Moo-compatible objects on request. L<Sub::Exporter> would have been capable,
  but had too many dependencies for the Type::Tiny project.
  
  Meanwhile L<Type::Utils>, L<Types::TypeTiny> and L<Test::TypeTiny> each
  used the venerable L<Exporter.pm|Exporter>. However, this meant they were
  unable to use the features like L<Sub::Exporter>-style function renaming
  which I'd built into Type::Library:
  
     ## import "Str" but rename it to "String".
     use Types::Standard "Str" => { -as => "String" };
  
  And so I decided to factor out code that could be shared by all Type-Tiny's
  exporters into a single place: Exporter::TypeTiny.
  
  As of version 0.026, Exporter::TypeTiny was also made available as
  L<Exporter::Tiny>, distributed independently on CPAN. CHOCOLATEBOY had
  convinced me that it was mature enough to live a life of its own.
  
  As of version 0.030, Type-Tiny depends on Exporter::Tiny and
  Exporter::TypeTiny is being phased out.
  
  =head1 OBLIGATORY EXPORTER COMPARISON
  
  Exporting is unlikely to be your application's performance bottleneck, but
  nonetheless here are some comparisons.
  
  B<< Comparative sizes according to L<Devel::SizeMe>: >>
  
     Exporter                     217.1Kb
     Sub::Exporter::Progressive   263.2Kb
     Exporter::Tiny               267.7Kb
     Exporter + Exporter::Heavy   281.5Kb
     Exporter::Renaming           406.2Kb
     Sub::Exporter                701.0Kb
  
  B<< Performance exporting a single sub: >>
  
                Rate     SubExp    ExpTiny SubExpProg      ExpPM
  SubExp      2489/s         --       -56%       -85%       -88%
  ExpTiny     5635/s       126%         --       -67%       -72%
  SubExpProg 16905/s       579%       200%         --       -16%
  ExpPM      20097/s       707%       257%        19%         --
  
  (Exporter::Renaming globally changes the behaviour of Exporter.pm, so could
  not be included in the same benchmarks.)
  
  B<< (Non-Core) Dependencies: >>
  
     Exporter                    -1
     Exporter::Renaming           0
     Exporter::Tiny               0
     Sub::Exporter::Progressive   0
     Sub::Exporter                3
  
  B<< Features: >>
  
                                        ExpPM   ExpTiny SubExp  SubExpProg
   Can export code symbols............. Yes     Yes     Yes     Yes      
   Can export non-code symbols......... Yes                              
   Groups/tags......................... Yes     Yes     Yes     Yes      
   Config avoids package variables.....                 Yes              
   Allows renaming of subs.............         Yes     Yes     Maybe    
   Install code into scalar refs.......         Yes     Yes     Maybe    
   Can be passed an "into" parameter...         Yes     Yes     Maybe    
   Can be passed an "installer" sub....         Yes     Yes     Maybe    
   Supports generators.................         Yes     Yes              
   Sane API for generators.............         Yes     Yes              
  
  (Certain Sub::Exporter::Progressive features are only available if
  Sub::Exporter is installed.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  L<Exporter::Shiny>,
  L<Sub::Exporter>,
  L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"Exporter/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TYPETINY';
  package Exporter::TypeTiny;
  require Exporter::Tiny;
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  our @ISA       = 'Exporter::Tiny';
  our @EXPORT_OK = qw| mkopt mkopt_hash _croak |;
  *import        = \&Exporter::Tiny::import;
  *mkopt         = \&Exporter::Tiny::mkopt;
  *mkopt_hash    = \&Exporter::Tiny::mkopt_hash;
  *_croak        = \&Exporter::Tiny::_croak;
  1;
EXPORTER_TYPETINY

$fatpacked{"File/Find/Rule.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_FIND_RULE';
  #       $Id$
  
  package File::Find::Rule;
  use strict;
  use File::Spec;
  use Text::Glob 'glob_to_regex';
  use Number::Compare;
  use Carp qw/croak/;
  use File::Find (); # we're only wrapping for now
  
  our $VERSION = '0.33';
  
  # we'd just inherit from Exporter, but I want the colon
  sub import {
      my $pkg = shift;
      my $to  = caller;
      for my $sym ( qw( find rule ) ) {
          no strict 'refs';
          *{"$to\::$sym"} = \&{$sym};
      }
      for (grep /^:/, @_) {
          my ($extension) = /^:(.*)/;
          eval "require File::Find::Rule::$extension";
          croak "couldn't bootstrap File::Find::Rule::$extension: $@" if $@;
      }
  }
  
  =head1 NAME
  
  File::Find::Rule - Alternative interface to File::Find
  
  =head1 SYNOPSIS
  
    use File::Find::Rule;
    # find all the subdirectories of a given directory
    my @subdirs = File::Find::Rule->directory->in( $directory );
  
    # find all the .pm files in @INC
    my @files = File::Find::Rule->file()
                                ->name( '*.pm' )
                                ->in( @INC );
  
    # as above, but without method chaining
    my $rule =  File::Find::Rule->new;
    $rule->file;
    $rule->name( '*.pm' );
    my @files = $rule->in( @INC );
  
  =head1 DESCRIPTION
  
  File::Find::Rule is a friendlier interface to File::Find.  It allows
  you to build rules which specify the desired files and directories.
  
  =cut
  
  # the procedural shim
  
  *rule = \&find;
  sub find {
      my $object = __PACKAGE__->new();
      my $not = 0;
  
      while (@_) {
          my $method = shift;
          my @args;
  
          if ($method =~ s/^\!//) {
              # jinkies, we're really negating this
              unshift @_, $method;
              $not = 1;
              next;
          }
          unless (defined prototype $method) {
              my $args = shift;
              @args = ref $args eq 'ARRAY' ? @$args : $args;
          }
          if ($not) {
              $not = 0;
              @args = $object->new->$method(@args);
              $method = "not";
          }
  
          my @return = $object->$method(@args);
          return @return if $method eq 'in';
      }
      $object;
  }
  
  
  =head1 METHODS
  
  =over
  
  =item C<new>
  
  A constructor.  You need not invoke C<new> manually unless you wish
  to, as each of the rule-making methods will auto-create a suitable
  object if called as class methods.
  
  =cut
  
  sub new {
      my $referent = shift;
      my $class = ref $referent || $referent;
      bless {
          rules    => [],
          subs     => {},
          iterator => [],
          extras   => {},
          maxdepth => undef,
          mindepth => undef,
      }, $class;
  }
  
  sub _force_object {
      my $object = shift;
      $object = $object->new()
        unless ref $object;
      $object;
  }
  
  =back
  
  =head2 Matching Rules
  
  =over
  
  =item C<name( @patterns )>
  
  Specifies names that should match.  May be globs or regular
  expressions.
  
   $set->name( '*.mp3', '*.ogg' ); # mp3s or oggs
   $set->name( qr/\.(mp3|ogg)$/ ); # the same as a regex
   $set->name( 'foo.bar' );        # just things named foo.bar
  
  =cut
  
  sub _flatten {
      my @flat;
      while (@_) {
          my $item = shift;
          ref $item eq 'ARRAY' ? push @_, @{ $item } : push @flat, $item;
      }
      return @flat;
  }
  
  sub name {
      my $self = _force_object shift;
      my @names = map { ref $_ eq "Regexp" ? $_ : glob_to_regex $_ } _flatten( @_ );
  
      push @{ $self->{rules} }, {
          rule => 'name',
          code => join( ' || ', map { "m{$_}" } @names ),
          args => \@_,
      };
  
      $self;
  }
  
  =item -X tests
  
  Synonyms are provided for each of the -X tests. See L<perlfunc/-X> for
  details.  None of these methods take arguments.
  
    Test | Method               Test |  Method
   ------|-------------        ------|----------------
     -r  |  readable             -R  |  r_readable
     -w  |  writeable            -W  |  r_writeable
     -w  |  writable             -W  |  r_writable
     -x  |  executable           -X  |  r_executable
     -o  |  owned                -O  |  r_owned
         |                           |
     -e  |  exists               -f  |  file
     -z  |  empty                -d  |  directory
     -s  |  nonempty             -l  |  symlink
         |                       -p  |  fifo
     -u  |  setuid               -S  |  socket
     -g  |  setgid               -b  |  block
     -k  |  sticky               -c  |  character
         |                       -t  |  tty
     -M  |  modified                 |
     -A  |  accessed             -T  |  ascii
     -C  |  changed              -B  |  binary
  
  Though some tests are fairly meaningless as binary flags (C<modified>,
  C<accessed>, C<changed>), they have been included for completeness.
  
   # find nonempty files
   $rule->file,
        ->nonempty;
  
  =cut
  
  use vars qw( %X_tests );
  %X_tests = (
      -r  =>  readable           =>  -R  =>  r_readable      =>
      -w  =>  writeable          =>  -W  =>  r_writeable     =>
      -w  =>  writable           =>  -W  =>  r_writable      =>
      -x  =>  executable         =>  -X  =>  r_executable    =>
      -o  =>  owned              =>  -O  =>  r_owned         =>
  
      -e  =>  exists             =>  -f  =>  file            =>
      -z  =>  empty              =>  -d  =>  directory       =>
      -s  =>  nonempty           =>  -l  =>  symlink         =>
                                 =>  -p  =>  fifo            =>
      -u  =>  setuid             =>  -S  =>  socket          =>
      -g  =>  setgid             =>  -b  =>  block           =>
      -k  =>  sticky             =>  -c  =>  character       =>
                                 =>  -t  =>  tty             =>
      -M  =>  modified                                       =>
      -A  =>  accessed           =>  -T  =>  ascii           =>
      -C  =>  changed            =>  -B  =>  binary          =>
     );
  
  for my $test (keys %X_tests) {
      my $sub = eval 'sub () {
          my $self = _force_object shift;
          push @{ $self->{rules} }, {
              code => "' . $test . ' \$_",
              rule => "'.$X_tests{$test}.'",
          };
          $self;
      } ';
      no strict 'refs';
      *{ $X_tests{$test} } = $sub;
  }
  
  
  =item stat tests
  
  The following C<stat> based methods are provided: C<dev>, C<ino>,
  C<mode>, C<nlink>, C<uid>, C<gid>, C<rdev>, C<size>, C<atime>,
  C<mtime>, C<ctime>, C<blksize>, and C<blocks>.  See L<perlfunc/stat>
  for details.
  
  Each of these can take a number of targets, which will follow
  L<Number::Compare> semantics.
  
   $rule->size( 7 );         # exactly 7
   $rule->size( ">7Ki" );    # larger than 7 * 1024 * 1024 bytes
   $rule->size( ">=7" )
        ->size( "<=90" );    # between 7 and 90, inclusive
   $rule->size( 7, 9, 42 );  # 7, 9 or 42
  
  =cut
  
  use vars qw( @stat_tests );
  @stat_tests = qw( dev ino mode nlink uid gid rdev
                    size atime mtime ctime blksize blocks );
  {
      my $i = 0;
      for my $test (@stat_tests) {
          my $index = $i++; # to close over
          my $sub = sub {
              my $self = _force_object shift;
  
              my @tests = map { Number::Compare->parse_to_perl($_) } @_;
  
              push @{ $self->{rules} }, {
                  rule => $test,
                  args => \@_,
                  code => 'do { my $val = (stat $_)['.$index.'] || 0;'.
                    join ('||', map { "(\$val $_)" } @tests ).' }',
              };
              $self;
          };
          no strict 'refs';
          *$test = $sub;
      }
  }
  
  =item C<any( @rules )>
  
  =item C<or( @rules )>
  
  Allows shortcircuiting boolean evaluation as an alternative to the
  default and-like nature of combined rules.  C<any> and C<or> are
  interchangeable.
  
   # find avis, movs, things over 200M and empty files
   $rule->any( File::Find::Rule->name( '*.avi', '*.mov' ),
               File::Find::Rule->size( '>200M' ),
               File::Find::Rule->file->empty,
             );
  
  =cut
  
  sub any {
      my $self = _force_object shift;
      # compile all the subrules to code fragments
      push @{ $self->{rules} }, {
          rule => "any",
          code => '(' . join( ' || ', map '( ' . $_->_compile . ' )', @_ ). ')',
          args => \@_,
      };
      
      # merge all the subs hashes of the kids into ourself
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *or = \&any;
  
  =item C<none( @rules )>
  
  =item C<not( @rules )>
  
  Negates a rule.  (The inverse of C<any>.)  C<none> and C<not> are
  interchangeable.
  
    # files that aren't 8.3 safe
    $rule->file
         ->not( $rule->new->name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );
  
  =cut
  
  sub not {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'not',
          args => \@_,
          code => '(' . join ( ' && ', map { "!(". $_->_compile . ")" } @_ ) . ")",
      };
      
      # merge all the subs hashes into us
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *none = \&not;
  
  =item C<prune>
  
  Traverse no further.  This rule always matches.
  
  =cut
  
  sub prune () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} },
        {
         rule => 'prune',
         code => '$File::Find::prune = 1'
        };
      $self;
  }
  
  =item C<discard>
  
  Don't keep this file.  This rule always matches.
  
  =cut
  
  sub discard () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'discard',
          code => '$discarded = 1',
      };
      $self;
  }
  
  =item C<exec( \&subroutine( $shortname, $path, $fullname ) )>
  
  Allows user-defined rules.  Your subroutine will be invoked with C<$_>
  set to the current short name, and with parameters of the name, the
  path you're in, and the full relative filename.
  
  Return a true value if your rule matched.
  
   # get things with long names
   $rules->exec( sub { length > 20 } );
  
  =cut
  
  sub exec {
      my $self = _force_object shift;
      my $code = shift;
  
      push @{ $self->{rules} }, {
          rule => 'exec',
          code => $code,
      };
      $self;
  }
  
  =item C<grep( @specifiers )>
  
  Opens a file and tests it each line at a time.
  
  For each line it evaluates each of the specifiers, stopping at the
  first successful match.  A specifier may be a regular expression or a
  subroutine.  The subroutine will be invoked with the same parameters
  as an ->exec subroutine.
  
  It is possible to provide a set of negative specifiers by enclosing
  them in anonymous arrays.  Should a negative specifier match the
  iteration is aborted and the clause is failed.  For example:
  
   $rule->grep( qr/^#!.*\bperl/, [ sub { 1 } ] );
  
  Is a passing clause if the first line of a file looks like a perl
  shebang line.
  
  =cut
  
  sub grep {
      my $self = _force_object shift;
      my @pattern = map {
          ref $_
            ? ref $_ eq 'ARRAY'
              ? map { [ ( ref $_ ? $_ : qr/$_/ ) => 0 ] } @$_
              : [ $_ => 1 ]
            : [ qr/$_/ => 1 ]
        } @_;
  
      $self->exec( sub {
          local *FILE;
          open FILE, $_ or return;
          local ($_, $.);
          while (<FILE>) {
              for my $p (@pattern) {
                  my ($rule, $ret) = @$p;
                  return $ret
                    if ref $rule eq 'Regexp'
                      ? /$rule/
                        : $rule->(@_);
              }
          }
          return;
      } );
  }
  
  =item C<maxdepth( $level )>
  
  Descend at most C<$level> (a non-negative integer) levels of directories
  below the starting point.
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =item C<mindepth( $level )>
  
  Do not apply any tests at levels less than C<$level> (a non-negative
  integer).
  
  =item C<extras( \%extras )>
  
  Specifies extra values to pass through to C<File::File::find> as part
  of the options hash.
  
  For example this allows you to specify following of symlinks like so:
  
   my $rule = File::Find::Rule->extras({ follow => 1 });
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =cut
  
  for my $setter (qw( maxdepth mindepth extras )) {
      my $sub = sub {
          my $self = _force_object shift;
          $self->{$setter} = shift;
          $self;
      };
      no strict 'refs';
      *$setter = $sub;
  }
  
  
  =item C<relative>
  
  Trim the leading portion of any path found
  
  =cut
  
  sub relative () {
      my $self = _force_object shift;
      $self->{relative} = 1;
      $self;
  }
  
  =item C<not_*>
  
  Negated version of the rule.  An effective shortand related to ! in
  the procedural interface.
  
   $foo->not_name('*.pl');
  
   $foo->not( $foo->new->name('*.pl' ) );
  
  =cut
  
  sub DESTROY {}
  sub AUTOLOAD {
      our $AUTOLOAD;
      $AUTOLOAD =~ /::not_([^:]*)$/
        or croak "Can't locate method $AUTOLOAD";
      my $method = $1;
  
      my $sub = sub {
          my $self = _force_object shift;
          $self->not( $self->new->$method(@_) );
      };
      {
          no strict 'refs';
          *$AUTOLOAD = $sub;
      }
      &$sub;
  }
  
  =back
  
  =head2 Query Methods
  
  =over
  
  =item C<in( @directories )>
  
  Evaluates the rule, returns a list of paths to matching files and
  directories.
  
  =cut
  
  sub in {
      my $self = _force_object shift;
  
      my @found;
      my $fragment = $self->_compile;
      my %subs = %{ $self->{subs} };
  
      warn "relative mode handed multiple paths - that's a bit silly\n"
        if $self->{relative} && @_ > 1;
  
      my $topdir;
      my $code = 'sub {
          (my $path = $File::Find::name)  =~ s#^(?:\./+)+##;
          my @args = ($_, $File::Find::dir, $path);
          my $maxdepth = $self->{maxdepth};
          my $mindepth = $self->{mindepth};
          my $relative = $self->{relative};
  
          # figure out the relative path and depth
          my $relpath = $File::Find::name;
          $relpath =~ s{^\Q$topdir\E/?}{};
          my $depth = scalar File::Spec->splitdir($relpath);
          #print "name: \'$File::Find::name\' ";
          #print "relpath: \'$relpath\' depth: $depth relative: $relative\n";
  
          defined $maxdepth && $depth >= $maxdepth
             and $File::Find::prune = 1;
  
          defined $mindepth && $depth < $mindepth
             and return;
  
          #print "Testing \'$_\'\n";
  
          my $discarded;
          return unless ' . $fragment . ';
          return if $discarded;
          if ($relative) {
              push @found, $relpath if $relpath ne "";
          }
          else {
              push @found, $path;
          }
      }';
  
      #use Data::Dumper;
      #print Dumper \%subs;
      #warn "Compiled sub: '$code'\n";
  
      my $sub = eval "$code" or die "compile error '$code' $@";
      for my $path (@_) {
          # $topdir is used for relative and maxdepth
          $topdir = $path;
          # slice off the trailing slash if there is one (the
          # maxdepth/mindepth code is fussy)
          $topdir =~ s{/?$}{}
            unless $topdir eq '/';
          $self->_call_find( { %{ $self->{extras} }, wanted => $sub }, $path );
      }
  
      return @found;
  }
  
  sub _call_find {
      my $self = shift;
      File::Find::find( @_ );
  }
  
  sub _compile {
      my $self = shift;
  
      return '1' unless @{ $self->{rules} };
      my $code = join " && ", map {
          if (ref $_->{code}) {
              my $key = "$_->{code}";
              $self->{subs}{$key} = $_->{code};
              "\$subs{'$key'}->(\@args) # $_->{rule}\n";
          }
          else {
              "( $_->{code} ) # $_->{rule}\n";
          }
      } @{ $self->{rules} };
  
      #warn $code;
      return $code;
  }
  
  =item C<start( @directories )>
  
  Starts a find across the specified directories.  Matching items may
  then be queried using L</match>.  This allows you to use a rule as an
  iterator.
  
   my $rule = File::Find::Rule->file->name("*.jpeg")->start( "/web" );
   while ( defined ( my $image = $rule->match ) ) {
       ...
   }
  
  =cut
  
  sub start {
      my $self = _force_object shift;
  
      $self->{iterator} = [ $self->in( @_ ) ];
      $self;
  }
  
  =item C<match>
  
  Returns the next file which matches, false if there are no more.
  
  =cut
  
  sub match {
      my $self = _force_object shift;
  
      return shift @{ $self->{iterator} };
  }
  
  1;
  
  __END__
  
  =back
  
  =head2 Extensions
  
  Extension modules are available from CPAN in the File::Find::Rule
  namespace.  In order to use these extensions either use them directly:
  
   use File::Find::Rule::ImageSize;
   use File::Find::Rule::MMagic;
  
   # now your rules can use the clauses supplied by the ImageSize and
   # MMagic extension
  
  or, specify that File::Find::Rule should load them for you:
  
   use File::Find::Rule qw( :ImageSize :MMagic );
  
  For notes on implementing your own extensions, consult
  L<File::Find::Rule::Extending>
  
  =head2 Further examples
  
  =over
  
  =item Finding perl scripts
  
   my $finder = File::Find::Rule->or
    (
     File::Find::Rule->name( '*.pl' ),
     File::Find::Rule->exec(
                            sub {
                                if (open my $fh, $_) {
                                    my $shebang = <$fh>;
                                    close $fh;
                                    return $shebang =~ /^#!.*\bperl/;
                                }
                                return 0;
                            } ),
    );
  
  Based upon this message http://use.perl.org/comments.pl?sid=7052&cid=10842
  
  =item ignore CVS directories
  
   my $rule = File::Find::Rule->new;
   $rule->or($rule->new
                  ->directory
                  ->name('CVS')
                  ->prune
                  ->discard,
             $rule->new);
  
  Note here the use of a null rule.  Null rules match anything they see,
  so the effect is to match (and discard) directories called 'CVS' or to
  match anything.
  
  =back
  
  =head1 TWO FOR THE PRICE OF ONE
  
  File::Find::Rule also gives you a procedural interface.  This is
  documented in L<File::Find::Rule::Procedural>
  
  =head1 EXPORTS
  
  L</find>, L</rule>
  
  =head1 TAINT MODE INTERACTION
  
  As of 0.32 File::Find::Rule doesn't capture the current working directory in
  a taint-unsafe manner.  File::Find itself still does operations that the taint
  system will flag as insecure but you can use the L</extras> feature to ask
  L<File::Find> to internally C<untaint> file paths with a regex like so:
  
      my $rule = File::Find::Rule->extras({ untaint => 1 });
      
  Please consult L<File::Find>'s documentation for C<untaint>,
  C<untaint_pattern>, and C<untaint_skip> for more information.
  
  =head1 BUGS
  
  The code makes use of the C<our> keyword and as such requires perl version
  5.6.0 or newer.
  
  Currently it isn't possible to remove a clause from a rule object.  If
  this becomes a significant issue it will be addressed.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net> with input gained from this
  use.perl discussion: http://use.perl.org/~richardc/journal/6467
  
  Additional proofreading and input provided by Kake, Greg McCarroll,
  and Andy Lester andy@petdance.com.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Find>, L<Text::Glob>, L<Number::Compare>, find(1)
  
  If you want to know about the procedural interface, see
  L<File::Find::Rule::Procedural>, and if you have an idea for a neat
  extension L<File::Find::Rule::Extending>
  
  =cut
  
  Implementation notes:
  
  $self->rules is an array of hashrefs.  it may be a code fragment or a call
  to a subroutine.
  
  Anonymous subroutines are stored in the $self->subs hashref keyed on the
  stringfied version of the coderef.
  
  When one File::Find::Rule object is combined with another, such as in the any
  and not operations, this entire hash is merged.
  
  The _compile method walks the rules element and simply glues the code
  fragments together so they can be compiled into an anyonymous File::Find
  match sub for speed
  
  
  [*] There's probably a win to be made with the current model in making
  stat calls use C<_>.  For
  
    find( file => size => "> 20M" => size => "< 400M" );
  
  up to 3 stats will happen for each candidate.  Adding a priming _
  would be a bit blind if the first operation was C< name => 'foo' >,
  since that can be tested by a single regex.  Simply checking what the
  next type of operation doesn't work since any arbritary exec sub may
  or may not stat.  Potentially worse, they could stat something else
  like so:
  
    # extract from the worlds stupidest make(1)
    find( exec => sub { my $f = $_; $f =~ s/\.c$/.o/ && !-e $f } );
  
  Maybe the best way is to treat C<_> as invalid after calling an exec,
  and doc that C<_> will only be meaningful after stat and -X tests if
  they're wanted in exec blocks.
FILE_FIND_RULE

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;
  
  # See POD at end for documentation
  
  use 5.00503;
  use strict;
  use Carp        ();
  use Config      ();
  use File::Spec  ();
  use File::Which ();
  
  # Globals
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};
  BEGIN {
  	$VERSION = '1.00';
  
  	# Inherit manually
  	require Exporter;
  	@ISA       = qw{ Exporter };
  	@EXPORT    = qw{ home     };
  	@EXPORT_OK = qw{
  		home
  		my_home
  		my_desktop
  		my_documents
  		my_music
  		my_pictures
  		my_videos
  		my_data
  		my_dist_config
  		my_dist_data
  		users_home
  		users_desktop
  		users_documents
  		users_music
  		users_pictures
  		users_videos
  		users_data
  	};
  
  	# %~ doesn't need (and won't take) exporting, as it's a magic
  	# symbol name that's always looked for in package 'main'.
  }
  
  # Inlined Params::Util functions
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  
  # Platform detection
  if ( $IMPLEMENTED_BY ) {
  	# Allow for custom HomeDir classes
  	# Leave it as the existing value
  } elsif ( $^O eq 'MSWin32' ) {
  	# All versions of Windows
  	$IMPLEMENTED_BY = 'File::HomeDir::Windows';
  } elsif ( $^O eq 'darwin') {
  	# 1st: try Mac::SystemDirectory by chansen
  	if ( eval { require Mac::SystemDirectory; 1 } ) {
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Cocoa';
  	} elsif ( eval { require Mac::Files; 1 } ) {
  		# 2nd try Mac::Files: Carbon - unmaintained since 2006 except some 64bit fixes
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Carbon';
  	} else {
  		# 3rd: fallback: pure perl
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin';
  	}
  } elsif ( $^O eq 'MacOS' ) {
  	# Legacy Mac OS
  	$IMPLEMENTED_BY = 'File::HomeDir::MacOS9';
  } elsif ( File::Which::which('xdg-user-dir') ) {
  	# freedesktop unixes
  	$IMPLEMENTED_BY = 'File::HomeDir::FreeDesktop';
  } else {
  	# Default to Unix semantics
  	$IMPLEMENTED_BY = 'File::HomeDir::Unix';
  }
  unless ( _DRIVER($IMPLEMENTED_BY, 'File::HomeDir::Driver') ) {
  	Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY");
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	$IMPLEMENTED_BY->my_home;
  }
  
  sub my_desktop {
  	$IMPLEMENTED_BY->can('my_desktop')
  		? $IMPLEMENTED_BY->my_desktop
  		: Carp::croak("The my_desktop method is not implemented on this platform");
  }
  
  sub my_documents {
  	$IMPLEMENTED_BY->can('my_documents')
  		? $IMPLEMENTED_BY->my_documents
  		: Carp::croak("The my_documents method is not implemented on this platform");
  }
  
  sub my_music {
  	$IMPLEMENTED_BY->can('my_music')
  		? $IMPLEMENTED_BY->my_music
  		: Carp::croak("The my_music method is not implemented on this platform");
  }
  
  sub my_pictures {
  	$IMPLEMENTED_BY->can('my_pictures')
  		? $IMPLEMENTED_BY->my_pictures
  		: Carp::croak("The my_pictures method is not implemented on this platform");
  }
  
  sub my_videos {
  	$IMPLEMENTED_BY->can('my_videos')
  		? $IMPLEMENTED_BY->my_videos
  		: Carp::croak("The my_videos method is not implemented on this platform");
  }
  
  sub my_data {
  	$IMPLEMENTED_BY->can('my_data')
  		? $IMPLEMENTED_BY->my_data
  		: Carp::croak("The my_data method is not implemented on this platform");
  }
  
  
  sub my_dist_data {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_data method requires an argument");
  	my $data   = my_data();
  
          # If datadir is not defined, there's nothing we can do: bail out
          # and return nothing...	
  	return undef unless defined $data;
  
          # On traditional unixes, hide the top-level directory
  	my $var = $data eq home()
  		? File::Spec->catdir( $data, '.perl', 'dist', $dist )
  		: File::Spec->catdir( $data, 'Perl',  'dist', $dist );
  
  	# directory exists: return it
  	return $var if -d $var;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $var );
  	return $var;
  }
  
  sub my_dist_config {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_config method requires an argument");
  
  	# not all platforms support a specific my_config() method
  	my $config = $IMPLEMENTED_BY->can('my_config')
  		? $IMPLEMENTED_BY->my_config
  		: $IMPLEMENTED_BY->my_documents;
  
  	# If neither configdir nor my_documents is defined, there's
  	# nothing we can do: bail out and return nothing...	
  	return undef unless defined $config;
  
  	# On traditional unixes, hide the top-level dir
  	my $etc = $config eq home()
  		? File::Spec->catdir( $config, '.perl', $dist )
  		: File::Spec->catdir( $config, 'Perl',  $dist );
  
  	# directory exists: return it
  	return $etc if -d $etc;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $etc );
  	return $etc;
  }
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	$IMPLEMENTED_BY->can('users_home')
  		? $IMPLEMENTED_BY->users_home( $_[-1] )
  		: Carp::croak("The users_home method is not implemented on this platform");
  }
  
  sub users_desktop {
  	$IMPLEMENTED_BY->can('users_desktop')
  		? $IMPLEMENTED_BY->users_desktop( $_[-1] )
  		: Carp::croak("The users_desktop method is not implemented on this platform");
  }
  
  sub users_documents {
  	$IMPLEMENTED_BY->can('users_documents')
  		? $IMPLEMENTED_BY->users_documents( $_[-1] )
  		: Carp::croak("The users_documents method is not implemented on this platform");
  }
  
  sub users_music {
  	$IMPLEMENTED_BY->can('users_music')
  		? $IMPLEMENTED_BY->users_music( $_[-1] )
  		: Carp::croak("The users_music method is not implemented on this platform");
  }
  
  sub users_pictures {
  	$IMPLEMENTED_BY->can('users_pictures')
  		? $IMPLEMENTED_BY->users_pictures( $_[-1] )
  		: Carp::croak("The users_pictures method is not implemented on this platform");
  }
  
  sub users_videos {
  	$IMPLEMENTED_BY->can('users_videos')
  		? $IMPLEMENTED_BY->users_videos( $_[-1] )
  		: Carp::croak("The users_videos method is not implemented on this platform");
  }
  
  sub users_data {
  	$IMPLEMENTED_BY->can('users_data')
  		? $IMPLEMENTED_BY->users_data( $_[-1] )
  		: Carp::croak("The users_data method is not implemented on this platform");
  }
  
  
  
  
  
  #####################################################################
  # Legacy Methods
  
  # Find the home directory of an arbitrary user
  sub home (;$) {
  	# Allow to be called as a method
  	if ( $_[0] and $_[0] eq 'File::HomeDir' ) {
  		shift();
  	}
  
  	# No params means my home
  	return my_home() unless @_;
  
  	# Check the param
  	my $name = shift;
  	if ( ! defined $name ) {
  		Carp::croak("Can't use undef as a username");
  	}
  	if ( ! length $name ) {
  		Carp::croak("Can't use empty-string (\"\") as a username");
  	}
  
  	# A dot also means my home
  	### Is this meant to mean File::Spec->curdir?
  	if ( $name eq '.' ) {
  		return my_home();
  	}
  
  	# Now hand off to the implementor
  	$IMPLEMENTED_BY->users_home($name);
  }
  
  
  
  
  
  #####################################################################
  # Tie-Based Interface
  
  # Okay, things below this point get scary
  
  CLASS: {
  	# Make the class for the %~ tied hash:
  	package File::HomeDir::TIE;
  
  	# Make the singleton object.
  	# (We don't use the hash for anything, though)
  	### THEN WHY MAKE IT???
  	my $SINGLETON = bless {};
  
  	sub TIEHASH { $SINGLETON }
  
  	sub FETCH {
  		# Catch a bad username
  		unless ( defined $_[1] ) {
  			Carp::croak("Can't use undef as a username");
  		}
  
  		# Get our homedir
  		unless ( length $_[1] ) {
  			return File::HomeDir::my_home();
  		}
  
  		# Get a named user's homedir
  		Carp::carp("The tied %~ hash has been deprecated");
  		return File::HomeDir::home($_[1]);
  	}
  
  	sub STORE    { _bad('STORE')    }
  	sub EXISTS   { _bad('EXISTS')   }
  	sub DELETE   { _bad('DELETE')   }
  	sub CLEAR    { _bad('CLEAR')    }
  	sub FIRSTKEY { _bad('FIRSTKEY') }
  	sub NEXTKEY  { _bad('NEXTKEY')  }
  
  	sub _bad ($) {
  		Carp::croak("You can't $_[0] with the %~ hash")
  	}
  }
  
  # Do the actual tie of the global %~ variable
  tie %~, 'File::HomeDir::TIE';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir - Find your home and other directories on any platform
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Modern Interface (Current User)
    $home     = File::HomeDir->my_home;
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $dist     = File::HomeDir->my_dist_data('File-HomeDir');
    $dist     = File::HomeDir->my_dist_config('File-HomeDir');
    
    # Modern Interface (Other Users)
    $home    = File::HomeDir->users_home('foo');
    $desktop = File::HomeDir->users_desktop('foo');
    $docs    = File::HomeDir->users_documents('foo');
    $music   = File::HomeDir->users_music('foo');
    $pics    = File::HomeDir->users_pictures('foo');
    $video   = File::HomeDir->users_videos('foo');
    $data    = File::HomeDir->users_data('foo');
  
  =head1 DESCRIPTION
  
  B<File::HomeDir> is a module for locating the directories that are "owned"
  by a user (typicaly your user) and to solve the various issues that arise
  trying to find them consistently across a wide variety of platforms.
  
  The end result is a single API that can find your resources on any platform,
  making it relatively trivial to create Perl software that works elegantly
  and correctly no matter where you run it.
  
  This module provides two main interfaces.
  
  The first is a modern L<File::Spec>-style interface with a consistent
  OO API and different implementation modules to support various
  platforms. You are B<strongly> recommended to use this interface.
  
  The second interface is for legacy support of the original 0.07 interface
  that exported a C<home()> function by default and tied the C<%~> variable.
  
  It is generally not recommended that you use this interface, but due to
  back-compatibility reasons they will remain supported until at least 2010.
  
  The C<%~> interface has been deprecated. Documentation was removed in 2009,
  Unit test were removed in 2011, usage will issue warnings from 2012, and the
  interface will be removed entirely in 2015  (in line with the general Perl
  toolchain convention of a 10 year support period for legacy APIs that
  are potentially or actually in common use).
  
  =head2 Platform Neutrality
  
  In the Unix world, many different types of data can be mixed together
  in your home directory (although on some Unix platforms this is no longer
  the case, particularly for "desktop"-oriented platforms).
  
  On some non-Unix platforms, separate directories are allocated for
  different types of data and have been for a long time.
  
  When writing applications on top of B<File::HomeDir>, you should thus
  always try to use the most specific method you can. User documents should
  be saved in C<my_documents>, data that supports an application but isn't
  normally editing by the user directory should go into C<my_data>.
  
  On platforms that do not make any distinction, all these different
  methods will harmlessly degrade to the main home directory, but on
  platforms that care B<File::HomeDir> will always try to Do The Right
  Thing(tm).
  
  =head1 METHODS
  
  Two types of methods are provided. The C<my_method> series of methods for
  finding resources for the current user, and the C<users_method> (read as
  "user's method") series for finding resources for arbitrary users.
  
  This split is necessary, as on most platforms it is B<much> easier to find
  information about the current user compared to other users, and indeed
  on a number you cannot find out information such as C<users_desktop> at
  all, due to security restrictions.
  
  All methods will double check (using a C<-d> test) that a directory
  actually exists before returning it, so you may trust in the values
  that are returned (subject to the usual caveats of race conditions of
  directories being deleted at the moment between a directory being returned
  and you using it).
  
  However, because in some cases platforms may not support the concept of home
  directories at all, any method may return C<undef> (both in scalar and list
  context) to indicate that there is no matching directory on the system.
  
  For example, most untrusted 'nobody'-type users do not have a home
  directory. So any modules that are used in a CGI application that
  at some level of recursion use your code, will result in calls to
  File::HomeDir returning undef, even for a basic home() call.
  
  =head2 my_home
  
  The C<my_home> method takes no arguments and returns the main home/profile
  directory for the current user.
  
  If the distinction is important to you, the term "current" refers to the
  real user, and not the effective user.
  
  This is also the case for all of the other "my" methods.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a home directory, or dies on error.
  
  =head2 my_desktop
  
  The C<my_desktop> method takes no arguments and returns the "desktop"
  directory for the current user.
  
  Due to the diversity and complexity of implementions required to deal with
  implementing the required functionality fully and completely, the
  C<my_desktop> method may or may not be implemented on each platform.
  
  That said, I am extremely interested in code to implement C<my_desktop> on
  Unix, as long as it is capable of dealing (as the Windows implementation
  does) with internationalisation. It should also avoid false positive
  results by making sure it only returns the appropriate directories for the
  appropriate platforms.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a desktop directory, or dies on error.
  
  =head2 my_documents
  
  The C<my_documents> method takes no arguments and returns the directory (for
  the current user) where the user's documents are stored.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a documents directory, or dies on error.
  
  =head2 my_music
  
  The C<my_music> method takes no arguments and returns the directory
  where the current user's music is stored.
  
  No bias is made to any particular music type or music program, rather the
  concept of a directory to hold the user's music is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_pictures
  
  The C<my_pictures> method takes no arguments and returns the directory
  where the current user's pictures are stored.
  
  No bias is made to any particular picture type or picture program, rather the
  concept of a directory to hold the user's pictures is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_videos
  
  The C<my_videos> method takes no arguments and returns the directory
  where the current user's videos are stored.
  
  No bias is made to any particular video type or video program, rather the
  concept of a directory to hold the user's videos is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_data
  
  The C<my_data> method takes no arguments and returns the directory where
  local applications should stored their internal data for the current
  user.
  
  Generally an application would create a subdirectory such as C<.foo>,
  beneath this directory, and store its data there. By creating your
  directory this way, you get an accurate result on the maximum number of
  platforms. But see the documentation about C<my_dist_config()> or
  C<my_dist_data()> below.
  
  For example, on Unix you get C<~/.foo> and on Win32 you get
  C<~/Local Settings/Application Data/.foo>
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a data directory, or dies on error.
  
  
  =head2 my_dist_config
  
    File::HomeDir->my_dist_config( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_config( 'File-HomeDir' );
    File::HomeDir->my_dist_config( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_config> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal configuration.
  
  The base directory will be either C<my_config> if the platform supports
  it, or C<my_documents> otherwise. The subdirectory itself will be 
  C<BASE/Perl/Dist-Name>. If the base directory is the user's homedir,
  C<my_dist_config> will be in C<~/.perl/Dist-Name> (and thus be hidden on
  all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  
  =head2 my_dist_data
  
    File::HomeDir->my_dist_data( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_data( 'File-HomeDir' );
    File::HomeDir->my_dist_data( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_data> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal data.
  
  This directory will be of course a subdirectory of C<my_data>. Platforms
  supporting data-specific directories will use
  C<DATA_DIR/perl/dist/Dist-Name> following the common
  "DATA/vendor/application" pattern. If the C<my_data> directory is the
  user's homedir, C<my_dist_data> will be in C<~/.perl/dist/Dist-Name>
  (and thus be hidden on all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  =head2 users_home
  
    $home = File::HomeDir->users_home('foo');
  
  The C<users_home> method takes a single param and is used to locate the
  parent home/profile directory for an identified user on the system.
  
  While most of the time this identifier would be some form of user name,
  it is permitted to vary per-platform to support user ids or UUIDs as
  applicable for that platform.
  
  Returns the directory path as a string, C<undef> if that user
  does not have a home directory, or dies on error.
  
  =head2 users_documents
  
    $docs = File::HomeDir->users_documents('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a documents directory, or dies on error.
  
  =head2 users_data
  
    $data = File::HomeDir->users_data('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a data directory, or dies on error.
  
  =head1 FUNCTIONS
  
  =head2 home
  
    use File::HomeDir;
    $home = home();
    $home = home('foo');
    $home = File::HomeDir::home();
    $home = File::HomeDir::home('foo');
  
  The C<home> function is exported by default and is provided for
  compatibility with legacy applications. In new applications, you should
  use the newer method-based interface above.
  
  Returns the directory path to a named user's home/profile directory.
  
  If provided no param, returns the directory path to the current user's
  home/profile directory.
  
  =head1 TO DO
  
  =over 4
  
  =item * Add more granularity to Unix, and add support to VMS and other
  esoteric platforms, so we can consider going core.
  
  =item * Add consistent support for users_* methods 
  
  =back
  
  =head1 SUPPORT
  
  This module is stored in an Open Repository at the following address.
  
  L<http://svn.ali.as/cpan/trunk/File-HomeDir>
  
  Write access to the repository is made available automatically to any
  published CPAN author, and to most other volunteers on request.
  
  If you are able to submit your bug report in the form of new (failing)
  unit tests, or can apply your fix directly instead of submitting a patch,
  you are B<strongly> encouraged to do so as the author currently maintains
  over 100 modules and it can take some time to deal with non-Critical bug
  reports or patches.
  
  This will guarantee that your issue will be addressed in the next
  release of the module.
  
  If you cannot provide a direct test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the CPAN
  bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-HomeDir>
  
  For other issues, for commercial enhancement or support, or to have your
  write access enabled for the repository, contact the author at the email
  address above.
  
  =head1 ACKNOWLEDGEMENTS
  
  The biggest acknowledgement goes to Chris Nandor, who wielded his
  legendary Mac-fu and turned my initial fairly ordinary Darwin
  implementation into something that actually worked properly everywhere,
  and then donated a Mac OS X license to allow it to be maintained properly.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  Chris Nandor E<lt>cnandor@cpan.orgE<gt>
  
  Stephen Steneker E<lt>stennie@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  Some parts copyright 2006 Chris Nandor.
  
  Some parts copyright 2006 Stephen Steneker.
  
  Some parts copyright 2009-2011 Jérôme Quelin.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;
  
  use 5.00503;
  use strict;
  use Cwd                 ();
  use Carp                ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	my $home = (getpwuid($<))[7];
  	return $home if $home && -d $home;
  
  	return undef;
  }
  
  sub _my_home {
  	my($class, $path) = @_;
  	my $home = $class->my_home;
  	return undef unless defined $home;
  
  	my $folder = "$home/$path";
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  sub my_desktop {
  	my $class = shift;
  	$class->_my_home('Desktop');
  }
  
  sub my_documents {
  	my $class = shift;
  	$class->_my_home('Documents');
  }
  
  sub my_data {
  	my $class = shift;
  	$class->_my_home('Library/Application Support');
  }
  
  sub my_music {
  	my $class = shift;
  	$class->_my_home('Music');
  }
  
  sub my_pictures {
  	my $class = shift;
  	$class->_my_home('Pictures');
  }
  
  sub my_videos {
  	my $class = shift;
  	$class->_my_home('Movies');
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Mac OS X specific file path for determining
  common user directories in pure perl, by just using C<$ENV{HOME}>
  without Carbon nor Cocoa API calls. In normal usage this module will
  always be used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;
  
  # Basic implementation for the Dawin family of operating systems.
  # This includes (most prominently) Mac OS X.
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  
  	# This is only a child class of the pure Perl darwin
  	# class so that we can do homedir detection of all three
  	# drivers at one via ->isa.
  	@ISA = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kCurrentUserFolderType(),
  	);
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDesktopFolderType(),
  	);
  }
  
  sub my_documents {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDocumentsFolderType(),
  	);
  }
  
  sub my_data {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kApplicationSupportFolderType(),
  	);
  }
  
  sub my_music {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMusicDocumentsFolderType(),
  	);
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kPictureDocumentsFolderType(),
  	);
  }
  
  sub my_videos {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMovieDocumentsFolderType(),
  	);
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::Files;
  	my $folder = Mac::Files::FindFolder(
  		Mac::Files::kUserDomain(),
  		$name,
  	);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  # in theory this can be done, but for now, let's cheat, since the
  # rest is Hard
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Note -- since this module requires Mac::Carbon and Mac::Carbon does
  not work with 64-bit perls, on such systems, File::HomeDir will try
  L<File::HomeDir::Darwin::Cocoa> and then fall back to the (pure Perl)
  L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
  
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =head1 TODO
  
  =over 4
  
  =item * Test with Mac OS (versions 7, 8, 9)
  
  =item * Some better way for users_* ?
  
  =back
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::SystemDirectory'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::SystemDirectory;
  	return Mac::SystemDirectory::HomeDirectory();
  }
  
  # from 10.4
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())
  	}
  	||
  	$class->SUPER::my_desktop;
  }
  
  # from 10.2
  sub my_documents {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())
  	}
  	||
  	$class->SUPER::my_documents;
  }
  
  # from 10.4
  sub my_data {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())
  	}
  	||
  	$class->SUPER::my_data;
  }
  
  # from 10.6
  sub my_music {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())
  	}
  	||
  	$class->SUPER::my_music;
  }
  
  # from 10.6
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())
  	}
  	||
  	$class->SUPER::my_pictures;
  }
  
  # from 10.6
  sub my_videos {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())
  	}
  	||
  	$class->SUPER::my_videos;
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::SystemDirectory;
  	my $folder = Mac::SystemDirectory::FindDirectory($name);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin::Cocoa - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories using Cocoa API through
  L<Mac::SystemDirectory>.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Theoretically, this should return the same paths as both of the other
  Darwin drivers.
  
  Because this module requires L<Mac::SystemDirectory>, if the module
  is not installed, L<File::HomeDir> will fall back to L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;
  
  # Abstract base class that provides no functionality,
  # but confirms the class is a File::HomeDir driver class.
  
  use 5.00503;
  use strict;
  use Carp ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.00';
  }
  
  sub my_home {
  	Carp::croak("$_[0] does not implement compulsory method $_[1]");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Driver - Base class for all File::HomeDir drivers
  
  =head1 DESCRIPTION
  
  This module is the base class for all L<File::HomeDir> drivers, and must
  be inherited from to identify a class as a driver.
  
  It is primarily provided as a convenience for this specific identification
  purpose, as L<File::HomeDir> supports the specification of custom drivers
  and an C<-E<gt>isa> check is used during the loading of the driver.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;
  
  # Specific functionality for unixes running free desktops
  # compatible with (but not using) File-BaseDir-0.03
  
  # See POD at the end of the file for more documentation.
  
  use 5.00503;
  use strict;
  use Carp                ();
  use File::Spec          ();
  use File::Which         ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  # xdg uses $ENV{XDG_CONFIG_HOME}/user-dirs.dirs to know where are the
  # various "my xxx" directories. That is a shell file. The official API
  # is the xdg-user-dir executable. It has no provision for assessing
  # the directories of a user that is different than the one we are
  # running under; the standard substitute user mechanisms are needed to
  # overcome this.
  
  my $xdgprog = File::Which::which('xdg-user-dir');
  
  sub _my {
  	# No quoting because input is hard-coded and only comes from this module
  	my $thingy = qx($xdgprog $_[1]);
  	chomp $thingy;
  	return $thingy;
  }
  
  # Simple stuff
  sub my_desktop   { shift->_my('DESKTOP')   }
  sub my_documents { shift->_my('DOCUMENTS') }
  sub my_music     { shift->_my('MUSIC')     }
  sub my_pictures  { shift->_my('PICTURES')  }
  sub my_videos    { shift->_my('VIDEOS')    }
  
  sub my_data {
  	$ENV{XDG_DATA_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .local share }
  	);
  }
  
  sub my_config {
  	$ENV{XDG_CONFIG_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .config }
  	);
  }
  
  # Custom locations (currently undocumented)
  sub my_download    { shift->_my('DOWNLOAD')    }
  sub my_publicshare { shift->_my('PUBLICSHARE') }
  sub my_templates   { shift->_my('TEMPLATES')   }
  
  sub my_cache {
      $ENV{XDG_CACHE_HOME}
      ||
      File::Spec->catdir(shift->my_home, qw{ .cache });
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_desktop   { Carp::croak('The users_desktop method is not available on an XDG based system.');   }
  sub users_documents { Carp::croak('The users_documents method is not available on an XDG based system.'); }
  sub users_music     { Carp::croak('The users_music method is not available on an XDG based system.');     }
  sub users_pictures  { Carp::croak('The users_pictures method is not available on an XDG based system.');  }
  sub users_videos    { Carp::croak('The users_videos method is not available on an XDG based system.');    }
  sub users_data      { Carp::croak('The users_data method is not available on an XDG based system.');      }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::FreeDesktop - Find your home and other directories on FreeDesktop.org Unix
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;
    $docs    = File::HomeDir->my_documents;
    $music   = File::HomeDir->my_music;
    $pics    = File::HomeDir->my_pictures;
    $videos  = File::HomeDir->my_videos;
    $data    = File::HomeDir->my_data;
  
  =head1 AUTHORS
  
  Jerome Quelin E<lt>jquellin@cpan.org<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Jerome Quelin.
  
  Some parts copyright 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;
  
  # Half-assed implementation for the legacy Mac OS9 operating system.
  # Provided mainly to provide legacy compatibility. May be removed at
  # a later date.
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  # Load early if in a forking environment and we have
  # prefork, or at run-time if not.
  SCOPE: {
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# Try for $ENV{HOME} if we have it
  	if ( defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	### DESPERATION SETS IN
  
  	# We could use the desktop
  	SCOPE: {
  		local $@;
  		eval {
  			my $home = $class->my_desktop;
  			return $home if $home and -d $home;
  		};
  	}
  
  	# Desperation on any platform
  	SCOPE: {
  		# On some platforms getpwuid dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	Carp::croak("Could not locate current user's home directory");
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# Find the desktop via Mac::Files
  	local $SIG{'__DIE__'} = '';
  	require Mac::Files;
  	my $home = Mac::Files::FindFolder(
  		Mac::Files::kOnSystemDisk(),
  		Mac::Files::kDesktopFolderType(),
  		);
  	return $home if $home and -d $home;
  
  	Carp::croak("Could not locate current user's desktop");
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	SCOPE: {
  		# On some platforms getpwnam dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwnam($name))[7];
  		return $home if defined $home and -d $home;
  	}
  
  	Carp::croak("Failed to find home directory for user '$name'");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::MacOS9 - Find your home and other directories on legacy Macs
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;
    $desktop = File::HomeDir->my_desktop;
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories on legacy Mac hosts. In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module is no longer actively maintained, and is included only for
  extreme back-compatibility.
  
  Only the C<my_home> and C<my_desktop> methods are supported.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::Temp            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA %DIR $ENABLED};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  	%DIR     = ();
  	$ENABLED = 0;
  }
  
  # Special magic use in test scripts
  sub import {
  	my $class = shift;
  	die "Attempted to initialise File::HomeDir::Test trice" if %DIR;
  
  	# Fill the test directories
  	my $BASE  = File::Temp::tempdir( CLEANUP => 1 );
  	%DIR = map { $_ => File::Spec->catdir( $BASE, $_ ) } qw{
  		my_home
  		my_desktop
  		my_documents
  		my_data
  		my_music
  		my_pictures
  		my_videos
  	};
  
  	# Hijack HOME to the home directory
  	$ENV{HOME} = $DIR{my_home};
  
  	# Make File::HomeDir load us instead of the native driver
  	$File::HomeDir::IMPLEMENTED_BY = # Prevent a warning
  	$File::HomeDir::IMPLEMENTED_BY = 'File::HomeDir::Test';
  
  	# Ready to go
  	$ENABLED = 1;
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	mkdir($DIR{my_home}, 0755) unless -d $DIR{my_home};
  	return $DIR{my_home};
  }
  
  sub my_desktop {
  	mkdir($DIR{my_desktop}, 0755) unless -d $DIR{my_desktop};
  	return $DIR{my_desktop};
  }
  
  sub my_documents {
  	mkdir($DIR{my_documents}, 0755) unless -f $DIR{my_documents};
  	return $DIR{my_documents};
  }
  
  sub my_data {
  	mkdir($DIR{my_data}, 0755) unless -d $DIR{my_data};
  	return $DIR{my_data};
  }
  
  sub my_music {
  	mkdir($DIR{my_music}, 0755) unless -d $DIR{my_music};
  	return $DIR{my_music};
  }
  
  sub my_pictures {
  	mkdir($DIR{my_pictures}, 0755) unless -d $DIR{my_pictures};
  	return $DIR{my_pictures};
  }
  
  sub my_videos {
  	mkdir($DIR{my_videos}, 0755) unless -d $DIR{my_videos};
  	return $DIR{my_videos};
  }
  
  sub users_home {
  	return undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Test - Prevent the accidental creation of user-owned files during testing
  
  =head1 SYNOPSIS
  
    use Test::More test => 1;
    use File::HomeDir::Test;
    use File::HomeDir;
  
  =head1 DESCRIPTION
  
  B<File::HomeDir::Test> is a L<File::HomeDir> driver intended for use in the test scripts
  of modules or applications that write files into user-owned directories.
  
  It is designed to prevent the pollution of user directories with files that are not part
  of the application install itself, but were created during testing. These files can leak
  state information from the tests into the run-time usage of an application, and on Unix
  systems also prevents tests (which may be executed as root via sudo) from writing files
  which cannot later be modified or removed by the regular user.
  
  =head1 SUPPORT
  
  See the support section of the main L<File::HomeDir> documentation.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  	my $home  = $class->_my_home(@_);
  
  	# On Unix in general, a non-existant home means "no home"
  	# For example, "nobody"-like users might use /nonexistant
  	if ( defined $home and ! -d $home ) {
  		$home = undef;
  	}
  
  	return $home;
  }
  
  sub _my_home {
  	my $class = shift;
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# This is from the original code, but I'm guessing
  	# it means "login directory" and exists on some Unixes.
  	if ( exists $ENV{LOGDIR} and $ENV{LOGDIR} ) {
  		return $ENV{LOGDIR};
  	}
  
  	### More-desperate methods
  
  	# Light desperation on any (Unixish) platform
  	SCOPE: {
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  # On unix by default, everything is under the same folder
  sub my_desktop {
  	shift->my_home;
  }
  
  sub my_documents {
  	shift->my_home;
  }
  
  sub my_data {
  	shift->my_home;
  }
  
  sub my_music {
  	shift->my_home;
  }
  
  sub my_pictures {
  	shift->my_home;
  }
  
  sub my_videos {
  	shift->my_home;
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	# IF and only if we have getpwuid support, and the
  	# name of the user is our own, shortcut to my_home.
  	# This is needed to handle HOME environment settings.
  	if ( $name eq getpwuid($<) ) {
  		return $class->my_home;
  	}
  
  	SCOPE: {
  		my $home = (getpwnam($name))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  sub users_desktop {
  	shift->users_home(@_);
  }
  
  sub users_documents {
  	shift->users_home(@_);
  }
  
  sub users_data {
  	shift->users_home(@_);
  }
  
  sub users_music {
  	shift->users_home(@_);
  }
  
  sub users_pictures {
  	shift->users_home(@_);
  }
  
  sub users_videos {
  	shift->users_home(@_);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Unix - Find your home and other directories on legacy Unix
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;     # All of these will... 
    $docs    = File::HomeDir->my_documents;   # ...default to home...
    $music   = File::HomeDir->my_music;       # ...directory
    $pics    = File::HomeDir->my_pictures;    #
    $videos  = File::HomeDir->my_videos;      #
    $data    = File::HomeDir->my_data;        # 
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  sub CREATE () { 1 }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# Do we have a user profile?
  	if ( exists $ENV{USERPROFILE} and $ENV{USERPROFILE} ) {
  		return $ENV{USERPROFILE};
  	}
  
  	# Some Windows use something like $ENV{HOME}
  	if ( exists $ENV{HOMEDRIVE} and exists $ENV{HOMEPATH} and $ENV{HOMEDRIVE} and $ENV{HOMEPATH} ) {
  		return File::Spec->catpath(
  			$ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '',
  		);
  	}
  
  	return undef;
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# The most correct way to find the desktop
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_DESKTOP(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	# MSWindows sets WINDIR, MS WinNT sets USERPROFILE.
  	foreach my $e ( 'USERPROFILE', 'WINDIR' ) {
  		next unless $ENV{$e};
  		my $desktop = File::Spec->catdir($ENV{$e}, 'Desktop');
  		return $desktop if $desktop and $class->_d($desktop);
  	}
  
  	# As a last resort, try some hard-wired values
  	foreach my $fixed (
  		# The reason there are both types of slash here is because
  		# this set of paths has been kept from thethe original version
  		# of File::HomeDir::Win32 (before it was rewritten).
  		# I can only assume this is Cygwin-related stuff.
  		"C:\\windows\\desktop",
  		"C:\\win95\\desktop",
  		"C:/win95/desktop",
  		"C:/windows/desktop",
  	) {
  		return $fixed if $class->_d($fixed);
  	}
  
  	return undef;
  }
  
  sub my_documents {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_PERSONAL(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_data {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_music {
  	my $class = shift;
  
  	# The most correct way to find my music
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	# The most correct way to find my pictures
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_videos {
  	my $class = shift;
  
  	# The most correct way to find my videos
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  # Special case version of -d
  sub _d {
  	my $self = shift;
  	my $path = shift;
  
  	# Window can legally return a UNC path from GetFolderPath.
  	# Not only is the meaning of -d complicated in this situation,
  	# but even on a local network calling -d "\\\\cifs\\path" can
  	# take several seconds. UNC can also do even weirder things,
  	# like launching processes and such.
  	# To avoid various crazy bugs caused by this, we do NOT attempt
  	# to validate UNC paths at all so that the code that is calling
  	# us has an opportunity to take special actions without our 
  	# blundering getting in the way.
  	if ( $path =~ /\\\\/ ) {
  		return 1;
  	}
  
  	# Otherwise do a stat as normal
  	return -d $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Windows - Find your home and other directories on Windows
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user (eg. using Windows XP Professional)
    $home    = File::HomeDir->my_home;        # C:\Documents and Settings\mylogin
    $desktop = File::HomeDir->my_desktop;     # C:\Documents and Settings\mylogin\Desktop
    $docs    = File::HomeDir->my_documents;   # C:\Documents and Settings\mylogin\My Documents
    $music   = File::HomeDir->my_music;       # C:\Documents and Settings\mylogin\My Documents\My Music
    $pics    = File::HomeDir->my_pictures;    # C:\Documents and Settings\mylogin\My Documents\My Pictures
    $videos  = File::HomeDir->my_videos;      # C:\Documents and Settings\mylogin\My Documents\My Video
    $data    = File::HomeDir->my_data;        # C:\Documents and Settings\mylogin\Local Settings\Application Data
  
  =head1 DESCRIPTION
  
  This module provides Windows-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Internally this module will use L<Win32>::GetFolderPath to fetch the location
  of your directories. As a result of this, in certain unusual situations
  (usually found inside large organisations) the methods may return UNC paths
  such as C<\\cifs.local\home$>.
  
  If your application runs on Windows and you want to have it work comprehensively
  everywhere, you may need to implement your own handling for these paths as they
  can cause strange behaviour.
  
  For example, stat calls to UNC paths may work but block for several seconds, but
  opendir() may not be able to read any files (creating the appearance of an existing
  but empty directory).
  
  To avoid complicating the problem any further, in the rare situation that a UNC path
  is returned by C<GetFolderPath> the usual -d validation checks will B<not> be done.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use 5.004;
  use strict;
  use Exporter   ();
  use File::Spec ();
  
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK};
  BEGIN {
  	$VERSION   = '1.09';
  	@ISA       = 'Exporter';
  	@EXPORT    = 'which';
  	@EXPORT_OK = 'where';
  }
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
  	# WinNT. PATHEXT might be set on Cygwin, but not used.
  	if ( $ENV{PATHEXT} ) {
  		push @PATHEXT, split ';', $ENV{PATHEXT};
  	} else {
  		# Win9X or other: doesn't have PATHEXT, so needs hardcoded.
  		push @PATHEXT, qw{.com .exe .bat};
  	}
  } elsif ( IS_VMS ) {
  	push @PATHEXT, qw{.exe .com};
  }
  
  sub which {
  	my ($exec) = @_;
  
  	return undef unless $exec;
  
  	my $all = wantarray;
  	my @results = ();
  
  	# check for aliases first
  	if ( IS_VMS ) {
  		my $symbol = `SHOW SYMBOL $exec`;
  		chomp($symbol);
  		unless ( $? ) {
  			return $symbol unless $all;
  			push @results, $symbol;
  		}
  	}
  	if ( IS_MAC ) {
  		my @aliases = split /\,/, $ENV{Aliases};
  		foreach my $alias ( @aliases ) {
  			# This has not been tested!!
  			# PPT which says MPW-Perl cannot resolve `Alias $alias`,
  			# let's just hope it's fixed
  			if ( lc($alias) eq lc($exec) ) {
  				chomp(my $file = `Alias $alias`);
  				last unless $file;  # if it failed, just go on the normal way
  				return $file unless $all;
  				push @results, $file;
  				# we can stop this loop as if it finds more aliases matching,
  				# it'll just be the same result anyway
  				last;
  			}
  		}
  	}
  
  	my @path = File::Spec->path;
  	if ( IS_DOS or IS_VMS or IS_MAC ) {
  		unshift @path, File::Spec->curdir;
  	}
  
  	foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
  		for my $ext ( @PATHEXT ) {
  			my $file = $base.$ext;
  
  			# We don't want dirs (as they are -x)
  			next if -d $file;
  
  			if (
  				# Executable, normal case
  				-x _
  				or (
  					# MacOS doesn't mark as executable so we check -e
  					IS_MAC
  					||
  					(
  						IS_DOS
  						and
  						grep {
  							$file =~ /$_\z/i
  						} @PATHEXT[1..$#PATHEXT]
  					)
  					# DOSish systems don't pass -x on
  					# non-exe/bat/com files. so we check -e.
  					# However, we don't want to pass -e on files
  					# that aren't in PATHEXT, like README.
  					and -e _
  				)
  			) {
  				return $file unless $all;
  				push @results, $file;
  			}
  		}
  	}
  
  	if ( $all ) {
  		return @results;
  	} else {
  		return undef;
  	}
  }
  
  sub where {
  	# force wantarray
  	my @res = which($_[0]);
  	return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::Which - Portable implementation of the `which' utility
  
  =head1 SYNOPSIS
  
    use File::Which;                  # exports which()
    use File::Which qw(which where);  # exports which() and where()
    
    my $exe_path = which('perldoc');
    
    my @paths = where('perl');
    - Or -
    my @paths = which('perl'); # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  C<File::Which> was created to be able to get the paths to executable programs
  on systems under which the `which' program wasn't implemented in the shell.
  
  C<File::Which> searches the directories of the user's C<PATH> (as returned by
  C<File::Spec-E<gt>path()>), looking for executable files having the name
  specified as a parameter to C<which()>. Under Win32 systems, which do not have a
  notion of directly executable files, but uses special extensions such as C<.exe>
  and C<.bat> to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head1 Steps Used on Win32, DOS, OS2 and VMS
  
  =head2 Windows NT
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head2 Windows 9x and other ancient Win/DOS/OS2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  =head2 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  =head1 Functions
  
  =head2 which($short_exe_name)
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where($short_exe_name)
  
  Not exported by default.
  
  Same as C<which($short_exe_name)> in array context. Same as the
  C<`where'> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 BUGS AND CAVEATS
  
  Not tested on VMS or MacOS, although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  File::Spec adds the current directory to the front of PATH if on
  Win32, VMS or MacOS. I have no knowledge of those so don't know if the
  current directory is searced first or not. Could someone please tell
  me?
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-Which>
  
  For other issues, contact the maintainer.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Per Einar Ellefsen E<lt>pereinar@cpan.orgE<gt>
  
  Originated in F<modperl-2.0/lib/Apache/Build.pm>. Changed for use in DocSet
  (for the mod_perl site) and Win32-awareness by me, with slight modifications
  by Stas Bekman, then extracted to create C<File::Which>.
  
  Version 0.04 had some significant platform-related changes, taken from
  the Perl Power Tools C<`which'> implementation by Abigail with
  enhancements from Peter Prymmer. See
  L<http://www.perl.com/language/ppt/src/which/index.html> for more
  information.
  
  =head1 COPYRIGHT
  
  Copyright 2002 Per Einar Ellefsen.
  
  Some parts copyright 2009 Adam Kennedy.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<which(1)>, Perl Power Tools:
  L<http://www.perl.com/language/ppt/index.html>.
  
  =cut
FILE_WHICH

$fatpacked{"FindBin/libs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FINDBIN_LIBS';
  ########################################################################
  # libs_curr_pm
  #
  # use $FindBin::Bin to search for 'lib' directories and use them.
  #
  # default action is to look for dir's named "lib" and silently use
  # the lib's without exporting anything. print turns on a short 
  # message with the abs_path results, export pushes out a variable
  # (default name is the base value), verbose turns on decision output
  # and print. export takes an optional argument with the name of a
  # variable to export.
  #
  # 
  ########################################################################
  
  ########################################################################
  # housekeeping
  ########################################################################
  
  package FindBin::libs;
  
  use v5.10;
  use strict;
  
  use FindBin;
  
  use File::Basename;
  
  use Carp    qw( croak                   );
  use Symbol  qw( qualify qualify_to_ref  );
  
  use File::Spec::Functions
  qw
  (
      &splitpath
      &splitdir
      &catpath
      &catdir
  );
  
  BEGIN
  {
      # however... there have been complaints of 
      # places where abs_path does not work. 
      #
      # if abs_path fails on the working directory
      # then replace it with rel2abs and live with 
      # possibly slower, redundant directories.
      #
      # the abs_path '//' hack allows for testing 
      # broken abs_path on primitive systems that
      # cannot handle the rooted system being linked
      # back to itself.
  
      use Cwd qw( &abs_path &cwd );
  
      unless( eval {abs_path '//';  abs_path cwd } )
      {
          # abs_path seems to be having problems,
          # fix is to stub it out.
          #
          # undef avoids nastygram.
  
          my $ref = qualify_to_ref 'abs_path', __PACKAGE__;
  
          my $sub = File::Spec::Functions->can( 'rel2abs' );
  
          undef &{ $ref };
  
          *$ref = $sub
      };
  }
  
  ########################################################################
  # package variables 
  ########################################################################
  
  our $VERSION    = '2.10';
  $VERSION = eval $VERSION;
  
  my %defaultz = 
  (
      base    => 'lib',
      use     => undef,
      blib    => undef,   # prefer ./blib at the first level
  
      subdir  => '',      # add this subdir also if found.
      subonly => undef,   # leave out lib's, use only subdir.
      export  => undef,   # push variable into caller's space.
      append  => undef,   # push onto existing array (vs. overwrite)
      verbose => undef,   # boolean: print inputs, results.
      debug   => undef,   # boolean: set internal breakpoints.
  
      print   => 1,       # display the results
  
      p5lib   => undef,   # prefix PERL5LIB with the results
  
      ignore => '/,/usr', # dir's to skip looking for ./lib
  );
  
  # only new directories are used, ignore pre-loads
  # this with unwanted values.
  
  my %found = ();
  
  # saves passing this between import and $handle_args.
  
  my %argz    = ();
  my $verbose = '';
  my $empty   = q{};
  
  ########################################################################
  # subroutines
  ########################################################################
  
  # HAK ALERT: $Bin is an absolute path, there are cases
  # where splitdir does not add the leading '' onto the
  # directory path for it on VMS. Fix is to unshift a leading
  # '' into @dirpath where the leading entry is true.
  
  my $find_libs
  = sub
  {
      my $base    = basename ( shift || $argz{ base } );
  
      my $subdir  = $argz{ subdir } || '';
  
      my $subonly = defined $argz{ subonly };
  
      # for some reason, RH Enterprise V/4 has a 
      # trailing '/'; I havn't seen another copy of 
      # FindBin that does this. fix is quick enough: 
      # strip the trailing '/'.
      #
      # using a regex to extract the value untaints it
      # (not useful for anything much, just helps the
      # poor slobs stuck in taint mode).
      #
      # after that splitpath can grab the directory 
      # portion for future use.
  
      my ( $Bin ) = ( $argz{ Bin } =~ m{^ (.+) }xs );
  
      print STDERR "\nSearching $Bin for '$base'...\n"
      if $verbose;
  
      my( $vol, $dir ) = splitpath $Bin, 1;
  
      my @dirpath = splitdir $dir;
  
      # fix for File::Spec::VMS missing the leading empty
      # string on a split. this can be removed once File::Spec
      # is fixed.
  
      unshift @dirpath, '' if $dirpath[ 0 ];
  
      my @libz    = ();
  
      PATH:
      for( 1 .. @dirpath )
      {
          # note that catpath is extraneous on *NIX; the 
          # volume only means something on DOS- & VMS-based
          # filesystems, and adding an empty basename on 
          # *nix is unnecessary.
          #
          # HAK ALERT: the poor slobs stuck on windog have an
          # abs_path that croaks on missing directories. have
          # to eval the check for subdir's. 
  
          my $abs
          = eval
          {
              abs_path
              catpath $vol, ( catdir @dirpath, $base ), $empty
          }
          || '';
  
          my $sub
          = $subdir
          ? eval { abs_path ( catpath '', $abs, $subdir ) } || ''
          : ''
          ;
  
          my @search = $subonly ? ( $sub ) : ( $abs, $sub );
  
          for my $dir ( @search )
          {
              if( $dir && -d $dir && ! exists $found{ $dir } )
              {
                  $found{ $dir } = ();
  
                  push @libz, $dir;
  
                  last if $argz{ scalar };
              }
          }
  
          pop @dirpath
      }
  
      # caller gets back the existing lib paths 
      # (including volume) walking up the path 
      # from $FindBin::Bin -> root.
      #
      # passing it back as a list isn't all that
      # painful for a few paths.
  
      wantarray ? @libz : \@libz
  };
  
  # break out the messy part into a separate block.
  
  my $handle_args 
  = sub
  {
      # discard the module, rest are arguments.
  
      shift;
  
      # anything after the module are options with arguments
      # assigned via '='.
  
      %argz
      = map
      {
          my $use_undef
          = do
          {
              my %a   = ();
              @a{ qw( export ignore ) } = ();
              \%a
          };
  
          my ( $k, $v ) = split '=', $_, 2;
  
          exists $use_undef->{ $k }
          or $v //= 1;
  
          # "no" inverts the sense of the test.
  
          $k =~ s{^no}{}
          and $v  = ! $v;
  
          ( $k => $v )
      }
      @_;
  
      # stuff "debug=1" into your arguments and perl -d will stop here.
  
      $DB::single = 1 if defined $argz{ debug };
  
      # default if nothing is supplied is to use the result;
      # otherwise, without use supplied either of export or
      # p5lib will turn off use.
  
      if( exists $argz{ use } )
      {
          # nothing further to do
      }
      elsif( defined $argz{ export } || defined $argz{ p5lib } )
      {
          $argz{ use } = undef;
      }
      else
      {
          $argz{ use } = 1;
      }
  
      local $defaultz{ Bin }
      = exists $argz{ realbin }
      ? $FindBin::RealBin
      : $FindBin::Bin
      ;
  
      # now apply the defaults, then sanity check the result.
      # base is a special case since it always has to exist.
      #
      # if $argz{ export } is defined but false then it takes
      # its default from $argz{ base }.
  
      while( my($k,$v) = each %defaultz )
      {
          # //= doesn't work here since undef may be a 
          # legit default.
  
          exists $argz{ $k }
          or
          $argz{ $k } = $v;
      }
  
      exists $argz{ base } && $argz{ base } 
      or croak "Bogus FindBin::libs: missing/false base argument, should be 'base=NAME'";
  
      exists $argz{ export }
      and
      $argz{ export } //= $argz{ base };
  
      $argz{ ignore } =
      [
          grep { $_ } split /\s*,\s*/, $argz{ ignore }
      ];
  
      $verbose = defined $argz{ verbose };
  
      my $base = $argz{ base };
  
      # now locate the libraries.
      #
      # %found contains the abs_path results for each directory to 
      # avoid double-including directories.
      #
      # note: loop short-curcuts for the (usually) list.
  
      %found = ();
  
      for( @{ $argz{ ignore } } )
      {
          if( my $dir = eval { abs_path catdir $_, $base } )
          {
              if( -d $dir )
              {
                  $found{ $dir } = 1;
              }
          }
      }
  };
  
  sub import
  {
      &$handle_args;
  
      my @libz = $find_libs->();
  
      # HAK ALERT: the regex does nothing for security,
      # just dodges -T. putting this down here instead
      # of inside find_libs allows people to use saner
      # untainting plans via find_libs.
  
      @libz   = map { m{ (.+) }xs } @libz;
  
      my $caller = caller;
  
      if( $verbose || defined $argz{ print } )
      {
          local $\ = "\n";
          local $, = "\n\t";
  
          print STDERR "Found */$argz{ base }:", @libz
          if $verbose;
      }
  
      if( $argz{ export } )
      {
          my $ref     = qualify_to_ref $argz{ export }, $caller;
  
          if( $verbose )
          {
              my $dest    = qualify $argz{ export }, $caller;
  
              $argz{ scalar }
              ? print STDERR "\nExporting: \$$dest\n"
              : print STDERR "\nExporting: \@$dest\n"
              ;
          }
  
          if( $argz{ scalar } )
          {
              *$ref = \$libz[0]
          }
          elsif
          (
              $argz{ append } 
              and
              my $ary = *{ $ref }{ ARRAY }
          )
          {
              push @$ary, @libz;
          }
          else
          {
              *$ref = \@libz
          }
      }
  
      if( defined $argz{ p5lib } )
      {
          # stuff the lib's found at the front of $ENV{ PERL5LIB }
  
          ( substr $ENV{ PERL5LIB }, 0, 0 ) = join ':', @libz, ''
          if @libz;
  
          print STDERR "\nUpdated PERL5LIB:\t$ENV{ PERL5LIB }\n"
          if $verbose;
      }
  
      if( $argz{ use } && @libz )
      {
          # this obviously won't work if lib ever depends 
          # on the caller's package.
          #
          # it does avoids issues with -T blowing up on the
          # old eval technique.
  
          require lib;
  
          lib->import( @libz );
      }
  
      0
  }
  
  # keep require happy
  
  1
  
  __END__
  
  =head1 NAME
  
  FindBin::libs - locate and a 'use lib' or export 
  directories based on $FindBin::Bin.
  
  =head1 SYNOPSIS
  
  This version of FindBin::libs is suitable for 
  Perl v5.10+.
  
      # search up $FindBin::Bin looking for ./lib directories
      # and "use lib" them.
  
      use FindBin::libs;
  
      # same as above with explicit defaults.
  
      use FindBin::libs qw( base=lib use=1 noexport noprint );
  
      # print the lib dir's before using them.
  
      use FindBin::libs qw( print );
  
      # find and use lib "altlib" dir's
  
      use FindBin::libs qw( base=altlib );
  
      # move starting point from $FindBin::Bin to '/tmp'
  
      use FindBin::libs qw( Bin=/tmp base=altlib );
  
      # skip "use lib", export "@altlib" instead.
  
      use FindBin::libs qw( base=altlib export );
  
      # find altlib directories, use lib them and export @mylibs
  
      use FindBin::libs qw( base=altlib export=mylibs use );
  
      # "export" defaults to "nouse", these two are identical:
  
      use FindBin::libs qw( export nouse );
      use FindBin::libs qw( export       );
  
      # use and export are not exclusive:
  
      use FindBin::libs qw( use export            ); # do both
      use FindBin::libs qw( nouse noexport print  ); # print only
      use FindBin::libs qw( nouse noexport        ); # do nothting at all
  
      # print a few interesting messages about the 
      # items found.
  
      use FindBinlibs qw( verbose );
  
      # turn on a breakpoint after the args are prcoessed, before
      # any search/export/use lib is handled.
  
      use FindBin::libs qw( debug );
  
      # prefix PERL5LIB with the lib's found.
  
      use FindBin::libs qw( perl5lib );
  
      # find a subdir of the lib's looked for.
      # the first example will use both ../lib and
      # ../lib/perl5; the second ../lib/perl5/frobnicate
      # (if they exist). it can also be used with export
      # and base to locate special configuration dir's.
      #
      # subonly with a base is useful for locating config
      # files. this finds any "./config/mypackage" dir's
      # without including any ./config dir's. the result
      # ends up in @config (see also "export=", above).
  
      use FindBin::libs qw( subdir=perl5 );
  
      use FindBin::libs qw( subdir=perl5/frobnicate );
  
      use FindBin::libs qw( base=config subdir=mypackage subonly export );
  
      # base and subonly are also useful if your 
      # project is stored in multiple git 
      # repositories. 
      #
      # say you need libs under api_foo/lib from api_bar: a
      # base of the git repository directory with subdir of
      # lib and subonly will pull in those lib dirs.
  
      use FindBin::libs qw( base=api_foo subdir=lib subonly );
  
      # no harm in using this multiple times to use
      # or export multple layers of libs.
  
      use FindBin::libs qw( export                                            );
      use FindBin::libs qw( export=found base=lib                             );
      use FindBin::libs qw( export=binz  base=bin            ignore=/foo,/bar );
      use FindBin::libs qw( export=junk  base=frobnicatorium                  );
      use FindBin::libs qw( export       base=foobar                          );
  
  =head1 DESCRIPTION
  
  =head2 General Use
  
  This module will locate directories along the path to $FindBin::Bin
  and "use lib" or export an array of the directories found. The default
  is to locate "lib" directories and "use lib" them without printing
  the list.
  
  Options controll whether the lib's found are exported into the caller's
  space, exported to PERL5LIB, or printed. Exporting or setting perl5lib
  will turn off the default of "use lib" so that:
  
      use FindBin::libs qw( export );
      use FindBin::libs qw( p5lib  );
  
  are equivalent to 
  
      use FindBin::libs qw( export nouse );
      use FindBin::libs qw( p5lib  nouse );
  
  Combining export with use or p5lib may be useful, p5lib and
  use are probably not all that useful together.
  
  =head3 Alternate directory name: 'base'
  
  The basename searched for can be changed via 'base=name' so
  that
  
      use FindBin::libs qw( base=altlib );
  
  will search for directories named "altlib" and "use lib" them.
  
  =head3 Exporting a variable: "export", "scalar", "append"
  
  =over 4
  
  =item "export"
  
  This installs the results of locating directories into the caller's 
  space. Without any argument, export pushes out a variable named after 
  the located [sub]dir; an argument can be supplied to give the variable 
  name. Without the "scalar" option, the exported variable will be an 
  array in increasing order of "distance" (i.e., "up" the file tree); 
  with the "scalar" option only the first (i.e., "nearest") path is 
  exported.
  
  If "export" is given then "nouse" is assumed; using both leaves the 
  variable exported and its contents handed to "use lib".
  
  For example:
  
      use FindBin::libs qw( export );
  
  will find "lib" directories and export @lib with the
  list of directories found.
  
      use FindBin::libs qw( export=mylibs );
  
  will find "lib" directories and export them as "@mylibs" to
  the caller.
  
  If "export" only is given then the "use" option defaults to 
  false. So:
  
      use FindBin::libs qw( export );
      use FindBin::libs qw( export nouse );
  
  are equivalent. This is mainly for use when looking for data
  directories with the "base=" argument.
  
  If base is used with export the default array name is the base
  directory value:
  
      use FindBin::libs qw( export base=meta );
  
  exports @meta while
  
      use FindBin::libs qw( export=metadirs base=meta );
  
  exports @metadirs as a list of paths ending in "/meta".
  
  The use and export switches are not exclusive:
  
      use FindBin::libs qw( use export=mylibs );
  
  will locate "lib" directories, use lib them, and export 
  @mylibs into the caller's package. 
  
  =item "scalar"
  
  Only searches for the first directory, which is exported (or
  overwritten) as a scalar rather than array. For example, if
  a project directory has ./bin and ./etc dir's then #! code in
  bin with
  
      use FindBin::libs qw( export scalar base=etc );
  
  will have an $etc variable with the absolute path to ./bin/../etc.
  For configuration varibles this is usually what you want and allows
  for "$etc/Foo.conf" rather than "$etc[0]/Foo.conf".
  
  =item "append"
  
  Sometimes it's simpler to accumulate multiple searches into a 
  single array. Say for ./etc dir's in collection of standard
  locations.
  
  In that case:
  
      use FindBin::libs qw( export=etc base=foo subdir=etc );
      use FindBin::libs qw( export=etc base=bar subdir=etc append );
  
  produces something like
  
      (
          /path/to/foo/etc
          /path/to/bar/etc
      )
  
  without append @etc will have only ./bar/etc since the array would
  be overwritten with each call to FB::l::import.
  
  =back
  
  =head3 Subdirectories
  
  The "subdir" and "subonly" settings will add or 
  exclusively use subdir's. This is useful if some
  of your lib's are in ../lib/perl5 along with 
  ../lib or all of the lib's are in ../lib/perl5.
  
  These could be handled with:
  
      use FindBin::libs;
      use FindBin::libs qw( subdir=perl5 subonly );
  
  which uses the "lib" dir's along with any lib/perl5 dirs.
  
  This can also be handy for locating subdir's used
  for configuring packages:
  
      use FindBin::libs qw( export base=config subonly=mypackage );
  
  Will leave @config containing any mypackage dir's found up
  the tree, nearest to closest.
  
  The array format is convienent for locating configuration files
  shared between projects in separate, sibling directories. For
  example given:
  
      ./proj/Foo/etc
      ./proj/etc
  
  with
  
      use FindBin::libs qw( export subdir=etc subonly )
  
  will export @etc with qw( ../proj/Foo/etc ../proj/etc ) in lexical
  order by distance from the #! code. At that point
  
      use List::Util qw( first );
  
      my $path = first { -e "$_/Global.config" } @etc;
  
  will locate the nearest "Global.confg" file. Note that this is 
  not the same as using "scalar" since that will export 
  $etc with only ./Foo/etc. 
  
  =head3 Setting PERL5LIB: p5lib
  
  For cases where the environment is more useful for setting
  up library paths "p5lib" can be used to preload this variable.
  This is mainly useful for automatically including directories
  outside of the parent tree of $FindBin::bin.
  
  For example, using:
  
      $ export PERL5LIB="/usr/local/foo:/usr/local/bar";
  
      $ myprog;
  
  or simply
  
      $ PERL5LIB="/usr/local/lib/foo:/usr/lib/bar" myprog;
  
  (depending on your shell) with #! code including:
  
      use FindBin::libs qw( p5lib );
  
  will not "use lib" any dir's found but will update PERL5LIB
  to something like:
  
      /home/me/sandbox/branches/lib:/usr/local/lib/foo:/usr/lib/bar
  
  This can make controlling the paths used simpler and avoid
  the use of symlinks for some testing (see examples below).
  
  =head2 Skipping directories
  
  By default, lib directories under / and /usr are
  sliently ignored. This normally means that /lib, /usr/lib, and
  '/usr/local/lib' are skipped. The "ignore" parameter provides
  a comma-separated list of directories to ignore:
  
      use FindBin::libs qw( ignore=/skip/this,/and/this/also );
  
  will replace the standard list and thus skip "/skip/this/lib"
  and "/and/this/also/lib". It will search "/lib" and "/usr/lib"
  since the argument ignore list replaces the original one.
  
  =head2 Homegrown Library Management 
  
  An all-too-common occurrance managing perly projects is
  being unable to install new modules becuse "it might 
  break things", and being unable to test them because
  you can't install them. The usual outcome of this is a 
  collection of hard-coded
  
      use lib qw( /usr/local/projectX ... )
  
  code at the top of each #! file that has to be updated by
  hand for each new project.
  
  To get away from this you'll often see relative paths
  for the lib's, which require running the code from one
  specific place. All this does is push the hard-coding
  into cron, shell wrappers, and begin blocks.
  
  With FindBin::libs you need suffer no more.
  
  Automatically finding libraries in and above the executable
  means you can put your modules into cvs/svn and check them
  out with the project, have multiple copies shared by developers,
  or easily move a module up the directory tree in a testbed
  to regression test the module with existing code. All without
  having to modify a single line of code.
  
  =over 4
  
  =item Code-speicfic modules.
  
  Say your sandbox is in ./sandbox and you are currently
  working in ./sandbox/projects/package/bin on a perl
  executable. You may have some number of modules that
  are specific -- or customized -- for this pacakge, 
  share some modules within the project, and may want 
  to use company-wide modules that are managed out of 
  ./sandbox in development. All of this lives under a 
  ./qc tree on the test boxes and under ./production 
  on production servers.
  
  For simplicity, say that your sandbox lives in your
  home direcotry, /home/jowbloe, as a directory or a
  symlink.
  
  If your #! uses FindBin::libs in it then it will
  effectively
  
      use lib
      qw(
          /home/jowbloe/sandbox/lib
          /home/jowbloe/sandbox/project/lib
          /home/jowbloe/sandbox/project/package/lib
      );
  
  if you run /home/jowbloe/sandbox/project/package/bin/foobar.
  This will happen the same way if you use a relative or
  absolute path, perl -d the thing, or if any of the lib
  directories are symlinks outside of your sandbox.
  
  This means that the most specific module directories
  ("closest" to your executable) will be picked up first.
  
  If you have a version of Frobnicate.pm in your ./package/lib
  for modifications fine: you'll use it before the one in 
  ./project or ./sandbox. 
  
  Using the "p5lib" argument can help in case where some of 
  the code lives outside of the sandbox. To test a sandbox
  version of some other module:
  
      use FindBin::libs qw( p5lib );
  
  and
  
      $ PERL5LIB=/other/sandbox/module foobar;
  
  =item Regression Testing
  
  Everntually, however, you'll need to regression test 
  Frobnicate.pm with other modules. 
  
  Fine: move, copy, or symlink it into ./project/lib and
  you can merrily run ./project/*/bin/* with it and see 
  if there are any problems. In fact, so can the nice 
  folks in QC. 
  
  If you want to install and test a new module just 
  prefix it into, say, ./sandbox/lib and all the code
  that has FindBin::libs will simply use it first. 
  
  =item Testing with Symlinks
  
  $FindBin::Bin is relative to where an executable is started from.
  This allows a symlink to change the location of directories used
  by FindBin::libs. Full regression testing of an executable can be
  accomplished with a symlink:
  
      ./sandbox
          ./lib -> /homegrown/dir/lib
          ./lib/What/Ever.pm
  
          ./pre-change
              ./bin/foobar
  
          ./post-change
              ./lib/What/Ever.pm
              ./bin/foobar -> ../../pre-last-change/bin/foobar
  
  Running foobar symlinked into the post-change directory will
  test it with whatever collection of modules is in the post-change
  directory. A large regression test on some collection of 
  changed modules can be performed with a few symlinks into a 
  sandbox area.
  
  =item Managing Configuration and Meta-data Files
  
  The "base" option alters FindBin::libs standard base directory.
  This allows for a heirarchical set of metadata directories:
  
      ./sandbox
          ./meta
          ./project/
              ./meta
  
          ./project/package
              ./bin
              ./meta
  
  with
  
      use FindBin::libs qw( base=meta export );
  
      sub read_meta
      {
          my $base = shift;
  
          for my $dir ( @meta )
          {
              # open the first one and return
              ...
          }
  
          # caller gets back empty list if nothing was read.
  
          ()
      }
  
  =item using "prove" with local modules.
  
  Modules that are not intended for CPAN will not usually have
  a Makefile.PL or Build setup. This makes it harder to check
  the code via "make test". Instead of hacking a one-time 
  Makefile, FindBin::libs can be used to locate modules in 
  a "lib" directory adjacent to the "t: directory. The setup
  for this module would look like:
  
  
      ./t/01.t
      ./t/02.t
      ...
  
      ./lib/FindBin/libs.pm
  
  since the *.t files use FindBin::libs they can locate the 
  most recent version of code without it having to be copied
  into a ./blib directory (usually via make) before being
  processed. If the module did not have a Makefile this would
  allow:
  
      prove t/*.t;
  
  to check the code.
  
  =back
  
  =head1 Notes
  
  =head2 Alternatives
  
  FindBin::libs was developed to avoid pitfalls with
  the items listed below. As of FindBin::libs-1.20,
  this is also mutli-platform, where other techniques
  may be limited to *NIX or at least less portable.
  
  =over 4
  
  =item PERL5LIBS
  
  PERL5LIB can be used to accomplish the same directory
  lookups as FindBin::libs.  The problem is PERL5LIB often
  contains absolte paths and does not automatically change
  depending on where tests are run. This can leave you 
  modifying a file, changing directory to see if it works
  with some other code and testing an unmodified version of 
  the code via PERL5LIB. FindBin::libs avoids this by using
  $FindBin::bin to reference where the code is running from.
  
  The same is true of trying to use almost any environmental
  solution, with Perl's built in mechanism or one based on
  $ENV{ PWD } or qx( pwd ).
  
  Aside: Combining an existing PERL5LIB for 
  out-of-tree lookups with the "p5lib" option 
  works well for most development situations. 
  
  =item use lib qw( ../../../../Lib );
  
  This works, but how many dots do you need to get all
  the working lib's into a module or #! code? Class
  distrubuted among several levels subdirectories may
  have qw( ../../../lib ) vs. qw( ../../../../lib )
  or various combinations of them. Validating these by
  hand (let alone correcting them) leaves me crosseyed
  after only a short session.
  
  =item Anchor on a fixed lib directory.
  
  Given a standard directory, it is possible to use
  something like:
  
      BEGIN
      {
          my ( $libdir ) = $0 =~ m{ ^( .+? )/SOMEDIR/ }x;
  
          eval "use lib qw( $libdir )";
      }
  
  This looks for a standard location (e.g., /path/to/Mylib)
  in the executable path (or cwd) and uses that. 
  
  The main problem here is that if the anchor ever changes
  (e.g., when moving code between projects or relocating 
  directories now that SVN supports it) the path often has
  to change in multiple files. The regex also may have to
  support multiple platforms, or be broken into more complicated
  File::Spec code that probably looks pretty much like what
  
      use FindBin::libs qw( base=Mylib )
  
  does anyway.
  
  =back
  
  =head2 FindBin::libs-1.2+ uses File::Spec
  
  In order to accmodate a wider range of filesystems, 
  the code has been re-written to use File::Spec for
  all directory and volume manglement. 
  
  There is one thing that File::Spec does not handle,
  hoever, which is fully reolving absolute paths. That
  still has to be handled via abs_path, when it works.
  
  The issue is that File::Spec::rel2abs and 
  Cwd::abs_path work differently: abs_path only 
  returns true for existing directories and 
  resolves symlinks; rel2abs simply prepends cwd() 
  to any non-absolute paths.
  
  The difference for FinBin::libs is that 
  including redundant directories can lead to 
  unexpected results in what gets included; 
  looking up the contents of heavily-symlinked 
  paths is slow (and has some -- admittedly 
  unlikely -- failures at runtime). So, abs_path() 
  is the preferred way to find where the lib's 
  really live after they are found looking up the 
  tree. Using abs_path() also avoids problems 
  where the same directory is included twice in a 
  sandbox' tree via symlinks.
  
  Due to previous complaints that abs_path did not 
  work properly on all systems, the current 
  version of FindBin::libs uses File::Spec to 
  break apart and re-assemble directories, with 
  abs_path used optinally. If "abs_path cwd" works 
  then abs_path is used on the directory paths 
  handed by File::Spec::catpath(); otherwise the 
  paths are used as-is. This may leave users on 
  systms with non-working abs_path() having extra
  copies of external library directories in @INC.
  
  Another issue is that I've heard reports of 
  some systems failing the '-d' test on symlinks,
  where '-e' would have succeded. 
  
  =head1 See Also
  
  =over 4
  
  =item File::Spec
  
  This is used for portability in dis- and re-assembling 
  directory paths based on $FindBin::Bin.
  
  =item Older code.
  
  FindBin::libs_5_8.pm is installed if $^V indicates
  that the running perl is prior to v5.10.
  
  =back
  
  =head1 BUGS
  
  =over 4
  
  =item 
  
  In order to avoid including junk, FindBin::libs
  uses '-d' to test the items before including
  them on the library list. This works fine so 
  long as abs_path() is used to disambiguate any
  symlinks first. If abs_path() is turned off
  then legitimate directories may be left off in
  whatever local conditions might cause a valid
  symlink to fail the '-d' test."
  
  =item
  
  File::Spec 3.16 and prior have a bug in VMS of
  not returning an absolute paths in splitdir for
  dir's without a leading '.'. Fix for this is to
  unshift '', @dirpath if $dirpath[0]. While not a
  bug, this is obviously a somewhat kludgy workaround
  and should be removed (with an added test for a 
  working version) once the File::Spec is fixed.
  
  =item 
  
  The hack for prior-to-5.12 versions of perl is 
  messy, but is the only I've found that works for
  the moment on *NIX, VMS, and MSW. I am not sure
  whether any of these systems are normally configured
  to share perl modules between versions. If the 
  moduels are not shared on multiple platforms then
  I can make this work by managing the installation
  rather than checking this every time at startup.
  
  For the moment, at least, this seems to work.
  
  =back
  
  =head1 AUTHOR
  
  Steven Lembark, Workhorse Computing <lembark@wrkhors.com>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2003-2014, Steven Lembark, Workhorse Computing.
  This code is released under the same terms as Perl-5.20
  or any later version of Perl.
FINDBIN_LIBS

$fatpacked{"Import/Into.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IMPORT_INTO';
  package Import::Into;
  
  use strict;
  use warnings FATAL => 'all';
  
  our $VERSION = '1.002000'; # 1.2.0
  
  sub _prelude {
    my $target = shift;
    my ($package, $file, $line, $level)
      = ref $target         ? @{$target}{qw(package filename line)}
      : $target =~ /[^0-9]/ ? ($target)
                            : (undef, undef, undef, $target);
    if (defined $level) {
      my ($p, $fn, $ln) = caller($level + 2);
      $package ||= $p;
      $file    ||= $fn;
      $line    ||= $ln;
    }
    qq{package $package;\n}
      . ($file ? "#line $line \"$file\"\n" : '')
  }
  
  sub _make_action {
    my ($action, $target) = @_;
    my $version = ref $target && $target->{version};
    my $ver_check = $version ? '$_[0]->VERSION($version);' : '';
    eval _prelude($target).qq{sub { $ver_check shift->$action(\@_) }}
      or die "Failed to build action sub to ${action} for ${target}: $@";
  }
  
  sub import::into {
    my ($class, $target, @args) = @_;
    _make_action(import => $target)->($class, @args);
  }
  
  sub unimport::out_of {
    my ($class, $target, @args) = @_;
    _make_action(unimport => $target)->($class, @args);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Import::Into - import packages into other packages
  
  =head1 SYNOPSIS
  
    package My::MultiExporter;
  
    use Import::Into;
  
    use Thing1 ();
    use Thing2 ();
  
    # simple
    sub import {
      Thing1->import::into(scalar caller);
    }
  
    # multiple
    sub import {
      my $target = caller;
      Thing1->import::into($target);
      Thing2->import::into($target, qw(import arguments));
    }
  
    # by level
    sub import {
      Thing1->import::into(1);
    }
  
    # with exporter
    use base qw(Exporter);
    sub import {
      shift->export_to_level(1);
      Thing1->import::into(1);
    }
  
    # no My::MultiExporter == no Thing1
    sub unimport {
      Thing1->unimport::out_of(scalar caller);
    }
  
  People wanting to re-export your module should also be using L<Import::Into>.
  Any exporter or pragma will work seamlessly.
  
  Note: You do B<not> need to make any changes to Thing1 to be able to call
  C<import::into> on it. This is a global method, and is callable on any
  package (and in fact on any object as well, although it's rarer that you'd
  want to do that).
  
  =head1 DESCRIPTION
  
  Writing exporters is a pain. Some use L<Exporter>, some use L<Sub::Exporter>,
  some use L<Moose::Exporter>, some use L<Exporter::Declare> ... and some things
  are pragmas.
  
  Exporting on someone else's behalf is harder.  The exporters don't provide a
  consistent API for this, and pragmas need to have their import method called
  directly, since they effect the current unit of compilation.
  
  C<Import::Into> provides global methods to make this painless.
  
  =head1 METHODS
  
  =head2 $package->import::into( $target, @arguments );
  
  A global method, callable on any package.  Imports the given package into
  C<$target>.  C<@arguments> are passed along to the package's import method.
  
  C<$target> can be an package name to export to, an integer for the
  caller level to export to, or a hashref with the following options:
  
  =over 4
  
  =item package
  
  The target package to export to.
  
  =item filename
  
  The apparent filename to export to.  Some exporting modules, such as
  L<autodie> or L<strictures>, care about the filename they are being imported
  to.
  
  =item line
  
  The apparent line number to export to.  To be combined with the C<filename>
  option.
  
  =item level
  
  The caller level to export to.  This will automatically populate the
  C<package>, C<filename>, and C<line> options, making it the easiest most
  constent option.
  
  =item version
  
  A version number to check for the module.  The equivalent of specifying the
  version number on a C<use> line.
  
  =back
  
  =head2 $package->unimport::out_of( $target, @arguments );
  
  Equivalent to C<import::into>, but dispatches to C<$package>'s C<unimport>
  method instead of C<import>.
  
  =head1 WHY USE THIS MODULE
  
  The APIs for exporting modules aren't consistent.  L<Exporter> subclasses
  provide export_to_level, but if they overrode their import method all bets
  are off.  L<Sub::Exporter> provides an into parameter but figuring out
  something used it isn't trivial. Pragmas need to have their C<import> method
  called directly since they affect the current unit of compilation.
  
  It's ... annoying.
  
  However, there is an approach that actually works for all of these types.
  
    eval "package $target; use $thing;"
  
  will work for anything checking caller, which is everything except pragmas.
  But it doesn't work for pragmas - pragmas need:
  
    $thing->import;
  
  because they're designed to affect the code currently being compiled - so
  within an eval, that's the scope of the eval itself, not the module that
  just C<use>d you - so
  
    sub import {
      eval "use strict;"
    }
  
  doesn't do what you wanted, but
  
    sub import {
      strict->import;
    }
  
  will apply L<strict> to the calling file correctly.
  
  Of course, now you have two new problems - first, that you still need to
  know if something's a pragma, and second that you can't use either of
  these approaches alone on something like L<Moose> or L<Moo> that's both
  an exporter and a pragma.
  
  So, a solution for that is:
  
    my $sub = eval "package $target; sub { shift->import(\@_) }";
    $sub->($thing, @import_args);
  
  which means that import is called from the right place for pragmas to take
  effect, and from the right package for caller checking to work - and so
  behaves correctly for all types of exporter, for pragmas, and for hybrids.
  
  Additionally, some import routines check the filename they are being imported
  to.  This can be dealt with by generating a L<#line directive|perlsyn/Plain
  Old Comments (Not!)> in the eval, which will change what C<caller> reports for
  the filename when called in the importer. The filename and line number to use
  in the directive then need to be fetched using C<caller>:
  
    my ($target, $file, $line) = caller(1);
    my $sub = eval qq{
      package $target;
    #line $line "$file"
      sub { shift->import(\@_) }
    };
    $sub->($thing, @import_args);
  
  And you need to switch between these implementations depending on if you are
  targetting a specific package, or something in your call stack.
  
  Remembering all this, however, is excessively irritating. So I wrote a module
  so I didn't have to anymore. Loading L<Import::Into> creates a global method
  C<import::into> which you can call on any package to import it into another
  package. So now you can simply write:
  
    use Import::Into;
  
    $thing->import::into($target, @import_args);
  
  This works because of how perl resolves method calls - a call to a simple
  method name is resolved against the package of the class or object, so
  
    $thing->method_name(@args);
  
  is roughly equivalent to:
  
    my $code_ref = $thing->can('method_name');
    $code_ref->($thing, @args);
  
  while if a C<::> is found, the lookup is made relative to the package name
  (i.e. everything before the last C<::>) so
  
    $thing->Package::Name::method_name(@args);
  
  is roughly equivalent to:
  
    my $code_ref = Package::Name->can('method_name');
    $code_ref->($thing, @args);
  
  So since L<Import::Into> defines a method C<into> in package C<import>
  the syntax reliably calls that.
  
  For more craziness of this order, have a look at the article I wrote at
  L<http://shadow.cat/blog/matt-s-trout/madness-with-methods> which covers
  coderef abuse and the C<${\...}> syntax.
  
  Final note: You do still need to ensure that you already loaded C<$thing> - if
  you're receiving this from a parameter, I recommend using L<Module::Runtime>:
  
    use Import::Into;
    use Module::Runtime qw(use_module);
  
    use_module($thing)->import::into($target, @import_args);
  
  And that's it.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Getty for asking "how can I get C<< use strict; use warnings; >>
  turned on for all consumers of my code?" and then "why is this not a
  module?!".
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Import::Into L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
IMPORT_INTO

$fatpacked{"Log/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE';
  package Log::Message;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  
  use Params::Check qw[check];
  use Log::Message::Item;
  use Log::Message::Config;
  use Locale::Maketext::Simple Style => 'gettext';
  
  local $Params::Check::VERBOSE = 1;
  
  BEGIN {
      use vars        qw[$VERSION @ISA $STACK $CONFIG];
      $VERSION    =   '0.08';
      $STACK      =   [];
  }
  
  
  =pod
  
  =head1 NAME
  
  Log::Message - A generic message storing mechanism;
  
  =head1 SYNOPSIS
  
      use Log::Message private => 0, config => '/our/cf_file';
  
      my $log = Log::Message->new(    private => 1,
                                      level   => 'log',
                                      config  => '/my/cf_file',
                                 );
  
      $log->store('this is my first message');
  
      $log->store(    message => 'message #2',
                      tag     => 'MY_TAG',
                      level   => 'carp',
                      extra   => ['this is an argument to the handler'],
                 );
  
      my @last_five_items = $log->retrieve(5);
  
      my @items = $log->retrieve( tag     => qr/my_tag/i,
                                  message => qr/\d/,
                                  remove  => 1,
                                );
  
      my @items = $log->final( level => qr/carp/, amount => 2 );
  
      my $first_error = $log->first()
  
      # croak with the last error on the stack
      $log->final->croak;
  
      # empty the stack
      $log->flush();
  
  
  =head1 DESCRIPTION
  
  Log::Message is a generic message storage mechanism.
  It allows you to store messages on a stack -- either shared or private
  -- and assign meta-data to it.
  Some meta-data will automatically be added for you, like a timestamp
  and a stack trace, but some can be filled in by the user, like a tag
  by which to identify it or group it, and a level at which to handle
  the message (for example, log it, or die with it)
  
  Log::Message also provides a powerful way of searching through items
  by regexes on messages, tags and level.
  
  =head1 Hierarchy
  
  There are 4 modules of interest when dealing with the Log::Message::*
  modules:
  
  =over 4
  
  =item Log::Message
  
  Log::Message provides a few methods to manipulate the stack it keeps.
  It has the option of keeping either a private or a public stack.
  More on this below.
  
  =item Log::Message::Item
  
  These are individual message items, which are objects that contain
  the user message as well as the meta-data described above.
  See the L<Log::Message::Item> manpage to see how to extract this
  meta-data and how to work with the Item objects.
  You should never need to create your own Item objects, but knowing
  about their methods and accessors is important if you want to write
  your own handlers. (See below)
  
  =item Log::Message::Handlers
  
  These are a collection of handlers that will be called for a level
  that is used on a L<Log::Message::Item> object.
  For example, if a message is logged with the 'carp' level, the 'carp'
  handler from L<Log::Message::Handlers> will be called.
  See the L<Log::Message::Handlers> manpage for more explanation about how
  handlers work, which one are available and how to create your own.
  
  =item Log::Message::Config
  
  Per Log::Message object, there is a configuration required that will
  fill in defaults if the user did not specify arguments to override
  them (like for example what tag will be set if none was provided),
  L<Log::Message::Config> handles the creation of these configurations.
  
  Configuration can be specified in 4 ways:
  
  =over 4
  
  =item *
  
  As a configuration file when you C<use Log::Message>
  
  =item *
  
  As arguments when you C<use Log::Message>
  
  =item *
  
  As a configuration file when you create a new L<Log::Message> object.
  (The config will then only apply to that object if you marked it as
  private)
  
  =item *
  
  As arguments when you create a new Log::Message object.
  
  You should never need to use the L<Log::Message::Config> module yourself,
  as this is transparently done by L<Log::Message>, but its manpage does
  provide an explanation of how you can create a config file.
  
  =back
  
  =back
  
  =head1 Options
  
  When using Log::Message, or creating a new Log::Message object, you can
  supply various options to alter its behaviour.
  Of course, there are sensible defaults should you choose to omit these
  options.
  
  Below an explanation of all the options and how they work.
  
  =over 4
  
  =item config
  
  The path to a configuration file to be read.
  See the manpage of L<Log::Message::Config> for the required format
  
  These options will be overridden by any explicit arguments passed.
  
  =item private
  
  Whether to create, by default, private or shared objects.
  If you choose to create shared objects, all Log::Message objects will
  use the same stack.
  
  This means that even though every module may make its own $log object
  they will still be sharing the same error stack on which they are
  putting errors and from which they are retrieving.
  
  This can be useful in big projects.
  
  If you choose to create a private object, then the stack will of
  course be private to this object, but it will still fall back to the
  shared config should no private config or overriding arguments be
  provided.
  
  =item verbose
  
  Log::Message makes use of another module to validate its arguments,
  which is called L<Params::Check>, which is a lightweight, yet
  powerful input checker and parser. (See the L<Params::Check>
  manpage for details).
  
  The verbose setting will control whether this module will
  generate warnings if something improper is passed as input, or merely
  silently returns undef, at which point Log::Message will generate a
  warning.
  
  It's best to just leave this at its default value, which is '1'
  
  =item tag
  
  The tag to add to messages if none was provided. If neither your
  config, nor any specific arguments supply a tag, then Log::Message will
  set it to 'NONE'
  
  Tags are useful for searching on or grouping by. For example, you
  could tag all the messages you want to go to the user as 'USER ERROR'
  and all those that are only debug information with 'DEBUG'.
  
  At the end of your program, you could then print all the ones tagged
  'USER ERROR' to STDOUT, and those marked 'DEBUG' to a log file.
  
  =item level
  
  C<level> describes what action to take when a message is logged. Just
  like C<tag>, Log::Message will provide a default (which is 'log') if
  neither your config file, nor any explicit arguments are given to
  override it.
  
  See the Log::Message::Handlers manpage to see what handlers are
  available by default and what they do, as well as to how to add your
  own handlers.
  
  =item remove
  
  This indicates whether or not to automatically remove the messages
  from the stack when you've retrieved them.
  The default setting provided by Log::Message is '0': do not remove.
  
  =item chrono
  
  This indicates whether messages should always be fetched in
  chronological order or not.
  This simply means that you can choose whether, when retrieving items,
  the item most recently added should be returned first, or the one that
  had been added most long ago.
  
  The default is to return the newest ones first
  
  =back
  
  =cut
  
  
  ### subs ###
  sub import {
      my $pkg     = shift;
      my %hash    = @_;
  
      $CONFIG = new Log::Message::Config( %hash )
                  or die loc(qq[Problem initialising %1], __PACKAGE__);
  
  }
  
  =head1 Methods
  
  =head2 new
  
  This creates a new Log::Message object; The parameters it takes are
  described in the C<Options> section below and let it just be repeated
  that you can use these options like this:
  
      my $log = Log::Message->new( %options );
  
  as well as during C<use> time, like this:
  
      use Log::Message option1 => value, option2 => value
  
  There are but 3 rules to keep in mind:
  
  =over 4
  
  =item *
  
  Provided arguments take precedence over a configuration file.
  
  =item *
  
  Arguments to new take precedence over options provided at C<use> time
  
  =item *
  
  An object marked private will always have an empty stack to begin with
  
  =back
  
  =cut
  
  sub new {
      my $class   = shift;
      my %hash    = @_;
  
      my $conf = new Log::Message::Config( %hash, default => $CONFIG ) or return undef;
  
      if( $conf->private || $CONFIG->private ) {
  
          return _new_stack( $class, config => $conf );
  
      } else {
          my $obj = _new_stack( $class, config => $conf, stack => $STACK );
  
          ### if it was an empty stack, this was the first object
          ### in that case, set the global stack to match it for
          ### subsequent new, non-private objects
          $STACK = $obj->{STACK} unless scalar @$STACK;
  
          return $obj;
      }
  }
  
  sub _new_stack {
      my $class = shift;
      my %hash  = @_;
  
      my $tmpl = {
          stack   => { default        => [] },
          config  => { default        => bless( {}, 'Log::Message::Config'),
                       required       => 1,
                       strict_type    => 1
                  },
      };
  
      my $args = check( $tmpl, \%hash, $CONFIG->verbose ) or (
          warn(loc(q[Could not create a new stack object: %1],
                  Params::Check->last_error)
          ),
          return
      );
  
  
      my %self = map { uc, $args->{$_} } keys %$args;
  
      return bless \%self, $class;
  }
  
  sub _get_conf {
      my $self = shift;
      my $what = shift;
  
      return defined $self->{CONFIG}->$what()
                  ?  $self->{CONFIG}->$what()
                  :  defined $CONFIG->$what()
                          ?  $CONFIG->$what()
                          :  undef;           # should never get here
  }
  
  =head2 store
  
  This will create a new Item object and store it on the stack.
  
  Possible arguments you can give to it are:
  
  =over 4
  
  =item message
  
  This is the only argument that is required. If no other arguments
  are given, you may even leave off the C<message> key. The argument
  will then automatically be assumed to be the message.
  
  =item tag
  
  The tag to add to this message. If not provided, Log::Message will look
  in your configuration for one.
  
  =item level
  
  The level at which this message should be handled. If not provided,
  Log::Message will look in your configuration for one.
  
  =item extra
  
  This is an array ref with arguments passed to the handler for this
  message, when it is called from store();
  
  The handler will receive them as a normal list
  
  =back
  
  store() will return true upon success and undef upon failure, as well
  as issue a warning as to why it failed.
  
  =cut
  
  ### should extra be stored in the item object perhaps for later retrieval?
  sub store {
      my $self = shift;
      my %hash = ();
  
      my $tmpl = {
          message => {
                  default     => '',
                  strict_type => 1,
                  required    => 1,
              },
          tag     => { default => $self->_get_conf('tag')     },
          level   => { default => $self->_get_conf('level'),  },
          extra   => { default => [], strict_type => 1 },
      };
  
      ### single arg means just the message
      ### otherwise, they are named
      if( @_ == 1 ) {
          $hash{message} = shift;
      } else {
          %hash = @_;
      }
  
      my $args = check( $tmpl, \%hash ) or (
          warn( loc(q[Could not store error: %1], Params::Check->last_error) ),
          return
      );
  
      my $extra = delete $args->{extra};
      my $item = Log::Message::Item->new(   %$args,
                                          parent  => $self,
                                          id      => scalar @{$self->{STACK}}
                                      )
              or ( warn( loc(q[Could not create new log item!]) ), return undef );
  
      push @{$self->{STACK}}, $item;
  
      {   no strict 'refs';
  
          my $sub = $args->{level};
  
          $item->$sub( @$extra );
      }
  
      return 1;
  }
  
  =head2 retrieve
  
  This will retrieve all message items matching the criteria specified
  from the stack.
  
  Here are the criteria you can discriminate on:
  
  =over 4
  
  =item tag
  
  A regex to which the tag must adhere. For example C<qr/\w/>.
  
  =item level
  
  A regex to which the level must adhere.
  
  =item message
  
  A regex to which the message must adhere.
  
  =item amount
  
  Maximum amount of errors to return
  
  =item chrono
  
  Return in chronological order, or not?
  
  =item remove
  
  Remove items from the stack upon retrieval?
  
  =back
  
  In scalar context it will return the first item matching your criteria
  and in list context, it will return all of them.
  
  If an error occurs while retrieving, a warning will be issued and
  undef will be returned.
  
  =cut
  
  sub retrieve {
      my $self = shift;
      my %hash = ();
  
      my $tmpl = {
          tag     => { default => qr/.*/ },
          level   => { default => qr/.*/ },
          message => { default => qr/.*/ },
          amount  => { default => '' },
          remove  => { default => $self->_get_conf('remove')  },
          chrono  => { default => $self->_get_conf('chrono')  },
      };
  
      ### single arg means just the amount
      ### otherwise, they are named
      if( @_ == 1 ) {
          $hash{amount} = shift;
      } else {
          %hash = @_;
      }
  
      my $args = check( $tmpl, \%hash ) or (
          warn( loc(q[Could not parse input: %1], Params::Check->last_error) ),
          return
      );
  
      my @list =
              grep { $_->tag      =~ /$args->{tag}/       ? 1 : 0 }
              grep { $_->level    =~ /$args->{level}/     ? 1 : 0 }
              grep { $_->message  =~ /$args->{message}/   ? 1 : 0 }
              grep { defined }
                  $args->{chrono}
                      ? @{$self->{STACK}}
                      : reverse @{$self->{STACK}};
  
      my $amount = $args->{amount} || scalar @list;
  
      my @rv = map {
                  $args->{remove} ? $_->remove : $_
             } scalar @list > $amount
                              ? splice(@list,0,$amount)
                              : @list;
  
      return wantarray ? @rv : $rv[0];
  }
  
  =head2 first
  
  This is a shortcut for retrieving the first item(s) stored on the
  stack. It will default to only retrieving one if called with no
  arguments, and will always return results in chronological order.
  
  If you only supply one argument, it is assumed to be the amount you
  wish returned.
  
  Furthermore, it can take the same arguments as C<retrieve> can.
  
  =cut
  
  sub first {
      my $self = shift;
  
      my $amt = @_ == 1 ? shift : 1;
      return $self->retrieve( amount => $amt, @_, chrono => 1 );
  }
  
  =head2 last
  
  This is a shortcut for retrieving the last item(s) stored on the
  stack. It will default to only retrieving one if called with no
  arguments, and will always return results in reverse chronological
  order.
  
  If you only supply one argument, it is assumed to be the amount you
  wish returned.
  
  Furthermore, it can take the same arguments as C<retrieve> can.
  
  =cut
  
  sub final {
      my $self = shift;
  
      my $amt = @_ == 1 ? shift : 1;
      return $self->retrieve( amount => $amt, @_, chrono => 0 );
  }
  
  =head2 flush
  
  This removes all items from the stack and returns them to the caller
  
  =cut
  
  sub flush {
      my $self = shift;
  
      return splice @{$self->{STACK}};
  }
  
  =head1 SEE ALSO
  
  L<Log::Message::Item>, L<Log::Message::Handlers>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE

$fatpacked{"Log/Message/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_CONFIG';
  package Log::Message::Config;
  use if $] > 5.017, 'deprecate';
  use strict;
  
  use Params::Check qw[check];
  use Module::Load;
  use FileHandle;
  use Locale::Maketext::Simple Style => 'gettext';
  
  BEGIN {
      use vars        qw[$VERSION $AUTOLOAD];
      $VERSION    =   '0.08';
  }
  
  sub new {
      my $class = shift;
      my %hash  = @_;
  
      ### find out if the user specified a config file to use
      ### and/or a default configuration object
      ### and remove them from the argument hash
      my %special =   map { lc, delete $hash{$_} }
                      grep /^config|default$/i, keys %hash;
  
      ### allow provided arguments to override the values from the config ###
      my $tmpl = {
          private => { default => undef,  },
          verbose => { default => 1       },
          tag     => { default => 'NONE', },
          level   => { default => 'log',  },
          remove  => { default => 0       },
          chrono  => { default => 1       },
      };
  
      my %lc_hash = map { lc, $hash{$_} } keys %hash;
  
      my $file_conf;
      if( $special{config} ) {
          $file_conf = _read_config_file( $special{config} )
                          or ( warn( loc(q[Could not parse config file!]) ), return );
      }
  
      my $def_conf = \%{ $special{default} || {} };
  
      ### make sure to only include keys that are actually defined --
      ### the checker will assign even 'undef' if you have provided that
      ### as a value
      ### priorities goes as follows:
      ### 1: arguments passed
      ### 2: any config file passed
      ### 3: any default config passed
      my %to_check =  map     { @$_ }
                      grep    { defined $_->[1] }
                      map     {   [ $_ =>
                                      defined $lc_hash{$_}        ? $lc_hash{$_}      :
                                      defined $file_conf->{$_}    ? $file_conf->{$_}  :
                                      defined $def_conf->{$_}     ? $def_conf->{$_}   :
                                      undef
                                  ]
                              } keys %$tmpl;
  
      my $rv = check( $tmpl, \%to_check, 1 )
                  or ( warn( loc(q[Could not validate arguments!]) ), return );
  
      return bless $rv, $class;
  }
  
  sub _read_config_file {
      my $file = shift or return;
  
      my $conf = {};
      my $FH = new FileHandle;
      $FH->open("$file", 'r') or (
                          warn(loc(q[Could not open config file '%1': %2],$file,$!)),
                          return {}
                      );
  
      while(<$FH>) {
          next if     /\s*#/;
          next unless /\S/;
  
          chomp; s/^\s*//; s/\s*$//;
  
          my ($param,$val) = split /\s*=\s*/;
  
          if( (lc $param) eq 'include' ) {
              load $val;
              next;
          }
  
          ### add these to the config hash ###
          $conf->{ lc $param } = $val;
      }
      close $FH;
  
      return $conf;
  }
  
  sub AUTOLOAD {
      $AUTOLOAD =~ s/.+:://;
  
      my $self = shift;
  
      return $self->{ lc $AUTOLOAD } if exists $self->{ lc $AUTOLOAD };
  
      die loc(q[No such accessor '%1' for class '%2'], $AUTOLOAD, ref $self);
  }
  
  sub DESTROY { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Log::Message::Config - Configuration options for Log::Message
  
  =head1 SYNOPSIS
  
      # This module is implicitly used by Log::Message to create a config
      # which it uses to log messages.
      # For the options you can pass, see the C<Log::Message new()> method.
  
      # Below is a sample of a config file you could use
  
      # comments are denoted by a single '#'
      # use a shared stack, or have a private instance?
      # if none provided, set to '0',
      private = 1
  
      # do not be verbose
      verbose = 0
  
      # default tag to set on new items
      # if none provided, set to 'NONE'
      tag = SOME TAG
  
      # default level to handle items
      # if none provided, set to 'log'
      level = carp
  
      # extra files to include
      # if none provided, no files are auto included
      include = mylib.pl
      include = ../my/other/lib.pl
  
      # automatically delete items
      # when you retrieve them from the stack?
      # if none provided, set to '0'
      remove = 1
  
      # retrieve errors in chronological order, or not?
      # if none provided, set to '1'
      chrono = 0
  
  =head1 DESCRIPTION
  
  Log::Message::Config provides a standardized config object for
  Log::Message objects.
  
  It can either read options as perl arguments, or as a config file.
  See the Log::Message manpage for more information about what arguments
  are valid, and see the Synopsis for an example config file you can use
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Item>, L<Log::Message::Handlers>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_CONFIG

$fatpacked{"Log/Message/Handlers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_HANDLERS';
  package Log::Message::Handlers;
  use if $] > 5.017, 'deprecate';
  use strict;
  use vars qw[$VERSION];
  
  $VERSION = '0.08';
  
  =pod
  
  =head1 NAME
  
  Log::Message::Handlers - Message handlers for Log::Message
  
  =head1 SYNOPSIS
  
      # Implicitly used by Log::Message to serve as handlers for
      # Log::Message::Item objects
  
      # Create your own file with a package called
      # Log::Message::Handlers to add to the existing ones, or to even
      # overwrite them
  
      $item->carp;
  
      $item->trace;
  
  
  =head1 DESCRIPTION
  
  Log::Message::Handlers provides handlers for Log::Message::Item objects.
  The handler corresponding to the level (see Log::Message::Item manpage
  for an explanation about levels) will be called automatically upon
  storing the error.
  
  Handlers may also explicitly be called on an Log::Message::Item object
  if one so desires (see the Log::Message manpage on how to retrieve the
  Item objects).
  
  =head1 Default Handlers
  
  =head2 log
  
  Will simply log the error on the stack, and do nothing special
  
  =cut
  
  sub log { 1 }
  
  =head2 carp
  
  Will carp (see the Carp manpage) with the error, and add the timestamp
  of when it occurred.
  
  =cut
  
  sub carp {
      my $self = shift;
      warn join " ", $self->message, $self->shortmess, 'at', $self->when, "\n";
  }
  
  =head2 croak
  
  Will croak (see the Carp manpage) with the error, and add the
  timestamp of when it occurred.
  
  =cut
  
  sub croak {
      my $self = shift;
      die join " ", $self->message, $self->shortmess, 'at', $self->when, "\n";
  }
  
  =head2 cluck
  
  Will cluck (see the Carp manpage) with the error, and add the
  timestamp of when it occurred.
  
  =cut
  
  sub cluck {
      my $self = shift;
      warn join " ", $self->message, $self->longmess, 'at', $self->when, "\n";
  }
  
  =head2 confess
  
  Will confess (see the Carp manpage) with the error, and add the
  timestamp of when it occurred
  
  =cut
  
  sub confess {
      my $self = shift;
      die join " ", $self->message, $self->longmess, 'at', $self->when, "\n";
  }
  
  =head2 die
  
  Will simply die with the error message of the item
  
  =cut
  
  sub die  { die  shift->message; }
  
  
  =head2 warn
  
  Will simply warn with the error message of the item
  
  =cut
  
  sub warn { warn shift->message; }
  
  
  =head2 trace
  
  Will provide a traceback of this error item back to the first one that
  occurred, clucking with every item as it comes across it.
  
  =cut
  
  sub trace {
      my $self = shift;
  
      for my $item( $self->parent->retrieve( chrono => 0 ) ) {
          $item->cluck;
      }
  }
  
  =head1 Custom Handlers
  
  If you wish to provide your own handlers, you can simply do the
  following:
  
  =over 4
  
  =item *
  
  Create a file that holds a package by the name of
  C<Log::Message::Handlers>
  
  =item *
  
  Create subroutines with the same name as the levels you wish to
  handle in the Log::Message module (see the Log::Message manpage for
  explanation on levels)
  
  =item *
  
  Require that file in your program, or add it in your configuration
  (see the Log::Message::Config manpage for explanation on how to use a
  config file)
  
  =back
  
  And that is it, the handler will now be available to handle messages
  for you.
  
  The arguments a handler may receive are those specified by the
  C<extra> key, when storing the message.
  See the Log::Message manpage for details on the arguments.
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Item>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_HANDLERS

$fatpacked{"Log/Message/Item.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_ITEM';
  package Log::Message::Item;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  use vars qw[$VERSION];
  use Params::Check qw[check];
  use Log::Message::Handlers;
  
  ### for the messages to store ###
  use Carp ();
  
  BEGIN {
      use vars qw[$AUTOLOAD $VERSION];
  
      $VERSION    =   '0.08';
  }
  
  ### create a new item.
  ### note that only an id (position on the stack), message and a reference
  ### to its parent are required. all the other things it can fill in itself
  sub new {
      my $class   = shift;
      my %hash    = @_;
  
      my $tmpl = {
          when        => { no_override    => 1,   default    => scalar localtime },
          id          => { required       => 1    },
          message     => { required       => 1    },
          parent      => { required        => 1    },
          level       => { default        => ''   },      # default may be conf dependant
          tag         => { default        => ''   },      # default may be conf dependant
          longmess    => { default        => _clean(Carp::longmess()) },
          shortmess   => { default        => _clean(Carp::shortmess())},
      };
  
      my $args = check($tmpl, \%hash) or return undef;
  
      return bless $args, $class;
  }
  
  sub _clean { map { s/\s*//; chomp; $_ } shift; }
  
  sub remove {
      my $item = shift;
      my $self = $item->parent;
  
      return splice( @{$self->{STACK}}, $item->id, 1, undef );
  }
  
  sub AUTOLOAD {
      my $self = $_[0];
  
      $AUTOLOAD =~ s/.+:://;
  
      return $self->{$AUTOLOAD} if exists $self->{$AUTOLOAD};
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 3;
  
      {   no strict 'refs';
          return *{"Log::Message::Handlers::${AUTOLOAD}"}->(@_);
      }
  }
  
  sub DESTROY { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Log::Message::Item  - Message objects for Log::Message
  
  =head1 SYNOPSIS
  
      # Implicitly used by Log::Message to create Log::Message::Item objects
  
      print "this is the message's id: ",     $item->id;
  
      print "this is the message stored: ",   $item->message;
  
      print "this is when it happened: ",     $item->when;
  
      print "the message was tagged: ",       $item->tag;
  
      print "this was the severity level: ",  $item->level;
  
      $item->remove;  # delete the item from the stack it was on
  
      # Besides these methods, you can also call the handlers on
      # the object specifically.
      # See the Log::Message::Handlers manpage for documentation on what
      # handlers are available by default and how to add your own
  
  
  =head1 DESCRIPTION
  
  Log::Message::Item is a class that generates generic Log items.
  These items are stored on a Log::Message stack, so see the Log::Message
  manpage about details how to retrieve them.
  
  You should probably not create new items by yourself, but use the
  storing mechanism provided by Log::Message.
  
  However, the accessors and handlers are of interest if you want to do
  fine tuning of how your messages are handled.
  
  The accessors and methods are described below, the handlers are
  documented in the Log::Message::Handlers manpage.
  
  =head1 Methods and Accessors
  
  =head2 remove
  
  Calling remove will remove the object from the stack it was on, so it
  will not show up any more in subsequent fetches of messages.
  
  You can still call accessors and handlers on it however, to handle it
  as you will.
  
  =head2 id
  
  Returns the internal ID of the item. This may be useful for comparing
  since the ID is incremented each time a new item is created.
  Therefore, an item with ID 4 must have been logged before an item with
  ID 9.
  
  =head2 when
  
  Returns the timestamp of when the message was logged
  
  =head2 message
  
  The actual message that was stored
  
  =head2 level
  
  The severity type of this message, as well as the name of the handler
  that was called upon storing it.
  
  =head2 tag
  
  Returns the identification tag that was put on the message.
  
  =head2 shortmess
  
  Returns the equivalent of a C<Carp::shortmess> for this item.
  See the C<Carp> manpage for details.
  
  =head2 longmess
  
  Returns the equivalent of a C<Carp::longmess> for this item, which
  is essentially a stack trace.
  See the C<Carp> manpage for details.
  
  =head2 parent
  
  Returns a reference to the Log::Message object that stored this item.
  This is useful if you want to have access to the full stack in a
  handler.
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Handlers>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_ITEM

$fatpacked{"Log/Message/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_SIMPLE';
  package Log::Message::Simple;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  use Log::Message private => 0;;
  
  BEGIN {
      use vars qw[$VERSION];
      $VERSION = '0.10';
  }
  
  
  =pod
  
  =head1 NAME
  
  Log::Message::Simple - Simplified interface to Log::Message
  
  =head1 SYNOPSIS
  
      use Log::Message::Simple qw[msg error debug
                                  carp croak cluck confess];
  
      use Log::Message::Simple qw[:STD :CARP];
  
      ### standard reporting functionality
      msg(    "Connecting to database",           $verbose );
      error(  "Database connection failed: $@",   $verbose );
      debug(  "Connection arguments were: $args", $debug );
  
      ### standard carp functionality
      carp(   "Wrong arguments passed: @_" );
      croak(  "Fatal: wrong arguments passed: @_" );
      cluck(  "Wrong arguments passed -- including stacktrace: @_" );
      confess("Fatal: wrong arguments passed -- including stacktrace: @_" );
  
      ### retrieve individual message
      my @stack = Log::Message::Simple->stack;
      my @stack = Log::Message::Simple->flush;
  
      ### retrieve the entire stack in printable form
      my $msgs  = Log::Message::Simple->stack_as_string;
      my $trace = Log::Message::Simple->stack_as_string(1);
  
      ### redirect output
      local $Log::Message::Simple::MSG_FH     = \*STDERR;
      local $Log::Message::Simple::ERROR_FH   = \*STDERR;
      local $Log::Message::Simple::DEBUG_FH   = \*STDERR;
  
      ### force a stacktrace on error
      local $Log::Message::Simple::STACKTRACE_ON_ERROR = 1
  
  =head1 DESCRIPTION
  
  This module provides standardized logging facilities using the
  C<Log::Message> module.
  
  =head1 FUNCTIONS
  
  =head2 msg("message string" [,VERBOSE])
  
  Records a message on the stack, and prints it to C<STDOUT> (or actually
  C<$MSG_FH>, see the C<GLOBAL VARIABLES> section below), if the
  C<VERBOSE> option is true.
  The C<VERBOSE> option defaults to false.
  
  Exported by default, or using the C<:STD> tag.
  
  =head2 debug("message string" [,VERBOSE])
  
  Records a debug message on the stack, and prints it to C<STDOUT> (or
  actually C<$DEBUG_FH>, see the C<GLOBAL VARIABLES> section below),
  if the C<VERBOSE> option is true.
  The C<VERBOSE> option defaults to false.
  
  Exported by default, or using the C<:STD> tag.
  
  =head2 error("error string" [,VERBOSE])
  
  Records an error on the stack, and prints it to C<STDERR> (or actually
  C<$ERROR_FH>, see the C<GLOBAL VARIABLES> sections below), if the
  C<VERBOSE> option is true.
  The C<VERBOSE> options defaults to true.
  
  Exported by default, or using the C<:STD> tag.
  
  =cut
  
  {   package Log::Message::Handlers;
  
      sub msg {
          my $self    = shift;
          my $verbose = shift || 0;
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::MSG_FH;
          print '['. $self->tag (). '] ' . $self->message . "\n";
          select $old_fh;
  
          return;
      }
  
      sub debug {
          my $self    = shift;
          my $verbose = shift || 0;
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::DEBUG_FH;
          print '['. $self->tag (). '] ' . $self->message . "\n";
          select $old_fh;
  
          return;
      }
  
      sub error {
          my $self    = shift;
          my $verbose = shift;
             $verbose = 1 unless defined $verbose;    # default to true
  
          ### so you don't want us to print the error? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::ERROR_FH;
  
          my $msg     = '['. $self->tag . '] ' . $self->message;
  
          print $Log::Message::Simple::STACKTRACE_ON_ERROR
                      ? Carp::shortmess($msg)
                      : $msg . "\n";
  
          select $old_fh;
  
          return;
      }
  }
  
  =head2 carp();
  
  Provides functionality equal to C<Carp::carp()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 croak();
  
  Provides functionality equal to C<Carp::croak()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 confess();
  
  Provides functionality equal to C<Carp::confess()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 cluck();
  
  Provides functionality equal to C<Carp::cluck()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head1 CLASS METHODS
  
  =head2 Log::Message::Simple->stack()
  
  Retrieves all the items on the stack. Since C<Log::Message::Simple> is
  implemented using C<Log::Message>, consult its manpage for the
  function C<retrieve> to see what is returned and how to use the items.
  
  =head2 Log::Message::Simple->stack_as_string([TRACE])
  
  Returns the whole stack as a printable string. If the C<TRACE> option is
  true all items are returned with C<Carp::longmess> output, rather than
  just the message.
  C<TRACE> defaults to false.
  
  =head2 Log::Message::Simple->flush()
  
  Removes all the items from the stack and returns them. Since
  C<Log::Message::Simple> is  implemented using C<Log::Message>, consult its
  manpage for the function C<retrieve> to see what is returned and how
  to use the items.
  
  =cut
  
  BEGIN {
      use Exporter;
      use Params::Check   qw[ check ];
      use vars            qw[ @EXPORT @EXPORT_OK %EXPORT_TAGS @ISA ];;
  
      @ISA            = 'Exporter';
      @EXPORT         = qw[error msg debug];
      @EXPORT_OK      = qw[carp cluck croak confess];
  
      %EXPORT_TAGS    = (
          STD     => \@EXPORT,
          CARP    => \@EXPORT_OK,
          ALL     => [ @EXPORT, @EXPORT_OK ],
      );
  
      my $log         = new Log::Message;
  
      for my $func ( @EXPORT, @EXPORT_OK ) {
          no strict 'refs';
  
                          ### up the carplevel for the carp emulation
                          ### functions
          *$func = sub {  local $Carp::CarpLevel += 2
                              if grep { $_ eq $func } @EXPORT_OK;
  
                          my $msg     = shift;
                          $log->store(
                                  message => $msg,
                                  tag     => uc $func,
                                  level   => $func,
                                  extra   => [@_]
                          );
                  };
      }
  
      sub flush {
          return reverse $log->flush;
      }
  
      sub stack {
          return $log->retrieve( chrono => 1 );
      }
  
      sub stack_as_string {
          my $class = shift;
          my $trace = shift() ? 1 : 0;
  
          return join $/, map {
                          '[' . $_->tag . '] [' . $_->when . '] ' .
                          ($trace ? $_->message . ' ' . $_->longmess
                                  : $_->message);
                      } __PACKAGE__->stack;
      }
  }
  
  =head1 GLOBAL VARIABLES
  
  =over 4
  
  =item $ERROR_FH
  
  This is the filehandle all the messages sent to C<error()> are being
  printed. This defaults to C<*STDERR>.
  
  =item $MSG_FH
  
  This is the filehandle all the messages sent to C<msg()> are being
  printed. This default to C<*STDOUT>.
  
  =item $DEBUG_FH
  
  This is the filehandle all the messages sent to C<debug()> are being
  printed. This default to C<*STDOUT>.
  
  =item $STACKTRACE_ON_ERROR
  
  If this option is set to C<true>, every call to C<error()> will
  generate a stacktrace using C<Carp::shortmess()>.
  Defaults to C<false>
  
  =back
  
  =cut
  
  BEGIN {
      use vars qw[ $ERROR_FH $MSG_FH $DEBUG_FH $STACKTRACE_ON_ERROR ];
  
      local $| = 1;
      $ERROR_FH               = \*STDERR;
      $MSG_FH                 = \*STDOUT;
      $DEBUG_FH               = \*STDOUT;
  
      $STACKTRACE_ON_ERROR    = 0;
  }
  
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_SIMPLE

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Moo::Object);
  use Sub::Quote;
  use B 'perlstring';
  use Scalar::Util 'blessed';
  use overload ();
  use Module::Runtime qw(use_module);
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  
  sub _SIGDIE
  {
    our ($CurrentAttribute, $OrigSigDie);
    my $sigdie = $OrigSigDie && $OrigSigDie != \&_SIGDIE
      ? $OrigSigDie
      : sub { die $_[0] };
  
    return $sigdie->(@_) if ref($_[0]);
  
    my $attr_desc = _attr_desc(@$CurrentAttribute{qw(name init_arg)});
    $sigdie->("$CurrentAttribute->{step} for $attr_desc failed: $_[0]");
  }
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    die "You cannot overwrite a locally defined method ($method) with @{[ $type || 'an accessor' ]}";
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      die "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ /\A[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)*\z/;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
  
    for my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (!defined $spec->{default} || ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name", 'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      for my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${reader}")}{CODE};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${accessor}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${writer}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${pred}")}{CODE};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $methods{$pred} =
          quote_sub "${into}::${pred}" =>
            '    '.$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
          ;
      }
    }
    if (my $pred = $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $spec->{builder_sub} );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${cl}")}{CODE};
      $methods{$cl} =
        quote_sub "${into}::${cl}" =>
          $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], use_module('Moo::Role')->methods_provided_by(use_module($hspec))
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && *{_getglob("${into}::${proxy}")}{CODE};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
  
  
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" => $self->_generate_asserter($name, $spec),
          delete $self->{captures}
        ;
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\perlstring $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\perlstring $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa}
      ? "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n");
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
        : perlstring $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->_generate_simple_get(@args);
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $value_store = '$_[0]';
      my $code;
      if ($coerce) {
        $value_store = '$value';
        $code = "do { my (\$self, \$value) = \@_;\n"
          ."        \$value = "
          .$self->_generate_coerce($name, $value_store, $coerce).";\n";
      }
      else {
        $code = "do { my \$self = shift;\n";
      }
      if ($isa_check) {
        $code .=
          "        ".$self->_generate_isa_check($name, $value_store, $isa_check).";\n";
      }
      my $simple = $self->_generate_simple_set('$self', $name, $spec, $value_store);
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', $value_store, $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        $value_store;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return perlstring($name) if !defined($init_arg) or $init_arg eq $name;
    return perlstring($name).' (constructor argument: '.perlstring($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce)
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_die_prefix {
    my ($self, $name, $prefix, $arg, $inside) = @_;
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'
    .'    init_arg => '.(defined $arg ? B::perlstring($arg) : 'undef') . ",\n"
    .'    name     => '.B::perlstring($name).",\n"
    .'    step     => '.B::perlstring($prefix).",\n"
    ."  };\n"
    .'  local $Method::Generate::Accessor::OrigSigDie = $SIG{__DIE__};'."\n"
    .'  local $SIG{__DIE__} = \&Method::Generate::Accessor::_SIGDIE;'."\n"
    .$inside
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.$self->_sanitize_name($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify(
          $code, $values, Sub::Quote::capture_unroll($cap_name, $captures, 6), $local
        );
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.$self->_sanitize_name($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name {
    my ($self, $name) = @_;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $name, $spec
                        );
      my $get_value =
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ($spec->{coerce}) {
        $get_value = $self->_generate_coerce(
          $name, $get_value,
          $spec->{coerce}, $init_arg
        )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}, $init_arg
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name, $spec),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $source,
              $spec->{coerce}, $init_arg
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}, $init_arg
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name, $spec),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      #Internals::SetReadWrite($foo);
      #Scalar::Util::weaken ($foo);
      #Internals::SetReadOnly($foo);
      #
      # but requires XS and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : $weak_simple;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
  
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  unless (".$self->_generate_simple_has('$_[0]', $name, $spec).") {\n"
     .qq!    die "Attempted to access '${name}' but it is not set";\n!
     ."  }\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using perlstring
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      die "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      die "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B 'perlstring';
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @builds;
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use strictures 1;
  use Sub::Quote;
  use base qw(Moo::Object);
  use Sub::Defer;
  use B 'perlstring';
  use Moo::_Utils qw(_getstash);
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    my $specs = $self->{attribute_specs}||={};
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        die "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        foreach my $key (keys %$old_spec) {
          if (!exists $new_spec->{$key}) {
            $new_spec->{$key} = $old_spec->{$key}
              unless $key eq 'handles';
          }
          elsif ($key eq 'moosify') {
            $new_spec->{$key} = [
              map { ref $_ eq 'ARRAY' ? @$_ : $_ }
                ($old_spec->{$key}, $new_spec->{$key})
            ];
          }
        }
      }
      if (exists $new_spec->{init_arg} && !defined $new_spec->{init_arg}
          && $new_spec->{required}) {
        die "${name} attribute can't be required with init_arg => undef";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    my $package = $self->{package};
    defer_sub "${package}::new" => sub {
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      $body .= $self->buildall_generator->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.perlstring($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg_key = perlstring($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $test{$_},
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, qw('
      .join(' ',@required_init).')) {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  use Moo;
  Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'lazy' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'ro' },
  );
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B qw(perlstring);
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL(Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;
  
  use strictures 1;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
  	$fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use strictures 1;
  use Moo::_Utils;
  use B 'perlstring';
  use Sub::Defer ();
  use Import::Into;
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
    strictures->import::into(1);
    if ($Role::Tiny::INFO{$target} and $Role::Tiny::INFO{$target}{is_role}) {
      die "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map { *$_{CODE}||() } grep !ref($_), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{"Role/Tiny.pm"} && $Role::Tiny::INFO{$superclass}) {
        require Carp;
        Carp::croak("Can't extend role '$superclass'");
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    no warnings 'once'; # piss off. -- mst
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target, $select_super) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
      require Sub::Defer;
      my ($moo_constructor, $con);
  
      if ($select_super && $MAKERS{$select_super}) {
        $moo_constructor = 1;
        $con = $MAKERS{$select_super}{constructor};
      } else {
        my $t_new = $target->can('new');
        if ($t_new) {
          if ($t_new == Moo::Object->can('new')) {
            $moo_constructor = 1;
          } elsif (my $defer_target = (Sub::Defer::defer_info($t_new)||[])->[0]) {
            my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
            if ($MAKERS{$pkg}) {
              $moo_constructor = 1;
              $con = $MAKERS{$pkg}{constructor};
            }
          }
        } else {
          $moo_constructor = 1; # no other constructor, make a Moo one
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(
          package => $target,
          accessor_generator => $class->_accessor_maker_for($target),
          $moo_constructor ? (
            $con ? (construction_string => $con->construction_string) : ()
          ) : (
            construction_builder => sub {
              '$class->'.$target.'::SUPER::new('
                .($target->can('FOREIGNBUILDARGS') ?
                  '$class->FOREIGNBUILDARGS(@_)' : '@_')
                .')'
            },
          ),
          subconstructor_handler => (
            '      if ($Moo::MAKERS{$class}) {'."\n"
            .'        '.$class.'->_constructor_maker_for($class,'.perlstring($target).');'."\n"
            .'        return $class->new(@_)'.";\n"
            .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
            .'        return $meta->new_object($class->BUILDARGS(@_));'."\n"
            .'      }'."\n"
          ),
        )
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $makers = $MAKERS{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
   use namespace::clean;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
   );
  
   has pounds => (
     is  => 'rw',
     isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  And elsewhere:
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  This module is an extremely light-weight subset of L<Moose> optimised for
  rapid startup and "pay only for what you use".
  
  It also avoids depending on any XS modules to allow simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite -- two
  thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead of provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  However, sometimes you're writing a command line script or a CGI script
  where fast startup is essential, or code designed to be deployed as a single
  file via L<App::FatPacker>, or you're writing a CPAN module and you want it
  to be usable by people with those constraints.
  
  I've tried several times to use L<Mouse> but it's 3x the size of Moo and
  takes longer to load than most of my Moo based CGI scripts take to run.
  
  If you don't want L<Moose>, you don't want "less metaprotocol" like L<Mouse>,
  you want "as little as possible" -- which means "no metaprotocol", which is
  what Moo provides.
  
  Better still, if you install and load L<Moose>, we set up metaclasses for your
  L<Moo> classes and L<Moo::Role> roles, so you can use them in L<Moose> code
  without ever noticing that some of your codebase is using L<Moo>.
  
  Hence, Moo exists as its name -- Minimal Object Orientation -- with a pledge
  to make it smooth to upgrade to L<Moose> when you need more than minimal
  features.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without anybody ever noticing you aren't using
  L<Moose> everywhere.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  classes and roles, so that C<< isa => 'MyClass' >> and C<< isa => 'MyRole' >>
  work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  So will extending a L<Mouse> class or consuming a L<Mouse::Role> - but note
  that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you want types to be upgraded to the L<Moose> types, use
  L<MooX::Types::MooseLike> and install the L<MooseX::Types> library to
  match the L<MooX::Types::MooseLike> library you're using - L<Moo> will
  load the L<MooseX::Types> library and use that type for the newly created
  metaclass.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  currently global and turns the mechanism off entirely so don't put this
  in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it
  will be used to generate simple accessors, readers, and writers for
  a speed boost.  Simple accessors are those without lazy defaults,
  type checks/coercions, or triggers.  Readers and writers generated
  by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   sub BUILDARGS {
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return { @args };
   };
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as C<BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares base class. Multiple superclasses can be passed for multiple
  inheritance (but please use roles instead).  The class will be loaded, however
  no errors will be triggered if it can't be found and there are already subs in
  the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
  
  or
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles have conflicting methods.  The
  roles will be loaded using the same mechansim as C<extends> uses.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
   package Foo;
   use Moo;
   has 'attr' => (
     is => 'ro'
   );
  
   package Bar;
   use Moo;
   extends 'Foo';
   has '+attr' => (
     default => sub { "blah" },
   );
  
  Using the C<+> notation, it's possible to override an attribute.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * is
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> generates an accessor that dies if you attempt to write to it - i.e.
  a getter only - by defaulting C<reader> to the name of the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> generates a reader like C<ro>, but also sets C<writer> to
  C<_set_${attribute_name}> for attributes that are designed to be written
  from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> generates a normal getter/setter by defaulting C<accessor> to the
  name of the attribute.
  
  =item * isa
  
  Takes a coderef which is meant to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   isa => sub {
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  Note that the return value is ignored, only whether the sub lives or
  dies matters.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<MooseX::Types> style named types, look at
  L<MooX::Types::MooseLike>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item * coerce
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always fire your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * handles
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a role (L<Moo::Role>) that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. Coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<default>
  
  Takes a coderef which will get called with $self as its only argument
  to populate an attribute if no value is supplied to the constructor - or
  if the attribute is lazy, when the attribute is first retrieved if no
  value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item * C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or <_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on instantiation.
  
  =item * C<reader>
  
  The value of this attribute will be the name of the method to get the value of
  the attribute.  If you like Java style methods, you might set this to
  C<get_foo>
  
  =item * C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item * C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened; use this when circular references are possible, which will cause
  leaks.
  
  =item * C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item * C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
   package Record;
  
   use Digest::MD5 qw(md5_hex);
  
   use Moo;
   use namespace::clean;
  
   has name => (is => 'ro', required => 1);
   has id => (is => 'lazy');
   sub _build_id {
     my ($self) = @_;
     return md5_hex($self->name);
   }
  
   1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes, so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> If you're coming to Moo from the Moose
  world, you may be accustomed to using L<namespace::autoclean> in all
  your packages. This is not recommended for L<Moo> packages, because
  L<namespace::autoclean> will inflate your class to a full L<Moose>
  class.  It'll work, but you will lose the benefits of L<Moo>.  Instead
  you are recommended to just use L<namespace::clean>.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, just make a library of coderefs, or better yet, functions
  that return quoted subs. L<MooX::Types::MooseLike> provides a similar API
  to L<MooseX::Types::Moose> so that you can write
  
    has days_to_live => (is => 'ro', isa => Int);
  
  and have it work with both; it is hoped that providing only subrefs as an
  API will encourage the use of other type systems as well, since it's
  probably the weakest part of Moose design-wise.
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you wanted
  L<Moose> - Moo succeeds at being small because it explicitly does not
  provide a metaprotocol. However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  C<BUILDARGS> is not triggered if your class does not have any attributes.
  Without attributes, C<BUILDARGS> return value would be ignored, so we just
  skip calling the method instead.
  
  Handling of warnings: when you C<use Moo> we enable FATAL warnings, and some
  several extra pragmas when used in development: L<indirect>,
  L<multidimensional>, and L<bareword::filehandles>.  See the L<strictures>
  documentation for the details on this.
  
  A similar invocation for L<Moose> would be:
  
    use Moose;
    use warnings FATAL => "all";
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
      package MyClass;
      use Moo;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
      package MyClass;
  
      use Moose;
      use MooseX::NonMoose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
      __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#moose@irc.perl.org">(click for instant chatroom login)</a>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#web-simple@irc.perl.org">(click for instant chatroom login)</a>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_CONFLICTS';
  package # hide from PAUSE
      Moo::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Moo',
      -conflicts => {
          # enter conflicting downstream deps here, with the version indicating
          # the last *broken* version that *does not work*.
          'HTML::Restrict' => '2.1.5',
      },
  
      # these dists' ::Conflicts modules (if they exist) are also checked for
      # more incompatibilities -- should include all runtime prereqs here.
      -also => [ qw(
          Carp
          Class::Method::Modifiers
          strictures
          Module::Runtime
          Role::Tiny
          Devel::GlobalDestruction
      ) ],
  ;
  
  1;
MOO_CONFLICTS

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  
  use strictures 1;
  use Moo::_Utils;
  use B qw(perlstring);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', do { no warnings 'once'; keys %Moo::MAKERS };
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    for my $spec (values %$attr_specs) {
      if (my $inflators = delete $spec->{moosify}) {
        $_->($spec) for @$inflators;
      }
    }
  
    my %methods
      = %{($am_role ? 'Role::Tiny' : 'Moo')->_concrete_methods_of($name)};
  
    # if stuff gets added afterwards, _maybe_reset_handlemoose should
    # trigger the recreation of the metaclass but we need to ensure the
    # Role::Tiny cache is cleared so we don't confuse Moo itself.
    if (my $info = $Role::Tiny::INFO{$name}) {
      delete $info->{methods};
    }
  
    # needed to ensure the method body is stable and get things named
    Sub::Defer::undefer_sub($_) for grep defined, values %methods;
    my @attrs;
    {
      # This local is completely not required for roles but harmless
      local @{_getstash($name)}{keys %methods};
      my %seen_name;
      foreach my $name (@$attr_order) {
        $seen_name{$name} = 1;
        my %spec = %{$attr_specs->{$name}};
        my %spec_map = (
          map { $_->name => $_->init_arg||$_->name }
          (
            (grep { $_->has_init_arg }
               $meta->attribute_metaclass->meta->get_all_attributes),
            grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
            map {
              my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                           ->meta;
              map $meta->get_attribute($_), $meta->get_attribute_list
            }  @{$spec{traits}||[]}
          )
        );
        # have to hard code this because Moose's role meta-model is lacking
        $spec_map{traits} ||= 'traits';
  
        $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
        my $coerce = $spec{coerce};
        if (my $isa = $spec{isa}) {
          my $tc = $spec{isa} = do {
            if (my $mapped = $TYPE_MAP{$isa}) {
              my $type = $mapped->();
              Scalar::Util::blessed($type) && $type->isa("Moose::Meta::TypeConstraint")
                or die "error inflating attribute '$name' for package '$_[0]': \$TYPE_MAP{$isa} did not return a valid type constraint'";
              $coerce ? $type->create_child_type(name => $type->name) : $type;
            } else {
              Moose::Meta::TypeConstraint->new(
                constraint => sub { eval { &$isa; 1 } }
              );
            }
          };
          if ($coerce) {
            $tc->coercion(Moose::Meta::TypeCoercion->new)
               ->_compiled_type_coercion($coerce);
            $spec{coerce} = 1;
          }
        } elsif ($coerce) {
          my $attr = perlstring($name);
          my $tc = Moose::Meta::TypeConstraint->new(
                     constraint => sub { die "This is not going to work" },
                     inlined => sub {
                        'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                     },
                   );
          $tc->coercion(Moose::Meta::TypeCoercion->new)
             ->_compiled_type_coercion($coerce);
          $spec{isa} = $tc;
          $spec{coerce} = 1;
        }
        %spec =
          map { $spec_map{$_} => $spec{$_} }
          grep { exists $spec_map{$_} }
          keys %spec;
        push @attrs, $meta->add_attribute($name => %spec);
      }
      foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
        foreach my $attr ($mouse->get_all_attributes) {
          my %spec = %{$attr};
          delete @spec{qw(
            associated_class associated_methods __METACLASS__
            provides curries
          )};
          my $name = delete $spec{name};
          next if $seen_name{$name}++;
          push @attrs, $meta->add_attribute($name => %spec);
        }
      }
    }
    for my $meth_name (keys %methods) {
      my $meth_code = $methods{$meth_name};
      $meta->add_method($meth_name, $meth_code) if $meth_code;
    }
  
    if ($am_role) {
      my $info = $Moo::Role::INFO{$name};
      $meta->add_required_methods(@{$info->{requires}});
      foreach my $modifier (@{$info->{modifiers}}) {
        my ($type, @args) = @$modifier;
        my $code = pop @args;
        $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
      }
    } else {
      foreach my $attr (@attrs) {
        foreach my $method (@{$attr->associated_methods}) {
          $method->{body} = $name->can($method->name);
        }
      }
      bless(
        $meta->find_method_by_name('new'),
        'Moo::HandleMoose::FakeConstructor',
      );
      # a combination of Moo and Moose may bypass a Moo constructor but still
      # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
      # global destruction.
      require Method::Generate::DemolishAll;
    }
    $meta->add_role(Class::MOP::class_of($_))
      for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
        do { no warnings 'once'; keys %{$Role::Tiny::APPLIED_TO{$name}} };
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->$meth(@_)
  }
  sub can {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->can(@_)
  }
  sub isa {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use strictures 1;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)[A-Z]+\(0x([0-9a-zA-Z]+)\)$/) {
      my $id = do { no warnings 'portable'; hex "$1" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  my @types = %TYPE_MAP;
  tie %TYPE_MAP, __PACKAGE__;
  %TYPE_MAP = @types;
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use strictures 1;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    $NO_BUILD{$class} and
      return bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class)
      : do {
          my $proto = ref($_[0]) eq 'HASH' ? $_[0] : { @_ };
          bless({ %$proto }, $class)->BUILDALL($proto);
        };
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    require Role::Tiny;
    { no warnings 'redefine'; *does = \&Role::Tiny::does_role }
    goto &Role::Tiny::does_role;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use strictures 1;
  use Moo::_Utils;
  use Role::Tiny ();
  use base qw(Role::Tiny);
  use Import::Into;
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  BEGIN { *INFO = \%Role::Tiny::INFO }
  
  our %INFO;
  our %APPLY_DEFAULTS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my ($me) = @_;
    _set_loaded(caller);
    strictures->import::into(1);
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      die "Cannot import Moo::Role into a Moo class";
    }
    $INFO{$target} ||= {};
    # get symbol table reference
    my $stash = _getstash($target);
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    return if $INFO{$target}{is_role}; # already exported into this package
    $INFO{$target}{is_role} = 1;
    *{_getglob("${target}::meta")} = $me->can('meta');
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later) with a map to the coderefs in case of copying or re-use
    my @not_methods = ('', map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $Role::Tiny::APPLIED_TO{$target} = { $target => undef };
  
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $INFO{$role};
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    _load_module($role);
    my $meta;
    if (!$INFO{$role}
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $Role::Tiny::APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
  
            $spec->{isa} = sub {
              &$check or die "Type constraint failed for $_[0]"
            };
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      require Class::Method::Modifiers if @$mods;
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      $me->_inhale_if_moose($role);
      die "${role} is not a Moo::Role" unless $INFO{$role};
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    $me->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $INFO{$role};
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
        $me->_inhale_if_moose($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      *{_getglob("${new_name}::ISA")} = [ $superclass ];
      $me->apply_roles_to_package($new_name, @roles);
      _set_loaded($new_name, (caller)[1]);
      return $new_name;
    }
  
    require Sub::Quote;
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Role::Tiny" unless $INFO{$role};
    }
  
    $Moo::MAKERS{$new_name} = {is_class => 1};
  
    $me->_handle_constructor($new_name, $_) for @roles;
  
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    _set_loaded(ref $new, (caller)[1]);
  
    my $apply_defaults = $APPLY_DEFAULTS{ref $new} ||= do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for(ref $new)
          and my $m = Moo->_accessor_maker_for(ref $new)) {
        require Sub::Quote;
  
        my $specs = $con_gen->all_attribute_specs;
  
        my $assign = '';
        my %captures;
        foreach my $name ( keys %attrs ) {
          my $spec = $specs->{$name};
          if ($m->has_eager_default($name, $spec)) {
            my ($has, $has_cap)
              = $m->generate_simple_has('$_[0]', $name, $spec);
            my ($code, $pop_cap)
              = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
            $assign .= $code;
            @captures{keys %$has_cap, keys %$pop_cap}
              = (values %$has_cap, values %$pop_cap);
          }
        }
        Sub::Quote::quote_sub($assign, \%captures);
      }
      else {
        sub {};
      }
    };
    $new->$apply_defaults;
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $Role::Tiny::COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    if ($INFO{$to}) {
      push @{$INFO{$to}{attributes}||=[]}, @$attr_info;
    } else {
      # only fiddle with the constructor if the target is a Moo class
      if ($INC{"Moo.pm"}
          and my $con = Moo->_constructor_maker_for($to)) {
        # shallow copy of the specs since the constructor will assign an index
        $con->register_attribute_specs(map ref() ? { %$_ } : $_, @$attr_info);
      }
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  And elsewhere:
  
   package Some::Class;
  
   use Moo;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
   package My::Role::ID;
  
   use Digest::MD5 qw(md5_hex);
   use Moo::Role;
   use Digest::SHA qw(sha1_hex);
  
   requires 'name';
  
   sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
   sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
   1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  
  no warnings 'once'; # guard against -w
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use constant lt_5_8_3 => ( $] < 5.008003 or $ENV{MOO_TEST_PRE_583} ) ? 1 : 0;
  use constant can_haz_subname => eval { require Sub::Name };
  
  use strictures 1;
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use base qw(Exporter);
  use Moo::_mro;
  use Config;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa _getstash _install_coderef _name_coderef
      _unimport_coderefs _in_global_destruction _set_loaded
  );
  
  sub _in_global_destruction ();
  *_in_global_destruction = \&Devel::GlobalDestruction::in_global_destruction;
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      require Sub::Defer;
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  sub _load_module {
    my $module = $_[0];
    my $file = module_notional_filename($module);
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    die $error;
  }
  
  sub _maybe_load_module {
    return $MAYBE_LOADED{$_[0]} if exists $MAYBE_LOADED{$_[0]};
    (my $proto = $_[0]) =~ s/::/\//g;
    local $@;
    if (eval { require "${proto}.pm"; 1 }) {
      $MAYBE_LOADED{$_[0]} = 1;
    } else {
      if (exists $INC{"${proto}.pm"}) {
        warn "$_[0] exists but failed to load with error: $@";
      }
      $MAYBE_LOADED{$_[0]} = 0;
    }
    return $MAYBE_LOADED{$_[0]};
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _get_linear_isa {
    return mro::get_linear_isa($_[0]);
  }
  
  sub _install_coderef {
    no warnings 'redefine';
    *{_getglob($_[0])} = _name_coderef(@_);
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    can_haz_subname ? Sub::Name::subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use strictures 1;
  use Moo::_Utils ();
  
  sub unimport { our $disarmed = 1 }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disarmed or Moo::_Utils::_in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  if ($INC{"Moose.pm"}) {
    require Moo::HandleMoose;
    Moo::HandleMoose->import;
  } else {
    $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
  }
  
  1;
MOO_SIFICATION

$fatpacked{"MooX/late.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOX_LATE';
  use 5.008;
  use strict;
  use warnings;
  
  package MooX::late;
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.014';
  
  use Moo              qw( );
  use Carp             qw( carp croak );
  use Scalar::Util     qw( blessed );
  use Module::Runtime  qw( is_module_name );
  
  BEGIN {
  	package MooX::late::DefinitionContext;
  	our $AUTHORITY = 'cpan:TOBYINK';
  	our $VERSION   = '0.014';
  	
  	use Moo;
  	use overload (
  		q[""]    => 'to_string',
  		q[bool]  => sub { 1 },
  		fallback => 1,
  	);
  	
  	has package  => (is => 'ro');
  	has filename => (is => 'ro');
  	has line     => (is => 'ro');
  	
  	sub to_string
  	{
  		my $self = shift;
  		sprintf(
  			'%s:%d, package %s',
  			$self->filename,
  			$self->line,
  			$self->package,
  		);
  	}
  	
  	sub new_from_caller
  	{
  		my ($class, $level) = @_;
  		$level = 0 unless defined $level;
  		
  		my ($p, $f, $c) = caller($level + 1);
  		return $class->new(
  			package  => $p,
  			filename => $f,
  			line     => $c,
  		);
  	}
  };
  
  # SUBCLASSING
  # This is a hook for people subclassing MooX::late.
  # It should be easy to tack on your own handlers
  # to the end of the list. A handler is only called
  # if exists($spec{$handler_name}) in the attribute
  # spec.
  # 
  sub _handlers
  {
  	qw( isa coerce lazy_build traits );
  }
  
  # SUBCLASSING
  # Not really sure why you'd want to override
  # this.
  #
  sub _definition_context_class
  {
  	"MooX::late::DefinitionContext";
  }
  
  sub import
  {
  	my $me = shift;
  	my $caller = caller;
  	
  	my $install_tracked;
  	{
  		no warnings;
  		if ($Moo::MAKERS{$caller})
  		{
  			$install_tracked = \&Moo::_install_tracked;
  		}
  		elsif ($Moo::Role::INFO{$caller})
  		{
  			$install_tracked = \&Moo::Role::_install_tracked;
  		}
  		else
  		{
  			croak "MooX::late applied to a non-Moo package"
  				. "(need: use Moo or use Moo::Role)";
  		}
  	}
  	
  	my $orig = $caller->can('has')  # lolcat
  		or croak "Could not locate 'has' function to alter";
  	
  	my @handlers = $me->_handlers;
  	
  	# SUBCLASSING
  	# MooX::late itself does not provide a
  	# `_finalize_attribute` method. Your subclass
  	# can, in which case it will be called right
  	# before setting up the attribute.
  	# 
  	my $finalize = $me->can("_finalize_attribute");
  	
  	$install_tracked->(
  		$caller, has => sub
  		{
  			my ($proto, %spec) = @_;
  			my $context = $me->_definition_context_class->new_from_caller(0);
  			
  			for my $name (ref $proto ? @$proto : $proto)
  			{
  				my $spec = +{ %spec }; # shallow clone
  				
  				for my $option (@handlers)
  				{
  					next unless exists $spec->{$option};
  					my $handler = $me->can("_handle_$option");
  					
  					# SUBCLASSING
  					# Note that handlers are called as methods, and
  					# get passed:
  					# 1. the attribute name
  					# 2. the attribute spec (hashref, modifiable)
  					# 3. a context object
  					# 4. the name of the caller class/role
  					#
  					$me->$handler($name, $spec, $context, $caller);
  				}
  				
  				$me->$finalize($name, $spec, $context, $caller) if $finalize;
  				$orig->($name, %$spec);
  			}
  			return;
  		},
  	);
  	
  	$me->_install_sugar($caller, $install_tracked);
  }
  
  # SUBCLASSING
  # This can be used to install additional functions
  # into the caller package.
  #
  sub _install_sugar
  {
  	my $me = shift;
  	my ($caller, $installer) = @_;
  	$installer->($caller, blessed => \&Scalar::Util::blessed);
  	$installer->($caller, confess => \&Carp::confess);
  }
  
  my %registry;
  sub _handle_isa
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	return if ref $spec->{isa};
  	
  	require Type::Utils;
  	$spec->{isa} = Type::Utils::dwim_type($spec->{isa}, for => $class);
  	
  	return;
  }
  
  sub _handle_coerce
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	my $c = $spec->{coerce};
  	my $i = $spec->{isa};
  	
  	if (defined($c) and !ref($c) and $c == 1)
  	{
  		if (blessed($i) and $i->isa('Type::Tiny') and $i->has_coercion)
  		{
  			$spec->{coerce} = $i->coercion;
  		}
  		elsif (blessed($i) and $i->can('has_coercion') and $i->has_coercion and $i->can('coerce'))
  		{
  			$spec->{coerce} = sub { $i->coerce(@_) };
  		}
  	}
  
  	if (defined($c) and !ref($c) and $c eq 0)
  	{
  		delete($spec->{coerce});
  	}
  
  	return;
  }
  
  sub _handle_lazy_build
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	return unless delete $spec->{lazy_build};
  	
  	$spec->{is}      ||= "ro";
  	$spec->{lazy}    ||= 1;
  	$spec->{builder} ||= "_build_$name";
  	
  	if ($name =~ /^_/)
  	{
  		$spec->{clearer}   ||= "_clear$name";
  		$spec->{predicate} ||= "_has$name";
  	}
  	else
  	{
  		$spec->{clearer}   ||= "clear_$name";
  		$spec->{predicate} ||= "has_$name";
  	}
  	
  	return;
  }
  
  sub _handle_traits
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	my @new;
  	foreach my $trait (@{ $spec->{traits} || [] })
  	{
  		my $handler = $me->can("_handletrait_$trait");
  		croak "$me cannot process trait $trait" unless $handler;
  		
  		# SUBCLASSING
  		# There is a second level of handlers for traits.
  		# Just add a method called "_handletrait_Foo"
  		# and it will be called to handle the trait "Foo".
  		# These handlers should normally return the empty
  		# list, but may return a list of strings to add to
  		# a *new* traits arrayref.
  		#
  		push @new, $me->$handler(@_);
  	}
  	
  	$spec->{traits} = \@new;
  	
  	if ($spec->{handles_via})
  	{
  		eval "require MooX::HandlesVia"
  			or croak("Requires MooX::HandlesVia for attribute trait defined at $context");
  		
  		my ($name, %spec) = MooX::HandlesVia::process_has($name, %$spec);
  		%$spec = %spec;
  	}
  	
  	return;
  }
  
  sub _handletrait_Array
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Collection::Array::MooseLike";
  	
  	return;
  }
  
  sub _handletrait_Hash
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Collection::Hash::MooseLike";
  	
  	return;
  }
  
  sub _handletrait_Code
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Code";
  	
  	# Special handling for execute_method!
  	while (my ($k, $v) = each %{ $spec->{handles} })
  	{
  		next unless $v eq q(execute_method);
  		
  		# MooX::HandlesVia can't handle this right yet.
  		delete $spec->{handles}{$k};
  		
  		# ... so we handle it ourselves.
  		eval qq{
  			package ${class};
  			sub ${k} {
  				my \$self = shift;
  				return \$self->${name}->(\$self, \@_);
  			}
  		};
  	}
  	
  	return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf8
  
  =for stopwords superset MooX
  
  =head1 NAME
  
  MooX::late - easily translate Moose code to Moo
  
  =head1 SYNOPSIS
  
     package Foo;
     use Moo;
     use MooX::late;
     has bar => (is => "ro", isa => "Str", default => "MacLaren's Pub");
  
  (Examples for Moo roles in section below.)
  
  =head1 DESCRIPTION
  
  L<Moo> is a light-weight object oriented programming framework which aims
  to be compatible with L<Moose>. It does this by detecting when Moose has
  been loaded, and automatically "inflating" its classes and roles to full
  Moose classes and roles. This way, Moo classes can consume Moose roles,
  Moose classes can extend Moo classes, and so forth.
  
  However, the surface syntax of Moo differs somewhat from Moose. For example
  the C<isa> option when defining attributes in Moose must be either a string
  or a blessed L<Moose::Meta::TypeConstraint> object; but in Moo must be a
  coderef. These differences in surface syntax make porting code from Moose to
  Moo potentially tricky. L<MooX::late> provides some assistance by enabling a
  slightly more Moosey surface syntax.
  
  MooX::late does the following:
  
  =over
  
  =item 1.
  
  Allows C<< isa => $string >> to work when defining attributes for all
  Moose's built-in type constraints (and assumes other strings are package
  names).
  
  This feature requires L<Types::Standard>.
  
  =item 2.
  
  B<< Retired feature: >> this is now built in to Moo.
  
  Allows C<< default => $non_reference_value >> to work when defining
  attributes.
  
  =item 3.
  
  Allows C<< lazy_build => 1 >> to work when defining attributes.
  
  =item 4.
  
  Exports C<blessed> and C<confess> functions to your namespace.
  
  =item 5.
  
  Handles certain attribute traits. Currently C<Hash>, C<Array> and C<Code>
  are supported. This feature requires L<MooX::HandlesVia>. 
  
  C<String>, C<Number>, C<Counter> and C<Bool> are unlikely to ever be
  supported because of internal implementation details of Moo. If you need
  another attribute trait to be supported, let me know and I will consider
  it.
  
  =item 6.
  
  Supports C<< coerce => 1 >> if the type constraint is a blessed object
  implementing L<Type::API::Constraint::Coercible>.
  
  =back
  
  Five features. It is not the aim of C<MooX::late> to make every aspect of
  Moo behave exactly identically to Moose. It's just going after the low-hanging
  fruit. So it does five things right now, and I promise that future versions
  will never do more than seven.
  
  =head2 Use in Moo::Roles
  
  MooX::late should work in Moo::Roles, with no particular caveats.
  
     package MyRole;
     use Moo::Role;
     use MooX::late;
  
  L<Package::Variant> can be used to build the Moo equivalent of
  parameterized roles. MooX::late should work in roles built with
  Package::Variant.
  
     use Package::Variant
        importing => [ qw( Moo::Role MooX::late ) ],
        subs      => [ qw( has with ) ];
  
  =head2 Type constraints
  
  Type constraint strings are interpreted using L<Type::Parser>, using the
  type constraints defined in L<Types::Standard>. This provides a very slight
  superset of Moose's type constraint syntax and built-in type constraints.
  
  Any unrecognized string that looks like it might be a class name is
  interpreted as a class type constraint.
  
  =head2 Subclassing
  
  MooX::late is designed to be reasonably easy to subclass. There are comments
  in the source code explaining hooks for extensibility.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=MooX-late>.
  
  =head1 SEE ALSO
  
  C<MooX::late> uses L<Types::Standard> to check type constraints.
  
  C<MooX::late> uses L<MooX::HandlesVia> to provide native attribute traits
  support.
  
  The following modules bring additional Moose functionality to Moo:
  
  =over
  
  =item *
  
  L<MooX::Override> - support override/super
  
  =item *
  
  L<MooX::Augment> - support augment/inner
  
  =back
  
  L<MooX> allows you to load Moo plus multiple MooX extension modules in a
  single line.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2012-2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MOOX_LATE

$fatpacked{"Number/Bytes/Human.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_BYTES_HUMAN';
  package Number::Bytes::Human;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.09';
  
  require Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(format_bytes parse_bytes);
  
  require POSIX;
  use Carp qw(croak carp);
  
  #my $DEFAULT_BLOCK = 1024;
  #my $DEFAULT_ZERO = '0';
  #my $DEFAULT_ROUND_STYLE = 'ceil';
  my %DEFAULT_SUFFIXES = (
    1024 => ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'],
    1000 => ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'],
    1024000 => ['', 'M', 'T', 'E', 'Y'],
    si_1024 => ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],
    si_1000 => ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
  );
  my @DEFAULT_PREFIXES = @{$DEFAULT_SUFFIXES{1024}};
  
  sub _default_suffixes {
    my $set = shift || 1024;
    if (exists $DEFAULT_SUFFIXES{$set}) {
      return @{$DEFAULT_SUFFIXES{$set}} if wantarray;
      return [ @{$DEFAULT_SUFFIXES{$set}} ];
    }
    croak "unknown suffix set '$set'";
  }
  
  my %ROUND_FUNCTIONS = (
    ceil => sub { return POSIX::ceil($_[0] * (10 ** $_[1])) / 10**$_[1]; },
    floor => sub { return POSIX::floor($_[0] * (10 ** $_[1])) / 10**$_[1]; },
    round => sub { return sprintf( "%." . ( $_[1] || 0 ) . "f", $_[0] ); },
    trunc => sub { return sprintf( "%d", $_[0] * (10 ** $_[1])) / 10**$_[1]; },
    # what about 'ceiling'?
  );
  
  sub _round_function {
    my $style = shift;
    if (exists $ROUND_FUNCTIONS{$style}) {
      return $ROUND_FUNCTIONS{$style}
    }
    croak "unknown round style '$style'";
  }
  
  # options
  #   block | block_size | base | bs => 1024 | 1000
  #   base_1024 | block_1024 | 1024 => $true
  #   base_1000 | block_1000 | 1000 => $true
  #
  #   round_function => \&
  #   round_style => 'ceiling', 'round', 'floor', 'trunc'
  #
  #   suffixes => 1024 | 1000 | si_1024 | si_1000 | 1024000 | \@
  #   si => 1
  #   unit => string (eg., 'B' | 'bps' | 'b')
  #
  #   zero => '0' (default) | '-' | '0%S' | undef
  #
  #
  #   supress_point_zero | no_point_zero =>
  #   b_to_i => 1
  #   to_s => \&
  #
  #   allow_minus => 0 | 1
  #   too_large => string
  #   quiet => 1 (supresses "too large number" warning)
  
  
  
  #  PROBABLY CRAP:
  #   precision => integer
  
  # parsed options
  #   BLOCK => 1024 | 1000
  #   ROUND_STYLE => 'ceil', 'round', 'floor', 'trunc'
  #   ROUND_FUNCTION => \&
  #   SUFFIXES => \@
  #   ZERO =>
  #   SI => undef | 1			Parse SI compatible
  
  
  =begin private
  
    $options = _parse_args($seed, $args)
    $options = _parse_args($seed, arg1 => $val1, ...)
  
  $seed is undef or a hashref
  $args is a hashref
  
  =end private
  
  =cut
  
  sub _parse_args {
    my $seed = shift;
    my %args;
  
    my %options;
    unless (defined $seed) { # use defaults
      $options{BLOCK} = 1024;
      $options{ROUND_STYLE} = 'ceil';
      $options{ROUND_FUNCTION} = _round_function($options{ROUND_STYLE});
      $options{ZERO} = '0';
      $options{SI} = undef;
      $options{PRECISION} = 1;
      $options{PRECISION_CUTOFF} = 1;
      #$options{SUFFIXES} = # deferred to the last minute when we know BLOCK, seek [**]
      $options{UNIT} = undef;
    }
    # else { %options = %$seed } # this is set if @_!=0, down below
  
    if (@_==0) { # quick return for default values (no customized args)
      return (defined $seed) ? $seed : \%options;
    } elsif (@_==1 && ref $_[0]) { # \%args
      %args = %{$_[0]};
    } else { # arg1 => $val1, arg2 => $val2
      %args = @_;
    }
  
    # this is done here so this assignment/copy doesn't happen if @_==0
    %options = %$seed unless %options;
  
  # block | block_size | base | bs => 1024 | 1000
  # block_1024 | base_1024 | 1024 => $true
  # block_1000 | base_1000 | 1024 => $true
    if ($args{block} ||
        $args{block_size} ||
        $args{base} ||
        $args{bs}
      ) {
      my $block = $args{block} ||
                  $args{block_size} ||
                  $args{base} ||
                  $args{bs};
      unless ($block==1000 || $block==1024 || $block==1_024_000) {
        croak "invalid base: $block (should be 1024, 1000 or 1024000)";
      }
      $options{BLOCK} = $block;
  
    } elsif ($args{block_1024} ||
             $args{base_1024}  ||
             $args{1024}) {
  
      $options{BLOCK} = 1024;
    } elsif ($args{block_1000} ||
             $args{base_1000}  ||
             $args{1000}) {
  
      $options{BLOCK} = 1000;
    }
  
  # round_function => \&
  # round_style => 'ceil' | 'floor' | 'round' | 'trunc'
    if ($args{round_function}) {
      unless (ref $args{round_function} eq 'CODE') {
        croak "round function ($args{round_function}) should be a code ref";
      }
      $options{ROUND_FUNCTION} = $args{round_function};
      $options{ROUND_STYLE} = $args{round_style} || 'unknown';
    } elsif ($args{round_style}) {
      $options{ROUND_FUNCTION} = _round_function($args{round_style});
      $options{ROUND_STYLE} = $args{round_style};
    }
  
  # SI compatibility (mostly for parsing)
    if ($args{si}) {
      $options{SI} = 1;
    }
  
  # suffixes => 1024 | 1000 | si_1024 | si_1000 | 1024000 | \@
    if ($args{suffixes}) {
      if (ref $args{suffixes} eq 'ARRAY') {
        $options{SUFFIXES} = $args{suffixes};
      } elsif ($args{suffixes} =~ /^(si_)?(1000|1024)$/) {
        $options{SUFFIXES} = _default_suffixes($args{suffixes});
      } else {
        croak "suffixes ($args{suffixes}) should be 1024, 1000, si_1024, si_1000, 1024000 or an array ref";
      }
    }
    if (defined $args{unit}) {
      $options{UNIT} = $args{unit};
    }
  
  # zero => undef | string
    if (exists $args{zero}) {
      $options{ZERO} = $args{zero};
      if (defined $options{ZERO}) {
        $options{ZERO} =~ s/%S/$options{SUFFIXES}->[0]/g
      }
    }
  
  # precision => <integer>
    if (exists $args{precision} and $args{precision} =~ /\A\d+\z/) {
      $options{PRECISION} = $args{precision};
    }
  
  # precision_cutoff => <intenger>
    if (exists $args{precision_cutoff} and ($args{precision_cutoff} =~ /\A\d+\z/ or $args{precision_cutoff} = '-1')) {
      $options{PRECISION_CUTOFF} = $args{precision_cutoff};
    }
  
  # quiet => 1
    if ($args{quiet}) {
      $options{QUIET} = 1;
    }
  
    if (defined $seed) {
      %$seed = %options;
      return $seed;
    }
    return \%options
  }
  
  # NOTE. _format_bytes() SHOULD not change $options - NEVER.
  
  sub _format_bytes {
    my $bytes = shift;
    return undef unless defined $bytes;
    my $options = shift;
    my %options = %$options;
  
    local *human_round = $options{ROUND_FUNCTION};
  
    return $options{ZERO} if ($bytes==0 && defined $options{ZERO});
  
    my $block = $options{BLOCK};
  
    # if a suffix set was not specified, pick a default [**]
    my @suffixes = $options{SUFFIXES} ? @{$options{SUFFIXES}} : _default_suffixes( ($options{SI} ? 'si_' : '') . $block);
  
    # WHAT ABOUT NEGATIVE NUMBERS: -1K ?
    my $sign = '';
    if ($bytes<0) {
       $bytes = -$bytes;
       $sign = '-';
    }
  
    my $suffix = $suffixes[0];
    my $x = $bytes;
    my $magnitude = 0;
    if($bytes >= $block) {
    #  return "$sign$bytes" if $bytes<$block;
      do {
        $x /= $block;
        $magnitude++;
      } while ( human_round($x, $options{PRECISION}) >= $block );
      if($magnitude >= (0 + @suffixes)) {
        carp "number too large (>= $block**$magnitude)" unless ($options{QUIET});
      }
      $suffix = $suffixes[$magnitude];
    }
    #$x = human_round( $x, $options{PRECISION} );
  
    $x = _precision_cutoff($x, $options);
    #reasses encase the precision_cutoff caused the value to cross the block size
    if($x >= $block) {
      $x /= $block;
      $magnitude++;
      if($magnitude >= (0 + @suffixes)) {
        carp "number too large (>= $block**$magnitude)" unless ($options{QUIET});
      }
      $suffix = $suffixes[$magnitude];
      $x = _precision_cutoff($x, $options);
    }
  
    my $unit = $options{UNIT} || '';
  
    return $sign . $x . $suffix . $unit;
  
  }
  
  sub _precision_cutoff {
   my $bytes   = shift;
   my $options = shift;
   my %options = %$options;
   if ( $options{PRECISION_CUTOFF} != -1 and ( length( sprintf( "%d", $bytes ) ) > $options{PRECISION_CUTOFF} ) ) {
     $bytes = sprintf( "%d", human_round( $bytes, 0 ) );
   } else {
     $bytes = sprintf( "%." . $options{PRECISION} . "f", human_round( $bytes, $options{PRECISION} ) );
   }
   return $bytes;
  }
  
  sub _parse_bytes {
    my $human = shift;
    my $options = shift;
    my %options = %$options;
  
    return 0 if( exists $options{ZERO} && ((!defined $options{ZERO} && !defined $human) || (defined $human && $human eq $options{ZERO})) );
    return undef unless defined $human;
  
    my %suffix_mult;
    my %suffix_block;
    my $m;
  
    if( $options{SUFFIXES} ) {
      $m = 1;
      foreach my $s (@{$options{SUFFIXES}}) {
        $suffix_mult{$s} = $m;
        $suffix_block{$s} = $options{BLOCK};
        $m *= $suffix_block{$s};
      }
    } else {
      if( !defined $options{SI} || $options{SI} == 1 ) {
        # If SI compatibility has been set BLOCK is ignored as it is infered from the unit
        $m = 1;
        foreach my $s (@{$DEFAULT_SUFFIXES{si_1000}}) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = 1000;
          $m *= $suffix_block{$s};
        }
      
        $m = 1;
        foreach my $s (@{$DEFAULT_SUFFIXES{si_1024}}) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = 1024;
          $m *= $suffix_block{$s};
        }
      }
  
      # The regular suffixes are only taken into account in default mode without specifically asking for SI compliance
      if( !defined $options{SI} ) {
        $m = 1;
        foreach my $s (_default_suffixes( $options{BLOCK} )) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = $options{BLOCK};
          $m *= $suffix_block{$s};
        }
      }
    }
  
    my ($sign, $int, $frac, $unit) = ($human =~ /^\s*(-?)\s*(\d*)(?:\.(\d*))?\s*(\D*)$/);
  
    $frac ||= 0;
  
  #  print STDERR "S: $sign I: $int F: $frac U: $unit\n";
  
  
    my $mult;
    my $block;
    my $u = $options{UNIT} || '';
    foreach my $s (keys %suffix_block) {
      if( $unit =~ /^${s}${u}$/i ) {
        $mult = ($sign eq '-' ? -1 : 1) * $suffix_mult{$s};
        $block = $suffix_block{$s};
        last;
      }
    }
  
    if( !defined $mult ) {
      carp "Could not parse human readable byte value '$human'";
  use Data::Dumper;
  print STDERR Dumper( %suffix_block );
      return undef;
    }
  
    my $bytes = int( ($int + ($frac / $block)) * $mult );
  
    return $bytes;
  }
  
  
  # convert byte count (file size) to human readable format
  sub format_bytes {
    my $bytes = shift;
    my $options = _parse_args(undef, @_);
    #use YAML; print Dump $options;
    return _format_bytes($bytes, $options);
  }
  
  # convert human readable format to byte count (file size)
  sub parse_bytes {
    my $human = shift;
    my $options = _parse_args(undef, @_);
    #use YAML; print Dump $options;
    return _parse_bytes($human, $options);
  }
  
  ### the OO way
  
  # new()
  sub new {
    my $proto = shift;
    my $class = ref $proto || $proto;
    my $opts = _parse_args(undef, @_);
    return bless $opts, $class;
  }
  
  # set_options()
  sub set_options {
    my $self = shift;
    return $self->_parse_args(@_);
  }
  
  # format()
  sub format {
    my $self = shift;
    my $bytes = shift;
    return _format_bytes($bytes, $self);
  }
  
  # parse()
  sub parse {
    my $self = shift;
    my $human = shift;
    return _parse_bytes($human, $self);
  }
  
  # the solution by COG in Filesys::DiskUsage
  # convert size to human readable format
  #sub _convert {
  #  defined (my $size = shift) || return undef;
  #  my $config = {@_};
  #  $config->{human} || return $size;
  #  my $block = $config->{'Human-readable'} ? 1000 : 1024;
  #  my @args = qw/B K M G/;
  #
  #  while (@args && $size > $block) {
  #    shift @args;
  #    $size /= $block;
  #  }
  #
  #  if ($config->{'truncate-readable'} > 0) {
  #    $size = sprintf("%.$config->{'truncate-readable'}f",$size);
  #  }
  #
  #  "$size$args[0]";
  #}
  #
  # not exact: 1024 => 1024B instead of 1K
  # not nicely formatted => 1.00 instead of 1K
  
  1;
  
  __END__
  
  =head1 NAME
  
  Number::Bytes::Human - Convert byte count to human readable format
  
  =head1 SYNOPSIS
  
    use Number::Bytes::Human qw(format_bytes parse_bytes);
    $size = format_bytes(0); # '0'
    $size = format_bytes(2*1024); # '2.0K'
  
    $size = format_bytes(1_234_890, bs => 1000); # '1.3M'
    $size = format_bytes(1E9, bs => 1000); # '1.0G'
  
    my $bytes = parse_bytes('1.0K');   # 1024
    my $bytes = parse_bytes('1.0KB');  # 1000, SI unit
    my $bytes = parse_bytes('1.0KiB'); # 1024, SI unit
  
    # the OO way
    $human = Number::Bytes::Human->new(bs => 1000, si => 1);
    $size = $human->format(1E7); # '10MB'
  
    $bytes = $human->parse('10MB');   # 10*1000*1000
    $bytes = $human->parse('10MiB');  # 10*1024*1024
    $bytes = $human->parse('10M');    # Error, no SI unit
  
    $human->set_options(zero => '-');
    $size = $human->format(0);    # '-'
    $bytes = $human->parse('-');  # 0
  
    $human = Number::Bytes::Human->new(bs => 1000, round_style => 'round', precision => 2);
    $size = $human->format(10240000); # '10.24MB'
  
  =head1 DESCRIPTION
  
  THIS IS ALPHA SOFTWARE: THE DOCUMENTATION AND THE CODE WILL SUFFER
  CHANGES SOME DAY (THANKS, GOD!).
  
  This module provides a formatter which turns byte counts
  to usual readable format, like '2.0K', '3.1G', '100B'.
  It was inspired in the C<-h> option of Unix
  utilities like C<du>, C<df> and C<ls> for "human-readable" output.
  
  From the FreeBSD man page of C<df>: http://www.freebsd.org/cgi/man.cgi?query=df
  
    "Human-readable" output.  Use unit suffixes: Byte, Kilobyte,
    Megabyte, Gigabyte, Terabyte and Petabyte in order to reduce the
    number of digits to four or fewer using base 2 for sizes.
  
    byte      B
    kilobyte  K = 2**10 B = 1024 B
    megabyte  M = 2**20 B = 1024 * 1024 B
    gigabyte  G = 2**30 B = 1024 * 1024 * 1024 B
    terabyte  T = 2**40 B = 1024 * 1024 * 1024 * 1024 B
  
    petabyte  P = 2**50 B = 1024 * 1024 * 1024 * 1024 * 1024 B
    exabyte   E = 2**60 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
    zettabyte Z = 2**70 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
    yottabyte Y = 2**80 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
  
  I have found this link to be quite useful:
  
    http://www.t1shopper.com/tools/calculate/
  
  If you feel like a hard-drive manufacturer, you can start
  counting bytes by powers of 1000 (instead of the generous 1024).
  Just use C<< bs => 1000 >>.
  
  But if you are a floppy disk manufacturer and want to start
  counting in units of 1024000 (for your "1.44 MB" disks)?
  Then use C<< bs => 1_024_000 >>.
  
  If you feel like a purist academic, you can force the use of
  metric prefixes
  according to the Dec 1998 standard by the IEC. Never mind the units for base 1000
  are C<('B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB')> and,
  even worse, the ones for base 1024 are
  C<('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB')>
  with the horrible names: bytes, kibibytes, mebibytes, etc.
  All you have to do is to use C<< si => 1 >>. Ain't that beautiful
  the SI system? Read about it:
  
    http://physics.nist.gov/cuu/Units/binary.html
  
  You can try a pure Perl C<"ls -lh">-inspired command with the one-liner, er, two-liner:
  
    $ perl -MNumber::Bytes::Human=format_bytes \
           -e 'printf "%5s %s\n", format_bytes(-s), $_ for @ARGV' *
  
  Why to write such a module? Because if people can write such things
  in C, it can be written much easier in Perl and then reused,
  refactored, abused. And then, when it is much improved, some
  brave soul can port it back to C (if only for the warm feeling
  of painful programming).
  
  It is also possible to parse human readable formatted bytes. The 
  automatic format detection recognizes SI units with the blocksizes
  of 1000 and 1024 respectively and additionally the customary K / M / G etc. with
  blocksize 1024. When si => 1 is added to the options only SI units
  are recognized. Explicitly specifying a blocksize changes it
  for all detected units.
  
  =head2 OBJECTS
  
  An alternative to the functional style of this module
  is the OO fashion. This is useful for avoiding the
  unnecessary parsing of the arguments over and over
  if you have to format lots of numbers
  
  
    for (@sizes) {
      my $fmt_size = format_bytes($_, @args);
      ...
    }
  
  versus
  
    my $human = Number::Format::Bytes->new(@args);
    for (@sizes) {
      my $fmt_size = $human->format($_);
      ...
    }
  
  for TODO
  [TODO] MAKE IT JUST A MATTER OF STYLE: memoize _parse_args()
  $seed == undef
  
  =head2 FUNCTIONS
  
  =over 4
  
  =item B<format_bytes>
  
    $h_size = format_bytes($size, @options);
  
  Turns a byte count (like 1230) to a readable format like '1.3K'.
  You have a bunch of options to play with. See the section
  L</"OPTIONS"> to know the details.
  
  =item B<parse_bytes>
  
    $size = parse_bytes($h_size, @options);
  
  Turns a human readable byte count into a number of the equivalent bytes.
  
  =back
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
    $h = Number::Bytes::Human->new(@options);
  
  The constructor. For details on the arguments, see the section
  L</"OPTIONS">.
  
  =item B<format>
  
    $h_size = $h->format($size);
  
  Turns a byte count (like 1230) to a readable format like '1.3K'.
  The statements
  
    $h = Number::Bytes::Human->new(@options);
    $h_size = $h->format($size);
  
  are equivalent to C<$h_size = format_bytes($size, @options)>,
  with only one pass for the option arguments.
  
  =item B<parse>
  
    $size = $h->parse($h_size)
  
  Turns a human readable byte count into the number of bytes.
  The statements
  
    $h = Number::Bytes::Human->new(@options);
    $size = $h->format($h_size);
  
  are equivalent to C<$size = parse_bytes($h_size, @options)>,
  with only one pass for the option arguments.
  
  =item B<set_options>
  
    $h->set_options(@options);
  
  To alter the options of a C<Number::Bytes::Human> object.
  See L</"OPTIONS">.
  
  =back
  
  =head2 OPTIONS
  
  =over 4
  
  =item BASE
  
    block | base | block_size | bs => 1000 | 1024 | 1024000
    base_1024 | block_1024 | 1024 => 1
    base_1000 | block_1000 | 1000 => 1
  
  The base to be used: 1024 (default), 1000 or 1024000.
  
  Any other value throws an exception.
  
  =item SUFFIXES
  
    suffixes => 1000 | 1024 | 1024000 | si_1000 | si_1024 | $arrayref
  
  By default, the used suffixes stand for '', 'K', 'M', ...
  for base 1024 and '', 'k', 'M', ... for base 1000
  (which are indeed the usual metric prefixes with implied unit
  as bytes, 'B'). For the weird 1024000 base, suffixes are
  '', 'M', 'T', etc.
  
  =item ZERO
  
    zero => string | undef
  
  The string C<0> maps to ('0' by default). If C<undef>, the general case is used.
  The string may contain '%S' in which case the suffix for byte is used.
  
    format_bytes(0, zero => '-') => '-'
  
  =item METRIC SYSTEM
  
    si => 1
  
  =item ROUND
  
    round_function => $coderef
    round_style => 'ceil' | 'floor' | 'round' | 'trunc'
  
  =item TO_S
  
  =item QUIET
  
    quiet => 1
  
  Suppresses the warnings emitted. Currently, the only case is
  when the number is large than C<$base**(@suffixes+1)>.
  
  =item PRECISION
  
    precision => <integer>
  
  default = 1
  sets the precicion of digits, only apropreacte for round_style 'round' or if you
  want to accept it in as the second parameter to your custome round_function.
  
  =item PRECISION_CUTOFF
  
    precision_cutoff => <integer>
  
  default = 1
  when the number of digits exceeds this number causes the precision to be cutoff
  (was default behaviour in 0.07 and below)
  
  =back
  
  =head2 EXPORT
  
  It is alright to import C<format_bytes> and C<parse_bytes>, but nothing is exported by default.
  
  =head1 DIAGNOSTICS
  
    "unknown round style '$style'";
  
    "invalid base: $block (should be 1024, 1000 or 1024000)";
  
    "round function ($args{round_function}) should be a code ref";
  
    "suffixes ($args{suffixes}) should be 1000, 1024, 1024000 or an array ref";
  
    "negative numbers are not allowed" (??)
  
  =head1 TO DO
  
  A function C<parse_bytes>
  
    parse_bytes($str, $options)
  
  which transforms '1k' to 1000, '1K' to 1024, '1MB' to 1E6,
  '1M' to 1024*1024, etc. (like gnu du).
  
    $str =~ /^\s*(\d*\.?\d*)\s*(\S+)/ # $num $suffix
  
  =head1 SEE ALSO
  
  F<lib/human.c> and F<lib/human.h> in GNU coreutils.
  
  The C<_convert()> solution by COG in Filesys::DiskUsage.
  
  =head1 BUGS
  
  Please report bugs via CPAN RT L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Number-Bytes-Human>
  or L<mailto://bug-Number-Bytes-Human@rt.cpan.org>. I will not be able to close the bug
  as BestPractical ignore my claims that I cannot log in, but I will answer anyway.
  
  =head1 AUTHOR
  
  Adriano R. Ferreira, E<lt>ferreira@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2005-2007 by Adriano R. Ferreira
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
NUMBER_BYTES_HUMAN

$fatpacked{"Number/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_COMPARE';
  package Number::Compare;
  use strict;
  use Carp qw(croak);
  use vars qw/$VERSION/;
  $VERSION = '0.03';
  
  sub new  {
      my $referent = shift;
      my $class = ref $referent || $referent;
      my $expr = $class->parse_to_perl( shift );
  
      bless eval "sub { \$_[0] $expr }", $class;
  }
  
  sub parse_to_perl {
      shift;
      my $test = shift;
  
      $test =~ m{^
                 ([<>]=?)?   # comparison
                 (.*?)       # value
                 ([kmg]i?)?  # magnitude
                $}ix
         or croak "don't understand '$test' as a test";
  
      my $comparison = $1 || '==';
      my $target     = $2;
      my $magnitude  = $3 || '';
      $target *=           1000 if lc $magnitude eq 'k';
      $target *=           1024 if lc $magnitude eq 'ki';
      $target *=        1000000 if lc $magnitude eq 'm';
      $target *=      1024*1024 if lc $magnitude eq 'mi';
      $target *=     1000000000 if lc $magnitude eq 'g';
      $target *= 1024*1024*1024 if lc $magnitude eq 'gi';
  
      return "$comparison $target";
  }
  
  sub test { $_[0]->( $_[1] ) }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Number::Compare - numeric comparisons
  
  =head1 SYNOPSIS
  
   Number::Compare->new(">1Ki")->test(1025); # is 1025 > 1024
  
   my $c = Number::Compare->new(">1M");
   $c->(1_200_000);                          # slightly terser invocation
  
  =head1 DESCRIPTION
  
  Number::Compare compiles a simple comparison to an anonymous
  subroutine, which you can call with a value to be tested again.
  
  Now this would be very pointless, if Number::Compare didn't understand
  magnitudes.
  
  The target value may use magnitudes of kilobytes (C<k>, C<ki>),
  megabytes (C<m>, C<mi>), or gigabytes (C<g>, C<gi>).  Those suffixed
  with an C<i> use the appropriate 2**n version in accordance with the
  IEC standard: http://physics.nist.gov/cuu/Units/binary.html
  
  =head1 METHODS
  
  =head2 ->new( $test )
  
  Returns a new object that compares the specified test.
  
  =head2 ->test( $value )
  
  A longhanded version of $compare->( $value ).  Predates blessed
  subroutine reference implementation.
  
  =head2 ->parse_to_perl( $test )
  
  Returns a perl code fragment equivalent to the test.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002,2011 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  http://physics.nist.gov/cuu/Units/binary.html
  
  =cut
NUMBER_COMPARE

$fatpacked{"Ouch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OUCH';
  use strict;
  use warnings;
  package Ouch;
  {
    $Ouch::VERSION = '0.0408';
  }
  use Carp qw(longmess shortmess);
  use parent 'Exporter';
  use overload bool => sub {1}, q{""} => 'scalar', fallback => 1;
  use Scalar::Util qw(blessed);
  
  our @EXPORT = qw(bleep ouch kiss hug barf);
  our @EXPORT_OK = qw(try throw catch catch_all caught caught_all);
  our %EXPORT_TAGS = ( traditional => [qw(try throw catch catch_all)], trytiny => [qw( throw caught caught_all )] );
  
  sub new {
    my ($class, $code, $message, $data) = @_;
    bless {code => $code, message => $message, data => $data, shortmess => shortmess($message), trace => longmess($message) }, $class;
  }
  
  sub try (&) {
    my $try = shift;
    eval { $try->() };
    return $@;
  }
  
  sub ouch {
    my ($code, $message, $data) = @_;
    my $self = __PACKAGE__->new($code, $message, $data);
    die $self;
  }
  
  sub throw {  # alias
    ouch @_;
  }
  
  sub kiss {
    my ($code, $e) = @_;
    $e ||= $@;
    if (blessed $e && $e->isa('Ouch') && $e->code eq $code) {
      return 1;
    }
    return 0;
  }
  
  sub catch {
    kiss @_;
  }
  
  sub caught {
    kiss @_;
  }
  
  sub hug {
    my ($e) = @_;
    $e ||= $@;
    return $@ ? 1 : 0;
  }
  
  sub catch_all {
    hug @_;
  }
  
  sub caught_all {
    hug @_;
  }
  
  sub bleep {
    my ($e) = @_;
    $e ||= $@;
    if (blessed $e && $e->isa('Ouch')) {
      return $e->message;
    }
    else {
      my $message = $@;
      if ($message =~ m{^(.*)\s+at\s.*line\s\d+.}xms) {
          return $1;
      }
      else {
          return $message;
      }
    }
  }
  
  sub barf {
      my ($e) = @_;
      my $code;
      $e ||= $@;
      if (blessed $e && $e->isa('Ouch')) {
          $code = $e->code;
      } 
      else {
          $code = 1;
      }
  
      print STDERR bleep($e)."\n";
      exit $code;
  }
  
  sub scalar {
    my $self = shift;
    return $self->{shortmess};
  }
  
  sub trace {
    my $self = shift;
    return $self->{trace};
  }
  
  sub hashref {
    my $self = shift;
    return {
      code    => $self->{code},
      message => $self->{message},
      data    => $self->{data},
    };
  }
  
  sub code {
    my $self = shift;
    return $self->{code};
  }
  
  sub message {
    my $self = shift;
    return $self->{message};
  }
  
  sub data {
    my $self = shift;
    return $self->{data};
  }
  
  =head1 NAME
  
  Ouch - Exceptions that don't hurt.
  
  =head1 VERSION
  
  version 0.0408
  
  =head1 SYNOPSIS
  
   use Ouch;
  
   eval { ouch(404, 'File not found.'); };
  
   if (kiss 404) {
     check_elsewhere();
   }
  
   say $@;           # These two lines do the
   say $@->scalar;   # same thing.
  
  =head1 DESCRIPTION
  
  Ouch provides a class for exception handling that doesn't require a lot of boilerplate, nor any up front definition. If L<Exception::Class>
  is working for you, great! But if you want something that is faster, easier to use, requires less typing, and has no prereqs, but still gives 
  you much of that same functionality, then Ouch is for you.
  
  =head2 Why another exception handling module?
  
  It really comes down to L<Carp> isn't enough for me, and L<Exception::Class> does what I want but makes me type way too much. Also, I tend to work on a lot of protocol-based systems that use error codes (HTTP, FTP, SMTP, JSON-RPC) rather than error classes, so that feels more natural to me. Consider the difference between these:
  
  B<Ouch>
  
   use Ouch;
   ouch 404, 'File not found.', 'file';
  
  B<Exception::Class>
  
   use Exception::Class (
      'FileNotFound' => {
          fields  => [ 'code', 'field' ],
      },
   );
   FileNotFound->throw( error => 'File not found.', code => 404, field => 'file' );
  
  And if you want to catch the exception you're looking at:
  
  B<Ouch>
  
   if (kiss 404) {
     # do something
   }
  
  B<Exception::Class>
  
   my $e;
   if ($e = Exception::Class->caught('FileNotFound')) {
     # do something
   }
  
  Those differences may not seem like a lot, but over any substantial program with lots of exceptions it can become a big deal. 
  
  =head2 Usage
  
  Most of the time, all you need to do is:
  
   ouch $code, $message, $data;
   ouch -32700, 'Parse error.', $request; # JSON-RPC 2.0 error
   ouch 441, 'You need to specify an email address.', 'email'; # form processing error
   ouch 'missing_param', 'You need to specify an email address.', 'email';
  
  You can also go long form if you prefer:
  
   die Ouch->new($code, $message, $data);
  
  If you want to rethrow an Ouch, you can simply C<die> it.
  
   eval { ouch(404, 'File not found.'); } ;
   die $@;
  
  =head2 Functional Interface
  
  =head3 ouch
  
  Some nice sugar instead of using the object oriented interface.
  
   ouch 2121, 'Did not do the big thing.';
  
  =over
  
  =item code
  
  An error code. An integer or string representing error type. Try to stick to codes used in whatever domain you happen to be working in. HTTP Status codes. JSON-RPC error codes, etc.
  
  =item message
  
  A human readable error message.
  
  =item data
  
  Optional. Anything you want to attach to the exception to help a developer catching it decide what to do. For example, if you're doing form processing, you might want this to be the name of the field that caused the exception. 
  
  B<WARNING:> Do not include objects or code refs in your data. This should only be stuff that is easily serializable like scalars, array refs, and hash refs.
  
  =back
  
  =head3 kiss
  
  Some nice sugar to trap an Ouch.
  
   if (kiss $code) {
      # make it go
   }
  
  =over
  
  =item code
  
  The code you're looking for.
  
  =item exception
  
  Optional. If you like you can pass the exception into C<kiss>. If not, it will just use whatever is in C<$@>. You might want to do this if you've saved the exception before running another C<eval>, for example.
  
  =back
  
  
  =head3 hug
  
  Some nice sugar to trap any exception.
  
   if (hug) {
     # make it stop
   }
  
  =over 
  
  =item exception
  
  Optional. If you like you can pass the exception into C<hug>. If not, it will just use whatever is in C<$@>.
  
  =back
  
  
  =head3 bleep 
  
  A little sugar to make exceptions human friendly. Returns a clean error message from any exception, including an Ouch.
  
   File not found.
  
  Rather than:
  
   File not found. at /Some/File.pm line 63.
  
  =over
  
  =item exception
  
  Optional. If you like you can pass the exception into C<bleep>. If not, it will just use whatever is in C<$@>.
  
  =back
  
  =head3 barf
  
  Calls C<bleep>, and then exits with error code
  
  =over
  
  =item exception
  
  Optional. You can pass an exception into C<barf> which then gets passed to C<bleep> otherwise it will use whatever's in C<$@>
  
  =back
  
  
  =head2 Object-Oriented Interface
  
  =head3 new
  
  Constructor for the object-oriented interface. Takes the same parameters as C<ouch>.
  
   Ouch->new($code, $message, $data);
  
  =head3 scalar
  
  Returns the scalar form of the error message:
  
   Crap! at /Some/File.pm line 43.
  
  Just as if you had done:
  
   die 'Crap!';
  
  Rather than:
  
   ouch $code, 'Crap!'; 
  
  =head3 trace
  
  Call this if you want the full stack trace that lead up to the ouch.
  
  =head3 hashref
  
  Returns a formatted hash reference of the exception, which can be useful for handing off to a serializer like L<JSON>.
  
   {
     code     => $code,
     message  => $message,
     data     => $data,
   }
  
  =head3 code
  
  Returns the C<code> passed into the constructor.
  
  =head3 message
  
  Returns the C<messsage> passed into the constructor.
  
  =head3 data
  
  Returns the C<data> passed into the constructor.
  
  =head2 Try::Tiny
  
  Many Ouch users like to use Ouch with L<Try::Tiny>.
  
   use Try::Tiny;
   use Ouch;
  
   try {
      ouch 404, 'File not found!';
   }
   catch {
      if (kiss(401, $_)) {
          # do something
      }
      else {
          die $_; # rethrow
      }
   };
  
  Some users are sticks in the mud who can't bring themselves to C<ouch> and C<kiss>. For them, there is the C<:trytiny> interface. Here's how it works:
  
   use Try::Tiny;
   use Ouch qw(:trytiny);
  
   try {
      throw(404, 'File not found!';
   }
   catch {
      if (caught(401, $_)) {
          # do something
      }
      else {
          die $_; # rethrow
      }
   };
  
  =head3 throw
  
  See C<ouch> for details.
  
  =head3 caught
  
  See C<kiss> for details.
  
  =head3 caught_all
  
  See C<hug> for details.
  
  =head1 DEPRECATED
  
  This functionality is deprecated and will be removed in a future release. Use Try::Tiny instead.
  
  =head2 Traditional Interface
  
  Some people just can't bring themselves to use the sugary cuteness of Ouch. For them there is the C<:traditional> interface. Here's how it works:
  
   use Ouch qw(:traditional);
  
   my $e = try {
     throw 404, 'File not found.';
   };
  
   if ( catch 404, $e ) {
     # do the big thing
   }
   elsif ( catch_all $e ) {
     # make it stop
   }
   else {
     # make it go
   }
  
  B<NOTE:> C<try> also populates C<$@>, and C<catch> and C<catch_all> will also use C<$@> if you don't specify an exception.
  
  =head3 try
  
  Returns an exception. Is basically just a nice wrapper around C<eval>.
  
  =over
  
  =item block
  
  Try accepts a code ref, anonymous subroutine, or a block. 
  
  B<NOTE:> You need a semi-colon at the end of a C<try> block.
  
  =back
  
  =head3 throw
  
  Works exactly like C<ouch>. See C<ouch> for details.
  
  =head3 catch
  
  Works exactly like C<kiss>. See C<kiss> for details.
  
  =head3 catch_all
  
  Works exactly like C<hug>. See C<hug> for details.
  
  
  =head1 REQUIREMENTS
  
  Requires Perl 5.12 or higher.
  
  
  
  =head1 SUPPORT
  
  =over
  
  =item Repository
  
  L<http://github.com/rizen/Ouch>
  
  =item Bug Reports
  
  L<http://github.com/rizen/Ouch/issues>
  
  =back
  
  
  =head1 SEE ALSO
  
  If you're looking for something lighter, check out L<Carp> that ships with Perl. Or if you're looking for something heavier check out L<Exception::Class>.
  
  =head1 AUTHOR
  
  JT Smith <jt_at_plainblack_dot_com>
  
  =head1 LEGAL
  
  Ouch is Copyright 2011 Plain Black Corporation (L<http://www.plainblack.com>) and is licensed under the same terms as Perl itself.
  
  =cut
  
  1;
OUCH

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  our $VERSION = '0.052'; # VERSION
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 3.40 ();
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_BSD   => ( scalar $^O =~ /bsd$/ ),
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?$}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT$/ ) : ( $_[0] eq '/' );
  }
  
  # flock doesn't work on NFS on BSD.  Since program authors often can't control
  # or detect that, we warn once instead of being fatal if we can detect it and
  # people who need it strict can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use if Path::Tiny::IS_BSD(), 'warnings::register' }
  #>>>
  
  my $WARNED_BSD_NFS = 0;
  
  sub _throw {
      my ( $self, $function, $file ) = @_;
      if (   IS_BSD()
          && $function =~ /^flock/
          && $! =~ /operation not supported/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_BSD_NFS ) {
              warnings::warn( flock => "No flock for NFS on BSD: continuing in unsafe mode" );
              $WARNED_BSD_NFS++;
          }
      }
      else {
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ), $! );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  
  sub path {
      my $path = shift;
      Carp::croak("path() requires a defined, positive-length argument")
        unless defined $path && length $path;
  
      # stringify initial path
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};
          $path .= "/" if $path =~ m{^$UNC_VOL$};
      }
  
      # concatenate more arguments (stringifies any objects, too)
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize paths
      my $cpath = $path = File::Spec->canonpath($path); # ugh, but probably worth it
      $path =~ tr[\\][/] if IS_WIN32();                 # unix convention enforced
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL$}; # canonpath strips it
  
      # hack to make splitpath give us a basename; root paths must always have
      # a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?$}{/};
      }
      else {
          $path =~ s{/$}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          my ($homedir) = glob($1); # glob without list context == heisenbug!
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      # and we're finally done
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  
  sub new { shift; path(@_) }
  
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  
  sub tempfile {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # relative path on any OS
      require Cwd;
      return path( ( defined($base) ? $base : Cwd::getcwd() ), $_[0]->[PATH] );
  }
  
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, ">>", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &append }
  
  sub append_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          append( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &append;
      }
  }
  
  
  sub basename {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[FILE];
      return $self->[FILE];
  }
  
  
  sub canonpath { $_[0]->[CANON] }
  
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  }
  
  
  sub digest {
      my ( $self, $alg, @args ) = @_;
      $alg = 'SHA-256' unless defined $alg;
      require Digest;
      return Digest->new( $alg, @args )->add( $self->slurp_raw )->hexdigest;
  }
  
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -f $_[0]->[PATH] }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked/ );
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX
              $opentype = "+<";
              $lock     = Fcntl::LOCK_EX();
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( @result, $counter );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if $chomp;
              push @result, $line;
              last if ++$counter == $args->{count};
          }
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})$//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() )
          && $args->{chomp}
          && !$args->{count} )
      {
          return split /(?:\x{0d}?\x{0a}|\x{0d})/, slurp_utf8($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err} = \$err unless defined $args->{err};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst'" );
  }
  
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.$)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  
  sub realpath {
      my $self = shift;
      require Cwd;
      my $realpath = eval {
          local $SIG{__WARN__} = sub { }; # (sigh) pure-perl CWD can carp
          Cwd::realpath( $self->[PATH] );
      };
      $self->_throw("resolving realpath") unless defined $realpath and length $realpath;
      return path($realpath);
  }
  
  
  # Easy to get wrong, so wash it through File::Spec (sigh)
  sub relative { path( File::Spec->abs2rel( $_[0]->[PATH], $_[1] ) ) }
  
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink $self->[PATH] || $self->_throw('unlink');
  }
  
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err}  = \$err unless defined $args->{err};
      $args->{safe} = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $temp = path( $self->[PATH] . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      # spewing need to follow the link
      # and replace the destination instead
      my $resolved_path = $self->[PATH];
      $resolved_path = readlink $resolved_path while -l $resolved_path;
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          spew( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  
  sub stringify { $_[0]->[PATH] }
  
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|$)};
      }
  }
  
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      $epoch = defined($epoch) ? $epoch : time();
      utime $epoch, $epoch, $self->[PATH]
        or $self->_throw("utime ($epoch)");
      return $self;
  }
  
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.052
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    $head = $file->lines( {count => 1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module attempts to provide a small, fast utility for working with
  file paths.  It is friendlier to use than L<File::Spec> and provides
  easy access to functions from several other core file handling modules.
  
  It doesn't attempt to be as full-featured as L<IO::All> or L<Path::Class>,
  nor does it try to work for anything except Unix-like and Win32 platforms.
  Even then, it might break if you try something particularly obscure or
  tortuous.  (Quick!  What does this mean: C<< ///../../..//./././a//b/.././c/././ >>?
  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode without CRLF translation.  Installing L<Unicode::UTF8> 0.58 or later
  will speed up several of them and is highly recommended.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  Unless an argument is given, the current directory is used as the
  absolute base path.  The argument must be absolute or you won't get an absolute
  result.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<binmode()> on the handle used for writing.
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  append will be done instead on the data encoded with C<Unicode::UTF8>.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename; # bar.txt
  
  Returns the file portion or last directory portion of a path.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt$/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies a file using L<File::Copy>'s C<copy> function.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  
  Returns a hexadecimal digest for a file.  Any arguments are passed to the
  constructor for L<Digest> to select an algorithm.  If no arguments are given,
  the default is SHA-256.
  
  =head2 dirname
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory name portion of the path.  This is roughly
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually has the trailing slash. If that's not desired, stringify directories
  or call C<parent> on files.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }
      if ( path("/tmp")->is_file ) { ... }
      if ( path("/tmp")->is_dir ) { ... }
  
  Just like C<-e>, C<-f> or C<-d>.  This means the file or directory actually has to
  exist on the filesystem.  Until then, it's just a path.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", "<<", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked with C<LOCK_SH>.  When using
  C<locked>, ">" or "+>" modes will delay truncation until after the lock is
  acquired.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.  If C<binmode>
  is provided, it will be set on the handle prior to reading.  If C<count> is
  provided, up to that many lines will be returned. If C<chomp> is set, any
  end-of-line character sequences (C<CR>, C<CRLF>, or C<LF>) will be removed
  from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of
  C<:raw:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Just like C<rename>.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the path can't be resolved (e.g. if it includes directories that don't exist),
  an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a relative path name.
  Given the trickiness of this, it's a thin wrapper around
  C<< File::Spec->abs2rel() >>.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  B<Note: as of 0.012, remove only works on files>.
  
  This is just like C<unlink>, except if the path does not exist, it returns
  false rather than throwing an exception.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference may be
  used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  slurp will be done instead and the result decoded with C<Unicode::UTF8>.
  This is just as strict and is roughly an order of magnitude faster than
  using C<:encoding(UTF-8)>.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>.
  If L<Unicode::UTF8> 0.58+ is installed, a raw spew will be done instead on
  the data encoded with C<Unicode::UTF8>.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with spew:
  
      path("foo.txt")->touch->spew( $content );
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_BSD IS_WIN32
  
  =head1 EXCEPTION HANDLING
  
  Failures will be thrown as exceptions in the class C<Path::Tiny::Error>.
  
  The object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op> — a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file> — the file or directory relating to the error
  
  =item *
  
  C<err> — hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg> — a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 CAVEATS
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  Path::Tiny has some heuristics to detect this
  and will warn once and let you continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  Consider L<PerlIO::utf8_strict> for a faster L<PerlIO> layer alternative to
  C<:encoding(UTF-8)>, though it does not appear to be as fast as the
  C<Unicode::UTF8> approach.
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
  김도형 - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Reply/Plugin/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REPLY_PLUGIN_TYPETINY';
  package Reply::Plugin::TypeTiny;
  
  use strict;
  use warnings;
  
  BEGIN {
  	$Reply::Plugin::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Reply::Plugin::TypeTiny::VERSION   = '0.038';
  };
  
  require Reply::Plugin;
  our @ISA = 'Reply::Plugin';
  
  use Scalar::Util qw(blessed);
  use Term::ANSIColor;
  
  sub mangle_error {
  	my $self  = shift;
  	my ($err) = @_;
  	
  	if (blessed $err and $err->isa("Error::TypeTiny::Assertion"))
  	{
  		my $explain = $err->explain;
  		if ($explain)
  		{
  			print color("cyan");
  			print "Error::TypeTiny::Assertion explain:\n";
  			$self->_explanation($explain, "");
  			local $| = 1;
  			print "\n";
  			print color("reset");
  		}
  	}
  	
  	return @_;
  }
  
  sub _explanation
  {
  	my $self = shift;
  	my ($ex, $indent)  = @_;
  	
  	for my $line (@$ex)
  	{
  		if (ref($line) eq q(ARRAY))
  		{
  			print "$indent * Explain:\n";
  			$self->_explanation($line, "$indent   ");
  		}
  		else
  		{
  			print "$indent * $line\n";
  		}
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Reply::Plugin::TypeTiny - improved type constraint exceptions in Reply
  
  =head1 STATUS
  
  This module is not covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is a small plugin to improve error messages in L<Reply>.
  Not massively tested.
  
  =begin trustme
  
  =item mangle_error
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>, L<Reply>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
REPLY_PLUGIN_TYPETINY

$fatpacked{"SHARYANTO/String/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SHARYANTO_STRING_UTIL';
  package SHARYANTO::String::Util;
  
  use 5.010001;
  use strict;
  use warnings;
  
  our $VERSION = '0.26'; # VERSION
  
  use Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(
                         ltrim
                         rtrim
                         trim
                         ltrim_lines
                         rtrim_lines
                         trim_lines
                         trim_blank_lines
                         ellipsis
                         indent
                         linenum
                         pad
                         qqquote
                 );
  
  sub ltrim {
      my $str = shift;
      $str =~ s/\A\s+//s;
      $str;
  }
  
  sub rtrim {
      my $str = shift;
      $str =~ s/\s+\z//s;
      $str;
  }
  
  sub trim {
      my $str = shift;
      $str =~ s/\A\s+//s;
      $str =~ s/\s+\z//s;
      $str;
  }
  
  sub ltrim_lines {
      my $str = shift;
      $str =~ s/^[ \t]+//mg; # XXX other unicode non-newline spaces
      $str;
  }
  
  sub rtrim_lines {
      my $str = shift;
      $str =~ s/[ \t]+$//mg;
      $str;
  }
  
  sub trim_lines {
      my $str = shift;
      $str =~ s/^[ \t]+//mg;
      $str =~ s/[ \t]+$//mg;
      $str;
  }
  
  sub trim_blank_lines {
      local $_ = shift;
      return $_ unless defined;
      s/\A(?:\n\s*)+//;
      s/(?:\n\s*){2,}\z/\n/;
      $_;
  }
  
  sub ellipsis {
      my ($str, $maxlen, $ellipsis) = @_;
      $maxlen   //= 80;
      $ellipsis //= "...";
  
      if (length($str) <= $maxlen) {
          return $str;
      } else {
          return substr($str, 0, $maxlen-length($ellipsis)) . $ellipsis;
      }
  }
  
  sub indent {
      my ($indent, $str, $opts) = @_;
      $opts //= {};
  
      if ($opts->{indent_blank_lines} // 1) {
          $str =~ s/^/$indent/mg;
      } else {
          $str =~ s/^([^\r\n]*\S[^\r\n]*)/$indent$1/mg;
      }
      $str;
  }
  
  sub linenum {
      my ($str, $opts) = @_;
      $opts //= {};
      $opts->{width}      //= 4;
      $opts->{zeropad}    //= 0;
      $opts->{skip_empty} //= 1;
  
      my $i = 0;
      $str =~ s/^(([\t ]*\S)?.*)/
          sprintf(join("",
                       "%",
                       ($opts->{zeropad} && !($opts->{skip_empty}
                                                  && !defined($2)) ? "0" : ""),
                       $opts->{width}, "s",
                       "|%s"),
                  ++$i && $opts->{skip_empty} && !defined($2) ? "" : $i,
                  $1)/meg;
  
      $str;
  }
  
  sub pad {
      my ($text, $width, $which, $padchar, $is_trunc) = @_;
      if ($which) {
          $which = substr($which, 0, 1);
      } else {
          $which = "r";
      }
      $padchar //= " ";
  
      my $w = length($text);
      if ($is_trunc && $w > $width) {
          $text = substr($text, 0, $width, 1);
      } else {
          if ($which eq 'l') {
              $text = ($padchar x ($width-$w)) . $text;
          } elsif ($which eq 'c') {
              my $n = int(($width-$w)/2);
              $text = ($padchar x $n) . $text . ($padchar x ($width-$w-$n));
          } else {
              $text .= ($padchar x ($width-$w));
          }
      }
      $text;
  }
  
  # BEGIN COPY PASTE FROM Data::Dump
  my %esc = (
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  # put a string value in double quotes
  sub qqquote {
    local($_) = $_[0];
    # If there are many '"' we might want to use qq() instead
    s/([\\\"\@\$])/\\$1/g;
    return qq("$_") unless /[^\040-\176]/;  # fast exit
  
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    # no need for 3 digits in escape for these
    s/([\0-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
    s/([\0-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
    s/([^\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
    return qq("$_");
  }
  # END COPY PASTE FROM Data::Dump
  
  1;
  # ABSTRACT: String utilities
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  SHARYANTO::String::Util - String utilities
  
  =head1 DESCRIPTION
  
  =head1 FUNCTIONS
  
  =head2 ltrim($str) => STR
  
  Trim whitespaces (including newlines) at the beginning of string. Equivalent to:
  
   $str =~ s/\A\s+//s;
  
  =head2 ltrim_lines($str) => STR
  
  Trim whitespaces (not including newlines) at the beginning of each line of
  string. Equivalent to:
  
   $str =~ s/^\s+//mg;
  
  =head2 rtrim($str) => STR
  
  Trim whitespaces (including newlines) at the end of string. Equivalent to:
  
   $str =~ s/[ \t]+\z//s;
  
  =head2 rtrim_lines($str) => STR
  
  Trim whitespaces (not including newlines) at the end of each line of
  string. Equivalent to:
  
   $str =~ s/[ \t]+$//mg;
  
  =head2 trim($str) => STR
  
  ltrim + rtrim.
  
  =head2 trim_lines($str) => STR
  
  ltrim_lines + rtrim_lines.
  
  =head2 trim_blank_lines($str) => STR
  
  Trim blank lines at the beginning and the end. Won't trim blank lines in the
  middle. Blank lines include lines with only whitespaces in them.
  
  =head2 ellipsis($str[, $maxlen, $ellipsis]) => STR
  
  Return $str unmodified if $str's length is less than $maxlen (default 80).
  Otherwise cut $str to ($maxlen - length($ellipsis)) and append $ellipsis
  (default '...') at the end.
  
  =head2 indent($indent, $str, \%opts) => STR
  
  Indent every line in $str with $indent. Example:
  
   indent('  ', "one\ntwo\nthree") # "  one\n  two\n  three"
  
  %opts is optional. Known options:
  
  =over 4
  
  =item * indent_blank_lines => BOOL (default 1)
  
  If set to false, does not indent blank lines (i.e., lines containing only zero
  or more whitespaces).
  
  =back
  
  =head2 linenum($str, \%opts) => STR
  
  Add line numbers. For example:
  
       1|line1
       2|line2
        |
       4|line4
  
  Known options:
  
  =over 4
  
  =item * width => INT (default: 4)
  
  =item * zeropad => BOOL (default: 0)
  
  If turned on, will output something like:
  
    0001|line1
    0002|line2
        |
    0004|line4
  
  =item * skip_empty => BOOL (default: 1)
  
  If set to false, keep printing line number even if line is empty:
  
       1|line1
       2|line2
       3|
       4|line4
  
  =back
  
  =head2 pad($text, $width[, $which[, $padchar[, $truncate]]]) => STR
  
  Return C<$text> padded with C<$padchar> to C<$width> columns. C<$which> is
  either "r" or "right" for padding on the right (the default if not specified),
  "l" or "left" for padding on the right, or "c" or "center" or "centre" for
  left+right padding to center the text.
  
  C<$padchar> is whitespace if not specified. It should be string having the width
  of 1 column.
  
  =head2 qqquote($str) => STR
  
  Quote or encode C<$str> to the Perl double quote (C<qq>) literal representation
  of the string. Example:
  
   say qqquote("a");        # => "a"
   say qqquote("a\n");      # => "a\n"
   say qqquote('"');        # => "\""
   say qqquote('$foo');     # => "\$foo"
  
  This code is taken from C<quote()> in L<Data::Dump>. Maybe I didn't look more
  closely, but I couldn't a module that provides a function to do something like
  this. L<String::Escape>, for example, provides C<qqbackslash> but it does not
  escape C<$>.
  
  
  None are exported by default, but they are exportable.
  
  =head1 SEE ALSO
  
  L<SHARYANTO>
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/SHARYANTO-String-Util>.
  
  =head1 SOURCE
  
  Source repository is at L<HASH(0x353ed90)>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website
  https://rt.cpan.org/Public/Dist/Display.html?Name=SHARYANTO-String-Util
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SHARYANTO_STRING_UTIL

$fatpacked{"Sort/Naturally.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SORT_NATURALLY';
  
  require 5;
  package Sort::Naturally;  # Time-stamp: "2004-12-29 18:30:03 AST"
  $VERSION = '1.03';
  @EXPORT = ('nsort', 'ncmp');
  require Exporter;
  @ISA = ('Exporter');
  
  use strict;
  use locale;
  use integer;
  
  #-----------------------------------------------------------------------------
  # constants:
  BEGIN { *DEBUG = sub () {0} unless defined &DEBUG }
  
  use Config ();
  BEGIN {
    # Make a constant such that if a whole-number string is that long
    #  or shorter, we KNOW it's treatable as an integer
    no integer;
    my $x = length(256 ** $Config::Config{'intsize'} / 2) - 1;
    die "Crazy intsize: <$Config::Config{'intsize'}>" if $x < 4;
    eval 'sub MAX_INT_SIZE () {' . $x . '}';
    die $@ if $@;
    print "intsize $Config::Config{'intsize'} => MAX_INT_SIZE $x\n" if DEBUG;
  }
  
  sub X_FIRST () {-1}
  sub Y_FIRST () { 1}
  
  my @ORD = ('same', 'swap', 'asis');
  
  #-----------------------------------------------------------------------------
  # For lack of a preprocessor:
  
  my($code, $guts);
  $guts = <<'EOGUTS';  # This is the guts of both ncmp and nsort:
  
      if($x eq $y) {
        # trap this expensive case first, and then fall thru to tiebreaker
        $rv = 0;
  
      # Convoluted hack to get numerics to sort first, at string start:
      } elsif($x =~ m/^\d/s) {
        if($y =~ m/^\d/s) {
          $rv = 0;    # fall thru to normal comparison for the two numbers
        } else {
          $rv = X_FIRST;
          DEBUG > 1 and print "Numeric-initial $x trumps letter-initial $y\n";
        }
      } elsif($y =~ m/^\d/s) {
        $rv = Y_FIRST;
        DEBUG > 1 and print "Numeric-initial $y trumps letter-initial $x\n";
      } else {
        $rv = 0;
      }
  
      unless($rv) {
        # Normal case:
        $rv = 0;
        DEBUG and print "<$x> and <$y> compared...\n";
  
       Consideration:
        while(length $x and length $y) {
  
          DEBUG > 2 and print " <$x> and <$y>...\n";
  
          # First, non-numeric comparison:
          $x2 = ($x =~ m/^(\D+)/s) ? length($1) : 0;
          $y2 = ($y =~ m/^(\D+)/s) ? length($1) : 0;
          # Now make x2 the min length of the two:
          $x2 = $y2 if $x2 > $y2;
          if($x2) {
            DEBUG > 1 and printf " <%s> and <%s> lexically for length $x2...\n",
              substr($x,0,$x2), substr($y,0,$x2);
            do {
             my $i = substr($x,0,$x2);
             my $j = substr($y,0,$x2);
             my $sv = $i cmp $j;
             print "SCREAM! on <$i><$j> -- $sv != $rv \n" unless $rv == $sv;
             last;
            }
  
  
             if $rv =
             # The ''. things here force a copy that seems to work around a
             #  mysterious intermittent bug that 'use locale' provokes in
             #  many versions of Perl.
                     $cmp
                     ? $cmp->(substr($x,0,$x2) . '',
                              substr($y,0,$x2) . '',
                             )
                     :
                     scalar(( substr($x,0,$x2) . '' ) cmp
                            ( substr($y,0,$x2) . '' )
                            )
            ;
            # otherwise trim and keep going:
            substr($x,0,$x2) = '';
            substr($y,0,$x2) = '';
          }
  
          # Now numeric:
          #  (actually just using $x2 and $y2 as scratch)
  
          if( $x =~ s/^(\d+)//s ) {
            $x2 = $1;
            if( $y =~ s/^(\d+)//s ) {
              # We have two numbers here.
              DEBUG > 1 and print " <$x2> and <$1> numerically\n";
              if(length($x2) < MAX_INT_SIZE and length($1) < MAX_INT_SIZE) {
                # small numbers: we can compare happily
                last if $rv = $x2 <=> $1;
              } else {
                # ARBITRARILY large integers!
  
                # This saves on loss of precision that could happen
                #  with actual stringification.
                # Also, I sense that very large numbers aren't too
                #  terribly common in sort data.
  
                # trim leading 0's:
                ($y2 = $1) =~ s/^0+//s;
                $x2 =~ s/^0+//s;
                print "   Treating $x2 and $y2 as bigint\n" if DEBUG;
  
                no locale; # we want the dumb cmp back.
                last if $rv = (
                   # works only for non-negative whole numbers:
                   length($x2) <=> length($y2)
                     # the longer the numeral, the larger the value
                   or $x2 cmp $y2
                     # between equals, compare lexically!!  amazing but true.
                );
              }
            } else {
              # X is numeric but Y isn't
              $rv = Y_FIRST;
              last;
            }
          } elsif( $y =~ s/^\d+//s ) {  # we don't need to capture the substring
            $rv = X_FIRST;
            last;
          }
           # else one of them is 0-length.
  
         # end-while
        }
      }
  EOGUTS
  
  sub maker {
    my $code = $_[0];
    $code =~ s/~COMPARATOR~/$guts/g || die "Can't find ~COMPARATOR~";
    eval $code;
    die $@ if $@;
  }
  
  ##############################################################################
  
  maker(<<'EONSORT');
  sub nsort {
    # get options:
    my($cmp, $lc);
    ($cmp,$lc) = @{shift @_} if @_ and ref($_[0]) eq 'ARRAY';
  
    return @_ unless @_ > 1 or wantarray; # be clever
  
    my($x, $x2, $y, $y2, $rv);  # scratch vars
  
    # We use a Schwartzian xform to memoize the lc'ing and \W-removal
  
    map $_->[0],
    sort {
      if($a->[0] eq $b->[0]) { 0 }   # trap this expensive case
      else {
  
      $x = $a->[1];
      $y = $b->[1];
  
  ~COMPARATOR~
  
      # Tiebreakers...
      DEBUG > 1 and print " -<${$a}[0]> cmp <${$b}[0]> is $rv ($ORD[$rv])\n";
      $rv ||= (length($x) <=> length($y))  # shorter is always first
          ||  ($cmp and $cmp->($x,$y) || $cmp->($a->[0], $b->[0]))
          ||  ($x      cmp $y     )
          ||  ($a->[0] cmp $b->[0])
      ;
  
      DEBUG > 1 and print "  <${$a}[0]> cmp <${$b}[0]> is $rv ($ORD[$rv])\n";
      $rv;
    }}
  
    map {;
      $x = $lc ? $lc->($_) : lc($_); # x as scratch
      $x =~ s/\W+//s;
      [$_, $x];
    }
    @_
  }
  EONSORT
  
  #-----------------------------------------------------------------------------
  maker(<<'EONCMP');
  sub ncmp {
    # The guts are basically the same as above...
  
    # get options:
    my($cmp, $lc);
    ($cmp,$lc) = @{shift @_} if @_ and ref($_[0]) eq 'ARRAY';
  
    if(@_ == 0) {
      @_ = ($a, $b); # bit of a hack!
      DEBUG > 1 and print "Hacking in <$a><$b>\n";
    } elsif(@_ != 2) {
      require Carp;
      Carp::croak("Not enough options to ncmp!");
    }
    my($a,$b) = @_;
    my($x, $x2, $y, $y2, $rv);  # scratch vars
  
    DEBUG > 1 and print "ncmp args <$a><$b>\n";
    if($a eq $b) { # trap this expensive case
      0;
    } else {
      $x = ($lc ? $lc->($a) : lc($a));
      $x =~ s/\W+//s;
      $y = ($lc ? $lc->($b) : lc($b));
      $y =~ s/\W+//s;
  
  ~COMPARATOR~
  
  
      # Tiebreakers...
      DEBUG > 1 and print " -<$a> cmp <$b> is $rv ($ORD[$rv])\n";
      $rv ||= (length($x) <=> length($y))  # shorter is always first
          ||  ($cmp and $cmp->($x,$y) || $cmp->($a,$b))
          ||  ($x cmp $y)
          ||  ($a cmp $b)
      ;
  
      DEBUG > 1 and print "  <$a> cmp <$b> is $rv\n";
      $rv;
    }
  }
  EONCMP
  
  # clean up:
  undef $guts;
  undef &maker;
  
  #-----------------------------------------------------------------------------
  1;
  
  ############### END OF MAIN SOURCE ###########################################
  __END__
  
  =head1 NAME
  
  Sort::Naturally -- sort lexically, but sort numeral parts numerically
  
  =head1 SYNOPSIS
  
    @them = nsort(qw(
     foo12a foo12z foo13a foo 14 9x foo12 fooa foolio Foolio Foo12a
    ));
    print join(' ', @them), "\n";
  
  Prints:
  
    9x 14 foo fooa foolio Foolio foo12 foo12a Foo12a foo12z foo13a
  
  (Or "foo12a" + "Foo12a" and "foolio" + "Foolio" and might be
  switched, depending on your locale.)
  
  =head1 DESCRIPTION
  
  This module exports two functions, C<nsort> and C<ncmp>; they are used
  in implementing my idea of a "natural sorting" algorithm.  Under natural
  sorting, numeric substrings are compared numerically, and other
  word-characters are compared lexically.
  
  This is the way I define natural sorting:
  
  =over
  
  =item *
  
  Non-numeric word-character substrings are sorted lexically,
  case-insensitively: "Foo" comes between "fish" and "fowl".
  
  =item *
  
  Numeric substrings are sorted numerically:
  "100" comes after "20", not before.
  
  =item *
  
  \W substrings (neither words-characters nor digits) are I<ignored>.
  
  =item *
  
  Our use of \w, \d, \D, and \W is locale-sensitive:  Sort::Naturally
  uses a C<use locale> statement.
  
  =item *
  
  When comparing two strings, where a numeric substring in one
  place is I<not> up against a numeric substring in another,
  the non-numeric always comes first.  This is fudged by
  reading pretending that the lack of a number substring has
  the value -1, like so:
  
    foo       =>  "foo",  -1
    foobar    =>  "foo",  -1,  "bar"
    foo13     =>  "foo",  13,
    foo13xyz  =>  "foo",  13,  "xyz"
  
  That's so that "foo" will come before "foo13", which will come
  before "foobar".
  
  =item *
  
  The start of a string is exceptional: leading non-\W (non-word,
  non-digit)
  components are are ignored, and numbers come I<before> letters.
  
  =item *
  
  I define "numeric substring" just as sequences matching m/\d+/ --
  scientific notation, commas, decimals, etc., are not seen.  If
  your data has thousands separators in numbers
  ("20,000 Leagues Under The Sea" or "20.000 lieues sous les mers"),
  consider stripping them before feeding them to C<nsort> or
  C<ncmp>.
  
  =back
  
  =head2 The nsort function
  
  This function takes a list of strings, and returns a copy of the list,
  sorted.
  
  This is what most people will want to use:
  
    @stuff = nsort(...list...);
  
  When nsort needs to compare non-numeric substrings, it
  uses Perl's C<lc> function in scope of a <use locale>.
  And when nsort needs to lowercase things, it uses Perl's
  C<lc> function in scope of a <use locale>.  If you want nsort
  to use other functions instead, you can specify them in
  an arrayref as the first argument to nsort:
  
    @stuff = nsort( [
                      \&string_comparator,   # optional
                      \&lowercaser_function  # optional
                    ],
                    ...list...
                  );
  
  If you want to specify a string comparator but no lowercaser,
  then the options list is C<[\&comparator, '']> or
  C<[\&comparator]>.  If you want to specify no string comparator
  but a lowercaser, then the options list is
  C<['', \&lowercaser]>.
  
  Any comparator you specify is called as
  C<$comparator-E<gt>($left, $right)>,
  and, like a normal Perl C<cmp> replacement, must return
  -1, 0, or 1 depending on whether the left argument is stringwise
  less than, equal to, or greater than the right argument.
  
  Any lowercaser function you specify is called as
  C<$lowercased = $lowercaser-E<gt>($original)>.  The routine
  must not modify its C<$_[0]>.
  
  =head2 The ncmp function
  
  Often, when sorting non-string values like this:
  
     @objects_sorted = sort { $a->tag cmp $b->tag } @objects;
  
  ...or even in a Schwartzian transform, like this:
  
     @strings =
       map $_->[0]
       sort { $a->[1] cmp $b->[1] }
       map { [$_, make_a_sort_key_from($_) ]
       @_
     ;
  
  ...you wight want something that replaces not C<sort>, but C<cmp>.
  That's what Sort::Naturally's C<ncmp> function is for.  Call it with
  the syntax C<ncmp($left,$right)> instead of C<$left cmp $right>,
  but otherwise it's a fine replacement:
  
     @objects_sorted = sort { ncmp($a->tag,$b->tag) } @objects;
  
     @strings =
       map $_->[0]
       sort { ncmp($a->[1], $b->[1]) }
       map { [$_, make_a_sort_key_from($_) ]
       @_
     ;
  
  Just as with C<nsort> can take different a string-comparator
  and/or lowercaser, you can do the same with C<ncmp>, by passing
  an arrayref as the first argument:
  
    ncmp( [
            \&string_comparator,   # optional
            \&lowercaser_function  # optional
          ],
          $left, $right
        )
  
  You might get string comparators from L<Sort::ArbBiLex|Sort::ArbBiLex>.
  
  =head1 NOTES
  
  =over
  
  =item *
  
  This module is not a substitute for
  L<Sort::Versions|Sort::Versions>!  If
  you just need proper version sorting, use I<that!>
  
  =item *
  
  If you need something that works I<sort of> like this module's
  functions, but not quite the same, consider scouting thru this
  module's source code, and adapting what you see.  Besides
  the functions that actually compile in this module, after the POD,
  there's several alternate attempts of mine at natural sorting
  routines, which are not compiled as part of the module, but which you
  might find useful.  They should all be I<working> implementations of
  slightly different algorithms
  (all of them based on Martin Pool's C<nsort>) which I eventually
  discarded in favor of my algorithm.  If you are having to
  naturally-sort I<very large> data sets, and sorting is getting
  ridiculously slow, you might consider trying one of those
  discarded functions -- I have a feeling they might be faster on
  large data sets.  Benchmark them on your data and see.  (Unless
  you I<need> the speed, don't bother.  Hint: substitute C<sort>
  for C<nsort> in your code, and unless your program speeds up
  drastically, it's not the sorting that's slowing things down.
  But if it I<is> C<nsort> that's slowing things down, consider
  just:
  
        if(@set >= SOME_VERY_BIG_NUMBER) {
          no locale; # vroom vroom
          @sorted = sort(@set);  # feh, good enough
        } elsif(@set >= SOME_BIG_NUMBER) {
          use locale;
          @sorted = sort(@set);  # feh, good enough
        } else {
          # but keep it pretty for normal cases
          @sorted = nsort(@set);
        }
  
  =item *
  
  If you do adapt the routines in this module, email me; I'd
  just be interested in hearing about it.
  
  =item *
  
  Thanks to the EFNet #perl people for encouraging this module,
  especially magister and a-mused.
  
  =back
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  Copyright 2001, Sean M. Burke C<sburke@cpan.org>, all rights
  reserved.  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Sean M. Burke C<sburke@cpan.org>
  
  =cut
  
  ############   END OF DOCS   ############
  
  ############################################################################
  ############################################################################
  
  ############ BEGIN OLD STUFF ############
  
  # We can't have "use integer;", or else (5 <=> 5.1) comes out "0" !
  
  #-----------------------------------------------------------------------------
  sub nsort {
    my($cmp, $lc);
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      if($x =~ m/^[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee](?:[+-]?\d+))?\z/s) {
        # It's entirely purely numeric, so treat it specially:
        push @bit, '', $x;
      } else {
        # Consume the string.
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          push @bit, ($x =~ s/^(\d+)//s) ?    $1  :  0;
        }
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      # End result: [original bit         , (text, number), (text, number), ...]
      # Minimally:  [0-length original bit,]
      # Examples:
      #    ['10'         => ''   ,  10,              ]
      #    ['fo900'      => 'fo' , 900,              ]
      #    ['foo10'      => 'foo',  10,              ]
      #    ['foo9.pl'    => 'foo',   9,   , '.pl', 0 ]
      #    ['foo32.pl'   => 'foo',  32,   , '.pl', 0 ]
      #    ['foo325.pl'  => 'foo', 325,   , '.pl', 0 ]
      #  Yes, always an ODD number of elements.
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Same as before, except without the pure-number trap.
  
  sub nsorts {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      while(length $x) {
        push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
        push @bit, ($x =~ s/^(\d+)//s) ?    $1  :  0;
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      # End result: [original bit         , (text, number), (text, number), ...]
      # Minimally:  [0-length original bit,]
      # Examples:
      #    ['10'         => ''   ,  10,              ]
      #    ['fo900'      => 'fo' , 900,              ]
      #    ['foo10'      => 'foo',  10,              ]
      #    ['foo9.pl'    => 'foo',   9,   , '.pl', 0 ]
      #    ['foo32.pl'   => 'foo',  32,   , '.pl', 0 ]
      #    ['foo325.pl'  => 'foo', 325,   , '.pl', 0 ]
      #  Yes, always an ODD number of elements.
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Same as before, except for the sort-key-making
  
  sub nsort0 {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      if($x =~ m/^[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee](?:[+-]?\d+))?\z/s) {
        # It's entirely purely numeric, so treat it specially:
        push @bit, '', $x;
      } else {
        # Consume the string.
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          # Secret sauce:
          if($x =~ s/^(\d+)//s) {
            if(substr($1,0,1) eq '0' and $1 != 0) {
              push @bit, $1 / (10 ** length($1));
            } else {
              push @bit, $1;
            }
          } else {
            push @bit, 0;
          }
        }
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Like nsort0, but WITHOUT pure number handling, and WITH special treatment
  # of pulling off extensions and version numbers.
  
  sub nsortf {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 3;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a     <=> @$b    ) || ($a->[1] cmp $b->[1])
         || ($a->[2] <=> $b->[2]) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use the
        #  lc'd extension, otherwise the verison, otherwise use
        #  the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ( ($x = defined($_) ? $_ : ''), '',0 );
  
      {
        # Consume the string.
  
        # First, pull off any VAX-style version
        $bit[2] = $1 if $x =~ s/;(\d+)$//;
  
        # Then pull off any apparent extension
        if( $x !~ m/^\.+$/s and     # don't mangle ".", "..", or "..."
            $x =~ s/(\.[^\.\;]*)$//sg
            # We could try to avoid catching all-digit extensions,
            #  but I think that's getting /too/ clever.
        ) {
          $i = $1;
          if($x =~ m<[^\\\://]$>s) {
            # We didn't take the whole basename.
            $bit[1] = lc $i;
            DEBUG and print "Consuming extension \"$1\"\n";
          } else {
            # We DID take the whole basename.  Fix it.
            $x = $1;  # Repair it.
          }
        }
  
        push @bit, '', -1   if $x =~ m/^\./s;
         # A hack to make .-initial filenames sort first, regardless of locale.
         # And -1 is always a sort-firster, since in the code below, there's
         # no allowance for filenames containing negative numbers: -1.dat
         # will be read as string '-' followed by number 1.
  
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          # Secret sauce:
          if($x =~ s/^(\d+)//s) {
            if(substr($1,0,1) eq '0' and $1 != 0) {
              push @bit, $1 / (10 ** length($1));
            } else {
              push @bit, $1;
            }
          } else {
            push @bit, 0;
          }
        }
      }
  
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      \@bit;
    }
    @_;
  }
  
  # yowza yowza yowza.
  
SORT_NATURALLY

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_Utils;
  use Scalar::Util qw(weaken);
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    weaken($DEFERRED{$made} = $DEFERRED{$deferred});
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    $DEFERRED{$deferred||''};
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_info;
    my $deferred = sub {
      $undeferred ||= undefer_sub($deferred_info->[3]);
      goto &$undeferred;
    };
    $deferred_info = [ $target, $maker, \$undeferred, $deferred ];
    weaken($DEFERRED{$deferred} = $deferred_info);
    _install_coderef($target => $deferred) if defined $target;
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map { defined $_ ? ($_->[3] => $_) : () } values %DEFERRED;
    weaken($_) for values %DEFERRED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all defered subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001011';
  
  use Carp ();
  use List::Util ();
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if (List::Util::first { ref || !m/ \A [:-]? \w+ \z /xm } @args) {
           Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif (defined(my $num = List::Util::first { !ref and m/^\d/ } @args)) {
           die "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ($setup eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              Carp::croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              Carp::croak $too_complicated if List::Util::first { ref } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 Carp::croak $too_complicated if List::Util::first { / \A - (?! all \b ) /x || ref } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              Carp::croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        Carp::croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 AUTHOR
  
  frew - Arthur Axel Schmidt (cpan:FREW) <frioux+cpan@gmail.com>
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Sub::Exporter::Progressive L</AUTHOR> and
  L</CONTRIBUTORS> as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  use strictures 1;
  
  sub _clean_eval { eval $_[0] }
  
  use Sub::Defer;
  use B 'perlstring';
  use Scalar::Util qw(weaken);
  use base qw(Exporter);
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub);
  
  our %QUOTED;
  
  our %WEAK_REFS;
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    my $assign = '';
    if (my ($code_args) = $code =~ /^\s*my\s*\(([^)]+)\)\s*=\s*\@_;$/s) {
      if ($code_args ne $args) {
        $assign = 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $assign = ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$assign.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my ($package, $hints, $bitmask, $hintshash) = (caller(0))[0,8,9,10];
    my $context
      ="package $package;\n"
      ."BEGIN {\n"
      ."  \$^H = ".B::perlstring($hints).";\n"
      ."  \${^WARNING_BITS} = ".B::perlstring($bitmask).";\n"
      ."  \%^H = (\n"
      . join('', map
       "    ".B::perlstring($_)." => ".B::perlstring($hintshash->{$_}).",",
        keys %$hintshash)
      ."  );\n"
      ."}\n";
    $code = "$context$code";
    my $quoted_info;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      unquote_sub($quoted_info->[4]);
    };
    $quoted_info = [ $name, $code, $captures, undef, $deferred ];
    weaken($QUOTED{$deferred} = $quoted_info);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    $QUOTED{$sub||''};
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    unless ($QUOTED{$sub}[3]) {
      my ($name, $code, $captures) = @{$QUOTED{$sub}};
  
      my $make_sub = "{\n";
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_QUOTED'} = \$QUOTED{$sub};
      $make_sub .= capture_unroll("\$_[1]", \%captures, 2);
  
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$_QUOTED->[3] = sub {\n"
      );
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$_QUOTED->[3] = \\&${name}\n";
      }
      $make_sub .= "}\n1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{$name} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          die "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
      }
    }
    $QUOTED{$sub}[3];
  }
  
  sub CLONE {
    %QUOTED = map { defined $_ ? ($_->[4] => $_) : () } values %QUOTED;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   };
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few caveats
  apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_QUOTE

$fatpacked{"Term/ReadLine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_READLINE';
  =head1 NAME
  
  Term::ReadLine - Perl interface to various C<readline> packages.
  If no real package is found, substitutes stubs instead of basic functions.
  
  =head1 SYNOPSIS
  
    use Term::ReadLine;
    my $term = Term::ReadLine->new('Simple Perl calc');
    my $prompt = "Enter your arithmetic expression: ";
    my $OUT = $term->OUT || \*STDOUT;
    while ( defined ($_ = $term->readline($prompt)) ) {
      my $res = eval($_);
      warn $@ if $@;
      print $OUT $res, "\n" unless $@;
      $term->addhistory($_) if /\S/;
    }
  
  =head1 DESCRIPTION
  
  This package is just a front end to some other packages. It's a stub to
  set up a common interface to the various ReadLine implementations found on
  CPAN (under the C<Term::ReadLine::*> namespace).
  
  =head1 Minimal set of supported functions
  
  All the supported functions should be called as methods, i.e., either as 
  
    $term = Term::ReadLine->new('name');
  
  or as 
  
    $term->addhistory('row');
  
  where $term is a return value of Term::ReadLine-E<gt>new().
  
  =over 12
  
  =item C<ReadLine>
  
  returns the actual package that executes the commands. Among possible
  values are C<Term::ReadLine::Gnu>, C<Term::ReadLine::Perl>,
  C<Term::ReadLine::Stub>.
  
  =item C<new>
  
  returns the handle for subsequent calls to following
  functions. Argument is the name of the application. Optionally can be
  followed by two arguments for C<IN> and C<OUT> filehandles. These
  arguments should be globs.
  
  =item C<readline>
  
  gets an input line, I<possibly> with actual C<readline>
  support. Trailing newline is removed. Returns C<undef> on C<EOF>.
  
  =item C<addhistory>
  
  adds the line to the history of input, from where it can be used if
  the actual C<readline> is present.
  
  =item C<IN>, C<OUT>
  
  return the filehandles for input and output or C<undef> if C<readline>
  input and output cannot be used for Perl.
  
  =item C<MinLine>
  
  If argument is specified, it is an advice on minimal size of line to
  be included into history.  C<undef> means do not include anything into
  history. Returns the old value.
  
  =item C<findConsole>
  
  returns an array with two strings that give most appropriate names for
  files for input and output using conventions C<"E<lt>$in">, C<"E<gt>out">.
  
  =item Attribs
  
  returns a reference to a hash which describes internal configuration
  of the package. Names of keys in this hash conform to standard
  conventions with the leading C<rl_> stripped.
  
  =item C<Features>
  
  Returns a reference to a hash with keys being features present in
  current implementation. Several optional features are used in the
  minimal interface: C<appname> should be present if the first argument
  to C<new> is recognized, and C<minline> should be present if
  C<MinLine> method is not dummy.  C<autohistory> should be present if
  lines are put into history automatically (maybe subject to
  C<MinLine>), and C<addhistory> if C<addhistory> method is not dummy.
  
  If C<Features> method reports a feature C<attribs> as present, the
  method C<Attribs> is not dummy.
  
  =back
  
  =head1 Additional supported functions
  
  Actually C<Term::ReadLine> can use some other package, that will
  support a richer set of commands.
  
  All these commands are callable via method interface and have names
  which conform to standard conventions with the leading C<rl_> stripped.
  
  The stub package included with the perl distribution allows some
  additional methods: 
  
  =over 12
  
  =item C<tkRunning>
  
  makes Tk event loop run when waiting for user input (i.e., during
  C<readline> method).
  
  =item C<event_loop>
  
  Registers call-backs to wait for user input (i.e., during C<readline>
  method).  This supersedes tkRunning.
  
  The first call-back registered is the call back for waiting.  It is
  expected that the callback will call the current event loop until
  there is something waiting to get on the input filehandle.  The parameter
  passed in is the return value of the second call back.
  
  The second call-back registered is the call back for registration.  The
  input filehandle (often STDIN, but not necessarily) will be passed in.
  
  For example, with AnyEvent:
  
    $term->event_loop(sub {
      my $data = shift;
      $data->[1] = AE::cv();
      $data->[1]->recv();
    }, sub {
      my $fh = shift;
      my $data = [];
      $data->[0] = AE::io($fh, 0, sub { $data->[1]->send() });
      $data;
    });
  
  The second call-back is optional if the call back is registered prior to
  the call to $term-E<gt>readline.
  
  Deregistration is done in this case by calling event_loop with C<undef>
  as its parameter:
  
      $term->event_loop(undef);
  
  This will cause the data array ref to be removed, allowing normal garbage
  collection to clean it up.  With AnyEvent, that will cause $data->[0] to
  be cleaned up, and AnyEvent will automatically cancel the watcher at that
  time.  If another loop requires more than that to clean up a file watcher,
  that will be up to the caller to handle.
  
  =item C<ornaments>
  
  makes the command line stand out by using termcap data.  The argument
  to C<ornaments> should be 0, 1, or a string of a form
  C<"aa,bb,cc,dd">.  Four components of this string should be names of
  I<terminal capacities>, first two will be issued to make the prompt
  standout, last two to make the input line standout.
  
  =item C<newTTY>
  
  takes two arguments which are input filehandle and output filehandle.
  Switches to use these filehandles.
  
  =back
  
  One can check whether the currently loaded ReadLine package supports
  these methods by checking for corresponding C<Features>.
  
  =head1 EXPORTS
  
  None
  
  =head1 ENVIRONMENT
  
  The environment variable C<PERL_RL> governs which ReadLine clone is
  loaded. If the value is false, a dummy interface is used. If the value
  is true, it should be tail of the name of the package to use, such as
  C<Perl> or C<Gnu>.  
  
  As a special case, if the value of this variable is space-separated,
  the tail might be used to disable the ornaments by setting the tail to
  be C<o=0> or C<ornaments=0>.  The head should be as described above, say
  
  If the variable is not set, or if the head of space-separated list is
  empty, the best available package is loaded.
  
    export "PERL_RL=Perl o=0" # Use Perl ReadLine sans ornaments
    export "PERL_RL= o=0"     # Use best available ReadLine sans ornaments
  
  (Note that processing of C<PERL_RL> for ornaments is in the discretion of the 
  particular used C<Term::ReadLine::*> package).
  
  =cut
  
  use strict;
  
  package Term::ReadLine::Stub;
  our @ISA = qw'Term::ReadLine::Tk Term::ReadLine::TermCap';
  
  $DB::emacs = $DB::emacs;	# To pacify -w
  our @rl_term_set;
  *rl_term_set = \@Term::ReadLine::TermCap::rl_term_set;
  
  sub PERL_UNICODE_STDIN () { 0x0001 }
  
  sub ReadLine {'Term::ReadLine::Stub'}
  sub readline {
    my $self = shift;
    my ($in,$out,$str) = @$self;
    my $prompt = shift;
    print $out $rl_term_set[0], $prompt, $rl_term_set[1], $rl_term_set[2];
    $self->register_Tk
       if not $Term::ReadLine::registered and $Term::ReadLine::toloop;
    #$str = scalar <$in>;
    $str = $self->get_line;
    utf8::upgrade($str)
        if (${^UNICODE} & PERL_UNICODE_STDIN || defined ${^ENCODING}) &&
           utf8::valid($str);
    print $out $rl_term_set[3];
    # bug in 5.000: chomping empty string creates length -1:
    chomp $str if defined $str;
    $str;
  }
  sub addhistory {}
  
  sub findConsole {
      my $console;
      my $consoleOUT;
  
      if (-e "/dev/tty" and $^O ne 'MSWin32') {
  	$console = "/dev/tty";
      } elsif (-e "con" or $^O eq 'MSWin32' or $^O eq 'msys') {
         $console = 'CONIN$';
         $consoleOUT = 'CONOUT$';
      } elsif ($^O eq 'VMS') {
  	$console = "sys\$command";
      } elsif ($^O eq 'os2' && !$DB::emacs) {
  	$console = "/dev/con";
      } else {
  	$console = undef;
      }
  
      $consoleOUT = $console unless defined $consoleOUT;
      $console = "&STDIN" unless defined $console;
      if ($console eq "/dev/tty" && !open(my $fh, "<", $console)) {
        $console = "&STDIN";
        undef($consoleOUT);
      }
      if (!defined $consoleOUT) {
        $consoleOUT = defined fileno(STDERR) && $^O ne 'MSWin32' ? "&STDERR" : "&STDOUT";
      }
      ($console,$consoleOUT);
  }
  
  sub new {
    die "method new called with wrong number of arguments" 
      unless @_==2 or @_==4;
    #local (*FIN, *FOUT);
    my ($FIN, $FOUT, $ret);
    if (@_==2) {
      my($console, $consoleOUT) = $_[0]->findConsole;
  
  
      # the Windows CONIN$ needs GENERIC_WRITE mode to allow
      # a SetConsoleMode() if we end up using Term::ReadKey
      open FIN, (  $^O eq 'MSWin32' && $console eq 'CONIN$' ) ? "+<$console" :
                                                                "<$console";
      open FOUT,">$consoleOUT";
  
      #OUT->autoflush(1);		# Conflicts with debugger?
      my $sel = select(FOUT);
      $| = 1;				# for DB::OUT
      select($sel);
      $ret = bless [\*FIN, \*FOUT];
    } else {			# Filehandles supplied
      $FIN = $_[2]; $FOUT = $_[3];
      #OUT->autoflush(1);		# Conflicts with debugger?
      my $sel = select($FOUT);
      $| = 1;				# for DB::OUT
      select($sel);
      $ret = bless [$FIN, $FOUT];
    }
    if ($ret->Features->{ornaments} 
        and not ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/)) {
      local $Term::ReadLine::termcap_nowarn = 1;
      $ret->ornaments(1);
    }
    return $ret;
  }
  
  sub newTTY {
    my ($self, $in, $out) = @_;
    $self->[0] = $in;
    $self->[1] = $out;
    my $sel = select($out);
    $| = 1;				# for DB::OUT
    select($sel);
  }
  
  sub IN { shift->[0] }
  sub OUT { shift->[1] }
  sub MinLine { undef }
  sub Attribs { {} }
  
  my %features = (tkRunning => 1, ornaments => 1, 'newTTY' => 1);
  sub Features { \%features }
  
  #sub get_line {
  #  my $self = shift;
  #  my $in = $self->IN;
  #  local ($/) = "\n";
  #  return scalar <$in>;
  #}
  
  package Term::ReadLine;		# So late to allow the above code be defined?
  
  our $VERSION = '1.14';
  
  my ($which) = exists $ENV{PERL_RL} ? split /\s+/, $ENV{PERL_RL} : undef;
  if ($which) {
    if ($which =~ /\bgnu\b/i){
      eval "use Term::ReadLine::Gnu;";
    } elsif ($which =~ /\bperl\b/i) {
      eval "use Term::ReadLine::Perl;";
    } elsif ($which =~ /^(Stub|TermCap|Tk)$/) {
      # it is already in memory to avoid false exception as seen in:
      # PERL_RL=Stub perl -e'$SIG{__DIE__} = sub { print @_ }; require Term::ReadLine'
    } else {
      eval "use Term::ReadLine::$which;";
    }
  } elsif (defined $which and $which ne '') {	# Defined but false
    # Do nothing fancy
  } else {
    eval "use Term::ReadLine::Gnu; 1" or eval "use Term::ReadLine::EditLine; 1" or eval "use Term::ReadLine::Perl; 1";
  }
  
  #require FileHandle;
  
  # To make possible switch off RL in debugger: (Not needed, work done
  # in debugger).
  our @ISA;
  if (defined &Term::ReadLine::Gnu::readline) {
    @ISA = qw(Term::ReadLine::Gnu Term::ReadLine::Stub);
  } elsif (defined &Term::ReadLine::EditLine::readline) {
    @ISA = qw(Term::ReadLine::EditLine Term::ReadLine::Stub);
  } elsif (defined &Term::ReadLine::Perl::readline) {
    @ISA = qw(Term::ReadLine::Perl Term::ReadLine::Stub);
  } elsif (defined $which && defined &{"Term::ReadLine::$which\::readline"}) {
    @ISA = "Term::ReadLine::$which";
  } else {
    @ISA = qw(Term::ReadLine::Stub);
  }
  
  package Term::ReadLine::TermCap;
  
  # Prompt-start, prompt-end, command-line-start, command-line-end
  #     -- zero-width beautifies to emit around prompt and the command line.
  our @rl_term_set = ("","","","");
  # string encoded:
  our $rl_term_set = ',,,';
  
  our $terminal;
  sub LoadTermCap {
    return if defined $terminal;
    
    require Term::Cap;
    $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
  }
  
  sub ornaments {
    shift;
    return $rl_term_set unless @_;
    $rl_term_set = shift;
    $rl_term_set ||= ',,,';
    $rl_term_set = 'us,ue,md,me' if $rl_term_set eq '1';
    my @ts = split /,/, $rl_term_set, 4;
    eval { LoadTermCap };
    unless (defined $terminal) {
      warn("Cannot find termcap: $@\n") unless $Term::ReadLine::termcap_nowarn;
      $rl_term_set = ',,,';
      return;
    }
    @rl_term_set = map {$_ ? $terminal->Tputs($_,1) || '' : ''} @ts;
    return $rl_term_set;
  }
  
  
  package Term::ReadLine::Tk;
  
  # This package inserts a Tk->fileevent() before the diamond operator.
  # The Tk watcher dispatches Tk events until the filehandle returned by
  # the$term->IN() accessor becomes ready for reading.  It's assumed
  # that the diamond operator will return a line of input immediately at
  # that point.
  
  my ($giveup);
  
  # maybe in the future the Tk-specific aspects will be removed.
  sub Tk_loop{
      if (ref $Term::ReadLine::toloop)
      {
          $Term::ReadLine::toloop->[0]->($Term::ReadLine::toloop->[2]);
      }
      else
      {
          Tk::DoOneEvent(0) until $giveup;
          $giveup = 0;
      }
  };
  
  sub register_Tk {
      my $self = shift;
      unless ($Term::ReadLine::registered++)
      {
          if (ref $Term::ReadLine::toloop)
          {
              $Term::ReadLine::toloop->[2] = $Term::ReadLine::toloop->[1]->($self->IN) if $Term::ReadLine::toloop->[1];
          }
          else
          {
              Tk->fileevent($self->IN,'readable',sub { $giveup = 1});
          }
      }
  };
  
  sub tkRunning {
    $Term::ReadLine::toloop = $_[1] if @_ > 1;
    $Term::ReadLine::toloop;
  }
  
  sub event_loop {
      shift;
  
      # T::RL::Gnu and T::RL::Perl check that this exists, if not,
      # it doesn't call the loop.  Those modules will need to be
      # fixed before this can be removed.
      if (not defined &Tk::DoOneEvent)
      {
          *Tk::DoOneEvent = sub {
              die "what?"; # this shouldn't be called.
          }
      }
  
      # store the callback in toloop, again so that other modules will
      # recognise it and call us for the loop.
      $Term::ReadLine::toloop = [ @_ ] if @_ > 0; # 0 because we shifted off $self.
      $Term::ReadLine::toloop;
  }
  
  sub PERL_UNICODE_STDIN () { 0x0001 }
  
  sub get_line {
    my $self = shift;
    my ($in,$out,$str) = @$self;
  
    if ($Term::ReadLine::toloop) {
      $self->register_Tk if not $Term::ReadLine::registered;
      $self->Tk_loop;
    }
  
    local ($/) = "\n";
    $str = <$in>;
  
    utf8::upgrade($str)
        if (${^UNICODE} & PERL_UNICODE_STDIN || defined ${^ENCODING}) &&
           utf8::valid($str);
    print $out $rl_term_set[3];
    # bug in 5.000: chomping empty string creates length -1:
    chomp $str if defined $str;
  
    $str;
  }
  
  1;
  
TERM_READLINE

$fatpacked{"Term/UI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_UI';
  package Term::UI;
  
  use if $] > 5.017, 'deprecate';
  
  use Carp;
  use Params::Check qw[check allow];
  use Term::ReadLine;
  use Locale::Maketext::Simple Style => 'gettext';
  use Term::UI::History;
  
  use strict;
  
  BEGIN {
      use vars        qw[$VERSION $AUTOREPLY $VERBOSE $INVALID];
      $VERBOSE    =   1;
      $VERSION    =   '0.42';
      $INVALID    =   loc('Invalid selection, please try again: ');
  }
  
  push @Term::ReadLine::Stub::ISA, __PACKAGE__
          unless grep { $_ eq __PACKAGE__ } @Term::ReadLine::Stub::ISA;
  
  
  =pod
  
  =head1 NAME
  
  Term::UI - Term::ReadLine UI made easy
  
  =head1 SYNOPSIS
  
      use Term::UI;
      use Term::ReadLine;
  
      my $term = Term::ReadLine->new('brand');
  
      my $reply = $term->get_reply(
                      prompt => 'What is your favourite colour?',
                      choices => [qw|blue red green|],
                      default => 'blue',
      );
  
      my $bool = $term->ask_yn(
                          prompt => 'Do you like cookies?',
                          default => 'y',
                  );
  
  
      my $string = q[some_command -option --no-foo --quux='this thing'];
  
      my ($options,$munged_input) = $term->parse_options($string);
  
  
      ### don't have Term::UI issue warnings -- default is '1'
      $Term::UI::VERBOSE = 0;
  
      ### always pick the default (good for non-interactive terms)
      ### -- default is '0'
      $Term::UI::AUTOREPLY = 1;
  
      ### Retrieve the entire session as a printable string:
      $hist = Term::UI::History->history_as_string;
      $hist = $term->history_as_string;
  
  =head1 DESCRIPTION
  
  C<Term::UI> is a transparent way of eliminating the overhead of having
  to format a question and then validate the reply, informing the user
  if the answer was not proper and re-issuing the question.
  
  Simply give it the question you want to ask, optionally with choices
  the user can pick from and a default and C<Term::UI> will DWYM.
  
  For asking a yes or no question, there's even a shortcut.
  
  =head1 HOW IT WORKS
  
  C<Term::UI> places itself at the back of the C<Term::ReadLine>
  C<@ISA> array, so you can call its functions through your term object.
  
  C<Term::UI> uses C<Term::UI::History> to record all interactions
  with the commandline. You can retrieve this history, or alter
  the filehandle the interaction is printed to. See the
  C<Term::UI::History> manpage or the C<SYNOPSIS> for details.
  
  =head1 METHODS
  
  =head2 $reply = $term->get_reply( prompt => 'question?', [choices => \@list, default => $list[0], multi => BOOL, print_me => "extra text to print & record", allow => $ref] );
  
  C<get_reply> asks a user a question, and then returns the reply to the
  caller. If the answer is invalid (more on that below), the question will
  be reposed, until a satisfactory answer has been entered.
  
  You have the option of providing a list of choices the user can pick from
  using the C<choices> argument. If the answer is not in the list of choices
  presented, the question will be reposed.
  
  If you provide a C<default>  answer, this will be returned when either
  C<$AUTOREPLY> is set to true, (see the C<GLOBAL VARIABLES> section further
  below), or when the user just hits C<enter>.
  
  You can indicate that the user is allowed to enter multiple answers by
  toggling the C<multi> flag. Note that a list of answers will then be
  returned to you, rather than a simple string.
  
  By specifying an C<allow> handler, you can yourself validate the answer
  a user gives. This can be any of the types that the Params::Check C<allow>
  function allows, so please refer to that manpage for details.
  
  Finally, you have the option of adding a C<print_me> argument, which is
  simply printed before the prompt. It's printed to the same file handle
  as the rest of the questions, so you can use this to keep track of a
  full session of Q&A with the user, and retrieve it later using the
  C<< Term::UI->history_as_string >> function.
  
  See the C<EXAMPLES> section for samples of how to use this function.
  
  =cut
  
  sub get_reply {
      my $term = shift;
      my %hash = @_;
  
      my $tmpl = {
          default     => { default => undef,  strict_type => 0 },
          prompt      => { default => '',     strict_type => 1, required => 1 },
          choices     => { default => [],     strict_type => 1 },
          multi       => { default => 0,      allow => [0, 1] },
          allow       => { default => qr/.*/ },
          print_me    => { default => '',     strict_type => 1 },
      };
  
      my $args = check( $tmpl, \%hash, $VERBOSE )
                  or ( carp( loc(q[Could not parse arguments]) ), return );
  
      # Check for legacy default on multi=1
      if ($args->{multi} and ref($args->{default}) ne "ARRAY") {
          $args->{default} = [ $args->{default} ];
      }
  
      ### add this to the prompt to indicate the default
      ### answer to the question if there is one.
      my $prompt_add;
  
      ### if you supplied several choices to pick from,
      ### we'll print them separately before the prompt
      if( @{$args->{choices}} ) {
          my $i;
  
          for my $choice ( @{$args->{choices}} ) {
              $i++;   # the answer counter -- but humans start counting
                      # at 1 :D
  
              ### so this choice is the default? add it to 'prompt_add'
              ### so we can construct a "foo? [DIGIT]" type prompt
              if (defined $args->{default}) {
                  if ($args->{multi}) {
                      push @$prompt_add, $i if (scalar(grep { m/^$choice$/ } @{$args->{default}}));
                  }
                  else {
                      $prompt_add = $i if ($choice eq $args->{default});
                  }
              }
  
              ### create a "DIGIT> choice" type line
              $args->{print_me} .= sprintf "\n%3s> %-s", $i, $choice;
          }
  
          $prompt_add = join(" ", @$prompt_add) if ($args->{multi});
  
          ### we listed some choices -- add another newline for
          ### pretty printing
          $args->{print_me} .= "\n" if $i;
  
          ### allowable answers are now equal to the choices listed
          $args->{allow} = $args->{choices};
  
      ### no choices, but a default? set 'prompt_add' to the default
      ### to construct a 'foo? [DEFAULT]' type prompt
      } elsif ( defined $args->{default} ) {
          if ($args->{multi} and ref($args->{default}) eq "ARRAY") {
              $prompt_add = join(" ", @{$args->{default}});
          }
          else {
              $prompt_add = $args->{default};
          }
      }
  
      ### we set up the defaults, prompts etc, dispatch to the readline call
      return $term->_tt_readline( %$args, prompt_add => $prompt_add );
  
  }
  
  =head2 $bool = $term->ask_yn( prompt => "your question", [default => (y|1,n|0), print_me => "extra text to print & record"] )
  
  Asks a simple C<yes> or C<no> question to the user, returning a boolean
  indicating C<true> or C<false> to the caller.
  
  The C<default> answer will automatically returned, if the user hits
  C<enter> or if C<$AUTOREPLY> is set to true. See the C<GLOBAL VARIABLES>
  section further below.
  
  Also, you have the option of adding a C<print_me> argument, which is
  simply printed before the prompt. It's printed to the same file handle
  as the rest of the questions, so you can use this to keep track of a
  full session of Q&A with the user, and retrieve it later using the
  C<< Term::UI->history_as_string >> function.
  
  
  See the C<EXAMPLES> section for samples of how to use this function.
  
  =cut
  
  sub ask_yn {
      my $term = shift;
      my %hash = @_;
  
      my $tmpl = {
          default     => { default => undef, allow => [qw|0 1 y n|],
                                                              strict_type => 1 },
          prompt      => { default => '', required => 1,      strict_type => 1 },
          print_me    => { default => '',                     strict_type => 1 },
          multi       => { default => 0,                      no_override => 1 },
          choices     => { default => [qw|y n|],              no_override => 1 },
          allow       => { default => [qr/^y(?:es)?$/i, qr/^n(?:o)?$/i],
                           no_override => 1
                         },
      };
  
      my $args = check( $tmpl, \%hash, $VERBOSE ) or return undef;
  
      ### uppercase the default choice, if there is one, to be added
      ### to the prompt in a 'foo? [Y/n]' type style.
      my $prompt_add;
      {   my @list = @{$args->{choices}};
          if( defined $args->{default} ) {
  
              ### if you supplied the default as a boolean, rather than y/n
              ### transform it to a y/n now
              $args->{default} = $args->{default} =~ /\d/
                                  ? { 0 => 'n', 1 => 'y' }->{ $args->{default} }
                                  : $args->{default};
  
              @list = map { lc $args->{default} eq lc $_
                                  ? uc $args->{default}
                                  : $_
                      } @list;
          }
  
          $prompt_add .= join("/", @list);
      }
  
      my $rv = $term->_tt_readline( %$args, prompt_add => $prompt_add );
  
      return $rv =~ /^y/i ? 1 : 0;
  }
  
  
  
  sub _tt_readline {
      my $term = shift;
      my %hash = @_;
  
      local $Params::Check::VERBOSE = 0;  # why is this?
      local $| = 1;                       # print ASAP
  
  
      my ($default, $prompt, $choices, $multi, $allow, $prompt_add, $print_me);
      my $tmpl = {
          default     => { default => undef,  strict_type => 0,
                              store => \$default },
          prompt      => { default => '',     strict_type => 1, required => 1,
                              store => \$prompt },
          choices     => { default => [],     strict_type => 1,
                              store => \$choices },
          multi       => { default => 0,      allow => [0, 1], store => \$multi },
          allow       => { default => qr/.*/, store => \$allow, },
          prompt_add  => { default => '',     store => \$prompt_add, strict_type => 1 },
          print_me    => { default => '',     store => \$print_me },
      };
  
      check( $tmpl, \%hash, $VERBOSE ) or return;
  
      ### prompts for Term::ReadLine can't be longer than one line, or
      ### it can display wonky on some terminals.
      history( $print_me ) if $print_me;
  
  
      if ($prompt_add) {
          ### we might have to add a default value to the prompt, to
          ### show the user what will be picked by default:
          $prompt .= " [$prompt_add]: " ;
      }
      else {
          $prompt .= " : ";
      }
  
  
      ### are we in autoreply mode?
      if ($AUTOREPLY) {
  
          ### you used autoreply, but didn't provide a default!
          carp loc(
              q[You have '%1' set to true, but did not provide a default!],
              '$AUTOREPLY'
          ) if( !defined $default && $VERBOSE);
  
          ### print it out for visual feedback
          if ($multi and defined($default)) {
              history( join ' ', grep { defined } $prompt, @$default );
              ### and return the default
              return @$default;
          }
          else {
              history( join ' ', grep { defined } $prompt, $default );
              ### and return the default
              return $default;
          }
  
      }
  
      if ($multi and defined($default)) {
          $default = join(' ', @$default);
      }
  
      ### so, no AUTOREPLY, let's see what the user will answer
      LOOP: {
  
          ### annoying bug in T::R::Perl that mucks up lines with a \n
          ### in them; So split by \n, save the last line as the prompt
          ### and just print the rest
          {   my @lines   = split "\n", $prompt;
              $prompt     = pop @lines;
  
              history( "$_\n" ) for @lines;
          }
  
          ### pose the question
          my $answer  = $term->readline($prompt);
          $answer     = $default unless length $answer;
  
          $term->addhistory( $answer ) if length $answer;
  
          ### add both prompt and answer to the history
          history( "$prompt $answer", 0 );
  
          ### if we're allowed to give multiple answers, split
          ### the answer on whitespace
          my @answers = $multi ? split(/\s+/, $answer) : $answer;
  
          ### the return value list
          my @rv;
  
          if( @$choices ) {
  
              for my $answer (@answers) {
  
                  ### a digit implies a multiple choice question,
                  ### a non-digit is an open answer
                  if( $answer =~ /\D/ ) {
                      push @rv, $answer if allow( $answer, $allow );
                  } else {
  
                      ### remember, the answer digits are +1 compared to
                      ### the choices, because humans want to start counting
                      ### at 1, not at 0
                      push @rv, $choices->[ $answer - 1 ]
                          if $answer > 0 && defined $choices->[ $answer - 1 ];
                  }
              }
  
          ### no fixed list of choices.. just check if the answers
          ### (or otherwise the default!) pass the allow handler
          } else {
              push @rv, grep { allow( $_, $allow ) } @answers;
          }
  
          ### if not all the answers made it to the return value list,
          ### at least one of them was an invalid answer -- make the
          ### user do it again
          if( (@rv != @answers) or
              (scalar(@$choices) and not scalar(@answers))
          ) {
              $prompt = $INVALID;
              $prompt .= "[$prompt_add] " if $prompt_add;
              redo LOOP;
  
          ### otherwise just return the answer, or answers, depending
          ### on the multi setting
          } else {
              return $multi ? @rv : $rv[0];
          }
      }
  }
  
  =head2 ($opts, $munged) = $term->parse_options( STRING );
  
  C<parse_options> will convert all options given from an input string
  to a hash reference. If called in list context it will also return
  the part of the input string that it found no options in.
  
  Consider this example:
  
      my $str =   q[command --no-foo --baz --bar=0 --quux=bleh ] .
                  q[--option="some'thing" -one-dash -single=blah' arg];
  
      my ($options,$munged) =  $term->parse_options($str);
  
      ### $options would contain: ###
      $options = {
                  'foo'       => 0,
                  'bar'       => 0,
                  'one-dash'  => 1,
                  'baz'       => 1,
                  'quux'      => 'bleh',
                  'single'    => 'blah\'',
                  'option'    => 'some\'thing'
      };
  
      ### and this is the munged version of the input string,
      ### ie what's left of the input minus the options
      $munged = 'command arg';
  
  As you can see, you can either use a single or a double C<-> to
  indicate an option.
  If you prefix an option with C<no-> and do not give it a value, it
  will be set to 0.
  If it has no prefix and no value, it will be set to 1.
  Otherwise, it will be set to its value. Note also that it can deal
  fine with single/double quoting issues.
  
  =cut
  
  sub parse_options {
      my $term    = shift;
      my $input   = shift;
  
      my $return = {};
  
      ### there's probably a more elegant way to do this... ###
      while ( $input =~ s/(?:^|\s+)--?([-\w]+=("|').+?\2)(?=\Z|\s+)//  or
              $input =~ s/(?:^|\s+)--?([-\w]+=\S+)(?=\Z|\s+)//         or
              $input =~ s/(?:^|\s+)--?([-\w]+)(?=\Z|\s+)//
      ) {
          my $match = $1;
  
          if( $match =~ /^([-\w]+)=("|')(.+?)\2$/ ) {
              $return->{$1} = $3;
  
          } elsif( $match =~ /^([-\w]+)=(\S+)$/ ) {
              $return->{$1} = $2;
  
          } elsif( $match =~ /^no-?([-\w]+)$/i ) {
              $return->{$1} = 0;
  
          } elsif ( $match =~ /^([-\w]+)$/ ) {
              $return->{$1} = 1;
  
          } else {
              carp(loc(q[I do not understand option "%1"\n], $match)) if $VERBOSE;
          }
      }
  
      return wantarray ? ($return,$input) : $return;
  }
  
  =head2 $str = $term->history_as_string
  
  Convenience wrapper around C<< Term::UI::History->history_as_string >>.
  
  Consult the C<Term::UI::History> man page for details.
  
  =cut
  
  sub history_as_string { return Term::UI::History->history_as_string };
  
  1;
  
  =head1 GLOBAL VARIABLES
  
  The behaviour of Term::UI can be altered by changing the following
  global variables:
  
  =head2 $Term::UI::VERBOSE
  
  This controls whether Term::UI will issue warnings and explanations
  as to why certain things may have failed. If you set it to 0,
  Term::UI will not output any warnings.
  The default is 1;
  
  =head2 $Term::UI::AUTOREPLY
  
  This will make every question be answered by the default, and warn if
  there was no default provided. This is particularly useful if your
  program is run in non-interactive mode.
  The default is 0;
  
  =head2 $Term::UI::INVALID
  
  This holds the string that will be printed when the user makes an
  invalid choice.
  You can override this string from your program if you, for example,
  wish to do localization.
  The default is C<Invalid selection, please try again: >
  
  =head2 $Term::UI::History::HISTORY_FH
  
  This is the filehandle all the print statements from this module
  are being sent to. Please consult the C<Term::UI::History> manpage
  for details.
  
  This defaults to C<*STDOUT>.
  
  =head1 EXAMPLES
  
  =head2 Basic get_reply sample
  
      ### ask a user (with an open question) for their favourite colour
      $reply = $term->get_reply( prompt => 'Your favourite colour? );
  
  which would look like:
  
      Your favourite colour?
  
  and C<$reply> would hold the text the user typed.
  
  =head2 get_reply with choices
  
      ### now provide a list of choices, so the user has to pick one
      $reply = $term->get_reply(
                  prompt  => 'Your favourite colour?',
                  choices => [qw|red green blue|] );
  
  which would look like:
  
        1> red
        2> green
        3> blue
  
      Your favourite colour?
  
  C<$reply> will hold one of the choices presented. C<Term::UI> will repose
  the question if the user attempts to enter an answer that's not in the
  list of choices. The string presented is held in the C<$Term::UI::INVALID>
  variable (see the C<GLOBAL VARIABLES> section for details.
  
  =head2 get_reply with choices and default
  
      ### provide a sensible default option -- everyone loves blue!
      $reply = $term->get_reply(
                  prompt  => 'Your favourite colour?',
                  choices => [qw|red green blue|],
                  default => 'blue' );
  
  which would look like:
  
        1> red
        2> green
        3> blue
  
      Your favourite colour? [3]:
  
  Note the default answer after the prompt. A user can now just hit C<enter>
  (or set C<$Term::UI::AUTOREPLY> -- see the C<GLOBAL VARIABLES> section) and
  the sensible answer 'blue' will be returned.
  
  =head2 get_reply using print_me & multi
  
      ### allow the user to pick more than one colour and add an
      ### introduction text
      @reply = $term->get_reply(
                  print_me    => 'Tell us what colours you like',
                  prompt      => 'Your favourite colours?',
                  choices     => [qw|red green blue|],
                  multi       => 1 );
  
  which would look like:
  
      Tell us what colours you like
        1> red
        2> green
        3> blue
  
      Your favourite colours?
  
  An answer of C<3 2 1> would fill C<@reply> with C<blue green red>
  
  =head2 get_reply & allow
  
      ### pose an open question, but do a custom verification on
      ### the answer, which will only exit the question loop, if
      ### the answer matches the allow handler.
      $reply = $term->get_reply(
                  prompt  => "What is the magic number?",
                  allow   => 42 );
  
  Unless the user now enters C<42>, the question will be reposed over
  and over again. You can use more sophisticated C<allow> handlers (even
  subroutines can be used). The C<allow> handler is implemented using
  C<Params::Check>'s C<allow> function. Check its manpage for details.
  
  =head2 an elaborate ask_yn sample
  
      ### ask a user if he likes cookies. Default to a sensible 'yes'
      ### and inform him first what cookies are.
      $bool = $term->ask_yn( prompt   => 'Do you like cookies?',
                             default  => 'y',
                             print_me => 'Cookies are LOVELY!!!' );
  
  would print:
  
      Cookies are LOVELY!!!
      Do you like cookies? [Y/n]:
  
  If a user then simply hits C<enter>, agreeing with the default,
  C<$bool> would be set to C<true>. (Simply hitting 'y' would also
  return C<true>. Hitting 'n' would return C<false>)
  
  We could later retrieve this interaction by printing out the Q&A
  history as follows:
  
      print $term->history_as_string;
  
  which would then print:
  
      Cookies are LOVELY!!!
      Do you like cookies? [Y/n]:  y
  
  There's a chance we're doing this non-interactively, because a console
  is missing, the user indicated he just wanted the defaults, etc.
  
  In this case, simply setting C<$Term::UI::AUTOREPLY> to true, will
  return from every question with the default answer set for the question.
  Do note that if C<AUTOREPLY> is true, and no default is set, C<Term::UI>
  will warn about this and return C<undef>.
  
  =head1 See Also
  
  C<Params::Check>, C<Term::ReadLine>, C<Term::UI::History>
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-term-ui@rt.cpan.org<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  =cut
TERM_UI

$fatpacked{"Term/UI/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_UI_HISTORY';
  package Term::UI::History;
  
  use strict;
  use vars qw[$VERSION];
  use base 'Exporter';
  use base 'Log::Message::Simple';
  
  $VERSION = '0.42';
  
  =pod
  
  =head1 NAME
  
  Term::UI::History - history function
  
  =head1 SYNOPSIS
  
      use Term::UI::History qw[history];
  
      history("Some message");
  
      ### retrieve the history in printable form
      $hist  = Term::UI::History->history_as_string;
  
      ### redirect output
      local $Term::UI::History::HISTORY_FH = \*STDERR;
  
  =head1 DESCRIPTION
  
  This module provides the C<history> function for C<Term::UI>,
  printing and saving all the C<UI> interaction.
  
  Refer to the C<Term::UI> manpage for details on usage from
  C<Term::UI>.
  
  This module subclasses C<Log::Message::Simple>. Refer to its
  manpage for additional functionality available via this package.
  
  =head1 FUNCTIONS
  
  =head2 history("message string" [,VERBOSE])
  
  Records a message on the stack, and prints it to C<STDOUT>
  (or actually C<$HISTORY_FH>, see the C<GLOBAL VARIABLES> section
  below), if the C<VERBOSE> option is true.
  
  The C<VERBOSE> option defaults to true.
  
  =cut
  
  BEGIN {
      use Log::Message private => 0;
  
      use vars      qw[ @EXPORT $HISTORY_FH ];
      @EXPORT     = qw[ history ];
      my $log     = new Log::Message;
      $HISTORY_FH = \*STDOUT;
  
      for my $func ( @EXPORT ) {
          no strict 'refs';
  
          *$func = sub {  my $msg     = shift;
                          $log->store(
                                  message => $msg,
                                  tag     => uc $func,
                                  level   => $func,
                                  extra   => [@_]
                          );
                  };
      }
  
      sub history_as_string {
          my $class = shift;
  
          return join $/, map { $_->message } __PACKAGE__->stack;
      }
  }
  
  
  {
      package # hide this from PAUSE
        Log::Message::Handlers;
  
      sub history {
          my $self    = shift;
          my $verbose = shift;
             $verbose = 1 unless defined $verbose;    # default to true
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          local $| = 1;
          my $old_fh = select $Term::UI::History::HISTORY_FH;
  
          print $self->message . "\n";
          select $old_fh;
  
          return;
      }
  }
  
  
  =head1 GLOBAL VARIABLES
  
  =over 4
  
  =item $HISTORY_FH
  
  This is the filehandle all the messages sent to C<history()> are being
  printed. This defaults to C<*STDOUT>.
  
  =back
  
  =head1 See Also
  
  C<Log::Message::Simple>, C<Term::UI>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2005 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
TERM_UI_HISTORY

$fatpacked{"Test/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TYPETINY';
  package Test::TypeTiny;
  
  use strict;
  use warnings;
  
  use Test::More qw();
  use Scalar::Util qw(blessed);
  use Types::TypeTiny qw(to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN {
  	*EXTENDED_TESTING = $ENV{EXTENDED_TESTING} ? sub(){!!1} : sub(){!!0};
  };
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  our @EXPORT    = qw( should_pass should_fail ok_subtype );
  our @EXPORT_OK = qw( EXTENDED_TESTING matchfor );
  
  sub matchfor
  {
  	my @matchers = @_;
  	bless \@matchers, do {
  		package #
  		Test::TypeTiny::Internal::MATCHFOR;
  		use overload
  			q[==] => 'match',
  			q[eq] => 'match',
  			q[""] => 'to_string',
  			fallback => 1;
  		sub to_string {
  			$_[0][0]
  		}
  		sub match {
  			my ($self, $e) = @_;
  			my $does = Scalar::Util::blessed($e) ? ($e->can('DOES') || $e->can('isa')) : undef;
  			for my $s (@$self) {
  				return 1 if  ref($s) && $e =~ $s;
  				return 1 if !ref($s) && $does && $e->$does($s);
  			}
  			return;
  		}
  		__PACKAGE__;
  	};
  }
  
  sub _mk_message
  {
  	require Type::Tiny;
  	my ($template, $value) = @_;
  	sprintf($template, Type::Tiny::_dd($value));
  }
  
  sub ok_subtype
  {
  	my ($type, @s) = @_;
  	@_ = (
  		not(scalar grep !$_->is_subtype_of($type), @s),
  		sprintf("%s subtype: %s", $type, join q[, ], @s),
  	);
  	goto \&Test::More::ok;
  }
  
  eval(EXTENDED_TESTING ? <<'SLOW' : <<'FAST');
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!!$type->check($value), '->check');
  	$test->ok(!!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!$type->check($value), '->check');
  	$test->ok(!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  SLOW
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!!$type->check($value),
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!$type->check($value),
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  FAST
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Test::TypeTiny - useful functions for testing the efficacy of type constraints
  
  =head1 SYNOPSIS
  
     use strict;
     use warnings;
     use Test::More;
     use Test::TypeTiny;
     
     use Types::Mine qw(Integer);
     
     should_pass(1, Integer);
     should_pass(-1, Integer);
     should_pass(0, Integer);
     should_fail(2.5, Integer);
     
     ok_subtype(Number, Integer);
     
     done_testing;
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Test::TypeTiny> provides a few handy functions for testing type constraints.
  
  =head2 Functions
  
  =over
  
  =item C<< should_pass($value, $type, $test_name) >>
  
  =item C<< should_pass($value, $type) >>
  
  Test that passes iff C<< $value >> passes C<< $type->check >>.
  
  =item C<< should_fail($value, $type, $test_name) >>
  
  =item C<< should_fail($value, $type) >>
  
  Test that passes iff C<< $value >> fails C<< $type->check >>.
  
  =item C<< ok_subtype($type, @subtypes) >>
  
  Test that passes iff all C<< @subtypes >> are subtypes of C<< $type >>.
  
  =item C<< EXTENDED_TESTING >>
  
  Exportable boolean constant.
  
  =item C<< matchfor(@things) >>
  
  Assistant for matching exceptions. Not exported by default.
  See also L<Test::Fatal::matchfor>.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the C<EXTENDED_TESTING> environment variable is set to true, this
  module will promote each C<should_pass> or C<should_fail> test into a
  subtest block and test the type constraint in both an inlined and
  non-inlined manner.
  
  This variable must be set at compile time (i.e. before this module is
  loaded).
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  For an alternative to C<should_pass>, see L<Test::Deep::Type> which will
  happily accept a Type::Tiny type constraint instead of a MooseX::Types one.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TEST_TYPETINY

$fatpacked{"Test/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_YAML';
  package Test::YAML;
  $Test::YAML::VERSION = '0.90';
  use Test::Base -Base;
  use lib 'lib';
  
  our $YAML    = 'YAML';
  our @EXPORT  = qw(
      no_diff
      run_yaml_tests
      run_roundtrip_nyn roundtrip_nyn
      run_load_passes load_passes
      dumper Load Dump LoadFile DumpFile
      XXX
  );
  
  delimiters('===', '+++');
  
  sub Dump     () { YAML(Dump => @_)     }
  sub Load     () { YAML(Load => @_)     }
  sub DumpFile () { YAML(DumpFile => @_) }
  sub LoadFile () { YAML(LoadFile => @_) }
  
  sub YAML () {
      load_yaml_pm();
      my $meth = shift;
      my $code = $YAML->can($meth) or die "$YAML cannot do $meth";
      goto &$code;
  }
  
  sub load_yaml_pm {
      my $file = "$YAML.pm";
      $file =~ s{::}{/}g;
      require $file;
  }
  
  sub run_yaml_tests() {
      run {
          my $block = shift;
          &{_get_function($block)}($block) unless
            _skip_tests_for_now($block) or
            _skip_yaml_tests($block);
      };
  }
  
  sub run_roundtrip_nyn() {
      my @options = @_;
      run {
          my $block = shift;
          roundtrip_nyn($block, @options);
      };
  }
  
  sub roundtrip_nyn() {
      my $block = shift;
      my $option = shift || '';
      die "'perl' data section required"
          unless exists $block->{perl};
      my @values = eval $block->perl;
      die "roundtrip_nyn eval perl error: $@" if $@;
      my $config = $block->config || '';
      my $result = eval "$config; Dump(\@values)";
      die "roundtrip_nyn YAML::Dump error: $@" if $@;
      if (exists $block->{yaml}) {
          is $result, $block->yaml,
              $block->description . ' (n->y)';
      }
      else {
          pass $block->description . ' (n->y)';
      }
  
      return if exists $block->{no_round_trip} or
          not exists $block->{yaml};
  
      if ($option eq 'dumper') {
          is dumper(Load($block->yaml)), dumper(@values),
              $block->description . ' (y->n)';
      }
      else {
          is_deeply [Load($block->yaml)], [@values],
              $block->description . ' (y->n)';
      }
  }
  
  sub count_roundtrip_nyn() {
      my $block = shift or die "Bad call to count_roundtrip_nyn";
      return 1 if exists $block->{skip_this_for_now};
      my $count = 0;
      $count++ if exists $block->{perl};
      $count++ unless exists $block->{no_round_trip} or
          not exists $block->{yaml};
      die "Invalid test definition" unless $count;
      return $count;
  }
  
  sub run_load_passes() {
      run {
          my $block = shift;
          my $yaml = $block->yaml;
          eval { YAML(Load => $yaml) };
          is("$@", "");
      };
  }
  
  sub load_passes() {
      my $block = shift;
      my $yaml = $block->yaml;
      eval { YAML(Load => $yaml) };
      is "$@", "", $block->description;
  }
  
  sub count_load_passes() {1}
  
  sub dumper() {
      require Data::Dumper;
      $Data::Dumper::Sortkeys = 1;
      $Data::Dumper::Terse = 1;
      $Data::Dumper::Indent = 1;
      return Data::Dumper::Dumper(@_);
  }
  
  sub _count_tests() {
      my $block = shift or die "Bad call to _count_tests";
      no strict 'refs';
      &{'count_' . _get_function_name($block)}($block);
  }
  
  sub _get_function_name() {
      my $block = shift;
      return $block->function || 'roundtrip_nyn';
  }
  
  sub _get_function() {
      my $block = shift;
      no strict 'refs';
      \ &{_get_function_name($block)};
  }
  
  sub _skip_tests_for_now() {
      my $block = shift;
      if (exists $block->{skip_this_for_now}) {
          _skip_test(
              $block->description,
              _count_tests($block),
          );
          return 1;
      }
      return 0;
  }
  
  sub _skip_yaml_tests() {
      my $block = shift;
      if ($block->skip_unless_modules) {
          my @modules = split /[\s\,]+/, $block->skip_unless_modules;
          for my $module (@modules) {
              eval "require $module";
              if ($@) {
                  _skip_test(
                      "This test requires the '$module' module",
                      _count_tests($block),
                  );
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub _skip_test() {
      my ($message, $count) = @_;
      SKIP: {
          skip($message, $count);
      }
  }
  
  #-------------------------------------------------------------------------------
  package Test::YAML::Filter;
  $Test::YAML::Filter::VERSION = '0.90';
  use Test::Base::Filter ();
  
  our @ISA = 'Test::Base::Filter';
  
  sub yaml_dump {
      Test::YAML::Dump(@_);
  }
  
  sub yaml_load {
      Test::YAML::Load(@_);
  }
  
  sub Dump { goto &Test::YAML::Dump }
  sub Load { goto &Test::YAML::Load }
  sub DumpFile { goto &Test::YAML::DumpFile }
  sub LoadFile { goto &Test::YAML::LoadFile }
  
  sub yaml_load_or_fail {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $result;
  }
  
  sub yaml_load_error_or_warning {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub perl_eval_error_or_warning {
      my ($result, $error, $warning) =
        $self->_perl_eval_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub _yaml_load_result_error_warning {
      $self->assert_scalar(@_);
      my $yaml = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval {
          $self->yaml_load($yaml);
      };
      return ($result, $@, $warning);
  }
  
  sub _perl_eval_result_error_warning {
      $self->assert_scalar(@_);
      my $perl = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval $perl;
      return ($result, $@, $warning);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::YAML - Testing Module for YAML Implementations
  
  =head1 SYNOPSIS
  
      use Test::YAML tests => 1;
  
      pass;
  
  =head1 DESCRIPTION
  
  Test::YAML is a subclass of Test::Base with YAML specific support.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST_YAML

$fatpacked{"Text/Glob.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_GLOB';
  package Text::Glob;
  use strict;
  use Exporter;
  use vars qw/$VERSION @ISA @EXPORT_OK
              $strict_leading_dot $strict_wildcard_slash/;
  $VERSION = '0.09';
  @ISA = 'Exporter';
  @EXPORT_OK = qw( glob_to_regex glob_to_regex_string match_glob );
  
  $strict_leading_dot    = 1;
  $strict_wildcard_slash = 1;
  
  use constant debug => 0;
  
  sub glob_to_regex {
      my $glob = shift;
      my $regex = glob_to_regex_string($glob);
      return qr/^$regex$/;
  }
  
  sub glob_to_regex_string
  {
      my $glob = shift;
      my ($regex, $in_curlies, $escaping);
      local $_;
      my $first_byte = 1;
      for ($glob =~ m/(.)/gs) {
          if ($first_byte) {
              if ($strict_leading_dot) {
                  $regex .= '(?=[^\.])' unless $_ eq '.';
              }
              $first_byte = 0;
          }
          if ($_ eq '/') {
              $first_byte = 1;
          }
          if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
              $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
              $regex .= "\\$_";
          }
          elsif ($_ eq '*') {
              $regex .= $escaping ? "\\*" :
                $strict_wildcard_slash ? "[^/]*" : ".*";
          }
          elsif ($_ eq '?') {
              $regex .= $escaping ? "\\?" :
                $strict_wildcard_slash ? "[^/]" : ".";
          }
          elsif ($_ eq '{') {
              $regex .= $escaping ? "\\{" : "(";
              ++$in_curlies unless $escaping;
          }
          elsif ($_ eq '}' && $in_curlies) {
              $regex .= $escaping ? "}" : ")";
              --$in_curlies unless $escaping;
          }
          elsif ($_ eq ',' && $in_curlies) {
              $regex .= $escaping ? "," : "|";
          }
          elsif ($_ eq "\\") {
              if ($escaping) {
                  $regex .= "\\\\";
                  $escaping = 0;
              }
              else {
                  $escaping = 1;
              }
              next;
          }
          else {
              $regex .= $_;
              $escaping = 0;
          }
          $escaping = 0;
      }
      print "# $glob $regex\n" if debug;
  
      return $regex;
  }
  
  sub match_glob {
      print "# ", join(', ', map { "'$_'" } @_), "\n" if debug;
      my $glob = shift;
      my $regex = glob_to_regex $glob;
      local $_;
      grep { $_ =~ $regex } @_;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::Glob - match globbing patterns against text
  
  =head1 SYNOPSIS
  
   use Text::Glob qw( match_glob glob_to_regex );
  
   print "matched\n" if match_glob( "foo.*", "foo.bar" );
  
   # prints foo.bar and foo.baz
   my $regex = glob_to_regex( "foo.*" );
   for ( qw( foo.bar foo.baz foo bar ) ) {
       print "matched: $_\n" if /$regex/;
   }
  
  =head1 DESCRIPTION
  
  Text::Glob implements glob(3) style matching that can be used to match
  against text, rather than fetching names from a filesystem.  If you
  want to do full file globbing use the File::Glob module instead.
  
  =head2 Routines
  
  =over
  
  =item match_glob( $glob, @things_to_test )
  
  Returns the list of things which match the glob from the source list.
  
  =item glob_to_regex( $glob )
  
  Returns a compiled regex which is the equivalent of the globbing
  pattern.
  
  =item glob_to_regex_string( $glob )
  
  Returns a regex string which is the equivalent of the globbing
  pattern.
  
  =back
  
  =head1 SYNTAX
  
  The following metacharacters and rules are respected.
  
  =over
  
  =item C<*> - match zero or more characters
  
  C<a*> matches C<a>, C<aa>, C<aaaa> and many many more.
  
  =item C<?> - match exactly one character
  
  C<a?> matches C<aa>, but not C<a>, or C<aaa>
  
  =item Character sets/ranges
  
  C<example.[ch]> matches C<example.c> and C<example.h>
  
  C<demo.[a-c]> matches C<demo.a>, C<demo.b>, and C<demo.c>
  
  =item alternation
  
  C<example.{foo,bar,baz}> matches C<example.foo>, C<example.bar>, and
  C<example.baz>
  
  =item leading . must be explictly matched
  
  C<*.foo> does not match C<.bar.foo>.  For this you must either specify
  the leading . in the glob pattern (C<.*.foo>), or set
  C<$Text::Glob::strict_leading_dot> to a false value while compiling
  the regex.
  
  =item C<*> and C<?> do not match /
  
  C<*.foo> does not match C<bar/baz.foo>.  For this you must either
  explicitly match the / in the glob (C<*/*.foo>), or set
  C<$Text::Glob::strict_wildcard_slash> to a false value with compiling
  the regex.
  
  =back
  
  =head1 BUGS
  
  The code uses qr// to produce compiled regexes, therefore this module
  requires perl version 5.005_03 or newer.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2006, 2007 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Glob>, glob(3)
  
  =cut
TEXT_GLOB

$fatpacked{"Type/Coercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION';
  package Type::Coercion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::VERSION   = '0.038';
  }
  
  use Eval::TypeTiny qw<>;
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny qw<>;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(+)       => sub { __PACKAGE__->add(@_) },
  	fallback   => 1,
  ;
  
  BEGIN {
  	require Type::Tiny;
  	overload->import(q(~~) => sub { $_[0]->has_coercion_for_value($_[1]) })
  		if Type::Tiny::SUPPORT_SMARTMATCH();
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	
  	if ("Sub::Quote"->can("quote_sub") && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_coercion('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->coerce(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	$params{name} = '__ANON__' unless exists($params{name});
  	my $C = delete($params{type_coercion_map}) || [];
  	my $F = delete($params{frozen});
  	
  	my $self = bless \%params, $class;
  	$self->add_type_coercions(@$C) if @$C;
  	Scalar::Util::weaken($self->{type_constraint}); # break ref cycle
  	$self->{frozen} = $F if $F;
  	
  	unless ($self->is_anon)
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$self->name =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $self->name =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid coercion name', $self->name;
  	}
  	
  	return $self;
  }
  
  sub name                   { $_[0]{name} }
  sub display_name           { $_[0]{display_name}      ||= $_[0]->_build_display_name }
  sub library                { $_[0]{library} }
  sub type_constraint        { $_[0]{type_constraint} }
  sub type_coercion_map      { $_[0]{type_coercion_map} ||= [] }
  sub moose_coercion         { $_[0]{moose_coercion}    ||= $_[0]->_build_moose_coercion }
  sub compiled_coercion      { $_[0]{compiled_coercion} ||= $_[0]->_build_compiled_coercion }
  sub frozen                 { $_[0]{frozen}            ||= 0 }
  sub coercion_generator     { $_[0]{coercion_generator} }
  sub parameters             { $_[0]{parameters} }
  
  sub has_library            { exists $_[0]{library} }
  sub has_type_constraint    { defined $_[0]{type_constraint} } # sic
  sub has_coercion_generator { exists $_[0]{coercion_generator} }
  sub has_parameters         { exists $_[0]{parameters} }
  
  sub add
  {
  	my $class = shift;
  	my ($x, $y, $swap) = @_;
  	
  	Types::TypeTiny::TypeTiny->check($x) and return $x->plus_fallback_coercions($y);
  	Types::TypeTiny::TypeTiny->check($y) and return $y->plus_coercions($x);
  	
  	_croak "Attempt to add $class to something that is not a $class"
  		unless blessed($x) && blessed($y) && $x->isa($class) && $y->isa($class);
  
  	($y, $x) = ($x, $y) if $swap;
  
  	my %opts;
  	if ($x->has_type_constraint and $y->has_type_constraint and $x->type_constraint == $y->type_constraint)
  	{
  		$opts{type_constraint} = $x->type_constraint;
  	}
  	elsif ($x->has_type_constraint and $y->has_type_constraint)
  	{
  #		require Type::Tiny::Union;
  #		$opts{type_constraint} = "Type::Tiny::Union"->new(
  #			type_constraints => [ $x->type_constraint, $y->type_constraint ],
  #		);
  	}
  	$opts{display_name} ||= "$x+$y";
  	delete $opts{display_name} if $opts{display_name} eq '__ANON__+__ANON__';
  	
  	my $new = $class->new(%opts);
  	$new->add_type_coercions( @{$x->type_coercion_map} );
  	$new->add_type_coercions( @{$y->type_coercion_map} );
  	return $new;
  }
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	
  	if ($self->has_library and not $self->is_anon)
  	{
  		return sprintf("%s::%s", $self->library, $self->name);
  	}
  	
  	return $self->name;
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub _clear_compiled_coercion {
  	delete $_[0]{_overload_coderef};
  	delete $_[0]{compiled_coercion};
  }
  
  sub freeze { $_[0]{frozen} = 1; $_[0] }
  
  sub coerce
  {
  	my $self = shift;
  	return $self->compiled_coercion->(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	my $r = $self->coerce(@_);
  	$self->type_constraint->assert_valid($r)
  		if $self->has_type_constraint;
  	return $r;
  }
  
  sub has_coercion_for_type
  {
  	my $self = shift;
  	my $type = Types::TypeTiny::to_TypeTiny($_[0]);
  	
  	return "0 but true"
  		if $self->has_type_constraint && $type->is_a_type_of($self->type_constraint);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $type->is_a_type_of($c->[$i]);
  	}
  	return;
  }
  
  sub has_coercion_for_value
  {
  	my $self = shift;
  	local $_ = $_[0];
  	
  	return "0 but true"
  		if $self->has_type_constraint && $self->type_constraint->check(@_);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $c->[$i]->check(@_);
  	}
  	return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	my @args = @_;
  	
  	_croak "Attempt to add coercion code to a Type::Coercion which has been frozen" if $self->frozen;
  	
  	while (@args)
  	{
  		my $type     = Types::TypeTiny::to_TypeTiny(shift @args);
  		my $coercion = shift @args;
  		
  		_croak "Types must be blessed Type::Tiny objects"
  			unless Types::TypeTiny::TypeTiny->check($type);
  		_croak "Coercions must be code references or strings"
  			unless Types::TypeTiny::StringLike->check($coercion) || Types::TypeTiny::CodeLike->check($coercion);
  		
  		push @{$self->type_coercion_map}, $type, $coercion;
  	}
  	
  	$self->_clear_compiled_coercion;
  	return $self;
  }
  
  sub _build_compiled_coercion
  {
  	my $self = shift;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return sub { $_[0] } unless @mishmash;
  
  	if ($self->can_be_inlined)
  	{
  		return Eval::TypeTiny::eval_closure(
  			source      => sprintf('sub ($) { %s }', $self->inline_coercion('$_[0]')),
  			description => sprintf("compiled coercion '%s'", $self),
  		);
  	}
  
  	# These arrays will be closed over.
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub,
  			$types[$i]->can_be_inlined ? sprintf('if (%s)', $types[$i]->inline_check('$_[0]')) :
  			sprintf('if ($checks[%d]->(@_))', $i);
  		push @sub,
  			!defined($codes[$i])
  				? sprintf('  { return $_[0] }') :
  			Types::TypeTiny::StringLike->check($codes[$i])
  				? sprintf('  { local $_ = $_[0]; return( %s ) }', $codes[$i]) :
  			sprintf('  { local $_ = $_[0]; return $codes[%d]->(@_) }', $i);
  	}
  	
  	push @sub, 'return $_[0];';
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', join qq[\n], @sub),
  		description => sprintf("compiled coercion '%s'", $self),
  		environment => {
  			'@checks' => [ map $_->compiled_check, @types ],
  			'@codes'  => \@codes,
  		},
  	);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	return
  		if $self->has_type_constraint
  		&& !$self->type_constraint->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type, $converter) = splice(@mishmash, 0, 2);
  		return unless $type->can_be_inlined;
  		return unless Types::TypeTiny::StringLike->check($converter);
  	}
  	return !!1;
  }
  
  sub _source_type_union
  {
  	my $self = shift;
  	
  	my @r;
  	push @r, $self->type_constraint if $self->has_type_constraint;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type) = splice(@mishmash, 0, 2);
  		push @r, $type;
  	}
  	
  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@r, tmp => 1);
  }
  
  sub inline_coercion
  {
  	my $self = shift;
  	my $varname = $_[0];
  	
  	_croak "This coercion cannot be inlined" unless $self->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return "($varname)" unless @mishmash;
  	
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub, sprintf('(%s) ?', $types[$i]->inline_check($varname));
  		push @sub,
  			(defined($codes[$i]) && ($varname eq '$_'))
  				? sprintf('scalar(%s) :', $codes[$i]) :
  			defined($codes[$i])
  				? sprintf('do { local $_ = %s; scalar(%s) } :', $varname, $codes[$i]) :
  			sprintf('%s :', $varname);
  	}
  	
  	push @sub, "$varname";
  	
  	"@sub";
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	my %options = ();
  	$options{type_coercion_map} = [ $self->freeze->_codelike_type_coercion_map('moose_type') ];
  	$options{type_constraint}   = $self->type_constraint if $self->has_type_constraint;
  	
  	require Moose::Meta::TypeCoercion;
  	my $r = "Moose::Meta::TypeCoercion"->new(%options);
  	
  	return $r;
  }
  
  sub _codelike_type_coercion_map
  {
  	my $self = shift;
  	my $modifier = $_[0];
  	
  	my @orig = @{ $self->type_coercion_map };
  	my @new;
  	
  	while (@orig)
  	{
  		my ($type, $converter) = splice(@orig, 0, 2);
  		
  		push @new, $modifier ? $type->$modifier : $type;
  		
  		if (Types::TypeTiny::CodeLike->check($converter))
  		{
  			push @new, $converter;
  		}
  		else
  		{
  			Eval::TypeTiny::eval_closure(
  				source      => sprintf('sub { local $_ = $_[0]; %s }', $converter),
  				description => sprintf("temporary compiled converter from '%s'", $type),
  			);
  		}
  	}
  	
  	return @new;
  }
  
  sub is_parameterizable
  {
  	shift->has_coercion_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  sub parameterize
  {
  	my $self = shift;
  	return $self unless @_;
  	$self->is_parameterizable
  		or _croak "Constraint '%s' does not accept parameters", "$self";
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  	
  	return ref($self)->new(
  		type_constraint    => $self->type_constraint,
  		type_coercion_map  => [ $self->coercion_generator->($self, $self->type_constraint, @_) ],
  		parameters         => \@_,
  		frozen             => 1,
  	);
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] eq 'Moose::Meta::TypeCoercion')
  	{
  		return !!1;
  	}
  	
  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] =~ /^Moose/ and my $r = $self->moose_coercion->isa(@_))
  	{
  		return $r;
  	}
  	
  	$self->SUPER::isa(@_);
  }
  
  sub can
  {
  	my $self = shift;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can(@_))
  	{
  		return sub { $method->(shift->moose_coercion, @_) };
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can($m))
  	{
  		return $method->($self->moose_coercion, @_);
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  # Private Moose method, but Moo uses this...
  sub _compiled_type_coercion
  {
  	my $self = shift;
  	if (@_)
  	{
  		my $thing = $_[0];
  		if (blessed($thing) and $thing->isa("Type::Coercion"))
  		{
  			$self->add_type_coercions(@{$thing->type_coercion_map});
  		}
  		elsif (Types::TypeTiny::CodeLike->check($thing))
  		{
  			require Types::Standard;
  			$self->add_type_coercions(Types::Standard::Any(), $thing);
  		}
  	}
  	$self->compiled_coercion;
  }
  
  *compile_type_coercion = \&compiled_coercion;
  sub meta { _croak("Not really a Moose::Meta::TypeCoercion. Sorry!") }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion - a set of coercions to a particular target type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< add($c1, $c2) >>
  
  Create a Type::Coercion from two existing Type::Coercion objects.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<name>
  
  A name for the coercion. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous coercion.
  
  =item C<display_name>
  
  A name to display for the coercion when stringified. These don't have
  to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<library>
  
  The package name of the type library this coercion is associated with.
  Optional. Informational only: setting this attribute does not install
  the coercion into the package.
  
  =item C<type_constraint>
  
  Weak reference to the target type constraint (i.e. the type constraint which
  the output of coercion coderefs is expected to conform to).
  
  =item C<type_coercion_map>
  
  Arrayref of source-type/code pairs. Don't set this in the constructor; use
  the C<add_type_coercions> method instead.
  
  =item C<< compiled_coercion >>
  
  Coderef to coerce a value (C<< $_[0] >>).
  
  The general point of this attribute is that you should not set it, and
  rely on the lazily-built default. Type::Coerce will usually generate a
  pretty fast coderef, inlining all type constraint checks, etc.
  
  =item C<moose_coercion>
  
  A L<Moose::Meta::TypeCoercion> object equivalent to this one. Don't set this
  manually; rely on the default built one.
  
  =item C<frozen>
  
  Boolean; default false. A frozen coercion cannot have C<add_type_coercions>
  called upon it.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_type_constraint>, C<has_library>
  
  Predicate methods.
  
  =item C<is_anon>
  
  Returns true iff the coercion does not have a C<name>.
  
  =item C<< qualified_name >>
  
  For non-anonymous coercions that have a library, returns a qualified
  C<< "Library::Type" >> sort of name. Otherwise, returns the same as C<name>.
  
  =item C<< add_type_coercions($type1, $code1, ...) >>
  
  Takes one or more pairs of L<Type::Tiny> constraints and coercion code,
  creating an ordered list of source types and coercion codes.
  
  Coercion codes can be expressed as either a string of Perl code (this
  includes objects which overload stringification), or a coderef (or object
  that overloads coderefification). In either case, the value to be coerced
  is C<< $_ >>.
  
  =item C<< coerce($value) >>
  
  Coerce the value to the target type.
  
  Returns the coerced value, or the original value if no coercion was
  possible.
  
  =item C<< assert_coerce($value) >>
  
  Coerce the value to the target type, and throw an exception if the result
  does not validate against the target type constraint.
  
  Returns the coerced value.
  
  =item C<< has_coercion_for_type($source_type) >>
  
  Returns true iff this coercion has a coercion from the source type.
  
  Returns the special string C<< "0 but true" >> if no coercion should
  actually be necessary for this type. (For example, if a coercion coerces
  to a theoretical "Number" type, there is probably no coercion necessary
  for values that already conform to the "Integer" type.)
  
  =item C<< has_coercion_for_value($value) >>
  
  Returns true iff the value could be coerced by this coercion.
  
  Returns the special string C<< "0 but true" >> if no coercion would be
  actually be necessary for this value (due to it already meeting the target
  type constraint).
  
  =item C<< can_be_inlined >>
  
  Returns true iff the coercion can be inlined.
  
  =item C<< inline_coercion($varname) >>
  
  Much like C<inline_coerce> from L<Type::Tiny>.
  
  =item C<< freeze >>
  
  Set C<frozen> to true. There is no C<unfreeze>. Called automatically by
  L<Type::Tiny> sometimes.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeCoercion.
  
  =back
  
  The following methods are used for parameterized coercions, but are not
  fully documented because they may change in the near future:
  
  =over
  
  =item C<< coercion_generator >>
  
  =item C<< has_coercion_generator >>
  
  =item C<< has_parameters >>
  
  =item C<< is_parameterizable >>
  
  =item C<< is_parameterized >>
  
  =item C<< parameterize(@params) >>
  
  =item C<< parameters >>
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_coercion >>
  
  =item C<< meta >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<coerce>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<has_coercion_for_value>.
  
  =item *
  
  Addition is overloaded to call C<add>.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item B<< Attempt to add coercion code to a Type::Coercion which has been frozen >>
  
  Type::Tiny type constraints are designed as immutable objects. Once you've
  created a constraint, rather than modifying it you generally create child
  constraints to do what you need.
  
  Type::Coercion objects, on the other hand, are mutable. Coercion routines
  can be added at any time during the object's lifetime.
  
  Sometimes Type::Tiny needs to freeze a Type::Coercion object to prevent this.
  In L<Moose> and L<Mouse> code this is likely to happen as soon as you use a
  type constraint in an attribute.
  
  Workarounds:
  
  =over
  
  =item *
  
  Define as many of your coercions as possible within type libraries, not
  within the code that uses the type libraries. The type library will be
  evaluated relatively early, likely before there is any reason to freeze
  a coercion.
  
  =item *
  
  If you do need to add coercions to a type within application code outside
  the type library, instead create a subtype and add coercions to that. The
  C<plus_coercions> method provided by L<Type::Tiny> should make this simple.
  
  =back
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Types::Standard>.
  
  L<Type::Coercion::Union>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_COERCION

$fatpacked{"Type/Coercion/FromMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_FROMMOOSE';
  package Type::Coercion::FromMoose;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::FromMoose::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::FromMoose::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	my @from = @{ $self->type_constraint->moose_type->coercion->type_coercion_map };
  
  	my @return;
  	while (@from)
  	{
  		my ($type, $code) = splice(@from, 0, 2);
  		$type = Moose::Util::TypeConstraints::find_type_constraint($type)
  			unless ref $type;
  		push @return, Types::TypeTiny::to_TypeTiny($type), $code;
  	}
  	
  	return \@return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::FromMoose not currently supported" if @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::FromMoose - a set of coercions borrowed from Moose
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  Moose.
  
  This is mostly for internal purposes.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_FROMMOOSE

$fatpacked{"Type/Coercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_UNION';
  package Type::Coercion::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::Union::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);
  	$type->isa('Type::Tiny::Union')
  		or _croak "Type::Coercion::Union must be used in conjunction with Type::Tiny::Union";
  	
  	my @c;
  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		push @c, @{$tc->coercion->type_coercion_map};
  	}
  	return \@c;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::Union not currently supported" if @_;
  }
  
  # sub _build_moose_coercion ???
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::Union - a set of coercions to a union type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  the child constraints of the union type constraint.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion::Union>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_UNION

$fatpacked{"Type/Library.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_LIBRARY';
  package Type::Library;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Library::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Library::VERSION   = '0.038';
  }
  
  use Eval::TypeTiny qw< eval_closure >;
  use Scalar::Util qw< blessed >;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny >;
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN { *NICE_PROTOTYPES = ($] >= 5.014) ? sub () { !!1 } : sub () { !!0 } };
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  {
  	my $got_subname;
  	sub _subname ($$)
  	{
  		$got_subname = 1 && goto \&Sub::Name::subname
  			if $got_subname || eval "require Sub::Name";
  		return $_[1];
  	}
  }
  
  sub _exporter_validate_opts
  {
  	my $class = shift;
  	
  	no strict "refs";
  	my $into  = $_[0]{into};
  	push @{"$into\::ISA"}, $class if $_[0]{base};
  	
  	return $class->SUPER::_exporter_validate_opts(@_);
  }
  
  sub _exporter_expand_tag
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	$name eq 'types'     and return map [ "$_"        => $value ], $class->type_names;
  	$name eq 'is'        and return map [ "is_$_"     => $value ], $class->type_names;
  	$name eq 'assert'    and return map [ "assert_$_" => $value ], $class->type_names;
  	$name eq 'to'        and return map [ "to_$_"     => $value ], $class->type_names;
  	$name eq 'coercions' and return map [ "$_"        => $value ], $class->coercion_names;
  	
  	if ($name eq 'all')
  	{
  		no strict "refs";
  		return (
  			map(
  				[ "+$_" => $value ],
  				$class->type_names,
  			),
  			map(
  				[ $_ => $value ],
  				$class->coercion_names,
  				@{"$class\::EXPORT"},
  				@{"$class\::EXPORT_OK"},
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_expand_tag(@_);
  }
  
  sub _mksub
  {
  	my $class = shift;
  	my ($type, $post_method) = @_;
  	$post_method ||= q();
  	
  	my $source = $type->is_parameterizable
  		? sprintf(
  			q{
  				sub (%s) {
  					my $params; $params = shift if ref($_[0]) eq q(ARRAY);
  					my $t = $params ? $type->parameterize(@$params) : $type;
  					@_ && wantarray ? return($t%s, @_) : return $t%s;
  				}
  			},
  			NICE_PROTOTYPES ? q(;$) : q(;@),
  			$post_method,
  			$post_method,
  		)
  		: sprintf(
  			q{ sub () { $type%s if $] } },
  			$post_method,
  		);
  		
  	return _subname(
  		$type->qualified_name,
  		eval_closure(
  			source      => $source,
  			description => sprintf("exportable function '%s'", $type),
  			environment => {'$type' => \$type},
  		),
  	);
  }
  
  sub _exporter_permitted_regexp
  {
  	my $class = shift;
  	
  	my $inherited = $class->SUPER::_exporter_permitted_regexp(@_);
  	my $types = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->type_names;
  	my $coercions = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->coercion_names;
  	
  	qr{^(?:
  		$inherited
  		| (?: (?:is_|to_|assert_)? (?:$types) )
  		| (?:$coercions)
  	)$}xms;
  }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	if ($name =~ /^\+(.+)/ and $class->has_type($1))
  	{
  		my $type   = $1;
  		my $value2 = +{%{$value||{}}};
  		
  		return map $class->_exporter_expand_sub($_, $value2, $globals),
  			$type, "is_$type", "assert_$type", "to_$type";
  	}
  	
  	if (my $type = $class->get_type($name))
  	{
  		my $post_method = q();
  		$post_method = '->mouse_type' if $globals->{mouse};
  		$post_method = '->moose_type' if $globals->{moose};
  		return ($name => $class->_mksub($type, $post_method)) if $post_method;
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  #sub _exporter_install_sub
  #{
  #	my $class = shift;
  #	my ($name, $value, $globals, $sym) = @_;
  #	
  #	warn sprintf(
  #		'Exporter %s exporting %s with prototype %s',
  #		$class,
  #		$name,
  #		prototype($sym),
  #	);
  #	
  #	$class->SUPER::_exporter_install_sub(@_);
  #}
  
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	my $into = $globals->{into}
  		or _croak("Parameter 'into' not supplied");
  	
  	if ($globals->{declare})
  	{
  		my $declared = sub (;$)
  		{
  			my $params; $params = shift if ref($_[0]) eq "ARRAY";
  			my $type = $into->get_type($name);
  			unless ($type)
  			{
  				_croak "Cannot parameterize a non-existant type" if $params;
  				$type = $name;
  			}
  			
  			my $t = $params ? $type->parameterize(@$params) : $type;
  			@_ && wantarray ? return($t, @_) : return $t;
  		};
  		
  		return(
  			$name,
  			_subname(
  				"$class\::$name",
  				NICE_PROTOTYPES ? sub (;$) { goto $declared } : sub (;@) { goto $declared },
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_fail(@_);
  }
  
  sub meta
  {
  	no strict "refs";
  	no warnings "once";
  	return $_[0] if blessed $_[0];
  	${"$_[0]\::META"} ||= bless {}, $_[0];
  }
  
  sub add_type
  {
  	my $meta  = shift->meta;
  	my $class = blessed($meta);
  	
  	my $type =
  		ref($_[0]) =~ /^Type::Tiny\b/  ? $_[0] :
  		blessed($_[0])                 ? to_TypeTiny($_[0]) :
  		ref($_[0]) eq q(HASH)          ? "Type::Tiny"->new(library => $class, %{$_[0]}) :
  		"Type::Tiny"->new(library => $class, @_);
  	my $name = $type->{name};
  	
  	$meta->{types} ||= {};
  	_croak 'Type %s already exists in this library', $name if $meta->has_type($name);
  	_croak 'Type %s conflicts with coercion of same name', $name if $meta->has_coercion($name);
  	_croak 'Cannot add anonymous type to a library' if $type->is_anon;
  	$meta->{types}{$name} = $type;
  	
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	
  	# There is an inlined coercion available, but don't use that because
  	# additional coercions can be added *after* the type has been installed
  	# into the library.
  	#
  	# XXX: maybe we can use it if the coercion is frozen???
  	#
  	*{"$class\::$name"}        = $class->_mksub($type);
  	*{"$class\::is_$name"}     = _subname "is_"    .$type->qualified_name, $type->compiled_check;
  	*{"$class\::to_$name"}     = _subname "to_"    .$type->qualified_name, sub ($) { $type->coerce($_[0]) };
  	*{"$class\::assert_$name"} = _subname "assert_".$type->qualified_name, $type->_overload_coderef;
  	
  	return $type;
  }
  
  sub get_type
  {
  	my $meta = shift->meta;
  	$meta->{types}{$_[0]};
  }
  
  sub has_type
  {
  	my $meta = shift->meta;
  	exists $meta->{types}{$_[0]};
  }
  
  sub type_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{types} };
  }
  
  sub add_coercion
  {
  	require Type::Coercion;
  	my $meta = shift->meta;
  	my $c    = blessed($_[0]) ? $_[0] : "Type::Coercion"->new(@_);
  	my $name = $c->name;
  
  	$meta->{coercions} ||= {};
  	_croak 'Coercion %s already exists in this library', $name if $meta->has_coercion($name);
  	_croak 'Coercion %s conflicts with type of same name', $name if $meta->has_type($name);
  	_croak 'Cannot add anonymous type to a library' if $c->is_anon;
  	$meta->{coercions}{$name} = $c;
  
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	my $class = blessed($meta);
  	*{"$class\::$name"} = $class->_mksub($c);
  	
  	return $c;
  }
  
  sub get_coercion
  {
  	my $meta = shift->meta;
  	$meta->{coercions}{$_[0]};
  }
  
  sub has_coercion
  {
  	my $meta = shift->meta;
  	exists $meta->{coercions}{$_[0]};
  }
  
  sub coercion_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{coercions} };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX::Types-like
  
  =head1 NAME
  
  Type::Library - tiny, yet Moo(se)-compatible type libraries
  
  =head1 SYNOPSIS
  
     package Types::Mine {
        use Scalar::Util qw(looks_like_number);
        use Type::Library -base;
        use Type::Tiny;
        
        my $NUM = "Type::Tiny"->new(
           name       => "Number",
           constraint => sub { looks_like_number($_) },
           message    => sub { "$_ ain't a number" },
        );
        
        __PACKAGE__->meta->add_type($NUM);
     }
        
     package Ermintrude {
        use Moo;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Bullwinkle {
        use Moose;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Maisy {
        use Mouse;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Library> is a tiny class for creating MooseX::Types-like type
  libraries which are compatible with Moo, Moose and Mouse.
  
  If you're reading this because you want to create a type library, then
  you're probably better off reading L<Type::Tiny::Manual::Libraries>.
  
  =head2 Methods
  
  A type library is a singleton class. Use the C<meta> method to get a blessed
  object which other methods can get called on. For example:
  
     Types::Mine->meta->add_type($foo);
  
  =begin trustme
  
  =item meta
  
  =end trustme
  
  =over
  
  =item C<< add_type($type) >> or C<< add_type(%opts) >>
  
  Add a type to the library. If C<< %opts >> is given, then this method calls
  C<< Type::Tiny->new(%opts) >> first, and adds the resultant type.
  
  Adding a type named "Foo" to the library will automatically define four
  functions in the library's namespace:
  
  =over
  
  =item C<< Foo >>
  
  Returns the Type::Tiny object.
  
  =item C<< is_Foo($value) >>
  
  Returns true iff $value passes the type constraint.
  
  =item C<< assert_Foo($value) >>
  
  Returns $value iff $value passes the type constraint. Dies otherwise.
  
  =item C<< to_Foo($value) >>
  
  Coerces the value to the type.
  
  =back
  
  =item C<< get_type($name) >>
  
  Gets the C<Type::Tiny> object corresponding to the name.
  
  =item C<< has_type($name) >>
  
  Boolean; returns true if the type exists in the library.
  
  =item C<< type_names >>
  
  List all types defined by the library.
  
  =item C<< add_coercion($c) >> or C<< add_coercion(%opts) >>
  
  Add a standalone coercion to the library. If C<< %opts >> is given, then
  this method calls C<< Type::Coercion->new(%opts) >> first, and adds the
  resultant coercion.
  
  Adding a coercion named "FooFromBar" to the library will automatically
  define a function in the library's namespace:
  
  =over
  
  =item C<< FooFromBar >>
  
  Returns the Type::Coercion object.
  
  =back
  
  =item C<< get_coercion($name) >>
  
  Gets the C<Type::Coercion> object corresponding to the name.
  
  =item C<< has_coercion($name) >>
  
  Boolean; returns true if the coercion exists in the library.
  
  =item C<< coercion_names >>
  
  List all standalone coercions defined by the library.
  
  =item C<< import(@args) >>
  
  Type::Library-based libraries are exporters.
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< NICE_PROTOTYPES >>
  
  If this is true, then Type::Library will give parameterizable type constraints
  slightly the nicer prototype of C<< (;$) >> instead of the default C<< (;@) >>.
  This allows constructs like:
  
     ArrayRef[Int] | HashRef[Int]
  
  ... to "just work". Sadly, this constant is false on Perl < 5.14, and
  expressions like the above need lots of parentheses to do what you mean.
  
  =back
  
  =head2 Export
  
  Type libraries are exporters. For the purposes of the following examples,
  assume that the C<Types::Mine> library defines types C<Number> and C<String>.
  
     # Exports nothing.
     # 
     use Types::Mine;
     
     # Exports a function "String" which is a constant returning
     # the String type constraint.
     #
     use Types::Mine qw( String );
     
     # Exports both String and Number as above.
     #
     use Types::Mine qw( String Number );
     
     # Same.
     #
     use Types::Mine qw( :types );
     
     # Exports a sub "is_String" so that "is_String($foo)" is equivalent
     # to "String->check($foo)".
     #
     use Types::Mine qw( is_String );
     
     # Exports "is_String" and "is_Number".
     #
     use Types::Mine qw( :is );
     
     # Exports a sub "assert_String" so that "assert_String($foo)" is
     # equivalent to "String->assert_return($foo)".
     #
     use Types::Mine qw( assert_String );
     
     # Exports "assert_String" and "assert_Number".
     #
     use Types::Mine qw( :assert );
     
     # Exports a sub "to_String" so that "to_String($foo)" is equivalent
     # to "String->coerce($foo)".
     #
     use Types::Mine qw( to_String );
     
     # Exports "to_String" and "to_Number".
     #
     use Types::Mine qw( :to );
     
     # Exports "String", "is_String", "assert_String" and "coerce_String".
     #
     use Types::Mine qw( +String );
     
     # Exports everything.
     #
     use Types::Mine qw( :all );
  
  Type libraries automatically inherit from L<Exporter::Tiny>; see the
  documentation of that module for tips and tricks importing from libraries.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_LIBRARY

$fatpacked{"Type/Params.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARAMS';
  package Type::Params;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Params::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Params::VERSION   = '0.038';
  }
  
  use B qw();
  use Eval::TypeTiny;
  use Scalar::Util qw(refaddr);
  use Error::TypeTiny;
  use Error::TypeTiny::Assertion;
  use Error::TypeTiny::WrongNumberOfParameters;
  use Type::Tiny::Union;
  use Types::Standard -types;
  use Types::TypeTiny qw(CodeLike ArrayLike to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  our @EXPORT = qw( compile );
  our @EXPORT_OK = qw( multisig validate Invocant );
  
  BEGIN {
  	my $Invocant = 'Type::Tiny::Union'->new(
  		name             => 'Invocant',
  		type_constraints => [Object, ClassName],
  	);
  	sub Invocant () { $Invocant };
  };
  
  sub _mkslurpy
  {
  	my ($name, $type, $tc, $i) = @_;
  	$name = 'local $_' if $name eq '$_';
  	
  	$type eq '@'
  		? sprintf(
  			'%s = [ @_[%d..$#_] ];',
  			$name,
  			$i,
  		)
  		: sprintf(
  			'%s = (($#_-%d)%%2)==0 ? "Error::TypeTiny::WrongNumberOfParameters"->throw(message => sprintf("Odd number of elements in %%s", %s)) : +{ @_[%d..$#_] };',
  			$name,
  			$i,
  			B::perlstring("$tc"),
  			$i,
  			$i,
  		);
  }
  
  sub compile
  {
  	my (@code, %env);
  	@code = 'my (@R, %tmp, $tmp);';
  	push @code, '#placeholder';   # $code[1]
  	
  	my %options    = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my $arg        = -1;
  	my $saw_slurpy = 0;
  	my $min_args   = 0;
  	my $max_args   = 0;
  	my $saw_opt    = 0;
  	
  	while (@_)
  	{
  		++$arg;
  		my $constraint = shift;
  		my $is_optional;
  		my $is_slurpy;
  		my $varname;
  		
  		if (Bool->check($constraint))
  		{
  			$constraint = $constraint ? Any : Optional[Any];
  		}
  		
  		if (HashRef->check($constraint))
  		{
  			$constraint = to_TypeTiny($constraint->{slurpy});
  			push @code,
  				$constraint->is_a_type_of(Dict)     ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Map)      ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Tuple)    ? _mkslurpy('$_', '@', $constraint => $arg) :
  				$constraint->is_a_type_of(HashRef)  ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(ArrayRef) ? _mkslurpy('$_', '@', $constraint => $arg) :
  				Error::TypeTiny::croak("Slurpy parameter not of type HashRef or ArrayRef");
  			$varname = '$_';
  			$is_slurpy++;
  			$saw_slurpy++;
  		}
  		else
  		{
  			Error::TypeTiny::croak("Parameter following slurpy parameter") if $saw_slurpy;
  			
  			$is_optional = grep $_->{uniq} == Optional->{uniq}, $constraint->parents;
  			
  			if ($is_optional)
  			{
  				push @code, sprintf 'return @R if $#_ < %d;', $arg;
  				$saw_opt++;
  				$max_args++;
  			}
  			else
  			{
  				Error::TypeTiny::croak("Non-Optional parameter following Optional parameter") if $saw_opt;
  				$min_args++;
  				$max_args++;
  			}
  			
  			$varname = sprintf '$_[%d]', $arg;
  		}
  		
  		if ($constraint->has_coercion and $constraint->coercion->can_be_inlined)
  		{
  			push @code, sprintf(
  				'$tmp%s = %s;',
  				($is_optional ? '{x}' : ''),
  				$constraint->coercion->inline_coercion($varname)
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		elsif ($constraint->has_coercion)
  		{
  			$env{'@coerce'}[$arg] = $constraint->coercion->compiled_coercion;
  			push @code, sprintf(
  				'$tmp%s = $coerce[%d]->(%s);',
  				($is_optional ? '{x}' : ''),
  				$arg,
  				$varname,
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		
  		if ($constraint->can_be_inlined)
  		{
  			push @code, sprintf(
  				'(%s) or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				$constraint->inline_check($varname),
  				$constraint->{uniq},
  				B::perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		else
  		{
  			$env{'@check'}[$arg] = $constraint->compiled_check;
  			push @code, sprintf(
  				'%s or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				sprintf(sprintf '$check[%d]->(%s)', $arg, $varname),
  				$constraint->{uniq},
  				B::perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		
  		push @code, sprintf 'push @R, %s;', $varname;
  	}
  	
  	if ($min_args == $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ != %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  		);
  	}
  	elsif ($min_args < $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ < %d || @_ > %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  			$max_args,
  		);
  	}
  	elsif ($min_args and $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d) if @_ < %d;',
  			$min_args,
  			$min_args,
  		);
  	}
  	
  	push @code, '@R;';
  	
  	my $source  = "sub { no warnings; ".join("\n", @code)." };";
  	
  	return $source if $options{want_source};
  	
  	my $closure = eval_closure(
  		source      => $source,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => \%env,
  	);
  	
  	return {
  		min_args   => $min_args,
  		max_args   => $saw_slurpy ? undef : $max_args,
  		closure    => $closure,
  	} if $options{want_details};
  	
  	return $closure;
  }
  
  my %compiled;
  sub validate
  {
  	my $arr = shift;
  	my $sub = $compiled{ join ":", map($_->{uniq}||"\@$_->{slurpy}", @_) } ||= compile({ caller_level => 1 }, @_);
  	@_ = @$arr;
  	goto $sub;
  }
  
  sub multisig
  {
  	my %options = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my @multi = map {
  		CodeLike->check($_)  ? { closure => $_ } :
  		ArrayLike->check($_) ? compile({ want_details => 1 }, @$_) :
  		$_;
  	} @_;
  	
  	my @code = 'sub { my $r; ';
  	
  	for my $i (0 .. $#multi)
  	{
  		my $sig = $multi[$i];
  		my @cond;
  		push @cond, sprintf('@_ >= %s', $sig->{min_args}) if defined $sig->{min_args};
  		push @cond, sprintf('@_ <= %s', $sig->{max_args}) if defined $sig->{max_args};
  		push @code, sprintf('if (%s){', join(' and ', @cond)) if @cond;
  		push @code, sprintf('eval { $r = [ $multi[%d]{closure}->(@_) ] };', $i);
  		push @code, 'return(@$r) if $r;';
  		push @code, '}' if @cond;
  	}
  	
  	push @code, '"Error::TypeTiny"->throw(message => "Parameter validation failed");';
  	push @code, '}';
  	
  	eval_closure(
  		source      => \@code,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => { '@multi' => \@multi },
  	);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords evals
  
  =head1 NAME
  
  Type::Params - Params::Validate-like parameter validation using Type::Tiny type constraints and coercions
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Params qw( compile );
   use Types::Standard qw( slurpy Str ArrayRef Num );
     
   sub deposit_monies
   {
      state $check = compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      my $account = Local::BankAccount->new($sort_code, $account_number);
      $account->deposit($_) for @$monies;
   }
   
   deposit_monies("12-34-56", "11223344", 1.2, 3, 99.99);
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type::Params uses L<Type::Tiny> constraints to validate the parameters to a
  sub. It takes the slightly unorthodox approach of separating validation
  into two stages:
  
  =over
  
  =item 1.
  
  Compiling the parameter specification into a coderef; then
  
  =item 2.
  
  Using the coderef to validate parameters.
  
  =back
  
  The first stage is slow (it might take a couple of milliseconds), but you
  only need to do it the first time the sub is called. The second stage is
  fast; according to my benchmarks faster even than the XS version of
  L<Params::Validate>.
  
  If you're using a modern version of Perl, you can use the C<state> keyword
  which was a feature added to Perl in 5.10. If you're stuck on Perl 5.8, the
  example from the SYNOPSIS could be rewritten as:
  
   my $deposit_monies_check;
   sub deposit_monies
   {
      $deposit_monies_check ||= compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      ...;
   }
  
  Not quite as neat, but not awful either.
  
  There's a shortcut reducing it to one step:
  
   use Type::Params qw( validate );
   
   sub deposit_monies
   {
      my ($sort_code, $account_number, $monies) = 
         validate( \@_, Str, Str, slurpy ArrayRef[Num] );
      
      ...;
   }
  
  Type::Params has a few tricks up its sleeve to make sure performance doesn't
  suffer too much with the shortcut, but it's never going to be as fast as the
  two stage compile/execute.
  
  =begin trustme
  
  Dude, these functions are documented!
  
  =item compile
  
  =item validate
  
  =item Invocant
  
  =item multisig
  
  =end trustme
  
  =head1 COOKBOOK
  
  =head2 Positional Parameters
  
     sub nth_root
     {
        state $check = compile( Num, Num );
        my ($x, $n) = $check->(@_);
        
        return $x ** (1 / $n);
     }
  
  =head2 Method Calls
  
  Type::Params exports an additional keyword C<Invocant> on request. This is
  a type constraint accepting blessed objects and also class names.
  
     use Types::Standard qw( ClassName Object Str Int );
     use Type::Params qw( compile Invocant );
     
     # a class method
     sub new_from_json
     {
        state $check = compile( ClassName, Str );
        my ($class, $json) = $check->(@_);
        
        $class->new( from_json($json) );
     }
     
     # an object method
     sub dump
     {
        state $check = compile( Object, Int );
        my ($self, $limit) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     # can be called as either and object or class method
     sub run
     {
        state $check = compile( Invocant );
        my ($proto) = $check->(@_);
        
        my $self = ref($proto) ? $proto : $default_instance;
        $self->_run;
     }
  
  =head2 Optional Parameters
  
     use Types::Standard qw( Object Optional Int );
     
     sub dump
     {
        state $check = compile( Object, Optional[Int] );
        my ($self, $limit) = $check->(@_);
        $limit //= 0;
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     $obj->dump(1);      # ok
     $obj->dump();       # ok
     $obj->dump(undef);  # dies
  
  =head2 Slurpy Parameters
  
     use Types::Standard qw( slurpy ClassName HashRef );
     
     sub new
     {
        state $check = compile( ClassName, slurpy HashRef );
        my ($class, $ref) = $check->(@_);
        bless $ref => $class;
     }
     
     __PACKAGE__->new(foo => 1, bar => 2);
  
  The following types from L<Types::Standard> can be made slurpy:
  C<ArrayRef>, C<Tuple>, C<HashRef>, C<Map>, C<Dict>. Hash-like types
  will die if an odd number of elements are slurped in.
  
  A check may only have one slurpy parameter, and it must be the last
  parameter.
  
  =head2 Named Parameters
  
  Just use a slurpy C<Dict>:
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub dump
     {
        state $check = compile(
           slurpy Dict[
              var    => Ref,
              limit  => Optional[Int],
           ],
        );
        my ($arg) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $arg->{limit};
        print Data::Dumper::Dumper($arg->{var});
     }
     
     dump(var => $foo, limit => 1);   # ok
     dump(var => $foo);               # ok
     dump(limit => 1);                # dies
  
  =head2 Mixed Positional and Named Parameters
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub my_print
     {
        state $check = compile(
           Str,
           slurpy Dict[
              colour => Optional[Str],
              size   => Optional[Int],
           ],
        );
        my ($string, $arg) = $check->(@_);
     }
     
     my_print("Hello World", colour => "blue");
  
  =head2 Coercions
  
  Coercions will automatically be applied for I<all> type constraints that have
  a coercion associated.
  
     use Type::Utils;
     use Types::Standard qw( Int Num );
     
     my $RoundedInt = declare as Int;
     coerce $RoundedInt, from Num, q{ int($_) };
     
     sub set_age
     {
        state $check = compile( Object, $RoundedInt );
        my ($self, $age) = $check->(@_);
        
        $self->{age} = $age;
     }
     
     $obj->set_age(32.5);   # ok; coerced to "32".
  
  Coercions carry over into structured types such as C<ArrayRef> automatically:
  
     sub delete_articles
     {
        state $check = compile( Object, slurpy ArrayRef[$RoundedInt] );
        my ($db, $articles) = $check->(@_);
        
        $db->select_article($_)->delete for @$articles;
     }
     
     # delete articles 1, 2 and 3
     delete_articles($my_db, 1.1, 2.2, 3.3);
  
  If type C<Foo> has coercions from C<Str> and C<ArrayRef> and you want to
  B<prevent> coercion, then use:
  
     state $check = compile( Foo->no_coercions );
  
  Or if you just want to prevent coercion from C<Str>, use:
  
     state $check = compile( Foo->minus_coercions(Str) );
  
  Or maybe add an extra coercion:
  
     state $check = compile(
        Foo->plus_coercions(Int, q{ Foo->new_from_number($_) }),
     );
  
  Note that the coercion is specified as a string of Perl code. This is usually
  the fastest way to do it, but a coderef is also accepted. Either way, the
  value to be coerced is C<< $_ >>.
  
  =head2 Alternatives
  
  Type::Params can export a C<multisig> function that compiles multiple
  alternative signatures into one, and uses the first one that works:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        [ HashRef, Num ],
        [ CodeRef ],
     );
     
     my ($int, $arrayref) = $check->( 1, [] );
     my ($hashref, $num)  = $check->( {}, 1.1 );
     my ($code)           = $check->( sub { 1 } );
     
     $check->( sub { 1 }, 1.1 );  # throws an exception
  
  Coercions, slurpy parameters, etc still work.
  
  There's currently no indication of which of the multiple signatures
  succeeded.
  
  The present implementation involves compiling each signature independently,
  and trying them each (in their given order!) in an C<eval> block. The only
  slightly intelligent part is that it checks if C<< scalar(@_) >> fits into
  the signature properly (taking into account optional and slurpy parameters),
  and skips evals which couldn't possibly succeed.
  
  It's also possible to list coderefs as alternatives in C<multisig>:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        sub { ... },
        [ HashRef, Num ],
        [ CodeRef ],
     );
  
  The coderef is expected to die if that alternative should be abandoned (and
  the next alternative tried), or return the list of accepted parameters. Here's
  a full example:
  
     sub get_from {
        state $check = multisig(
           [ Int, ArrayRef ],
           [ Str, HashRef ],
           sub {
              my ($meth, $obj);
              die unless is_Object($obj);
              die unless $obj->can($meth);
              return ($meth, $obj);
           },
        );
        my ($needle, $haystack) = $check->(@_);
        
        is_HashRef($haystack)  ? $haystack->{$needle} :
        is_ArrayRef($haystack) ? $haystack->[$needle] :
        is_Object($haystack)   ? $haystack->$needle   :
        die;
     }
     
     get_from(0, \@array);      # returns $array[0]
     get_from('foo', \%hash);   # returns $hash{foo}
     get_from('foo', $obj);     # returns $obj->foo
  
  =head1 COMPARISON WITH PARAMS::VALIDATE
  
  L<Type::Params> is not really a drop-in replacement for L<Params::Validate>;
  the API differs far too much to claim that. Yet it performs a similar task,
  so it makes sense to compare them.
  
  =over
  
  =item *
  
  Type::Params will tend to be faster if you've got a sub which is called
  repeatedly, but may be a little slower than Params::Validate for subs that
  are only called a few times. This is because it does a bunch of work the
  first time your sub is called to make subsequent calls a lot faster.
  
  =item *
  
  Type::Params is mostly geared towards positional parameters, while
  Params::Validate seems to be primarily aimed at named parameters. (Though
  either works for either.) Params::Validate doesn't appear to have a
  particularly natural way of validating a mix of positional and named
  parameters.
  
  =item *
  
  Type::Utils allows you to coerce parameters. For example, if you expect
  a L<Path::Tiny> object, you could coerce it from a string.
  
  =item *
  
  Params::Validate allows you to supply defaults for missing parameters;
  Type::Params does not, but you may be able to use coercion from Undef.
  
  =item *
  
  If you are primarily writing object-oriented code, using Moose or similar,
  and you are using Type::Tiny type constraints for your attributes, then
  using Type::Params allows you to use the same constraints for method calls.
  
  =item *
  
  Type::Params comes bundled with Types::Standard, which provides a much
  richer vocabulary of types than the type validation constants that come
  with Params::Validate. For example, Types::Standard provides constraints
  like C<< ArrayRef[Int] >> (an arrayref of integers), while the closest from
  Params::Validate is C<< ARRAYREF >>, which you'd need to supplement with
  additional callbacks if you wanted to check that the arrayref contained
  integers.
  
  Whatsmore, Type::Params doesn't just work with Types::Standard, but also
  any other Type::Tiny type constraints.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>, L<Type::Coercion>, L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARAMS

$fatpacked{"Type/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARSER';
  package Type::Parser;
  
  use strict;
  use warnings;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  
  # Token types
  # 
  sub TYPE      () { "TYPE" };
  sub QUOTELIKE () { "QUOTELIKE" };
  sub STRING    () { "STRING" };
  sub CLASS     () { "CLASS" };
  sub L_BRACKET () { "L_BRACKET" };
  sub R_BRACKET () { "R_BRACKET" };
  sub COMMA     () { "COMMA" };
  sub SLURPY    () { "SLURPY" };
  sub UNION     () { "UNION" };
  sub INTERSECT () { "INTERSECT" };
  sub NOT       () { "NOT" };
  sub L_PAREN   () { "L_PAREN" };
  sub R_PAREN   () { "R_PAREN" };
  sub MYSTERY   () { "MYSTERY" };
  
  our @EXPORT_OK = qw( eval_type _std_eval parse );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  Evaluate: {
  	
  	sub parse
  	{
  		my $str = $_[0];
  		my $parser = "Type::Parser::AstBuilder"->new(input => $str);
  		$parser->build;
  		wantarray ? ($parser->ast, $parser->remainder) : $parser->ast;
  	}
  	
  	sub extract_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		wantarray ? (_eval_type($parsed, $reg), $tail) : _eval_type($parsed, $reg);
  	}
  	
  	sub eval_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		_croak("Unexpected tail on type expression: $tail") if $tail =~ /\S/sm;
  		return _eval_type($parsed, $reg);
  	}
  	
  	my $std;
  	sub _std_eval
  	{
  		require Type::Registry;
  		unless ($std)
  		{
  			$std = "Type::Registry"->new;
  			$std->add_types(-Standard);
  		}
  		eval_type($_[0], $std);
  	}
  	
  	sub _eval_type
  	{
  		my ($node, $reg) = @_;
  		
  		$node = _simplify_expression($node);
  		
  		if ($node->{type} eq "list")
  		{
  			return map _eval_type($_, $reg), @{$node->{list}};
  		}
  		
  		if ($node->{type} eq "union")
  		{
  			require Type::Tiny::Union;
  			return "Type::Tiny::Union"->new(
  				type_constraints => [ map _eval_type($_, $reg), @{$node->{union}} ],
  			);
  		}
  		
  		if ($node->{type} eq "intersect")
  		{
  			require Type::Tiny::Intersection;
  			return "Type::Tiny::Intersection"->new(
  				type_constraints => [ map _eval_type($_, $reg), @{$node->{intersect}} ],
  			);
  		}
  		
  		if ($node->{type} eq "slurpy")
  		{
  			return +{ slurpy => _eval_type($node->{of}, $reg) };
  		}
  		
  		if ($node->{type} eq "complement")
  		{
  			return _eval_type($node->{of}, $reg)->complementary_type;
  		}
  		
  		if ($node->{type} eq "parameterized")
  		{
  			my $base = _eval_type($node->{base}, $reg);
  			
  			return $base unless $base->is_parameterizable || $node->{params};
  			return $base->parameterize($node->{params} ? _eval_type($node->{params}, $reg) : ());
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq CLASS)
  		{
  			my $class = substr($node->{token}->spelling, 0, length($node->{token}->spelling) - 2);
  			require Type::Tiny::Class;
  			return "Type::Tiny::Class"->new(class => $class);
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq QUOTELIKE)
  		{
  			return eval($node->{token}->spelling); #ARGH
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq STRING)
  		{
  			return $node->{token}->spelling;
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq TYPE)
  		{
  			my $t = $node->{token}->spelling;
  			my $r;
  			if ($t =~ /^(.+)::(\w+)$/)
  			{
  				require Types::TypeTiny;
  				my $library = $1; $t = $2;
  				eval "require $library;";
  				$r =
  					$library->isa('MooseX::Types::Base')  ? Types::TypeTiny::to_TypeTiny(Moose::Util::TypeConstraints::find_type_constraint($library->get_type($t))) :
  					$library->can("get_type")             ? $library->get_type($t) :
  					$reg->simple_lookup("$library\::$t", 1);
  				}
  			else
  			{
  				$r = $reg->simple_lookup($t, 1);
  			}
  			$r or _croak("%s is not a known type constraint", $node->{token}->spelling);
  			return $r;
  		}
  	}
  	
  	sub _simplify_expression
  	{
  		my $expr = shift;
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq COMMA)
  		{
  			return _simplify("list", COMMA, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq UNION)
  		{
  			return _simplify("union", UNION, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq INTERSECT)
  		{
  			return _simplify("intersect", INTERSECT, $expr);
  		}
  		
  		return $expr;
  	}
  	
  	sub _simplify
  	{
  		my $type = shift;
  		my $op   = shift;
  		
  		my @list;
  		for my $expr ($_[0]{lhs}, $_[0]{rhs})
  		{
  			if ($expr->{type} eq "expression" and $expr->{op}[0] eq $op)
  			{
  				my $simple = _simplify($type, $op, $expr);
  				push @list, @{ $simple->{$type} };
  			}
  			else
  			{
  				push @list, $expr;
  			}
  		}
  		
  		return { type => $type, $type => \@list };
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::AstBuilder;
  	
  	sub new
  	{
  		my $class = shift;
  		bless { @_ }, $class;
  	}
  	
  	our %precedence = (
  #		Type::Parser::COMMA()     , 1 ,
  		Type::Parser::UNION()     , 2 ,
  		Type::Parser::INTERSECT() , 3 ,
  		Type::Parser::NOT()       , 4 ,
  	);
  	
  	sub _parse_primary
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		$tokens->assert_not_empty;
  		
  		if ($tokens->peek(0)->type eq Type::Parser::NOT)
  		{
  			$tokens->eat(Type::Parser::NOT);
  			$tokens->assert_not_empty;
  			return {
  				type  => "complement",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::SLURPY)
  		{
  			$tokens->eat(Type::Parser::SLURPY);
  			$tokens->assert_not_empty;
  			return {
  				type  => "slurpy",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::L_PAREN)
  		{
  			$tokens->eat(Type::Parser::L_PAREN);
  			my $r = $self->_parse_expression;
  			$tokens->eat(Type::Parser::R_PAREN);
  			return $r;
  		}
  		
  		if ($tokens->peek(1)
  		and $tokens->peek(0)->type eq Type::Parser::TYPE
  		and $tokens->peek(1)->type eq Type::Parser::L_BRACKET)
  		{
  			my $base = { type  => "primary", token => $tokens->eat(Type::Parser::TYPE) };
  			$tokens->eat(Type::Parser::L_BRACKET);
  			$tokens->assert_not_empty;
  			
  			local $precedence{ Type::Parser::COMMA() } = 1;
  			
  			my $params = undef;
  			if ($tokens->peek(0)->type eq Type::Parser::R_BRACKET)
  			{
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			else
  			{
  				$params = $self->_parse_expression;
  				$params = { type => "list", list => [$params] } unless $params->{type} eq "list";
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			return {
  				type   => "parameterized",
  				base   => $base,
  				params => $params,
  			};
  		}
  		
  		my $type = $tokens->peek(0)->type;
  		if ($type eq Type::Parser::TYPE
  		or  $type eq Type::Parser::QUOTELIKE
  		or  $type eq Type::Parser::STRING
  		or  $type eq Type::Parser::CLASS)
  		{
  			return { type  => "primary", token => $tokens->eat };
  		}
  		
  		Type::Parser::_croak("Unexpected token in primary type expression; got '%s'", $tokens->peek(0)->spelling);
  	}
  	
  	sub _parse_expression_1
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		my ($lhs, $min_p) = @_;
  		while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} >= $min_p)
  		{
  			my $op  = $tokens->eat;
  			my $rhs = $self->_parse_primary;
  			
  			while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} > $precedence{$op->type})
  			{
  				my $lookahead = $tokens->peek(0);
  				$rhs = $self->_parse_expression_1($rhs, $precedence{$lookahead->type});
  			}
  			
  			$lhs = {
  				type => "expression",
  				op   => $op,
  				lhs  => $lhs,
  				rhs  => $rhs,
  			};
  		}
  		return $lhs;
  	}
  	
  	sub _parse_expression
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		return $self->_parse_expression_1($self->_parse_primary, 0);
  	}
  	
  	sub build
  	{
  		my $self = shift;
  		$self->{tokens} = "Type::Parser::TokenStream"->new(remaining => $self->{input});
  		$self->{ast}    = $self->_parse_expression;
  	}
  	
  	sub ast
  	{
  		$_[0]{ast};
  	}
  	
  	sub remainder
  	{
  		$_[0]{tokens}->remainder;
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::Token;
  	sub type     { $_[0][0] }
  	sub spelling { $_[0][1] }
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::TokenStream;
  	
  	use Scalar::Util qw(looks_like_number);
  	use Text::Balanced qw(extract_quotelike);
  	
  	sub new
  	{
  		my $class = shift;
  		bless { stack => [], done => [], @_ }, $class;
  	}
  	
  	sub peek
  	{
  		my $self  = shift;
  		my $ahead = $_[0];
  		
  		while ($self->_stack_size <= $ahead and length $self->{remaining})
  		{
  			$self->_stack_extend;
  		}
  		
  		my @tokens = grep ref, @{ $self->{stack} };
  		return $tokens[$ahead];
  	}
  	
  	sub empty
  	{
  		my $self = shift;
  		not $self->peek(0);
  	}
  	
  	sub eat
  	{
  		my $self = shift;
  		$self->_stack_extend unless $self->_stack_size;
  		my $r;
  		while (defined(my $item = shift @{$self->{stack}}))
  		{
  			push @{ $self->{done} }, $item;
  			if (ref $item)
  			{
  				$r = $item;
  				last;
  			}
  		}
  		
  		if (@_ and $_[0] ne $r->type)
  		{
  			unshift @{$self->{stack}}, pop @{$self->{done}};
  			Type::Parser::_croak("Expected $_[0]; got ".$r->type);
  		}
  		
  		return $r;
  	}
  	
  	sub assert_not_empty
  	{
  		my $self = shift;
  		Type::Parser::_croak("Expected token; got empty string") if $self->empty;
  	}
  	
  	sub _stack_size
  	{
  		my $self = shift;
  		scalar grep ref, @{ $self->{stack} };
  	}
  	
  	sub _stack_extend
  	{
  		my $self = shift;
  		push @{ $self->{stack} }, $self->_read_token;
  		my ($space) = ($self->{remaining} =~ m/^([\s\n\r]*)/sm);
  		return unless length $space;
  		push @{ $self->{stack} }, $space;
  		substr($self->{remaining}, 0, length $space) = "";
  	}
  	
  	sub remainder
  	{
  		my $self = shift;
  		return join "",
  			map { ref($_) ? $_->spelling : $_ }
  			(@{$self->{stack}}, $self->{remaining})
  	}
  	
  	my %punctuation = (
  		'['       => bless([ Type::Parser::L_BRACKET, "[" ], "Type::Parser::Token"),
  		']'       => bless([ Type::Parser::R_BRACKET, "]" ], "Type::Parser::Token"),
  		'('       => bless([ Type::Parser::L_PAREN,   "[" ], "Type::Parser::Token"),
  		')'       => bless([ Type::Parser::R_PAREN,   "]" ], "Type::Parser::Token"),
  		','       => bless([ Type::Parser::COMMA,     "," ], "Type::Parser::Token"),
  		'=>'      => bless([ Type::Parser::COMMA,     "=>" ], "Type::Parser::Token"),
  		'slurpy'  => bless([ Type::Parser::SLURPY,    "slurpy" ], "Type::Parser::Token"),
  		'|'       => bless([ Type::Parser::UNION,     "|" ], "Type::Parser::Token"),
  		'&'       => bless([ Type::Parser::INTERSECT, "&" ], "Type::Parser::Token"),
  		'~'       => bless([ Type::Parser::NOT,       "~" ], "Type::Parser::Token"),
  	);
  	
  	sub _read_token
  	{
  		my $self = shift;
  		
  		return if $self->{remaining} eq "";
  		
  		# Punctuation
  		# 
  		
  		if ($self->{remaining} =~ /^( => | [()\]\[|&~,] )/xsm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			return $punctuation{$spelling};
  		}
  		
  		if (my $quotelike = extract_quotelike $self->{remaining})
  		{
  			return bless([ Type::Parser::QUOTELIKE, $quotelike ], "Type::Parser::Token"),;
  		}
  		
  		if ($self->{remaining} =~ /^([+-]?[\w:.+]+)/sm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			
  			if ($spelling =~ /::$/sm)
  			{
  				return bless([ Type::Parser::CLASS, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif (looks_like_number($spelling))
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($self->{remaining} =~ /^\s*=>/sm) # peek ahead
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($spelling eq "slurpy")
  			{
  				return $punctuation{$spelling};
  			}
  			
  			return bless([ Type::Parser::TYPE, $spelling ], "Type::Parser::Token");
  		}
  		
  		my $rest = $self->{remaining};
  		$self->{remaining} = "";
  		return bless([ Type::Parser::MYSTERY, $rest ], "Type::Parser::Token");
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords non-whitespace
  
  =head1 NAME
  
  Type::Parser - parse type constraint strings
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Parser qw( eval_type );
   use Type::Registry;
   
   my $reg = Type::Registry->for_me;
   $reg->add_types("Types::Standard");
   
   my $type = eval_type("Int | ArrayRef[Int]", $reg);
   
   $type->check(10);        # true
   $type->check([1..4]);    # true
   $type->check({foo=>1});  # false
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Generally speaking, you probably don't want to be using this module directly.
  Instead use the C<< lookup >> method from L<Type::Registry> which wraps it.
  
  =head2 Functions
  
  =over
  
  =item C<< parse($string) >>
  
  Parse the type constraint string into something like an AST.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< extract_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< eval_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  Throws an error if the "tail" contains any non-whitespace character.
  
  =back
  
  =head2 Constants
  
  The following constants correspond to values returned by C<< $token->type >>.
  
  =over
  
  =item C<< TYPE >>
  
  =item C<< QUOTELIKE >>
  
  =item C<< STRING >>
  
  =item C<< CLASS >>
  
  =item C<< L_BRACKET >>
  
  =item C<< R_BRACKET >>
  
  =item C<< COMMA >>
  
  =item C<< SLURPY >>
  
  =item C<< UNION >>
  
  =item C<< INTERSECT >>
  
  =item C<< NOT >>
  
  =item C<< L_PAREN >>
  
  =item C<< R_PAREN >>
  
  =item C<< MYSTERY >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Registry>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARSER

$fatpacked{"Type/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_REGISTRY';
  package Type::Registry;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Registry::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Registry::VERSION   = '0.038';
  }
  
  use Exporter::Tiny qw( mkopt );
  use Scalar::Util qw( refaddr );
  use Type::Parser qw( eval_type );
  use Types::TypeTiny qw( CodeLike ArrayLike to_TypeTiny );
  
  our @ISA = 'Exporter::Tiny';
  our @EXPORT_OK = qw(t);
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	
  	if ($name eq "t")
  	{
  		my $caller = $globals->{into};
  		my $reg = $class->for_class(
  			ref($caller) ? sprintf('HASH(0x%08X)', refaddr($caller)) : $caller
  		);
  		return t => sub (;$) { @_ ? $reg->lookup(@_) : $reg };
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  sub new
  {
  	my $class = shift;
  	ref($class) and _croak("Not an object method");
  	bless {}, $class;
  }
  
  {
  	my %registries;
  	
  	sub for_class
  	{
  		my $class = shift;
  		my ($for) = @_;
  		$registries{$for} ||= $class->new;
  	}
  	
  	sub for_me
  	{
  		my $class = shift;
  		my $for   = caller;
  		$registries{$for} ||= $class->new;
  	}
  }
  
  sub add_types
  {
  	my $self = shift;
  	my $opts = mkopt(\@_);
  	for my $opt (@$opts)
  	{
  		my ($lib, $types) = @_;
  		
  		$lib =~ s/^-/Types::/;
  		eval "require $lib";
  		
  		my %hash;
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$types ||= [qw/-types/];
  			ArrayLike->check($types)
  				or _croak("Expected arrayref following '%s'; got %s", $lib, $types);
  			
  			$lib->import({into => \%hash}, @$types);
  			$hash{$_} = &{$hash{$_}}() for keys %hash;
  		}
  		elsif ($lib->isa("MooseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MooseX::Types type constraint library. No import options currently supported", $lib);
  			
  			require Moose::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Moose::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		elsif ($lib->isa("MouseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MouseX::Types type constraint library. No import options currently supported", $lib);
  			
  			require Mouse::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Mouse::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		else
  		{
  			_croak("%s is not a type library", $lib);
  		}
  		
  		for my $key (sort keys %hash)
  		{
  			exists($self->{$key})
  				and _croak("Duplicate type name: %s", $key);
  			$self->{$key} = $hash{$key};
  		}
  	}
  	$self;
  }
  
  sub add_type
  {
  	my $self = shift;
  	my ($type, $name) = @_;
  	$type = to_TypeTiny($type);
  	$name ||= do {
  		$type->is_anon
  			and _croak("Expected named type constraint; got anonymous type constraint");
  		$type->name;
  	};
  	
  	exists($self->{$name})
  		and _croak("Duplicate type name: %s", $name);
  	
  	$self->{$name} = $type;
  	$self;
  }
  
  sub alias_type
  {
  	my $self = shift;
  	my ($old, @new) = @_;
  	$self->{$_} = $self->{$old} for @new;
  	$self;
  }
  
  sub simple_lookup
  {
  	my $self = shift;
  	
  	my ($tc) = @_;
  	$tc =~ s/(^\s+|\s+$)//g;
  	
  	if (exists $self->{$tc})
  	{
  		return $self->{$tc};
  	}
  	
  	return;
  }
  
  sub lookup
  {
  	my $self = shift;
  	
  	$self->simple_lookup(@_) or eval_type($_[0], $self);
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  	my $type = $self->simple_lookup($method);
  	return $type if $type;
  	_croak(q[Can't locate object method "%s" via package "%s"], $method, ref($self));
  }
  
  # Prevent AUTOLOAD being called for DESTROY!
  sub DESTROY
  {
  	return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords optlist
  
  =head1 NAME
  
  Type::Registry - a glorified hashref for looking up type constraints
  
  =head1 SYNOPSIS
  
     package Foo::Bar;
     
     use Type::Registry;
     
     my $reg = "Type::Registry"->for_me;  # a registry for Foo::Bar
     
     # Register all types from Types::Standard
     $reg->add_types(-Standard);
     
     # Register just one type from Types::XSD
     $reg->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     $reg->add_types("MyApp::Types");
     
     # Create a type alias
     $reg->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = $reg->lookup("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  Alternatively:
  
     package Foo::Bar;
     
     use Type::Registry qw( t );
     
     # Register all types from Types::Standard
     t->add_types(-Standard);
     
     # Register just one type from Types::XSD
     t->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     t->add_types("MyApp::Types");
     
     # Create a type alias
     t->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = t("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head2 Changes under consideration
  
  An exception to this policy is that the following feature is being
  considered. When type constraint barewords are imported into a package
  that has a registry:
  
     use Type::Registry qw(t);
     use Types::Standard -types;
  
  Then the C<Str>, C<Num>, etc keywords imported from L<Types::Standard> will
  work fine, but C<< t->lookup("Str") >> and C<< t->lookup("Num") >> will fail,
  because importing types from a library does not automatically add them to
  your registry.
  
  Some kind of integration may be desirable between Type::Registry and
  L<Type::Library>, but exactly what form that will take is still to be
  decided.
  
  =head1 DESCRIPTION
  
  A type registry is basically just a hashref mapping type names to type
  constraint objects.
  
  =head2 Constructors
  
  =over
  
  =item C<< new >>
  
  Create a new glorified hashref.
  
  =item C<< for_class($class) >>
  
  Create or return the existing glorified hashref associated with the given
  class.
  
  =item C<< for_me >>
  
  Create or return the existing glorified hashref associated with the caller.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< add_types(@libraries) >>
  
  The libraries list is treated as an "optlist" (a la L<Data::OptList>).
  
  Strings are the names of type libraries; if the first character is a
  hyphen, it is expanded to the "Types::" prefix. If followed by an
  arrayref, this is the list of types to import from that library.
  Otherwise, imports all types from the library.
  
     use Type::Registry qw(t);
     
     t->add_types(-Standard);  # OR: t->add_types("Types::Standard");
     
     t->add_types(
        -TypeTiny => ['HashLike'],
        -Standard => ['HashRef' => { -as => 'RealHash' }],
     );
  
  L<MooseX::Types> (and experimentally, L<MouseX::Types>) libraries can
  also be added this way, but I<< cannot be followed by an arrayref of
  types to import >>.
  
  =item C<< add_type($type, $name) >>
  
  The long-awaited singular form of C<add_types>. Given a type constraint
  object, adds it to the registry with a given name. The name may be
  omitted, in which case C<< $type->name >> is called, and Type::Registry
  will throw an error if C<< $type >> is anonymous. If a name is explicitly
  given, Type::Registry cares not one wit whether the type constraint is
  anonymous.
  
  This method can even add L<MooseX::Types> and L<MouseX::Types> type
  constraints; indeed anything that can be handled by L<Types::TypeTiny>'s
  C<to_TypeTiny> function. (Bear in mind that to_TypeTiny I<always> results
  in an anonymous type constraint, so C<< $name >> will be required.)
  
  =item C<< alias_type($oldname, $newname) >>
  
  Create an alias for an existing type.
  
  =item C<< simple_lookup($name) >>
  
  Look up a type in the registry by name. 
  
  Returns undef if not found.
  
  =item C<< lookup($name) >>
  
  Look up by name, with a DSL.
  
     t->lookup("Int|ArrayRef[Int]")
  
  The DSL can be summed up as:
  
     X               type from this registry
     My::Lib::X      type from a type library
     ~X              complementary type
     X | Y           union
     X & Y           intersection
     X[...]          parameterized type
     slurpy X        slurpy type
     Foo::Bar::      class type
  
  Croaks if not found.
  
  =item C<< AUTOLOAD >>
  
  Overloaded to call C<lookup>.
  
     $registry->Str;  # like $registry->lookup("Str")
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< t >>
  
  This class can export a function C<< t >> which acts like
  C<< "Type::Registry"->for_class($importing_class) >>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Library>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_REGISTRY

$fatpacked{"Type/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY';
  package Type::Tiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::VERSION   = '0.038';
  }
  
  use Eval::TypeTiny ();
  use Scalar::Util qw( blessed weaken refaddr isweak );
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _swap { $_[2] ? @_[1,0] : @_[0,1] }
  
  BEGIN {
  	($] > 5.010001)
  		? eval q{ sub SUPPORT_SMARTMATCH () { !!0 } }
  		: eval q{ sub SUPPORT_SMARTMATCH () { !!1 } }
  }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(+)       => sub { $_[2] ? $_[1]->plus_coercions($_[0]) : $_[0]->plus_fallback_coercions($_[1]) },
  	q(|)       => sub { my @tc = _swap @_; require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@tc) },
  	q(&)       => sub { my @tc = _swap @_; require Type::Tiny::Intersection; "Type::Tiny::Intersection"->new(type_constraints => \@tc) },
  	q(~)       => sub { shift->complementary_type },
  	q(==)      => sub { $_[0]->equals($_[1]) },
  	q(<)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(_swap @_) },
  	q(>)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(reverse _swap @_) },
  	q(<=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(_swap @_) },
  	q(>=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(reverse _swap @_) },
  	q(eq)      => sub { "$_[0]" eq "$_[1]" },
  	q(cmp)     => sub { $_[2] ? ("$_[1]" cmp "$_[0]") : ("$_[0]" cmp "$_[1]") },
  	fallback   => 1,
  ;
  BEGIN {
  	overload->import(q(~~) => sub { $_[0]->check($_[1]) })
  		if Type::Tiny::SUPPORT_SMARTMATCH;
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	$self->message unless exists $self->{message};
  	
  #	if ($self->has_parent && $self->_is_null_constraint)
  #	{
  #		$self->{_overload_coderef} ||= $self->parent->_overload_coderef;
  #	}
  #	els
  	if (!exists($self->{message}) && exists(&Sub::Quote::quote_sub) && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_assert('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->assert_return(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  our %ALL_TYPES;
  
  my $QFS;
  my $uniq = 1;
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	if (exists $params{parent})
  	{
  		$params{parent} = ref($params{parent}) =~ /^Type::Tiny\b/
  			? $params{parent}
  			: Types::TypeTiny::to_TypeTiny($params{parent});
  		
  		_croak "Parent must be an instance of %s", __PACKAGE__
  			unless blessed($params{parent}) && $params{parent}->isa(__PACKAGE__);
  	}
  	
  	$params{name} = "__ANON__" unless exists $params{name};
  	$params{uniq} = $uniq++;
  	
  	if ($params{name} ne "__ANON__")
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$params{name} =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid type name', $params{name};
  	}
  	
  	if (exists $params{coercion} and !ref $params{coercion} and $params{coercion})
  	{
  		$params{parent}->has_coercion
  			or _croak "coercion => 1 requires type to have a direct parent with a coercion";
  		
  		$params{coercion} = $params{parent}->coercion;
  	}
  	
  	if (!exists $params{inlined}
  	and exists $params{constraint}
  	and ( !exists $params{parent} or $params{parent}->can_be_inlined )
  	and $QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($params{constraint}) || [] };
  		
  		$params{inlined} = sub {
  			my ($self, $var) = @_;
  			my $code = Sub::Quote::inlinify(
  				$var eq q($_) ? $perlstring : "local \$_ = $var; $perlstring",
  				$var,
  			);
  			$code = sprintf('%s and %s', $self->parent->inline_check($var), $code) if $self->has_parent;
  			return $code;
  		} if $perlstring && !$captures;
  	}
  	
  	my $self = bless \%params, $class;
  	
  	unless ($params{tmp})
  	{
  		my $uniq = $self->{uniq};
  		
  		$ALL_TYPES{$uniq} = $self;
  		weaken( $ALL_TYPES{$uniq} );
  		
  		package # no index
  			Moo::HandleMoose;
  		$Moo::HandleMoose::TYPE_MAP{$self} = sub { $ALL_TYPES{$uniq} };
  	}
  	
  	if (ref($params{coercion}) eq q(CODE))
  	{
  		require Types::Standard;
  		my $code = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(Types::Standard::Any(), $code);
  	}
  	elsif (ref($params{coercion}) eq q(ARRAY))
  	{
  		my $arr = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(@$arr);
  	}
  	
  	$self->{type_constraints} ||= undef;
  	
  	return $self;
  }
  
  sub DESTROY
  {
  	my $self = shift;
  	delete( $ALL_TYPES{$self->{uniq}} );
  	package # no index
  		Moo::HandleMoose;
  	delete( $Moo::HandleMoose::TYPE_MAP{$self} );
  	return;
  }
  
  sub _clone
  {
  	my $self = shift;
  	my %opts;
  	$opts{$_} = $self->{$_} for qw< name display_name message >;
  	$self->create_child_type(%opts);
  }
  
  our $DD;
  sub _dd
  {
  	@_ = $_ unless @_;
  	my ($value) = @_;
  	
  	goto $DD if ref($DD) eq q(CODE);
  	
  	require B;
  	
  	!defined $value ? 'Undef' :
  	!ref $value     ? sprintf('Value %s', B::perlstring($value)) :
  	do {
  		my $N = 0 + (defined($DD) ? $DD : 72);
  		require Data::Dumper;
  		local $Data::Dumper::Indent   = 0;
  		local $Data::Dumper::Useqq    = 1;
  		local $Data::Dumper::Terse    = 1;
  		local $Data::Dumper::Sortkeys = 1;
  		local $Data::Dumper::Maxdepth = 2;
  		my $str = Data::Dumper::Dumper($value);
  		$str = substr($str, 0, $N - 12).'...'.substr($str, -1, 1)
  			if length($str) >= $N;
  		"Reference $str";
  	}
  }
  
  sub _loose_to_TypeTiny
  {
  	map +(
  		ref($_)
  			? Types::TypeTiny::to_TypeTiny($_)
  			: do { require Type::Utils; Type::Utils::dwim_type($_) }
  	), @_;
  }
  
  sub name                     { $_[0]{name} }
  sub display_name             { $_[0]{display_name}   ||= $_[0]->_build_display_name }
  sub parent                   { $_[0]{parent} }
  sub constraint               { $_[0]{constraint}     ||= $_[0]->_build_constraint }
  sub compiled_check           { $_[0]{compiled_type_constraint} ||= $_[0]->_build_compiled_check }
  sub coercion                 { $_[0]{coercion}       ||= $_[0]->_build_coercion }
  sub message                  { $_[0]{message} }
  sub library                  { $_[0]{library} }
  sub inlined                  { $_[0]{inlined} }
  sub constraint_generator     { $_[0]{constraint_generator} }
  sub inline_generator         { $_[0]{inline_generator} }
  sub name_generator           { $_[0]{name_generator} ||= $_[0]->_build_name_generator }
  sub coercion_generator       { $_[0]{coercion_generator} }
  sub parameters               { $_[0]{parameters} }
  sub moose_type               { $_[0]{moose_type}     ||= $_[0]->_build_moose_type }
  sub mouse_type               { $_[0]{mouse_type}     ||= $_[0]->_build_mouse_type }
  sub deep_explanation         { $_[0]{deep_explanation} }
  
  sub has_parent               { exists $_[0]{parent} }
  sub has_library              { exists $_[0]{library} }
  sub has_coercion             {        $_[0]{coercion} and !!@{ $_[0]{coercion}->type_coercion_map } }
  sub has_inlined              { exists $_[0]{inlined} }
  sub has_constraint_generator { exists $_[0]{constraint_generator} }
  sub has_inline_generator     { exists $_[0]{inline_generator} }
  sub has_coercion_generator   { exists $_[0]{coercion_generator} }
  sub has_parameters           { exists $_[0]{parameters} }
  sub has_message              { defined $_[0]{message} }
  sub has_deep_explanation     { exists $_[0]{deep_explanation} }
  
  sub _default_message         { $_[0]{_default_message} ||= $_[0]->_build_default_message }
  
  sub _assert_coercion
  {
  	my $self = shift;
  	_croak "No coercion for this type constraint"
  		unless $self->has_coercion && @{$self->coercion->type_coercion_map};
  	return $self->coercion;
  }
  
  my $null_constraint = sub { !!1 };
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub _build_constraint
  {
  	return $null_constraint;
  }
  
  sub _is_null_constraint
  {
  	shift->constraint == $null_constraint;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion;
  	my $self = shift;
  	my %opts = (type_constraint => $self);
  	$opts{display_name} = "to_$self" unless $self->is_anon;
  	return "Type::Coercion"->new(%opts);
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	return sub { sprintf '%s did not pass type constraint', _dd($_[0]) } if "$self" eq "__ANON__";
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s"', _dd($_[0]), $name };
  }
  
  sub _build_name_generator
  {
  	my $self = shift;
  	return sub {
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], @a);
  	};
  }
  
  sub _build_compiled_check
  {
  	my $self = shift;
  	
  	if ($self->_is_null_constraint and $self->has_parent)
  	{
  		return $self->parent->compiled_check;
  	}
  	
  	if ($INC{'Mouse/Util.pm'} and Mouse::Util::MOUSE_XS())
  	{
  		require Mouse::Util::TypeConstraints;
  		
  		if ($self->{_is_core})
  		{
  			my $xs = "Mouse::Util::TypeConstraints"->can($self->name);
  			return $xs if $xs;
  		}
  		elsif ($self->is_parameterized and $self->has_parent
  		and $self->parent->{_is_core} and $self->parent->name =~ /^(ArrayRef|HashRef|Maybe)$/)
  		{
  			my $xs = "Mouse::Util::TypeConstraints"->can("_parameterize_".$self->parent->name."_for");
  			return $xs->($self->parameters->[0]) if $xs;
  		}
  	}
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', $self->inline_check('$_[0]')),
  		description => sprintf("compiled check '%s'", $self),
  	) if $self->can_be_inlined;
  	
  	my @constraints;
  	push @constraints, $self->parent->compiled_check if $self->has_parent;
  	push @constraints, $self->constraint if !$self->_is_null_constraint;
  	return $null_constraint unless @constraints;
  	
  	return sub ($)
  	{
  		local $_ = $_[0];
  		for my $c (@constraints)
  		{
  			return unless $c->(@_);
  		}
  		return !!1;
  	};
  }
  
  sub equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if refaddr($self) == refaddr($other);
  	
  	return !!1 if $self->has_parent  && $self->_is_null_constraint  && $self->parent==$other;
  	return !!1 if $other->has_parent && $other->_is_null_constraint && $other->parent==$self;
  	
  	return !!1 if refaddr($self->compiled_check) == refaddr($other->compiled_check);
  	
  	return $self->qualified_name eq $other->qualified_name
  		if $self->has_library && !$self->is_anon && $other->has_library && !$other->is_anon;
  	
  	return $self->inline_check('$x') eq $other->inline_check('$x')
  		if $self->can_be_inlined && $other->can_be_inlined;
  	
  	return;
  }
  
  sub is_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->equals($other) or $self->parent->is_subtype_of($other);
  }
  
  sub is_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_subtype_of($self);
  }
  
  sub is_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->equals($other) or $self->is_subtype_of($other);
  }
  
  sub strictly_equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	$self->{uniq} == $other->{uniq};
  }
  
  sub is_strictly_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->strictly_equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->strictly_equals($other) or $self->parent->is_strictly_subtype_of($other);
  }
  
  sub is_strictly_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_strictly_subtype_of($self);
  }
  
  sub is_strictly_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->strictly_equals($other) or $self->is_strictly_subtype_of($other);
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	(exists $self->{library} and $self->name ne "__ANON__")
  		? "$self->{library}::$self->{name}"
  		: $self->{name};
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub parents
  {
  	my $self = shift;
  	return unless $self->has_parent;
  	return ($self->parent, $self->parent->parents);
  }
  
  sub check
  {
  	my $self = shift;
  	($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  }
  
  sub _strict_check
  {
  	my $self = shift;
  	local $_ = $_[0];
  
  	my @constraints =
  		reverse
  		map  { $_->constraint }
  		grep { not $_->_is_null_constraint }
  		($self, $self->parents);
  	
  	for my $c (@constraints)
  	{
  		return unless $c->(@_);
  	}
  	
  	return !!1;
  }
  
  sub get_message
  {
  	my $self = shift;
  	local $_ = $_[0];
  	$self->has_message
  		? $self->message->(@_)
  		: $self->_default_message->(@_);
  }
  
  sub validate
  {
  	my $self = shift;
  	
  	return undef if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	return $self->get_message(@_);
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	if ($self->has_parent)
  	{
  		my $parent = $self->parent->validate_explain($value, $varname);
  		return [ sprintf('"%s" is a subtype of "%s"', $self, $self->parent), @$parent ] if $parent;
  	}
  	
  	my $message = sprintf(
  		'%s%s',
  		$self->get_message($value),
  		$varname eq q{$_} ? '' : sprintf(' (in %s)', $varname),
  	);
  	
  	if ($self->is_parameterized and $self->parent->has_deep_explanation)
  	{
  		my $deep = $self->parent->deep_explanation->($self, $value, $varname);
  		return [ $message, @$deep ] if $deep;
  	}
  	
  	return [ $message, sprintf('"%s" is defined as: %s', $self, $self->_perlcode) ];
  }
  
  my $b;
  sub _perlcode
  {
  	my $self = shift;
  	
  	return $self->inline_check('$_')
  		if $self->can_be_inlined;
  	
  	$b ||= do {
  		require B::Deparse;
  		my $tmp = "B::Deparse"->new;
  		$tmp->ambient_pragmas(strict => "all", warnings => "all") if $tmp->can('ambient_pragmas');
  		$tmp;
  	};
  	
  	my $code = $b->coderef2text($self->constraint);
  	$code =~ s/\s+/ /g;
  	return "sub $code";
  }
  
  sub assert_valid
  {
  	my $self = shift;
  	
  	return !!1 if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub assert_return
  {
  	my $self = shift;
  	
  	return $_[0] if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	return $self->parent->can_be_inlined
  		if $self->has_parent && $self->_is_null_constraint;
  	return !!1
  		if !$self->has_parent && $self->_is_null_constraint;
  	return $self->has_inlined;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	_croak 'Cannot inline type constraint check for "%s"', $self
  		unless $self->can_be_inlined;
  	
  	return $self->parent->inline_check(@_)
  		if $self->has_parent && $self->_is_null_constraint;
  	return '(!!1)'
  		if !$self->has_parent && $self->_is_null_constraint;
  	
  	local $_ = $_[0];
  	my @r = $self->inlined->($self, @_);
  	if (@r and not defined $r[0])
  	{
  		_croak 'Inlining type constraint check for "%s" returned undef!', $self
  			unless $self->has_parent;
  		$r[0] = $self->parent->inline_check(@_);
  	}
  	my $r = join " && " => map { /[;{}]/ ? "do { $_ }" : "($_)" } @r;
  	return @r==1 ? $r : "($r)";
  }
  
  sub inline_assert
  {
  	require B;
  	my $self = shift;
  	my $varname = $_[0];
  	my $code = sprintf(
  		q[do { no warnings "void"; %s ? %s : Type::Tiny::_failed_check(%d, %s, %s) };],
  		$self->inline_check(@_),
  		$varname,
  		$self->{uniq},
  		B::perlstring("$self"),
  		$varname,
  	);
  	return $code;
  }
  
  sub _failed_check
  {
  	require Error::TypeTiny::Assertion;
  	
  	my ($self, $name, $value, %attrs) = @_;
  	$self = $ALL_TYPES{$self} unless ref $self;
  	
  	my $exception_class = delete($attrs{exception_class}) || "Error::TypeTiny::Assertion";
  	
  	if ($self)
  	{
  		$exception_class->throw(
  			message => $self->get_message($value),
  			type    => $self,
  			value   => $value,
  			%attrs,
  		);
  	}
  	else
  	{
  		$exception_class->throw(
  			message => sprintf('%s did not pass type constraint "%s"', _dd($value), $name),
  			value   => $value,
  			%attrs,
  		);
  	}
  }
  
  sub coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->coerce(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->assert_coerce(@_);
  }
  
  sub is_parameterizable
  {
  	shift->has_constraint_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  my %param_cache;
  sub parameterize
  {
  	my $self = shift;
  	
  	$self->is_parameterizable
  		or @_ ? _croak("Type '%s' does not accept parameters", "$self") : return($self);
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  
  	# Generate a key for caching parameterized type constraints,
  	# but only if all the parameters are strings or type constraints.
  	my $key;
  	if ( not grep(ref($_) && !Types::TypeTiny::TypeTiny->check($_), @_) )
  	{
  		require B;
  		$key = join ":", map(Types::TypeTiny::TypeTiny->check($_) ? $_->{uniq} : B::perlstring($_), $self, @_);
  	}
  	
  	return $param_cache{$key} if defined $key && defined $param_cache{$key};
  	
  	local $Type::Tiny::parameterize_type = $self;
  	local $_ = $_[0];
  	my $P;
  	
  	my $constraint = $self->constraint_generator->(@_);
  	
  	if (Types::TypeTiny::TypeTiny->check($constraint))
  	{
  		$P = $constraint;
  	}
  	else
  	{
  		my %options = (
  			constraint   => $constraint,
  			display_name => $self->name_generator->($self, @_),
  			parameters   => [@_],
  		);
  		$options{inlined} = $self->inline_generator->(@_)
  			if $self->has_inline_generator;
  		exists $options{$_} && !defined $options{$_} && delete $options{$_}
  			for keys %options;
  		
  		$P = $self->create_child_type(%options);
  		
  		my $coercion;
  		$coercion = $self->coercion_generator->($self, $P, @_)
  			if $self->has_coercion_generator;
  		$P->coercion->add_type_coercions( @{$coercion->type_coercion_map} )
  			if $coercion;
  	}
  	
  	if (defined $key)
  	{
  		$param_cache{$key} = $P;
  		weaken($param_cache{$key});
  	}
  	
  	return $P;
  }
  
  sub child_type_class
  {
  	__PACKAGE__;
  }
  
  sub create_child_type
  {
  	my $self = shift;
  	return $self->child_type_class->new(parent => $self, @_);
  }
  
  sub complementary_type
  {
  	my $self = shift;
  	my $r    = ($self->{complementary_type} ||= $self->_build_complementary_type);
  	weaken($self->{complementary_type}) unless isweak($self->{complementary_type});
  	return $r;
  }
  
  sub _build_complementary_type
  {
  	my $self = shift;
  	my %opts = (
  		constraint   => sub { not $self->check($_) },
  		display_name => sprintf("~%s", $self),
  	);
  	$opts{display_name} =~ s/^\~{2}//;
  	$opts{inlined} = sub { shift; "not(".$self->inline_check(@_).")" }
  		if $self->can_be_inlined;
  	return "Type::Tiny"->new(%opts);
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	require Moose::Meta::TypeConstraint;
  	return "Moose::Meta::TypeConstraint"->new(%opts);
  }
  
  sub _build_moose_type
  {
  	my $self = shift;
  	
  	my $r;
  	if ($self->{_is_core})
  	{
  		require Moose::Util::TypeConstraints;
  		$r = Moose::Util::TypeConstraints::find_type_constraint($self->name);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		Scalar::Util::weaken($r->{"Types::TypeTiny::to_TypeTiny"});
  	}
  	else
  	{
  		my %opts;
  		$opts{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  		$opts{parent}     = $self->parent->moose_type if $self->has_parent;
  		$opts{constraint} = $self->constraint         unless $self->_is_null_constraint;
  		$opts{message}    = $self->message            if $self->has_message;
  		$opts{inlined}    = $self->inlined            if $self->has_inlined;
  		
  		$r = $self->_instantiate_moose_type(%opts);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		$self->{moose_type} = $r;  # prevent recursion
  		$r->coercion($self->coercion->moose_coercion) if $self->has_coercion;
  	}
  		
  	return $r;
  }
  
  sub _build_mouse_type
  {
  	my $self = shift;
  	
  	my %options;
  	$options{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  	$options{parent}     = $self->parent->mouse_type if $self->has_parent;
  	$options{constraint} = $self->constraint         unless $self->_is_null_constraint;
  	$options{message}    = $self->message            if $self->has_message;
  		
  	require Mouse::Meta::TypeConstraint;
  	my $r = "Mouse::Meta::TypeConstraint"->new(%options);
  	
  	$self->{mouse_type} = $r;  # prevent recursion
  	$r->_add_type_coercions(
  		$self->coercion->freeze->_codelike_type_coercion_map('mouse_type')
  	) if $self->has_coercion;
  	
  	return $r;
  }
  
  sub plus_coercions
  {
  	my $self = shift;
  	
  	my @more = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? @{ $_[0]->type_coercion_map }
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@more,
  		@{$self->coercion->type_coercion_map},
  	);
  	return $new;
  }
  
  sub plus_fallback_coercions
  {
  	my $self = shift;
  	
  	my @more = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? @{ $_[0]->type_coercion_map }
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@{$self->coercion->type_coercion_map},
  		@more,
  	);
  	return $new;
  }
  
  sub minus_coercions
  {
  	my $self = shift;
  	
  	my @not = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? grep(blessed($_)&&$_->isa("Type::Tiny"), @{ $_[0]->type_coercion_map })
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my @keep;
  	my $c = $self->coercion->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		my $keep_this = 1;
  		NOT: for my $n (@not)
  		{
  			if ($c->[$i] == $n)
  			{
  				$keep_this = 0;
  				last NOT;
  			}
  		}
  		
  		push @keep, $c->[$i], $c->[$i+1] if $keep_this;
  	}
  
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(@keep);
  	return $new;
  }
  
  sub no_coercions
  {
  	shift->_clone;
  }
  
  sub coercibles
  {
  	my $self = shift;
  	$self->has_coercion ? $self->coercion->_source_type_union : $self;
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and ref($self))
  	{
  		return !!1                       if $_[0] eq 'Moose::Meta::TypeConstraint';
  		return $self->is_parameterized   if $_[0] eq 'Moose::Meta::TypeConstraint::Parameterized';
  		return $self->is_parameterizable if $_[0] eq 'Moose::Meta::TypeConstraint::Parameterizable';
  	}
  	
  	if ($INC{"Moose.pm"} and ref($self) and $_[0] =~ /^Moose/ and my $r = $self->moose_type->isa(@_))
  	{
  		return $r;
  	}
  
  	if ($INC{"Mouse.pm"} and ref($self) and $_[0] eq 'Mouse::Meta::TypeConstraint')
  	{
  		return !!1;
  	}
  
  	$self->SUPER::isa(@_);
  }
  
  sub can
  {
  	my $self = shift;
  	
  	return !!0 if $_[0] eq 'type_parameter' && blessed($_[0]) && $_[0]->has_parameters;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if ($INC{"Moose.pm"} and ref($self) and my $method = $self->moose_type->can(@_))
  	{
  		return sub { $method->(shift->moose_type, @_) };
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if ($INC{"Moose.pm"} and ref($self) and my $method = $self->moose_type->can($m))
  	{
  		return $method->($self->moose_type, @_);
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  sub DOES
  {
  	my $self = shift;
  	
  	return !!1 if  ref($self) && $_[0] =~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;
  	return !!1 if !ref($self) && $_[0] eq 'Type::API::Constraint::Constructor';
  	
  	"UNIVERSAL"->can("DOES") ? $self->SUPER::DOES(@_) : $self->isa(@_);
  }
  
  # fill out Moose-compatible API
  sub inline_environment         { +{} }
  sub _inline_check              { shift->inline_check(@_) }
  sub _compiled_type_constraint  { shift->compiled_check(@_) }
  sub meta                       { _croak("Not really a Moose::Meta::TypeConstraint. Sorry!") }
  sub compile_type_constraint    { shift->compiled_check }
  sub _actually_compile_type_constraint   { shift->_build_compiled_check }
  sub hand_optimized_type_constraint      { shift->{hand_optimized_type_constraint} }
  sub has_hand_optimized_type_constraint  { exists(shift->{hand_optimized_type_constraint}) }
  sub type_parameter             { (shift->parameters || [])->[0] }
  
  # some stuff for Mouse-compatible API
  sub __is_parameterized         { shift->is_parameterized(@_) }
  sub _add_type_coercions        { shift->coercion->add_type_coercions(@_) };
  sub _as_string                 { shift->qualified_name(@_) }
  sub _compiled_type_coercion    { shift->coercion->compiled_coercion(@_) };
  sub _identity                  { refaddr(shift) };
  sub _unite                     { require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@_) };
  
  # Hooks for Type::Tie
  sub TIESCALAR  { require Type::Tie; unshift @_, 'Type::Tie::SCALAR'; goto \&Type::Tie::SCALAR::TIESCALAR };
  sub TIEARRAY   { require Type::Tie; unshift @_, 'Type::Tie::ARRAY';  goto \&Type::Tie::SCALAR::TIEARRAY };
  sub TIEHASH    { require Type::Tie; unshift @_, 'Type::Tie::HASH';   goto \&Type::Tie::SCALAR::TIEHASH };
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX MouseX MooX Moose-compat
  
  =head1 NAME
  
  Type::Tiny - tiny, yet Moo(se)-compatible type constraint
  
  =head1 SYNOPSIS
  
     use Scalar::Util qw(looks_like_number);
     use Type::Tiny;
     
     my $NUM = "Type::Tiny"->new(
        name       => "Number",
        constraint => sub { looks_like_number($_) },
        message    => sub { "$_ ain't a number" },
     );
     
     package Ermintrude {
        use Moo;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Bullwinkle {
        use Moose;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Maisy {
        use Mouse;
        has favourite_number => (is => "ro", isa => $NUM);
     }
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> is a tiny class for creating Moose-like type constraint
  objects which are compatible with Moo, Moose and Mouse.
  
  Maybe now we won't need to have separate MooseX, MouseX and MooX versions
  of everything? We can but hope...
  
  This documents the internals of L<Type::Tiny>. L<Type::Tiny::Manual> is
  a better starting place if you're new.
  
  =head2 Constructor
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<< name >>
  
  The name of the type constraint. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous type constraint.
  
  =item C<< display_name >>
  
  A name to display for the type constraint when stringified. These don't
  have to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<< parent >>
  
  Optional attribute; parent type constraint. For example, an "Integer"
  type constraint might have a parent "Number".
  
  If provided, must be a Type::Tiny object.
  
  =item C<< constraint >>
  
  Coderef to validate a value (C<< $_ >>) against the type constraint. The
  coderef will not be called unless the value is known to pass any parent
  type constraint.
  
  Defaults to C<< sub { 1 } >> - i.e. a coderef that passes all values.
  
  =item C<< compiled_check >>
  
  Coderef to validate a value (C<< $_[0] >>) against the type constraint.
  This coderef is expected to also handle all validation for the parent
  type constraints.
  
  The general point of this attribute is that you should not set it, and
  rely on the lazily-built default. Type::Tiny will usually generate a
  pretty fast coderef.
  
  =item C<< message >>
  
  Coderef that returns an error message when C<< $_ >> does not validate
  against the type constraint. Optional (there's a vaguely sensible default.)
  
  =item C<< inlined >>
  
  A coderef which returns a string of Perl code suitable for inlining this
  type. Optional.
  
  If C<constraint> (above) is a coderef generated via L<Sub::Quote>, then
  Type::Tiny I<may> be able to automatically generate C<inlined> for you.
  
  =item C<< library >>
  
  The package name of the type library this type is associated with.
  Optional. Informational only: setting this attribute does not install
  the type into the package.
  
  =item C<< coercion >>
  
  A L<Type::Coercion> object associated with this type.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built coercion object.
  
  You may pass C<< coercion => 1 >> to the constructor to inherit coercions
  from the constraint's parent. (This requires the parent constraint to have
  a coercion.)
  
  =item C<< complementary_type >>
  
  A complementary type for this type. For example, the complementary type
  for an integer type would be all things that are not integers, including
  floating point numbers, but also alphabetic strings, arrayrefs, filehandles,
  etc.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built complementary type.
  
  =item C<< moose_type >>, C<< mouse_type >>
  
  Objects equivalent to this type constraint, but as a
  L<Moose::Meta::TypeConstraint> or L<Mouse::Meta::TypeConstraint>.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built objects.
  
  It should rarely be necessary to obtain a L<Moose::Meta::TypeConstraint>
  object from L<Type::Tiny> because the L<Type::Tiny> object itself should
  be usable pretty much anywhere a L<Moose::Meta::TypeConstraint> is expected.
  
  =back
  
  The following additional attributes are used for parameterizable (e.g.
  C<ArrayRef>) and parameterized (e.g. C<< ArrayRef[Int] >>) type
  constraints. Unlike Moose, these aren't handled by separate subclasses.
  
  =over
  
  =item C<< parameters >>
  
  In parameterized types, returns an arrayref of the parameters.
  
  =item C<< name_generator >>
  
  A coderef which generates a new display_name based on parameters.
  Optional; the default is reasonable.
  
  =item C<< constraint_generator >>
  
  Coderef that generates a new constraint coderef based on parameters.
  Optional; providing a generator makes this type into a parameterizable
  type constraint.
  
  =item C<< inline_generator >>
  
  A coderef which generates a new inlining coderef based on parameters.
  
  =item C<< coercion_generator >>
  
  A coderef which generates a new L<Type::Coercion> object based on parameters.
  
  =item C<< deep_explanation >>
  
  This API is not finalized. Coderef used by L<Error::TypeTiny::Assertion> to
  peek inside parameterized types and figure out why a value doesn't pass the
  constraint.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_parent>, C<has_library>, C<has_inlined>, C<has_constraint_generator>, C<has_inline_generator>, C<has_coercion_generator>, C<has_parameters>, C<has_message>, C<has_deep_explanation>
  
  Predicate methods.
  
  =item C<has_coercion>
  
  Predicate method with a little extra DWIM. Returns false if the coercion is
  a no-op.
  
  =item C<< is_anon >>
  
  Returns true iff the type constraint does not have a C<name>.
  
  =item C<< is_parameterized >>, C<< is_parameterizable >>
  
  Indicates whether a type has been parameterized (e.g. C<< ArrayRef[Int] >>)
  or could potentially be (e.g. C<< ArrayRef >>).
  
  =item C<< qualified_name >>
  
  For non-anonymous type constraints that have a library, returns a qualified
  C<< "Library::Type" >> sort of name. Otherwise, returns the same as C<name>.
  
  =item C<< parents >>
  
  Returns a list of all this type constraint's ancestor constraints. For
  example, if called on the C<Str> type constraint would return the list
  C<< (Value, Defined, Item, Any) >>.
  
  B<< Due to a historical misunderstanding, this differs from the Moose
  implementation of the C<parents> method. In Moose, C<parents> only returns the
  immediate parent type constraints, and because type constraints only have
  one immediate parent, this is effectively an alias for C<parent>. The
  extension module L<MooseX::Meta::TypeConstraint::Intersection> is the only
  place where multiple type constraints are returned; and they are returned
  as an arrayref in violation of the base class' documentation. I'm keeping
  my behaviour as it seems more useful. >>
  
  =item C<< equals($other) >>, C<< is_subtype_of($other) >>, C<< is_supertype_of($other) >>, C<< is_a_type_of($other) >>
  
  Compare two types. See L<Moose::Meta::TypeConstraint> for what these all mean.
  (OK, Moose doesn't define C<is_supertype_of>, but you get the idea, right?)
  
  Note that these have a slightly DWIM side to them. If you create two
  L<Type::Tiny::Class> objects which test the same class, they're considered
  equal. And:
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_subtype_of( $subtype_of_Num );  # true
  
  =item C<< strictly_equals($other) >>, C<< is_strictly_subtype_of($other) >>, C<< is_strictly_supertype_of($other) >>, C<< is_strictly_a_type_of($other) >>
  
  Stricter versions of the type comparison functions. These only care about
  explicit inheritance via C<parent>.
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_strictly_subtype_of( $subtype_of_Num );  # false
  
  =item C<< check($value) >>
  
  Returns true iff the value passes the type constraint.
  
  =item C<< validate($value) >>
  
  Returns the error message for the value; returns an explicit undef if the
  value passes the type constraint.
  
  =item C<< validate_explain($value, $varname) >>
  
  Like C<validate> but instead of a string error message, returns an arrayref
  of strings explaining the reasoning why the value does not meet the type
  constraint, examining parent types, etc.
  
  The C<< $varname >> is an optional string like C<< '$foo' >> indicating the
  name of the variable being checked.
  
  =item C<< assert_valid($value) >>
  
  Like C<< check($value) >> but dies if the value does not pass the type
  constraint.
  
  Yes, that's three very similar methods. Blame L<Moose::Meta::TypeConstraint>
  whose API I'm attempting to emulate. :-)
  
  =item C<< assert_return($value) >>
  
  Like C<< assert_valid($value) >> but returns the value if it passes the type
  constraint.
  
  This seems a more useful behaviour than C<< assert_valid($value) >>. I would
  have just changed C<< assert_valid($value) >> to do this, except that there
  are edge cases where it could break Moose compatibility.
  
  =item C<< get_message($value) >>
  
  Returns the error message for the value; even if the value passes the type
  constraint.
  
  =item C<< coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type.
  
  =item C<< assert_coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type. Throws an exception if this is
  not possible.
  
  =item C<< coercibles >>
  
  Return a type constraint which is the union of type constraints that can be
  coerced to this one (including this one). If this type constraint has no
  coercions, returns itself.
  
  =item C<< can_be_inlined >>
  
  Returns boolean indicating if this type can be inlined.
  
  =item C<< inline_check($varname) >>
  
  Creates a type constraint check for a particular variable as a string of
  Perl code. For example:
  
     print( Types::Standard::Num->inline_check('$foo') );
  
  prints the following output:
  
     (!ref($foo) && Scalar::Util::looks_like_number($foo))
  
  For Moose-compat, there is an alias C<< _inline_check >> for this method.
  
  =item C<< inline_assert($varname) >>
  
  Much like C<inline_check> but outputs a statement of the form:
  
     die ... unless ...;
  
  Note that if this type has a custom error message, the inlined code will
  I<ignore> this custom message!!
  
  =item C<< parameterize(@parameters) >>
  
  Creates a new parameterized type; throws an exception if called on a
  non-parameterizable type.
  
  =item C<< create_child_type(%attributes) >>
  
  Construct a new Type::Tiny object with this object as its parent.
  
  =item C<< child_type_class >>
  
  The class that create_child_type will construct.
  
  =item C<< plus_coercions($type1, $code1, ...) >>
  
  Shorthand for creating a new child type constraint with the same coercions
  as this one, but then adding some extra coercions (at a higher priority than
  the existing ones).
  
  =item C<< plus_fallback_coercions($type1, $code1, ...) >>
  
  Like C<plus_coercions>, but added at a lower priority.
  
  =item C<< minus_coercions($type1, ...) >>
  
  Shorthand for creating a new child type constraint with fewer type coercions.
  
  =item C<< no_coercions >>
  
  Shorthand for creating a new child type constraint with no coercions at all.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeConstraint.
  
  If Mouse is loaded, then C<isa> mocks Mouse::Meta::TypeConstraint.
  
  =item C<< DOES($role) >>
  
  Overridden to advertise support for various roles.
  
  See also L<Type::API::Constraint>, etc.
  
  =item C<< TIESCALAR >>, C<< TIEARRAY >>, C<< TIEHASH >>
  
  These are provided as hooks that wrap L<Type::Tie>. (Type::Tie is distributed
  separately, and can be used with non-Type::Tiny type constraints too.) They
  allow the following to work:
  
     use Types::Standard qw(Int);
     tie my @list, Int;
     push @list, 123, 456;   # ok
     push @list, "Hello";    # dies
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_constraint >>
  
  =item C<< hand_optimized_type_constraint >>
  
  =item C<< has_hand_optimized_type_constraint >>
  
  =item C<< inline_environment >>
  
  =item C<< meta >>
  
  =item C<< type_parameter >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to return the qualified name.
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<assert_return>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<check>.
  
  =item *
  
  The C<< == >> operator is overloaded to call C<equals>.
  
  =item *
  
  The C<< < >> and C<< > >> operators are overloaded to call C<is_subtype_of>
  and C<is_supertype_of>.
  
  =item *
  
  The C<< ~ >> operator is overloaded to call C<complementary_type>.
  
  =item *
  
  The C<< | >> operator is overloaded to build a union of two type constraints.
  See L<Type::Tiny::Union>.
  
  =item *
  
  The C<< & >> operator is overloaded to build the intersection of two type
  constraints. See L<Type::Tiny::Intersection>.
  
  =item *
  
  The C<< + >> operator is overloaded to call C<plus_coercions> or
  C<plus_fallback_coercions> as appropriate.
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< Type::Tiny::SUPPORT_SMARTMATCH >>
  
  Indicates whether the smart match overload is supported on your
  version of Perl.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< $Type::Tiny::DD >>
  
  This in undef by default but may be set to a coderef that Type::Tiny
  and related modules will use to dump data structures in things like
  error messages.
  
  Otherwise Type::Tiny uses it's own routine to dump data structures.
  C<< $DD >> may then be set to a number to limit the lengths of the
  dumps. (Default limit is 72.)
  
  This is a package variable (rather than get/set class methods) to allow
  for easy localization.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>, L<Type::API>.
  
  L<Type::Library>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>, L<Type::Tiny::Intersection>.
  
  L<Moose::Meta::TypeConstraint>,
  L<Mouse::Meta::TypeConstraint>.
  
  L<Type::Params>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 THANKS
  
  Thanks to Matt S Trout for advice on L<Moo> integration.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY

$fatpacked{"Type/Tiny/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_CLASS';
  package Type::Tiny::Class;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::Class::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Class::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	return $proto->class->new(@_) if blessed $proto; # DWIM
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Class type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Class type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Class type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply class name" unless exists $opts{class};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub class       { $_[0]{class} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self  = shift;
  	my $class = $self->class;
  	return sub { blessed($_) and $_->isa($class) };
  }
  
  sub _build_inlined
  {
  	my $self  = shift;
  	my $class = $self->class;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and $var->isa(q[$class])};
  	};
  }
  
  sub _build_default_message
  {
  	no warnings 'uninitialized';
  	my $self = shift;
  	my $c = $self->class;
  	return sub { sprintf '%s did not pass type constraint (not isa %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not isa %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Class;
  	return "Moose::Meta::TypeConstraint::Class"->new(%opts, class => $self->class);
  }
  
  sub plus_constructors
  {
  	my $self = shift;
  	
  	unless (@_)
  	{
  		require Types::Standard;
  		push @_, Types::Standard::HashRef(), "new";
  	}
  	
  	require B;
  	require Types::TypeTiny;
  	
  	my $class = B::perlstring($self->class);
  	
  	my @r;
  	while (@_)
  	{
  		my $source = shift;
  		Types::TypeTiny::TypeTiny->check($source)
  			or _croak "Expected type constraint; got $source";
  		
  		my $constructor = shift;
  		Types::TypeTiny::StringLike->check($constructor)
  			or _croak "Expected string; got $constructor";
  		
  		push @r, $source, sprintf('%s->%s($_)', $class, $constructor);
  	}
  	
  	return $self->plus_coercions(\@r);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self  = shift;
  	my $class = $self->class;
  	
  	my @isa = grep $class->isa($_), do { no strict "refs"; no warnings; @{"$class\::ISA"} };
  	
  	if (@isa == 0)
  	{
  		require Types::Standard;
  		return Types::Standard::Object();
  	}
  	
  	if (@isa == 1)
  	{
  		return ref($self)->new(class => $isa[0])
  	}
  	
  	require Type::Tiny::Intersection;
  	"Type::Tiny::Intersection"->new(
  		type_constraints => [ map ref($self)->new(class => $_), @isa ],
  	);
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	my @isa;
  	if (eval { require mro })
  	{
  		@isa = @{ mro::get_linear_isa(ref $value) };
  	}
  	else
  	{
  		require Class::ISA;
  		@isa = Class::ISA::super_path(ref $value);
  	}
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	require Type::Utils;
  	return [
  		sprintf('"%s" requires that the reference isa %s', $self, $self->class),
  		sprintf('The reference%s isa %s', $display_var, Type::Utils::english_list(@isa)),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Class - type constraints based on the "isa" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->isa("Some::Class") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Constructor
  
  =over
  
  =item C<new>
  
  When the constructor is called on an I<instance> of Type::Tiny::Class, it
  passes the call through to the constructor of the class for the constraint.
  So for example:
  
     my $type = Type::Tiny::Class->new(class => "Foo::Bar");
     my $obj  = $type->new(hello => "World");
     say ref($obj);   # prints "Foo::Bar"
  
  This little bit of DWIM was borrowed from L<MooseX::Types::TypeDecorator>,
  but Type::Tiny doesn't take the idea quite as far.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<class>
  
  The class for the constraint.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is automatically calculated, and cannot be passed to the constructor.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< plus_constructors($source, $method_name) >>
  
  Much like C<plus_coercions> but adds coercions that go via a constructor.
  (In fact, this is implemented as a wrapper for C<plus_coercions>.)
  
  Example:
  
     package MyApp::Minion;
     
     use Moose; extends "MyApp::Person";
     
     use Types::Standard qw( HashRef Str );
     use Type::Utils qw( class_type );
     
     my $Person = class_type({ class => "MyApp::Person" });
     
     has boss => (
        is     => "ro",
        isa    => $Person->plus_constructors(
           HashRef,     "new",
           Str,         "_new_from_name",
        ),
        coerce => 1,
     );
     
     package main;
     
     MyApp::Minion->new(
        ...,
        boss => "Bob",  ## via MyApp::Person->_new_from_name
     );
     
     MyApp::Minion->new(
        ...,
        boss => { name => "Bob" },  ## via MyApp::Person->new
     );
  
  Because coercing C<HashRef> via constructor is a common desire, if
  you call C<plus_constructors> with no arguments at all, this is the
  default.
  
     $classtype->plus_constructors(Types::Standard::HashRef, "new")
     $classtype->plus_constructors()  ## identical to above
  
  This is handy for Moose/Mouse/Moo-based classes.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Class>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_CLASS

$fatpacked{"Type/Tiny/Duck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_DUCK';
  package Type::Tiny::Duck;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Duck::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Duck::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Duck type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Duck type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Duck type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of methods" unless exists $opts{methods};
  	
  	$opts{methods} = [$opts{methods}] unless ref $opts{methods};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub methods     { $_[0]{methods} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self    = shift;
  	my @methods = @{$self->methods};
  	return sub { blessed($_[0]) and not grep(!$_[0]->can($_), @methods) };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my @methods = @{$self->methods};
  	sub {
  		my $var = $_[1];
  		local $" = q{ };
  		qq{ Scalar::Util::blessed($var) and not grep(!$var->can(\$_), qw/@methods/) };
  	};
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	require Moose::Meta::TypeConstraint::DuckType;
  	return "Moose::Meta::TypeConstraint::DuckType"->new(%opts, methods => $self->methods);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the reference can %s',
  			$self,
  			Type::Utils::english_list(map qq["$_"], @{$self->methods}),
  		),
  		map  sprintf('The reference cannot "%s"', $_),
  		grep !$value->can($_),
  		@{$self->methods}
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Duck - type constraints based on the "can" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->can("method") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<methods>
  
  An arrayref of method names.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::DuckType>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_DUCK

$fatpacked{"Type/Tiny/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ENUM';
  package Type::Tiny::Enum;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Enum::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Enum::VERSION   = '0.038';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => 'values';
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new
  {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Enum type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Enum type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Enum type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of values" unless exists $opts{values};
  	
  	my %tmp =
  		map { $_ => 1 }
  		@{ ref $opts{values} eq "ARRAY" ? $opts{values} : [$opts{values}] };
  	$opts{values} = [sort keys %tmp];
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub values      { $_[0]{values} }
  sub constraint  { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	sprintf("Enum[%s]", join q[,], @$self);
  }
  
  sub _build_constraint
  {
  	my $self = shift;
  	my $regexp = join "|", map quotemeta, @$self;
  	return sub { defined and m{\A(?:$regexp)\z} };
  }
  
  sub can_be_inlined
  {
  	!!1;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	my $regexp = join "|", map quotemeta, @$self;
  	$_[0] eq '$_'
  		? "(defined and !ref and m{\\A(?:$regexp)\\z})"
  		: "(defined($_[0]) and !ref($_[0]) and $_[0] =~ m{\\A(?:$regexp)\\z})";
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Enum;
  	return "Moose::Meta::TypeConstraint::Enum"->new(%opts, values => $self->values);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Str();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	!defined($value) ? [
  		sprintf(
  			'"%s" requires that the value is defined',
  			$self,
  		),
  	] :
  	@$self < 13 ? [
  		sprintf(
  			'"%s" requires that the value is equal to %s',
  			$self,
  			Type::Utils::english_list(\"or", map B::perlstring($_), @$self),
  		),
  	] :
  	[
  		sprintf(
  			'"%s" requires that the value is one of an enumerated list of strings',
  			$self,
  		),
  	];
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Enum - string enum type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Enum type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<values>
  
  Arrayref of allowable value strings. Non-string values (e.g. objects with
  overloading) will be stringified in the constructor.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Str, and cannot be passed to the
  constructor.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<values>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Enum>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ENUM

$fatpacked{"Type/Tiny/Intersection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_INTERSECTION';
  package Type::Tiny::Intersection;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Intersection::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Intersection::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Intersection type constraints cannot have a parent constraint" if exists $opts{parent};
  	_croak "Intersection type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Intersection type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[&], @$self;
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) || return for @checks;
  		return !!1;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	sprintf '(%s)', join " and ", map $_->inline_check($_[0]), @$self;
  }
  
  sub has_parent
  {
  	!!@{ $_[0]{type_constraints} };
  }
  
  sub parent
  {
  	$_[0]{type_constraints}[0];
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	for my $type (@$self)
  	{
  		my $deep = $type->validate_explain($value, $varname);
  		return [
  			sprintf(
  				'"%s" requires that the value pass %s',
  				$self,
  				Type::Utils::english_list(map qq["$_"], @$self),
  			),
  			@$deep,
  		] if $deep;
  	}
  	
  	return ["Mysterious!"];
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Intersection - intersection type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Intersection type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the
  intersection is itself an intersection type constraint, this is "exploded"
  into the new intersection.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  (Technically any of the types in the intersection could be treated as a
  parent type; we choose the first arbitrarily.)
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<MooseX::Meta::TypeConstraint::Intersection>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_INTERSECTION

$fatpacked{"Type/Tiny/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ROLE';
  package Type::Tiny::Role;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Role::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Role::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed weaken >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  my %cache;
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Role type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Role type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Role type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply role name" unless exists $opts{role};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub role        { $_[0]{role} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self = shift;
  	my $role = $self->role;
  	return sub { blessed($_) and do { my $method = $_->can('DOES')||$_->can('isa'); $_->$method($role) } };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my $role = $self->role;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and do { my \$method = $var->can('DOES')||$var->can('isa'); $var->\$method(q[$role]) }};
  	};
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	my $c = $self->role;
  	return sub { sprintf '%s did not pass type constraint (not DOES %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not DOES %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	return ["Reference provides no DOES method to check roles"] unless $value->can('DOES');
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	return [
  		sprintf('"%s" requires that the reference does %s', $self, $self->role),
  		sprintf("The reference%s doesn't %s", $display_var, $self->role),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Role - type constraints based on the "DOES" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->DOES("Some::Role") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<role>
  
  The role for the constraint.
  
  Note that this package doesn't subscribe to any particular flavour of roles
  (L<Moose::Role>, L<Mouse::Role>, L<Moo::Role>, L<Role::Tiny>, etc). It simply
  trusts the object's C<DOES> method (see L<UNIVERSAL>).
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Role>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ROLE

$fatpacked{"Type/Tiny/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_UNION';
  package Type::Tiny::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Union::VERSION   = '0.038';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Union type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Union type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Union type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	my $self = $proto->SUPER::new(%opts);
  	$self->coercion if grep $_->has_coercion, @$self;
  	return $self;
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[|], @$self;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion::Union;
  	my $self = shift;
  	return "Type::Coercion::Union"->new(type_constraint => $self);
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) && return !!1 for @checks;
  		return;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	sprintf '(%s)', join " or ", map $_->inline_check($_[0]), @$self;
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	my @tc = map $_->moose_type, @{$self->type_constraints};
  	
  	require Moose::Meta::TypeConstraint::Union;
  	return "Moose::Meta::TypeConstraint::Union"->new(%opts, type_constraints => \@tc);
  }
  
  sub has_parent
  {
  	defined(shift->parent);
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self = shift;
  	my ($first, @rest) = @$self;
  	
  	for my $parent ($first, $first->parents)
  	{
  		return $parent unless grep !$_->is_a_type_of($parent), @rest;
  	}
  	
  	return;
  }
  
  sub find_type_for
  {
  	my @types = @{+shift};
  	for my $type (@types)
  	{
  		return $type if $type->check(@_);
  	}
  	return;
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the value pass %s',
  			$self,
  			Type::Utils::english_list(\"or", map qq["$_"], @$self),
  		),
  		map {
  			$_->get_message($value),
  			map("    $_", @{ $_->validate_explain($value) || []}),
  		} @$self
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Union - union type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Union type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the union
  is itself a union type constraint, this is "exploded" into the new union.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  =item C<coercion>
  
  Will typically be a L<Type::Coercion::Union>.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< find_type_for($value) >>
  
  Returns the first individual type constraint in the union which
  C<< $value >> passes.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_UNION

$fatpacked{"Type/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_UTILS';
  package Type::Utils;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Utils::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Utils::VERSION   = '0.038';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Scalar::Util qw< blessed >;
  use Type::Library;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny HashLike StringLike CodeLike >;
  
  our @EXPORT = qw<
  	declare as where message inline_as
  	class_type role_type duck_type union intersection enum
  	coerce from via
  	declare_coercion to_type
  >;
  our @EXPORT_OK = (
  	@EXPORT,
  	qw<
  		extends type subtype
  		match_on_type compile_match_on_type
  		dwim_type english_list
  	>,
  );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  sub extends
  {
  	_croak "Not a type library" unless caller->isa("Type::Library");
  	my $caller = caller->meta;
  	
  	foreach my $lib (@_)
  	{
  		eval "use $lib; 1" or _croak "Could not load library '$lib': $@";
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$caller->add_type( $lib->get_type($_) )
  				for sort $lib->meta->type_names;
  			$caller->add_coercion( $lib->get_coercion($_) )
  				for sort $lib->meta->coercion_names;
  		}
  		elsif ($lib->isa('MooseX::Types::Base'))
  		{
  			require Moose::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $moose = Moose::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($moose);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $moose->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		elsif ($lib->isa('MouseX::Types::Base'))
  		{
  			require Mouse::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $mouse = Mouse::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($mouse);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $mouse->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		else
  		{
  			_croak("'$lib' is not a type constraint library");
  		}
  	}
  }
  
  sub declare
  {
  	my %opts;
  	if (@_ % 2 == 0)
  	{
  		%opts = @_;
  	}
  	else
  	{
  		(my($name), %opts) = @_;
  		_croak "Cannot provide two names for type" if exists $opts{name};
  		$opts{name} = $name;
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	if (defined $opts{parent})
  	{
  		$opts{parent} = to_TypeTiny($opts{parent});
  		
  		unless (TypeTiny->check($opts{parent}))
  		{
  			$caller->isa("Type::Library")
  				or _croak("Parent type cannot be a %s", ref($opts{parent})||'non-reference scalar');
  			$opts{parent} = $caller->meta->get_type($opts{parent})
  				or _croak("Could not find parent type");
  		}
  	}
  	
  	my $type;
  	if (defined $opts{parent})
  	{
  		$type = delete($opts{parent})->create_child_type(%opts);
  	}
  	else
  	{
  		my $bless = delete($opts{bless}) || "Type::Tiny";
  		eval "require $bless";
  		$type = $bless->new(%opts);
  	}
  	
  	if ($caller->isa("Type::Library"))
  	{
  		$caller->meta->add_type($type) unless $type->is_anon;
  	}
  	
  	return $type;
  }
  
  *subtype = \&declare;
  *type = \&declare;
  
  sub as (@)
  {
  	parent => @_;
  }
  
  sub where (&;@)
  {
  	constraint => @_;
  }
  
  sub message (&;@)
  {
  	message => @_;
  }
  
  sub inline_as (&;@)
  {
  	inlined => @_;
  }
  
  sub class_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ +shift };
  	
  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{class} = $name unless exists $opts{class};
  	}
  	
  	$opts{bless} = "Type::Tiny::Class";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub role_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ +shift };
  	
  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{role}  = $name unless exists $opts{role};
  	}
  	
  	$opts{bless} = "Type::Tiny::Role";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub duck_type
  {
  	my $name    = ref($_[0]) ? undef : shift;
  	my @methods = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{methods} = \@methods;
  	
  	$opts{bless} = "Type::Tiny::Duck";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub enum
  {
  	my $name   = ref($_[0]) ? undef : shift;
  	my @values = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{values} = \@values;
  	
  	$opts{bless} = "Type::Tiny::Enum";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub union
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Union";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub intersection
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Intersection";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub declare_coercion
  {
  	my %opts;
  	$opts{name} = shift if !ref($_[0]);
  	
  	while (HashLike->check($_[0]) and not TypeTiny->check($_[0]))
  	{
  		%opts = (%opts, %{+shift});
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	my $bless = delete($opts{bless}) || "Type::Coercion";
  	eval "require $bless";
  	my $c = $bless->new(%opts);
  	
  	my @C;
  	
  	if ($caller->isa("Type::Library"))
  	{
  		my $meta = $caller->meta;
  		$meta->add_coercion($c) unless $c->is_anon;
  		while (@_)
  		{
  			push @C, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @C, shift;
  		}
  	}
  	
  	$c->add_type_coercions(@C);
  	
  	return $c->freeze;
  }
  
  sub coerce
  {
  	if ((scalar caller)->isa("Type::Library"))
  	{
  		my $meta = (scalar caller)->meta;
  		my ($type) = map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  		my @opts;
  		while (@_)
  		{
  			push @opts, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @opts, shift;
  		}
  		return $type->coercion->add_type_coercions(@opts);
  	}
  	
  	my ($type, @opts) = @_;
  	$type = to_TypeTiny($type);
  	return $type->coercion->add_type_coercions(@opts);
  }
  
  sub from (@)
  {
  	return @_;
  }
  
  sub to_type (@)
  {
  	my $type = shift;
  	unless (TypeTiny->check($type))
  	{
  		caller->isa("Type::Library")
  			or _croak "Target type cannot be a string";
  		$type = caller->meta->get_type($type)
  			or _croak "Could not find target type";
  	}
  	return +{ type_constraint => $type }, @_;
  }
  
  sub via (&;@)
  {
  	return @_;
  }
  
  sub match_on_type
  {
  	my $value = shift;
  	
  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}
  		
  		$type->check($value) or next;
  		
  		if (StringLike->check($code))
  		{
  			local $_ = $value;
  			if (wantarray) {
  				my @r = eval "$code";
  				die $@ if $@;
  				return @r;
  			}
  			if (defined wantarray) {
  				my $r = eval "$code";
  				die $@ if $@;
  				return $r;
  			}
  			eval "$code";
  			die $@ if $@;
  			return;
  		}
  		else
  		{
  			CodeLike->($code);
  			local $_ = $value;
  			return $code->($value);
  		}
  	}
  	
  	_croak("No cases matched for %s", Type::Tiny::_dd($value));
  }
  
  sub compile_match_on_type
  {
  	my @code = 'sub { local $_ = $_[0]; ';
  	my @checks;
  	my @actions;
  	
  	my $els = '';
  	
  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}
  		
  		if ($type->can_be_inlined)
  		{
  			push @code, sprintf('%sif (%s)', $els, $type->inline_check('$_'));
  		}
  		else
  		{
  			push @checks, $type;
  			push @code, sprintf('%sif ($checks[%d]->check($_))', $els, $#checks);
  		}
  		
  		$els = 'els';
  		
  		if (StringLike->check($code))
  		{
  			push @code, sprintf('  { %s }', $code);
  		}
  		else
  		{
  			CodeLike->($code);
  			push @actions, $code;
  			push @code, sprintf('  { $actions[%d]->(@_) }', $#actions);
  		}
  	}
  	
  	push @code, 'else', '  { Type::Util::_croak("No cases matched for %s", Type::Tiny::_dd($_[0])) }';
  	
  	push @code, '}';  # /sub
  	
  	require Eval::TypeTiny;
  	return Eval::TypeTiny::eval_closure(
  		source      => \@code,
  		environment => {
  			'@actions' => \@actions,
  			'@checks'  => \@checks,
  		},
  	);
  }
  
  {
  	package #hide
  	Type::Registry::DWIM;
  	
  	our @ISA = qw(Type::Registry);
  	
  	sub simple_lookup
  	{
  		my $self = shift;
  		my $r;
  		
  		# If the lookup is chained to a class, then the class' own
  		# type registry gets first refusal.
  		#
  		if (defined $self->{"~~chained"})
  		{
  			my $chained = "Type::Registry"->for_class($self->{"~~chained"});
  			$r = eval { $chained->simple_lookup(@_) } unless $self == $chained;
  			return $r if defined $r;
  		}
  		
  		# Fall back to types in Types::Standard.
  		require Types::Standard;
  		return 'Types::Standard'->get_type($_[0]) if 'Types::Standard'->has_type($_[0]);
  		
  		# Only continue any further if we've been called from Type::Parser.
  		return unless $_[1];
  		
  		# If Moose is loaded...
  		if ($INC{'Moose.pm'})
  		{
  			require Moose::Util::TypeConstraints;
  			require Types::TypeTiny;
  			$r = Moose::Util::TypeConstraints::find_type_constraint($_[0]);
  			return Types::TypeTiny::to_TypeTiny($r) if defined $r;
  		}
  		
  		# If Mouse is loaded...
  		if ($INC{'Mouse.pm'})
  		{
  			require Mouse::Util::TypeConstraints;
  			require Types::TypeTiny;
  			$r = Mouse::Util::TypeConstraints::find_type_constraint($_[0]);
  			return Types::TypeTiny::to_TypeTiny($r) if defined $r;
  		}
  		
  		return unless $_[0] =~ /^\s*(\w+(::\w+)*)\s*$/sm;
  		return unless defined $self->{"~~assume"};
  		
  		# Lastly, if it looks like a class/role name, assume it's
  		# supposed to be a class/role type.
  		#
  		
  		if ($self->{"~~assume"} eq "Type::Tiny::Class")
  		{
  			require Type::Tiny::Class;
  			return "Type::Tiny::Class"->new(class => $_[0]);
  		}
  		
  		if ($self->{"~~assume"} eq "Type::Tiny::Role")
  		{
  			require Type::Tiny::Role;
  			return "Type::Tiny::Role"->new(role => $_[0]);
  		}
  		
  		die;
  	}
  }
  
  our $dwimmer;
  sub dwim_type
  {
  	my ($string, %opts) = @_;
  	$opts{for} = caller unless defined $opts{for};
  	
  	$dwimmer ||= do {
  		require Type::Registry;
  		'Type::Registry::DWIM'->new;
  	};
  	
  	local $dwimmer->{'~~chained'} = $opts{for};
  	local $dwimmer->{'~~assume'}  = $opts{does} ? 'Type::Tiny::Role' : 'Type::Tiny::Class';
  	
  	$dwimmer->lookup($string);
  }
  
  sub english_list
  {
  	my $conjunction = ref($_[0]) eq 'SCALAR' ? ${+shift} : 'and';
  	my @items = sort @_;
  	
  	return $items[0] if @items == 1;
  	return "$items[0] $conjunction $items[1]" if @items == 2;
  	
  	my $tail = pop @items;
  	join(', ', @items, "$conjunction $tail");
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smush smushed
  
  =head1 NAME
  
  Type::Utils - utility functions to make defining and using type constraints a little easier
  
  =head1 SYNOPSIS
  
     package Types::Mine;
     
     use Type::Library -base;
     use Type::Utils -all;
     
     BEGIN { extends "Types::Standard" };
     
     declare "AllCaps",
        as "Str",
        where { uc($_) eq $_ },
        inline_as { my $varname = $_[1]; "uc($varname) eq $varname" };
     
     coerce "AllCaps",
        from "Str", via { uc($_) };
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This module provides utility functions to make defining and using type
  constraints a little easier. 
  
  =head2 Type declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< declare $name, %options >>
  
  =item C<< declare %options >>
  
  Declare a named or anonymous type constraint. Use C<as> and C<where> to
  specify the parent type (if any) and (possibly) refine its definition.
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
     my $EvenInt = declare as Int, where { $_ % 2 == 0 };
  
  B<< NOTE: >>
  If the caller package inherits from L<Type::Library> then any non-anonymous
  types declared in the package will be automatically installed into the
  library.
  
  Hidden gem: if you're inheriting from a type constraint that includes some
  coercions, you can include C<< coercion => 1 >> in the C<< %options >> hash
  to inherit the coercions.
  
  =item C<< subtype $name, %options >>
  
  =item C<< subtype %options >>
  
  Declare a named or anonymous type constraint which is descended from an
  existing type constraint. Use C<as> and C<where> to specify the parent
  type and refine its definition.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< type $name, %options >>
  
  =item C<< type %options >>
  
  Declare a named or anonymous type constraint which is not descended from
  an existing type constraint. Use C<where> to provide a coderef that
  constrains values.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< as $parent >>
  
  Used with C<declare> to specify a parent type constraint:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  =item C<< where { BLOCK } >>
  
  Used with C<declare> to provide the constraint coderef:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  The coderef operates on C<< $_ >>, which is the value being tested.
  
  =item C<< message { BLOCK } >>
  
  Generate a custom error message when a value fails validation.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        message {
           Int->validate($_) or "$_ is not divisible by two";
        };
  
  Without a custom message, the messages generated by Type::Tiny are along
  the lines of I<< Value "33" did not pass type constraint "EvenInt" >>,
  which is usually reasonable.
  
  =item C<< inline_as { BLOCK } >>
  
  Generate a string of Perl code that can be used to inline the type check into
  other functions. If your type check is being used within a L<Moose> or L<Moo>
  constructor or accessor methods, or used by L<Type::Params>, this can lead to
  significant performance improvements.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           my ($constraint, $varname) = @_;
           my $perlcode = 
              $constraint->parent->inline_check($varname)
              . "&& ($varname % 2 == 0)";
           return $perlcode;
        };
     
     warn EvenInt->inline_check('$xxx');  # demonstration
  
  B<Experimental:> your C<inline_as> block can return a list, in which case
  these will be smushed together with "&&". The first item on the list may
  be undef, in which case the undef will be replaced by the inlined parent
  type constraint. (And will throw an exception if there is no parent.)
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           return (undef, "($_ % 2 == 0)");
        };
  
  Returning a list like this is considered experimental, is not tested very
  much, and I offer no guarantees that it will necessarily work with
  Moose/Mouse/Moo.
  
  =item C<< class_type $name, { class => $package, %options } >>
  
  =item C<< class_type { class => $package, %options } >>
  
  Shortcut for declaring a L<Type::Tiny::Class> type constraint.
  
  =item C<< role_type $name, { role => $package, %options } >>
  
  =item C<< role_type { role => $package, %options } >>
  
  Shortcut for declaring a L<Type::Tiny::Role> type constraint.
  
  =item C<< duck_type $name, \@methods >>
  
  =item C<< duck_type \@methods >>
  
  Shortcut for declaring a L<Type::Tiny::Duck> type constraint.
  
  =item C<< union $name, \@constraints >>
  
  =item C<< union \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Union> type constraint.
  
  =item C<< enum $name, \@values >>
  
  =item C<< enum \@values >>
  
  Shortcut for declaring a L<Type::Tiny::Enum> type constraint.
  
  =item C<< intersection $name, \@constraints >>
  
  =item C<< intersection \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Intersection> type constraint.
  
  =back
  
  =head2 Coercion declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< coerce $target, @coercions >>
  
  Add coercions to the target type constraint. The list of coercions is a
  list of type constraint, conversion code pairs. Conversion code can be
  either a string of Perl code or a coderef; in either case the value to
  be converted is C<< $_ >>.
  
  =item C<< from $source >>
  
  Sugar to specify a type constraint in a list of coercions:
  
     coerce EvenInt, from Int, via { $_ * 2 };  # As a coderef...
     coerce EvenInt, from Int, q { $_ * 2 };    # or as a string!
  
  =item C<< via { BLOCK } >>
  
  Sugar to specify a coderef in a list of coercions.
  
  =item C<< declare_coercion $name, \%opts, $type1, $code1, ... >>
  
  =item C<< declare_coercion \%opts, $type1, $code1, ... >>
  
  Declares a coercion that is not explicitly attached to any type in the
  library. For example:
  
     declare_coercion "ArrayRefFromAny", from "Any", via { [$_] };
  
  This coercion will be exportable from the library as a L<Type::Coercion>
  object, but the ArrayRef type exported by the library won't automatically
  use it.
  
  Coercions declared this way are immutable (frozen).
  
  =item C<< to_type $type >>
  
  Used with C<declare_coercion> to declare the target type constraint for
  a coercion, but still without explicitly attaching the coercion to the
  type constraint:
  
     declare_coercion "ArrayRefFromAny",
        to_type "ArrayRef",
        from "Any", via { [$_] };
  
  You should pretty much always use this when declaring an unattached
  coercion because it's exceedingly useful for a type coercion to know what
  it will coerce to - this allows it to skip coercion when no coercion is
  needed (e.g. avoiding coercing C<< [] >> to C<< [ [] ] >>) and allows
  C<assert_coerce> to work properly.
  
  =back
  
  =head2 Type library management
  
  =over
  
  =item C<< extends @libraries >>
  
  Indicates that this type library extends other type libraries, importing
  their type constraints.
  
  Should usually be executed in a C<< BEGIN >> block.
  
  This is not exported by default because it's not fun to export it to Moo,
  Moose or Mouse classes! C<< use Type::Utils -all >> can be used to import
  it into your type library.
  
  =back
  
  =head2 Other
  
  =over
  
  =item C<< match_on_type $value => ($type => \&action, ..., \&default?) >>
  
  Something like a C<switch>/C<case> or C<given>/C<when> construct. Dispatches
  along different code paths depending on the type of the incoming value.
  Example blatantly stolen from the Moose documentation:
  
     sub to_json
     {
        my $value = shift;
        
        return match_on_type $value => (
           HashRef() => sub {
              my $hash = shift;
              '{ '
                 . (
                 join ", " =>
                 map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                 sort keys %$hash
              ) . ' }';
           },
           ArrayRef() => sub {
              my $array = shift;
              '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
           },
           Num()   => q {$_},
           Str()   => q { '"' . $_ . '"' },
           Undef() => q {'null'},
           => sub { die "$_ is not acceptable json type" },
        );
     }
  
  Note that unlike Moose, code can be specified as a string instead of a
  coderef. (e.g. for C<Num>, C<Str> and C<Undef> above.)
  
  For improved performance, try C<compile_match_on_type>.
  
  This function is not exported by default.
  
  =item C<< my $coderef = compile_match_on_type($type => \&action, ..., \&default?) >>
  
  Compile a C<match_on_type> block into a coderef. The following JSON
  converter is about two orders of magnitude faster than the previous
  example:
  
     sub to_json;
     *to_json = compile_match_on_type(
        HashRef() => sub {
           my $hash = shift;
           '{ '
              . (
              join ", " =>
              map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
              sort keys %$hash
           ) . ' }';
        },
        ArrayRef() => sub {
           my $array = shift;
           '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
        },
        Num()   => q {$_},
        Str()   => q { '"' . $_ . '"' },
        Undef() => q {'null'},
        => sub { die "$_ is not acceptable json type" },
     );
  
  Remember to store the coderef somewhere fairly permanent so that you
  don't compile it over and over. C<state> variables (in Perl >= 5.10)
  are good for this. (Same sort of idea as L<Type::Params>.)
  
  This function is not exported by default.
  
  =item C<< dwim_type($string, %options) >>
  
  Given a string like "ArrayRef[Int|CodeRef]", turns it into a type constraint
  object, hopefully doing what you mean.
  
  It uses the syntax of L<Type::Parser>. Firstly the L<Type::Registry>
  for the caller package is consulted; if that doesn't have a match,
  L<Types::Standard> is consulted for type constraint names; and if
  there's still no match, then if a type constraint looks like a class
  name, a new L<Type::Tiny::Class> object is created for it.
  
  Somewhere along the way, it also checks Moose/Mouse's type constraint
  registries if they are loaded.
  
  You can specify an alternative for the caller using the C<for> option.
  If you'd rather create a L<Type::Tiny::Role> object, set the C<does>
  option to true.
  
     # An arrayref of objects, each of which must do role Foo.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);
     
     Type::Registry->for_me->add_types("-Standard");
     Type::Registry->for_me->alias_type("Int" => "Foo");
     
     # An arrayref of integers.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);
  
  While it's probably better overall to use the proper L<Type::Registry>
  interface for resolving type constraint strings, this function often does
  what you want.
  
  It should never die if it fails to find a type constraint (but may die
  if the type constraint string is syntactically malformed), preferring to
  return undef.
  
  This function is not exported by default.
  
  =item C<< english_list(\$conjunction, @items) >>
  
  Joins the items with commas, placing a conjunction before the final item.
  The conjunction is optional, defaulting to "and".
  
     english_list(qw/foo bar baz/);       # "foo, bar, and baz"
     english_list(\"or", qw/quux quuux/); # "quux or quuux"
  
  This function is not exported by default.
  
  =back
  
  =head1 EXPORT
  
  By default, all of the functions documented above are exported, except
  C<subtype> and C<type> (prefer C<declare> instead), C<extends>, C<dwim_type>,
  and C<match_on_type>/C<compile_match_on_type>.
  
  This module uses L<Exporter::Tiny>; see the documentation of that module
  for tips and tricks importing from Type::Utils.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_UTILS

$fatpacked{"Types/Common/Numeric.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_NUMERIC';
  package Types::Common::Numeric;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::Numeric::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::Numeric::VERSION   = '0.038';
  }
  
  use Type::Library -base, -declare => qw(
  	PositiveNum PositiveOrZeroNum
  	PositiveInt PositiveOrZeroInt
  	NegativeNum NegativeOrZeroNum
  	NegativeInt NegativeOrZeroInt
  	SingleDigit
  );
  
  use Types::Standard qw( Num Int );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => 'PositiveNum',
  	parent     => Num,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive number" },
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be a number greater than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'PositiveInt',
  	parent     => Int,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive integer" },
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be an integer greater than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'NegativeNum',
  	parent     => Num,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative number" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be a number less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'NegativeInt',
  	parent     => Int,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative integer" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be an integer less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'SingleDigit',
  	parent     => Int,
  	constraint => sub { $_ >= -9 and $_ <= 9 },
  	inlined    => sub { undef, qq($_ >= -9), qq($_ <= 9) },
  	message    => sub { "Must be a single digit" },
  );
   
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::Numeric - drop-in replacement for MooseX::Types::Common::Numeric
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::Numeric>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::Numeric>.
  
  =over
  
  =item C<PositiveNum>
  
  =item C<PositiveOrZeroNum>
  
  =item C<PositiveInt>
  
  =item C<PositiveOrZeroInt>
  
  =item C<NegativeNum>
  
  =item C<NegativeOrZeroNum>
  
  =item C<NegativeInt>
  
  =item C<NegativeOrZeroInt>
  
  =item C<SingleDigit>
  
  =back
  
  C<SingleDigit> interestingly accepts the numbers -9 to -1; not
  just 0 to 9. 
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::String>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_NUMERIC

$fatpacked{"Types/Common/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_STRING';
  package Types::Common::String;
  
  use 5.006001;
  use strict;
  use warnings;
  use utf8;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::String::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::String::VERSION   = '0.038';
  }
  
  use Type::Library -base, -declare => qw(
  	SimpleStr
  	NonEmptySimpleStr
  	NumericCode
  	LowerCaseSimpleStr
  	UpperCaseSimpleStr
  	Password
  	StrongPassword
  	NonEmptyStr
  	LowerCaseStr
  	UpperCaseStr
  );
  
  use Types::Standard qw( Str );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => SimpleStr,
  	parent     => Str,
  	constraint => sub { length($_) <= 255 and not /\n/ },
  	inlined    => sub { undef, qq(length($_) <= 255), qq($_ !~ /\\n/) },
  	message    => sub { "Must be a single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NonEmptySimpleStr,
  	parent     => SimpleStr,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must be a non-empty single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NumericCode,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { /^[0-9]+$/ },
  	inlined    => sub { SimpleStr->inline_check($_), qq($_ =~ m/^[0-9]+\$/) },
  	message    => sub {
  		'Must be a non-empty single line of no more than 255 chars that consists '
  			. 'of numeric characters only'
  	},
  );
  
  NumericCode->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ do { (my $code = $_) =~ s/[[:punct:]]//g; $code } ],
  );
  
  $meta->add_type(
  	name       => Password,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { length($_) > 3 },
  	inlined    => sub { SimpleStr->inline_check($_), qq(length($_) > 3) },
  	message    => sub { "Must be between 4 and 255 chars" },
  );
  
  $meta->add_type(
  	name       => StrongPassword,
  	parent     => Password,
  	constraint => sub { length($_) > 7 and /[^a-zA-Z]/ },
  	inlined    => sub { SimpleStr()->inline_check($_), qq(length($_) > 7), qq($_ =~ /[^a-zA-Z]/) },
  	message    => sub { "Must be between 8 and 255 chars, and contain a non-alpha char" },
  );
  
  $meta->add_type(
  	name       => NonEmptyStr,
  	parent     => Str,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must not be empty" },
  );
  
  $meta->add_type(
  	name       => LowerCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain upper case letters" },
  );
  
  LowerCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ uc($_) ],
  );
  
  $meta->add_type(
  	name       => LowerCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain pper case letters" },
  );
  
  LowerCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ uc($_) ],
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::String - drop-in replacement for MooseX::Types::Common::String
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::String>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::String>.
  
  =over
  
  =item C<SimpleStr>
  
  =item C<NonEmptySimpleStr>
  
  =item C<NumericCode>
  
  =item C<LowerCaseSimpleStr>
  
  =item C<UpperCaseSimpleStr>
  
  =item C<Password>
  
  =item C<StrongPassword>
  
  =item C<NonEmptyStr>
  
  =item C<LowerCaseStr>
  
  =item C<UpperCaseStr>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::Numeric>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_STRING

$fatpacked{"Types/Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Types::Path::Tiny;
  # ABSTRACT: Path::Tiny types and coercions for Moose and Moo
  our $VERSION = '0.005'; # VERSION
  
  use Path::Tiny qw();
  use Type::Library 0.008 -base, -declare => qw( Path AbsPath File AbsFile Dir AbsDir );
  use Type::Utils;
  use Types::Standard qw( Str ArrayRef );
  use Types::TypeTiny 0.004 StringLike => { -as => "Stringable" };
  
  #<<<
  class_type Path, { class => "Path::Tiny" };
  
  declare AbsPath,
      as Path, where { $_->is_absolute },
      inline_as { $_[0]->parent->inline_check($_) . "&& ${_}->is_absolute" },
      message {
          is_Path($_) ? "Path '$_' is not absolute" : Path->get_message($_);
      };
  
  declare File,
      as Path, where { $_->is_file },
      inline_as { $_[0]->parent->inline_check($_) . "&& (-f $_)" },
      message {
          is_Path($_) ? "File '$_' does not exist" : Path->get_message($_);
      };
  
  declare Dir,
      as Path, where { $_->is_dir },
      inline_as { $_[0]->parent->inline_check($_) . "&& (-d $_)" },
      message {
          is_Path($_) ? "Directory '$_' does not exist" : Path->get_message($_);
      };
  
  declare AbsFile,
      as intersection([AbsPath, File]),
      message {
          is_AbsPath($_) ? File->get_message($_) : AbsPath->get_message($_);
      };
  
  declare AbsDir,
      as intersection([AbsPath, Dir]),
      message {
          is_AbsPath($_) ? Dir->get_message($_) : AbsPath->get_message($_);
      };
  #>>>
  
  for my $type ( Path, File, Dir ) {
      coerce(
          $type,
          from Str()        => q{ Path::Tiny::path($_) },
          from Stringable() => q{ Path::Tiny::path($_) },
          from ArrayRef()   => q{ Path::Tiny::path(@$_) },
      );
  }
  
  for my $type ( AbsPath, AbsFile, AbsDir ) {
      coerce(
          $type,
          from Path         => q{ $_->absolute },
          from Str()        => q{ Path::Tiny::path($_)->absolute },
          from Stringable() => q{ Path::Tiny::path($_)->absolute },
          from ArrayRef()   => q{ Path::Tiny::path(@$_)->absolute },
      );
  }
  
  ### optionally add Getopt option type (adapted from MooseX::Types:Path::Class
  ##eval { require MooseX::Getopt; };
  ##if ( !$@ ) {
  ##    MooseX::Getopt::OptionTypeMap->add_option_type_to_map( $_, '=s', )
  ##      for ( 'Path::Tiny', Path );
  ##}
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Path::Tiny - Path::Tiny types and coercions for Moose and Moo
  
  =head1 VERSION
  
  version 0.005
  
  =head1 SYNOPSIS
  
    ### specification of type constraint with coercion
  
    package Foo;
  
    use Moose;
    use Types::Path::Tiny qw/Path AbsPath/;
  
    has filename => (
      is => 'ro',
      isa => Path,
      coerce => 1,
    );
  
    has directory => (
      is => 'ro',
      isa => AbsPath,
      coerce => 1,
    );
  
    ### usage in code
  
    Foo->new( filename => 'foo.txt' ); # coerced to Path::Tiny
    Foo->new( directory => '.' ); # coerced to path('.')->absolute
  
  =head1 DESCRIPTION
  
  This module provides L<Path::Tiny> types for Moose, Moo, etc.
  
  It handles two important types of coercion:
  
  =over 4
  
  =item *
  
  coercing objects with overloaded stringification
  
  =item *
  
  coercing to absolute paths
  
  =back
  
  It also can check to ensure that files or directories exist.
  
  =for Pod::Coverage method_names_here
  
  =head1 SUBTYPES
  
  This module uses L<Type::Tiny> to define the following subtypes.
  
  =head2 Path
  
  C<Path> ensures an attribute is a L<Path::Tiny> object.  Strings and
  objects with overloaded stringification may be coerced.
  
  =head2 AbsPath
  
  C<AbsPath> is a subtype of C<Path> (above), but coerces to an absolute path.
  
  =head2 File, AbsFile
  
  These are just like C<Path> and C<AbsPath>, except they check C<-f> to ensure
  the file actually exists on the filesystem.
  
  =head2 Dir, AbsDir
  
  These are just like C<Path> and C<AbsPath>, except they check C<-d> to ensure
  the directory actually exists on the filesystem.
  
  =head1 CAVEATS
  
  =head2 Path vs File vs Dir
  
  C<Path> just ensures you have a L<Path::Tiny> object.
  
  C<File> and C<Dir> check the filesystem.  Don't use them unless that's really
  what you want.
  
  =head2 Usage with File::Temp
  
  Be careful if you pass in a File::Temp object. Because the argument is
  stringified during coercion into a Path::Tiny object, no reference to the
  original File::Temp argument is held.  Be sure to hold an external reference to
  it to avoid immediate cleanup of the temporary file or directory at the end of
  the enclosing scope.
  
  A better approach is to use Path::Tiny's own C<tempfile> or C<tempdir>
  constructors, which hold the reference for you.
  
      Foo->new( filename => Path::Tiny->tempfile );
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Path::Tiny>
  
  =item *
  
  L<Moose::Manual::Types>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/types-path-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/types-path-tiny>
  
    git clone git://github.com/dagolden/types-path-tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTOR
  
  Toby Inkster <tobyink@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
TYPES_PATH_TINY

$fatpacked{"Types/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD';
  package Types::Standard;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	eval { require re };
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  	if ($] < 5.010) { require Devel::TypeTiny::Perl58Compat };
  }
  
  BEGIN {
  	$Types::Standard::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::VERSION   = '0.038';
  }
  
  use Type::Library -base;
  
  our @EXPORT_OK = qw( slurpy );
  
  use Scalar::Util qw( blessed looks_like_number );
  use Types::TypeTiny ();
  
  sub _is_class_loaded {
  	return !!0 if ref $_[0];
  	return !!0 if not $_[0];
  	my $stash = do { no strict 'refs'; \%{"$_[0]\::"} };
  	return !!1 if exists $stash->{'ISA'};
  	return !!1 if exists $stash->{'VERSION'};
  	foreach my $globref (values %$stash) {
  		return !!1 if *{$globref}{CODE};
  	}
  	return !!0;
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = __PACKAGE__->meta;
  
  sub Stringable (&)
  {
  	package #private
  	Types::Standard::_Stringable;
  	use overload q[""] => sub { $_[0]{text} ||= $_[0]{code}->() }, fallback => 1;
  	bless +{ code => $_[0] };
  }
  
  sub LazyLoad ($$)
  {
  	package #private
  	Types::Standard::LazyLoad;
  	use overload fallback => 1, q[&{}] => sub {
  		my ($typename, $function) = @{$_[0]};
  		my $type  = $meta->get_type($typename);
  		my $class = "Types::Standard::$typename";
  		eval "require $class; 1" or die($@);
  		# Majorly break encapsulation for Type::Tiny :-O
  		for my $key (keys %$type)
  		{
  			next unless ref($type->{$key}) eq __PACKAGE__;
  			my $f = $type->{$key}[1];
  			$type->{$key} = $class->can("__$f");
  		}
  		return $class->can("__$function");
  	};
  	bless \@_;
  }
  
  no warnings;
  
  BEGIN { *STRICTNUM = $ENV{PERL_TYPES_STANDARD_STRICTNUM} ? sub(){!!1} : sub(){!!0} };
  
  my $_any = $meta->add_type({
  	name       => "Any",
  	_is_core   => 1,
  	inlined    => sub { "!!1" },
  });
  
  my $_item = $meta->add_type({
  	name       => "Item",
  	_is_core   => 1,
  	inlined    => sub { "!!1" },
  	parent     => $_any,
  });
  
  $meta->add_type({
  	name       => "Bool",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { !defined $_ or $_ eq q() or $_ eq '0' or $_ eq '1' },
  	inlined    => sub { "!defined $_[1] or $_[1] eq q() or $_[1] eq '0' or $_[1] eq '1'" },
  });
  
  my $_undef = $meta->add_type({
  	name       => "Undef",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { !defined $_ },
  	inlined    => sub { "!defined($_[1])" },
  });
  
  my $_def = $meta->add_type({
  	name       => "Defined",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { defined $_ },
  	inlined    => sub { "defined($_[1])" },
  });
  
  my $_val = $meta->add_type({
  	name       => "Value",
  	_is_core   => 1,
  	parent     => $_def,
  	constraint => sub { not ref $_ },
  	inlined    => sub { "defined($_[1]) and not ref($_[1])" },
  });
  
  my $_str = $meta->add_type({
  	name       => "Str",
  	_is_core   => 1,
  	parent     => $_val,
  	constraint => sub { ref(\$_) eq 'SCALAR' or ref(\(my $val = $_)) eq 'SCALAR' },
  	inlined    => sub {
  		"defined($_[1]) and do { ref(\\$_[1]) eq 'SCALAR' or ref(\\(my \$val = $_[1])) eq 'SCALAR' }"
  	},
  });
  
  my $_laxnum = $meta->add_type({
  	name       => "LaxNum",
  	parent     => $_str,
  	constraint => sub { looks_like_number $_ },
  	inlined    => sub { "defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1])" },
  });
  
  my $_strictnum = $meta->add_type({
  	name       => "StrictNum",
  	parent     => $_str,
  	constraint => sub {
  		my $val = $_;
  		($val =~ /\A[+-]?[0-9]+\z/) ||
  		( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
  		(?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
  		[0-9]*                                #matches 0-9 zero or more times
  		(?:\.[0-9]+)?                         #matches optional .89 or nothing
  		(?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
  		\z/x );
  	},
  	inlined    => sub {
  		'my $val = '.$_[1].';'.
  		Value()->inline_check('$val')
  		.' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
  		. '$val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
  			(?=[0-9]|\.[0-9])                 # matches previous +- only if there is something like 3 or .3
  			[0-9]*                            # matches 0-9 zero or more times
  			(?:\.[0-9]+)?                     # matches optional .89 or nothing
  			(?:[Ee](?:[+-]?[0-9]+))?          # matches E1 or e1 or e-1 or e+1 etc
  		\z/x ); '
  	},
  });
  
  my $_num = $meta->add_type({
  	name       => "Num",
  	_is_core   => 1,
  	parent     => (STRICTNUM ? $_strictnum : $_laxnum),
  });
  
  $meta->add_type({
  	name       => "Int",
  	_is_core   => 1,
  	parent     => $_num,
  	constraint => sub { /\A-?[0-9]+\z/ },
  	inlined    => sub { "defined $_[1] and $_[1] =~ /\\A-?[0-9]+\\z/" },
  });
  
  my $_classn = $meta->add_type({
  	name       => "ClassName",
  	_is_core   => 1,
  	parent     => $_str,
  	constraint => sub { goto \&_is_class_loaded },
  	inlined    => sub { "Types::Standard::_is_class_loaded($_[1])" },
  });
  
  $meta->add_type({
  	name       => "RoleName",
  	parent     => $_classn,
  	constraint => sub { not $_->can("new") },
  	inlined    => sub { "Types::Standard::_is_class_loaded($_[1]) and not $_[1]\->can('new')" },
  });
  
  my $_ref = $meta->add_type({
  	name       => "Ref",
  	_is_core   => 1,
  	parent     => $_def,
  	constraint => sub { ref $_ },
  	inlined    => sub { "!!ref($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Ref') unless @_;
  		
  		my $reftype = shift;
  		Types::TypeTiny::StringLike->check($reftype)
  			or _croak("Parameter to Ref[`a] expected to be string; got $reftype");
  		
  		$reftype = "$reftype";
  		return sub {
  			ref($_[0]) and Scalar::Util::reftype($_[0]) eq $reftype;
  		}
  	},
  	inline_generator => sub
  	{
  		my $reftype = shift;
  		return sub {
  			my $v = $_[1];
  			"ref($v) and Scalar::Util::reftype($v) eq q($reftype)";
  		};
  	},
  	deep_explanation => sub {
  		require B;
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		return if $type->check($value);
  		my $reftype = Scalar::Util::reftype($value);
  		return [
  			sprintf('"%s" constrains reftype(%s) to be equal to %s', $type, $varname, B::perlstring($param)),
  			sprintf('reftype(%s) is %s', $varname, defined($reftype) ? B::perlstring($reftype) : "undef"),
  		];
  	},
  });
  
  $meta->add_type({
  	name       => "CodeRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "CODE" },
  	inlined    => sub { "ref($_[1]) eq 'CODE'" },
  });
  
  $meta->add_type({
  	name       => "RegexpRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref($_) && !!re::is_regexp($_) },
  	inlined    => sub { "ref($_[1]) && !!re::is_regexp($_[1])" },
  });
  
  $meta->add_type({
  	name       => "GlobRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "GLOB" },
  	inlined    => sub { "ref($_[1]) eq 'GLOB'" },
  });
  
  $meta->add_type({
  	name       => "FileHandle",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub {
  		(ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
  		or (blessed($_) && $_->isa("IO::Handle"))
  	},
  	inlined    => sub {
  		"(ref($_[1]) eq \"GLOB\" && Scalar::Util::openhandle($_[1])) ".
  		"or (Scalar::Util::blessed($_[1]) && $_[1]\->isa(\"IO::Handle\"))"
  	},
  });
  
  my $_arr = $meta->add_type({
  	name       => "ArrayRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "ARRAY" },
  	inlined    => sub { "ref($_[1]) eq 'ARRAY'" },
  	constraint_generator => LazyLoad(ArrayRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ArrayRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ArrayRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ArrayRef => 'coercion_generator'),
  });
  
  my $_hash = $meta->add_type({
  	name       => "HashRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "HASH" },
  	inlined    => sub { "ref($_[1]) eq 'HASH'" },
  	constraint_generator => LazyLoad(HashRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(HashRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(HashRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(HashRef => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "ScalarRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "SCALAR" or ref $_ eq "REF" },
  	inlined    => sub { "ref($_[1]) eq 'SCALAR' or ref($_[1]) eq 'REF'" },
  	constraint_generator => LazyLoad(ScalarRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ScalarRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ScalarRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ScalarRef => 'coercion_generator'),
  });
  
  my $_obj = $meta->add_type({
  	name       => "Object",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { blessed $_ },
  	inlined    => sub { "Scalar::Util::blessed($_[1])" },
  });
  
  $meta->add_type({
  	name       => "Maybe",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Maybe') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Maybe[`a] expected to be a type constraint; got $param");
  		
  		return sub
  		{
  			my $value = shift;
  			return !!1 unless defined $value;
  			return $param->check($value);
  		};
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!defined($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s is defined', Type::Tiny::_dd($value)),
  			sprintf('"%s" constrains the value with "%s" if it is defined', $type, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  my $_map = $meta->add_type({
  	name       => "Map",
  	parent     => $_hash,
  	constraint_generator => LazyLoad(Map => 'constraint_generator'),
  	inline_generator     => LazyLoad(Map => 'inline_generator'),
  	deep_explanation     => LazyLoad(Map => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Map => 'coercion_generator'),
  });
  
  my $_Optional = $meta->add_type({
  	name       => "Optional",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Optional') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Optional[`a] expected to be a type constraint; got $param");
  		
  		sub { exists($_[0]) ? $param->check($_[0]) : !!1 }
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!exists($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s exists', $varname),
  			sprintf('"%s" constrains %s with "%s" if it exists', $type, $varname, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  sub slurpy {
  	my $t = shift;
  	wantarray ? (+{ slurpy => $t }, @_) : +{ slurpy => $t };
  }
  
  $meta->add_type({
  	name       => "Tuple",
  	parent     => $_arr,
  	name_generator => sub
  	{
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], map { ref($_) eq "HASH" ? sprintf("slurpy %s", $_->{slurpy}) : $_ } @a);
  	},
  	constraint_generator => LazyLoad(Tuple => 'constraint_generator'),
  	inline_generator     => LazyLoad(Tuple => 'inline_generator'),
  	deep_explanation     => LazyLoad(Tuple => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Tuple => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "Dict",
  	parent     => $_hash,
  	name_generator => sub
  	{
  		my ($s, @p) = @_;
  		my $l = ref($p[-1]) eq q(HASH) ? pop(@p)->{slurpy} : undef;
  		my %a = @p;
  		sprintf('%s[%s%s]', $s, join(q[,], map sprintf("%s=>%s", $_, $a{$_}), sort keys %a), $l ? ",slurpy $l" : '');
  	},
  	constraint_generator => LazyLoad(Dict => 'constraint_generator'),
  	inline_generator     => LazyLoad(Dict => 'inline_generator'),
  	deep_explanation     => LazyLoad(Dict => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Dict => 'coercion_generator'),
  });
  
  use overload ();
  $meta->add_type({
  	name       => "Overload",
  	parent     => $_obj,
  	constraint => sub { overload::Overloaded($_) },
  	inlined    => sub { "Scalar::Util::blessed($_[1]) and overload::Overloaded($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Overload') unless @_;
  		
  		my @operations = map {
  			Types::TypeTiny::StringLike->check($_)
  				? "$_"
  				: _croak("Parameters to Overload[`a] expected to be a strings; got $_");
  		} @_;
  		
  		return sub {
  			my $value = shift;
  			for my $op (@operations) {
  				return unless overload::Method($value, $op);
  			}
  			return !!1;
  		}
  	},
  	inline_generator => sub {
  		my @operations = @_;
  		return sub {
  			my $v = $_[1];
  			join " and ",
  				"Scalar::Util::blessed($v)",
  				map "overload::Method($v, q[$_])", @operations;
  		};
  	},
  });
  
  our %_StrMatch;
  $meta->add_type({
  	name       => "StrMatch",
  	parent     => $_str,
  	constraint_generator => sub
  	{
  		return $meta->get_type('StrMatch') unless @_;
  		
  		my ($regexp, $checker) = @_;
  		
  		ref($regexp) eq 'Regexp'
  			or _croak("First parameter to StrMatch[`a] expected to be a Regexp; got $regexp");
  		
  		if (@_ > 1)
  		{
  			$checker = Types::TypeTiny::to_TypeTiny($checker);
  			Types::TypeTiny::TypeTiny->check($checker)
  				or _croak("Second parameter to StrMatch[`a] expected to be a type constraint; got $checker")
  		}
  		
  		$checker
  			? sub {
  				my $value = shift;
  				return if ref($value);
  				my @m = ($value =~ $regexp);
  				$checker->check(\@m);
  			}
  			: sub {
  				my $value = shift;
  				!ref($value) and $value =~ $regexp;
  			}
  		;
  	},
  	inline_generator => sub
  	{
  		require B;
  		my ($regexp, $checker) = @_;
  		my $regexp_string = "$regexp";
  		$_StrMatch{$regexp_string} = $regexp;
  		if ($checker)
  		{
  			return unless $checker->can_be_inlined;
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and do { my \$m = [$v =~ \$Types::Standard::_StrMatch{%s}]; %s }",
  					B::perlstring($regexp_string),
  					$checker->inline_check('$m'),
  				;
  			};
  		}
  		else
  		{
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and $v =~ \$Types::Standard::_StrMatch{%s}",
  					B::perlstring($regexp_string),
  				;
  			};
  		}
  	},
  });
  
  $meta->add_type({
  	name       => "OptList",
  	parent     => $_arr,
  	constraint => sub {
  		for my $inner (@$_) {
  			return unless ref($inner) eq q(ARRAY);
  			return unless @$inner == 2;
  			return unless is_Str($inner->[0]);
  		}
  		return !!1;
  	},
  	inlined     => sub {
  		my ($self, $var) = @_;
  		my $Str_check = Str()->inline_check('$inner->[0]');
  		my @code = 'do { my $ok = 1; ';
  		push @code,   sprintf('for my $inner (@{%s}) { no warnings; ', $var);
  		push @code,   sprintf('($ok=0) && last unless ref($inner) eq q(ARRAY) && @$inner == 2 && (%s); ', $Str_check);
  		push @code,   '} ';
  		push @code, '$ok }';
  		return (undef, join(q( ), @code));
  	},
  });
  
  $meta->add_type({
  	name       => "Tied",
  	parent     => $_ref,
  	constraint => sub {
  		!!tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_})
  	},
  	inlined    => sub {
  		my ($self, $var) = @_;
  		$self->parent->inline_check($var)
  		. " and !!tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var})"
  	},
  	name_generator => sub
  	{
  		my $self  = shift;
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require B;
  			return sprintf("%s[%s]", $self, B::perlstring($param));
  		}
  		return sprintf("%s[%s]", $self, $param);
  	},
  	constraint_generator => sub
  	{
  		return $meta->get_type('Tied') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		
  		my $check = $param->compiled_check;
  		return sub {
  			$check->(tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_}));
  		};
  	},
  	inline_generator => sub {
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		return unless $param->can_be_inlined;
  		
  		return sub {
  			require B;
  			my $var = $_[1];
  			sprintf(
  				"%s and do { my \$TIED = tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var}); %s }",
  				Ref()->inline_check($var),
  				$param->inline_check('$TIED')
  			);
  		};
  	},
  });
  
  $meta->add_type({
  	name       => "InstanceOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('InstanceOf') unless @_;
  		require Type::Tiny::Class;
  		my @classes = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Class"->new(class => $_, display_name => sprintf('InstanceOf[%s]', B::perlstring($_)))
  		} @_;
  		return $classes[0] if @classes == 1;
  		
  		require B;
  		require Type::Tiny::Union;
  		return "Type::Tiny::Union"->new(
  			type_constraints => \@classes,
  			display_name     => sprintf('InstanceOf[%s]', join q[,], map B::perlstring($_->class), @classes),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "ConsumerOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('ConsumerOf') unless @_;
  		require B;
  		require Type::Tiny::Role;
  		my @roles = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Role"->new(role => $_, display_name => sprintf('ConsumerOf[%s]', B::perlstring($_)))
  		} @_;
  		return $roles[0] if @roles == 1;
  		
  		require Type::Tiny::Intersection;
  		return "Type::Tiny::Intersection"->new(
  			type_constraints => \@roles,
  			display_name     => sprintf('ConsumerOf[%s]', join q[,], map B::perlstring($_->role), @roles),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "HasMethods",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('HasMethods') unless @_;
  		require B;
  		require Type::Tiny::Duck;
  		return "Type::Tiny::Duck"->new(
  			methods      => \@_,
  			display_name => sprintf('HasMethods[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "Enum",
  	parent     => $_str,
  	constraint_generator => sub {
  		return $meta->get_type('Enum') unless @_;
  		require B;
  		require Type::Tiny::Enum;
  		return "Type::Tiny::Enum"->new(
  			values       => \@_,
  			display_name => sprintf('Enum[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_coercion({
  	name               => "MkOpt",
  	type_constraint    => $meta->get_type("OptList"),
  	type_coercion_map  => [
  		$_arr,    q{ Exporter::Tiny::mkopt($_) },
  		$_hash,   q{ Exporter::Tiny::mkopt($_) },
  		$_undef,  q{ [] },
  	],
  });
  
  $meta->add_coercion({
  	name               => "Join",
  	type_constraint    => $_str,
  	coercion_generator => sub {
  		my ($self, $target, $sep) = @_;
  		Types::TypeTiny::StringLike->check($sep)
  			or _croak("Parameter to Join[`a] expected to be a string; got $sep");
  		require B;
  		$sep = B::perlstring($sep);
  		return (ArrayRef(), qq{ join($sep, \@\$_) });
  	},
  });
  
  $meta->add_coercion({
  	name               => "Split",
  	type_constraint    => $_arr,
  	coercion_generator => sub {
  		my ($self, $target, $re) = @_;
  		ref($re) eq q(Regexp)
  			or _croak("Parameter to Split[`a] expected to be a regular expresssion; got $re");
  		my $regexp_string = "$re";
  		$regexp_string =~ s/\\\//\\\\\//g; # toothpicks
  		return (Str(), qq{ [split /$regexp_string/, \$_] });
  	},
  });
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords booleans vstrings typeglobs
  
  =encoding utf-8
  
  =for stopwords datetimes
  
  =head1 NAME
  
  Types::Standard - bundled set of built-in types for Type::Tiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> bundles a few types which seem to be useful.
  
  =head2 Moose-like
  
  The following types are similar to those described in
  L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< Any >>
  
  Absolutely any value passes this type constraint (even undef).
  
  =item C<< Item >>
  
  Essentially the same as C<Any>. All other type constraints in this library
  inherit directly or indirectly from C<Item>.
  
  =item C<< Bool >>
  
  Values that are reasonable booleans. Accepts 1, 0, the empty string and
  undef.
  
  =item C<< Maybe[`a] >>
  
  Given another type constraint, also accepts undef. For example,
  C<< Maybe[Int] >> accepts all integers plus undef.
  
  =item C<< Undef >>
  
  Only undef passes this type constraint.
  
  =item C<< Defined >>
  
  Only undef fails this type constraint.
  
  =item C<< Value >>
  
  Any defined, non-reference value.
  
  =item C<< Str >>
  
  Any string.
  
  (The only difference between C<Value> and C<Str> is that the former accepts
  typeglobs and vstrings.)
  
  Other customers also bought: C<< StringLike >> from L<Types::TypeTiny>.
  
  =item C<< Num >>
  
  See C<LaxNum> and C<StrictNum> below.
  
  =item C<< Int >>
  
  An integer; that is a string of digits 0 to 9, optionally prefixed with a
  hyphen-minus character.
  
  =item C<< ClassName >>
  
  The name of a loaded package. The package must have C<< @ISA >> or
  C<< $VERSION >> defined, or must define at least one sub to be considered
  a loaded package.
  
  =item C<< RoleName >>
  
  Like C<< ClassName >>, but the package must I<not> define a method called
  C<new>. This is subtly different from Moose's type constraint of the same
  name; let me know if this causes you any problems. (I can't promise I'll
  change anything though.)
  
  =item C<< Ref[`a] >>
  
  Any defined reference value, including blessed objects.
  
  Unlike Moose, C<Ref> is a parameterized type, allowing Scalar::Util::reftype
  checks, a la
  
     Ref["HASH"]  # hashrefs, including blessed hashrefs
  
  =item C<< ScalarRef[`a] >>
  
  A value where C<< ref($value) eq "SCALAR" or ref($value) eq "REF" >>.
  
  If parameterized, the referred value must pass the additional constraint.
  For example, C<< ScalarRef[Int] >> must be a reference to a scalar which
  holds an integer value.
  
  =item C<< ArrayRef[`a] >>
  
  A value where C<< ref($value) eq "ARRAY" >>.
  
  If parameterized, the elements of the array must pass the additional
  constraint. For example, C<< ArrayRef[Num] >> must be a reference to an
  array of numbers.
  
  Other customers also bought: C<< ArrayLike >> from L<Types::TypeTiny>.
  
  =item C<< HashRef[`a] >>
  
  A value where C<< ref($value) eq "HASH" >>.
  
  If parameterized, the values of the hash must pass the additional
  constraint. For example, C<< HashRef[Num] >> must be a reference to an
  hash where the values are numbers. The hash keys are not constrained,
  but Perl limits them to strings; see C<Map> below if you need to further
  constrain the hash values.
  
  Other customers also bought: C<< HashLike >> from L<Types::TypeTiny>.
  
  =item C<< CodeRef >>
  
  A value where C<< ref($value) eq "CODE" >>.
  
  Other customers also bought: C<< CodeLike >> from L<Types::TypeTiny>.
  
  =item C<< RegexpRef >>
  
  A value where C<< ref($value) eq "Regexp" >>.
  
  =item C<< GlobRef >>
  
  A value where C<< ref($value) eq "GLOB" >>.
  
  =item C<< FileHandle >>
  
  A file handle.
  
  =item C<< Object >>
  
  A blessed object.
  
  (This also accepts regexp refs.)
  
  =back
  
  =head2 Structured
  
  OK, so I stole some ideas from L<MooseX::Types::Structured>.
  
  =over
  
  =item C<< Map[`k, `v] >>
  
  Similar to C<HashRef> but parameterized with type constraints for both the
  key and value. The constraint for keys would typically be a subtype of
  C<Str>.
  
  =item C<< Tuple[...] >>
  
  Subtype of C<ArrayRef>, accepting an list of type constraints for
  each slot in the array.
  
  C<< Tuple[Int, HashRef] >> would match C<< [1, {}] >> but not C<< [{}, 1] >>.
  
  =item C<< Dict[...] >>
  
  Subtype of C<HashRef>, accepting an list of type constraints for
  each slot in the hash.
  
  For example C<< Dict[name => Str, id => Int] >> allows
  C<< { name => "Bob", id => 42 } >>.
  
  =item C<< Optional[`a] >>
  
  Used in conjunction with C<Dict> and C<Tuple> to specify slots that are
  optional and may be omitted (but not necessarily set to an explicit undef).
  
  C<< Dict[name => Str, id => Optional[Int]] >> allows C<< { name => "Bob" } >>
  but not C<< { name => "Bob", id => "BOB" } >>.
  
  =back
  
  This module also exports a C<slurpy> function, which can be used as follows:
  
     my $type = Tuple[Str, slurpy ArrayRef[Int]];
     
     $type->( ["Hello"] );                # ok
     $type->( ["Hello", 1, 2, 3] );       # ok
     $type->( ["Hello", [1, 2, 3]] );     # not ok
  
  =begin trustme
  
  =item slurpy
  
  =end trustme
  
  =head2 Objects
  
  OK, so I stole some ideas from L<MooX::Types::MooseLike::Base>.
  
  =over
  
  =item C<< InstanceOf[`a] >>
  
  Shortcut for a union of L<Type::Tiny::Class> constraints.
  
  C<< InstanceOf["Foo", "Bar"] >> allows objects blessed into the C<Foo>
  or C<Bar> classes, or subclasses of those.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< ConsumerOf[`a] >>
  
  Shortcut for an intersection of L<Type::Tiny::Role> constraints.
  
  C<< ConsumerOf["Foo", "Bar"] >> allows objects where C<< $o->DOES("Foo") >>
  and C<< $o->DOES("Bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< HasMethods[`a] >>
  
  Shortcut for a L<Type::Tiny::Duck> constraint.
  
  C<< HasMethods["foo", "bar"] >> allows objects where C<< $o->can("foo") >>
  and C<< $o->can("bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =back
  
  =head2 More
  
  There are a few other types exported by this function:
  
  =over
  
  =item C<< Overload[`a] >>
  
  With no parameters, checks that the value is an overloaded object. Can
  be given one or more string parameters, which are specific operations
  to check are overloaded. For example, the following checks for objects
  which overload addition and subtraction.
  
     Overload["+", "-"]
  
  =item C<< Tied[`a] >>
  
  A reference to a tied scalar, array or hash.
  
  Can be parameterized with a type constraint which will be applied to
  the object returned by the C<< tied() >> function. As a convenience,
  can also be parameterized with a string, which will be inflated to a
  L<Type::Tiny::Class>.
  
     use Types::Standard qw(Tied);
     use Type::Utils qw(class_type);
     
     my $My_Package = class_type { class => "My::Package" };
     
     tie my %h, "My::Package";
     \%h ~~ Tied;                   # true
     \%h ~~ Tied[ $My_Package ];    # true
     \%h ~~ Tied["My::Package"];    # true
     
     tie my $s, "Other::Package";
     \$s ~~ Tied;                   # true
     $s  ~~ Tied;                   # false !!
  
  If you need to check that something is specifically a reference to
  a tied hash, use an intersection:
  
     use Types::Standard qw( Tied HashRef );
     
     my $TiedHash = (Tied) & (HashRef);
     
     tie my %h, "My::Package";
     tie my $s, "Other::Package";
     
     \%h ~~ $TiedHash;     # true
     \$s ~~ $TiedHash;     # false
  
  =item C<< StrMatch[`a] >>
  
  A string that matches a regular expression:
  
     declare "Distance",
        as StrMatch[ qr{^([0-9]+)\s*(mm|cm|m|km)$} ];
  
  You can optionally provide a type constraint for the array of subexpressions:
  
     declare "Distance",
        as StrMatch[
           qr{^([0-9]+)\s*(.+)$},
           Tuple[
              Int,
              enum(DistanceUnit => [qw/ mm cm m km /]),
           ],
        ];
  
  =item C<< Enum[`a] >>
  
  As per MooX::Types::MooseLike::Base:
  
     has size => (is => "ro", isa => Enum[qw( S M L XL XXL )]);
  
  =item C<< OptList >>
  
  An arrayref of arrayrefs in the style of L<Data::OptList> output.
  
  =item C<< LaxNum >>, C<< StrictNum >>
  
  In Moose 2.09, the C<Num> type constraint implementation was changed from
  being a wrapper around L<Scalar::Util>'s C<looks_like_number> function to
  a stricter regexp (which disallows things like "-Inf" and "Nan").
  
  Types::Standard provides I<both> implementations. C<LaxNum> is measurably
  faster.
  
  The C<Num> type constraint is currently an alias for C<LaxNum> unless you
  set the C<PERL_TYPES_STANDARD_STRICTNUM> environment variable to true before
  loading Types::Standard, in which case it becomes an alias for C<StrictNum>.
  The constant C<< Types::Standard::STRICTNUM >> can be used to check if
  C<Num> is being strict.
  
  Most people should probably use C<Num> or C<StrictNum>. Don't explicitly
  use C<LaxNum> unless you specifically need an attribute which will accept
  things like "Inf".
  
  =back
  
  =head2 Coercions
  
  None of the types in this type library have any coercions by default.
  However some standalone coercions may be exported. These can be combined
  with type constraints using the C<< + >> operator.
  
  =over
  
  =item C<< MkOpt >>
  
  A coercion from C<ArrayRef>, C<HashRef> or C<Undef> to C<OptList>. Example
  usage in a Moose attribute:
  
     use Types::Standard qw( OptList MkOpt );
     
     has options => (
        is     => "ro",
        isa    => OptList + MkOpt,
        coerce => 1,
     );
  
  =item C<< Split[`a] >>
  
  Split a string on a regexp.
  
     use Types::Standard qw( ArrayRef Str Split );
     
     has name => (
        is     => "ro",
        isa    => (ArrayRef[Str]) + (Split[qr/\s/]),
        coerce => 1,
     );
  
  =item C<< Join[`a] >>
  
  Join an array of strings with a delimiter.
  
     use Types::Standard qw( Str Join );
     
     my $FileLines = Str + Join["\n"];
     
     has file_contents => (
        is     => "ro",
        isa    => $FileLines,
        coerce => 1,
     );
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< Types::Standard::STRICTNUM >>
  
  Indicates whether C<Num> is an alias for C<StrictNum>. (It is usually an
  alias for C<LaxNum>.)
  
  =back
  
  =begin private
  
  =item Stringable
  
  =item LazyLoad
  
  =end private
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>,
  L<MooseX::Types::Structured>.
  
  L<Types::XSD> provides some type constraints based on XML Schema's data
  types; this includes constraints for ISO8601-formatted datetimes, integer
  ranges (e.g. C<< PositiveInteger[maxInclusive=>10] >> and so on.
  
  L<Types::Encodings> provides C<Bytes> and C<Chars> type constraints that
  were formerly found in Types::Standard.
  
  L<Types::Common::Numeric> and L<Types::Common::String> provide replacements
  for L<MooseX::Types::Common>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD

$fatpacked{"Types/Standard/ArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_ARRAYREF';
  package Types::Standard::ArrayRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ArrayRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ArrayRef::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ArrayRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ArrayRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $array = shift;
  		$param->check($_) || return for @$array;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'ARRAY' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (\@{$v}) { "
  		.    "\$ok = 0 && last unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $i (0 .. $#$value)
  	{
  		my $item = $value->[$i];
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the array with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->[%d]', $varname, $i)) },
  		]
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @new) = ($_, 0);';
  			push @code,    'for (@$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('push @new, (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my @new;
  				for my $item (@$value)
  				{
  					return $value unless $coercable_item->check($item);
  					push @new, $param->coerce($item);
  				}
  				return \@new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ArrayRef - internals for the Types::Standard ArrayRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_ARRAYREF

$fatpacked{"Types/Standard/Dict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_DICT';
  package Types::Standard::Dict;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Dict::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Dict::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_hash = Types::Standard::HashRef;
  my $_map  = Types::Standard::Map;
  my $_any  = Types::Standard::Any;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my %constraints = @_;
  	
  	while (my ($k, $v) = each %constraints)
  	{
  		$constraints{$k} = Types::TypeTiny::to_TypeTiny($v);
  		Types::TypeTiny::TypeTiny->check($v)
  			or _croak("Parameter to Dict[`a] for key '$k' expected to be a type constraint; got $v");
  	}
  	
  	return sub
  	{
  		my $value = $_[0];
  		if ($slurpy)
  		{
  			my %tmp = map {
  				exists($constraints{$_}) ? () : ($_ => $value->{$_})
  			} keys %$value;
  			return unless $slurpy->check(\%tmp);
  		}
  		else
  		{
  			exists($constraints{$_}) || return for sort keys %$value;
  		}
  		for (sort keys %constraints) {
  			my $c = $constraints{$_};
  			return unless exists($value->{$_}) || $c->is_strictly_a_type_of(Types::Standard::Optional);
  			return unless $c->check( exists $value->{$_} ? $value->{$_} : () );
  		}
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	# We can only inline a parameterized Dict if all the
  	# constraints inside can be inlined.
  	
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	return if $slurpy && !$slurpy->can_be_inlined;
  	
  	# Is slurpy a very loose type constraint?
  	# i.e. Any, Item, Defined, Ref, or HashRef
  	my $slurpy_is_any = $slurpy && $_hash->is_a_type_of( $slurpy );
  	
  	# Is slurpy a parameterized Map, or expressable as a parameterized Map?
  	my $slurpy_is_map = $slurpy
  		&& $slurpy->is_parameterized
  		&& ((
  			$slurpy->parent->strictly_equals($_map)
  			&& $slurpy->parameters
  		)||(
  			$slurpy->parent->strictly_equals($_hash)
  			&& [ $_any, $slurpy->parameters->[0] ]
  		));
  	
  	my %constraints = @_;
  	for my $c (values %constraints)
  	{
  		next if $c->can_be_inlined;
  		return;
  	}
  	
  	my $regexp = join "|", map quotemeta, sort keys %constraints;
  	return sub
  	{
  		require B;
  		my $h = $_[1];
  		join " and ",
  			"ref($h) eq 'HASH'",
  			( $slurpy_is_any ? '1'
  			: $slurpy_is_map ? do {
  				'(not grep {'
  				."my \$v = ($h)->{\$_};"
  				.sprintf(
  					'not((%s) and (%s))',
  					$slurpy_is_map->[0]->inline_check('$_'),
  					$slurpy_is_map->[1]->inline_check('$v'),
  				) ."} keys \%{$h})"
  			}
  			: $slurpy ? do {
  				'do {'
  				. "my \$slurpy_tmp = +{ map /\\A(?:$regexp)\\z/ ? () : (\$_ => ($h)->{\$_}), keys \%{$h} };"
  				. $slurpy->inline_check('$slurpy_tmp')
  				. '}'
  			}
  			: "not(grep !/\\A(?:$regexp)\\z/, keys \%{$h})" ),
  			( map {
  				my $k = B::perlstring($_);
  				$constraints{$_}->is_strictly_a_type_of( Types::Standard::Optional )
  					? $constraints{$_}->inline_check("$h\->{$k}")
  					: ( "exists($h\->{$k})", $constraints{$_}->inline_check("$h\->{$k}") )
  			} sort keys %constraints ),
  	}
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my @params = @{ $type->parameters };
  	
  	my $slurpy = ref($params[-1]) eq q(HASH) ? pop(@params)->{slurpy} : undef;
  	my %constraints = @params;
  			
  	for my $k (sort keys %constraints)
  	{
  		next if $constraints{$k}->parent == Types::Standard::Optional && !exists $value->{$k};
  		next if $constraints{$k}->check($value->{$k});
  		
  		return [
  			sprintf('"%s" requires key %s to appear in hash', $type, B::perlstring($k))
  		] unless exists $value->{$k};
  		
  		return [
  			sprintf('"%s" constrains value at key %s of hash with "%s"', $type, B::perlstring($k), $constraints{$k}),
  			@{ $constraints{$k}->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	if ($slurpy)
  	{
  		my %tmp = map {
  			exists($constraints{$_}) ? () : ($_ => $value->{$_})
  		} keys %$value;
  		
  		my $explain = $slurpy->validate_explain(\%tmp, '$slurpy');
  		return [
  			sprintf('"%s" requires the hashref of additional key/value pairs to conform to "%s"', $type, $slurpy),
  			@$explain,
  		] if $explain;
  	}
  	else
  	{
  		for my $k (sort keys %$value)
  		{
  			return [
  				sprintf('"%s" does not allow key %s to appear in hash', $type, B::perlstring($k))
  			] unless exists $constraints{$k};
  		}
  	}
  	
  	return;
  }
  
  my $label_counter = 0;
  our ($keycheck_counter, @KEYCHECK) = -1;
  sub __coercion_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my ($parent, $child, %dict) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $all_inlinable = 1;
  	for my $tc (values %dict)
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	$all_inlinable = 0 if $slurpy && !$slurpy->can_be_inlined;
  	$all_inlinable = 0 if $slurpy && $slurpy->has_coercion && !$slurpy->coercion->can_be_inlined;
  	
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			require B;
  			
  			my $keycheck = join "|", map quotemeta, sort { length($b) <=> length($a) or $a cmp $b } keys %dict;
  			$keycheck = $KEYCHECK[++$keycheck_counter] = qr{^($keycheck)$}ms; # regexp for legal keys
  			
  			my $label = sprintf("DICTLABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %tmp, %new) = ($_, 0);';
  			push @code,       "$label: {";
  			if ($slurpy)
  			{
  				push @code, sprintf('my $slurped = +{ map +($_=~$%s::KEYCHECK[%d])?():($_=>$orig->{$_}), keys %%$orig };', __PACKAGE__, $keycheck_counter);
  				if ($slurpy->has_coercion)
  				{
  					push @code, sprintf('my $coerced = %s;', $slurpy->coercion->inline_coercion('$slurped'));
  					push @code, sprintf('((%s)&&(%s))?(%%new=%%$coerced):(($return_orig = 1), last %s);', $_hash->inline_check('$coerced'), $slurpy->inline_check('$coerced'), $label);
  				}
  				else
  				{
  					push @code, sprintf('(%s)?(%%new=%%$slurped):(($return_orig = 1), last %s);', $slurpy->inline_check('$slurped'), $label);
  				}
  			}
  			else
  			{
  				push @code, sprintf('($_ =~ $%s::KEYCHECK[%d])||(($return_orig = 1), last %s) for sort keys %%$orig;', __PACKAGE__, $keycheck_counter, $label);
  			}
  			for my $k (keys %dict)
  			{
  				my $ct = $dict{$k};
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);
  				my $K = B::perlstring($k);
  				
  				push @code, "if (exists \$orig->{$K}) {" if $ct_optional;
  				if ($ct_coerce)
  				{
  					push @code, sprintf('%%tmp = (); $tmp{x} = %s;', $ct->coercion->inline_coercion("\$orig->{$K}"));
  					push @code, sprintf(
  #						$ct_optional
  #							? 'if (%s) { $new{%s}=$tmp{x} }'
  #							:
  						'if (%s) { $new{%s}=$tmp{x} } else { $return_orig = 1; last %s }',
  						$ct->inline_check('$tmp{x}'),
  						$K,
  						$label,
  					);
  				}
  				else
  				{
  					push @code, sprintf(
  #						$ct_optional
  #							? 'if (%s) { $new{%s}=$orig->{%s} }'
  #							:
  						'if (%s) { $new{%s}=$orig->{%s} } else { $return_orig = 1; last %s }',
  						$ct->inline_check("\$orig->{$K}"),
  						$K,
  						$K,
  						$label,
  					);
  				}
  				push @code, '}' if $ct_optional;
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			#warn "CODE:: @code";
  			"@code";
  		});
  	}
  	
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				
  				if ($slurpy)
  				{
  					my %slurped = map exists($dict{$_}) ? () : ($_ => $value->{$_}), keys %$value;
  					
  					if ($slurpy->check(\%slurped))
  					{
  						%new = %slurped;
  					}
  					elsif ($slurpy->has_coercion)
  					{
  						my $coerced = $slurpy->coerce(\%slurped);
  						$slurpy->check($coerced) ? (%new = %$coerced) : (return $value);
  					}
  					else
  					{
  						return $value;
  					}
  				}
  				else
  				{
  					for my $k (keys %$value)
  					{
  						return $value unless exists $dict{$k};
  					}
  				}
  
  				for my $k (keys %dict)
  				{
  					my $ct = $dict{$k};
  					my @accept;
  					
  					if (exists $value->{$k} and $ct->check($value->{$k}))
  					{
  						@accept = $value->{$k};
  					}
  					elsif (exists $value->{$k} and $ct->has_coercion)
  					{
  						my $x = $ct->coerce($value->{$k});
  						@accept = $x if $ct->check($x);
  					}
  					elsif (exists $value->{$k})
  					{
  						return $value;
  					}
  					
  					if (@accept)
  					{
  						$new{$k} = $accept[0];
  					}
  					elsif (not $ct->is_a_type_of(Types::Standard::Optional))
  					{
  						return $value;
  					}
  				}
  				
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Dict - internals for the Types::Standard Dict type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_DICT

$fatpacked{"Types/Standard/HashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_HASHREF';
  package Types::Standard::HashRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::HashRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::HashRef::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::HashRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to HashRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $hash = shift;
  		$param->check($_) || return for values %$hash;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (values \%{$v}) { "
  		.    "\$ok = 0 && last unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $k (sort keys %$value)
  	{
  		my $item = $value->{$k};
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the hash with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{$_} = (%s);', $param->coercion->inline_coercion('$orig->{$_}'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $coercable_item->check($value->{$k});
  					$new{$k} = $param->coerce($value->{$k});
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::HashRef - internals for the Types::Standard HashRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_HASHREF

$fatpacked{"Types/Standard/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_MAP';
  package Types::Standard::Map;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Map::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Map::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = Types::Standard->meta;
  
  no warnings;
  
  sub __constraint_generator
  {
  	return $meta->get_type('Map') unless @_;
  	
  	my ($keys, $values) = map Types::TypeTiny::to_TypeTiny($_), @_;
  	Types::TypeTiny::TypeTiny->check($keys)
  		or _croak("First parameter to Map[`k,`v] expected to be a type constraint; got $keys");
  	Types::TypeTiny::TypeTiny->check($values)
  		or _croak("Second parameter to Map[`k,`v] expected to be a type constraint; got $values");
  	
  	return sub
  	{
  		my $hash = shift;
  		$keys->check($_)   || return for keys %$hash;
  		$values->check($_) || return for values %$hash;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my ($k, $v) = @_;
  	return unless $k->can_be_inlined && $v->can_be_inlined;
  	my $k_check = $k->inline_check('$k');
  	my $v_check = $v->inline_check('$v');
  	return sub {
  		my $h = $_[1];
  		"ref($h) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$v (values \%{$h}) { "
  		.    "\$ok = 0 && last unless $v_check "
  		.  "}; "
  		.  "for my \$k (keys \%{$h}) { "
  		.    "\$ok = 0 && last unless $k_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my ($kparam, $vparam) = @{ $type->parameters };
  	
  	for my $k (sort keys %$value)
  	{
  		unless ($kparam->check($k))
  		{
  			return [
  				sprintf('"%s" constrains each key in the hash with "%s"', $type, $kparam),
  				@{ $kparam->validate_explain($k, sprintf('key %s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  		
  		unless ($vparam->check($value->{$k}))
  		{
  			return [
  				sprintf('"%s" constrains each value in the hash with "%s"', $type, $vparam),
  				@{ $vparam->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $kparam, $vparam) = @_;
  	return unless $kparam->has_coercion || $vparam->has_coercion;
  	
  	my $kcoercable_item = $kparam->has_coercion ? $kparam->coercion->_source_type_union : $kparam;
  	my $vcoercable_item = $vparam->has_coercion ? $vparam->coercion->_source_type_union : $vparam;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ((!$kparam->has_coercion or $kparam->coercion->can_be_inlined)
  	and (!$vparam->has_coercion or $vparam->coercion->can_be_inlined)
  	and $kcoercable_item->can_be_inlined
  	and $vcoercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $kcoercable_item->inline_check('$_'));
  			push @code, sprintf('$return_orig++ && last unless (%s);', $vcoercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{(%s)} = (%s);',
  				$kparam->has_coercion ? $kparam->coercion->inline_coercion('$_') : '$_',
  				$vparam->has_coercion ? $vparam->coercion->inline_coercion('$orig->{$_}') : '$orig->{$_}',
  			);
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $kcoercable_item->check($k) && $vcoercable_item->check($value->{$k});
  					$new{$kparam->has_coercion ? $kparam->coerce($k) : $k} =
  						$vparam->has_coercion ? $vparam->coerce($value->{$k}) : $value->{$k};
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Map - internals for the Types::Standard Map type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_MAP

$fatpacked{"Types/Standard/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_SCALARREF';
  package Types::Standard::ScalarRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ScalarRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ScalarRef::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ScalarRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ScalarRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $ref = shift;
  		$param->check($$ref) || return;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	return sub {
  		my $v = $_[1];
  		my $param_check = $param->inline_check("\${$v}");
  		"(ref($v) eq 'SCALAR' or ref($v) eq 'REF') and $param_check";
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $item ($$value)
  	{
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains the referenced scalar value with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('${%s}', $varname)) },
  		];
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $new) = ($_, 0);';
  			push @code,    'for ($$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('$new = (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\$new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my $new;
  				for my $item ($$value)
  				{
  					return $value unless $coercable_item->check($item);
  					$new = $param->coerce($item);
  				}
  				return \$new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ScalarRef - internals for the Types::Standard ScalarRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_SCALARREF

$fatpacked{"Types/Standard/Tuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_TUPLE';
  package Types::Standard::Tuple;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Tuple::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Tuple::VERSION   = '0.038';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_Optional = Types::Standard::Optional;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  		Types::TypeTiny::TypeTiny->check($slurpy)
  			or _croak("Slurpy parameter to Tuple[...] expected to be a type constraint; got $slurpy");
  	}
  	
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	for (@constraints)
  	{
  		Types::TypeTiny::TypeTiny->check($_)
  			or _croak("Parameters to Tuple[...] expected to be type constraints; got $_");
  	}
  		
  	return sub
  	{
  		my $value = $_[0];
  		if ($#constraints < $#$value)
  		{
  			defined($slurpy) && $slurpy->check(
  				$slurpy->is_a_type_of(Types::Standard::HashRef)
  					? +{@$value[$#constraints+1 .. $#$value]}
  					: +[@$value[$#constraints+1 .. $#$value]]
  			) or return;
  		}
  		for my $i (0 .. $#constraints)
  		{
  			$i <= $#$value or $constraints[$i]->is_strictly_a_type_of($_Optional) or return;
  			$constraints[$i]->check(exists $value->[$i] ? $value->[$i] : ()) or return;
  		}
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = pop(@constraints)->{slurpy};
  	}
  	
  	return if grep { not $_->can_be_inlined } @constraints;
  	return if defined $slurpy && !$slurpy->can_be_inlined;
  	
  	my $tmpl = defined($slurpy) && $slurpy->is_a_type_of(Types::Standard::HashRef)
  		? "do { my \$tmp = +{\@{%s}[%d..\$#{%s}]}; %s }"
  		: "do { my \$tmp = +[\@{%s}[%d..\$#{%s}]]; %s }";
  	
  	my $min = 0 + grep !$_->is_strictly_a_type_of($_Optional), @constraints;
  	
  	return sub
  	{
  		my $v = $_[1];
  		join " and ",
  			"ref($v) eq 'ARRAY'",
  			"scalar(\@{$v}) >= $min",
  			($slurpy
  				? sprintf($tmpl, $v, $#constraints+1, $v, $slurpy->inline_check('$tmp'))
  				: sprintf("\@{$v} <= %d", scalar @constraints)
  			),
  			map { $constraints[$_]->inline_check("$v\->[$_]") } 0 .. $#constraints;
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	
  	my @constraints = @{ $type->parameters };
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  	}
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	
  	if ($#constraints < $#$value and not $slurpy)
  	{
  		return [
  			sprintf('"%s" expects at most %d values in the array', $type, $#constraints),
  			sprintf('%d values found; too many', $#$value),
  		];
  	}
  	
  	for my $i (0 .. $#constraints)
  	{
  		next if $constraints[$i]->is_strictly_a_type_of( Types::Standard::Optional ) && $i > $#$value;
  		next if $constraints[$i]->check($value->[$i]);
  		
  		return [
  			sprintf('"%s" constrains value at index %d of array with "%s"', $type, $i, $constraints[$i]),
  			@{ $constraints[$i]->validate_explain($value->[$i], sprintf('%s->[%s]', $varname, $i)) },
  		];
  	}
  	
  	if (defined($slurpy))
  	{
  		my $tmp = $slurpy->is_a_type_of(Types::Standard::HashRef)
  			? +{@$value[$#constraints+1 .. $#$value]}
  			: +[@$value[$#constraints+1 .. $#$value]];
  		$slurpy->check($tmp) or return [
  			sprintf(
  				'Array elements from index %d are slurped into a %s which is constrained with "%s"',
  				$#constraints+1,
  				$slurpy->is_a_type_of(Types::Standard::HashRef) ? 'hashref' : 'arrayref',
  				$slurpy,
  			),
  			@{ $slurpy->validate_explain($tmp, '$SLURPY') },
  		];
  	}
  	
  	return;
  }
  
  my $label_counter = 0;
  sub __coercion_generator
  {
  	my ($parent, $child, @tuple) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $slurpy;
  	if (exists $tuple[-1] and ref $tuple[-1] eq "HASH")
  	{
  		$slurpy = pop(@tuple)->{slurpy};
  	}
  	
  	my $all_inlinable = 1;
  	for my $tc (@tuple, ($slurpy ? $slurpy : ()))
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my $label = sprintf("TUPLELABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @tmp, @new) = ($_, 0);';
  			push @code,       "$label: {";
  			push @code,       sprintf('(($return_orig = 1), last %s) if @$orig > %d;', $label, scalar @tuple) unless $slurpy;
  			for my $i (0 .. $#tuple)
  			{
  				my $ct = $tuple[$i];
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);
  				
  				if ($ct_coerce)
  				{
  					push @code, sprintf('@tmp = (); $tmp[0] = %s;', $ct->coercion->inline_coercion("\$orig->[$i]"));
  					push @code, sprintf(
  						$ct_optional
  							? 'if (%s) { $new[%d]=$tmp[0] }'
  							: 'if (%s) { $new[%d]=$tmp[0] } else { $return_orig = 1; last %s }',
  						$ct->inline_check('$tmp[0]'),
  						$i,
  						$label,
  					);
  				}
  				else
  				{
  					push @code, sprintf(
  						$ct_optional
  							? 'if (%s) { $new[%d]=$orig->[%s] }'
  							: 'if (%s) { $new[%d]=$orig->[%s] } else { $return_orig = 1; last %s }',
  						$ct->inline_check("\$orig->[$i]"),
  						$i,
  						$i,
  						$label,
  					);
  				}
  			}
  			if ($slurpy)
  			{
  				my $size = @tuple;
  				push @code, sprintf('if (@$orig > %d) {', $size);
  				push @code, sprintf('my $tail = [ @{$orig}[%d .. $#$orig] ];', $size);
  				push @code, $slurpy->has_coercion
  					? sprintf('$tail = %s;', $slurpy->coercion->inline_coercion('$tail'))
  					: q();
  				push @code, sprintf(
  					'(%s) ? push(@new, @$tail) : ($return_orig++);',
  					$slurpy->inline_check('$tail'),
  				);
  				push @code, '}';
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				
  				if (!$slurpy and @$value > @tuple)
  				{
  					return $value;
  				}
  				
  				my @new;
  				for my $i (0 .. $#tuple)
  				{
  					my $ct = $tuple[$i];
  					my @accept;
  					
  					if (exists $value->[$i] and $ct->check($value->[$i]))
  					{
  						@accept = $value->[$i];
  					}
  					elsif (exists $value->[$i] and $ct->has_coercion)
  					{
  						my $x = $ct->coerce($value->[$i]);
  						@accept = $x if $ct->check($x);
  					}
  					else
  					{
  						return $value;
  					}
  					
  					if (@accept)
  					{
  						$new[$i] = $accept[0];
  					}
  					elsif (not $ct->is_a_type_of(Types::Standard::Optional))
  					{
  						return $value;
  					}
  				}
  				
  				if ($slurpy and @$value > @tuple)
  				{
  					my $tmp = $slurpy->has_coercion
  						? $slurpy->coerce([ @{$value}[@tuple .. $#$value] ])
  						: [ @{$value}[@tuple .. $#$value] ];
  					$slurpy->check($tmp) ? push(@new, @$tmp) : return($value);
  				}
  				
  				return \@new;
  			},
  		);
  	};
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Tuple - internals for the Types::Standard Tuple type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_TUPLE

$fatpacked{"Types/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_TYPETINY';
  package Types::TypeTiny;
  
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.038';
  
  use Scalar::Util qw< blessed refaddr weaken >;
  
  our @EXPORT_OK = ( __PACKAGE__->type_names, qw/to_TypeTiny/ );
  
  my %cache;
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  sub meta
  {
  	return $_[0];
  }
  
  sub has_type
  {
  	defined(shift->get_coercion(@_))
  }
  
  sub get_type
  {
  	my $self = shift;
  	my $func = $self->can(@_) or return;
  	my $type = $func->();
  	return $type if blessed($type) && $type->isa("Type::Tiny");
  	return;
  }
  
  sub type_names
  {
  	qw( CodeLike StringLike TypeTiny HashLike ArrayLike );
  }
  
  sub has_coercion
  {
  	defined(shift->get_coercion(@_))
  }
  
  sub get_coercion
  {
  	();
  }
  
  sub coercion_names
  {
  	();
  }
  
  sub StringLike ()
  {
  	require Type::Tiny;
  	$cache{StringLike} ||= "Type::Tiny"->new(
  		name       => "StringLike",
  		constraint => sub {    !ref($_   ) or Scalar::Util::blessed($_   ) && overload::Method($_   , q[""])  },
  		inlined    => sub { qq/!ref($_[1]) or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[""])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub HashLike ()
  {
  	require Type::Tiny;
  	$cache{HashLike} ||= "Type::Tiny"->new(
  		name       => "HashLike",
  		constraint => sub {    ref($_   ) eq q[HASH] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[%{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[HASH] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\%{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub ArrayLike ()
  {
  	require Type::Tiny;
  	$cache{ArrayLike} ||= "Type::Tiny"->new(
  		name       => "ArrayLike",
  		constraint => sub {    ref($_   ) eq q[ARRAY] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[@{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[ARRAY] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\@{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub CodeLike ()
  {
  	require Type::Tiny;
  	$cache{CodeLike} ||= "Type::Tiny"->new(
  		name       => "CodeLike",
  		constraint => sub {    ref($_   ) eq q[CODE] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[&{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[CODE] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\&{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub TypeTiny ()
  {
  	require Type::Tiny;
  	$cache{TypeTiny} ||= "Type::Tiny"->new(
  		name       => "TypeTiny",
  		constraint => sub {  Scalar::Util::blessed($_   ) && $_   ->isa(q[Type::Tiny])  },
  		inlined    => sub { my $var = $_[1]; "Scalar::Util::blessed($var) && $var\->isa(q[Type::Tiny])" },
  		library    => __PACKAGE__,
  	);
  }
  
  my %ttt_cache;
  
  sub to_TypeTiny
  {
  	my $t = $_[0];
  	
  	return $t unless ref $t;
  	return $t if ref($t) =~ /^Type::Tiny\b/;
  	
  	return $ttt_cache{ refaddr($t) } if $ttt_cache{ refaddr($t) };
  	
  	if (my $class = blessed $t)
  	{
  		return $t                           if $class->isa("Type::Tiny");
  		goto \&_TypeTinyFromMoose           if $class->isa("Moose::Meta::TypeConstraint");
  		goto \&_TypeTinyFromMoose           if $class->isa("MooseX::Types::TypeDecorator");
  		goto \&_TypeTinyFromValidationClass if $class->isa("Validation::Class::Simple");
  		goto \&_TypeTinyFromValidationClass if $class->isa("Validation::Class");
  		goto \&_TypeTinyFromGeneric         if $t->can("check") && $t->can("get_message"); # i.e. Type::API::Constraint
  	}
  	
  	goto \&_TypeTinyFromCodeRef if ref($t) eq q(CODE);
  	
  	$t;
  }
  
  sub _TypeTinyFromMoose
  {
  	my $t = $_[0];
  	
  	if (ref $t->{"Types::TypeTiny::to_TypeTiny"})
  	{
  		return $t->{"Types::TypeTiny::to_TypeTiny"};
  	}
  	
  	if ($t->name ne '__ANON__')
  	{
  		require Types::Standard;
  		my $ts = 'Types::Standard'->get_type($t->name);
  		return $ts if $ts->{_is_core};
  	}
  	
  	my %opts;
  	$opts{display_name} = $t->name;
  	$opts{constraint}   = $t->constraint;
  	$opts{parent}       = to_TypeTiny($t->parent)              if $t->has_parent;
  	$opts{inlined}      = sub { shift; $t->_inline_check(@_) } if $t->can_be_inlined;
  	$opts{message}      = sub { $t->get_message($_) }          if $t->has_message;
  	$opts{moose_type}   = $t;
  	
  	require Type::Tiny;
  	my $new = 'Type::Tiny'->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	
  	$new->{coercion} = do {
  		require Type::Coercion::FromMoose;
  		'Type::Coercion::FromMoose'->new(type_constraint => $new);
  	} if $t->has_coercion;
  	
  	return $new;
  }
  
  sub _TypeTinyFromValidationClass
  {
  	my $t = $_[0];
  	
  	require Type::Tiny;
  	require Types::Standard;
  	
  	my %opts = (
  		parent            => Types::Standard::HashRef(),
  		_validation_class => $t,
  	);
  	
  	if ($t->VERSION >= "7.900048")
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = eval { $t->validate };
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = (eval { $t->validate } ? "OK" : $t->errors_to_string);
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  	}
  	else  # need to use hackish method
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate };
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate } ? "OK" : $t->errors_to_string;
  		};
  	}
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	
  	$new->coercion->add_type_coercions(
  		Types::Standard::HashRef() => sub {
  			my %params = %$_;
  			for my $k (keys %params)
  				{ delete $params{$_} unless $t->get_fields($k) };
  			$t->params->clear;
  			$t->params->add(%params);
  			eval { $t->validate };
  			$t->get_hash;
  		},
  	);
  	
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  sub _TypeTinyFromGeneric
  {
  	my $t = $_[0];
  	
  	# XXX - handle inlining??
  	
  	my %opts = (
  		constraint => sub { $t->check(@_ ? @_ : $_) },
  		message    => sub { $t->get_message(@_ ? @_ : $_) },
  	);
  	
  	$opts{display_name} = $t->name if $t->can("name");
  	
  	$opts{coercion} = sub { $t->coerce(@_ ? @_ : $_) }
  		if $t->can("has_coercion") && $t->has_coercion && $t->can("coerce");
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  sub _TypeTinyFromCodeRef
  {
  	my $t = $_[0];
  	
  	my %opts = (
  		constraint => sub {
  			return !!eval { $t->($_) };
  		},
  		message => sub {
  			local $@;
  			eval { $t->($_); 1 } or do { chomp $@; return $@ if $@ };
  			return sprintf('%s did not pass type constraint', Type::Tiny::_dd($_));
  		},
  	);
  
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords arrayfication hashification
  
  =head1 NAME
  
  Types::TypeTiny - type constraints used internally by Type::Tiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Dogfooding.
  
  This isn't a real Type::Library-based type library; that would involve
  too much circularity. But it exports some type constraints which, while
  designed for use within Type::Tiny, may be more generally useful.
  
  =head2 Types
  
  =over
  
  =item C<< StringLike >>
  
  Accepts strings and objects overloading stringification.
  
  =item C<< HashLike >>
  
  Accepts hashrefs and objects overloading hashification.
  
  =item C<< ArrayLike >>
  
  Accepts arrayrefs and objects overloading arrayfication.
  
  =item C<< CodeLike >>
  
  Accepts coderefs and objects overloading codification.
  
  =item C<< TypeTiny >>
  
  Accepts blessed L<Type::Tiny> objects.
  
  =back
  
  =head2 Coercion Functions
  
  =over
  
  =item C<< to_TypeTiny($constraint) >>
  
  Promotes (or "demotes" if you prefer) a Moose::Meta::TypeConstraint object
  to a Type::Tiny object.
  
  Can also handle L<Validation::Class> objects. Type constraints built from 
  Validation::Class objects deliberately I<ignore> field filters when they
  do constraint checking (and go to great lengths to do so); using filters for
  coercion only. (The behaviour of C<coerce> if we don't do that is just too
  weird!)
  
  Can also handle any object providing C<check> and C<get_message> methods.
  (This includes L<Mouse::Meta::TypeConstraint> objects.) If the object also
  provides C<has_coercion> and C<coerce> methods, these will be used too.
  
  Can also handle coderefs (but not blessed coderefs or objects overloading
  C<< &{} >>). Coderefs are expected to return true iff C<< $_ >> passes the
  constraint. If C<< $_ >> fails the type constraint, they may either return
  false, or die with a helpful error message.
  
  =back
  
  =head2 Methods
  
  These are implemented so that C<< Types::TypeTiny->meta->get_type($foo) >>
  works, for rough compatibility with a real L<Type::Library> type library.
  
  =over
  
  =item C<< meta >>
  
  =item C<< type_names >>
  
  =item C<< get_type($name) >>
  
  =item C<< has_type($name) >>
  
  =item C<< coercion_names >>
  
  =item C<< get_coercion($name) >>
  
  =item C<< has_coercion($name) >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_TYPETINY

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  use 5.008001;
  package YAML;
  $YAML::VERSION = '0.90';
  use YAML::Mo;
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML - YAML Ain't Markup Language (tm)
  
  =head1 NOTE
  
  This module has been released to CPAN as YAML::Old, and soon YAML.pm
  will be changed to just be a frontend interface module for all the
  various Perl YAML implementation modules, including YAML::Old.
  
  If you want robust and fast YAML processing using the normal Dump/Load
  API, please consider switching to YAML::XS. It is by far the best Perl
  module for YAML at this time. It requires that you have a C compiler,
  since it is written in C.
  
  If you really need to use this version of YAML.pm it will always be
  available as YAML::Old.
  
  If you don't care which YAML module use, as long as it's the best one
  installed on your system, use YAML::Any.
  
  The rest of this documentation is left unchanged, until YAML.pm is
  switched over to the new UI-only version.
  
  =head1 SYNOPSIS
  
      use YAML;
  
      # Load a YAML stream of 3 YAML documents into Perl data structures.
      my ($hashref, $arrayref, $string) = Load(<<'...');
      ---
      name: ingy
      age: old
      weight: heavy
      # I should comment that I also like pink, but don't tell anybody.
      favorite colors:
          - red
          - green
          - blue
      ---
      - Clark Evans
      - Oren Ben-Kiki
      - Ingy döt Net
      --- >
      You probably think YAML stands for "Yet Another Markup Language". It
      ain't! YAML is really a data serialization language. But if you want
      to think of it as a markup, that's OK with me. A lot of people try
      to use XML as a serialization format.
  
      "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
      ...
  
      # Dump the Perl data structures back into YAML.
      print Dump($string, $arrayref, $hashref);
  
      # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
      use Data::Dumper;
      print Dumper($string, $arrayref, $hashref);
  
  =head1 DESCRIPTION
  
  The YAML.pm module implements a YAML Loader and Dumper based on the YAML
  1.0 specification. L<http://www.yaml.org/spec/>
  
  YAML is a generic data serialization language that is optimized for
  human readability. It can be used to express the data structures of most
  modern programming languages. (Including Perl!!!)
  
  For information on the YAML syntax, please refer to the YAML
  specification.
  
  =head1 WHY YAML IS COOL
  
  =over 4
  
  =item YAML is readable for people.
  
  It makes clear sense out of complex data structures. You should find
  that YAML is an exceptional data dumping tool. Structure is shown
  through indentation, YAML supports recursive data, and hash keys are
  sorted by default. In addition, YAML supports several styles of scalar
  formatting for different types of data.
  
  =item YAML is editable.
  
  YAML was designed from the ground up to be an excellent syntax for
  configuration files. Almost all programs need configuration files, so
  why invent a new syntax for each one? And why subject users to the
  complexities of XML or native Perl code?
  
  =item YAML is multilingual.
  
  Yes, YAML supports Unicode. But I'm actually referring to programming
  languages. YAML was designed to meet the serialization needs of Perl,
  Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
  interoperable between those languages. That means YAML serializations
  produced by Perl can be processed by Python.
  
  =item YAML is taint safe.
  
  Using modules like Data::Dumper for serialization is fine as long as you
  can be sure that nobody can tamper with your data files or
  transmissions. That's because you need to use Perl's C<eval()> built-in
  to deserialize the data. Somebody could add a snippet of Perl to erase
  your files.
  
  YAML's parser does not need to eval anything.
  
  =item YAML is full featured.
  
  YAML can accurately serialize all of the common Perl data structures and
  deserialize them again without losing data relationships. Although it is
  not 100% perfect (no serializer is or can be perfect), it fares as well
  as the popular current modules: Data::Dumper, Storable, XML::Dumper and
  Data::Denter.
  
  YAML.pm also has the ability to handle code (subroutine) references and
  typeglobs. (Still experimental) These features are not found in Perl's
  other serialization modules.
  
  =item YAML is extensible.
  
  The YAML language has been designed to be flexible enough to solve it's
  own problems. The markup itself has 3 basic construct which resemble
  Perl's hash, array and scalar. By default, these map to their Perl
  equivalents. But each YAML node also supports a tagging mechanism (type
  system) which can cause that node to be interpreted in a completely
  different manner. That's how YAML can support object serialization and
  oddball structures like Perl's typeglob.
  
  =back
  
  =head1 YAML IMPLEMENTATIONS IN PERL
  
  This module, YAML.pm, is really just the interface module for YAML
  modules written in Perl. The basic interface for YAML consists of two
  functions: C<Dump> and C<Load>. The real work is done by the modules
  YAML::Dumper and YAML::Loader.
  
  Different YAML module distributions can be created by subclassing
  YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple
  consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
  
  Why would there be more than one implementation of YAML? Well, despite
  YAML's offering of being a simple data format, YAML is actually very
  deep and complex. Implementing the entirety of the YAML specification is
  a daunting task.
  
  For this reason I am currently working on 3 different YAML implementations.
  
  =over
  
  =item YAML
  
  The main YAML distribution will keeping evolving to support the entire
  YAML specification in pure Perl. This may not be the fastest or most
  stable module though. Currently, YAML.pm has lots of known bugs. It is
  mostly a great tool for dumping Perl data structures to a readable form.
  
  =item YAML::Tiny
  
  The point of YAML::Tiny is to strip YAML down to the 90% that people
  use most and offer that in a small, fast, stable, pure Perl form.
  YAML::Tiny will simply die when it is asked to do something it can't.
  
  =item YAML::Syck
  
  C<libsyck> is the C based YAML processing library used by the Ruby
  programming language (and also Python, PHP and Pugs). YAML::Syck is the
  Perl binding to C<libsyck>. It should be very fast, but may have
  problems of its own. It will also require C compilation.
  
  NOTE: Audrey Tang has actually completed this module and it works great
        and is 10 times faster than YAML.pm.
  
  =back
  
  In the future, there will likely be even more YAML modules. Remember,
  people other than Ingy are allowed to write YAML modules!
  
  =head1 FUNCTIONAL USAGE
  
  YAML is completely OO under the hood. Still it exports a few useful top
  level functions so that it is dead simple to use. These functions just
  do the OO stuff for you. If you want direct access to the OO API see the
  documentation for YAML::Dumper and YAML::Loader.
  
  =head2 Exported Functions
  
  The following functions are exported by YAML.pm by default. The reason
  they are exported is so that YAML works much like Data::Dumper. If you
  don't want functions to be imported, just use YAML with an empty
  import list:
  
      use YAML ();
  
  =over 4
  
  =item Dump(list-of-Perl-data-structures)
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper(). It takes a list of Perl data structures and
  dumps them into a serialized form. It returns a string containing the
  YAML stream. The structures can be references or plain scalars.
  
  =item Load(string-containing-a-YAML-stream)
  
  Turn YAML into Perl data. This is the opposite of Dump. Just like
  Storable's thaw() function or the eval() function in relation to
  Data::Dumper. It parses a string containing a valid YAML stream into a
  list of Perl data structures.
  
  =back
  
  =head2 Exportable Functions
  
  These functions are not exported by default but you can request them in
  an import list like this:
  
      use YAML qw'freeze thaw Bless';
  
  =over 4
  
  =item freeze() and thaw()
  
  Aliases to Dump() and Load() for Storable fans. This will also allow
  YAML.pm to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =item DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =item LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =item Bless(perl-node, [yaml-node | class-name])
  
  Associate a normal Perl node, with a yaml node. A yaml node is an object
  tied to the YAML::Node class. The second argument is either a yaml node
  that you've already created or a class (package) name that supports a
  yaml_dump() function. A yaml_dump() function should take a perl node and
  return a yaml node. If no second argument is provided, Bless will create
  a yaml node. This node is not returned, but can be retrieved with the
  Blessed() function.
  
  Here's an example of how to use Bless. Say you have a hash containing
  three keys, but you only want to dump two of them. Furthermore the keys
  must be dumped in a certain order. Here's how you do that:
  
      use YAML qw(Dump Bless);
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash)->keys(['banana', 'apple']);
      print Dump $hash;
  
  produces:
  
      ---
      apple: good
      banana: bad
      cauliflower: ugly
      ---
      banana: bad
      apple: good
  
  Bless returns the tied part of a yaml-node, so that you can call the
  YAML::Node methods. This is the same thing that YAML::Node::ynode()
  returns. So another way to do the above example is:
  
      use YAML qw(Dump Bless);
      use YAML::Node;
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash);
      $ynode = ynode(Blessed($hash));
      $ynode->keys(['banana', 'apple']);
      print Dump $hash;
  
  Note that Blessing a Perl data structure does not change it anyway. The
  extra information is stored separately and looked up by the Blessed
  node's memory address.
  
  =item Blessed(perl-node)
  
  Returns the yaml node that a particular perl node is associated with
  (see above). Returns undef if the node is not (YAML) Blessed.
  
  =back
  
  =head1 GLOBAL OPTIONS
  
  YAML options are set using a group of global variables in the YAML
  namespace. This is similar to how Data::Dumper works.
  
  For example, to change the indentation width, do something like:
  
      local $YAML::Indent = 3;
  
  The current options are:
  
  =over 4
  
  =item DumperClass
  
  You can override which module/class YAML uses for Dumping data.
  
  =item LoaderClass
  
  You can override which module/class YAML uses for Loading data.
  
  =item Indent
  
  This is the number of space characters to use for each indentation level
  when doing a Dump(). The default is 2.
  
  By the way, YAML can use any number of characters for indentation at any
  level. So if you are editing YAML by hand feel free to do it anyway that
  looks pleasing to you; just be consistent for a given level.
  
  =item SortKeys
  
  Default is 1. (true)
  
  Tells YAML.pm whether or not to sort hash keys when storing a document.
  
  YAML::Node objects can have their own sort order, which is usually what
  you want. To override the YAML::Node order and sort the keys anyway, set
  SortKeys to 2.
  
  =item Stringify
  
  Default is 0. (false)
  
  Objects with string overloading should honor the overloading and dump the
  stringification of themselves, rather than the actual object's guts.
  
  =item UseHeader
  
  Default is 1. (true)
  
  This tells YAML.pm whether to use a separator string for a Dump
  operation. This only applies to the first document in a stream.
  Subsequent documents must have a YAML header by definition.
  
  =item UseVersion
  
  Default is 0. (false)
  
  Tells YAML.pm whether to include the YAML version on the
  separator/header.
  
      --- %YAML:1.0
  
  =item AnchorPrefix
  
  Default is ''.
  
  Anchor names are normally numeric. YAML.pm simply starts with '1' and
  increases by one for each new anchor. This option allows you to specify a
  string to be prepended to each anchor number.
  
  =item UseCode
  
  Setting the UseCode option is a shortcut to set both the DumpCode and
  LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
  Perl code references as Perl (using B::Deparse) and to load them back
  into memory using eval(). The reason this has to be an option is that
  using eval() to parse untrusted code is, well, untrustworthy.
  
  =item DumpCode
  
  Determines if and how YAML.pm should serialize Perl code references. By
  default YAML.pm will dump code references as dummy placeholders (much
  like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
  references will be dumped as actual Perl code.
  
  DumpCode can also be set to a subroutine reference so that you can
  write your own serializing routine. YAML.pm passes you the code ref. You
  pass back the serialization (as a string) and a format indicator. The
  format indicator is a simple string like: 'deparse' or 'bytecode'.
  
  =item LoadCode
  
  LoadCode is the opposite of DumpCode. It tells YAML if and how to
  deserialize code references. When set to '1' or 'deparse' it will use
  C<eval()>. Since this is potentially risky, only use this option if you
  know where your YAML has been.
  
  LoadCode can also be set to a subroutine reference so that you can write
  your own deserializing routine. YAML.pm passes the serialization (as a
  string) and a format indicator. You pass back the code reference.
  
  =item UseBlock
  
  YAML.pm uses heuristics to guess which scalar style is best for a given
  node. Sometimes you'll want all multiline scalars to use the 'block'
  style. If so, set this option to 1.
  
  NOTE: YAML's block style is akin to Perl's here-document.
  
  =item UseFold
  
  If you want to force YAML to use the 'folded' style for all multiline
  scalars, then set $UseFold to 1.
  
  NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.
  
  =item UseAliases
  
  YAML has an alias mechanism such that any given structure in memory gets
  serialized once. Any other references to that structure are serialized
  only as alias markers. This is how YAML can serialize duplicate and
  recursive structures.
  
  Sometimes, when you KNOW that your data is nonrecursive in nature, you
  may want to serialize such that every node is expressed in full. (ie as
  a copy of the original). Setting $YAML::UseAliases to 0 will allow you
  to do this. This also may result in faster processing because the lookup
  overhead is by bypassed.
  
  THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option
  *will* cause Dump() to run in an endless loop, chewing up your computers
  memory. You have been warned.
  
  =item CompressSeries
  
  Default is 1.
  
  Compresses the formatting of arrays of hashes:
  
      -
        foo: bar
      -
        bar: foo
  
  becomes:
  
      - foo: bar
      - bar: foo
  
  Since this output is usually more desirable, this option is turned on by
  default.
  
  =back
  
  =head1 YAML TERMINOLOGY
  
  YAML is a full featured data serialization language, and thus has its
  own terminology.
  
  It is important to remember that although YAML is heavily influenced by
  Perl and Python, it is a language in its own right, not merely just a
  representation of Perl structures.
  
  YAML has three constructs that are conspicuously similar to Perl's hash,
  array, and scalar. They are called mapping, sequence, and string
  respectively. By default, they do what you would expect. But each
  instance may have an explicit or implicit tag (type) that makes it
  behave differently. In this manner, YAML can be extended to represent
  Perl's Glob or Python's tuple, or Ruby's Bigint.
  
  =over 4
  
  =item stream
  
  A YAML stream is the full sequence of Unicode characters that a YAML
  parser would read or a YAML emitter would write. A stream may contain
  one or more YAML documents separated by YAML headers.
  
      ---
      a: mapping
      foo: bar
      ---
      - a
      - sequence
  
  =item document
  
  A YAML document is an independent data structure representation within a
  stream. It is a top level node. Each document in a YAML stream must
  begin with a YAML header line. Actually the header is optional on the
  first document.
  
      ---
      This: top level mapping
      is:
          - a
          - YAML
          - document
  
  =item header
  
  A YAML header is a line that begins a YAML document. It consists of
  three dashes, possibly followed by more info. Another purpose of the
  header line is that it serves as a place to put top level tag and anchor
  information.
  
      --- !recursive-sequence &001
      - * 001
      - * 001
  
  =item node
  
  A YAML node is the representation of a particular data structure. Nodes
  may contain other nodes. (In Perl terms, nodes are like scalars.
  Strings, arrayrefs and hashrefs. But this refers to the serialized
  format, not the in-memory structure.)
  
  =item tag
  
  This is similar to a type. It indicates how a particular YAML node
  serialization should be transferred into or out of memory. For instance
  a Foo::Bar object would use the tag 'perl/Foo::Bar':
  
      - !perl/Foo::Bar
          foo: 42
          bar: stool
  
  =item collection
  
  A collection is the generic term for a YAML data grouping. YAML has two
  types of collections: mappings and sequences. (Similar to hashes and arrays)
  
  =item mapping
  
  A mapping is a YAML collection defined by unordered key/value pairs with
  unique keys. By default YAML mappings are loaded into Perl hashes.
  
      a mapping:
          foo: bar
          two: times two is 4
  
  =item sequence
  
  A sequence is a YAML collection defined by an ordered list of elements. By
  default YAML sequences are loaded into Perl arrays.
  
      a sequence:
          - one bourbon
          - one scotch
          - one beer
  
  =item scalar
  
  A scalar is a YAML node that is a single value. By default YAML scalars
  are loaded into Perl scalars.
  
      a scalar key: a scalar value
  
  YAML has many styles for representing scalars. This is important because
  varying data will have varying formatting requirements to retain the
  optimum human readability.
  
  =item plain scalar
  
  A plain scalar is unquoted. All plain scalars are automatic candidates
  for "implicit tagging". This means that their tag may be determined
  automatically by examination. The typical uses for this are plain alpha
  strings, integers, real numbers, dates, times and currency.
  
      - a plain string
      - -42
      - 3.1415
      - 12:34
      - 123 this is an error
  
  =item single quoted scalar
  
  This is similar to Perl's use of single quotes. It means no escaping
  except for single quotes which are escaped by using two adjacent
  single quotes.
  
      - 'When I say ''\n'' I mean "backslash en"'
  
  =item double quoted scalar
  
  This is similar to Perl's use of double quotes. Character escaping can
  be used.
  
      - "This scalar\nhas two lines, and a bell -->\a"
  
  =item folded scalar
  
  This is a multiline scalar which begins on the next line. It is
  indicated by a single right angle bracket. It is unescaped like the
  single quoted scalar. Line folding is also performed.
  
      - >
       This is a multiline scalar which begins on
       the next line. It is indicated by a single
       carat. It is unescaped like the single
       quoted scalar. Line folding is also
       performed.
  
  =item block scalar
  
  This final multiline form is akin to Perl's here-document except that
  (as in all YAML data) scope is indicated by indentation. Therefore, no
  ending marker is required. The data is verbatim. No line folding.
  
      - |
          QTY  DESC          PRICE  TOTAL
          ---  ----          -----  -----
            1  Foo Fighters  $19.95 $19.95
            2  Bar Belles    $29.95 $59.90
  
  =item parser
  
  A YAML processor has four stages: parse, load, dump, emit.
  
  A parser parses a YAML stream. YAML.pm's Load() function contains a
  parser.
  
  =item loader
  
  The other half of the Load() function is a loader. This takes the
  information from the parser and loads it into a Perl data structure.
  
  =item dumper
  
  The Dump() function consists of a dumper and an emitter. The dumper
  walks through each Perl data structure and gives info to the emitter.
  
  =item emitter
  
  The emitter takes info from the dumper and turns it into a YAML stream.
  
  NOTE:
  In YAML.pm the parser/loader and the dumper/emitter code are currently
  very closely tied together. In the future they may be broken into
  separate stages.
  
  =back
  
  For more information please refer to the immensely helpful YAML
  specification available at L<http://www.yaml.org/spec/>.
  
  =head1 ysh - The YAML Shell
  
  The YAML distribution ships with a script called 'ysh', the YAML shell.
  ysh provides a simple, interactive way to play with YAML. If you type in
  Perl code, it displays the result in YAML. If you type in YAML it turns
  it into Perl code.
  
  To run ysh, (assuming you installed it along with YAML.pm) simply type:
  
      ysh [options]
  
  Please read the C<ysh> documentation for the full details. There are
  lots of options.
  
  =head1 BUGS & DEFICIENCIES
  
  If you find a bug in YAML, please try to recreate it in the YAML Shell
  with logging turned on ('ysh -L'). When you have successfully reproduced
  the bug, please mail the LOG file to the author (ingy@cpan.org).
  
  WARNING: This is still *ALPHA* code. Well, most of this code has been
  around for years...
  
  BIGGER WARNING: YAML.pm has been slow in the making, but I am committed
  to having top notch YAML tools in the Perl world. The YAML team is close
  to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of
  a very old pre 1.0 spec. In actuality there isn't a ton of difference,
  and this YAML.pm is still fairly useful. Things will get much better in
  the future.
  
  =head1 RESOURCES
  
  L<http://lists.sourceforge.net/lists/listinfo/yaml-core> is the mailing
  list. This is where the language is discussed and designed.
  
  L<http://www.yaml.org> is the official YAML website.
  
  L<http://www.yaml.org/spec/> is the YAML 1.0 specification.
  
  L<http://yaml.kwiki.org> is the official YAML wiki.
  
  =head1 SEE ALSO
  
  See YAML::XS. Fast!
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  is responsible for YAML.pm.
  
  The YAML serialization language is the result of years of collaboration
  between Oren Ben-Kiki, Clark Evans and Ingy döt Net. Several others
  have added help along the way.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005, 2006, 2008, 2011-2014. Ingy döt Net.
  
  Copyright (c) 2001, 2002, 2005. Brian Ingerson.
  
  Some parts copyright (c) 2009 - 2010 Adam Kennedy
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  package YAML::Any;
  $YAML::Any::VERSION = '0.90';
  use strict;
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::Croak(@_);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Any - Pick a YAML implementation and use it.
  
  =head1 SYNOPSIS
  
      use YAML::Any;
      $YAML::Indent = 3;
      my $yaml = Dump(@objects);
  
  =head1 DESCRIPTION
  
  There are several YAML implementations that support the Dump/Load API.
  This module selects the best one available and uses it.
  
  =head1 ORDER
  
  Currently, YAML::Any will choose the first one of these YAML
  implementations that is installed on your system:
  
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  
  =head1 OPTIONS
  
  If you specify an option like:
  
      $YAML::Indent = 4;
  
  And YAML::Any is using YAML::XS, it will use the proper variable:
  $YAML::XS::Indent.
  
  =head1 SUBROUTINES
  
  Like all the YAML modules that YAML::Any uses, the following subroutines
  are exported by default:
  
      Dump
      Load
  
  and the following subroutines are exportable by request:
  
      DumpFile
      LoadFile
  
  =head1 METHODS
  
  YAML::Any provides the following class methods.
  
  =over
  
  =item YAML::Any->order;
  
  This method returns a list of the current possible implementations that
  YAML::Any will search for.
  
  =item YAML::Any->implementation;
  
  This method returns the implementation the YAML::Any will use. This
  result is obtained by finding the first member of YAML::Any->order that
  is either already loaded in C<%INC> or that can be loaded using
  C<require>. If no implementation is found, an error will be thrown.
  
  =back
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008, 2014. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  $YAML::Dumper::VERSION = '0.90';
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo);
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0],
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) =
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      require YAML;
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} =
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) =
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash.
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
  
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Dumper - YAML class for dumping Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Dumper;
      my $dumper = YAML::Dumper->new;
      $dumper->indent_width(4);
      print $dumper->dump({foo => 'bar'});
  
  =head1 DESCRIPTION
  
  YAML::Dumper is the module that YAML.pm used to serialize Perl objects to
  YAML. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  $YAML::Dumper::Base::VERSION = '0.90';
  use YAML::Mo;
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
  
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Dumper::Base - Base class for YAML Dumper classes
  
  =head1 SYNOPSIS
  
      package YAML::Dumper::Something;
      use YAML::Dumper::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Dumper::Base is a base class for creating YAML dumper classes.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  $YAML::Error::VERSION = '0.90';
  use YAML::Mo;
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)}
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
       YAML_PARSE_ERR_NO_ANCHOR
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  $YAML::Warning::VERSION = '0.90';
  our @ISA = 'YAML::Error';
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Error - Error formatting class for YAML modules
  
  =head1 SYNOPSIS
  
      $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias);
      $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
  
  =head1 DESCRIPTION
  
  This module provides a C<die> and a C<warn> facility.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  $YAML::Loader::VERSION = '0.90';
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';
  my $LIT_CHAR_RX = "\\$LIT_CHAR";
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS')
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE')
        if length($self->stream) and
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) =
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) =
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) {
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE');
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface);
  }
  
  # Morph a node to it's explicit type
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
  
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
  
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) =
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      # https://rt.cpan.org/Public/Bug/Display.html?id=90593
      if ($self->inline =~ /^"((?>(?>(?:\\"|[^"]){0,32766}){0,32766}))"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`\^]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/ or die;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or die;
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
  
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos;
  
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
  
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Loader - YAML class for loading Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Loader;
      my $loader = YAML::Loader->new;
      my $hash = $loader->load(<<'...');
      foo: bar
      ...
  
  =head1 DESCRIPTION
  
  YAML::Loader is the module that YAML.pm used to deserialize YAML to Perl
  objects. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  $YAML::Loader::Base::VERSION = '0.90';
  use YAML::Mo;
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Loader::Base - Base class for YAML Loader classes
  
  =head1 SYNOPSIS
  
      package YAML::Loader::Something;
      use YAML::Loader::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Loader::Base is a base class for creating YAML loader classes.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict; use warnings;
  package YAML::Marshall;
  $YAML::Marshall::VERSION = '0.90';
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Marshall - YAML marshalling class you can mixin to your classes
  
  =head1 SYNOPSIS
  
      package Bar;
      use Foo -base;
      use YAML::Marshall -mixin;
  
  =head1 DESCRIPTION
  
  For classes that want to handle their own YAML serialization.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo;
  $YAML::Mo::VERSION = '0.90';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict; use warnings;
  package YAML::Node;
  $YAML::Node::VERSION = '0.90';
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
  	$self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
  	$self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
  	$self = tied(*{$_[0]});
      }
      else {
  	$self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
  		    ($type eq 'HASH') ? 'mapping' :
  		    $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
  	yaml_scalar->new($self, $_[1]);
  	return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{TAG} = YAML::Tag->new($value);
  	return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{KEYS} = $value;
  	return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  $yaml_scalar::VERSION = '0.90';
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  $yaml_sequence::VERSION = '0.90';
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  $yaml_mapping::VERSION = '0.90';
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}};
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
  	return (grep {$_ eq $key} @{$self->{KEYS}})
  	       ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
  	$self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
  	$self->{HASH}{$key} = $value;
      }
      else {
  	if (not grep {$_ eq $key} @{$self->{KEYS}}) {
  	    push(@{$self->{KEYS}}, $key);
  	}
  	$self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
  	$return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
  	$return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
  	if ($self->{KEYS}[$i] eq $key) {
  	    splice(@{$self->{KEYS}}, $i, 1);
  	}
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Node - A generic data node that encapsulates YAML information
  
  =head1 SYNOPSIS
  
      use YAML;
      use YAML::Node;
  
      my $ynode = YAML::Node->new({}, 'ingerson.com/fruit');
      %$ynode = qw(orange orange apple red grape green);
      print Dump $ynode;
  
  yields:
  
      --- !ingerson.com/fruit
      orange: orange
      apple: red
      grape: green
  
  =head1 DESCRIPTION
  
  A generic node in YAML is similar to a plain hash, array, or scalar node
  in Perl except that it must also keep track of its type. The type is a
  URI called the YAML type tag.
  
  YAML::Node is a class for generating and manipulating these containers.
  A YAML node (or ynode) is a tied hash, array or scalar. In most ways it
  behaves just like the plain thing. But you can assign and retrieve and
  YAML type tag URI to it. For the hash flavor, you can also assign the
  order that the keys will be retrieved in. By default a ynode will offer
  its keys in the same order that they were assigned.
  
  YAML::Node has a class method call new() that will return a ynode. You
  pass it a regular node and an optional type tag. After that you can
  use it like a normal Perl node, but when you YAML::Dump it, the magical
  properties will be honored.
  
  This is how you can control the sort order of hash keys during a YAML
  serialization. By default, YAML sorts keys alphabetically. But notice
  in the above example that the keys were Dumped in the same order they
  were assigned.
  
  YAML::Node exports a function called ynode(). This function returns the tied object so that you can call special methods on it like ->keys().
  
  keys() works like this:
  
      use YAML;
      use YAML::Node;
  
      %$node = qw(orange orange apple red grape green);
      $ynode = YAML::Node->new($node);
      ynode($ynode)->keys(['grape', 'apple']);
      print Dump $ynode;
  
  produces:
  
      ---
      grape: green
      apple: red
  
  It tells the ynode which keys and what order to use.
  
  ynodes will play a very important role in how programs use YAML. They
  are the foundation of how a Perl class can marshall the Loading and
  Dumping of its objects.
  
  The upcoming versions of YAML.pm will have much more information on this.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  Copyright (c) 2002. Brian Ingerson. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict; use warnings;
  package YAML::Tag;
  $YAML::Tag::VERSION = '0.90';
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Tag - Tag URI object class for YAML
  
  =head1 SYNOPSIS
  
      use YAML::Tag;
  
  =head1 DESCRIPTION
  
  Used by YAML::Node.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  $YAML::Types::VERSION = '0.90';
  use YAML::Mo;
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  $YAML::Type::blessed::VERSION = '0.90';
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  $YAML::Type::undef::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  $YAML::Type::glob::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
      my $ynode = YAML::Node->new({}, '!perl/glob:');
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value;
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  $YAML::Type::code::VERSION = '0.90';
  my $dummy_warned = 0;
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  $YAML::Type::ref::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  $YAML::Type::regexp::VERSION = '0.90';
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Types - Marshall Perl internal data types to/from YAML
  
  =head1 SYNOPSIS
  
      $::foo = 42;
      print YAML::Dump(*::foo);
  
      print YAML::Dump(qr{match me});
  
  =head1 DESCRIPTION
  
  This module has the helper classes for transferring objects,
  subroutines, references, globs, regexps and file handles to and
  from YAML.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TYPES

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use strictures 1;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
OO

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;
  
  use strict;
  use warnings FATAL => 'all';
  
  BEGIN {
    *_PERL_LT_5_8_4 = ($] < 5.008004) ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '1.005003'; # 1.5.3
  
  sub VERSION {
    my ($class, $version) = @_;
    for ($version) {
      last unless defined && !ref && int != 1;
      die "Major version specified as $_ - this is strictures version 1";
    }
    # passing undef here may either warn or die depending on the version of perl.
    # we can't match the caller's warning state in this case, so just disable the
    # warning.
    no warnings 'uninitialized';
    shift->SUPER::VERSION(@_);
  }
  
  our $extra_load_states;
  
  our $Smells_Like_VCS = (-e '.git' || -e '.svn' || -e '.hg'
    || (-e '../../dist.ini'
        && (-e '../../.git' || -e '../../.svn' || -e '../../.hg' )));
  
  sub import {
    strict->import;
    warnings->import(FATAL => 'all');
  
    my $extra_tests = do {
      if (exists $ENV{PERL_STRICTURES_EXTRA}) {
        if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}) {
          die 'PERL_STRICTURES_EXTRA checks are not available on perls older than 5.8.4: '
            . "please unset \$ENV{PERL_STRICTURES_EXTRA}\n";
        }
        $ENV{PERL_STRICTURES_EXTRA};
      } elsif (! _PERL_LT_5_8_4) {
        !!((caller)[1] =~ /^(?:t|xt|lib|blib)/
           and $Smells_Like_VCS)
      }
    };
    if ($extra_tests) {
      $extra_load_states ||= do {
  
        my (%rv, @failed);
        foreach my $mod (qw(indirect multidimensional bareword::filehandles)) {
          eval "require $mod; \$rv{'$mod'} = 1;" or do {
            push @failed, $mod;
  
            # courtesy of the 5.8 require bug
            # (we do a copy because 5.16.2 at least uses the same read-only
            # scalars for the qw() list and it doesn't seem worth a $^V check)
  
            (my $file = $mod) =~ s|::|/|g;
            delete $INC{"${file}.pm"};
          };
        }
  
        if (@failed) {
          my $failed = join ' ', @failed;
          print STDERR <<EOE;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  EOE
        }
  
        \%rv;
      };
  
      indirect->unimport(':fatal') if $extra_load_states->{indirect};
      multidimensional->unimport if $extra_load_states->{multidimensional};
      bareword::filehandles->unimport if $extra_load_states->{'bareword::filehandles'};
    }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures - turn on strict and make all warnings fatal
  
  =head1 SYNOPSIS
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
  
  except when called from a file which matches:
  
    (caller)[1] =~ /^(?:t|xt|lib|blib)/
  
  and when either C<.git>, C<.svn>, or C<.hg> is present in the current directory (with
  the intention of only forcing extra tests on the author side) -- or when C<.git>,
  C<.svn>, or C<.hg> is present two directories up along with C<dist.ini> (which would
  indicate we are in a C<dzil test> operation, via L<Dist::Zilla>) --
  or when the C<PERL_STRICTURES_EXTRA> environment variable is set, in which case
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Note that C<PERL_STRICTURES_EXTRA> may at some point add even more tests, with only a minor
  version increase, but any changes to the effect of C<use strictures> in
  normal mode will involve a major version bump.
  
  If any of the extra testing modules are not present, L<strictures> will
  complain loudly, once, via C<warn()>, and then shut up. But you really
  should consider installing them, they're all great anti-footgun tools.
  
  =head1 DESCRIPTION
  
  I've been writing the equivalent of this module at the top of my code for
  about a year now. I figured it was time to make it shorter.
  
  Things like the importer in C<use Moose> don't help me because they turn
  warnings on but don't make them fatal -- which from my point of view is
  useless because I want an exception to tell me my code isn't warnings-clean.
  
  Any time I see a warning from my code, that indicates a mistake.
  
  Any time my code encounters a mistake, I want a crash -- not spew to STDERR
  and then unknown (and probably undesired) subsequent behaviour.
  
  I also want to ensure that obvious coding mistakes, like indirect object
  syntax (and not so obvious mistakes that cause things to accidentally compile
  as such) get caught, but not at the cost of an XS dependency and not at the
  cost of blowing things up on another machine.
  
  Therefore, L<strictures> turns on additional checking, but only when it thinks
  it's running in a test file in a VCS checkout -- although if this causes
  undesired behaviour this can be overridden by setting the
  C<PERL_STRICTURES_EXTRA> environment variable.
  
  If additional useful author side checks come to mind, I'll add them to the
  C<PERL_STRICTURES_EXTRA> code path only -- this will result in a minor version increase (e.g.
  1.000000 to 1.001000 (1.1.0) or similar). Any fixes only to the mechanism of
  this code will result in a sub-version increase (e.g. 1.000000 to 1.000001
  (1.0.1)).
  
  If the behaviour of C<use strictures> in normal mode changes in any way, that
  will constitute a major version increase -- and the code already checks
  when its version is tested to ensure that
  
    use strictures 1;
  
  will continue to only introduce the current set of strictures even if 2.0 is
  installed.
  
  =head1 METHODS
  
  =head2 import
  
  This method does the setup work described above in L</DESCRIPTION>
  
  =head2 VERSION
  
  This method traps the C<< strictures->VERSION(1) >> call produced by a use line
  with a version number on it and does the version check.
  
  =head1 EXTRA TESTING RATIONALE
  
  Every so often, somebody complains that they're deploying via C<git pull>
  and that they don't want L<strictures> to enable itself in this case -- and that
  setting C<PERL_STRICTURES_EXTRA> to 0 isn't acceptable (additional ways to
  disable extra testing would be welcome but the discussion never seems to get
  that far).
  
  In order to allow us to skip a couple of stages and get straight to a
  productive conversation, here's my current rationale for turning the
  extra testing on via a heuristic:
  
  The extra testing is all stuff that only ever blows up at compile time;
  this is intentional. So the oft-raised concern that it's different code being
  tested is only sort of the case -- none of the modules involved affect the
  final optree to my knowledge, so the author gets some additional compile
  time crashes which he/she then fixes, and the rest of the testing is
  completely valid for all environments.
  
  The point of the extra testing -- especially C<no indirect> -- is to catch
  mistakes that newbie users won't even realise are mistakes without
  help. For example,
  
    foo { ... };
  
  where foo is an & prototyped sub that you forgot to import -- this is
  pernicious to track down since all I<seems> fine until it gets called
  and you get a crash. Worse still, you can fail to have imported it due
  to a circular require, at which point you have a load order dependent
  bug which I've seen before now I<only> show up in production due to tiny
  differences between the production and the development environment. I wrote
  L<http://shadow.cat/blog/matt-s-trout/indirect-but-still-fatal/> to explain
  this particular problem before L<strictures> itself existed.
  
  As such, in my experience so far L<strictures>' extra testing has
  I<avoided> production versus development differences, not caused them.
  
  Additionally, L<strictures>' policy is very much "try and provide as much
  protection as possible for newbies -- who won't think about whether there's
  an option to turn on or not" -- so having only the environment variable
  is not sufficient to achieve that (I get to explain that you need to add
  C<use strict> at least once a week on freenode #perl -- newbies sometimes
  completely skip steps because they don't understand that that step
  is important).
  
  I make no claims that the heuristic is perfect -- it's already been evolved
  significantly over time, especially for 1.004 where we changed things to
  ensure it only fires on files in your checkout (rather than L<strictures>-using
  modules you happened to have installed, which was just silly). However, I
  hope the above clarifies why a heuristic approach is not only necessary but
  desirable from a point of view of providing new users with as much safety as possible,
  and will allow any future discussion on the subject to focus on "how do we
  minimise annoyance to people deploying from checkouts intentionally".
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<indirect>
  
  =item *
  
  L<multidimensional>
  
  =item *
  
  L<bareword::filehandles>
  
  =back
  
  =head1 COMMUNITY AND SUPPORT
  
  =head2 IRC channel
  
  irc.perl.org #toolchain
  
  (or bug 'mst' in query on there or freenode)
  
  =head2 Git repository
  
  Gitweb is on http://git.shadowcat.co.uk/ and the clone URL is:
  
    git clone git://git.shadowcat.co.uk/p5sagit/strictures.git
  
  The web interface to the repository is at:
  
    http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=p5sagit/strictures.git
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@gmail.com>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the strictures L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
STRICTURES

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR';
  package Class::XSAccessor;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor::Heavy;
  use XSLoader;
  
  our $VERSION = '1.19';
  
  XSLoader::load('Class::XSAccessor', $VERSION);
  
  sub _make_hash {
    my $ref = shift;
  
    if (ref ($ref)) {
      if (ref($ref) eq 'ARRAY') {
        $ref = { map { $_ => $_ } @$ref }
      } 
    } else {
      $ref = { $ref, $ref };
    }
  
    return $ref;
  }
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    # TODO: Refactor. Move more duplicated code to ::Heavy
    my $read_subs      = _make_hash($opts{getters} || {});
    my $set_subs       = _make_hash($opts{setters} || {});
    my $acc_subs       = _make_hash($opts{accessors} || {});
    my $lvacc_subs     = _make_hash($opts{lvalue_accessors} || {});
    my $pred_subs      = _make_hash($opts{predicates} || {});
    my $ex_pred_subs   = _make_hash($opts{exists_predicates} || {});
    my $def_pred_subs  = _make_hash($opts{defined_predicates} || {});
    my $test_subs      = _make_hash($opts{__tests__} || {});
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["test", $test_subs],
                          ["ex_predicate", $ex_pred_subs],
                          ["def_predicate", $def_pred_subs],
                          ["def_predicate", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $hashkey = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $hashkey, \%opts, $subtype->[0]);
      }
    }
  
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $hashkey, $opts, $type) = @_;
  
    croak("Cannot use undef as a hash key for generating an XS $type accessor. (Sub: $subname)")
      if not defined $hashkey;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $hashkey);
    }
    elsif ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $hashkey);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $hashkey, $opts->{chained}||0);
    }
    elsif ($type eq 'def_predicate') {
      newxs_defined_predicate($subname, $hashkey);
    }
    elsif ($type eq 'ex_predicate') {
      newxs_exists_predicate($subname, $hashkey);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      newxs_boolean($subname, 0);
    }
    elsif ($type eq 'test') {
      newxs_test($subname, $hashkey);
    }
    else {
      newxs_accessor($subname, $hashkey, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Class::XSAccessor
      replace     => 1,   # Replace existing methods (if any)
      constructor => 'new',
      getters     => {
        get_foo => 'foo', # 'foo' is the hash key to access
        get_bar => 'bar',
      },
      setters => {
        set_foo => 'foo',
        set_bar => 'bar',
      },
      accessors => {
        foo => 'foo',
        bar => 'bar',
      },
      # "predicates" is an alias for "defined_predicates"
      defined_predicates => {
        defined_foo => 'foo',
        defined_bar => 'bar',
      },
      exists_predicates => {
        has_foo => 'foo',
        has_bar => 'bar',
      },
      lvalue_accessors => { # see below
        baz => 'baz', # ...
      },
      true  => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference, if preferred,
    # which can also help Perl::Tidy to format the statement correctly.
    use Class::XSAccessor {
       # If the name => key values are always identical,
       # the following shorthand can be used.
       accessors => [ 'foo', 'bar' ],
    };
  
  =head1 DESCRIPTION
  
  Class::XSAccessor implements fast read, write and read/write accessors in XS.
  Additionally, it can provide predicates such as C<has_foo()> for testing
  whether the attribute C<foo> exists in the object (which is different from
  "is defined within the object").
  It only works with objects that are implemented as ordinary hashes.
  L<Class::XSAccessor::Array> implements the same interface for objects
  that use arrays for their internal representation.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS). Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless { @_ }, ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Parameters to C<new()> are added to the
  object.
  
  The XS accessor methods are between 3 and 4 times faster than typical
  pure-Perl accessors in some simple benchmarking.
  The lower factor applies to the potentially slightly obscure
  C<sub set_foo_pp {$_[0]-E<gt>{foo} = $_[1]}>, so if you usually
  write clear code, a factor of 3.5 speed-up is a good estimate.
  If in doubt, do your own benchmarking!
  
  The method names may be fully qualified. The example in the synopsis could
  have been written as C<MyClass::get_foo> instead
  of C<get_foo>. This way, methods can be installed in classes other
  than the current class. See also: the C<class> option below.
  
  By default, the setters return the new value that was set,
  and the accessors (mutators) do the same. This behaviour can be changed
  with the C<chained> option - see below. The predicates return a boolean.
  
  Since version 1.01, C<Class::XSAccessor> can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then consider a large class hierarchy
  with interfaces such as L<PPI>. These methods are provided by the C<true>
  and C<false> options - see the synopsis.
  
  C<defined_predicates> check whether a given object attribute is defined.
  C<predicates> is an alias for C<defined_predicates> for compatibility with
  older versions of C<Class::XSAccessor>. C<exists_predicates> checks
  whether the given attribute exists in the object using C<exists>.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, additional options
  can be supplied which modify behaviour. The options are specified as key/value pairs
  in the same manner as the accessor declaration. For example:
  
    use Class::XSAccessor
      getters => {
        get_foo => 'foo',
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. The
  the C<class> option allows the target class to be specified.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 'zip' };
    
    package main;
    my $address = Address->new(zip => 2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably won't work for objects based on I<tied> hashes. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  that's only known at run-time. Note that compiling C code at run-time a la L<Inline::C|Inline::C>
  is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed>. Previously, a small amount of
  memory would leak if C<Class::XSAccessor>-based classes were loaded in a subthread without having
  been loaded in the "main" thread. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation, as of 1.00, the memory will still not be released, in the same situation,
  but it will be recycled when the same class, or a similar class, is loaded again in B<any> thread.
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<Class::XSAccessor::Array>
  
  =item * L<AutoXS>
  
  =back
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_ARRAY';
  package Class::XSAccessor::Array;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor;
  use Class::XSAccessor::Heavy;
  
  our $VERSION = '1.19';
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    my $read_subs      = $opts{getters} || {};
    my $set_subs       = $opts{setters} || {};
    my $acc_subs       = $opts{accessors} || {};
    my $lvacc_subs     = $opts{lvalue_accessors} || {};
    my $pred_subs      = $opts{predicates} || {};
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];  
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["pred_subs", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $array_index = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $array_index, \%opts, $subtype->[0]);
      }
    }
     
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $array_index, $opts, $type) = @_;
  
    croak("Cannot use undef as a array index for generating an XS $type accessor. (Sub: $subname)")
      if not defined $array_index;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $array_index);
    }
    if ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $array_index);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $array_index, $opts->{chained}||0);
    }
    elsif ($type eq 'predicate') {
      newxs_predicate($subname, $array_index);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      Class::XSAccessor::newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      Class::XSAccessor::newxs_boolean($subname, 0);
    }
    else {
      newxs_accessor($subname, $array_index, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Array - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
    
    package MyClassUsingArraysAsInternalStorage;
    use Class::XSAccessor::Array
      constructor => 'new',
      getters => {
        get_foo => 0, # 0 is the array index to access
        get_bar => 1,
      },
      setters => {
        set_foo => 0,
        set_bar => 1,
      },
      accessors => { # a mutator
        buz => 2,
      },
      predicates => { # test for definedness
        has_buz => 2,
      },
      lvalue_accessors => { # see below
        baz => 3,
      },
      true => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference if you prefer it,
    # which can also help PerlTidy to flow the statement correctly.
    use Class::XSAccessor {
      getters => {
        get_foo => 0,
        get_bar => 1,
      },
    };
  
  =head1 DESCRIPTION
  
  The module implements fast XS accessors both for getting at and
  setting an object attribute. Additionally, the module supports
  mutators and simple predicates (C<has_foo()> like tests for definedness
  of an attributes).
  The module works only with objects
  that are implemented as B<arrays>. Using it on hash-based objects is
  bound to make your life miserable. Refer to L<Class::XSAccessor> for
  an implementation that works with hash-based objects.
  
  A simple benchmark showed a significant performance
  advantage over writing accessors in Perl.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS) for you. Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless [], ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Note that any parameters to new() will be
  discarded! If there is a better idiom for array-based objects, let
  me know.
  
  While generally more obscure than hash-based objects,
  objects using blessed arrays as internal representation
  are a bit faster as its somewhat faster to access arrays than hashes.
  Accordingly, this module is slightly faster (~10-15%) than
  L<Class::XSAccessor>, which works on hash-based objects.
  
  The method names may be fully qualified. In the example of the
  synopsis, you could have written C<MyClass::get_foo> instead
  of C<get_foo>. This way, you can install methods in classes other
  than the current class. See also: The C<class> option below.
  
  Since version 1.01, you can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then think of a large class hierarchy
  with interfaces such as PPI. This is implemented as the C<true>
  and C<false> options, see synopsis.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, you can add options
  which modify behaviour. The options are specified as key/value pairs just as the
  accessor declaration. Example:
  
    use Class::XSAccessor::Array
      getters => {
        get_foo => 0,
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor::Array> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor::Array ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. Using
  the C<class> option, you can explicitly specify where the methods
  are to be generated.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 0 };
    
    package main;
    my $address = Address->new(2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably wouldn't work if your objects are I<tied>. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  or array index that's only known at run-time. Note that compiling C code at run-time
  a la Inline::C is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed> that would leak a small amount of
  memory if you loaded C<Class::XSAccessor>-based classes in a subthread that hadn't been loaded
  in the "main" thread before. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation as of 1.00, the memory will not be released again either in the above
  situation. But it will be recycled when the same class or a similar class is loaded
  again in B<any> thread.
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  
  L<AutoXS>
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_ARRAY

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_HEAVY';
  package # hide from PAUSE
      Class::XSAccessor::Heavy;
  
  use 5.008;
  use strict;
  use warnings;
  use Carp;
  
  our $VERSION  = '1.19';
  our @CARP_NOT = qw(
          Class::XSAccessor
          Class::XSAccessor::Array
  );
  
  # TODO Move more duplicated code from XSA and XSA::Array here
  
  
  sub check_sub_existence {
    my $subname = shift;
  
    my $sub_package = $subname;
    $sub_package =~ s/([^:]+)$// or die;
    my $bare_subname = $1;
      
    my $sym;
    {
      no strict 'refs';
      $sym = \%{"$sub_package"};
    }
    no warnings;
    local *s = $sym->{$bare_subname};
    my $coderef = *s{CODE};
    if ($coderef) {
      $sub_package =~ s/::$//;
      Carp::croak("Cannot replace existing subroutine '$bare_subname' in package '$sub_package' with an XS implementation. If you wish to force a replacement, add the 'replace => 1' parameter to the arguments of 'use ".(caller())[0]."'.");
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Heavy - Guts you don't care about
  
  =head1 SYNOPSIS
    
    use Class::XSAccessor!
  
  =head1 DESCRIPTION
  
  Common guts for Class::XSAccessor and Class::XSAccessor::Array.
  No user-serviceable parts inside!
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  L<Class::XSAccessor::Array>
  
  =head1 AUTHOR
  
  Steffen Mueller, E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy, E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
  
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_HEAVY

$fatpacked{"x86_64-linux-thread-multi/JSON/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_JSON_SYCK';
  package JSON::Syck;
  use strict;
  use vars qw( $VERSION @EXPORT_OK @ISA );
  use Exporter;
  use YAML::Syck ();
  
  BEGIN {
      $VERSION   = '1.27';
      @EXPORT_OK = qw( Load Dump LoadFile DumpFile DumpInto );
      @ISA       = 'Exporter';
      *Load      = \&YAML::Syck::LoadJSON;
      *Dump      = \&YAML::Syck::DumpJSON;
  }
  
  sub DumpFile {
      my $file = shift;
      if ( YAML::Syck::_is_glob($file) ) {
          my $err = YAML::Syck::DumpJSONFile( $_[0], $file );
          if ($err) {
              $! = 0 + $err;
              die "Error writing to filehandle $file: $!\n";
          }
      }
      else {
          open( my $fh, '>', $file ) or die "Cannot write to $file: $!";
          my $err = YAML::Syck::DumpJSONFile( $_[0], $fh );
          if ($err) {
              $! = 0 + $err;
              die "Error writing to file $file: $!\n";
          }
          close $fh
            or die "Error writing to file $file: $!\n";
      }
      return 1;
  }
  
  sub LoadFile {
      my $file = shift;
      if ( YAML::Syck::_is_glob($file) ) {
          YAML::Syck::LoadJSON(
              do { local $/; <$file> }
          );
      }
      else {
          if ( !-e $file || -z $file ) {
              die("'$file' is non-existent or empty");
          }
          open( my $fh, '<', $file ) or die "Cannot read from $file: $!";
          YAML::Syck::LoadJSON(
              do { local $/; <$fh> }
          );
      }
  }
  
  sub DumpInto {
      my $bufref = shift;
      ( ref $bufref ) or die "DumpInto not given reference to output buffer\n";
      YAML::Syck::DumpJSONInto( $_[0], $bufref );
      1;
  }
  
  $JSON::Syck::ImplicitTyping  = 1;
  $JSON::Syck::MaxDepth        = 512;
  $JSON::Syck::Headless        = 1;
  $JSON::Syck::ImplicitUnicode = 0;
  $JSON::Syck::SingleQuote     = 0;
  
  1;
  
  __END__
  
  =head1 NAME
  
  JSON::Syck - JSON is YAML (but consider using L<JSON::XS> instead!)
  
  =head1 SYNOPSIS
  
      use JSON::Syck; # no exports by default 
  
      my $data = JSON::Syck::Load($json);
      my $json = JSON::Syck::Dump($data);
  
      # $file can be an IO object, or a filename
      my $data = JSON::Syck::LoadFile($file);
      JSON::Syck::DumpFile($file, $data);
  
      # Dump into a pre-existing buffer
      my $json;
      JSON::Syck::DumpInto(\$json, $data);
  
  =head1 DESCRIPTION
  
  JSON::Syck is a syck implementation of JSON parsing and generation. Because
  JSON is YAML (L<http://redhanded.hobix.com/inspect/yamlIsJson.html>), using
  syck gives you a fast and memory-efficient parser and dumper for JSON data
  representation.
  
  However, a newer module L<JSON::XS>, has since emerged.  It is more flexible,
  efficient and robust, so please consider using it instead of this module.
  
  =head1 DIFFERENCE WITH JSON
  
  You might want to know the difference between the I<JSON> module and
  this one.
  
  Since JSON is a pure-perl module and JSON::Syck is based on libsyck,
  JSON::Syck is supposed to be very fast and memory efficient. See
  chansen's benchmark table at
  L<http://idisk.mac.com/christian.hansen/Public/perl/serialize.pl>
  
  JSON.pm comes with dozens of ways to do the same thing and lots of
  options, while JSON::Syck doesn't. There's only C<Load> and C<Dump>.
  
  Oh, and JSON::Syck doesn't use camelCase method names :-)
  
  =head1 REFERENCES
  
  =head2 SCALAR REFERENCE
  
  For now, when you pass a scalar reference to JSON::Syck, it
  dereferences to get the actual scalar value.
  
  JSON::Syck raises an exception when you pass in circular references.
  
  If you want to serialize self refernecing stuff, you should use
  YAML which supports it.
  
  =head2 SUBROUTINE REFERENCE
  
  When you pass subroutine reference, JSON::Syck dumps it as null.
  
  =head1 UTF-8 FLAGS
  
  By default this module doesn't touch any of utf-8 flags set in
  strings, and assumes UTF-8 bytes to be passed and emit.
  
  However, when you set C<$JSON::Syck::ImplicitUnicode> to 1, this
  module properly decodes UTF-8 binaries and sets UTF-8 flag everywhere,
  as in:
  
    JSON (UTF-8 bytes)   => Perl (UTF-8 flagged)
    JSON (UTF-8 flagged) => Perl (UTF-8 flagged)
    Perl (UTF-8 bytes)   => JSON (UTF-8 flagged)
    Perl (UTF-8 flagged) => JSON (UTF-8 flagged)
  
  By default, JSON::Syck::Dump will only transverse up to 512 levels of
  a datastructure in order to avoid an infinite loop when it is
  presented with an circular reference.
  
  However, you set C<$JSON::Syck::MaxLevels> to a larger value if you
  have very complex structures.
  
  Unfortunately, there's no implicit way to dump Perl UTF-8 flagged data
  structure to utf-8 encoded JSON. To do this, simply use Encode module, e.g.:
  
    use Encode;
    use JSON::Syck qw(Dump);
  
    my $json = encode_utf8( Dump($data) );
  
  Alternatively you can use Encode::JavaScript::UCS to encode Unicode
  strings as in I<%uXXXX> form.
  
    use Encode;
    use Encode::JavaScript::UCS;
    use JSON::Syck qw(Dump);
  
    my $json_unicode_escaped = encode( 'JavaScript-UCS', Dump($data) );
  
  =head1 QUOTING
  
  According to the JSON specification, all JSON strings are to be double-quoted.
  However, when embedding JavaScript in HTML attributes, it may be more
  convenient to use single quotes.
  
  Set C<$JSON::Syck::SingleQuote> to 1 will make both C<Dump> and C<Load> expect
  single-quoted string literals.
  
  =head1 BUGS
  
  Dumping into tied (or other magic variables) with C<DumpInto> might not work
  properly in all cases.
  
  When dumping with C<DumpFile>, some spacing might be wrong and
  C<$JSON::Syck::SingleQuote> might be handled incorrectly.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<YAML::Syck>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  Tatsuhiko Miyagawa E<lt>miyagawa@gmail.comE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005-2009 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  The F<libsyck> code bundled with this library is released by
  "why the lucky stiff", under a BSD-style license.  See the F<COPYING>
  file for details.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
X86_64-LINUX-THREAD-MULTI_JSON_SYCK

$fatpacked{"x86_64-linux-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
    pairmap pairgrep pairfirst pairs pairkeys pairvalues
  );
  our $VERSION    = "1.38";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 $b = any { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 $b = all { BLOCK } @list
  
  Similar to C<any>, except that it requires all elements of the C<@list> to make
  the C<BLOCK> return true. If any element returns false, then it returns false.
  If the C<BLOCK> never returns false or the C<@list> was empty then it returns
  true.
  
  =head2 $b = none { BLOCK } @list
  
  =head2 $b = notall { BLOCK } @list
  
  Similar to C<any> and C<all>, but with the return sense inverted. C<none>
  returns true only if no value in the LIST causes the BLOCK to return true, and
  C<notall> returns true only if not all of the values do.
  
  =head2 $val = first { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 $num = max @list
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 $str = maxstr @list
  
  Similar to C<max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 $num = min @list
  
  Similar to C<max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 $str = minstr @list
  
  Similar to C<min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 $num = product @list
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 $num_or_undef = sum @list
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 $num = sum0 @list
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather than
  C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  =cut
  
  =head2 @kvlist = pairgrep { BLOCK } @kvlist
  
  =head2 $count = pairgrep { BLOCK } @kvlist
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 ( $key, $val ) = pairfirst { BLOCK } @kvlist
  
  =head2 $found = pairfirst { BLOCK } @kvlist
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @list = pairmap { BLOCK } @kvlist
  
  =head2 $count = pairmap { BLOCK } @kvlist
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @pairs = pairs @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of ARRAY references, each containing two items from the given
  list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 @keys = pairkeys @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 @values = pairvalues @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 @values = shuffle @values
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce will return
  an incorrect result. This will show up as test 7 of reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.38";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted
  );
  our $VERSION    = "1.38";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 $pkg = blessed( $ref )
  
  If C<$ref> is a blessed reference the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 $addr = refaddr( $ref )
  
  If C<$ref> is reference the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 $type = reftype( $ref )
  
  If C<$ref> is a reference the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken( REF )
  
  The lvalue C<REF> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken( REF )
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  C<weaken()>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 $weak = isweak( $ref )
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 $var = dualvar( $num, $string )
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 $dual = isdual( $var )
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is actually
  implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 $vstring = isvstring( $var )
  
  If C<$var> is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 $isnum = looks_like_number( $var )
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 $fh = openhandle( $fh )
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 $ro = readonly( $var )
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 $code = set_prototype( $code, $prototype )
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 $t = tainted( $var )
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its
  functions so that those without access to a C compiler may still use it.
  However some of the functions are only available when a C compiler was
  available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-thread-multi/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
X86_64-LINUX-THREAD-MULTI_SUB_NAME

$fatpacked{"x86_64-linux-thread-multi/Term/ReadLine/Gnu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TERM_READLINE_GNU';
  #
  #	Gnu.pm --- The GNU Readline/History Library wrapper module
  #
  #	$Id: Gnu.pm 445 2014-03-01 16:14:02Z hayashi $
  #
  #	Copyright (c) 2014 Hiroo Hayashi.  All rights reserved.
  #
  #	This program is free software; you can redistribute it and/or
  #	modify it under the same terms as Perl itself.
  #
  #	Some of documentation strings in this file are cited from the
  #	GNU Readline/History Library Manual.
  
  package Term::ReadLine::Gnu;
  
  =head1 NAME
  
  Term::ReadLine::Gnu - Perl extension for the GNU Readline/History Library
  
  =head1 SYNOPSIS
  
    use Term::ReadLine;
    $term = new Term::ReadLine 'ProgramName';
    while ( defined ($_ = $term->readline('prompt>')) ) {
      ...
    }
  
  =head1 DESCRIPTION
  
  =head2 Overview
  
  This is an implementation of Term::ReadLine using the GNU
  Readline/History Library.
  
  For basic functions object oriented interface is provided. These are
  described in the section L<"Standard Methods"|"Standard Methods"> and
  L<"C<Term::ReadLine::Gnu> Functions"|"C<Term::ReadLine::Gnu> Functions">.
  
  This package also has the interface with the almost all functions and
  variables which are documented in the GNU Readline/History Library
  Manual.  They are documented in the section
  L<"C<Term::ReadLine::Gnu> Functions"|"C<Term::ReadLine::Gnu> Functions">
  and
  L<"C<Term::ReadLine::Gnu> Variables"|"C<Term::ReadLine::Gnu> Variables">
  briefly.  For more detail of the GNU Readline/History Library, see
  'GNU Readline Library Manual' and 'GNU History Library Manual'.
  
  The sample programs under C<eg/> directory and test programs under
  C<t/> directory in the C<Term::ReadLine::Gnu> distribution include
  many example of this module.
  
  =head2 Standard Methods
  
  These methods are standard methods defined by B<Term::ReadLine>.
  
  =cut
  
  use strict;
  use Carp;
  
  # This module can't be loaded directly.
  BEGIN {
      if (not defined $Term::ReadLine::VERSION) {
          croak <<END;
  It is invalid to load Term::ReadLine::Gnu directly.  Please consult
  the Term::ReadLine documentation for more information.
  END
      }
  }
  
  {
      use Exporter ();
      use DynaLoader;
      use vars qw($VERSION @ISA @EXPORT_OK);
  
      $VERSION = '1.21';
  
      # Term::ReadLine::Gnu::AU makes a function in
      # `Term::ReadLine::Gnu::XS' as a method.
      # The namespace of Term::ReadLine::Gnu::AU is searched before ones
      # of other classes
      @ISA = qw(Term::ReadLine::Gnu::AU Term::ReadLine::Stub
  	      Exporter DynaLoader);
  
      @EXPORT_OK = qw(RL_PROMPT_START_IGNORE RL_PROMPT_END_IGNORE
  		    NO_MATCH SINGLE_MATCH MULT_MATCH
  		    ISFUNC ISKMAP ISMACR
  		    UNDO_DELETE UNDO_INSERT UNDO_BEGIN UNDO_END
  		    RL_STATE_NONE RL_STATE_INITIALIZING
  		    RL_STATE_INITIALIZED RL_STATE_TERMPREPPED
  		    RL_STATE_READCMD RL_STATE_METANEXT
  		    RL_STATE_DISPATCHING RL_STATE_MOREINPUT
  		    RL_STATE_ISEARCH RL_STATE_NSEARCH
  		    RL_STATE_SEARCH RL_STATE_NUMERICARG
  		    RL_STATE_MACROINPUT RL_STATE_MACRODEF
  		    RL_STATE_OVERWRITE RL_STATE_COMPLETING
  		    RL_STATE_SIGHANDLER RL_STATE_UNDOING
  		    RL_STATE_INPUTPENDING RL_STATE_TTYCSAVED
  		    RL_STATE_CALLBACK RL_STATE_VIMOTION
  		    RL_STATE_MULTIKEY RL_STATE_VICMDONCE
  		    RL_STATE_DONE);
  
      bootstrap Term::ReadLine::Gnu $VERSION; # DynaLoader
  }
  require Term::ReadLine::Gnu::XS;
  
  #	Global Variables
  
  use vars qw(%Attribs %Features);
  
  # Each variable in the GNU Readline Library is tied to an entry of
  # this hash (%Attribs).  By accessing the hash entry, you can read
  # and/or write the variable in the GNU Readline Library.  See the
  # package definition of Term::ReadLine::Gnu::Var and following code
  # for more details.
  
  # Normal (non-tied) entries
  %Attribs  = (
  	     MinLength => 1,
  	     do_expand => 0,
  	     completion_word => [],
  	     term_set => ['', '', '', ''],
  	    );
  %Features = (
  	     appname => 1, minline => 1, autohistory => 1,
  	     getHistory => 1, setHistory => 1, addHistory => 1,
  	     readHistory => 1, writeHistory => 1,
  	     preput => 1, attribs => 1, newTTY => 1,
  	     tkRunning => Term::ReadLine::Stub->Features->{'tkRunning'},
  	     ornaments => Term::ReadLine::Stub->Features->{'ornaments'},
  	     stiflehistory => 1,
  	    );
  
  sub Attribs { \%Attribs; }
  sub Features { \%Features; }
  
  # keep rl_readline_version value for efficiency
  my $readline_version;
  
  #
  #	GNU Readline/History Library constant definition
  #	These are included in @EXPORT_OK.
  
  # I can define these variables in XS code to use the value defined in
  # readline.h, etc.  But it needs some calling convention change and
  # will cause compatiblity problem. I hope the definition of these
  # constant value will not be changed.
  
  # for non-printing characters in prompt string
  sub RL_PROMPT_START_IGNORE	{ "\001"; }
  sub RL_PROMPT_END_IGNORE	{ "\002"; }
  
  # for rl_filename_quoting_function
  sub NO_MATCH	 { 0; }
  sub SINGLE_MATCH { 1; }
  sub MULT_MATCH   { 2; }
  
  # for rl_generic_bind, rl_function_of_keyseq
  sub ISFUNC	{ 0; }
  sub ISKMAP	{ 1; }
  sub ISMACR	{ 2; }
  
  # for rl_add_undo
  sub UNDO_DELETE	{ 0; }
  sub UNDO_INSERT	{ 1; }
  sub UNDO_BEGIN	{ 2; }
  sub UNDO_END	{ 3; }
  
  # for rl_readline_state
  sub RL_STATE_NONE		{ 0x00000; } # no state; before first call
  sub RL_STATE_INITIALIZING	{ 0x00001; } # initializing
  sub RL_STATE_INITIALIZED	{ 0x00002; } # initialization done
  sub RL_STATE_TERMPREPPED	{ 0x00004; } # terminal is prepped
  sub RL_STATE_READCMD		{ 0x00008; } # reading a command key
  sub RL_STATE_METANEXT		{ 0x00010; } # reading input after ESC
  sub RL_STATE_DISPATCHING	{ 0x00020; } # dispatching to a command
  sub RL_STATE_MOREINPUT		{ 0x00040; } # reading more input in a command function
  sub RL_STATE_ISEARCH		{ 0x00080; } # doing incremental search
  sub RL_STATE_NSEARCH		{ 0x00100; } # doing non-inc search
  sub RL_STATE_SEARCH		{ 0x00200; } # doing a history search
  sub RL_STATE_NUMERICARG		{ 0x00400; } # reading numeric argument
  sub RL_STATE_MACROINPUT		{ 0x00800; } # getting input from a macro
  sub RL_STATE_MACRODEF		{ 0x01000; } # defining keyboard macro
  sub RL_STATE_OVERWRITE		{ 0x02000; } # overwrite mode
  sub RL_STATE_COMPLETING		{ 0x04000; } # doing completion
  sub RL_STATE_SIGHANDLER		{ 0x08000; } # in readline sighandler
  sub RL_STATE_UNDOING		{ 0x10000; } # doing an undo
  # The following RL_STATE_* are defined since TRL 6.0
  sub RL_STATE_INPUTPENDING	{ 0x020000; } #	rl_execute_next called
  sub RL_STATE_TTYCSAVED		{ 0x040000; } #	tty special chars saved
  sub RL_STATE_CALLBACK		{ 0x080000; } #	using the callback interface
  sub RL_STATE_VIMOTION		{ 0x100000; } #	reading vi motion arg
  sub RL_STATE_MULTIKEY		{ 0x200000; } #	reading multiple-key command
  sub RL_STATE_VICMDONCE		{ 0x400000; } #	entered vi command mode at least once
  # The following RL_STATE_* is defined since TRL 6.1
  sub RL_STATE_REDISPLAYING	{ 0x800000; } #	updating terminal display
  # The value was changed since TRL 6.0 and 6.1
  # done; accepted line
  sub RL_STATE_DONE { $readline_version < 0x0600 ? 0x80000 : 
  			($readline_version < 0x0601 ? 0x800000 : 0x1000000); }
  
  #
  #	Methods Definition
  #
  
  =over 4
  
  =item C<ReadLine>
  
  returns the actual package that executes the commands. If you have
  installed this package,  possible value is C<Term::ReadLine::Gnu>.
  
  =cut
  
  sub ReadLine { 'Term::ReadLine::Gnu'; }
  
  =item C<new(NAME,[IN[,OUT]])>
  
  returns the handle for subsequent calls to following functions.
  Argument is the name of the application.  Optionally can be followed
  by two arguments for C<IN> and C<OUT> file handles. These arguments
  should be globs.
  
  =cut
  
  # The origin of this function is Term::ReadLine::Perl.pm by Ilya Zakharevich.
  sub new {
      my $this = shift;		# Package
      my $class = ref($this) || $this;
  
      my $name = shift;
  
      my $self = \%Attribs;
      bless $self, $class;
  
      # set rl_readline_name before .inputrc is read in rl_initialize()
      $Attribs{readline_name} = $name;
  
      # some version of Perl cause segmentation fault, if XS module
      # calls setenv() before the 1st assignment to $ENV{}.
      $ENV{_TRL_DUMMY} = '';
  
      # initialize the GNU Readline Library and termcap library
      $self->initialize();
  
      # enable ornaments to be compatible with perl5.004_05(?)
      unless ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/) {
  	local $^W = 0;		# Term::ReadLine is not warning flag free
  	# Without the next line Term::ReadLine::Stub::ornaments is used.
  	# Why does Term::ReadLine::Gnu::AU selects it at first?!!!
  	# If you know why this happens, please let me know.  Thanks.
  	undef &Term::ReadLine::Gnu::ornaments;
  	$self->ornaments(1);
      }
  
      if (!@_) {
  	my ($IN,$OUT) = $self->findConsole();
  	open(IN,"<$IN")   || croak "Cannot open $IN for read";
  	open(OUT,">$OUT") || croak "Cannot open $OUT for write";
  	# borrowed from Term/ReadLine.pm
  	my $sel = select(OUT);
  	$| = 1;				# for DB::OUT
  	select($sel);
  	$Attribs{instream} = \*IN;
  	$Attribs{outstream} = \*OUT;
      } else {
  	$Attribs{instream} = shift;
  	$Attribs{outstream} = shift;
      }
      $readline_version = $Attribs{readline_version};
  
      $self;
  }
  
  sub DESTROY {}
  
  =item C<readline(PROMPT[,PREPUT])>
  
  gets an input line, with actual C<GNU Readline> support.  Trailing
  newline is removed.  Returns C<undef> on C<EOF>.  C<PREPUT> is an
  optional argument meaning the initial value of input.
  
  The optional argument C<PREPUT> is granted only if the value C<preput>
  is in C<Features>.
  
  C<PROMPT> may include some escape sequences.  Use
  C<RL_PROMPT_START_IGNORE> to begin a sequence of non-printing
  characters, and C<RL_PROMPT_END_IGNORE> to end of such a sequence.
  
  =cut
  
  # to peacify -w
  $Term::ReadLine::registered = $Term::ReadLine::registered;
  
  sub readline {			# should be ReadLine
      my $self = shift;
      my ($prompt, $preput) = @_;
  
      # contributed fix for Perl debugger
      # make sure the outstream fd inside the readline library is
      # in sync (see http://bugs.debian.org/236018)
      $Attribs{outstream} = $Attribs{outstream};
  
      # ornament support (now prompt only)
      $prompt = ${$Attribs{term_set}}[0] . $prompt . ${$Attribs{term_set}}[1];
  
      # `completion_function' support for compatibility with
      # Term:ReadLine::Perl.  Prefer $completion_entry_function, since a
      # program which uses $completion_entry_function should know
      # Term::ReadLine::Gnu and have better completion function using
      # the variable.
      $Attribs{completion_entry_function} = $Attribs{_trp_completion_function}
  	if (!defined $Attribs{completion_entry_function}
  	    && defined $Attribs{completion_function});
  
      # TkRunning support
      if (not $Term::ReadLine::registered and $Term::ReadLine::toloop
  	and defined &Tk::DoOneEvent) {
  	$self->register_Tk;
  	$Attribs{getc_function} = $Attribs{Tk_getc};
      }
  
      # call readline()
      my $line;
      if (defined $preput) {
  	my $saved_startup_hook = $Attribs{startup_hook};
  	$Attribs{startup_hook} = sub {
  	    $self->rl_insert_text($preput);
  	    &$saved_startup_hook
  		if defined $saved_startup_hook;
  	};
  	$line = $self->rl_readline($prompt);
  	$Attribs{startup_hook} = $saved_startup_hook;
      } else {
  	$line = $self->rl_readline($prompt);
      }
      return undef unless defined $line;
  
      # history expansion
      if ($Attribs{do_expand}) {
  	my $result;
  	($result, $line) = $self->history_expand($line);
  	my $outstream = $Attribs{outstream};
  	print $outstream "$line\n" if ($result);
  
  	# return without adding line into history
  	if ($result < 0 || $result == 2) {
  	    return '';		# don't return `undef' which means EOF.
  	}
      }
  
      # add to history buffer
      $self->add_history($line)
  	if (defined $self->{MinLength} && $self->{MinLength} > 0
  	    && length($line) >= $self->{MinLength});
  
      return $line;
  }
  
  =item C<AddHistory(LINE1, LINE2, ...)>
  
  adds the lines to the history of input, from where it can be used if
  the actual C<readline> is present.
  
  =cut
  
  use vars '*addhistory';
  *addhistory = \&AddHistory;	# for backward compatibility
  
  sub AddHistory {
      my $self = shift;
      foreach (@_) {
  	$self->add_history($_);
      }
  }
  
  =item C<IN>, C<OUT>
  
  return the file handles for input and output or C<undef> if
  C<readline> input and output cannot be used for Perl.
  
  =cut
  
  sub IN  { $Attribs{instream}; }
  sub OUT { $Attribs{outstream}; }
  
  =item C<MinLine([MAX])>
  
  If argument C<MAX> is specified, it is an advice on minimal size of
  line to be included into history.  C<undef> means do not include
  anything into history.  Returns the old value.
  
  =cut
  
  sub MinLine {
      my $self = shift;
      my $old_minlength = $self->{MinLength};
      $self->{MinLength} = shift;
      $old_minlength;
  }
  
  # findConsole is defined in ReadLine.pm.
  
  =item C<findConsole>
  
  returns an array with two strings that give most appropriate names for
  files for input and output using conventions C<"E<lt>$in">, C<"E<gt>$out">.
  
  =item C<Attribs>
  
  returns a reference to a hash which describes internal configuration
  (variables) of the package.  Names of keys in this hash conform to
  standard conventions with the leading C<rl_> stripped.
  
  See section "Variables" for supported variables.
  
  =item C<Features>
  
  Returns a reference to a hash with keys being features present in
  current implementation. Several optional features are used in the
  minimal interface: C<appname> should be present if the first argument
  to C<new> is recognized, and C<minline> should be present if
  C<MinLine> method is not dummy.  C<autohistory> should be present if
  lines are put into history automatically (maybe subject to
  C<MinLine>), and C<addHistory> if C<AddHistory> method is not dummy. 
  C<preput> means the second argument to C<readline> method is processed.
  C<getHistory> and C<setHistory> denote that the corresponding methods are 
  present. C<tkRunning> denotes that a Tk application may run while ReadLine
  is getting input.
  
  =cut
  
  # Not tested yet.  How do I use this?
  sub newTTY {
      my ($self, $in, $out) = @_;
      $Attribs{instream}  = $in;
      $Attribs{outstream} = $out;
      my $sel = select($out);
      $| = 1;			# for DB::OUT
      select($sel);
  }
  
  =back
  
  =cut
  
  # documented later
  sub CallbackHandlerInstall {
      my $self = shift;
      my ($prompt, $lhandler) = @_;
  
      $Attribs{_callback_handler} = $lhandler;
  
      # ornament support (now prompt only)
      $prompt = ${$Attribs{term_set}}[0] . $prompt . ${$Attribs{term_set}}[1];
  
      $Attribs{completion_entry_function} = $Attribs{_trp_completion_function}
  	if (!defined $Attribs{completion_entry_function}
  	    && defined $Attribs{completion_function});
  
      $self->rl_callback_handler_install($prompt,
  				       \&Term::ReadLine::Gnu::XS::_ch_wrapper);
  }
  
  
  #
  #	Additional Supported Methods
  #
  
  # Documentation is after '__END__' for efficiency.
  
  # for backward compatibility
  use vars qw(*AddDefun *BindKey *UnbindKey *ParseAndBind *StifleHistory);
  *AddDefun = \&add_defun;
  *BindKey = \&bind_key;
  *UnbindKey = \&unbind_key;
  *ParseAndBind = \&parse_and_bind;
  *StifleHistory = \&stifle_history;
  
  sub SetHistory {
      my $self = shift;
      $self->clear_history();
      $self->AddHistory(@_);
  }
  
  sub GetHistory {
      my $self = shift;
      $self->history_list();
  }
  
  sub ReadHistory {
      my $self = shift;
      ! $self->read_history_range(@_);
  }
  
  sub WriteHistory {
      my $self = shift;
      ! $self->write_history(@_);
  }
  
  #
  #	Access Routines for GNU Readline/History Library Variables
  #
  package Term::ReadLine::Gnu::Var;
  use Carp;
  use strict;
  use vars qw(%_rl_vars);
  
  %_rl_vars
      = (
         rl_line_buffer				=> ['S', 0],
         rl_prompt				=> ['S', 1],
         rl_library_version			=> ['S', 2],
         rl_terminal_name				=> ['S', 3],
         rl_readline_name				=> ['S', 4],
         rl_basic_word_break_characters		=> ['S', 5],
         rl_basic_quote_characters		=> ['S', 6],
         rl_completer_word_break_characters	=> ['S', 7],
         rl_completer_quote_characters		=> ['S', 8],
         rl_filename_quote_characters		=> ['S', 9],
         rl_special_prefixes			=> ['S', 10],
         history_no_expand_chars			=> ['S', 11],
         history_search_delimiter_chars		=> ['S', 12],
         rl_executing_macro			=> ['S', 13], # GRL 4.2
         history_word_delimiters			=> ['S', 14], # GRL 4.2
         rl_display_prompt			=> ['S', 15], # GRL 6.0
         rl_executing_keyseq			=> ['S', 16], # GRL 6.3
  
         rl_point					=> ['I', 0],
         rl_end					=> ['I', 1],
         rl_mark					=> ['I', 2],
         rl_done					=> ['I', 3],
         rl_pending_input				=> ['I', 4],
         rl_completion_query_items		=> ['I', 5],
         rl_completion_append_character		=> ['C', 6],
         rl_ignore_completion_duplicates		=> ['I', 7],
         rl_filename_completion_desired		=> ['I', 8],
         rl_filename_quoting_desired		=> ['I', 9],
         rl_inhibit_completion			=> ['I', 10],
         history_base				=> ['I', 11],
         history_length				=> ['I', 12],
         history_max_entries			=> ['I', 13],
         max_input_history			=> ['I', 13], # before GRL 4.2
         history_write_timestamps			=> ['I', 14], # GRL 5.0
         history_expansion_char			=> ['C', 15],
         history_subst_char			=> ['C', 16],
         history_comment_char			=> ['C', 17],
         history_quotes_inhibit_expansion		=> ['I', 18],
         rl_erase_empty_line			=> ['I', 19], # GRL 4.0
         rl_catch_signals				=> ['I', 20], # GRL 4.0
         rl_catch_sigwinch			=> ['I', 21], # GRL 4.0
         rl_already_prompted			=> ['I', 22], # GRL 4.1
         rl_num_chars_to_read			=> ['I', 23], # GRL 4.1
         rl_dispatching				=> ['I', 24], # GRL 4.2
         rl_gnu_readline_p			=> ['I', 25], # GRL 4.1
         rl_readline_state			=> ['I', 26], # GRL 4.2
         rl_explicit_arg				=> ['I', 27], # GRL 4.2
         rl_numeric_arg				=> ['I', 28], # GRL 4.2
         rl_editing_mode				=> ['I', 29], # GRL 4.2
         rl_attempted_completion_over		=> ['I', 30], # GRL 4.2
         rl_completion_type			=> ['I', 31], # GRL 4.2
         rl_readline_version			=> ['I', 32], # GRL 4.2a
         rl_completion_suppress_append		=> ['I', 33], # GRL 4.3
         rl_completion_quote_character		=> ['C', 34], # GRL 5.0
         rl_completion_suppress_quote		=> ['I', 35], # GRL 5.0
         rl_completion_found_quote		=> ['I', 36], # GRL 5.0
         rl_completion_mark_symlink_dirs		=> ['I', 37], # GRL 4.3
         rl_prefer_env_winsize			=> ['I', 38], # GRL 5.1
         rl_sort_completion_matches		=> ['I', 39], # GRL 6.0
         rl_completion_invoking_key		=> ['C', 40], # GRL 6.0
         rl_executing_key				=> ['I', 41], # GRL 6.3
         rl_key_sequence_length			=> ['I', 42], # GRL 6.3
         rl_change_environment			=> ['I', 43], # GRL 6.3
  
         rl_startup_hook				=> ['F', 0],
         rl_event_hook				=> ['F', 1],
         rl_getc_function				=> ['F', 2],
         rl_redisplay_function			=> ['F', 3],
         rl_completion_entry_function		=> ['F', 4],
         rl_attempted_completion_function		=> ['F', 5],
         rl_filename_quoting_function		=> ['F', 6],
         rl_filename_dequoting_function		=> ['F', 7],
         rl_char_is_quoted_p			=> ['F', 8],
         rl_ignore_some_completions_function	=> ['F', 9],
         rl_directory_completion_hook		=> ['F', 10],
         history_inhibit_expansion_function	=> ['F', 11],
         rl_pre_input_hook			=> ['F', 12], # GRL 4.0
         rl_completion_display_matches_hook	=> ['F', 13], # GRL 4.0
         rl_completion_word_break_hook		=> ['F', 14], # GRL 5.0
         rl_prep_term_function			=> ['F', 15], # GRL 4.2
         rl_deprep_term_function			=> ['F', 16], # GRL 4.2
         rl_directory_rewrite_hook		=> ['F', 17], # GRL 4.2
         rl_filename_rewrite_hook			=> ['F', 18], # GRL 6.1
         rl_signal_event_hook			=> ['F', 19], # GRL 6.3
         rl_input_available_hook			=> ['F', 20], # GRL 6.3
         rl_filename_stat_hook			=> ['F', 21], # GRL 6.3
  
         rl_instream				=> ['IO', 0],
         rl_outstream				=> ['IO', 1],
  
         rl_executing_keymap			=> ['K', 0],
         rl_binding_keymap			=> ['K', 1],
  
         rl_last_func                             => ['LF', 0],
        );
  
  sub TIESCALAR {
      my $class = shift;
      my $name = shift;
      return bless \$name, $class;
  }
  
  sub FETCH {
      my $self = shift;
      confess "wrong type" unless ref $self;
  
      my $name = $$self;
      if (! defined $_rl_vars{$name}) {
  	confess "Term::ReadLine::Gnu::Var::FETCH: Unknown variable name `$name'\n";
  	return undef ;
      }
  
      my ($type, $id) = @{$_rl_vars{$name}};
      if ($type eq 'S') {
  	return _rl_fetch_str($id);
      } elsif ($type eq 'I') {
  	return _rl_fetch_int($id);
      } elsif ($type eq 'C') {
  	return chr(_rl_fetch_int($id));
      } elsif ($type eq 'F') {
  	return _rl_fetch_function($id);
      } elsif ($type eq 'IO') {
  	return _rl_fetch_iostream($id);
      } elsif ($type eq 'K') {
  	return _rl_fetch_keymap($id);
      } elsif ($type eq 'LF') {
          return _rl_fetch_last_func();
      } else {
  	carp "Term::ReadLine::Gnu::Var::FETCH: Illegal type `$type'\n";
  	return undef;
      }
  }
  
  sub STORE {
      my $self = shift;
      confess "wrong type" unless ref $self;
  
      my $name = $$self;
      if (! defined $_rl_vars{$name}) {
  	confess "Term::ReadLine::Gnu::Var::STORE: Unknown variable name `$name'\n";
  	return undef ;
      }
  
      my $value = shift;
      my ($type, $id) = @{$_rl_vars{$name}};
      if ($type eq 'S') {
  	if ($name eq 'rl_line_buffer') {
  	    return _rl_store_rl_line_buffer($value);
  	} else {
  	    return _rl_store_str($value, $id);
  	}
      } elsif ($type eq 'I') {
  	return _rl_store_int($value, $id);
      } elsif ($type eq 'C') {
  	return chr(_rl_store_int(ord($value), $id));
      } elsif ($type eq 'F') {
  	return _rl_store_function($value, $id);
      } elsif ($type eq 'IO') {
  	return _rl_store_iostream($value, $id);
      } elsif ($type eq 'K' || $type eq 'LF') {
  	carp "Term::ReadLine::Gnu::Var::STORE: read only variable `$name'\n";
  	return undef;
      } else {
  	carp "Term::ReadLine::Gnu::Var::STORE: Illegal type `$type'\n";
  	return undef;
      }
  }
  
  package Term::ReadLine::Gnu;
  use Carp;
  use strict;
  
  #
  #	set value of %Attribs
  #
  
  #	Tie all Readline/History variables
  foreach (keys %Term::ReadLine::Gnu::Var::_rl_vars) {
      my $name;
      ($name = $_) =~ s/^rl_//;	# strip leading `rl_'
      tie $Attribs{$name},  'Term::ReadLine::Gnu::Var', $_;
  }
  
  #	add reference to some functions
  {
      my ($name, $fname);
      no strict 'refs';		# allow symbolic reference
      map {
  	($name = $_) =~ s/^rl_//; # strip leading `rl_'
  	$fname = 'Term::ReadLine::Gnu::XS::' . $_;
  	$Attribs{$name} = \&$fname; # symbolic reference
      } qw(rl_getc
  	 rl_redisplay
  	 rl_callback_read_char
  	 rl_display_match_list
  	 rl_filename_completion_function
  	 rl_username_completion_function
  	 list_completion_function
           _trp_completion_function);
      # auto-split subroutine cannot be processed in the map loop above
      use strict 'refs';
      $Attribs{shadow_redisplay} = \&Term::ReadLine::Gnu::XS::shadow_redisplay;
      $Attribs{Tk_getc} = \&Term::ReadLine::Gnu::XS::Tk_getc;
      $Attribs{list_completion_function} = \&Term::ReadLine::Gnu::XS::list_completion_function;
  }
  
  package Term::ReadLine::Gnu::AU;
  use Carp;
  no strict qw(refs vars);
  
  sub AUTOLOAD {
      { $AUTOLOAD =~ s/.*:://; }	# preserve match data
      my $name;
      if (exists $Term::ReadLine::Gnu::XS::{"rl_$AUTOLOAD"}) {
  	$name = "Term::ReadLine::Gnu::XS::rl_$AUTOLOAD";
      } elsif (exists $Term::ReadLine::Gnu::XS::{"$AUTOLOAD"}) {
  	$name = "Term::ReadLine::Gnu::XS::$AUTOLOAD";
      } else {
  	croak "Cannot do `$AUTOLOAD' in Term::ReadLine::Gnu";
      }
      local $^W = 0;		# Why is this line necessary ?
      *$AUTOLOAD = sub { shift; &$name(@_); };
      goto &$AUTOLOAD;
  }
  1;
  __END__
  
  
  =head2 C<Term::ReadLine::Gnu> Functions
  
  All these GNU Readline/History Library functions are callable via
  method interface and have names which conform to standard conventions
  with the leading C<rl_> stripped.
  
  Almost methods have lower level functions in
  C<Term::ReadLine::Gnu::XS> package.  To use them full qualified name
  is required.  Using method interface is preferred.
  
  =over 4
  
  =item Readline Convenience Functions
  
  =over 4
  
  =item Naming Function
  
  =over 4
  
  =item C<add_defun(NAME, FUNC [,KEY=-1])>
  
  Add name to the Perl function C<FUNC>.  If optional argument C<KEY> is
  specified, bind it to the C<FUNC>.  Returns reference to
  C<FunctionPtr>.
  
    Example:
  	# name name `reverse-line' to a function reverse_line(),
  	# and bind it to "\C-t"
  	$term->add_defun('reverse-line', \&reverse_line, ord "\ct");
  
  =back
  
  =item Selecting a Keymap
  
  =over 4
  
  =item C<make_bare_keymap>
  
  	Keymap	rl_make_bare_keymap()
  
  =item C<copy_keymap(MAP)>
  
  	Keymap	rl_copy_keymap(Keymap|str map)
  
  =item C<make_keymap>
  
  	Keymap	rl_make_keymap()
  
  =item C<discard_keymap(MAP)>
  
  	Keymap	rl_discard_keymap(Keymap|str map)
  
  =item C<free_keymap(MAP)>
  
  	void	rl_free_keymap(Keymap|str map)
  
  =item C<get_keymap>
  
  	Keymap	rl_get_keymap()
  
  =item C<set_keymap(MAP)>
  
  	Keymap	rl_set_keymap(Keymap|str map)
  
  =item C<get_keymap_by_name(NAME)>
  
  	Keymap	rl_get_keymap_by_name(str name)
  
  =item C<get_keymap_name(MAP)>
  
  	str	rl_get_keymap_name(Keymap map)
  
  =back
  
  =item Binding Keys
  
  =over 4
  
  =item C<bind_key(KEY, FUNCTION [,MAP])>
  
  	int	rl_bind_key(int key, FunctionPtr|str function,
  			    Keymap|str map = rl_get_keymap())
  
  Bind C<KEY> to the C<FUNCTION>.  C<FUNCTION> is the name added by the
  C<add_defun> method.  If optional argument C<MAP> is specified, binds
  in C<MAP>.  Returns non-zero in case of error.
  
  =item C<bind_key_if_unbound(KEY, FUNCTION [,MAP])>
  
  	int	rl_bind_key_if_unbound(int key, FunctionPtr|str function,
  			    	       Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<unbind_key(KEY [,MAP])>
  
  	int	rl_unbind_key(int key, Keymap|str map = rl_get_keymap())
  
  Bind C<KEY> to the null function.  Returns non-zero in case of error.
  
  =item C<unbind_function(FUNCTION [,MAP])>
  
  	int	rl_unbind_function(FunctionPtr|str function,
  				   Keymap|str map = rl_get_keymap())
  
  =item C<unbind_command(COMMAND [,MAP])>
  
  	int	rl_unbind_command(str command,
  				  Keymap|str map = rl_get_keymap())
  
  =item C<bind_keyseq(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_bind_keyseq(str keyseq, FunctionPtr|str function,
  			       Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<set_key(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_set_key(str keyseq, FunctionPtr|str function,
  			   Keymap|str map = rl_get_keymap())	# GRL 4.2
  
  =item C<bind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])>
  
  	int	rl_bind_keyseq_if_unbound(str keyseq, FunctionPtr|str function,
  					  Keymap|str map = rl_get_keymap()) # GRL 5.0
  
  =item C<generic_bind(TYPE, KEYSEQ, DATA, [,MAP])>
  
  	int	rl_generic_bind(int type, str keyseq,
  				FunctionPtr|Keymap|str data,
  				Keymap|str map = rl_get_keymap())
  
  =item C<parse_and_bind(LINE)>
  
  	void	rl_parse_and_bind(str line)
  
  Parse C<LINE> as if it had been read from the F<~/.inputrc> file and
  perform any key bindings and variable assignments found.  For more
  detail see 'GNU Readline Library Manual'.
  
  =item C<read_init_file([FILENAME])>
  
  	int	rl_read_init_file(str filename = '~/.inputrc')
  
  =back
  
  =item Associating Function Names and Bindings
  
  =over 4
  
  =item C<named_function(NAME)>
  
  	FunctionPtr rl_named_function(str name)
  
  =item C<get_function_name(FUNCTION)>
  
  	str	rl_get_function_name(FunctionPtr function)	# TRG orignal
  
  =item C<function_of_keyseq(KEYMAP [,MAP])>
  
  	(FunctionPtr|Keymap|str data, int type)
  		rl_function_of_keyseq(str keyseq,
  				      Keymap|str map = rl_get_keymap())
  
  =item C<invoking_keyseqs(FUNCTION [,MAP])>
  
  	(@str)	rl_invoking_keyseqs(FunctionPtr|str function,
  				    Keymap|str map = rl_get_keymap())
  
  =item C<function_dumper([READABLE])>
  
  	void	rl_function_dumper(int readable = 0)
  
  =item C<list_funmap_names>
  
  	void	rl_list_funmap_names()
  
  =item C<funmap_names>
  
  	(@str)	rl_funmap_names()
  
  =item C<add_funmap_entry(NAME, FUNCTION)>
  
  	int	rl_add_funmap_entry(char *name, FunctionPtr|str function)
  
  =back
  
  =item Allowing Undoing
  
  =over 4
  
  =item C<begin_undo_group>
  
  	int	rl_begin_undo_group()
  
  =item C<end_undo_group>
  
  	int	rl_end_undo_group()
  
  =item C<add_undo(WHAT, START, END, TEXT)>
  
  	int	rl_add_undo(int what, int start, int end, str text)
  
  =item C<free_undo_list>
  
  	void	rl_free_undo_list()
  
  =item C<do_undo>
  
  	int	rl_do_undo()
  
  =item C<modifying([START [,END]])>
  
  	int	rl_modifying(int start = 0, int end = rl_end)
  
  =back
  
  =item Redisplay
  
  =over 4
  
  =item C<redisplay>
  
  	void	rl_redisplay()
  
  =item C<forced_update_display>
  
  	int	rl_forced_update_display()
  
  =item C<on_new_line>
  
  	int	rl_on_new_line()
  
  =item C<on_new_line_with_prompt>
  
  	int	rl_on_new_line_with_prompt()			# GRL 4.1
  
  =item C<reset_line_state>
  
  	int	rl_reset_line_state()
  
  =item C<crlf>
  
  	int	rl_crlf()
  
  =item C<rl_show_char(C)>
  
  	int	rl_show_char(int c)
  
  =item C<message(FMT[, ...])>
  
  	int	rl_message(str fmt, ...)
  
  =item C<clear_message>
  
  	int	rl_clear_message()
  
  =item C<save_prompt>
  
  	void	rl_save_prompt()
  
  =item C<restore_prompt>
  
  	void	rl_restore_prompt()
  
  =item C<expand_prompt(PROMPT)>
  
  	int	rl_expand_prompt(str prompt)
  
  =item C<set_prompt(PROMPT)>
  
  	int	rl_set_prompt(const str prompt)			# GRL 4.2
  
  =back
  
  =item Modifying Text
  
  =over 4
  
  =item C<insert_text(TEXT)>
  
  	int	rl_insert_text(str text)
  
  =item C<delete_text([START [,END]])>
  
  	int	rl_delete_text(int start = 0, int end = rl_end)
  
  =item C<copy_text([START [,END]])>
  
  	str	rl_copy_text(int start = 0, int end = rl_end)
  
  =item C<kill_text([START [,END]])>
  
  	int	rl_kill_text(int start = 0, int end = rl_end)
  
  =item C<push_macro_input(MACRO)>
  
  	int	rl_push_macro_input(str macro)
  
  =back
  
  =item Character Input
  
  =over 4
  
  =item C<read_key>
  
  	int	rl_read_key()
  
  =item C<getc(STREAM)>
  
  	int	rl_getc(FILE *STREAM)
  
  =item C<stuff_char(C)>
  
  	int	rl_stuff_char(int c)
  
  =item C<execute_next(C)>
  
  	int	rl_execute_next(int c)
  
  =item C<clear_pending_input()>
  
  	int	rl_clear_pending_input()			# GRL 4.2
  
  =item C<set_keyboard_input_timeout(uSEC)>
  
  	int	rl_set_keyboard_input_timeout(int usec)		# GRL 4.2
  
  =back
  
  =item Terminal Management
  
  =over 4
  
  =item C<prep_terminal(META_FLAG)>
  
  	void	rl_prep_terminal(int META_FLAG)
  
  =item C<deprep_terminal()>
  
  	void	rl_deprep_terminal()
  
  =item C<tty_set_default_bindings(KMAP)>
  
  	void	rl_tty_set_default_bindings([Keymap KMAP])	# GRL 4.0
  
  =item C<tty_unset_default_bindings(KMAP)>
  
  	void	rl_tty_unset_default_bindings([Keymap KMAP])	# GRL 5.0
  
  =item C<reset_terminal([TERMINAL_NAME])>
  
  	int	rl_reset_terminal(str terminal_name = getenv($TERM))
  
  =back
  
  =item Utility Functions
  
  =over 4
  
  =item C<save_state(READLINE_STATE)>
  
  	NOT IMPLEMENTED YET!
  	int	rl_save_state(struct readline_state *sp)	# GRL 6.0
  
  =item C<restore_state(READLINE_STATE)>
  
  	NOT IMPLEMENTED YET!
  	int	rl_restore_state(struct readline_state *sp)	# GRL 6.0
  
  =item C<free(MEM)>
  
  	Not implemented since not required for Perl.
  	int	rl_(void *mem)					# GRL 6.0
  
  =item C<replace_line(TEXT [,CLEAR_UNDO])>
  
  	int	rl_replace_line(str text, int clear_undo)	# GRL 4.3
  
  =item C<extend_line_buffer(LEN)>
  
  	Not implemented since not required for Perl.
  	int	rl_extend_line_buffer(int len)
  
  =item C<initialize>
  
  	int	rl_initialize()
  
  =item C<ding>
  
  	int	rl_ding()
  
  =item C<alphabetic(C)>
  
  	int	rl_alphabetic(int C)				# GRL 4.2
  
  =item C<display_match_list(MATCHES [,LEN [,MAX]])>
  
  	void	rl_display_match_list(\@matches, len = $#maches, max) # GRL 4.0
  
  Since the first element of an array @matches as treated as a possible
  completion, it is not displayed.  See the descriptions of
  C<completion_matches()>.
  
  When C<MAX> is ommited, the max length of an item in @matches is used.
  
  =back
  
  =item Miscellaneous Functions
  
  =over 4
  
  =item C<macro_bind(KEYSEQ, MACRO [,MAP])>
  
  	int	rl_macro_bind(const str keyseq, const str macro, Keymap map)
  
  =item C<macro_dumper(READABLE)>
  
  	int	rl_macro_dumper(int readline)
  
  =item C<variable_bind(VARIABLE, VALUE)>
  
  	int	rl_variable_bind(const str variable, const str value)
  
  =item C<variable_value(VARIABLE)>
  
  	str	rl_variable_value(const str variable)		# GRL 5.1
  
  =item C<variable_dumper(READABLE)>
  
  	int	rl_variable_dumper(int readline)
  
  =item C<set_paren_blink_timeout(uSEC)>
  
  	int	rl_set_paren_blink_timeout(usec)		# GRL 4.2
  
  =item C<get_termcap(cap)>
  
  	str	rl_get_termcap(cap)
  
  =item C<clear_history>
  
      void	rl_clear_history()				# GRL 6.3
  
  =back
  
  =item Alternate Interface
  
  =over 4
  
  =item C<callback_handler_install(PROMPT, LHANDLER)>
  
  	void	rl_callback_handler_install(str prompt, pfunc lhandler)
  
  =item C<callback_read_char>
  
  	void	rl_callback_read_char()
  
  =item C<callback_handler_remove>
  
  	void	rl_callback_handler_remove()
  
  =back
  
  =back
  
  =item Readline Signal Handling
  
  =over 4
  
  =item C<cleanup_after_signal>
  
  	void	rl_cleanup_after_signal()			# GRL 4.0
  
  =item C<free_line_state>
  
  	void	rl_free_line_state()				# GRL 4.0
  
  =item C<reset_after_signal>
  
  	void	rl_reset_after_signal()				# GRL 4.0
  
  =item C<echo_signal_char>
  
  	void	rl_echo_signal_char(int sig)			# GRL 6.0
  
  =item C<resize_terminal>
  
  	void	rl_resize_terminal()				# GRL 4.0
  
  =item C<set_screen_size(ROWS, COLS)>
  
  	void	rl_set_screen_size(int ROWS, int COLS)		# GRL 4.2
  
  =item C<get_screen_size()>
  
  	(int rows, int cols)	rl_get_screen_size()		# GRL 4.2
  
  =item C<reset_screen_size()>
  
  	void	rl_reset_screen_size()				# GRL 5.1
  
  =item C<set_signals>
  
  	int	rl_set_signals()				# GRL 4.0
  
  =item C<clear_signals>
  
  	int	rl_clear_signals()				# GRL 4.0
  
  =back
  
  =item Completion Functions
  
  =over 4
  
  =item C<complete_internal([WHAT_TO_DO])>
  
  	int	rl_complete_internal(int what_to_do = TAB)
  
  =item C<completion_mode(FUNCTION)>
  
  	int	rl_completion_mode(FunctionPtr|str function)	# GRL 4.3
  
  =item C<completion_matches(TEXT [,FUNC])>
  
  	(@str)	rl_completion_matches(str text,
  				      pfunc func = filename_completion_function)
  
  =item C<filename_completion_function(TEXT, STATE)>
  
  	str	rl_filename_completion_function(str text, int state)
  
  =item C<username_completion_function(TEXT, STATE)>
  
  	str	rl_username_completion_function(str text, int state)
  
  =item C<list_completion_function(TEXT, STATE)>
  
  	str	list_completion_function(str text, int state)	# TRG original
  
  =back
  
  =item History Functions
  
  =over 4
  
  =item Initializing History and State Management
  
  =over 4
  
  =item C<using_history>
  
  	void	using_history()
  
  =item C<history_get_history_state>
  
  	NOT IMPLEMENTED YET!
  	HISTORY_STATE	*history_get_hitory_state()		# GRL 6.3
  
  =item C<history_set_history_state>
  
  	NOT IMPLEMENTED YET!
  	void	*history_set_hitory_state(HISTORY_STATE *state)	# GRL 6.3
  
  =back
  
  =item History List Management
  
  =over 4
  
  =item C<addhistory(STRING[, STRING, ...])>
  
  	void	add_history(str string)
  
  =item C<add_history_time(STRING)>
  
  	void	add_history_time(str string)			# GRL 5.0
  
  =item C<remove_history(WHICH)>
  
  	str	remove_history(int which)
  
  =item C<free_history(HISTENT)>
  
  	Not implemented since Term::ReadLine::Gnu does not support the
  	member 'data' of HIST_ENTRY structure, remove_history() covers it.
  	histdata_t	free_history_entry(HIST_ENTRY *histent)	# GRL 5.0
  
  =item C<replace_history_entry(WHICH, LINE)>
  
  	str	replace_history_entry(int which, str line)
  
  =item C<clear_history>
  
  	void	clear_history()
  
  =item C<StifleHistory(MAX)>
  
  	int	stifle_history(int max|undef)
  
  stifles the history list, remembering only the last C<MAX> entries.
  If C<MAX> is undef, remembers all entries.  This is a replacement
  of unstifle_history().
  
  =item C<unstifle_history>
  
  	int	unstifle_history()
  
  This is equivalent with 'stifle_history(undef)'.
  
  =item C<SetHistory(LINE1 [, LINE2, ...])>
  
  sets the history of input, from where it can be used if the actual
  C<readline> is present.
  
  =item C<history_is_stifled>
  
  	int	history_is_stifled()
  
  =back
  
  =item Information About the History List
  
  =over 4
  
  =item C<history_list>
  
  	Not implemented since not required for Perl.
  	HIST_ENTRY **history_list()
  
  =item C<where_history>
  
  	int	where_history()
  
  =item C<current_history>
  
  	str	current_history()
  
  =item C<history_get(OFFSET)>
  
  	str	history_get(offset)
  
  =item C<history_get_time(OFFSET)
  
  	time_t	history_get_time(offset)			# GRL 5.0
  
  =item C<history_total_bytes>
  
  	int	history_total_bytes()
  
  =item C<GetHistory>
  
  returns the history of input as a list, if actual C<readline> is present.
  
  =back
  
  =item Moving Around the History List
  
  =over 4
  
  =item C<history_set_pos(POS)>
  
  	int	history_set_pos(int pos)
  
  =item C<previous_history>
  
  	str	previous_history()
  
  =item C<next_history>
  
  	str	next_history()
  
  =back
  
  =item Searching the History List
  
  =over 4
  
  =item C<history_search(STRING [,DIRECTION])>
  
  	int	history_search(str string, int direction = -1)
  
  =item C<history_search_prefix(STRING [,DIRECTION])>
  
  	int	history_search_prefix(str string, int direction = -1)
  
  =item C<history_search_pos(STRING [,DIRECTION [,POS]])>
  
  	int	history_search_pos(str string,
  				   int direction = -1,
  				   int pos = where_history())
  
  =back
  
  =item Managing the History File
  
  =over 4
  
  =item C<ReadHistory([FILENAME [,FROM [,TO]]])>
  
  	int	read_history(str filename = '~/.history',
  			     int from = 0, int to = -1)
  
  	int	read_history_range(str filename = '~/.history',
  				   int from = 0, int to = -1)
  
  adds the contents of C<FILENAME> to the history list, a line at a
  time.  If C<FILENAME> is false, then read from F<~/.history>.  Start
  reading at line C<FROM> and end at C<TO>.  If C<FROM> is omitted or
  zero, start at the beginning.  If C<TO> is omitted or less than
  C<FROM>, then read until the end of the file.  Returns true if
  successful, or false if not.  C<read_history()> is an aliase of
  C<read_history_range()>.
  
  =item C<WriteHistory([FILENAME])>
  
  	int	write_history(str filename = '~/.history')
  
  writes the current history to C<FILENAME>, overwriting C<FILENAME> if
  necessary.  If C<FILENAME> is false, then write the history list to
  F<~/.history>.  Returns true if successful, or false if not.
  
  
  =item C<append_history(NELEMENTS [,FILENAME])>
  
  	int	append_history(int nelements, str filename = '~/.history')
  
  =item C<history_truncate_file([FILENAME [,NLINES]])>
  
  	int	history_truncate_file(str filename = '~/.history',
  				      int nlines = 0)
  
  =back
  
  =item History Expansion
  
  =over 4
  
  =item C<history_expand(LINE)>
  
  	(int result, str expansion) history_expand(str line)
  
  Note that this function returns C<expansion> in scalar context.
  
  =item C<get_history_event(STRING, CINDEX [,QCHAR])>
  
  	(str text, int cindex) = get_history_event(str  string,
  						   int  cindex,
  						   char qchar = '\0')
  
  =item C<history_tokenize(LINE)>
  
  	(@str)	history_tokenize(str line)
  
  =item C<history_arg_extract(LINE, [FIRST [,LAST]])>
  
  	str history_arg_extract(str line, int first = 0, int last = '$')
  
  =back
  
  =back
  
  =back
  
  =head2 C<Term::ReadLine::Gnu> Variables
  
  Following GNU Readline/History Library variables can be accessed by a
  Perl program.  See 'GNU Readline Library Manual' and 'GNU History
  Library Manual' for details of each variable.  You can access them with
  C<Attribs> methods.  Names of keys in this hash conform to standard
  conventions with the leading C<rl_> stripped.
  
  Examples:
  
      $attribs = $term->Attribs;
      $v = $attribs->{library_version};	# rl_library_version
      $v = $attribs->{history_base};	# history_base
  
  =over 4
  
  =item Readline Variables
  
  	str rl_line_buffer
  	int rl_point
  	int rl_end
  	int rl_mark
  	int rl_done
  	int rl_num_chars_to_read (GRL 4.1)
  	int rl_pending_input
  	int rl_dispatching
  	int rl_erase_empty_line (GRL 4.0)
  	str rl_prompt (read only)
  	str rl_display_prompt
  	int rl_already_prompted (GRL 4.1)
  	str rl_library_version (read only)
  	int rl_readline_version (read only)
  	int rl_gnu_readline_p (GRL 4.1, read only)
  	str rl_terminal_name
  	str rl_readline_name
  	filehandle rl_instream
  	filehandle rl_outstream
  	int rl_prefer_env_winsize (GRL 5.1)
  	pfunc rl_last_func (GRL 4.2, read only)
  	pfunc rl_startup_hook
  	pfunc rl_pre_input_hook (GRL 4.0)
  	pfunc rl_event_hook
  	pfunc rl_getc_function
  	pfunc rl_signal_event_hook (GRL 6.3)
  	pfunc rl_input_available_hook (GRL 6.3)
  	pfunc rl_redisplay_function
  	pfunc rl_prep_term_function (GRL 2.1)
  	pfunc rl_deprep_term_function (GRL 2.1)
  	Keymap rl_executing_keymap (read only)
  	Keymap rl_binding_keymap (read only)
  	str rl_executing_macro (GRL 4.2, read only)
  	int rl_executing_key (GRL 6.3, read only)
  	str rl_executing_keyseq (GRL 6.3, read only)
  	int rl_key_sequence_length (read only)
  	int rl_readline_state (GRL 4.2, read only)
  	int rl_explicit_arg (read only)
  	int rl_numeric_arg (read only)
  	int rl_editing_mode (read only)
  
  =item Signal Handling Variables
  
  	int rl_catch_signals (GRL 4.0)
  	int rl_catch_sigwinch (GRL 4.0)
  	int rl_change_environment (GRL 6.3)
  
  =item Completion Variables
  
  	pfunc rl_completion_entry_function
  	pfunc rl_attempted_completion_function
  	pfunc rl_filename_quoting_function
  	pfunc rl_filename_dequoting_function
  	pfunc rl_char_is_quoted_p
  	pfunc rl_ignore_some_completions_function
  	pfunc rl_directory_completion_hook
  	pfunc rl_directory_rewrite_hook (GRL 4.2)
  	pfunc rl_filename_stat_hook (GRL 6.3)
  	pfunc rl_filename_rewrite_hook (GRL 6.1)
  	pfunc rl_completion_display_matches_hook (GRL 4.0)
  	str rl_basic_word_break_characters
  	str rl_basic_quote_characters
  	str rl_completer_word_break_characters
  	pfunc rl_completion_word_break_hook (GRL 5.0)
  	str rl_completer_quote_characters
  	str rl_filename_quote_characters
  	str rl_special_prefixes
  	int rl_completion_query_items
  	int rl_completion_append_character
  	int rl_completion_suppress_append (GRL 4.3)
  	int rl_completion_quote_character (GRL 5.0)
  	int rl_completion_suppress_quote (GRL 5.0)
  	int rl_completion_found_quote (GRL 5.0)
  	int rl_completion_mark_symlink_dirs (GRL 4.3)
  	int rl_ignore_completion_duplicates
  	int rl_filename_completion_desired
  	int rl_filename_quoting_desired
  	int rl_attempted_completion_over
  	int rl_sort_completion_matches (GRL 6.0)
  	int rl_completion_type (read only)
  	int rl_completion_invoking_key (GRL 6.0, read only)
  	int rl_inhibit_completion
  
  =item History Variables
  
  	int history_base (read only)
  	int history_length (read only)
  	int history_max_entries (called `max_input_history', read only)
  	int history_write_timestamps (GRL 5.0)
  	char history_expansion_char
  	char history_subst_char
  	char history_comment_char
  	str history_word_delimiters (GRL 4.2)
  	str history_search_delimiter_chars
  	str history_no_expand_chars
  	int history_quotes_inhibit_expansion
  	pfunc history_inhibit_expansion_function
  
  =item Function References
  
  	rl_getc
  	rl_redisplay
  	rl_callback_read_char
  	rl_display_match_list
  	rl_filename_completion_function
  	rl_username_completion_function
  	list_completion_function
  	shadow_redisplay
  	Tk_getc
  
  =back
  
  =head2 Custom Completion
  
  In this section variables and functions for custom completion is
  described with examples.
  
  Most of descriptions in this section is cited from GNU Readline
  Library manual.
  
  =over 4
  
  =item C<rl_completion_entry_function>
  
  This variable holds reference refers to a generator function for
  C<completion_matches()>.
  
  A generator function is called repeatedly from
  C<completion_matches()>, returning a string each time.  The arguments
  to the generator function are C<TEXT> and C<STATE>.  C<TEXT> is the
  partial word to be completed.  C<STATE> is zero the first time the
  function is called, allowing the generator to perform any necessary
  initialization, and a positive non-zero integer for each subsequent
  call.  When the generator function returns C<undef> this signals
  C<completion_matches()> that there are no more possibilities left.
  
  If the value is undef, built-in C<filename_completion_function> is
  used.
  
  A sample generator function, C<list_completion_function>, is defined
  in Gnu.pm.  You can use it as follows;
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      $attribs->{completion_entry_function} =
  	$attribs->{list_completion_function};
      ...
      $attribs->{completion_word} =
  	[qw(reference to a list of words which you want to use for completion)];
      $term->readline("custom completion>");
  
  See also C<completion_matches>.
  
  =item C<rl_attempted_completion_function>
  
  A reference to an alternative function to create matches.
  
  The function is called with C<TEXT>, C<LINE_BUFFER>, C<START>, and
  C<END>.  C<LINE_BUFFER> is a current input buffer string.  C<START>
  and C<END> are indices in C<LINE_BUFFER> saying what the boundaries of
  C<TEXT> are.
  
  If this function exists and returns null list or C<undef>, or if this
  variable is set to C<undef>, then an internal function
  C<rl_complete()> will call the value of
  C<$rl_completion_entry_function> to generate matches, otherwise the
  array of strings returned will be used.
  
  The default value of this variable is C<undef>.  You can use it as follows;
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      sub sample_completion {
          my ($text, $line, $start, $end) = @_;
          # If first word then username completion, else filename completion
          if (substr($line, 0, $start) =~ /^\s*$/) {
      	    return $term->completion_matches($text,
  					     $attribs->{'username_completion_function'});
          } else {
      	    return ();
          }
      }
      ...
      $attribs->{attempted_completion_function} = \&sample_completion;
  
  =item C<completion_matches(TEXT, ENTRY_FUNC)>
  
  Returns an array of strings which is a list of completions for
  C<TEXT>.  If there are no completions, returns C<undef>.  The first
  entry in the returned array is the substitution for C<TEXT>.  The
  remaining entries are the possible completions.
  
  C<ENTRY_FUNC> is a generator function which has two arguments, and
  returns a string.  The first argument is C<TEXT>.  The second is a
  state argument; it is zero on the first call, and non-zero on
  subsequent calls.  C<ENTRY_FUNC> returns a C<undef> to the caller when
  there are no more matches.
  
  If the value of C<ENTRY_FUNC> is undef, built-in
  C<filename_completion_function> is used.
  
  C<completion_matches> is a Perl wrapper function of an internal
  function C<completion_matches()>.  See also
  C<$rl_completion_entry_function>.
  
  =item C<completion_function>
  
  A variable whose content is a reference to a function which returns a
  list of candidates to complete.
  
  This variable is compatible with C<Term::ReadLine::Perl> and very easy
  to use.
  
      use Term::ReadLine;
      ...
      my $term = new Term::ReadLine 'sample';
      my $attribs = $term->Attribs;
      ...
      $attribs->{completion_function} = sub {
  	my ($text, $line, $start) = @_;
  	return qw(a list of candidates to complete);
      }
  
  =item C<list_completion_function(TEXT, STATE)>
  
  A sample generator function defined by C<Term::ReadLine::Gnu>.
  Example code at C<rl_completion_entry_function> shows how to use this
  function.
  
  =back
  
  =head2 C<Term::ReadLine::Gnu> Specific Features
  
  =over 4
  
  =item C<Term::ReadLine::Gnu> Specific Functions
  
  =over 4
  
  =item C<CallbackHandlerInstall(PROMPT, LHANDLER)>
  
  This method provides the function C<rl_callback_handler_install()>
  with the following addtional feature compatible with C<readline>
  method; ornament feature, C<Term::ReadLine::Perl> compatible
  completion function, histroy expansion, and addition to history
  buffer.
  
  =item C<call_function(FUNCTION, [COUNT [,KEY]])>
  
  	int	rl_call_function(FunctionPtr|str function, count = 1, key = -1)
  
  =item C<rl_get_all_function_names>
  
  Returns a list of all function names.
  
  =item C<shadow_redisplay>
  
  A redisplay function for password input.  You can use it as follows;
  
  	$attribs->{redisplay_function} = $attribs->{shadow_redisplay};
  	$line = $term->readline("password> ");
  
  =item C<rl_filename_list>
  
  Returns candidates of filename to complete.  This function can be used
  with C<completion_function> and is implemented for the compatibility
  with C<Term::ReadLine::Perl>.
  
  =item C<list_completion_function>
  
  See the description of section L<"Custom Completion"|"Custom Completion">.
  
  =back
  
  =item C<Term::ReadLine::Gnu> Specific Variables
  
  =over 4
  
  =item C<do_expand>
  
  When true, the history expansion is enabled.  By default false.
  
  =item C<completion_function>
  
  See the description of section L<"Custom Completion"|"Custom Completion">.
  
  =item C<completion_word>
  
  A reference to a list of candidates to complete for
  C<list_completion_function>.
  
  =back
  
  =item C<Term::ReadLine::Gnu> Specific Commands
  
  =over 4
  
  =item C<history-expand-line>
  
  The equivalent of the Bash C<history-expand-line> editing command.
  
  =item C<operate-and-get-next>
  
  The equivalent of the Korn shell C<operate-and-get-next-history-line>
  editing command and the Bash C<operate-and-get-next>.
  
  This command is bound to C<\C-o> by default for the compatibility with
  the Bash and C<Term::ReadLine::Perl>.
  
  =item C<display-readline-version>
  
  Shows the version of C<Term::ReadLine::Gnu> and the one of the GNU
  Readline Library.
  
  =item C<change-ornaments>
  
  Change ornaments interactively.
  
  =back
  
  =back
  
  =head1 FILES
  
  =over 4
  
  =item F<~/.inputrc>
  
  Readline init file.  Using this file it is possible that you would
  like to use a different set of key bindings.  When a program which
  uses the Readline library starts up, the init file is read, and the
  key bindings are set.
  
  Conditional key binding is also available.  The program name which is
  specified by the first argument of C<new> method is used as the
  application construct.
  
  For example, when your program call C<new> method like this;
  
  	...
  	$term = new Term::ReadLine 'PerlSh';
  	...
  
  your F<~/.inputrc> can define key bindings only for it as follows;
  
  	...
  	$if PerlSh
  	Meta-Rubout: backward-kill-word
  	"\C-x\C-r": re-read-init-file
          "\e[11~": "Function Key 1"
  	$endif
  	...
  
  =back
  
  =head1 EXPORTS
  
  None.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item Term::ReadLine::Gnu Project Home Page
  
  	http://sourceforge.net/projects/perl-trg/
  
  =item GNU Readline Library Manual
  
  =item GNU History Library Manual
  
  =item C<Term::ReadLine>
  
  =item C<Term::ReadLine::Perl> (Term-ReadLine-Perl-xx.tar.gz)
  
  =item F<eg/*> and F<t/*> in the Term::ReadLine::Gnu distribution
  
  =item Works which use Term::ReadLine::Gnu
  
  =over 4
  
  =item Perl Debugger
  
  	perl -d
  
  =item Perl Shell (psh)
  
  	http://gnp.github.io/psh/
  
  The Perl Shell is a shell that combines the interactive nature of a
  Unix shell with the power of Perl.
  
  A programmable completion feature compatible with bash is implemented.
  
  =item SPP (Synopsys Plus Perl)
  
  	http://vlsiweb.stanford.edu/~jsolomon/SPP/
  
  SPP (Synopsys Plus Perl) is a Perl module that wraps around Synopsys'
  shell programs.  SPP is inspired by the original dc_perl written by
  Steve Golson, but it's an entirely new implementation.  Why is it
  called SPP and not dc_perl?  Well, SPP was written to wrap around any
  of Synopsys' shells.
  
  =item PFM (Personal File Manager for Unix/Linux)
  
  	http://p-f-m.sourceforge.net/
  
  Pfm is a terminal-based file manager written in Perl, based on PFM.COM
  for MS-DOS (originally by Paul Culley and Henk de Heer).
  
  =item The soundgrab
  
  	http://brittonkerin.com/soundgrab/soundgrab.html
  
  soundgrab is designed to help you slice up a big long raw audio file
  (by default 44.1 kHz 2 channel signed sixteen bit little endian) and
  save your favorite sections to other files. It does this by providing
  you with a cassette player like command line interface.
  
  =item PDL (The Perl Data Language)
  
  	http://pdl.perl.org/
  
  PDL (``Perl Data Language'') gives standard Perl the ability to
  compactly store and speedily manipulate the large N-dimensional data
  arrays which are the bread and butter of scientific computing.
  
  =item PIQT (Perl Interactive DBI Query Tool)
  
  	http://piqt.sourceforge.net/
  
  PIQT is an interactive query tool using the Perl DBI database
  interface. It supports ReadLine, provides a built in scripting language
  with a Lisp like syntax, an online help system, and uses wrappers to
  interface to the DBD modules.
  
  =item vshnu (the New Visual Shell)
  
  	http://www.cs.indiana.edu/~kinzler/vshnu/
  
  A visual shell and CLI shell supplement.
  
  =item Distributions which depend on Term::ReadLine::Gnu on CPAN
  
  	https://metacpan.org/requires/distribution/Term-ReadLine-Gnu
  
  =back
  
  If you know any other works which can be listed here, please let me
  know.
  
  =back
  
  =head1 AUTHOR
  
  Hiroo Hayashi C<E<lt>hiroo.hayashi@computer.orgE<gt>>
  
  C<http://www.perl.org/CPAN/authors/Hiroo_HAYASHI/>
  
  =head1 TODO
  
  GTK+ support in addition to Tk.
  
  =head1 BUGS
  
  C<rl_add_defun()> can define up to 16 functions.
  
  Ornament feature works only on prompt strings.  It requires very hard
  hacking of C<display.c:rl_redisplay()> in GNU Readline library to
  ornament input line.
  
  Some readline function and variable are not tested yet.  Your
  contribution is welcome.  See C<t/readline.t>XS for details.
  
  =cut
X86_64-LINUX-THREAD-MULTI_TERM_READLINE_GNU

$fatpacked{"x86_64-linux-thread-multi/Term/ReadLine/Gnu/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TERM_READLINE_GNU_XS';
  #!/usr/local/bin/perl
  #
  #	XS.pm : perl function definition for Term::ReadLine::Gnu
  #
  #	$Id: XS.pm 438 2014-02-03 14:40:47Z hayashi $
  #
  #	Copyright (c) 2008 Hiroo Hayashi.  All rights reserved.
  #
  #	This program is free software; you can redistribute it and/or
  #	modify it under the same terms as Perl itself.
  
  package Term::ReadLine::Gnu::XS;
  
  use Carp;
  use strict;
  use AutoLoader 'AUTOLOAD';
  
  use vars qw($VERSION);
  $VERSION='1.17';	# added for CPAN
  
  # make aliases
  use vars qw(%Attribs);
  *Attribs = \%Term::ReadLine::Gnu::Attribs;
  
  use vars qw(*read_history);
  *read_history = \&read_history_range;
  
  # alias for 8 characters limitation imposed by AutoSplit
  use vars qw(*rl_unbind_key *rl_unbind_function *rl_unbind_command
  	    *history_list *history_arg_extract);
  *rl_unbind_key = \&unbind_key;
  *rl_unbind_function = \&unbind_function;
  *rl_unbind_command = \&unbind_command;
  *history_list = \&hist_list;
  *history_arg_extract = \&hist_arg_extract;
  
  # For backward compatibility.  Using these name (*_in_map) is deprecated.
  use vars qw(*rl_unbind_function_in_map *rl_unbind_command_in_map);
  *rl_unbind_function_in_map = \&unbind_function;
  *rl_unbind_command_in_map  = \&unbind_command;
  
  rl_add_defun('history-expand-line',	 \&history_expand_line);
  # bind operate-and-get-next to \C-o by default for the compatibility
  # with bash and Term::ReadLine::Perl
  rl_add_defun('operate-and-get-next',	 \&operate_and_get_next, ord "\co");
  rl_add_defun('display-readline-version', \&display_readline_version);
  rl_add_defun('change-ornaments',	 \&change_ornaments);
  
  # for ornaments()
  
  # Prompt-start, prompt-end, command-line-start, command-line-end
  #     -- zero-width beautifies to emit around prompt and the command line.
  # string encoded:
  my $rl_term_set = ',,,';
  
  # These variables are used by completion functions.  Don't use for
  # other purpose.
  my $_i;
  my @_matches;
  my @_tstrs;
  my $_tstrs_init = 0;
  
  1;
  
  # Uncomment the following line to enable AutoSplit.  If you are using
  # AutoLoader.pm distributed with Perl 5.004 or earlier, you must
  # update AutoLoader.pm due to its bug.
  
  #__END__
  
  
  #
  #	Readline Library function wrappers
  #
  
  # Convert keymap name to Keymap if the argument is not reference to Keymap
  sub _str2map ($) {
      return ref $_[0] ? $_[0]
  	: (rl_get_keymap_by_name($_[0]) || carp "unknown keymap name \`$_[0]\'\n");
  }
  
  # Convert function name to Function if the argument is not reference
  # to Function
  sub _str2fn ($) {
      return ref $_[0] ? $_[0]
  	: (rl_named_function($_[0]) || carp "unknown function name \`$_[0]\'\n");
  }
  
  sub rl_copy_keymap ($)    { return _rl_copy_keymap(_str2map($_[0])); }
  sub rl_discard_keymap ($) { return _rl_discard_keymap(_str2map($_[0])); }
  sub rl_set_keymap ($)     { return _rl_set_keymap(_str2map($_[0])); }
  
  # rl_bind_key
  sub rl_bind_key ($$;$) {
      if (defined $_[2]) {
  	return _rl_bind_key($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_key($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_bind_key_if_unbound
  sub rl_bind_key_if_unbound ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_key_if_unbound() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_key_if_unbound($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_key_if_unbound($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_unbind_key
  sub unbind_key ($;$) {
      if (defined $_[1]) {
  	return _rl_unbind_key($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_key($_[0]);
      }
  }
  
  # rl_unbind_function
  sub unbind_function ($;$) {
      # libreadline.* in Debian GNU/Linux 2.0 tells wrong value as '2.1-bash'
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 2.2) {
  	carp "rl_unbind_function() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[1]) {
  	return _rl_unbind_function($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_function($_[0]);
      }
  }
  
  # rl_unbind_command
  sub unbind_command ($;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 2.2) {
  	carp "rl_unbind_command() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[1]) {
  	return _rl_unbind_command($_[0], _str2map($_[1]));
      } else {
  	return _rl_unbind_command($_[0]);
      }
  }
  
  # rl_bind_keyseq
  sub rl_bind_keyseq ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_keyseq() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_keyseq($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_keyseq($_[0], _str2fn($_[1]));
      }
  }
  
  sub rl_set_key ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_set_key() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_set_key($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_set_key($_[0], _str2fn($_[1]));
      }
  }
  
  # rl_bind_keyseq_if_unbound
  sub rl_bind_keyseq_if_unbound ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_bind_keyseq_if_unbound() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[2]) {
  	return _rl_bind_keyseq_if_unbound($_[0], _str2fn($_[1]), _str2map($_[2]));
      } else {
  	return _rl_bind_keyseq_if_unbound($_[0], _str2fn($_[1]));
      }
  }
  
  sub rl_macro_bind ($$;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if (defined $_[2]) {
  	return _rl_macro_bind($_[0], $_[1], _str2map($_[2]));
      } else {
  	return _rl_macro_bind($_[0], $_[1]);
      }
  }
  
  sub rl_generic_bind ($$$;$) {
      if      ($_[0] == Term::ReadLine::Gnu::ISFUNC) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_function($_[1], _str2fn($_[2]), _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_function($_[1], _str2fn($_[2]));
  	}
      } elsif ($_[0] == Term::ReadLine::Gnu::ISKMAP) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_keymap($_[1], _str2map($_[2]), _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_keymap($_[1], _str2map($_[2]));
  	}
      } elsif ($_[0] == Term::ReadLine::Gnu::ISMACR) {
  	if (defined $_[3]) {
  	    _rl_generic_bind_macro($_[1], $_[2], _str2map($_[3]));
  	} else {
  	    _rl_generic_bind_macro($_[1], $_[2]);
  	}
      } else {
  	carp("Term::ReadLine::Gnu::rl_generic_bind: invalid \`type\'\n");
      }
  }
  
  sub rl_call_function ($;$$) {
      if (defined $_[2]) {
  	return _rl_call_function(_str2fn($_[0]), $_[1], $_[2]);
      } elsif (defined $_[1]) {
  	return _rl_call_function(_str2fn($_[0]), $_[1]);
      } else {
  	return _rl_call_function(_str2fn($_[0]));
      }
  }
  
  sub rl_invoking_keyseqs ($;$) {
      if (defined $_[1]) {
  	return _rl_invoking_keyseqs(_str2fn($_[0]), _str2map($_[1]));
      } else {
  	return _rl_invoking_keyseqs(_str2fn($_[0]));
      }
  }
  
  sub rl_add_funmap_entry ($$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_add_funmap_entry() is not supported.  Ignored\n";
  	return;
      }
      return _rl_add_funmap_entry($_[0], _str2fn($_[1]));
  }
  
  sub rl_tty_set_default_bindings (;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.2) {
  	carp "rl_tty_set_default_bindings() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[0]) {
  	return _rl_tty_set_defaut_bindings(_str2map($_[1]));
      } else {
  	return _rl_tty_set_defaut_bindings();
      }
  }
  
  sub rl_tty_unset_default_bindings (;$) {
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 5.0) {
  	carp "rl_tty_unset_default_bindings() is not supported.  Ignored\n";
  	return;
      }
      if (defined $_[0]) {
  	return _rl_tty_unset_defaut_bindings(_str2map($_[1]));
      } else {
  	return _rl_tty_unset_defaut_bindings();
      }
  }
  
  sub rl_message {
      my $fmt = shift;
      my $line = sprintf($fmt, @_);
      _rl_message($line);
  }
  
  sub rl_completion_mode {
      # libreadline.* in Debian GNU/Linux 2.0 tells wrong value as '2.1-bash'
      my ($version) = $Attribs{library_version}
  	=~ /(\d+\.\d+)/;
      if ($version < 4.3) {
  	carp "rl_completion_mode() is not supported.  Ignored\n";
  	return;
      }
      return _rl_completion_mode(_str2fn($_[0]));
  }
  
  #
  #	for compatibility with Term::ReadLine::Perl
  #
  sub rl_filename_list {
      my ($text) = @_;
  
      # lcd : lowest common denominator
      my ($lcd, @matches) = rl_completion_matches($text,
  						\&rl_filename_completion_function);
      return @matches ? @matches : $lcd;
  }
  
  #
  #	History Library function wrappers
  #
  # history_list
  sub hist_list () {
      my ($i, $history_base, $history_length, @d);
      $history_base   = $Attribs{history_base};
      $history_length = $Attribs{history_length};
      for ($i = $history_base; $i < $history_base + $history_length; $i++) {
  	push(@d, history_get($i));
      }
      @d;
  }
  
  # history_arg_extract
  sub hist_arg_extract ( ;$$$ ) {
      my ($line, $first, $last) = @_;
      $line  = $_      unless defined $line;
      $first = 0       unless defined $first;
      $last  = ord '$' unless defined $last; # '
      $first = ord '$' if defined $first and $first eq '$'; # '
      $last  = ord '$' if defined $last  and $last  eq '$'; # '
      &_history_arg_extract($line, $first, $last);
  }
  
  sub get_history_event ( $$;$ ) {
      _get_history_event($_[0], $_[1], defined $_[2] ? ord $_[2] : 0);
  }
  
  #
  #	Ornaments
  #
  
  # This routine originates in Term::ReadLine.pm.
  
  # Debian GNU/Linux discourages users from using /etc/termcap.  A
  # subroutine ornaments() defined in Term::ReadLine.pm uses
  # Term::Caps.pm which requires /etc/termcap.
  
  # This module calls termcap (or its compatible) library, which the GNU
  # Readline Library already uses, instead of Term::Caps.pm.
  
  # Some terminals do not support 'ue' (underline end).
  use vars qw(%term_no_ue);
  %term_no_ue = ( kterm => 1 );
  
  sub ornaments {
      return $rl_term_set unless @_;
      $rl_term_set = shift;
      $rl_term_set ||= ',,,';
      $rl_term_set = $term_no_ue{$ENV{TERM}} ? 'us,me,,' : 'us,ue,,'
  	if $rl_term_set eq '1';
      my @ts = split /,/, $rl_term_set, 4;
      my @rl_term_set
  	= map {
  	    # non-printing characters must be informed to readline
  	    my $t;
  	    ($_ and $t = tgetstr($_))
  		? (Term::ReadLine::Gnu::RL_PROMPT_START_IGNORE
  		   . $t
  		   . Term::ReadLine::Gnu::RL_PROMPT_END_IGNORE)
  		    : '';
  	} @ts;
      $Attribs{term_set} = \@rl_term_set;
      return $rl_term_set;
  }
  
  #
  #	a sample custom function
  #
  
  # The equivalent of the Bash shell M-^ history-expand-line editing
  # command.
  
  # This routine was borrowed from bash.
  sub history_expand_line {
      my ($count, $key) = @_;
      my ($expanded, $new_line) = history_expand($Attribs{line_buffer});
      if ($expanded > 0) {
    	rl_modifying(0, $Attribs{end}); # save undo information
    	$Attribs{line_buffer} = $new_line;
      } elsif ($expanded < 0) {
    	my $OUT = $Attribs{outstream};
    	print $OUT "\n$new_line\n";
    	rl_on_new_line();
      }				# $expanded == 0 : no change
  }
  
  # The equivalent of the Korn shell C-o operate-and-get-next-history-line
  # editing command. 
  
  # This routine was borrowed from bash.
  sub operate_and_get_next {
      my ($count, $key) = @_;
  
      my $saved_history_line_to_use = -1;
      my $old_rl_startup_hook;
  
      # Accept the current line.
      rl_call_function('accept-line', 1, $key);
  
      # Find the current line, and find the next line to use. */
      my $where = where_history();
      if ((history_is_stifled()
  	 && ($Attribs{history_length} >= $Attribs{max_input_history}))
  	|| ($where >= $Attribs{history_length} - 1)) {
  	$saved_history_line_to_use = $where;
      } else {
  	$saved_history_line_to_use = $where + 1;
      }
      $old_rl_startup_hook = $Attribs{startup_hook};
      $Attribs{startup_hook} = sub {
  	if ($saved_history_line_to_use >= 0) {
  	    rl_call_function('previous-history',
  			     $Attribs{history_length}
  			     - $saved_history_line_to_use,
  			     0);
  	    $Attribs{startup_hook} = $old_rl_startup_hook;
  	    $saved_history_line_to_use = -1;
  	}
      };
  }
  
  sub display_readline_version {	# show version
      my($count, $key) = @_;	# ignored in this function
      my $OUT = $Attribs{outstream};
      print $OUT
  	("\nTerm::ReadLine::Gnu version: $Term::ReadLine::Gnu::VERSION");
      print $OUT
  	("\nGNU Readline Library version: $Attribs{library_version}\n");
      rl_on_new_line();
  }
  
  # sample function of rl_message()
  sub change_ornaments {
      my($count, $key) = @_;	# ignored in this function
      rl_save_prompt;
      rl_message("[S]tandout, [U]nderlining, [B]old, [R]everse, [V]isible bell: ");
      my $c = chr rl_read_key;
      if ($c =~ /s/i) {
  	ornaments('so,me,,');
      } elsif ($c =~ /u/i) {
  	ornaments('us,me,,');
      } elsif ($c =~ /b/i) {
  	ornaments('md,me,,');
      } elsif ($c =~ /r/i) {
  	ornaments('mr,me,,');
      } elsif ($c =~ /v/i) {
  	ornaments('vb,,,');
      } else {
  	rl_ding;
      }
      rl_restore_prompt;
      rl_clear_message;
  }
  
  #
  #	for tkRunning
  #
  sub Tk_getc {
      &Term::ReadLine::Tk::Tk_loop
  	if $Term::ReadLine::toloop && defined &Tk::DoOneEvent;
      my $FILE = $Attribs{instream};
      return rl_getc($FILE);
  }
  
  # redisplay function for secret input like password
  # usage:
  #	$a->{redisplay_function} = $a->{shadow_redisplay};
  #	$line = $t->readline("password> ");
  sub shadow_redisplay {
      @_tstrs = _tgetstrs() unless $_tstrs_init;
      # remove prompt start/end mark from prompt string
      my $prompt = $Attribs{prompt}; my $s;
      $s = Term::ReadLine::Gnu::RL_PROMPT_START_IGNORE; $prompt =~ s/$s//g;
      $s = Term::ReadLine::Gnu::RL_PROMPT_END_IGNORE;   $prompt =~ s/$s//g;
      my $OUT = $Attribs{outstream};
      my $oldfh = select($OUT); $| = 1; select($oldfh);
      print $OUT ($_tstrs[0],	# carriage return
  		$_tstrs[1],	# clear to EOL
  		$prompt, '*' x length($Attribs{line_buffer}));
      print $OUT ($_tstrs[2]	# cursor left
  		x (length($Attribs{line_buffer}) - $Attribs{point}));
      $oldfh = select($OUT); $| = 0; select($oldfh);
  }
  
  sub _tgetstrs {
      my @s = (tgetstr('cr'),	# carriage return
  	     tgetstr('ce'),	# clear to EOL
  	     tgetstr('le'));	# cursor left
      warn <<"EOM" unless (defined($s[0]) && defined($s[1]) && defined($s[2]));
  Your terminal 'TERM=$ENV{TERM}' does not support enough function.
  Check if your environment variable 'TERM' is set correctly.
  EOM
      # suppress warning "Use of uninitialized value in print at ..."
      $s[0] = $s[0] || ''; $s[1] = $s[1] || ''; $s[2] = $s[2] || '';
      $_tstrs_init = 1;
      return @s;
  }
  
  # callback handler wrapper function for CallbackHandlerInstall method
  sub _ch_wrapper {
      my $line = shift;
  
      if (defined $line) {
  	if ($Attribs{do_expand}) {
  	    my $result;
  	    ($result, $line) = history_expand($line);
  	    my $outstream = $Attribs{outstream};
  	    print $outstream "$line\n" if ($result);
  
  	    # return without adding line into history
  	    if ($result < 0 || $result == 2) {
  		return '';	# don't return `undef' which means EOF.
  	    }
  	}
  
  	# add to history buffer
  	add_history($line) 
  	    if ($Attribs{MinLength} > 0
  		&& length($line) >= $Attribs{MinLength});
      }
      &{$Attribs{_callback_handler}}($line);
  }
  
  #
  #	List Completion Function
  #
  sub list_completion_function ( $$ ) {
      my($text, $state) = @_;
  
      $_i = $state ? $_i + 1 : 0;	# clear counter at the first call
      my $cw = $Attribs{completion_word};
      for (; $_i <= $#{$cw}; $_i++) {
  	return $cw->[$_i] if ($cw->[$_i] =~ /^\Q$text/);
      }
      return undef;
  }
  
  #
  #	wrapper completion function of 'completion_function'
  #	for compatibility with Term::ReadLine::Perl
  #
  sub _trp_completion_function ( $$ ) {
      my($text, $state) = @_;
  
      my $cf;
      return undef unless defined ($cf = $Attribs{completion_function});
  
      if ($state) {
  	$_i++;
      } else {
  	# the first call
  	$_i = 0;		# clear index
  	@_matches = &$cf($text,
  			 $Attribs{line_buffer},
  			 $Attribs{point} - length($text));
  	# return here since $#_matches is 0 instead of -1 when
  	# @_matches = undef
  	return undef unless defined $_matches[0];
      }
  
      return $_matches[$_i];
  }
  
  1;
  
  __END__
X86_64-LINUX-THREAD-MULTI_TERM_READLINE_GNU_XS

$fatpacked{"x86_64-linux-thread-multi/YAML/Dumper/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_DUMPER_SYCK';
  package YAML::Dumper::Syck;
  use strict;
  
  sub new { $_[0] }
  sub dump { shift; YAML::Syck::Dump( $_[0] ) }
  
  1;
X86_64-LINUX-THREAD-MULTI_YAML_DUMPER_SYCK

$fatpacked{"x86_64-linux-thread-multi/YAML/Loader/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_LOADER_SYCK';
  package YAML::Loader::Syck;
  use strict;
  
  sub new { $_[0] }
  sub load { shift; YAML::Syck::Load( $_[0] ) }
  
  1;
X86_64-LINUX-THREAD-MULTI_YAML_LOADER_SYCK

$fatpacked{"x86_64-linux-thread-multi/YAML/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_SYCK';
  package YAML::Syck;
  
  # See documentation after the __END__ mark.
  
  use strict;
  use vars qw(
    @ISA @EXPORT @EXPORT_OK $VERSION
    $Headless $SortKeys $SingleQuote
    $ImplicitBinary $ImplicitTyping $ImplicitUnicode
    $UseCode $LoadCode $DumpCode
    $DeparseObject $LoadBlessed
  );
  use 5.006;
  use Exporter;
  
  BEGIN {
      $VERSION   = '1.27';
      @EXPORT    = qw( Dump Load DumpFile LoadFile );
      @EXPORT_OK = qw( DumpInto );
      @ISA       = qw( Exporter );
  
      $SortKeys    = 1;
      $LoadBlessed = 1;
  
      local $@;
      eval {
          require XSLoader;
          XSLoader::load( __PACKAGE__, $VERSION );
          1;
      } or do {
          require DynaLoader;
          push @ISA, 'DynaLoader';
          __PACKAGE__->bootstrap($VERSION);
      };
  
  }
  
  use constant QR_MAP => {
      ''   => sub { qr{$_[0]} },
      x    => sub { qr{$_[0]}x },
      i    => sub { qr{$_[0]}i },
      s    => sub { qr{$_[0]}s },
      m    => sub { qr{$_[0]}m },
      ix   => sub { qr{$_[0]}ix },
      sx   => sub { qr{$_[0]}sx },
      mx   => sub { qr{$_[0]}mx },
      si   => sub { qr{$_[0]}si },
      mi   => sub { qr{$_[0]}mi },
      ms   => sub { qr{$_[0]}sm },
      six  => sub { qr{$_[0]}six },
      mix  => sub { qr{$_[0]}mix },
      msx  => sub { qr{$_[0]}msx },
      msi  => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub __qr_helper {
      if ( $_[0] =~ /\A  \(\?  ([ixsm]*)  (?:-  (?:[ixsm]*))?  : (.*) \)  \z/x ) {
          my $sub = QR_MAP()->{$1} || QR_MAP()->{''};
          &$sub($2);
      }
      else {
          qr/$_[0]/;
      }
  }
  
  sub Dump {
      $#_
        ? join( '', map { YAML::Syck::DumpYAML($_) } @_ )
        : YAML::Syck::DumpYAML( $_[0] );
  }
  
  sub Load {
      if (wantarray) {
          my ($rv) = YAML::Syck::LoadYAML( $_[0] );
          @{$rv};
      }
      else {
          @_ = $_[0];
          goto &YAML::Syck::LoadYAML;
      }
  }
  
  sub _is_glob {
      my $h = shift;
  
      return 1 if ( ref($h) eq 'GLOB' );
      return 1 if ( ref( \$h ) eq 'GLOB' );
      return 1 if ( ref($h) =~ m/^IO::/ );
  
      return;
  }
  
  sub DumpFile {
      my $file = shift;
      if ( _is_glob($file) ) {
          for (@_) {
              my $err = YAML::Syck::DumpYAMLFile( $_, $file );
              if ($err) {
                  $! = 0 + $err;
                  die "Error writing to filehandle $file: $!\n";
              }
          }
      }
      else {
          open( my $fh, '>', $file ) or die "Cannot write to $file: $!";
          for (@_) {
              my $err = YAML::Syck::DumpYAMLFile( $_, $fh );
              if ($err) {
                  $! = 0 + $err;
                  die "Error writing to file $file: $!\n";
              }
          }
          close $fh
            or die "Error writing to file $file: $!\n";
      }
      return 1;
  }
  
  sub LoadFile {
      my $file = shift;
      if ( _is_glob($file) ) {
          Load(
              do { local $/; <$file> }
          );
      }
      else {
          if ( !-e $file || -z $file ) {
              die("'$file' is empty or non-existent");
          }
          open( my $fh, '<', $file ) or die "Cannot read from $file: $!";
          Load(
              do { local $/; <$fh> }
          );
      }
  }
  
  sub DumpInto {
      my $bufref = shift;
      ( ref $bufref ) or die "DumpInto not given reference to output buffer\n";
      YAML::Syck::DumpYAMLInto( $_, $bufref ) for @_;
      1;
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME 
  
  YAML::Syck - Fast, lightweight YAML loader and dumper
  
  =head1 SYNOPSIS
  
      use YAML::Syck;
  
      # Set this for interoperability with other YAML/Syck bindings:
      # e.g. Load('Yes') becomes 1 and Load('No') becomes ''.
      $YAML::Syck::ImplicitTyping = 1;
  
      $data = Load($yaml);
      $yaml = Dump($data);
  
      # $file can be an IO object, or a filename
      $data = LoadFile($file);
      DumpFile($file, $data);
  
      # A string with multiple YAML streams in it
      $yaml = Dump(@data);
      @data = Load($yaml);
  
      # Dumping into a pre-existing output buffer
      my $yaml;
      DumpInto(\$yaml, @data);
  
  =head1 DESCRIPTION
  
  This module provides a Perl interface to the B<libsyck> data serialization
  library.  It exports the C<Dump> and C<Load> functions for converting
  Perl data structures to YAML strings, and the other way around.
  
  B<NOTE>: If you are working with other language's YAML/Syck bindings
  (such as Ruby), please set C<$YAML::Syck::ImplicitTyping> to C<1> before
  calling the C<Load>/C<Dump> functions.  The default setting is for
  preserving backward-compatibility with C<YAML.pm>.
  
  =head1 Differences Between YAML::Syck and YAML
  
  =head2 Error handling
  
  Some calls are designed to die rather than returning YAML. You should wrap
  your calls in eval to assure you do not get unexpected results.
  
  =head1 FLAGS
  
  =head2 $YAML::Syck::Headless
  
  Defaults to false.  Setting this to a true value will make C<Dump> omit the
  leading C<---\n> marker.
  
  =head2 $YAML::Syck::SortKeys
  
  Defaults to false.  Setting this to a true value will make C<Dump> sort
  hash keys.
  
  =head2 $YAML::Syck::SingleQuote
  
  Defaults to false.  Setting this to a true value will make C<Dump> always emit
  single quotes instead of bare strings.
  
  =head2 $YAML::Syck::ImplicitTyping
  
  Defaults to false.  Setting this to a true value will make C<Load> recognize
  various implicit types in YAML, such as unquoted C<true>, C<false>, as well as
  integers and floating-point numbers.  Otherwise, only C<~> is recognized to
  be C<undef>.
  
  =head2 $YAML::Syck::ImplicitUnicode
  
  Defaults to false.  For Perl 5.8.0 or later, setting this to a true value will
  make C<Load> set Unicode flag on for every string that contains valid UTF8
  sequences, and make C<Dump> return a unicode string.
  
  Regardless of this flag, Unicode strings are dumped verbatim without escaping;
  byte strings with high-bit set will be dumped with backslash escaping.
  
  However, because YAML does not distinguish between these two kinds of strings,
  so this flag will affect loading of both variants of strings.
  
  If you want to use LoadFile or DumpFile with unicode, you are required to open
  your own file in order to assure it's UTF8 encoded:
  
    open(my $fh, ">:encoding(UTF-8)", "out.yml");
    DumpFile($fh, $hashref);
  
  =head2 $YAML::Syck::ImplicitBinary
  
  Defaults to false.  For Perl 5.8.0 or later, setting this to a true value will
  make C<Dump> generate Base64-encoded C<!!binary> data for all non-Unicode
  scalars containing high-bit bytes.
  
  =head2 $YAML::Syck::UseCode / $YAML::Syck::LoadCode / $YAML::Syck::DumpCode
  
  These flags control whether or not to try and eval/deparse perl source code;
  each of them defaults to false.
  
  Setting C<$YAML::Syck::UseCode> to a true value is equivalent to setting
  both C<$YAML::Syck::LoadCode> and C<$YAML::Syck::DumpCode> to true.
  
  =head2 $YAML::Syck::LoadBlessed
  
  Defaults to true. Setting to false will block YAML::Syck from doing ANY
  blessing. This is an interface change since 1.21. The variable name was
  misleading, implying that no blessing would happen when in fact it did.
  
  Prior to 1.22, setting this to a false value only prevented C<Load> from
  blessing tag names that did not begin with C<!!perl> or C<!perl>;.
  
  =head1 BUGS
  
  Dumping Glob/IO values do not work yet.
  
  Dumping of Tied variables is unsupported.
  
  Dumping into tied (or other magic variables) with C<DumpInto> might not work
  properly in all cases.
  
  =head1 CAVEATS
  
  This module implements the YAML 1.0 spec.  To deal with data in YAML 1.1, 
  please use the C<YAML::XS> module instead.
  
  The current implementation bundles libsyck source code; if your system has a
  site-wide shared libsyck, it will I<not> be used.
  
  Tag names such as C<!!perl/hash:Foo> is blessed into the package C<Foo>, but
  the C<!hs/foo> and C<!!hs/Foo> tags are blessed into C<hs::Foo>.  Note that
  this holds true even if the tag contains non-word characters; for example,
  C<!haskell.org/Foo> is blessed into C<haskell.org::Foo>.  Please use
  L<Class::Rebless> to cast it into other user-defined packages. You can also
  set the LoadBlessed flag false to disable all blessing.
  
  This module has L<a lot of known
  issues|https://rt.cpan.org/Public/Dist/Display.html?Name=YAML-Syck>
  and has only been semi-actively maintained since 2007. If you
  encounter an issue with it probably won't be fixed unless you L<offer
  up a patch|http://github.com/toddr/YAML-Syck> in Git that's ready for
  release.
  
  There are still good reasons to use this module, such as better
  interoperability with other syck wrappers (like Ruby's), or some edge
  case of YAML's syntax that it handles better. It'll probably work
  perfectly for you, but if it doesn't you may want to look at
  L<YAML::XS>, or perhaps at looking another serialization format like
  L<JSON>.
  
  =head1 SEE ALSO
  
  L<YAML>, L<JSON::Syck>
  
  L<http://www.yaml.org/>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005-2009 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  The F<libsyck> code bundled with this library is released by
  "why the lucky stiff", under a BSD-style license.  See the F<COPYING>
  file for details.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
X86_64-LINUX-THREAD-MULTI_YAML_SYCK

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use FindBin::libs;
use App::Rad qw(MoreHelp);
use App::Rad::Plugin::MoreHelp;

App::Rad->run();
use 5.014;
use strict;
use warnings;
use Data::Dumper;
use Sort::Naturally;
use Path::Tiny; # only need this for reconfigure-remove when done
use Moo;
use App::Pipeline::Lite4::Command::viewpipeline;
use App::Pipeline::Lite4::Command::viewgraph;
use App::Pipeline::Lite4::Command::viewsystemconfig;
use App::Pipeline::Lite4::Command::new;
use App::Pipeline::Lite4::Command::run;
use App::Pipeline::Lite4::Command::file;
use App::Pipeline::Lite4::Command::symlink;
use App::Pipeline::Lite4::Command::symlink2;

sub setup {
     my $c = shift;
     #$c->register( "setup", \&_setup, "setup pipelite" );
     $c->register_commands( {
         new => "create a new pipeline",          
         vp => "view pipeline",
         vg => "view pipeline graph",
         #vd => "view datasource",
         #vc => "view config",
         vsc => "view system config",
         #vl => "view log",
         #ve => "view error",
         run => "run pipeline",
         file => "get files",
         symlink => "symlink files",
         version => "version"
      #   symlink2 => "symlink files"
         } );
}

sub _setup {
     
}

sub new {
     my $c = shift;
     my $desc = 'new PIPELINE_DIR';
     my %options = (
         'output_dir|d=s' => 'Sets output directory location'
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv }  == 0;
     App::Pipeline::Lite4::Command::new->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show "new" : IMPLEMENT !!!# 
}

sub vp {
     my $c = shift;
     my $desc = 'vc (view pipeline) [OPTIONS] PIPELINE_DIR';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vp -e vim. Overrides config file setting if exists.'
     );

     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     App::Pipeline::Lite4::Command::viewpipeline->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show the config file : IMPLEMENT !!!#
}

sub vg {
     my $c = shift;
     my $desc = 'vg (view pipeline graph) [OPTIONS] PIPELINE_DIR';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vg -e vim. Overrides config file setting if exists.'
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     App::Pipeline::Lite4::Command::viewgraph->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show the config file : IMPLEMENT !!!#
}

#sub vc {
#     my $c = shift;
#     my $desc = 'vc (view config) [OPTIONS] PIPELINE_DIR';
#     my %options = (
#         'editor|e=s' => 'Sets the editor e.g. plite vc -e vim. Overrides config file setting if exists.'
#     );
#     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
#     return join ' ', "Argument: ", $c->argv->flatten;      # else show the config file
#}

sub vsc {
     my $c = shift;
     my $desc = 'vsc (view system config) [OPTIONS]';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vc -e vim. Overrides config file setting if exists.',
         #'output_dir|o=s'         => "output file",
     );
     #return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     #print Dumper $c->options;
     App::Pipeline::Lite4::Command::viewsystemconfig->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      # else show the config file
}

sub ve {
     
}

sub vd {
     
}

sub vl {
    
}

sub run {
     my $c = shift;
     my $desc = 'run (run pipeline) [OPTIONS] PIPELINE';
     my %options = (
         'datasource|d=s' => 'Provides a path name to a datasource.',
         'smoke_test|m'   => 'Runs pipeline with out dispatching jobs',
         'run_num|r=i'    => 'Run on this run number',
         'steps|s=s'      => 'Run only these steps',
         'jobs|j=s'       => "Only run these jobs. Corresponds to rows in datasource. e.g --jobs '1,5,7-21' . Starts from job 0"
         # IN ORDER OF USEFULNESS: 
         # 'jobs|j=s'  => 'Run only on these job numbers (corresponds to rows in the datasource)'
         # 'run|r=i'   => 'Run on this run number',
         # 'steps|s=s' => 'Run only these steps'
         # '' 'output_dir|o=s'         => "output file",
     );
     
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;       
     $c->getopt( keys %options );   
     App::Pipeline::Lite4::Command::run->new->execute($c->options, $c->argv);
}

sub file {
     my $c = shift;
     my $desc = 'file (get pipeline output files) [OPTIONS] PIPELINE';
     my %options = (
     'run_num|r=i'  => 'run_num',
     'stats|s'      => 'Show stats (size and mtime)',
     'step_name|t'     => 'Show step name in header',
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;       
     $c->getopt( keys %options );   
     App::Pipeline::Lite4::Command::file->new->execute($c->options, $c->argv);
}

sub version {
     my $c = shift;
     my $desc = 'version';
     print "0.02\n";
     #my %options = (
     #'run_num|r=i'  => 'run_num',
     #'stats|s'      => 'Show stats (size and mtime)',
     #'step_name|t'     => 'Show step name in header',
     #);
     #return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;       
     #$c->getopt( keys %options );   
     #App::Pipeline::Lite4::Command::file->new->execute($c->options, $c->argv);
     return;
}


sub symlink {
    my $c = shift;
my $desc = "symlink (creates dir of symlinks) [OPTIONS] PIPELINE
 Create symlinks with identifiers based on a datasource column (specified by --id_field)\n";
    my %options = (
           #'datasource|d=s' => 'Provides a path name to a datasource.',
          'run_num|r=i'  => 'run_num',
          'id_field|f=s'   => 'Field in the datasource that will be the file prefix',
          'step_and_fname|s=s' => 'Step and filename in format STEP#FILENAME',
          #'path|p=s' => 'Path of symlink directory other than default, which will be created if it does not exist',
          'name|n=s' => 'Replaces filename with new name',
          'datasource|d=s' => 'Path to datasource file, if not given then datasource of the run_num will be used'
          );  
      $c->getopt( keys %options );
      return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
      App::Pipeline::Lite4::Command::symlink2->new->execute($c->options, $c->argv);
}

#sub symlink2 {
#      my $c = shift;
#    my $desc = 'symlink (creates dir of symlinks) [OPTIONS] PIPELINE';
#    my %options = (
#           #'datasource|d=s' => 'Provides a path name to a datasource.',
#          'run_num|r=i'  => 'run_num',
#          'id_field|f=s'   => 'Field in the datasource that will be the file prefix',
#          'step_and_fname|s=s' => 'Step and filename in format STEP#FILENAME (required)',
#          'path|p=s' => 'Path of symlink directory other than default, which will be created if it does not exist',
#          'name|n=s' => 'Replaces filename with new name',
#          'datasource|d=s' => 'Path to datasource file, if not given then datasource of the last run will be used'
#          );  
#      $c->getopt( keys %options );
#      return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
#      App::Pipeline::Lite4::Command::symlink2->new->execute($c->options, $c->argv);
#}


sub _options_str {
    my $options = shift;
    my $options_str;
    foreach my $key ( nsort keys %$options ){
       my ($longform,$shortform) = $key =~ /(.+)\|([a-z]+)/;
       $options_str .= "\t-$shortform --$longform\t" . $options->{$key} . "\n";  
    }
    return $options_str; 
}

sub _usage {
    my $cmd = shift;
    my $options_str = _options_str( shift);
    my $usage = <<USAGE
    
Usage: plite $cmd
     $options_str
USAGE
;
    return $usage;
}
