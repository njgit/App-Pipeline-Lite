#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Pipeline/Lite4.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4';
  use strict;
  use warnings;
  package App::Pipeline::Lite4;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  use Types::Path::Tiny qw/Path AbsPath/;
  extends 'App::Pipeline::Lite4::Base';
  use App::Pipeline::Lite4::Util;
  use App::Pipeline::Lite4::Parser; 
  use App::Pipeline::Lite4::Resolver;
  use App::Pipeline::Lite4::Grapher;
  use File::Copy;
  use Data::Dumper;
  has smoke_test => ( isa => 'Bool', is => 'rw', default => sub {0} ); 
  has external_dispatcher => ( isa => 'Path::Tiny|Undef', is => 'rw', 
                                lazy_build => 1 );
  
  sub _build_external_dispatcher {
      my $self = shift;  
        
      my $dispatcher = $self->config->{_}->{dispatcher}; #check local config 
      
      # if does not exist, check system config    
      $dispatcher = $self->system_config->{_}->{dispatcher} 
                                 unless defined( $dispatcher);
      
      defined($dispatcher) ?  path($dispatcher) : undef;    
  }
  
  sub util {
      my $self = shift;
      # give back object with utilities
      return App::Pipeline::Lite4::Util->new(  pipeline_dir => $self->pipeline_dir);
  }
  
  sub symlink {
      my $self      = shift;
      my $opt       = shift; # this is the options  with the id_field,symlinkdir if required
      #my $pipeline_file = shift;
      my $id_field = $opt->{id_field};
      
      my $STEP_AND_FNAME = $opt->{step_and_fname}; 
      
      my ($STEP,$FNAME);
      if( defined $STEP_AND_FNAME ){
        ($STEP,$FNAME) = split '#', $STEP_AND_FNAME;
      }
      
      my $parser = App::Pipeline::Lite4::Parser->new(
          pipeline_dir => $self->pipeline_dir,
       );
      
      $parser->preparse(  $self->pipeline_file, 
                          $self->pipeline_preparse_file ); 
      
      $parser->parse(  $self->pipeline_preparse_file, 
                       $self->pipeline_parse_file  );
      #warn "WORKING WITH DATASOURCE: " .    $self->datasource_file;
        
      my $resolver = App::Pipeline::Lite4::Resolver->new (                      
                         pipeline_dir         => $self->pipeline_dir,
                         #datasource_file     => $self->datasource_resolved_file,
                         #datasource_file      => defined( $opt->{datasource} ) ? $opt->{datasource} : $self->datasource_file,
                         datasource_file     => $self->datasource_file,
                         current_run_num      => defined( $self->run_num ) ? $self->run_num : undef,
                         step_filter_str      => defined( $self->step_filter_str) ? $self->step_filter_str : undef,
                         job_filter_str       => defined( $self->job_filter_str) ? $self->job_filter_str : undef,
                         #run_num_dep         => defined( $self->run_num_dep ) ? $self->run_num_dep : undef
                         );   
                         
      #warn Dumper $resolver->pipeline_datasource;                                          
      $resolver->resolve($self->pipeline_parse_file,$self->pipeline_resolved_file);
          
      my $datasource = $resolver->pipeline_datasource;
      
      # read resolved file YAML
      my $resolved_file_yaml = $self->pipeline_resolved_file->slurp;
      my $resolved_pipeline  = Load($resolved_file_yaml);
      my $output_run_dir = path( $self->output_dir, "run" . $self->run_num );
     
      foreach my $job_num (keys %$resolved_pipeline){
          my $job = $resolved_pipeline->{$job_num};         
          foreach my $step (keys %$job) {
              my $job_ids;   # A job_id is a label attached to each job based on the values in a column (specified by id_field) of the datasource
  
              if (defined ($STEP_AND_FNAME) ){
                 next unless $step eq $STEP;
              }
  
              my $symlink_dir = path($resolver->symlink_dir, $step, $self->run_num);
              $symlink_dir->mkpath;
              my $condition = $job->{$step}->{condition};                   
              if(defined($condition) && $condition eq 'groupby'){
                 my $condition_params = $job->{$step}->{condition_params};
                 $job_ids = $self->_get_job_ids($id_field,$datasource,$condition_params);
                 my $num_jobs = scalar @$job_ids;
                 #warn "groupby step in symlink";
                 next if $job_num >= $num_jobs ;
              }else{
                 # get the job ids  
                 $job_ids = $self->_get_job_ids($id_field,$datasource,undef);
              }
              
              if( defined $STEP_AND_FNAME ){
                  my $file_path = path($output_run_dir,"job$job_num",$step,$FNAME);  
                  if( $file_path->exists ) {
                      my $path_to_link = $file_path;
                      $self->_symlink_paths($job_num, $path_to_link,$job_ids,$symlink_dir,$opt->{name});
                  }else{
                      warn "path $file_path does not exist - SYMLINK NOT MADE";
                  }
                  next;
              }
  
              my $outputfiles = $job->{$step}->{outputfiles};
              foreach my $outputfile ( @$outputfiles ){
                 # warn "OUTPUTFILE: ", $outputfile,"\n";           
                 my  $outputfile_path = path($output_run_dir,"job$job_num",$step,$outputfile);  
                 # warn "LOOKING FOR $outputfile_path";          
                 if( $outputfile_path->exists ) {
                 #    warn "FOUND: ", $outputfile_path;
                 #    my $symlink_path = path($symlink_dir,$job_ids->[$job_num]);
                 #    warn "SYMLINK $outputfile_path $symlink_path";
                    my $path_to_link = $outputfile_path;
                    $self->_symlink_paths($job_num, $path_to_link,$job_ids,$symlink_dir,$opt->{name});
                 }            
               }
           
              my $placeholders= $job->{$step}->{placeholders};
              foreach my $placeholder ( @$placeholders ){
                  my $path_to_link;
                  # warn "PLACEHOLDER: ", $placeholder,"\n";
                  my ($file ) = $placeholder =~ /$step\.(.+)/;
                  if( defined $file ){           
              
                     my  $file_path = path($output_run_dir,"job$job_num",$step,$file);    
                     #  warn "Looking for $file in $file_path";        
                     if( $file_path->exists ) {
                         #warn "FOUND: ", $file_path;     
                         my $path_to_link = $file_path; 
                         $self->_symlink_paths($job_num,$path_to_link,$job_ids,$symlink_dir,$opt->{name});        
                     }
                  }else{
                        #warn "no file in $placeholder";
                  }
           }
         }
      }   
  }
   
  sub _symlink_paths {
      my $self = shift;
      my $job_num = shift;
      my $path_to_link =shift;
      my $job_ids =shift;
      my $symlink_dir = shift;
      my $name = shift;
      
      if(defined $path_to_link){
               my $id =$job_ids->[$job_num];
               my $new_basename = "$id-".$path_to_link->basename;
               if( defined( $name )){
                  $new_basename = "$id$name" ;                                
                }     
               my $symlink_path = path($symlink_dir,$new_basename);        
               #my $symlink_path = path($symlink_dir,$job_ids->[$job_num],$file_path);
               print STDERR " SYMLINK $path_to_link $symlink_path\n";    
               CORE::symlink $path_to_link, $symlink_path;       
           }  
  } 
   
  sub _get_job_ids {
      my $self = shift;
      my $id_field = shift;  
      my $datasource = shift;
      my $groupby_fields = shift;
      
      my @job_ids ;
      if(defined $groupby_fields){
          my $groupby_field = $groupby_fields->[0];  # only one group by supported at the moment
          if( $groupby_field eq $id_field){      
              $datasource = $datasource->group([$groupby_field],[$id_field],[sub { $_[0] } ],["$id_field-group"] );
          }else{
              $datasource = $datasource->group([$groupby_field],[$id_field],[sub { join("-",@_) } ],["$id_field-group"] );
          }        
          #$self->logger->debug("Symlink - grouped datasource looks like " . $datasource->tsv );
          $id_field = "$id_field-group";
      }
     
      if( ! defined( $id_field) ){
             warn "No ID field defined. Prepending job numbers " ;
             @job_ids = map {"job$_"} (0 .. $datasource->nofRow -1 );
      }elsif( $datasource->hasCol($id_field) ){
             @job_ids = $datasource->col($id_field);
      }else{
             warn "No matching ID field in datasource. Prepending job numbers";
             @job_ids = map {"job$_"} (0 .. $datasource->nofRow -1 );
      }    
      return \@job_ids;  
  }
   
  
  sub run_pipeline {
      my $self = shift;   
      my $pipeline_file = shift; 
  
     # RESOLVE DATASOURCE HERE
  
      my $parser = App::Pipeline::Lite4::Parser->new(
          pipeline_dir => $self->pipeline_dir,
       );
      
      $parser->preparse(  $self->pipeline_file, 
                          $self->pipeline_preparse_file ); 
      
      $parser->parse(  $self->pipeline_preparse_file, 
                       $self->pipeline_parse_file  );
      #warn "WORKING WITH DATASOURCE: " .    $self->datasource_file;
        
      my $resolver = App::Pipeline::Lite4::Resolver->new (                      
                         pipeline_dir         => $self->pipeline_dir,
                         #datasource_file      => $self->datasource_resolved_file,
                         datasource_file      => $self->datasource_file,
                         current_run_num      => defined( $self->run_num ) ? $self->run_num : undef,
                         step_filter_str      => defined( $self->step_filter_str) ? $self->step_filter_str : undef,
                         job_filter_str       => defined( $self->job_filter_str) ? $self->job_filter_str : undef,
                         #run_num_dep          => defined( $self->run_num_dep ) ? $self->run_num_dep : undef
                         );   
                         
     #warn Dumper $resolver->pipeline_datasource;                                       
     
     $resolver->resolve($self->pipeline_parse_file,$self->pipeline_resolved_file); 
     
     
      my $grapher = App::Pipeline::Lite4::Grapher->new ( 
                         pipeline_dir    => $self->pipeline_dir,
                         datasource_file => $self->datasource_file,
                         );     
                                           
      $grapher->add_dependents(  $self->pipeline_resolved_file, 
                                 $self->pipeline_graph_file );                
       
      # copy stuff over to settings directory
      my $run_num = $resolver->current_run_num;
      $self->copy_pipeline_files_to_run_settings_dir($run_num); 
       
      if ( ! $self->smoke_test ) { 
     
        if( defined( $self->external_dispatcher ) ) {       
           $self->external_dispatch( $self->external_dispatcher );            
        } else {
            print "\n*** dispatcher not defined - see config file ***\n";
            # warn using local dispatch option
            #print "\n***\n\nUsing built in dispatcher\n\n***\n";
            #my $dispatcher = App::Pipeline::Lite4::Dispatcher->new( 
            #             pipeline_graph_file => $self->pipeline_graph_file,
            #             logfile => $self->logfile );                                      
            #$dispatcher->dispatch;    
       }
     }else{      
       $self->logger->debug("Smoke Test!");    
     }
     
  }
  
  sub external_dispatch {
     # TYPE  Path::Tiny :$dispatcher_exe )  {
      my $self=shift;
      my $dispatcher_exe=shift;
      
      my $pipeline_graph_file = $self->pipeline_graph_file->absolute;
      
      my $pipeline_dir = $self->pipeline_dir->absolute->stringify;
      ouch 'App_Pipeline_Lite4_Error', "Dispatcher does not exist at $dispatcher_exe" 
       unless $dispatcher_exe->exists;
      
       my $dispatcher_path_str = $dispatcher_exe->absolute->stringify;     
      ouch  'App_Pipeline_Lite4_Error', "Dispatcher app is not executable" 
        unless ( -x $dispatcher_path_str);  
        
      #my $dispatcher_cmd =  qq{ $dispatcher_path_str  $pipeline_dir };
      my $dispatcher_cmd =  qq{ $dispatcher_path_str  $pipeline_graph_file };
      system( $dispatcher_cmd );    
  }
  
  
  sub copy_pipeline_files_to_run_settings_dir  {
     
     my $self = shift;
     my $run_num = shift;
     $self->new_run_settings_dir($run_num)->mkpath unless $self->new_run_settings_dir($run_num)->exists;  
     
     copy( $self->pipeline_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy pipeline file to run settings directory";
     
     copy( $self->pipeline_graph_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy graph file to run settings directory";
      
     copy( $self->datasource_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy datasource file to run settings directory"; 
       
     #make a standardised version to the pipeline name 
     copy( $self->datasource_file->stringify , path( $self->run_settings_dir($run_num), $self->pipeline_name . ".datasource" )->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy datasource file to run settings directory"; 
      
     #copy( $self->datasource_resolved_file->stringify , $self->run_settings_dir($run_num)->stringify )
     #  or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy resolved datasource file to run settings directory"; 
       
     if( $self->software_ini_file->exists){ 
         copy( $self->software_ini_file->stringify , $self->run_settings_dir($run_num)->stringify )
           or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy software ini file to run settings directory";
     }
  }
  
  
  
  1;
APP_PIPELINE_LITE4

$fatpacked{"App/Pipeline/Lite4/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_BASE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Base;
  use Moo;
  use MooX::late;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  use Config::Tiny;
  use Ouch;
  use File::HomeDir; 
  use Data::Table;
  use App::Pipeline::Lite4::Logger; 
  use List::Util qw(max);
  
  has pipeline_dir  => ( isa => Path,  is => 'rw', coerce => 1, trigger  => \&_pipeline_dir_trigger);
  has use_relative_paths  => (isa => 'Bool', is => 'rw', default => sub {0});
  has pipeline_name    => ( isa => 'Str', is => 'rw', lazy_build => 1);
  has pipeline_file    => ( isa => Path, is => 'rw',  lazy_build => 1);
  has logfile          => ( isa => Path, is => 'rw', lazy_build => 1);
  has logconf          => ( isa => 'HashRef|Undef', is => 'rw', lazy_build => 1);
  has logconffile      => ( isa => Path, is => 'rw',  lazy_build => 1);
  has logger           => ( isa => 'App::Pipeline::Lite4::Logger', lazy_build=>1);
  has system_logfile   => ( isa => Path, is => 'rw',  lazy_build => 1);
  has system_logger    => ( isa => 'App::Pipeline::Lite4::Logger', lazy_build=>1);
  # config locations
  
  has config           => ( isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has config_file      => ( isa => Path, is => 'rw', coerce => 1, lazy_build => 1);
  has system_config      => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 ); 
  has system_config_file => ( isa => Path, is => 'rw', coerce => 1, lazy_build => 1);
  
  =cut
  has logconffile      => ( isa => Path, is => 'rw',  lazy_build => 1);
  =cut
  
  has output_dir       => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build => 1 );
  has input_dir        => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has sys_dir          => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has software_dir     => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has software_ini      => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has software_ini_file => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has test_data_file   => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
  has datasource_file  => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
  has datasource_resolved_file  => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
   
  has pipeline_preparse_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_parse_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_resolved_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_graph_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 );
  has pipeline_submission_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 );
  has pipeline_datasource  => ( isa => 'Data::Table', is => 'rw', lazy_build =>1 ); #used in util.
  
  has symlink_dir => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build => 1 );
  has output_run_name => (  isa => 'Str', is => 'rw', default => sub {return 'run'} );
  has output_job_name => (  isa => 'Str', is => 'rw', default => sub {return 'job'} );
  has run_settings_name => ( isa => 'Str', is => 'rw', default => sub {return 'settings'});
  
  has run_num => ( isa => 'Str', is => 'rw'); 
  has job_filter_str  => ( isa => 'Str|Undef', is => 'rw');
  has step_filter_str => ( isa => 'Str|Undef', is => 'rw');
  has argument_str    => ( isa => 'Str|Undef', is => 'rw'  );
  
  
  sub _pipeline_dir_trigger {
      my $self = shift;
      return if $self->pipeline_dir->is_absolute;
      if ($self->use_relative_paths){
          warn "USING RELATIVE PATHS";
          warn "The pipeline_dir is relative " if $self->pipeline_dir->is_relative;
          warn "But the pipeline_dir is absolute" if $self->pipeline_dir->is_absolute;
      } else {
         $self->pipeline_dir( $self->pipeline_dir->absolute );
      }
  }
  
  sub _build_pipeline_name {
      my $self = shift;
      return $self->pipeline_dir->basename; 
  }
  
  sub _build_pipeline_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.pipeline' ); 
  }
  
  sub _build_pipeline_preparse_file {
      my $self = shift;
      return path(   $self->sys_dir,  $self->pipeline_name . '.preparse.yaml') ; 
  }
  
  sub _build_pipeline_parse_file {
      my $self = shift;
      return path(   $self->sys_dir, $self->pipeline_name . '.parse.yaml') ; 
  }
  
  sub _build_pipeline_resolved_file {
      my $self = shift;
      return path(   $self->sys_dir, $self->pipeline_name . '.resolved.yaml') ; 
  }
  
  sub _build_pipeline_graph_file {
      my $self = shift;
      return path(  $self->sys_dir,  $self->pipeline_name . '.graph.yaml') ; 
  }
  
  sub _build_pipeline_submission_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.submissions.txt') ; 
  }
  
  sub _build_pipeline_datasource {
      my $self = shift;
      my $datasourcefile = path( $self->datasource_file )->absolute;  
      ouch 'badfile', "Need to provide datasource file location\n" unless defined( $datasourcefile);
      #my $t =  App::Pipeline::Lite2::Datasource->new( datasource_file => $datasourcefile );         
      my $t = Data::Table::fromTSV( $datasourcefile->stringify );
  }
  
  sub _build_logfile {
      my $self = shift;
      #return file($self->pipeline_dir, $self->pipeline_name .".log")->stringify;
      #this should be able to be set system/user wide
      my $tmp_dir = "/tmp/";
      return path($tmp_dir, $self->pipeline_name .".log") #->stringify;
  }
  
  sub _build_system_logfile {
      my $self = shift;
      #return file($self->pipeline_dir, $self->pipeline_name .".log")->stringify;
      #this should be able to be set system/user wide
      my $sys_log_dir = File::HomeDir->my_data;
      return path($sys_log_dir, "plite.log"); #->stringify;
  }
  
  sub _build_software_ini_file {
     my $self = shift;  
     my $file = path($self->software_dir, 'software.ini');
     return $file;
  }
  
  sub _build_software_ini {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->software_ini_file->exists;
      my $conf = $cf->read( $self->software_ini_file->absolute->stringify ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_logger {
      my $self = shift;   
      my $logger = App::Pipeline::Lite4::Logger->new( logfile => $self->logfile) ;    
      return $logger; 
  }
  
  sub _build_system_logger {
      my $self = shift;
      my $logger = App::Pipeline::Lite4::Logger->new( logfile => $self->system_logfile) ;    
      return $logger;
  }
  
  sub _build_logconf {
      my $self = shift;
      # open YAML config file
       my $logconf_yaml =  $self->logconffile->stat
        ? $self->logconffile->slurp
        : return undef;
      my $logconfig = Load($logconf_yaml);
      return $logconfig;
  }
  
  sub _build_logconffile {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.log.conf' );
  }
  
  sub _build_config_file {
     my $self = shift;  
     my $file = path($self->pipeline_dir, $self->pipeline_name.'.ini');
     #print "config file is $file\n";
     #$file->touch;
     return $file;
  }
  
  sub _build_config {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->config_file->exists;
      my $conf = $cf->read( $self->config_file ) 
         or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_system_config {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->system_config_file->exists;
      my $conf = $cf->read( $self->system_config_file ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_system_config_file {
     my $self = shift;  
     my $system_config_dir = File::HomeDir->my_dist_config('App-Pipeline-Lite4', { create => 1 });
     my $system_config_file = path($system_config_dir, 'config.ini');
     #print "config file is $file\n";
     #$file->touch;
     return $system_config_file;
  }
  
  sub _build_output_dir {
      my $self = shift;
      my $output_dir = $self->config->{_}->{output_dir}; 
      return path($output_dir) if(defined( $output_dir)) ;
      return path( $self->pipeline_dir, 'output'  ); 
  }
  
  sub _build_input_dir {
      my $self = shift;
      my $input_dir = $self->config->{_}->{input_dir}; 
      return path($input_dir) if(defined( $input_dir)) ;
      return path( $self->pipeline_dir, 'input'  ); 
  }
  
  
  sub _build_symlink_dir {
      my $self = shift;
      my $symlink_dir = $self->config->{_}->{symlink_dir}; 
      return path($symlink_dir) if(defined( $symlink_dir)) ;
      return path( $self->pipeline_dir, 'symlink'  ); 
  }
  
  
  sub _build_software_dir {
      my $self = shift;
      my $software_dir = $self->config->{_}->{software_dir}; 
      return path($software_dir) if(defined( $software_dir)) ;
      return path( $self->pipeline_dir, 'software'  ); 
  }
  
  sub _build_sys_dir {
      my $self = shift;
      my $sys_dir = $self->config->{_}->{sys_dir}; 
      return path($sys_dir) if(defined( $sys_dir)) ;    
      my $sys_path= path( $self->pipeline_dir, 'sys'  ); 
      mkdir $sys_path unless $sys_path->exists; #while old systems catch up
      return $sys_path;
  }
  
  sub _build_datasource_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.datasource');
  }
  
  sub _build_datasource_resolved_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.resolved.datasource');
  }
  
  sub _build_test_data_file {
      my $self = shift;
      return path( $self->pipeline_dir, 'test_data', 'test.txt'  ); 
  }
  
  sub run_dir  {
      my $self = shift;
      ## Num $run_num
      my $run_num = shift;
      return path( $self->output_dir, $self->output_run_name . $run_num );
  }
  
  sub run_settings_dir   {
     my $self = shift;
     #Num $run_num
     my $run_num = shift;   
     my $settings_dir = path($self->run_dir($run_num), $self->run_settings_name );
     if( $settings_dir->exists){
        my $num_runs = scalar $settings_dir->children; 
        return path($settings_dir, $num_runs);
     }else{
        return path($settings_dir, 1);
     }
  }
  
  sub last_run_num {
      my $self=shift;
      #read in files in data directory
      #order by run number
      # - if none then run number is 1.
      my $run_num = max map { if( $_ =~ /run([0-9]+)/){$1}else{} } $self->output_dir->children;
      $run_num = 0 unless (defined $run_num);    
      return $run_num;   
  }
  
  sub new_run_settings_dir { 
     my $self = shift;
     #(Num $run_num){
     # this should generate a new settings 
     #dir taking into account reruns
     my $run_num = shift;   
     my $settings_dir = path($self->run_dir($run_num), $self->run_settings_name );
     
     if( $settings_dir->exists){
        my $num_runs = scalar $settings_dir->children + 1; 
        return path($settings_dir, $num_runs);
     }else{
        return path($settings_dir, 1);
     }  
  }
  
  sub datasource_from_run {
      my $self = shift;
      my $run_num = shift;
      my $settings_path = $self->run_settings_dir($run_num);   
      my $datasource_path = path($settings_path, $self->datasource_file->basename );
      return $datasource_path;
  }
  
  #sub _reconfigure {
  #    my $self = shift;
  #    my $old  = shift;
  #    my $new  = shift;
  #    return if( ! path($old)->exists)
  #    mv path($old)-> ;
  #}
  
  
  
  1;
APP_PIPELINE_LITE4_BASE

$fatpacked{"App/Pipeline/Lite4/Command/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_FILE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::file;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  use Number::Bytes::Human qw(format_bytes);
  use Time::Piece;
  use Data::Table;
  sub execute {
      my ($self, $opt, $args) = @_;
   
      
      eval {
         
         # set show steps if stats
         $opt->{step_name} = 1 if $opt->{stats};
          
         # Default is to get the latest run and the latest datasource
     
        my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
        my $run_num = $resolver->_last_run_number;           
         if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
         }
        
        #get datasource from settings directory and set to datasource file
        $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
        my $datasource = $resolver->pipeline_datasource;
        #print $datasource->tsv;
         
        # Go through each job  
            # create a hash based on steps 
            #  $steps{step}{filename}{jobnum}
            #  then  at the end  
        my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
   
        my $iter = $output_run_dir->iterator( { recurse => 1 } );
        my %step_hash;
        my %jobs;
        while( my $path = $iter->() ){        
          next unless $path->is_file;
          next if(  $path->basename =~ m{/?(out|err)$} ); 
          next unless $path =~ /job/; #removes setting directory and other things that are not jobs
          
          #print $path . "\n";
          my ($job, $step,$name)  = $path->stringify =~ m{(job[0-9]+)/(.+)/(.+)$};
          #my ($step) = $path->stringify =~ m{job[0-9]+/(.+)/} ;
          #print join " ", $job, $step, $name .  "\n";
          if( $opt->{stats} ){
             my $time = localtime($path->stat->mtime)->datetime;
             $step_hash{$step}{$name}{$job} = format_bytes( $path->stat->size) . "," . "[$time]";
          }else{
            $step_hash{$step}{$name}{$job} = $path;
          } 
          $jobs{$job} =1;
        }  
       
        #print header
        
        my @row;
        my $header;
        foreach my $step (nsort keys %step_hash){
          my $names = $step_hash{$step};
          foreach my $name (nsort keys %$names){
             if( $opt->{step_name} ){
               push @row,  $step."-".$name;
             }else{
               push @row,  $name;
             }
          }
        }
        
        #print join "\t", @row; print "\n";
        $header = [@row];
        
        my @table_data;
        foreach my $job (nsort keys %jobs){  
            @row = ();
            # go through each step and if the name doesn't have this job then put in some null character          
            foreach my $step (nsort keys %step_hash){
                my $names = $step_hash{$step};
                foreach my $name (nsort keys %$names){
                    if( exists $names->{$name}->{$job} ){                  
                     push @row,  $names->{$name}->{$job} 
                  }else{
                    push @row,"-";
                  }
                                   
                }
            }
            #print join "\t", @row; print "\n";
            push @table_data, [@row];
         }
         
        my $t = Data::Table->new(\@table_data, $header, 0);
        $datasource->colMerge($t, {renameCol => 1 } );
        print $datasource->tsv;
         
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( kiss 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER' ){
         print "\n*** There is something to fix before this pipeline can dispatch ***\n";
         print "\n", bleep(), "\n\n"; 
         print "This might be fixed by:\n
               - giving the placeholder a value (e.g. treating as an argument) via --args
               - fixing an error in the placeholder name
               - creating values for this placeholder in the datasource
          \n";
      }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  
  1;
APP_PIPELINE_LITE4_COMMAND_FILE

$fatpacked{"App/Pipeline/Lite4/Command/new.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_NEW';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::new;
  use Moo;
  use MooX::late;
  use Ouch;
  use App::Pipeline::Lite4::SetupPipeline;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      # get pipeline directory
      # get pipelite object    
      eval {        
          my $App_Pipeline_Lite_Setup = App::Pipeline::Lite4::SetupPipeline->new( pipeline_dir => $args->[0]); 
          $App_Pipeline_Lite_Setup->output_dir( dir( $opt->{output_dir} ) ) if defined($opt->{output_dir});      
          if( defined $opt->{based_on}){
               $App_Pipeline_Lite_Setup->create_pipeline_directory( based_on => $opt->{based_on} ); # this needs to be written in setup            
          }else{
               $App_Pipeline_Lite_Setup->create_pipeline_directory();
          }        
      };
      
      if( kiss 'App_Pipeline_Lite2_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_NEW

$fatpacked{"App/Pipeline/Lite4/Command/run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_RUN';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::run;
  use Moo;
  use Ouch;
  use Path::Tiny;
  use App::Pipeline::Lite4;
  sub execute {
      my ($self, $opt, $args) = @_;
      
      eval {
          # Initiate
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          # Get options
          my $desc ="smoke-test";
          $desc = $App_Pipeline_Lite->util->ask_for_description
          unless defined $opt->{smoke_test};
          my $step_filter = $opt->{steps} // "*";
          my $job_filter  = $opt->{jobs} // "*";
          my $run_num =  $App_Pipeline_Lite->last_run_num + 1;
          $run_num = $opt->{run_num} if defined($opt->{run_num});
          my $run_info = join " ", "run" . "[ $run_num ]", "[ step-filter: " . $step_filter  . " ]", "[ job-filter: " . $job_filter . " ]";
          
          #Set Options
          $App_Pipeline_Lite->util->append_description( $run_info, $desc ); # Write Options to log
          
          $App_Pipeline_Lite->smoke_test(1) if defined($opt->{smoke_test});
          $App_Pipeline_Lite->step_filter_str($step_filter);
          $App_Pipeline_Lite->job_filter_str( $job_filter );
          
          $App_Pipeline_Lite->run_num($run_num);
          
          # Get datasource from datasource if supplied, otherwise from runnum
          if( defined $opt->{datasource} ) {
              # pre check that file exists
              my $datasource_path = $opt->{datasource};
              ouch 'App_Pipeline_Lite4_Error', "The datasource path ($datasource_path) is not a file" unless path( $datasource_path)->is_file ;
              $App_Pipeline_Lite->datasource_file( $datasource_path )  ;
          } elsif( defined $opt->{run_num}){
              my $datasource_path = $App_Pipeline_Lite->datasource_from_run($run_num);
              ouch 'App_Pipeline_Lite4_Error', "The datasource path ($datasource_path) defined by run_num is not a file" unless path( $datasource_path)->is_file ;
              $App_Pipeline_Lite->datasource_file($datasource_path);
          }
          
          # Run the pipeline
          $App_Pipeline_Lite->run_pipeline;
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( kiss 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER' ){
         print "\n*** There is something to fix before this pipeline can dispatch ***\n";
         print "\n", bleep(), "\n\n"; 
         print "This might be fixed by:\n
               - giving the placeholder a value (e.g. treating as an argument) via --args
               - fixing an error in the placeholder name
               - creating values for this placeholder in the datasource
          \n";
     }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_RUN

$fatpacked{"App/Pipeline/Lite4/Command/symdir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMDIR';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symdir;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
   sub execute {
      my ($self, $opt, $args) = @_;
      
       # get pipeline directory
       # get pipelite object 
      
       eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
     
          my ($step,$filename) = split '#', $opt->{step_and_fname} ;
          
          # get the datasource  
          my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
          my $run_num = $resolver->_last_run_number;           
          if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
           }
        
          #get datasource from settings directory and set to datasource file
          $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
          my $datasource = $resolver->pipeline_datasource;
                  
          my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
          my @jobs =  grep { /job/ } $output_run_dir->children
          print "@jobs\n"; 
          #my $iter = $output_run_dir->iterator( { recurse => 1 } );
          #my %step_hash;
          #my %jobs;
          #while( my $path = $iter->() ){        
          #  next unless $path->is_file;
          #  next if(  $path->basename =~ m{/?(out|err)$} ); 
          #  next unless $path =~ /job/; #removes setting directory and other things that are not jobs
          #}
          
          
          # parse the step name and filename
          # check that the field exists
          # go through each job directory and make the link
          # if a file doesn't exist warn. 
          # make a datasource for the symlink files
              
       };
      
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_SYMDIR

$fatpacked{"App/Pipeline/Lite4/Command/symlink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMLINK';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symlink;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
       eval {
          my $id_field = $opt->{id_field};
          my $pipeline_dir =       path($args->[0]);
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Requires step_and_filename argument"
             unless ( defined( $opt->{step_and_fname} ) );
          my ($step,$filename) = split '#', $opt->{step_and_fname} ;
          
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Something went wrong specifying the step and filename" 
             unless ( defined($step) and defined($filename));
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Something went wrong specifying the step and filename" 
             if( $step eq '' or $filename eq '');
          
          # get the datasource  
          my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
          my $run_num = $resolver->_last_run_number;           
          if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
          }
          
          my $datasource;
          if( defined( $opt->{datasource} )){
            $resolver->datasource_file($opt->{datasource} );
            $datasource = $resolver->pipeline_datasource;
          }else{
            #get datasource from settings directory and set to datasource file
            $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
            $datasource = $resolver->pipeline_datasource;
          }
           
          my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
          my @jobs = nsort grep { /job/ } $output_run_dir->children;
  
          my @job_ids = map {$_->basename} @jobs;
          if( ! defined( $id_field) ){
             warn "No ID field defined. Prepending job numbers " 
          }elsif( $datasource->hasCol($id_field) ){
             @job_ids = $datasource->col($id_field);
          }else{
             warn "No matching ID field in datasource. Prepending job numbers"
          }
          
          #default path
          my $symlink_dir = path($resolver->symlink_dir, $step, $run_num);
          $symlink_dir = $opt->{path} if defined($opt->{path});
          $symlink_dir->mkpath;
          my @table_data;
          foreach my $job (@jobs){
            my $path = path($job,$step,$filename);
            my $id = shift @job_ids;
            if( $path->exists){
               my $new_basename = "$id-".$path->basename;
               if( defined( $opt->{name} )){
                  my $name = $opt->{name};
                  $new_basename = "$id$name" ;                                
               }             
               my $new_path = path($symlink_dir,$new_basename);
               symlink $path, $new_path->absolute;  
               print "symlinked $path to $new_path\n";
               push @table_data, [$new_path];
            }else{
               warn "path $path does not exist";
               push @table_data, ["-"];
            }
          }
          
          my $t = Data::Table->new(\@table_data, [$filename], 0);
          $datasource->colMerge($t);
          my $datasource_tsv = $datasource->tsv;
          my $datasource_path = path($symlink_dir,$pipeline_dir->basename . ".datasource");
          $datasource_path->spew($datasource_tsv);
          # parse the step name and filename
          # check that the field exists
          # go through each job directory and make the link
          # if a file doesn't exist warn. 
          # make a datasource for the symlink files            
       };
      
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( kiss  'App_Pipeline_Lite_CMD_ERROR') {
         print bleep(), "\n";       
       }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_SYMLINK

$fatpacked{"App/Pipeline/Lite4/Command/symlink2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMLINK2';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symlink2;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
       eval {
          my $pipeline_dir =   path($args->[0]);
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);      
          my $run_num = $App_Pipeline_Lite->last_run_num;
          if(defined $opt->{run_num}){     
             $run_num = $opt->{run_num};
          }
          $App_Pipeline_Lite->run_num($run_num);        
          my $datasource_path = $App_Pipeline_Lite->datasource_from_run($run_num);
          $App_Pipeline_Lite->datasource_file($datasource_path);
          if(defined $opt->{datasource} ){
              $App_Pipeline_Lite->datasource_file($opt->{datasource});
          }
          $App_Pipeline_Lite->symlink($opt);       
       };
       
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( kiss  'App_Pipeline_Lite_CMD_ERROR') {
         print bleep(), "\n";       
       }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }    
  1;
APP_PIPELINE_LITE4_COMMAND_SYMLINK2

$fatpacked{"App/Pipeline/Lite4/Command/viewconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWCONFIG';
  # use strict;
  # use warnings;
  # package App::Pipeline::Lite4::Command::viewconfig;
  # use Moo;
  # use Ouch;
  # use App::Pipeline::Lite4;
  
  # # sub execute {
      # my ($self, $opt, $args) = @_;
      
  # #     # get pipeline directory
      # # get pipelite object 
      
  # #     eval {
          # my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
  # #         if(defined $opt->{editor}){
                  # $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          # }                             
          # $App_Pipeline_Lite->util->view_file_with_editor( 
                                # $App_Pipeline_Lite->pipeline_file->absolute->stringify);
          
  # #     };
      
  # #     if( kiss 'App_Pipeline_Lite4_Error') {
         # print bleep(), "\n"; 
      # } elsif ( hug ) {
         # print 'An error occurred, check logs: ', $@ ;
      # }
  # }
  #1;
APP_PIPELINE_LITE4_COMMAND_VIEWCONFIG

$fatpacked{"App/Pipeline/Lite4/Command/viewgraph.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWGRAPH';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewgraph;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      
      # get pipeline directory
      # get pipelite object 
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          if(defined $opt->{editor}){
                  $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          }                             
          $App_Pipeline_Lite->util->view_file_with_editor( 
                                $App_Pipeline_Lite->pipeline_graph_file->absolute->stringify);
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWGRAPH

$fatpacked{"App/Pipeline/Lite4/Command/viewpipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWPIPELINE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewpipeline;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      
      # get pipeline directory
      # get pipelite object 
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          if(defined $opt->{editor}){
                  $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          }                             
          $App_Pipeline_Lite->util->view_file_with_editor( 
                                $App_Pipeline_Lite->pipeline_file->absolute->stringify);
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWPIPELINE

$fatpacked{"App/Pipeline/Lite4/Command/viewsystemconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWSYSTEMCONFIG';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewsystemconfig;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
        
      
      eval {       
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new;
          my $App_Pipeline_Lite_Util = App::Pipeline::Lite4::Util->new; 
          if(defined $opt->{editor}){               
                  $App_Pipeline_Lite_Util->set_editor( $opt->{editor});
          }                             
          $App_Pipeline_Lite_Util->view_file_with_editor( $App_Pipeline_Lite->system_config_file );
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWSYSTEMCONFIG

$fatpacked{"App/Pipeline/Lite4/Grapher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_GRAPHER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Grapher;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  #use List::AllUtils qw(min any); can't use as get kick ups about requiring versions > 1.32
  use List::Util qw(min reduce);
  use Data::Compare;
  use Data::Dumper;
  use App::Pipeline::Lite4::Util;
  extends 'App::Pipeline::Lite4::Base';
  has pipeline_step_struct_with_dependents => ( isa => 'HashRef', is => 'rw' );
  
  sub add_dependents {
     my $self=shift;
     # Path::Tiny :$yaml_infile,
     my $yaml_infile = shift;  
     # Path::Tiny :$yaml_outfile
     my $yaml_outfile = shift;
     $self->pipeline_resolved_file($yaml_infile);
     $self->_add_dependents;
     $yaml_outfile->spew( Dump( $self->pipeline_step_struct_with_dependents ) );
  }
  
  #method _add_dependents {    
  sub _add_dependents {
      my $self = shift;
      my $resolved_file_yaml = $self->pipeline_resolved_file->slurp;
      my $resolved_pipeline = Load($resolved_file_yaml); 
      
      my $lowest_job_num = min keys $resolved_pipeline;
      my $num_of_jobs    = scalar keys $resolved_pipeline;
      
     # my $valid_steps = $self->valid_steps( $resolved_pipeline);
      my $valid_steps = $self->valid_steps_hash( $resolved_pipeline);
      
      foreach my $job_num (keys %$resolved_pipeline){
          my $job = $resolved_pipeline->{$job_num};
          foreach my $step (keys %$job) {
             $job->{$step}->{dependents} = [];
             if( defined($job->{$step}->{placeholders})) {
                $self->_add_dependents_for_step_via_placeholder( 
                          $job->{$step}, #step
                          $step, #step_name 
                          $job_num,
                          $lowest_job_num,  
                          $num_of_jobs, 
                          $valid_steps 
                          );
             }
             
             if( defined( $job->{$step}->{after}) ) {
                 $self->_add_dependents_for_step_via_after_condition( 
                          $job->{$step}, #step
                          $step,   #sep_name
                          $job_num, 
                          $lowest_job_num, 
                          $num_of_jobs, 
                          $valid_steps );  
             }           
          }
      }
      $self->pipeline_step_struct_with_dependents($resolved_pipeline);
  }
  
  sub _add_dependents_for_step_via_placeholder {
  # TYPE (  HashRef :$step, Str :$step_name, Num :$job_num, Num :$lowest_job_num, 
  # TYPE Num :$num_of_jobs, ArrayRef :$valid_steps ) {
       my ($self,$step,$step_name,$job_num, $lowest_job_num, 
           $num_of_jobs,$valid_steps_hash  ) = @_;
       
       $self->logger->debug( "Valid Steps: " . Dumper $valid_steps_hash );
       my $rgx1 = qr{^([\w\-]+)\.{0,1}};
       my $rgx2 = qr{^jobs\.([\w\-]+)\.{0,1}};      
       my $rgx3 = qr{groupbyebyebye}; # should not match anything
       if( defined( $step->{condition} ) ){         
         if(  $step->{condition} eq 'groupby'){
           my $params = $step->{condition_params};     
           my $params_str = join '\.', @$params;
           my $rgx3_str = '^groupby\.' . $params_str . '\.' . '([\w\-]+)\.{0,1}';
           $rgx3 = qr{$rgx3_str};
         }
       } 
       #warn "REGEX3 $rgx3";     
       my $placeholders = $step->{placeholders};
       my $dependents   = $step->{dependents};
       
       my @valid_steps = keys %$valid_steps_hash;
       foreach my $placeholder (@$placeholders){                                    
           my ($placeholder_step_name) = $placeholder =~ $rgx2;#/^(\w+)\.{0,1}/; # =~ /step([0-9]+)/;
           ($placeholder_step_name) = $placeholder =~ $rgx3 unless defined($placeholder_step_name);
           ($placeholder_step_name) = $placeholder =~ $rgx1 unless defined($placeholder_step_name);
            
           # warn "GOT STEP NAME: $placeholder_step_name from $placeholder";
           $self->logger->debug("step $step_name: placeholder step name - $placeholder_step_name (from $placeholder)");  
           next unless defined($placeholder_step_name);
           
           ### I want 'any' unfortunately any isn't in recent version of List::Util and List::MoreUtils is XS and not core
           my $code = sub { my $k = shift; return 1 if( $placeholder_step_name eq $k ); return 0;   };
           my $next = reduce { $a || $code->(local $_ = $b)  } 0,  @valid_steps;
           next unless $next;
           
           # DO THIS WHEN List::Util qw(any) works for most Perls  
           #next unless any { $placeholder_step_name eq $_ } @$valid_steps; # if we have filtered steps this is important, and also takes care of the 0 datasource step
           ########################################################
           
                  
               my ($existing_dependents, $this_step_name) = (0,0);
               
               ## Actually want List::Util qw(any)
               my $codeA = sub { my $k = shift; return 1 if( "$job_num.$placeholder_step_name"  eq $k ); return 0;   };
               $existing_dependents = reduce { $a || $codeA->(local $_ = $b)  } 0,  @$dependents;
               
               # DO THIS WHEN List::Util qw(any) works for most Perls  
               #$existing_dependents =  any { $_ eq "$job_num.$placeholder_step_name"  }  @$dependents;
               ##############################################################################
               $this_step_name = 1 if( $placeholder_step_name eq $step_name);                                   
               if ( defined $step->{condition} ) {
                   # only defined condition is 'once' so far
                   # the 'any' code above will skip adding the same dependent jobs if a placeholder with the same step name occurs multiple times. 
                   # it works because it sets $existing_dependents true if any of the job numbers is present                
                   #---
                   if( $step->{condition} eq 'once'){ 
                       # now a once condition referencing another step with a once condition only needs to put down the minimal job number
                       # remember we are looking at the placeholder and trying to determine dependencies,
                       # the valid steps hash, tells us what condition the step of that placeholder is, so we can 
                       # adjust for once or groupby steps
                       if( defined $valid_steps_hash->{$placeholder_step_name}->{condition} ){             
                           if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'once' ){
                             push(@$dependents, "$lowest_job_num.$placeholder_step_name") unless ( $this_step_name or $existing_dependents) ; 
                           }
                       }else {
                           for my $i ( $lowest_job_num .. ( $num_of_jobs -1 )){
                              push(@$dependents, "$i.$placeholder_step_name") unless ( $this_step_name or $existing_dependents) ;                                               
                           }
                    
                       }
                     }
                     if ( $step->{condition} eq 'groupby'  ){
                         
                         #we take the job number and get the group we need
                         my $util = App::Pipeline::Lite4::Util->new;
                         my $params = $step->{condition_params};
                         #warn "PARAMS: ", Dumper $params;
                         my $groupby_hash = $util->datasource_groupby2( $self->pipeline_datasource, @$params );
                         my $groupby_ids  = $util->datasource_groupby2_order($self->pipeline_datasource, @$params);
                         #my @groupby_ids = sort keys %$groupby_hash;
                         #warn "GRAPHER JOBNUM: $job_num";
                         #warn "GRAPHER GROUPID: @groupby_ids";
                         #warn "gRAPHER CMD", $step->{cmd};
                         #warn "STEP",  Dumper $step;
                         my $group_id = $groupby_ids->[$job_num]; 
                         #warn "GRAPHER GROUPID: $group_id";
                         my $job_ids = $groupby_hash->{$group_id};
                         
                         
                         # if we are referring to a step that is a groupby step, then we only need to 
                         # put int dependencies that refer to the jobs generated by that step - i.e. only up to job 4 rather
                         # than job 10 for example, as it won't exist 
                         
                         if( defined $valid_steps_hash->{$placeholder_step_name}->{condition} ){             
                           if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'groupby' ){
                               # different conditions will have different numbers, 
                               # we can only refer to a groupby with the same condition  
                               # and then we only put in the job number, 
                               my $placeholder_step_params = $valid_steps_hash->{$placeholder_step_name}->{condition_params};
                               #my $comp = Array::Compare->new; 
                               if( ! Compare( $placeholder_step_params, $params  ) ){
                                  ouch 'App_Pipeline4_Error', "One groupby statement depends on another groupby statement with a different groupby field(s)";
                               }else{
                                  
                                  push(@$dependents, "$job_num.$placeholder_step_name") 
                                     unless ( $this_step_name or $existing_dependents or ($job_num >= scalar(@$groupby_ids)) ); 
                               } 
                           }
                           #do something for once here
                          }else{
                         
                             foreach my $job_id (@$job_ids){  
                                push( @$dependents, "$job_id.$placeholder_step_name" ) unless ( $this_step_name or $existing_dependents) ;
                             }
                         }
                     } 
                   
               }else{                 
                   #$existing_dependents =  any { $_ eq "$job_num.$placeholder_step_name"  }  @$dependents;
                   #$this_step_name = 1 if( $placeholder_step_name eq $step_name);  
                   if( defined ( $valid_steps_hash->{$placeholder_step_name}->{condition} ) ){                     
                       if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'once'){
                            push( @$dependents, "$lowest_job_num.$placeholder_step_name")
                                unless ($this_step_name or $existing_dependents) ; 
                       }
                       
                    }else{
                      push( @$dependents, "$job_num.$placeholder_step_name")
                        unless ($this_step_name or $existing_dependents) ;
                   }
               }       
           #}         
       }
  }
  =cut To implement
  sub _add_dependents_for_step_via_after_condition {
      #TYPE: HashRef :$step, Str :$step_name, Num :$job_num, 
      #TYPE: Num :$lowest_job_num, Num :$num_of_jobs, ArrayRef :$valid_steps )
        my ($self,$step,$step_name,$job_num, $lowest_job_num, 
           $num_of_jobs,$valid_steps_hash  ) = @_;
        foreach my $after_step_name ($step->{after}->flatten){
          # if($after_step_num > $step) {
             # ouch 'steperror', "Need to ensure that a step does not define steps to run after that are future steps"; 
          # } 
          
         # if ( $after_step_num < $step_num ) { 
              my $dependents = $step->{dependents};  
               $self->logger->debug("step $step_name: placeholder step num - $after_step_name");                         
               if ( defined $step->{condition} ) { # only 'once' is the only thing that can occur from the condition key                
                   for my $i ( $lowest_job_num .. ( $num_of_jobs -1 )){
                       push( @$dependents, "$i.$after_step_name");                                               
                   }
               }else{
                   ouch 'App_Pipeline4_Error', "The after condition of step $step_name refers to its own step"
                     if( $after_step_name eq $step_name );
                  
                   push(@$dependents, "$job_num.$after_step_name")
                     unless any { $_ eq "$job_num.$after_step_name"  }  @$dependents ;
               }       
         #  }                    
                     
      }
  }
  =cut
  
  ####DEPRECATED## REMOVE
  sub valid_steps {
    #TYPE: ( HashRef :$resolved_pipeline ) {
    my $self = shift;    
    my $resolved_pipeline = shift;  
    # run through the first job.  
    my ($a_job);
    my @jobs = keys %$resolved_pipeline;
    my ($min_job_num) = sort {$a <=> $b} @jobs;
    $a_job =  $resolved_pipeline->{$min_job_num}; 
    my @step_names =  keys %$a_job;
    warn "@step_names";
    return \@step_names;    
  } 
  ############
  
  
  sub valid_steps_hash {
    #TYPE: ( HashRef :$resolved_pipeline ) {
    my $self = shift;    
    my $resolved_pipeline = shift;  
    # run through the first job.  
    my ($a_job);
    my @jobs = keys %$resolved_pipeline;
    my ($min_job_num) = sort {$a <=> $b} @jobs;
    $a_job =  $resolved_pipeline->{$min_job_num}; 
    my @step_names =  keys %$a_job;
    my %valid_step_hash;
    foreach my $step (keys %$a_job){
       $valid_step_hash{$step}->{condition} = $a_job->{$step}->{condition};
       $valid_step_hash{$step}->{condition_params} = $a_job->{$step}->{condition_params};   
    }
    
    return \%valid_step_hash;
  } 
  
  1;
APP_PIPELINE_LITE4_GRAPHER

$fatpacked{"App/Pipeline/Lite4/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_LOGGER';
  package App::Pipeline::Lite4::Logger;
  use Moo;
  use MooX::late;
  use Path::Tiny;
  use Time::Piece;
  use Devel::StackTrace;
  has logfile => ( isa => 'Path::Tiny|Undef', is => 'rw' );
  has system_logfile => ( isa => 'Path::Tiny|Undef', is => 'rw' );
  sub log {
      my $self  = shift;
      my $level = shift;
      my $msg   = shift; 
      
      my $t = localtime;  
      my $trace = Devel::StackTrace->new();
      
      my $frame = $trace->frame(1);
      my $package = $frame->package;
      my $app_caller = "unknown";
      
      while ( my $frame = $trace->prev_frame() ) {
         if ( $frame->package =~ /Command\:\:(.+)/ ) {
            $app_caller = $1;
            last;
         }
      }
      
      my $log_msg = "[" . $level . "] " . "[ $app_caller -> $package ] " . " [ " . $t->strftime . " ] " . $msg;         
      my $append_log = $self->logfile->opena; #( $level =~ /sys/ ) ? $self->system_logfile->opena : $self->logfile->opena;
      print $append_log $log_msg, "\n";
  }
  
  sub debug {
     my $self = shift;
     my $msg  = shift;
     $self->log("debug",$msg) ;
  }
  
  sub info {
     my $self = shift;
     my $msg  = shift;
     $self->log("info",$msg) ;
  }
  
  
  1;
APP_PIPELINE_LITE4_LOGGER

$fatpacked{"App/Pipeline/Lite4/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_PACKER';
  package App::Pipeline::Lite4::Packer;
  use Moo;
  use App::FatPacker;
  use Path::Tiny;
  # thieve from Carton fatpacking (MIYAGAWA)
  
  sub fatpack_plite {
      my $self = shift;
      my $dir = path(shift);
      my $file = $dir->child('plite');
      
      my $fatpacked = $self->do_fatpack($file);     
      my $executable = path($dir,'packed')->child('plite');
      warn "... Bundling $executable\n";   
      $executable->spew($fatpacked);
      chmod 0755, $executable;
  }
  
  sub do_fatpack {
      my ($self, $file) = @_;
      my $packer = App::FatPacker->new;
   
      my @modules = split /\r?\n/, $packer->trace(args => [$file]); #, use => $self->required_modules);
      @modules = grep { !/main.pm/ } @modules;
      @modules = grep { !/XS.pm/ } @modules;
      @modules = grep { !/Moose/ } @modules;
      print join "\n", @modules, "\n"; 
      my @packlists = $packer->packlists_containing(\@modules);
      $packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute, \@packlists);
   
      my $fatpacked = do {
          local $SIG{__WARN__} = sub {};
          $packer->fatpack_file($file);
      };
   
      # HACK: File::Spec bundled into arch in < 5.16, but is loadable as pure-perl
      #use Config;
      #$fatpacked =~ s/\$fatpacked{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;
      
      $fatpacked;
  }
  1;
APP_PIPELINE_LITE4_PACKER

$fatpacked{"App/Pipeline/Lite4/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_PARSER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Parser ;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  use SHARYANTO::String::Util qw(trim rtrim);
  
  extends 'App::Pipeline::Lite4::Base';
  
  has append_err_str => ( isa => 'Bool' , is => 'rw', default => sub { 1;} );
  has prepend_cwd_str => ( isa => 'Bool' , is => 'rw', default => sub { 1;} );
  
  #has append  => (isa => 'Str', is =>'rw', default=> sub {''} );
  #has prepend =>  (isa => 'Str', is =>'rw', default=> sub {''} );
  
  has append => (isa => 'Str|Undef', is =>'rw', lazy_build => 1 );
  has prepend =>  (isa => 'Str|Undef', is =>'rw', lazy_build =>1  );
  
  sub get_step_name { 
      #TYPE( :$str) 
     my $str = shift;
     my ($name) = $str =~ /^([\w\-]+)\./;
     return $name;
  }
  
  sub get_step_condition {
      my $str = shift;
     #TYPE: :$str 
    
     my ($condition) = $str =~ /^[\w\-]+\.([\w\-]+)\.*/;
     return $condition;
  }
  
  sub _build_append {
      my $self = shift;
      my $append_str = $self->config->{_}->{append}; #check local config 
      
      # if does not exist, check system config    
      $append_str = $self->system_config->{_}->{append} 
                                 unless defined( $append_str);
      $append_str = " " . $append_str . " "; #make sure there is a space between commands
      defined($append_str) ?  $append_str : undef;  
  }
  
   sub _build_prepend {
      my $self = shift;
      my $prepend_str = $self->config->{_}->{prepend}; #check local config 
      
      # if does not exist, check system config    
      $prepend_str = $self->system_config->{_}->{prepend} 
                                 unless defined( $prepend_str);
      $prepend_str = " " . $prepend_str . " " if defined($prepend_str); #make sure there is a space between commands
      defined($prepend_str) ?  $prepend_str : undef;  
  }
  
  
  sub preparse {
      my $self = shift;       
      my $pipeline_file = shift // $self->pipeline_file; # TYPE: Path::Class::File :$pipeline_file = $self->pipeline_file,   
      my $yaml_outfile = shift // $self->pipeline_preparse_file;     # TYPE: Path::Class::File :$yaml_outfile = $self->pipeline_preparse_file 
      # parse the current steps in the pipeline 
      my $step_hash = parse_pipeline_to_step_hash( $pipeline_file );       
      # append other stuff here first, and then err string
      # <---     
      $self->append_err_str_to_cmd( $step_hash  )
        if  ( $self->append_err_str );      
       # prepend other stuff here first, and then cwd string
       # <---   
      $self->prepend_str_to_cmd($step_hash, $self->prepend ) 
        if  ( defined $self->prepend);  
      $self->prepend_cwd_str_to_cmd($step_hash ) 
        if  ( $self->prepend_cwd_str);        
      $yaml_outfile->spew( Dump($step_hash) );
  };
  
  sub parse {
      # TYPE: Path::Class::File :$yaml_infile, 
      # TYPE: Path::Class::File :$yaml_outfile  
    my $self= shift;
    my $yaml_infile  =shift;
    my $yaml_outfile =shift;  
    my $step_hash_yaml = $yaml_infile->slurp;
    my $step_hash    = Load($step_hash_yaml); 
    my $step_struct  = pipeline_step_hash_to_step_struct( $step_hash );
    $yaml_outfile->spew( Dump($step_struct) );  
  };
  
  sub append_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $str = shift;
    my $append_str_func   = sub { my $step_name = shift // 'default'; return $str};
    # concat_to_cmd knows to provide step name to the coderef
    my $appended_step_hash = $self->concat_to_cmd($step_hash, $append_str_func, 'APPEND');
  }
  
  # yes this is a specific case of above - look to refactor
  sub append_err_str_to_cmd {  
      my $self = shift;
      #TYPE: HashRef $step_hash 
      my $step_hash = shift;  
      my $append_str_func   =  sub { my $step_name = shift // 'default'; return " 2>[% $step_name.err %]" };
      # concat_to_cmd knows to provide step name to this coderef
      my $appended_step_hash = $self->concat_to_cmd($step_hash, $append_str_func, 'APPEND');  
  }
  
  sub prepend_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $str = shift;
    my $prepend_str_func   = sub { my $step_name = shift // 'default'; return $str};
    # concat_to_cmd knows to provide step name to the coderef
    my $prepended_step_hash = $self->concat_to_cmd($step_hash, $prepend_str_func, 'PREPEND');
  }
  
  # yes this is a specific case of above - look to refactor
  sub prepend_cwd_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $prepend_str_func   = sub { my $step_name = shift // 'default'; return "cd [% $step_name %]; "};
    # concat_to_cmd knows to provide step name to the coderef
    my $prepended_step_hash = $self->concat_to_cmd($step_hash, $prepend_str_func, 'PREPEND');
  }
  
  # requires a coderef that returns a string, which can be used to 
  # parameterise a step name
  sub concat_to_cmd {
      my $self = shift;
      #TYPE: HashRef $step_hash 
      my $step_hash = shift;
      my $concat_string_code = shift;
      my $type_of_concat = shift; #APPEND or PREPEND
      foreach my $step ( keys %$step_hash) {
         my $step_name =  get_step_name( $step);
         $step_name = trim( $step_name ) ;
         $step_hash->{$step} = rtrim( $step_hash->{$step} );           
         my $concat_str = $concat_string_code->($step_name);
         my $step_cond = get_step_condition( $step);
         if( defined($step_cond) ){
             if($step_cond eq 'once'){              
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step}  = $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;                             
             }
             
              if($step_cond eq 'groupby'){              
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step}  = $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;                             
             }
             
         } else {
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step} =  $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;
         }
     } 
     return $step_hash;
  }
  
  
  =func parse_pipeline_file_to_step_hash
    A step hash has a key such as "1." and value "some_cmd -h MOREOPTIONS ARGS ..."
  =cut
  sub parse_pipeline_to_step_hash   {
      # TYPE:  Path::Tiny $file
      my $file = shift;
      # Each Step Starts with X. or X.[condition], then a space, where X is the step name
      # Can be multiline but cannot start with X. on a line
      my @pipeline_file_contents = $file->lines;
      my %stephash;
      my $stepname;
      my $not_started=1;
      foreach my $line (@pipeline_file_contents) {        
          if ( $not_started && $line =~ /^\s+$/){next;} #allow blank lines at top of pipeline description
          if ( $line =~ /^#/){ next; }  
          my $C = qr{^[\w\-]+\.};
          my $D = qr{^[\w\-]+\.output};
          my $E = qr{^[\w\-]+\.once};
          my $F = qr{^[\w\-]+\.mem};       
          my $G = qr{^[\w\-]+\.after};
          my $H = qr{^[\w\-]+\.queue};
          my $I = qr{^[\w\-]+\.cores};
          my $J = qr{^[\w\-]+\.groupby\.[\w\-]+};
          my $K = qr{^[\w\-]+\.groupby\.[\w\-]+\.[\w\-]+};
              
          my $N = qr{\s(.+)};
          my $O = qr{\s+};
          my $rg = qr{        
              ($C|$D|$E|$F|$G|$H|$I|$J|$K)$N      
          }x;
          my $rg_whitespace = qr{        
              ($C|$D|$E|$F|$G|$H|$I|$J|$K)$O      
          }x;
         
          if( $line =~ $rg) {
              $not_started = 0;          
              $stepname = $1;            
              my $steptext = $2;
              $stephash{$stepname}  = $steptext;            
          }elsif($line =~ $rg_whitespace){ # step has white space after it
              $not_started = 0;
              $stepname = $1;
              $stephash{$stepname} = ""
          }elsif($line =~ /$C/){    # if the line matches as the first part of a step, yet is not a fully valid step then there is a misspelling or invalidity
              ouch 'App_Pipeline_Lite4_Error', "This step does not have a valid condition (is it misspelt?)\n ==> $line";
          }else{
              $stephash{$stepname} .= $line; 
          }    
      }
      return {%stephash};  
  }
  
  #takes step hash and parses it to more processed structure
  sub pipeline_step_hash_to_step_struct {
      #   TYPE: Path::Tiny :$yamlfile ) {
      my $step_hash = shift;
      my %step_struct;
      foreach my $step ( keys %$step_hash ){  
              
             my $step_name = get_step_name( $step);
             my $step_condition = get_step_condition( $step);
             
             if( !defined($step_condition) ) {
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = undef; # change to 'none'?
             } 
                        
             elsif( $step_condition eq 'output' ) {
                 my @files = $step_hash->{$step} =~ /(\[\%.+?\%\]\S+|\S+)/g; #my @files = split(/\s/, $step_hash->{$step}); 
                 $step_struct{$step_name}->{outputfiles} = \@files; #$step_hash->{$step};
             }
                        
             elsif( $step_condition eq 'once' ) {
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = 'once';
             }
             
             elsif ( $step_condition eq 'mem' ) { 
               $step_struct{$step_name}->{mem} = trim( $step_hash->{$step} );
             }
                    
             elsif ( $step_condition eq 'after' ) { 
               my @after = split(/\s/, $step_hash->{$step}); 
               $step_struct{$step_name}->{after} = \@after ;
             }
             
             elsif ( $step_condition eq 'queue' ) { 
               $step_struct{$step_name}->{queue} =trim( $step_hash->{$step} );
             }
             
             elsif ( $step_condition eq 'cores' ) { 
               $step_struct{$step_name}->{cores} =trim( $step_hash->{$step} );
             }
             elsif( $step_condition eq 'groupby' ) {         
               my @condition_params = split( /\./,$step);            
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = $step_condition;
               my @params = @condition_params[2 .. $#condition_params];
               $step_struct{$step_name}->{condition_params} = \@params;
             }
             
             # get placeholders
             if( ! exists( $step_struct{$step_name}->{placeholders} ) ){$step_struct{$step_name}->{placeholders} = undef;}#initialise to undef
             if( ( ! defined $step_condition) or ($step_condition eq 'once') or ($step_condition eq 'output') or ($step_condition eq 'groupby') ){
               #my (@placeholders) = ( $step_hash->{$step} =~ /\[\%\s+([a-z0-9\.]+)\s\%\]/g );
               my (@placeholders) = ( $step_hash->{$step} =~ /\[\%\s+([\w\-\.]+)\s+\%\]/g ); #\w is alphanumeric plus _, added more spaces at end. Consider /\[\%\s+([a-z0-9_][\w\.]+)\s+\%\]/g enforcing lower case start.
               if ( @placeholders >= 1){ 
                  $step_struct{$step_name}->{placeholders} = \@placeholders;
               }; 
             }   
  
      }
      return \%step_struct;
  }
  
  1;
APP_PIPELINE_LITE4_PARSER

$fatpacked{"App/Pipeline/Lite4/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_RESOLVER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Resolver ;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  use YAML::Any;
  use List::Util qw(max reduce);
  use Data::Table;
  use Data::Dumper;
  use App::Pipeline::Lite4::Template::TinyMod;
  use App::Pipeline::Lite4::Util;
  use Storable qw(dclone);
  extends 'App::Pipeline::Lite4::Base';
  
  #has pipeline_datasource  => ( isa => 'Data::Table', is => 'rw', lazy_build =>1 );
  has placeholder_hash     => ( isa =>'HashRef', is => 'rw', default => sub {return {}});
  has current_run_num => ( isa => 'Num|Undef', is => 'rw');
  has current_run_dir => (isa => Path, is =>'rw', lazy_build => 1);
  has pipeline_step_struct => ( isa => 'HashRef' , is => 'rw', lazy_build => 1 );
  has pipeline_step_struct_resolved => ( isa => 'HashRef' , is => 'rw', default => sub {{}}  );
  has run_num_dep  => ( isa => 'Num|Undef', is => 'rw');
  has tot_jobs => ( isa => 'Num', is => 'ro', lazy_build => 1);
  #has job_filter_str  => ( isa => 'Str|Undef', is =>'rw');
  has job_filter => ( isa  => 'ArrayRef|Undef', is =>'rw', lazy_build => 1 );
  
  #has step_filter_str => ( isa => 'Str|Undef', is => 'rw'); in base
  has step_filter => ( isa => 'ArrayRef|Undef' , is => 'rw', lazy_build =>1 );
  
  
  #sub _build_pipeline_datasource {
  #    my $self = shift;
  #    my $datasourcefile = path( $self->datasource_file )->absolute;
  #    ouch 'badfile', "Need to provide datasource file location\n" unless defined( $datasourcefile);
  #    #my $t =  App::Pipeline::Lite2::Datasource->new( datasource_file => $datasourcefile );
  #    my $t = Data::Table::fromTSV( $datasourcefile->stringify );
  #}
  
  sub _build_pipeline_step_struct {
       my $self = shift;
       my $yaml = $self->pipeline_parse_file->slurp;
       return Load($yaml);
  }
  
  sub _build_current_run_dir {
      my $self = shift;
      return  path( $self->output_dir, $self->output_run_name . ($self->current_run_num) );
  }
  
  sub _build_tot_jobs {
      my $self = shift;
      return $self->pipeline_datasource->lastRow + 1;
  }
  
  sub _build_job_filter  {
      my $self= shift;
  
      #check the jobs don't exceed the datasource
      my $ds_rows = $self-> pipeline_datasource->nofRow;
  
      if( defined $self->job_filter_str ) {
          #my @jobs_to_keep = $self->job_filter_str->split('\s+');
          #return \@jobs_to_keep;
          my $jobs = $self->_parse_job_filter_str($self->job_filter_str);
          my $max_job = max( @$jobs );
          #$self->logger->debug("Check max job filter row with number of datasource rows: ($ds_rows) ");
          $self->logger->debug("Check max of jobs in job filter: ( @$jobs max = $max_job)
                                 with num of datasource rows: ($ds_rows) ");
          #jobs start from 0
          ouch 'App_Pipeline_Lite4_ERROR', "max job in filter exceeds datasource row." if $max_job >= $ds_rows ;
  
          return $jobs;
      } else {
          return undef;
      }
  }
  
  sub _parse_job_filter_str {
      my $self = shift;
      my $job_filter_str = shift;
      my @job_filters = split ',', $job_filter_str;
      my @jobs;
      foreach my $job_filter (@job_filters){
          if($job_filter =~ '-'){
             my @pair = split '-', $job_filter;
             push @jobs, $pair[0] .. $pair[1];
          }else{
             push @jobs, $job_filter;
          }
  
      }
      return [ App::Pipeline::Lite4::Util::uniq( @jobs ) ];
  }
  
  
  sub _build_step_filter {
      my $self = shift;
      if( defined $self->step_filter_str ) {
          #my ($start_step, $end_step) = $self->step_filter_str =~ /([0-9]+)\-([0-9]+)/;
          my @steps;
          #if(defined($start_step) and defined($end_step)){
          #   @steps = $start_step .. $end_step;
          #   return \@steps;
          #} else {
             @steps = split '\s+', $self->step_filter_str;
             return \@steps;
          #}
      } else {
          return undef;
      }
  }
  
  #does this only need to be done on a per job basis.
  sub _step_filter_on_resolved_step_struct  {
          my $self = shift;
          my $steps = $self->step_filter;
          #warn "@$steps";
          my $resolved_step_struct = $self->pipeline_step_struct_resolved;
          $self->logger->debug( "Steps to keep: @$steps\n");
          foreach my $step_struct (values %$resolved_step_struct) {
              foreach my $step_name ( keys %$step_struct) {
                 $self->logger->debug( "Checking $step_name against filter\n" );
  
                 #### WE WANT ANY####
                 my $code = sub { my $k = shift; return 1 if( $step_name eq $k ); return 0;   };
                 my $dont_delete = reduce { $a || $code->(local $_ = $b)  } 0,  @$steps;
  
                 #delete $step_struct->{$step_name} unless any{ ($step_name eq $_) } any{ ($step_name eq $_) } @$steps;
                 #######
  
                 delete $step_struct->{$step_name} unless $dont_delete; #any{ ($step_name eq $_) } @$steps;
              }
          }
          #the run number must be set to the last run. otherwise we could end up with dependency issues.
          #this might not be good enough, e.g. we may have run a smoke_test - this creates output directories
          #my $last_run_num = App::Pipeline::Lite1::Resolver->new( output_dir => $self->output_dir)->_last_run_number;
          #$self->run_num($last_run_num) unless defined($self->run_num); #the user has already assigned a run number we use this
          #$self->logger->debug("Set run number to " . $self->run_num);
  }
  
  sub _job_filter_on_resolved_step_struct   {
       my $self=shift;
       my $jobs_to_keep= $self->job_filter;
  
       my $resolved_step_struct = $self->pipeline_step_struct_resolved;
       $self->logger->debug( "Jobs to keep: @$jobs_to_keep\n");
  
       $self->logger->debug( "RESOLVED STEP STRUCT BEFORE FILTER: " . Dumper($resolved_step_struct)  );
  
  
       foreach my $job_num (keys %$resolved_step_struct) {
  
            #### WE WANT ANY####
                 my $code = sub { my $k = shift; return 1 if( $job_num eq $k ); return 0;   };
                 my $dont_delete = reduce { $a || $code->(local $_ = $b)  } 0,  @$jobs_to_keep;
            #delete $resolved_step_struct->{$job_num} unless any { ($job_num == $_) } @$jobs_to_keep;
            #######
  
           delete $resolved_step_struct->{$job_num} unless $dont_delete;
       }
  
       $self->logger->debug( "RESOLVED STEP STRUCT AFTER FILTER: " . Dumper($resolved_step_struct)  );
  }
  
  sub resolve {
     my $self = shift;
     # TYPE: ( Path::Class::File :$yaml_infile,  Path::Class::File :$yaml_outfile )
     my $yaml_infile  = shift;
     my $yaml_outfile = shift;
     $self->pipeline_parse_file($yaml_infile); #sets the path to yaml file produced by parser step
     $self->_resolve;
     $yaml_outfile->spew( Dump( $self->pipeline_step_struct_resolved ) );
  }
  
  sub _resolve {
      my $self = shift;
      #$self->clear_pipeline_step_struct_resolved;
      $self->current_run_num( $self->_last_run_number + 1 ) unless defined( $self->current_run_num);
  
      foreach my $row ( 0 .. $self->pipeline_datasource->lastRow ) {
           $self->logger->log("debug", "=== Job $row  ===");
           $self->_add_data_source_to_placeholder_hash( $row);
            #add input file directory to placeholder hash
           $self->_add_input_files_to_placeholder_hash;
  
           # add globals to placeholder hash
           ##$self->_add_dir_to_placeholder_hash ( dir_name => 'global', dir_path => dir( $self->output_dir , 'run' . ($self->current_run_num) ));
           # add data dir to placeholder hash
           ##$self->_add_dir_to_placeholder_hash ( dir_name => 'data', dir_path => dir( $self->output_dir->parent ) );
  
           # add in the output files expected for each step to the placeholder hash
           $self->_add_steps_in_step_struct_to_placeholder_hash($row);
           $self->_create_directory_structure_from_placeholder_hash;
  
           # add software to placeholder hash - MUST GO AFTER CREATE DIRECTORY
           # OTHERWISE DIRECTORIES WILL BE MADE FOR SOFTWARE
           $self->_add_software_to_placeholder_hash;
  
           # add in the output files expected for each step to the placeholder hash
           $self->_add_expected_output_files_to_placeholder_hash( $row);
           $self->_add_expected_output_files_to_jobs_in_placeholder_hash;
           #warn Dumper $self->placeholder_hash;
  
           # validate placeholders against placeholder hash
           $self->_validate_placeholder_hash_with_placeholders;
           # interpolate the cmds in each step and add to new resolved_step_struct
           $self->_interpolate_cmd_in_step_struct_to_resolved_step_struct( $row);
           $self->_step_filter_on_resolved_step_struct if defined $self->step_filter_str;
           $self->_job_filter_on_resolved_step_struct if defined $self->job_filter_str;
           $self->_once_condition_filter_on_resolved_step_struct;
           $self->_groupby_condition_filter_on_resolved_step_struct;
           $self->placeholder_hash({});
      }
      #$self->logger->log( "info", "Final Resolved Step Struct: \n" . Dumper $self->pipeline_step_struct_resolved );
  }
  
  
  =method _add_data_source_to_placeholder_hash
     Reads the data source as specified in $self->pipeline_datasource and
     parses a specified row of the datasource to the placeholder_hash
  =cut
  sub _add_data_source_to_placeholder_hash{
        #TYPE:  Num :$datasource_row
        my $self = shift;
        my $datasource_row = shift;
        my $t = $self->pipeline_datasource;
        my @header = $t->header;
        for my $i (0 .. $t->lastCol ) {
           #print $header[$i], " ", $t->col($i), "\n";
           my @datasource_rows = $t->col($i);
           $self->logger->log( "debug", "Datasource col $i : ".$header[$i] . " =>  $datasource_rows[$datasource_row]");
           #adds in the datasource reference here, so that we can deal specially with datasource stuff later in create_directory_structure
           $self->_placeholder_hash_add_item( "datasource." . $header[$i],  $datasource_rows[$datasource_row]  );
  
      }
  }
  
  
  sub _add_software_to_placeholder_hash {
      my $self = shift;
      return unless defined $self->software_dir;
      my $dir = $self->software_dir;
      return unless $dir->exists;
      my @software = $dir->children;
  
      #add to placeholder;
      for my $i (0 .. $#software) {
         $self->_placeholder_hash_add_item( "software.".$software[$i]->basename, $software[$i]->stringify )
          unless $software[$i]->stringify eq $self->software_ini_file->stringify;
      }
  
      # we then need to add the software in in the software.ini file
      return unless defined $self->software_ini;
      return unless $self->software_ini_file->exists;
      foreach my $software_name ( keys %{ $self->software_ini->{_} }  ) {
          $self->_placeholder_hash_add_item(  "software.$software_name", $self->software_ini->{_}->{$software_name} );
      }
  
  }
  
  
  sub _add_input_files_to_placeholder_hash {
     my $self = shift;
     # read folder called input add to the placeholder hash
     # can add folders to input directory and it will pick the names
     return unless defined $self->input_dir;
     my $dir = $self->input_dir;
     return unless $dir->stat;
  
     ouch 'App_Pipeline_Lite4_ERROR', "The input directory $dir does not exist" unless $dir->stat;
  
     my @files;
  
     my $iter = $dir->iterator( { recurse => 1 } );
     while( my $path = $iter->() ){
          next unless( $path->is_file || $path->is_dir);
          push( @files, $path);
     }
      #add to placeholder;
      for my $i (0 .. $#files) {
         $self->_placeholder_hash_add_item( "input.".$files[$i]->basename,
                                             $files[$i]->stringify );
      }
  }
  
  # placeholder hash is where we have {step0}{file1} = value
  # currently we leave it for the groupby case, so that we just have a long key that still matched fine
  # probably we should have the step and its field names as one key
  # {groupby}{cmp.hmr}{file.name} = /outputdir/job../hmr/file.name
  sub _placeholder_hash_add_item{
     #TYPE: ( Str :$keystr, Str :$value)
     my $self   = shift;
     my $keystr = shift;
     my $value  = shift;
     my @keystr = split('\.', $keystr);
     if( $keystr[0] eq 'jobs'){
  	  @keystr = ( $keystr[0], $keystr[1], join('.', @keystr[2 .. $#keystr]  ) );
  	}else {
        @keystr = ( $keystr[0], join('.', @keystr[1 .. $#keystr]  ) );
  	}
     if (@keystr == 2){
      $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] } = $value ;
      $self->logger->log("debug", " _placeholder_hash_add_item:  Adding @keystr and $value. Value from hash: " . $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] });
  
     }
      if (@keystr == 3){
         $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] }{ $keystr[2] } = $value;
     }
  }
  
  # this method could be broken down into
  # _add_steps_to_placeholder_hash
  # _add_all_job_steps_to_placeholder_hash
  # or leave it like this, except call it _add_steps_to_placeholder_hash
  # as we are using the same mechanism to generate the file locations.
  #
  # this is a horrible function and needs to be fixed and refactored in someway
  # the reason we loop over all jobs is because any job can still refer tot_jobs
  # groupby and jobs placeholders if they wish... not entirely true for groupby
  # we would have to bring in the syntax to allow a specific group to be instantiated using
  # groupby.type=A.file.txt or something like that.
  # at the moment if this is done, then one group is given (the one where the group values are top of an ascending perl sort
  
  sub _add_steps_in_step_struct_to_placeholder_hash {
     #TYPES: ( Num :$job_num ){
     my $self = shift;
     my $JOB_NUM = shift;
     my $step_struct = $self->pipeline_step_struct; # we have placeholders parsed for each step
     #warn "JOB_NUM $JOB_NUM";
     foreach my $step_name (keys %$step_struct ){
        $self->logger->log( "debug", "Processing Pipeline to placeholder hash step " . $step_name);
        my $placeholders = $step_struct->{$step_name}->{placeholders};
        next unless defined($placeholders);
        foreach my $placeholder ( @$placeholders ) {
  
              #
              # A placeholder that references a step, should be mentioned in that step.
              # I.e We do not need to worry about it if it appears in other steps.
              # Thus we only process the placeholders in step X that mention this step X.
              # -----
  
              my $output_files;
              my @output_run_dir;
              # case 1. stepX.fileY
              $self->logger->debug("step $step_name. Processing $placeholder");
              #my $placeholder_rgx = qr/(step$step_num)(\.(.+))*/;
              my $placeholder_rgx = qr/^($step_name)(\.(.+))*$/;
              if( @output_run_dir = $placeholder =~ $placeholder_rgx ){
                 $self->logger->debug("step $step_name. Got " . Dumper(@output_run_dir) . " from $placeholder");
                 @output_run_dir = @output_run_dir[0,2]; # we don't want [1], so @output_run_dir is 2 length array
                 if( defined $output_run_dir[1] ){ # if the 2nd element is defined e.g. normally a filename like note.txt
                     # specific case for steps that are once - they can only refer to a single job directory
  
                     # 2/07/2014
                     # because this is being done for every row in the datasource then we will be making a once step
                     # for each job/row and then later pruning those steps that we dont need - i.e. we only want to have the
                     # job0 step for a once condition. It should also mean that for row0/job0, any placeholder would get job0 path names
                     # so this really shouldn't be needed, I'm not sure I understand why it's there.
                     if ( defined (   $step_struct->{$step_name}->{condition} )){
  
                        if( $step_struct->{$step_name}->{condition} eq 'once' ){
                            my $min_job = 0;
                            my $jobs = $self->job_filter;
                            ($min_job) = sort {$a <=> $b} @$jobs if defined($jobs);
                            $output_files = $self->_generate_file_output_location($min_job, \@output_run_dir)->stringify;
                        }else {
                            # we may have to deal with a case here for groupby
                            $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;
                        }
                     }else{
                            $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;
                     }
  
                     #the below condition is just weird - by defn $output_run_dir[1] is !defined,
                     #and $output_run_dir[2] should not exist.
                     # anyway this below is just the case where the step name exists.
                 }elsif ( ( ! defined $output_run_dir[1] ) and ( ! defined $output_run_dir[2] ) and ( defined $output_run_dir[0] ) ) {
                    pop @output_run_dir; #remove last entry because it def can't be undefined I guess, no, remove last entry because we only want the step dir
                    $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;
                    #warn "PLACEHOLDER", $placeholder;
                    #warn "OUTPUT RUN DIR (NORMAL PLCHOLDER) ". Dumper @output_run_dir;
                    #warn "OUTPUTFILES(NORMAL PLCHOLDER) ".$output_files;
                 }
                 $self->logger->debug("step $step_name. Extracted a run dir from: @output_run_dir. Full path is $output_files ");
              }
  
              # case 2.  jobs.stepX.fileY
              # note that because we don't check for conditions in this function
              # then having "jobs...." allows us to identify placeholders that are
              # from once conditions.
              # I think we should have conditions here instead, jobs only exists in a once step.
              # although it does give some clarity about what is going on in the summary steps.
              my $jobs_placeholder_rgx = qr/jobs\.([\w\-]+)\.(.+)$/;
              if(@output_run_dir = $placeholder =~ $jobs_placeholder_rgx){
                 # get all the files from a step for all jobs
                 my @stepfiles;
                 my $num_of_jobs = $self->tot_jobs;
                 for my $job_num ( 0 .. $num_of_jobs -1 ) {
                     if( $output_run_dir[0] eq 'datasource' ) {
                        my $t = $self->pipeline_datasource;
                        my @datasource_rows = $t->col( $output_run_dir[1] );
                        push( @stepfiles,$datasource_rows[$job_num] );
                     }else{
                        push( @stepfiles,
                              $self->_generate_file_output_location(
                                  $job_num, \@output_run_dir)->stringify );
                     }
                 }
                 # JOB FILTER
                 my $job_filter = $self->job_filter;
                 @stepfiles = @stepfiles[@$job_filter] if defined ( $job_filter );
                 $output_files = join ' ', @stepfiles;
                 $self->logger->debug("step $step_name. Extracted a run dir from: @output_run_dir. Full path is $output_files ");
              }
  
  
              # case 3. groupby
              # to get the run directory we need to make a regex that takes into account
              # the condition_params - we are parsing [% groupby.type.file.txt %]
              # we have to infer the group by fields from the placeholder regex and not the
              # step condition, because these can occurr in a stp without a groupby condition
              # the only way to do that is to get the header from the datasource and see if there
              # are any matching fields.
  
              if( $placeholder =~ /groupby/ ){ #don't get in the door unless groupby
                 my $groupby_placeholder_rgx;
                 # get the datasource
  
                 my $col_names = $self->pipeline_datasource->{header};
                 #warn "WORKING WITH DATASOURCE: " . $self->datasource_file;
                 #warn "DATASOURCE: " . Dumper $self->pipeline_datasource;
  
                 my $col_names_rgx_str = join "|", @$col_names;
                 my $groupby_placeholder_rgx_str = 'groupby\.('.$col_names_rgx_str . ')\.(' . $col_names_rgx_str . ')*\.*([\w\-]+)\.(.+)$';
                 #warn "PLACEHOLDER $placeholder";
                 #warn "PLACEHOLDER RGX:", $groupby_placeholder_rgx_str;
                 $groupby_placeholder_rgx = qr/$groupby_placeholder_rgx_str/;
                 my @output_run_dir = $placeholder =~  $groupby_placeholder_rgx;
                 #warn "PLACEHOLDER PARTS:", Dumper @output_run_dir;
  
                 # check if the second argument is present
                 my @group_names;
                 if ( defined $output_run_dir[1] ){
  
                     @group_names = @output_run_dir[0,1];
                     @output_run_dir = @output_run_dir[2 .. $#output_run_dir];
  
                 }else{
  
                     @group_names = $output_run_dir[0 ];
                     @output_run_dir = @output_run_dir[2 .. $#output_run_dir];
                 }
                  # warn "OUTPUTDIR @output_run_dir";
                 if ( ! defined $output_run_dir[0] ){
                     ouch 'App_Pipeline_Lite4_ERROR', "The groupby placeholder has a group name that does not exist in the datasource";
                 }
  
                 # now get the mapping of job ids
                 #warn "OUTPUTDIR", "@output_run_dir";
                 my $util = App::Pipeline::Lite4::Util->new;
                 #warn "GROUP NAMES: @group_names";
                 my $job_map_hash = $util->datasource_groupby2( $self->pipeline_datasource, @group_names );
                 #warn Dumper $job_map_hash;
  
                 # So now run through the jobids and make strings of the files
                 # we only do the jobs that we need to do, i.e. since we have grouped into eg 4 groups,
                 # we only want to do the four jobs and these will be done on each iteration of _resolve looop
                 my @grouped_jobs = sort keys %$job_map_hash;
                 my $grouped_job_idx;
                 $grouped_job_idx = ($JOB_NUM <= $#grouped_jobs) ? $JOB_NUM : 0;
                 # for job numbers higher, then you get the first group
                 # this will be implemented later so that you can chose
                 # which group thought someihtng like
                 # [% groupby.type=A.file.txt %]
                 my $grouped_jobs_id = $grouped_jobs[ $grouped_job_idx ];
                 my @stepfiles;
                 my $jobs = $job_map_hash->{$grouped_jobs_id};
                 for my $job_num ( @$jobs){
                     if( $output_run_dir[0] eq 'datasource' ) {
                        my $t = $self->pipeline_datasource;
                        my @datasource_rows = $t->col( $output_run_dir[1] );
                        push( @stepfiles,$datasource_rows[$job_num] );
                    }else{
                     push( @stepfiles, $self->_generate_file_output_location($job_num, \@output_run_dir)->stringify );
                    }
  
                 }
                 my $job_filter = $self->job_filter;
                 @stepfiles = @stepfiles[@$job_filter] if defined ( $job_filter );
                 $output_files = defined $stepfiles[0] ? join ' ', @stepfiles : "";
                 #warn "STEPFILES: $output_files";
  
              }
  
              # add to placeholder hash - if there is something to add
              if( defined( $output_files ) ){
                  $self->_placeholder_hash_add_item( $placeholder, $output_files); #in order key,value
                  $self->logger->debug("step $step_name. Generated file location for placeholder $placeholder as $output_files");
              }
           }
     }
     #warn Dumper $self->placeholder_hash;
  }
  
  =method _create_directory_structure_from_placeholder_hash
    At the moment we  allow directory with 'dir' in the name
    to be created as a directory - e.g. for this scenario
    e.g. 1. some_app --output-dir [ step1.dir ]
    Where some_app requires a pre-existing directory for storing it's output
    We could resolve this issue without using this.
    By doing:
    1. mkdir [% step1.outputdir %]; some_app --output-dir [% step1.outputdir %]
    So it's debatable whether we want automatic creation of directories with 'dir' in the name,
    but will leave for backwards compatability
    THE DIR BEHAVIOUR SHOULD BE DEPRECATED
  =cut
  
  sub _create_directory_structure_from_placeholder_hash {
      my $self = shift;
      $self->logger->debug("Creating directory structure from placeholder hash...");
      # run over hash
      my $placeholder_hash = $self->placeholder_hash;
      $self->logger->debug(Dumper($placeholder_hash));
      foreach my $step (keys %$placeholder_hash ){
         next if( ($step eq 'step0') or ($step eq 'datasource')); # we don't create any directories from the source step values. (which could be filenames)
         next if( ($step eq 'groupby')); # don't make directory on a groupby
         foreach my $param (keys $placeholder_hash->{$step} ){
             if ($param =~ /dir/) {
                 my $dir = path( $placeholder_hash->{$step}->{$param} );
                 #make_path($dir->stringify);
                 $dir->mkpath;
                 $self->logger->debug("Making directory: $dir" );
             } else {
                my $file = path( $placeholder_hash->{$step}->{$param} );
                #make_path($file->parent->stringify);
                $file->parent->mkpath;
                $self->logger->debug("Making directory (step $step): " . $file->parent->stringify );
  
             }
         }
      }
  }
  
  # processing the "X.output file1 file2 .."  lines
  sub _add_expected_output_files_to_placeholder_hash {
       # TYPE: ( Num :$job_num )
       my $self = shift;
       my $job_num = shift;
       my $step_struct = $self->pipeline_step_struct; # we have outputfiles parsed for each step
       foreach my $step_name (keys %$step_struct ){
          $self->logger->debug( "Processing expected output file for Step: " . $step_name);
          $self->logger->debug("Make filepaths and placeholder hash entry for stated outputs of step $step_name");
          my $file_num = 1;
          $self->logger->debug("So far there are " . ($file_num - 1) . " file(s) registered as outputs for this step");
          my $outputfiles = $step_struct->{$step_name}->{outputfiles};
          if( defined( $outputfiles) ) {
              foreach my $outputfile ( @$outputfiles ) {
                    #output_path_in_run_dir should be output_path_in_job_dir
                    #check whether the file_path is absolute, if its absolute then we don't generate anything for it
                   # if($step_name =~ /^[1-9][0-9]*[a-z]*$/){
                   #   my $file_path = $self->_generate_file_output_location( $job_num, ['step'. $step_name , $outputfile] );
                   #   $self->placeholder_hash->{"step$step_name"}{"output$file_num"}=$file_path->stringify;
                   #   $self->logger->debug( "Made step$step_name output$file_num : " . $file_path->stringify);
                   #   $file_num++;
                   # }else{
                      my $file_path = $self->_generate_file_output_location( $job_num, [ $step_name , $outputfile] );
                      $self->placeholder_hash->{"$step_name"}{"output$file_num"}=$file_path->stringify;
                      $self->logger->debug( "Made $step_name output$file_num : " . $file_path->stringify);
                      $file_num++;
                   # }
              }
          }
       }
  }
  
  sub _add_expected_output_files_to_jobs_in_placeholder_hash {
      my $self = shift;
      #get the expected output files
      my $step_struct = $self->pipeline_step_struct;
      my $placeholder_hash = $self->placeholder_hash;
      return if( ! exists $placeholder_hash->{jobs} );
      my $jobs = $placeholder_hash->{jobs};
      foreach my $step (keys %$jobs){
         next if $step eq 'datasource';
         my $filenames_and_paths = $jobs->{$step};
         my @filenames = keys %$filenames_and_paths;
         foreach my $filename (@filenames){
           my ($output_num) = $filename =~ /output([0-9]+)/;
           next unless defined( $output_num);
           my $outputfiles = $step_struct->{$step}->{outputfiles};
           my $name_of_output_file  = $outputfiles->[$output_num-1];
           $filenames_and_paths->{$filename}  =~ s/output$output_num/$name_of_output_file/g;
         }
      }
  }
  
  =method _validate_placeholder_with_placeholders
  
     What happens if you add a non existant placeholder e.g. [% step0.fil %] ?
     The parser has parsed out this placeholder - so it is part of the step_struct placeholders for each step
     But, it won't have a corresponding value in the placeholder hash, since it not of the right form.
     Not having a value, might be desired behaviour for somethings (this could be warned),
     But not existing in the hash is an error.
  
  =cut
  
  sub _validate_placeholder_hash_with_placeholders {
     my $self = shift;
     #foreach step check that we have the right stuff in the placeholder hash
      my $step_struct = $self->pipeline_step_struct;
      my %problem_placeholders;
      foreach my $step_name ( keys %$step_struct) {
         my $placeholders = $step_struct->{$step_name}->{placeholders};
         $self->logger->debug( "Validating Step: " . $step_name);
          foreach my $placeholder (@$placeholders) {
             #if($placeholder =~ /^datasource\./){
             #   ($placeholder ) = $placeholder =~ /datasource\.(.+)$/;
             #}
             #ouch 'App_Pipeline_Lite2_Error', "Check the placeholder $placeholder - it is incorrectly named."
             #  . Dumper ($self->placeholder_hash)
             #  unless $self->_placeholder_hash_check_item_exists( keystr => $placeholder );
             $problem_placeholders{ $placeholder } = 1  unless $self->_placeholder_hash_check_item_exists(  $placeholder );;
          }
      }
      my @problem_placeholders = keys %problem_placeholders;
      my $problem_placeholders = join "\n", @problem_placeholders ;
      ouch 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER', "Check the placeholders:\n$problem_placeholders\n"
               if @problem_placeholders > 0;
  
  }
  
  sub _interpolate_cmd_in_step_struct_to_resolved_step_struct {
      # ( Num :$job_num ) {
      my $self = shift;
      my $job_num = shift;
      my $step_struct = $self->pipeline_step_struct;
      $self->logger->debug("Step struct has : " . Dumper( $step_struct ));
      $self->logger->debug("Placeholder hash has : " . Dumper ( $self->placeholder_hash ) );
      my %output_hash;
      my $interpolated_cmd;
      my $interpolated_output;
      my $new_step_struct = dclone($step_struct);
      my $tt = App::Pipeline::Lite4::Template::TinyMod->new;
      foreach my $step ( keys %$step_struct) {
         my $cmd = $step_struct->{$step}->{cmd};
         $interpolated_cmd = $tt->_process($self->placeholder_hash, $cmd);
         $new_step_struct->{$step}->{cmd} =$interpolated_cmd;
         $interpolated_cmd = '';
  
         #also do for output line
  
         if( exists $step_struct->{$step}->{outputfiles} ){
             my $output_files = $step_struct->{$step}->{outputfiles};
              $new_step_struct->{$step}->{outputfiles} = [];
             foreach my $output (@$output_files){
                 $interpolated_output = $tt->_process($self->placeholder_hash, $output);
                 my $outputfiles = $new_step_struct->{$step}->{outputfiles};
                 push(@$outputfiles, $interpolated_output); #CHECK THIS IN TEST
                 $interpolated_output = '';
             }
         }
      }
      $self->pipeline_step_struct_resolved->{$job_num} = $new_step_struct;
  }
  
  
  sub _placeholder_hash_check_item_exists{
      # TYPE: Str :$keystr
      my $self = shift;
      my $keystr = shift;
      my @keystr = ();
      @keystr = split('\.', $keystr) if ($keystr =~ /\./);
      return exists $self->placeholder_hash->{ $keystr } if( @keystr == 0);
  
      if( $keystr[0] eq 'jobs'){
  	  @keystr = ( $keystr[0], $keystr[1], join('.', @keystr[2 .. $#keystr]  ) );
  	}else {
        @keystr = ( $keystr[0], join('.', @keystr[1 .. $#keystr]  ) );
  	}
  
      return exists $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] } if @keystr == 2;
      return exists $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] }{ $keystr[2] } if @keystr == 3;
  }
  
  sub _once_condition_filter_on_resolved_step_struct {
     my $self = shift;
     my $resolved_step_struct = $self->pipeline_step_struct_resolved;
     my @keys = sort {$a <=> $b } keys %$resolved_step_struct;
     shift @keys; #remove the lowest job
     $self->logger->debug("Deleting once steps in these steps: @keys");
     foreach my $job_num (@keys){
         my $job = $resolved_step_struct->{$job_num};
         foreach my $step (keys %$job) {
            next unless ( exists  $job->{$step}->{condition}  );
            next unless ( defined $job->{$step}->{condition}  );
            if ( $job->{$step}->{condition} eq 'once') {
                  $self->logger->debug("Deleting once step in $job_num");
                  delete $job->{$step};
            }
         }
     }
  }
  
  sub _groupby_condition_filter_on_resolved_step_struct {
      my $self = shift;
      my $resolved_step_struct = $self->pipeline_step_struct_resolved;
      my @keys = sort {$a <=> $b } keys %$resolved_step_struct;
      # need to get the number of jobs to shift off.
      my $util = App::Pipeline::Lite4::Util->new;
  
      #shift @keys for 0 .. $num_grouped_jobs - 1; #remove the X lowest jobs depending on the step groupby clause
      $self->logger->debug("Consider deleting groupby steps in these steps: @keys");
      foreach my $job_num (@keys){
         my $job = $resolved_step_struct->{$job_num};
         foreach my $step (keys %$job) {
            next unless ( exists  $job->{$step}->{condition}  );
            next unless ( defined $job->{$step}->{condition}  );
            if ( $job->{$step}->{condition} eq 'groupby') {
                  my $params = $job->{$step}->{condition_params};
                  my $num_grouped_jobs = $util->datasource_groupby2_num_groups($self->pipeline_datasource, @$params);
                  if( $job_num >= $num_grouped_jobs){
                      $self->logger->debug("Deleting groupby step $step in $job_num");
                      delete $job->{$step};
                  }
            }
         }
     }
  }
  
  
  
  sub _generate_file_output_location {
     # TYPE:( :$job_num, :$output_path_in_run_dir )
     my ($self, $job_num, $output_path_in_run_dir) = @_;
     if ( defined $self->run_num_dep ) {
        my $steps = $self->step_filter;
  
        #### WE WANT ANY####
        my $code = sub { my $k = shift; return 1 if( $output_path_in_run_dir->[0] eq $k ); return 0;   };
        my $valid_step = reduce { $a || $code->(local $_ = $b)  } 0,  @$steps;
        # my $valid_step = any{ ($output_path_in_run_dir->[0] =~ $_) } @$steps;
        ###############
  
        if ( !$valid_step ) {
         my $alt_run_dir = path( $self->output_dir, $self->output_run_name . ($self->run_num_dep) );
         return path( $alt_run_dir , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
        }
     }
     return path( $self->current_run_dir , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
     # return file( $self->output_dir, 'run' . ($self->current_run_num) , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
  }
  
  =method _run_number
     Provides the last run number by looking at previous run directory numbers
  =cut
  ## THIS IS IN BASE NOW - REMOVE
  sub _last_run_number {
      my $self=shift;
      #read in files in data directory
      #order by run number
      # - if none then run number is 1.
      my $run_num = max map { if( $_ =~ /run([0-9]+)/){$1}else{} } $self->output_dir->children;
      $run_num = 0 unless (defined $run_num);
      return $run_num;
  }
  
  1;
APP_PIPELINE_LITE4_RESOLVER

$fatpacked{"App/Pipeline/Lite4/SetupPipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_SETUPPIPELINE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::SetupPipeline ;
  use Moo;
  use MooX::late;
  
  extends 'App::Pipeline::Lite4::Base';
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
   
  sub create_pipeline_directory {
      my $self=shift;
      my $based_on = shift; # PARAMETER TYPE: ( Path::Tiny $based_on? ) i.e. optional 
      
      my $dir             = $self->pipeline_dir;
      my $output_dir      = $self->output_dir;
      my $input_dir       = $self->input_dir;
      my $pipeline_file   = $self->pipeline_file;
      my $test_data_file  = $self->test_data_file;
      my $datasource_file = $self->datasource_file;
      my $software_dir    = $self->software_dir;
      my $sys_dir         = $self->sys_dir;
      ouch 'App_Pipeline_Lite4_Error', "That pipeline already exists."  if $dir->exists;
      $dir->mkpath();  
      $output_dir->mkpath();
      $input_dir->mkpath();
      $software_dir->mkpath();
      $sys_dir->mkpath();
      
      #set output file and read to config file
      $self->config->{_}->{output_dir} = $output_dir->absolute->stringify;
      $self->config->{_}->{input_dir}  = $input_dir->absolute->stringify;
  
      $self->config->write($self->config_file->absolute->stringify); 
      
      #create a small pipeline file and a dummy test data directory
   
      $pipeline_file->spew("seq. seq [% datasource.N %] | egrep -v '[% datasource.filter %]' > [% seq.filterseq.txt %]");
      $test_data_file->parent->mkpath();
      #$test_data_file->spew("line1\nline2\nline3");    
  my $ds = "N\tfilter\tgroup\tname
  12\t5|6\tA\tjames
  15\t7|8\tB\tnozomi
  16\t9|10\tA\tryan
  20\t12|13\tB\ttiffiny";
       
      #create a small datasource file
      #my $datasource = "step0.file1\n" . $test_data_file->absolute->stringify;
      $datasource_file->spew($ds);
      $self->create_logfile_config;
  }
  
  
  sub create_logfile_config {
     my $self = shift; 
     my $default = 
     { 
       file => {
                filename => defined($self->logfile) ? $self->logfile : "/tmp/".__PACKAGE__.".log",
                maxlevel => "debug",
                minlevel => "warning",
                message_layout => "%T [%L] [%p] line %l: %m",
              }
     };
     my $conf_yaml  = Dump($default);
     $self->logconffile->spew($conf_yaml);  
  }
  1;
APP_PIPELINE_LITE4_SETUPPIPELINE

$fatpacked{"App/Pipeline/Lite4/Template/TinyMod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_TEMPLATE_TINYMOD';
  package App::Pipeline::Lite4::Template::TinyMod;
  
  # Load overhead: 40k
  
  #use 5.00503;
  use strict;
  
  $Template::Tiny::VERSION = '1.12';
  
  # Evaluatable expression
  my $EXPR = qr/ [a-z_\-][\-\w.]* /xs;
  
  # Opening [% tag including whitespace chomping rules
  my $LEFT = qr/
  	(?:
  		(?: (?:^|\n) [ \t]* )? \[\%\-
  		|
  		\[\% \+?
  	) \s*
  /xs;
  
  # Closing %] tag including whitespace chomping rules
  my $RIGHT  = qr/
  	\s* (?:
  		\+? \%\]
  		|
  		\-\%\] (?: [ \t]* \n )?
  	)
  /xs;
  
  sub new {
  	bless { @_[1..$#_] }, $_[0];
  }
  
  sub _process {
  	my ($self, $stash, $text) = @_;
      # Resolve expressions
  
  	$text =~ s/
  		$LEFT ( $EXPR ) $RIGHT
  	/
  		eval {
  			$self->_expression($stash, $1)
  			. '' # Force stringification
  		}
  	/gsex;
  	return $text;
  }
  
  
  sub _expression {
  	my $cursor = $_[1];
  	
  	my @path   = split /\./, $_[2];
  	if( $path[0] eq 'jobs'){
  	  @path = ( $path[0], $path[1], join('.', @path[2 .. $#path]  ) ); 
  	}else {
        @path = ( $path[0], join('.', @path[1 .. $#path]  ) );
  	}
  	
  	foreach ( @path ) {
  		# Support for private keys
  		return undef if substr($_, 0, 1) eq '_';
  
  		# Split by data type
  		my $type = ref $cursor;
  		
  		#if ( $type eq 'ARRAY' ) {
  		#	return '' unless /^(?:0|[0-9]\d*)\z/;
  		#	$cursor = $cursor->[$_];
  		#} elsif ( $type eq 'HASH' ) {
  		#	$cursor = $cursor->{$_};
  		#} elsif ( $type ) {
  		#	$cursor = $cursor->$_();
  		#} else {
  		#	return '';
  		#}
  		if ( $type eq 'HASH' ) {
  			$cursor = $cursor->{$_};
  	    }else {
  		  return '';	
          }
  		
  	}
  	return $cursor;
  }
APP_PIPELINE_LITE4_TEMPLATE_TINYMOD

$fatpacked{"App/Pipeline/Lite4/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_UTIL';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Util ;
  use Moo;
  use Term::UI;
  use Term::ReadLine; 
  use Path::Tiny;
  use Time::Piece;
  use Data::Dumper;
  extends 'App::Pipeline::Lite4::Base';
   
  use Ouch;
  
  sub view_file_with_editor {
      my $self = shift; 
      my $filename = shift; # PARAMETER TYPE: ( Path::Tiny $filename ) 
      
      my $editor = $self->system_config->{_}->{editor} ; #check system config first     
      ouch 'App_Pipeline_Lite4_Error', "No pipeline editor set, try --editor EDITOR.  (e.g. --editor vim)" unless defined($editor);    
      my $cmd = qq{$editor $filename};
      
      eval {
        system($cmd);
      };
      
      if ( hug ) {
        ouch 'App_Pipeline_Lite4_Error', "Viewing the file with the editor '$editor' did not work. Perhaps set something different in system config.";    
      }
  }
  
  sub set_editor  {
      my $self = shift;
      my $editor = shift; # TYPE: ( Str $editor  )
      $self->system_config->{_}->{editor}  = $editor;
      $self->system_config->write($self->system_config_file);
      $self->system_logger->log( "info", "Set $editor as default editor");
  }
  
  sub ask_for_description {
    #( Num $run_num ) {
    my $self = shift;  
    my $term = Term::ReadLine->new('describe-run');
      
    my $print_me = <<PRINTME;
       
       *************
        Description
       -------------    
  PRINTME
      
      my $bool = $term->ask_yn(
              prompt => "Do you want to describe this run?"            
              );
            
     if($bool) {
       my $desc = $term->get_reply(
              print_me => $print_me,
              prompt => "Enter description: ",
       ); 
     }  
  }
  
  sub append_description {
    my $self         = shift;  
    my $run_info     = shift // "";
    my $message      = shift // "";
    my $append_file  = $self->pipeline_submission_file;
    my $t = localtime;
    my $run_desc = join "\t", $t->datetime, $run_info, $message;
    $run_desc .= "\n";
    my $path = path($append_file)->append($run_desc); 
  }
  
  sub uniq {
    my %seen;
    return grep { !$seen{$_}++ } @_;
  }
  
  sub datasource_groupby {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    while( my $row = $next->() ){ 
      #warn Dumper $row;   
      push( @{ $group_hash{ $row->{$groupby_field} } }, $i );  
      $i++;
    }
    return \%group_hash; 
  }
  #the idea is to only offer a groupby one attribute, if more than one
  #is required then the datasource should be given an extra column and
  # the two column mergedin to a specific column
  # the exception is for grouptransby which will work with two columns in general I think.
  # for testing purposes we have this here.
  =cut
  sub datasource_groupby2 {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    while( my $row = $next->() ){ 
      #warn Dumper $row;
      
      if( defined($groupby_field1) and defined( $groupby_field2 )){    
          push( @{ $group_hash{$row->{$groupby_field1} .'-' . $row->{$groupby_field2} } } , $i );  
      }elsif( defined($groupby_field1 ) ){
          push( @{ $group_hash{ $row->{$groupby_field1} } }, $i );   
      }else{
          ouch "App_Pipeline_Lite4_Error","No groupby fields to group by";
      }
        
      $i++;
    }
    return \%group_hash; 
  }
  =cut
  sub datasource_groupby2 {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my $grouphash_and_order_array = datasource_groupby2main($datasource_table,$groupby_field1,$groupby_field2);
    return $grouphash_and_order_array->[0];
  }
  
  
  sub datasource_groupby2main {
    #my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    my @group_array;
    my @group_array_unique;
    while( my $row = $next->() ){ 
      #warn Dumper $row;
      if( defined($groupby_field1) and defined( $groupby_field2 )){    
          push( @{ $group_hash{$row->{$groupby_field1} .'-' . $row->{$groupby_field2} } } , $i );  
          push( @group_array, $row->{$groupby_field1} .'-' . $row->{$groupby_field2});
      }elsif( defined($groupby_field1 ) ){
          push( @{ $group_hash{ $row->{$groupby_field1} } }, $i );   
          push( @group_array, $row->{$groupby_field1} );
      }else{
          ouch "App_Pipeline_Lite4_Error","No groupby fields to group by";
      }
        
      $i++;
    }
    @group_array_unique = uniq( @group_array);
    return [ \%group_hash, \@group_array_unique]; 
  }
  
  
  # this gives back group ids in an ordering that
  # is ordered by first instance of group in the datasource
  sub datasource_groupby2_order {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my $grouphash_and_order_array = datasource_groupby2main($datasource_table,$groupby_field1,$groupby_field2);
    return $grouphash_and_order_array->[1];
  }
  
   
  
  sub datasource_groupby2_num_groups {
    my $self = shift;
    my @args = @_;
    #warn "DATASOURC ARGS ," , Dumper @args;
    my $groupby_hash = $self->datasource_groupby2(@args);
    return scalar keys %$groupby_hash;  
  }
  
  sub groupby_placeholder_regex_get_step {
    my $self       = shift;
    my $datasource = shift;
    my $groupby_fields  = shift;
  
    my $col_names = $datasource->{header};
    my $col_names_rgx_str = join "|", @$col_names;               
    my $groupby_placeholder_rgx_str = 'groupby\.('.$col_names_rgx_str . ')\.(' . $col_names_rgx_str . ')*\.*(.+)$';
    
  }
  
  1;
APP_PIPELINE_LITE4_UTIL

$fatpacked{"App/Rad.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD';
  package App::Rad;
  use 5.006;
  use App::Rad::Help;
  use Carp                ();
  use warnings;
  use strict;
  
  our $VERSION = '1.05';
  {
  
  #========================#
  #   INTERNAL FUNCTIONS   #
  #========================#
  
  my @OPTIONS = ();
  
  sub _init {
      my $c = shift;
  
      # instantiate references for the first time
      $c->{'_ARGV'    } = [];
      $c->{'_options'} = {};
      $c->{'_stash'  } = {};
      $c->{'_config' } = {};
      $c->{'_plugins'} = [];
  
      # this internal variable holds
      # references to all special
      # pre-defined control functions
      $c->{'_functions'} = {
          'setup'        => \&setup,
          'pre_process'  => \&pre_process,
          'post_process' => \&post_process,
          'default'      => \&default,
          'invalid'      => \&invalid,
          'teardown'     => \&teardown,
      };
      
      #load extensions
      App::Rad::Help->load($c);
      foreach (@OPTIONS) {
          if ($_ eq 'include') {
              eval 'use App::Rad::Include; App::Rad::Include->load($c)';
              Carp::croak 'error loading "include" extension.' if ($@);
          }
          elsif ($_ eq 'exclude') {
              eval 'use App::Rad::Exclude; App::Rad::Exclude->load($c)';
              Carp::croak 'error loading "exclude" extension.' if ($@);
          }
          elsif ($_ eq 'debug') {
              $c->{'debug'} = 1;
          }
          else {
          	$c->load_plugin($_);
          }
  	}
  	
      # tiny cheat to avoid doing a lot of processing
      # when not in debug mode. If needed, I'll create
      # an actual is_debugging() method or something
      if ($c->{'debug'}) {
          $c->debug('initializing: default commands are: '
              . join ( ', ', $c->commands() )
          );
      }
  }
  
  sub import {
      my $class = shift;
      @OPTIONS  = @_;
  }
  
  sub load_plugin {
      my $c      = shift;
      my $plugin = shift;
  	my $class  = ref $c;
  
      my $plugin_fullname = '';    
  	if ($plugin =~ s{^\+}{} ) {
  		$plugin_fullname = $plugin;
  	}
      else {
          $plugin_fullname = "App::Rad::Plugin::$plugin";
      }
  	eval "use $plugin_fullname ()";
      Carp::croak "error loading plugin '$plugin_fullname': $@\n"
          if $@;
      my %methods = _get_subs_from($plugin_fullname);
  
      Carp::croak "No methods found for plugin '$plugin_fullname'\n"
  		unless keys %methods > 0;
  
  	no strict 'refs';
  	foreach my $method (keys %methods) {
          # don't add plugin's internal methods
          next if substr ($method, 0, 1) eq '_';
  
  		*{"$class\::$method"} = $methods{$method};
  		$c->debug("-- method '$method' added [$plugin_fullname]");
  
          # fill $c->plugins()
          push @{ $c->{'_plugins'} }, $plugin;
  	}
  }
  
  # this function browses a file's
  # symbol table (usually 'main') and maps
  # each function to a hash
  #
  # FIXME: if I create a sub here (Rad.pm) and
  # there is a global variable with that same name
  # inside the user's program (e.g.: sub ARGV {}),
  # the name will appear here as a command. It really 
  # shouldn't...
  sub _get_subs_from {
      my $package = shift || 'main';
      $package .= '::';
      
      my %subs = ();
  
      no strict 'refs';
      while (my ($key, $value) = ( each %{*{$package}} )) {
          local (*SYMBOL) = $value;
          if ( defined $value && defined *SYMBOL{CODE} ) {
              $subs{$key} = $value;
          }
      }
      return %subs;
  }
  
  
  # overrides our pre-defined control
  # functions with any available
  # user-defined ones
  sub _register_functions {
      my $c = shift;
      my %subs = _get_subs_from('main');
  
      # replaces only if the function is
      # in 'default', 'pre_process' or 'post_process'
      foreach ( keys %{$c->{'_functions'}} ) {
          if ( defined $subs{$_} ) {
              $c->debug("overriding $_ with user-defined function.");
              $c->{'_functions'}->{$_} = $subs{$_};
          }
      }
  }
  
  # retrieves command line arguments
  # to be executed by the main program
  sub _get_input {
      my $c = shift;
  
      my $cmd = (defined ($ARGV[0]) and substr($ARGV[0], 0, 1) ne '-')
              ? shift @ARGV
              : ''
              ;
  
      @{$c->argv} = @ARGV;
      $c->{'cmd'} = $cmd;
  
      $c->debug('received command: ' . $c->{'cmd'});
      $c->debug('received parameters: ' . join (' ', @{$c->argv} ));
  
      $c->_tinygetopt();
  }
  
  # stores arguments passed to a
  # command via --param[=value] or -p
  sub _tinygetopt {
      my $c = shift;
  
      my @argv = ();
      foreach ( @{$c->argv} ) {
  
          # single option (could be grouped)
          if ( m/^\-([^\-\=]+)$/o) {
              my @args = split //, $1;
              foreach (@args) {
  				if ($c->options->{$_}) {
  					$c->options->{$_}++;
  				}
  				else {
  					$c->options->{$_} = 1;
  				}
              }
          }
          # long option: --name or --name=value
          elsif (m/^\-\-([^\-\=]+)(?:\=(.+))?$/o) {
              $c->options->{$1} = defined $2 ? $2 
  			                  : 1
                                ;
          }
          else {
              push @argv, $_;
          }
      }
      @{$c->argv} = @argv;
  }
  
  
  #========================#
  #     PUBLIC METHODS     #
  #========================#
  
  sub load_config {
      require App::Rad::Config;
      App::Rad::Config::load_config(@_);
  }
  
  
  #TODO: this code probably could use some optimization
  sub register_commands {
      my $c = shift;
      my %help_for_sub = ();
      my %rules = ();
  
      # process parameters
      foreach my $item (@_) {
          if ( ref ($item) ) {
              Carp::croak '"register_commands" may receive only HASH references'
                  unless ref ($item) eq 'HASH';
              foreach my $params (keys %{$item}) {
                  if ($params eq '-ignore_prefix'
                   or $params eq '-ignore_suffix'
                   or $params eq '-ignore_regexp'
                  ) {
                      $rules{$params} = $item->{$params};
                  }
                  else {
                      $help_for_sub{$params} = $item->{$params};
                  }
              }
          }
          else {
              $help_for_sub{$item} = undef; # no help text
          }
      }
  
      my %subs = _get_subs_from('main');
  
      foreach (keys %help_for_sub) {
  
          # we only add the sub to the commands
          # list if it's *not* a control function
          if ( not defined $c->{'_functions'}->{$_} ) {
  
              # user want to register a valid (existant) sub
              if ( exists $subs{$_} ) {
                  $c->debug("registering $_ as a command.");
                  $c->{'_commands'}->{$_}->{'code'} = $subs{$_};
                  App::Rad::Help->register_help($c, $_, $help_for_sub{$_});
              }
              else {
                  Carp::croak "'$_' does not appear to be a valid sub. Registering seems impossible.\n";
              }
          }
      }
  
      # no parameters, or params+rules: try to register everything
      if ((!%help_for_sub) or %rules) {
          foreach my $subname (keys %subs) {
  
              # we only add the sub to the commands
              # list if it's *not* a control function
              if ( not defined $c->{'_functions'}->{$subname} ) {
  
                  if ( $rules{'-ignore_prefix'} ) {  
                      next if ( substr ($subname, 0, length($rules{'-ignore_prefix'}))
                             eq $rules{'-ignore_prefix'}
                              );
                  }
                  if ( $rules{'-ignore_suffix'} ) {
                      next if ( substr ($subname, 
                                        length($subname) - length($rules{'-ignore_suffix'}),
                                        length($rules{'-ignore_suffix'})
                                       )
                                eq $rules{'-ignore_suffix'}
                              );
                  }
                  if ( $rules{'-ignore_regexp'} ) {
                      my $re = $rules{'-ignore_regexp'};
                      next if $subname =~ m/$re/o;
                  }
  
                  # avoid duplicate registration
                  if ( !exists $help_for_sub{$subname} ) {
                      $c->{'_commands'}->{$subname}->{'code'} = $subs{$subname};
                      App::Rad::Help->register_help($c, $subname, undef);
                  }
              }
          }
      }
  }
  
  
  sub register_command { return register(@_) }
  sub register {
      my ($c, $command_name, $coderef, $helptext) = @_;
      $c->debug("got: " . ref $coderef);
      return undef
          unless ( (ref $coderef) eq 'CODE' );
  
      $c->debug("registering $command_name as a command.");
      $c->{'_commands'}->{$command_name}->{'code'} = $coderef;
      App::Rad::Help->register_help($c, $command_name, $helptext);
      return $command_name;
  }
  
  sub unregister_command { return unregister(@_) }
  sub unregister {
      my ($c, $command_name) = @_;
  
      if ( $c->{'_commands'}->{$command_name} ) {
          delete $c->{'_commands'}->{$command_name};
      }
      else {
          return undef;
      }
  }
  
  
  sub create_command_name {
      my $id = 0;
      foreach (commands()) {
          if ( m/^cmd(\d+)$/ ) {
              $id = $1 if ($1 > $id);
          }
      }
      return 'cmd' . ($id + 1);
  }
  
  
  sub commands {
      return ( keys %{$_[0]->{'_commands'}} );
  }
  
  
  sub is_command {
      my ($c, $cmd) = @_;
      return (defined $c->{'_commands'}->{$cmd}
              ? 1
              : 0
             );
  }
  
  sub command :lvalue { cmd(@_) }
  sub cmd :lvalue {
      $_[0]->{'cmd'};
  }
  
  
  sub run {
      my $class = shift;
      my $c = {};
      bless $c, $class;
  
      $c->_init();
  
      # first we update the control functions
      # with any overriden value
      $c->_register_functions();
  
      # then we run the setup to register
      # some commands
      $c->{'_functions'}->{'setup'}->($c);
  
      # now we get the actual input from
      # the command line (someone using the app!)
      $c->_get_input();
  
      # run the specified command
      $c->execute();
  
      # that's it. Tear down everything and go home :)
      $c->{'_functions'}->{'teardown'}->($c);
  
      return 0;
  }
  
  # run operations 
  # in a shell-like environment
  #sub shell {
  #    my $class = shift;
  #    App::Rad::Shell::shell($class);
  #}
  
  sub execute {
      my ($c, $cmd) = @_;
  
      # given command has precedence
      if ($cmd) {
          $c->{'cmd'} = $cmd;
      }
      else {
          $cmd = $c->{'cmd'};  # now $cmd always has the called cmd
      }
  
      $c->debug('calling pre_process function...');
      $c->{'_functions'}->{'pre_process'}->($c);
  
      $c->debug("executing '$cmd'...");
  
      # valid command, run it
      if ($c->is_command($c->{'cmd'}) ) {
          $c->{'output'} = $c->{'_commands'}->{$cmd}->{'code'}->($c);
      }
      # no command, run default()
      elsif ( $cmd eq '' ) {
          $c->debug('no command detected. Falling to default');
          $c->{'output'} = $c->{'_functions'}->{'default'}->($c);
      }
      # invalid command, run invalid()
      else {
          $c->debug("'$cmd' is not a valid command. Falling to invalid.");
          $c->{'output'} = $c->{'_functions'}->{'invalid'}->($c);
      }
  
      # 3: post-process the result
      # from the command
      $c->debug('calling post_process function...');
      $c->{'_functions'}->{'post_process'}->($c);
  
      $c->debug('reseting output');
      $c->{'output'} = undef;
  }
  
  sub argv    { return $_[0]->{'_ARGV'}     }
  sub options { return $_[0]->{'_options'} }
  sub stash   { return $_[0]->{'_stash'}   }   
  sub config  { return $_[0]->{'_config'}  }
  
  # $c->plugins is sort of "read-only" externally
  sub plugins { 
      my @plugins = @{$_[0]->{'_plugins'}};
      return @plugins;
  }
  
  
  sub getopt {
      require Getopt::Long;
      Carp::croak "Getopt::Long needs to be version 2.36 or above"
          unless $Getopt::Long::VERSION >= 2.36;
  
      my ($c, @options) = @_;
  
      # reset values from tinygetopt
      $c->{'_options'} = {};
  
      my $parser = new Getopt::Long::Parser;
      $parser->configure( qw(bundling) );
  
      my @tARGV = @ARGV; # we gotta stick to our API
      my $ret = $parser->getoptions($c->{'_options'}, @options);
      @{$c->argv} = @ARGV;
      @ARGV = @tARGV;
  
      return $ret;
  }
  
  sub debug {
      if (shift->{'debug'}) {
          print "[debug]   @_\n";
      }
  }
  
  # gets/sets the output (returned value)
  # of a command, to be post processed
  sub output {
      my ($c, @msg) = @_;
      if (@msg) {
          $c->{'output'} = join(' ', @msg);
      }
      else {
          return $c->{'output'};
      }
  }
  
  
  #=========================#
  #     CONTROL FUNCTIONS   #
  #=========================#
  
  sub setup { $_[0]->register_commands( {-ignore_prefix => '_'} ) }
  
  sub teardown {}
  
  sub pre_process {}
  
  sub post_process {
      my $c = shift;
  
      if ($c->output()) {
          print $c->output() . $/;
      }
  }
  
  
  sub default {
      my $c = shift;
      return $c->{'_commands'}->{'help'}->{'code'}->($c);
  }
  
  
  sub invalid {
      my $c = shift;
      return $c->{'_functions'}->{'default'}->($c);
  }
  
  
  }
  42; # ...and thus ends thy module  ;)
  __END__
  
  =head1 NAME
  
  App::Rad - Rapid (and easy!) creation of command line applications
  
  =head1 VERSION
  
  Version 1.04
  
  =head1 SYNOPSIS
  
  This is your smallest working application (let's call it I<myapp.pl>)
  
      use App::Rad;
      App::Rad->run();
  
  That's it, your program already works and you can use it directly via the command line (try it!)
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          help    show syntax and available commands
  
  Next, start creating your own functions (e.g.) inside I<myapp.pl>:
  
      sub hello {
          return "Hello, World!";
      }
  
  And now your simple command line program I<myapp.pl> has a 'hello' command!
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          hello
          help    show syntax and available commands
  
  
     [user@host]$ ./myapp.pl hello
     Hello, World!
  
  You could easily add a customized help message for your command through the 'Help()' attribute:
  
      sub hello 
      :Help(give a nice compliment)
      {
          return "Hello, World!";
      }
  
  And then, as expected:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          hello   give a nice compliment
          help    show syntax and available commands
  
  
  App::Rad also lets you expand your applications, providing a lot of flexibility for every command, with embedded help, argument and options parsing, configuration file, default behavior, and much more:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup {
          my $c = shift;
  
          $c->register_commands( {
                  foo => 'expand your foo!',
                  bar => 'have a drink! arguments: --drink=DRINK',
              });
      }
  
      sub foo {
          my $c = shift;
          $c->load_config('myapp.conf');
  
          return 'foo expanded to ' . baz() * $c->config->{'myfoo'};
      }
  
      # note that 'baz' was not registered as a command,
      # so it can't be called from the outside.
      sub baz { rand(10) }
  
      sub bar {
          my $c = shift;
          if ( $c->options->{'drink'} ) {
              return 'you asked for a ' . $c->options->{'drink'};
          }
          else {
              return 'you need to ask for a drink';
          }
      }
  
          
  
  You can try on the command line:
  
     [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          bar 	have a drink! arguments: --drink=DRINK
          foo 	expand your foo!
          help	show syntax and available commands
  
  
     [user@host]$ ./myapp.pl bar --drink=martini
      you asked for a martini
  
  
  =head1 WARNING
  
  This module is very young, likely to change in strange ways and to have some bugs (please report if you find any!). I will try to keep the API stable, but even that is subject to change (let me know if you find anything annoying or have a wishlist). You have been warned!
  
  
  =head1 DESCRIPTION
  
  App::Rad aims to be a simple yet powerful framework for developing your command-line applications. It can easily transform your Perl I<one-liners> into reusable subroutines than can be called directly by the user of your program.
  
  It also tries to provide a handy interface for your common command-line tasks. B<If you have a feature request to easen out your tasks even more, please drop me an email or a RT feature request.>
  
  =head2 Extending App::Rad - Plugins!
  
  App::Rad plugins can be loaded by naming them as arguments to the C<< use App::Rad >> statement. Just ommit the C<< App::Rad::Plugin >> prefix from the plugin name. For example:
  
     use App::Rad  qw(My::Module);
  
  will load the C<< App::Rad::Plugin::My::Module >> plugin for you!
  
  Developers are B<strongly> encouraged to publish their App::Rad plugins under the C<< App::Rad::Plugin >> namespace. But, if your plugin start with a name other than that, you can fully qualify the name by using an unary plus sign:
  
    use App::Rad  qw(
            My::Module
            +Fully::Qualified::Plugin::Name
    );
  
  Note that plugins are loaded in the order in which they appear.
  
  B<Please refer to the actual plugin documentation for specific usage>. And check out L<< App::Rad::Plugin >> if you want to create your own plugins.
  
  
  =head1 INSTANTIATION
  
  These are the main execution calls for the application. In your App::Rad programs, the B<*ONLY*> thing your script needs to actually (and actively) call is one of the instantiation (or dispatcher) methods. Leave all the rest to your subs. Currently, the only available dispatcher is run():
  
  =head2 run()
  
  You'll be able to access all of your program's commands directly through the command line, as shown in the synopsis.
  
  
  =head1 BUILT-IN COMMANDS
  
  This module comes with the following default commands. You are free to override them as you see fit.
  
  
  =head2 help
  
  Shows help information for your program. This built-in function displays the program name and all available commands (including the ones you added yourself) if a user types the 'help' command, or no command at all, or any command that does not exist (as they'd fall into the 'default' control function which (by default) calls 'help').
  
  You can also display specific embedded help for your commands, either explicitly registering them with C<< $c->register() >> or C<< $c->register_commands() >> inside C<< $c->setup() >> (see respective sections below) or with the Help() attribute:
  
      use App::Rad;
      App::Rad->run();
      
      sub mycmd 
      :Help(display a nice welcome message) 
      {
          return "Welcome!";
      }
  
  the associated help text would go like this:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
  
      Available Commands:
          help 	show syntax and available commands
          mycmd	display a nice welcome message
      
  
  =head1 OTHER BUILT IN COMMANDS (OPT-IN)
  
  The 'include' and 'exclude' commands below let the user include and exclude commands to your program and, as this might be dangerous when the user is not yourself, you have to opt-in on them:
  
     use App::Rad qw(include);  # add the 'include' command
     use App::Rad qw(exclude);  # add the 'exclude' command
  
  though you'll probably want to set them both:
  
     use App::Rad qw(include exclude);
  
  
  =head2 include I<[command_name]> I<-perl_params> I<'your subroutine code'>
  
  Includes the given subroutine into your program on-the-fly, just as you would writing it directly into your program.
  
  Let's say you have your simple I<'myapp.pl'> program that uses App::Rad sitting on your system quietly. One day, perhaps during your sysadmin's tasks, you create a really amazing one-liner to solve a really hairy problem, and want to keep it for posterity (reusability is always a good thing!). 
  
  For instance, to change a CSV file in place, adding a column on position #2 containing the line number, you might do something like this (this is merely illustrative, it's not actually the best way to do it):
  
      $ perl -i -paF, -le 'splice @F,1,0,$.; $_=join ",",@F' somesheet.csv
  
  And you just found out that you might use this other times. What do you do? App::Rad to the rescue!
  
  In the one-liner above, just switch I<'perl'> to I<'myapp.pl include SUBNAME'> and remove the trailing parameters (I<somesheet.csv>):
  
      $ myapp.pl include addcsvcol -i -paF, -le 'splice @F,1,0,$.; $_=join ",",@F'
  
  That's it! Now myapp.pl has the 'addcsvcol' command (granted, not the best name) and you can call it directly whenever you want:
  
      $ myapp.pl addcsvcol somesheet.csv
  
  App::Rad not only transforms and adjusts your one-liner so it can be used inside your program, but also automatically formats it with Perl::Tidy (if you have it). This is what the one-liner above would look like inside your program:
  
      sub addcsvcol {
          my $c = shift;
      
          local ($^I) = "";
          local ($/)  = "\n";
          local ($\)  = "\n";
        LINE: while ( defined( $_ = <ARGV> ) ) {
              chomp $_;
              our (@F) = split( /,/, $_, 0 );
              splice @F, 1, 0, $.;
              $_ = join( ',', @F );
          }
          continue {
              die "-p destination: $!\n" unless print $_;
          }
      }
  
  With so many arguments (-i, -p, -a -F,, -l -e), this is about as bad as it gets. And still one might find this way easier to document and mantain than a crude one-liner stored in your ~/.bash_history or similar.
  
  B<Note:> If you don't supply a name for your command, App::Rad will make one up for you (cmd1, cmd2, ...). But don't do that, as you'll have a hard time figuring out what that specific command does.
  
  B<Another Note: App::Rad tries to adjust the command to its interface, but please keep in mind this module is still in its early stages so it's not guaranteed to work every time. *PLEASE* let me know via email or RT bug request if your one-liner was not correctly translated into an App::Rad command. Thanks!>
  
  
  =head2 exclude I<command_name>
  
  Removes the requested function from your program. Note that this will delete the actual code from your program, so be *extra* careful. It is strongly recommended that you do not use this command and either remove the subroutine yourself or add the function to your excluded list inside I<setup()>.
  
  Note that built-in commands such as 'help' cannot be removed via I<exclude>. They have to be added to your excluded list inside I<setup()>.
  
  
  
  =head1 ROLLING YOUR OWN COMMANDS
  
  Creating a new command is as easy as writing any sub inside your program. Some names ("setup", "default", "invalid", "pre_process", "post_process" and "teardown") are reserved for special purposes (see the I<Control Functions> section of this document). App::Rad provides a nice interface for reading command line input and writing formatted output:
  
  
  =head2 The Controller
  
  Every command (sub) you create receives the controller object "C<< $c >>" (sometimes referred as "C<< $self >>" in other projects) as an argument. The controller is the main interface to App::Rad and has several methods to easen your command manipulation and execution tasks.
  
  
  =head2 Reading arguments
  
  When someone types in a command, she may pass some arguments to it. Those arguments can be accessed in four different ways, depending on what you want. This way it's up to you to control which and how many arguments (if at all) you want to receive and/or use. They are:
  
  =head3 @ARGV
  
  Perl's @ARGV array has all the arguments passed to your command, without the command name (use C<< $c->cmd >> for this) and without any processing (even if you explicitly use C<< $c->getopt >>, which will change $c->argv instead, see below). Since the command itself won't be in the @ARGV parameters, you can use it in each command as if they were stand-alone programs.
  
  =head3 $c->options
  
  App::Rad lets you automatically retrieve any POSIX syntax command line options (I<getopt-style>) passed to your command via the $c->options method. This method returns a hash reference with keys as given parameters and values as... well... values. The 'options' method automatically supports two simple argument structures:
  
  Extended (long) option. Translates C<< --parameter or --parameter=value >> into C<< $c->options->{parameter} >>. If no value is supplied, it will be set to 1.
  
  Single-letter option. Translates C<< -p >> into C<< $c->options->{p} >>.
  
  Single-letter options can be nested together, so C<-abc> will be parsed into C<< $c->options->{a} >>, C<< $c->options->{b} >> and C<< $c->options{c} >>, while C<--abc> will be parsed into C<< $c->options->{abc} >>. We could, for instance, create a dice-rolling command like this:
  
      sub roll {
          my $c = shift;
  
          my $value = 0;
          for ( 1..$c->options->{'times'} ) {
              $value += ( int(rand ($c->options->{'faces'}) + 1));
          }
          return $value;
      }
  
  And now you can call your 'roll' command like:
  
      [user@host]$ ./myapp.pl roll --faces=6 --times=2
  
  Note that App::Rad does not control which arguments can or cannot be passed: they are all parsed into C<< $c->options >> and it's up to you to use whichever you want. For a more advanced use and control, see the C<< $c->getopt >> method below.
  
  Also note that single-letter options will be set to 1. However, if a user types them more than once, the value will be incremented accordingly. For example, if a user calls your program like so:
  
     [user@host]$ ./myapp.pl some_command -vvv
  
  or
  
     [user@host]$ ./myapp.pl some_command -v -v -v
  
  then, in both cases, C<< $c->options->{v} >> will be set to 3. This will let you easily keep track of how many times any given option was chosen, and still let you just check for definedness if you don't care about that. 
  
  
  =head3 $c->argv
  
  The array reference C<< $c->argv >> contains every argument passed to your command that have B<not> been parsed into C<< $c->options >>. This is usually a list of every provided argument that didn't start with a dash (-), unless you've called C<< $c->getopt >> and used something like 'param=s' (again, see below).
  
  =head3 $c->getopt (Advanced Getopt usage)
  
  App::Rad is also smoothly integrated with Getopt::Long, so you can have even more flexibility and power while parsing your command's arguments, such as aliases and types. Call the C<< $c->getopt() >> method anytime inside your commands (or just once in your "pre_process" function to always have the same interface) passing a simple array with your options, and refer back to $c->options to see them. For instance: 
  
      sub roll {
          my $c = shift;
  
          $c->getopt( 'faces|f=i', 'times|t=i' )
              or $c->execute('usage') and return undef;
  
          # and now you have $c->options->{'faces'} 
          # and $c->options->{'times'} just like above.
      }
  
  This becomes very handy for complex or feature-rich commands. Please refer to the Getopt::Long module for more usage examples.
  
  
  B<< So, in order to manipulate and use any arguments, remember: >>
  
  =over 6
  
  =item * The given command name does not appear in the argument list;
  
  =item * All given arguments are in C<< @ARGV >>
  
  =item * Automatically processed arguments are in C<< $c->options >>
  
  =item * Non-processed arguments (the ones C<< $c->options >> didn't catch) are in $c->argv
  
  =item * You can use C<< $c->getopt >> to have C<< Getopt::Long >> parse your arguments (it will B<not> change C<< @ARGV >>)
  
  =back
  
  
  =head2 Sharing Data: C<< $c->stash >>
  
  The "stash" is a universal hash for storing data among your Commands:
  
      $c->stash->{foo} = 'bar';
      $c->stash->{herculoids} = [ qw(igoo tundro zok gloop gleep) ];
      $c->stash->{application} = { name => 'My Application' };
  
  You can use it for more granularity and control over your program. For instance, you can email the output of a command if (and only if) something happened:
  
      sub command {
          my $c = shift;
          my $ret = do_something();
  
          if ( $ret =~ /critical error/ ) {
              $c->stash->{mail} = 1;
          }
          return $ret;
      }
  
      sub post_process {
          my $c = shift;
  
          if ( $c->stash->{mail} ) {
              # send email alert...
          }
          else {
              print $c->output . "\n";
          }
      }
  
  
  
  =head2 Returning output
  
  Once you're through, return whatever you want to give as output for your command:
  
      my $ret = "Here's the list: ";
      $ret .= join ', ', 1..5;
      return $ret;
      
      # this prints "Here's the list: 1, 2, 3, 4, 5"
  
  App::Rad lets you post-process the returned value of every command, so refrain from printing to STDOUT directly whenever possible as it will give much more power to your programs. See the I<post_process()> control function further below in this document.
  
  
  =head1 HELPER METHODS
  
  App::Rad's controller comes with several methods to help you manage your application easily. B<If you can think of any other useful command that is not here, please drop me a line or RT request>.
  
  
  =head2 $c->execute( I<COMMAND_NAME> )
  
  Runs the given command. If no command is given, runs the one stored in C<< $c->cmd >>. If the command does not exist, the 'default' command is ran instead. Each I<execute()> call also invokes pre_process and post_process, so you can easily manipulate income and outcome of every command.
  
  
  =head2 $c->cmd
  
  Returns a string containing the name of the command (that is, the first argument of your program), that will be called right after pre_process.
  
  
  =head3 $c->command
  
  Alias for C<< $c->cmd >>. This longer form is discouraged and may be removed in future versions, as one may confuse it with the C<< $c->commands() >> method, explained below. You have been warned.
  
  
  =head2 $c->commands()
  
  Returns a list of available commands (I<functions>) inside your program
  
  
  =head2 $c->is_command ( I<COMMAND_NAME> )
  
  Returns 1 (true) if the given I<COMMAND_NAME> is available, 0 (false) otherwise.
  
  
  =head2 $c->create_command_name()
  
  Returns a valid name for a command (i.e. a name slot that's not been used by your program). This goes in the form of 'cmd1', 'cmd2', etc., so don't use unless you absolutely have to. App::Rad, for instance, uses this whenever you try to I<include> (see below) a new command but do not supply a name for it.
  
  
  =head2 $c->load_config( I<< FILE (FILE2, FILE3, ...) >> )
  
  This method lets you easily load into your program one or more configuration files written like this:
  
      # comments and blank lines are discarded
      key1 value1
      key2:value2
      key3=value3
      key5           # stand-alone attribute (and inline-comment)
  
  
  =head2 $c->config
  
  Returns a hash reference with any loaded config values (see C<< $c->load_config() >> above).
  
  
  =head2 $c->register ( I<NAME>, I<CODEREF> [, I<INLINE_HELP> ])
  
  Registers a coderef as a callable command. Note that you don't have to call this in order to register a sub inside your program as a command, run() will already do this for you - and if you don't want some subroutines to be issued as commands you can always use C<< $c->register_commands() >> (note the plural) inside setup(). This is just an interface to dinamically include commands in your programs. The function returns the command name in case of success, undef otherwise.
  
  It is also very useful for creating aliases for your commands:
  
      sub setup {
          my $c = shift;
          $c->register_commands();
  
          $c->register('myalias', \&command);
      }
  
      sub command { return "Hi!" }
  
  and, on the command line:
  
      [user@host]$ ./myapp.pl command
      Hi!
  
      [user@host]@ ./myapp.pl myalias
      Hi!
  
  The last parameter is optional and lets you add inline help to your command:
  
      $c->register('cmd_name', \&cmd_func, 'display secret of life');
  
  =head3 $c->register_command ( I<NAME>, I<CODEREF> [, I<INLINE_HELP> ] )
  
  Longer alias for C<< $c->register() >>. It's use is disencouraged as one may confuse it with C<register_commands> (note the plural) below. Plus you type more :)
  As such, this method may be removed in future versions. You have been warned!
  
  =head2 $c->register_commands()
  
  This method, usually called during setup(), tells App::Rad to register subroutines as valid commands. If called without any parameters, it will register B<all> subroutines in your main program as valid commands (note that the default behavior of App::Rad is to ignore subroutines starting with an underscore '_'). You can easily change this behavior using some of the options below:
  
  =head3 Adding single commands
  
      $c->register_commands( qw/foo bar baz/ );
  
  The code above will register B<only> the subs C<foo>, C<bar> and C<baz> as commands. Other subroutines will B<not> be valid commands, so they can be used as internal subs for your program. You can change this behavior with the bundled options - see 'Adding several commands' and 'Putting it all together' below.
  
  =head3 Adding single commands (with inline help)
  
      $c->register_commands(
              {
                  dos2unix => 'convert text files from DOS to Unix format',
                  unix2dos => 'convert text files from Unix to DOS format',
              }
      );
  
  You can pass a hash reference containing commands as keys and a small help string as their values. The code above will register B<only> the subs C<dos2unix> and C<unix2dos>, and the default help for your program will become something like this:
  
      [user@host]$ ./myapp.pl
      Usage: myapp.pl command [arguments]
      
      Available Commands:
          dos2unix    convert text files from DOS to Unix format
          help        show syntax and available commands
          unix2dos    convert text files from Unix to DOS format
  
  
  =head3 Adding several commands
  
  You can pass a hash reference as an argument, letting you choose which subroutines to add as commands. The following keys may be used (note the dash preceding each key):
  
  =over 4
  
  =item * C<< -ignore_prefix >>: subroutine names starting with the given string won't be added as commands
  
  =item * C<< -ignore_suffix >>: subroutine names ending with the given string won't be added as commands
  
  =item * C<< -ignore_regexp >>: subroutine names matching the given regular expression (as a string) won't be added as commands
  
  =back
  
  For example:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup { 
          my $c = shift; 
          $c->register_commands( { -ignore_prefix => '_' } );
      }
  
      sub foo  {}  # will become a command
      sub bar  {}  # will become a command
      sub _baz {}  # will *NOT* become a command
  
  This way you can easily segregate between commands and helper functions, making your code even more reusable without jeopardizing the command line interface (As of version 1.04, ignoring commands with underscore '_' prefixes is also the default App::Rad behavior).
  
  
  =head3 Putting it all together
  
  You can combine some of the options above to have even more flexibility:
  
      $c->register_commands(
              'foo',
              { -ignore_suffix => 'foo' },
              { bar => 'all your command line are belong to us' },
      );
  
  The code above will register as commands all subs with names B<not> ending in 'foo', but it B<will> register the 'foo' sub as well. It will also give the 'bar' command the help string. This behavior is handy for registering several commands and having a few exceptions, or to add your commands and only have inline help for a few of them (as you see fit).
  
  You don't have to worry about the order of your elements passed, App::Rad will figure them out for you in a DWIM fashion.
  
      # this does the same as the code above
      $c->register_commands(
              { bar => 'all your command line are belong to us' },
              'foo',
              { -ignore_suffix => 'foo' },
      );
  
  You can even bundle the hash reference to include your C<< cmd => help >> and special keys:
  
      # this behaves the same way as the code above:
      $c->register_commands(
          'foo',
          { 
              -ignore_suffix => 'foo',
              bar => 'all your command line are belong to us',
          }
      );
  
  
  =head2 $c->unregister_command ( I<NAME> )
  
  Longer alias for C<< $c->unregister() >>. The use of the shorter form is encouraged, and this alias may be removed in future versions. You have been warned.
  
  
  =head3 $c->unregister ( I<NAME> )
  
  Unregisters a given command name so it's not available anymore. Note that the subroutine will still be there to be called from inside your program - it just won't be accessible via command line anymore.
  
  
  =head2 $c->debug( I<MESSAGE> )
  
  Will print the given message on screen only if the debug flag is enabled:
  
      use App::Rad  qw( debug );
  
  Note that, if debug is enabled, App::Rad itself will print several debug messages stating its current flow, so you can easily find out where everything is happening.
  
  
  =head2 $c->plugins()
  
  Returns a list of all loaded plugins, in the order in which they were loaded.
  
  
  =head2 $c->load_plugin( I<PLUGIN NAME> )
  
  This method will dinamically load the given plugin. The plugin needs to be under the C<< App::Rad::Plugin >> namespace, and the name should be relative to this path (i.e. $c->load_plugin('MyPlugin') will try to load 'App::Rad::Plugin::MyPlugin'). If you want to load a plugin by its fully qualified name, you need to prepend a plus sign to the name ('+Fully::Qualified::Plugin::Name'). B<This is an internal method> and you really should refrain from using it. Instead, plugins should be loaded as parameters to the C<< use App::Rad >> statement, as explained above.
  
  
  =head1 CONTROL FUNCTIONS (to possibly override)
  
  App::Rad implements some control functions which are expected to be overridden by implementing them in your program. They are as follows:
  
  =head2 setup()
  
  This function is responsible for setting up what your program can and cannot do, plus everything you need to set before actually running any command (connecting to a database or host, check and validate things, download a document, whatever). Note that, if you override setup(), you B<< *must* >> call C<< $c->register_commands() >> or at least C<< $c->register() >> so your subs are classified as valid commands (check $c->register_commands() above for more information).
  
  Another interesting thing you can do with setup is to manipulate the command list. For instance, you may want to be able to use the C<include> and C<exclude> commands, but not let them available for all users. So instead of writing:
  
      use App::Rad qw(include exclude);
      App::Rad->run();
  
  you can write something like this:
  
      use App::Rad;
      App::Rad->run();
  
      sub setup {
          my $c = shift;
          $c->register_commands();
  
          # EUID is 'root'
          if ( $> == 0 ) {
              $c->register('include', \&App::Rad::include);
              $c->register('exclude', \&App::Rad::exclude);
          }
      }
  
  to get something like this:
  
      [user@host]$ myapp.pl help
      Usage: myapp.pl command [arguments]
  
      Available Commands:
         help
  
      [user@host]$ sudo myapp.pl help
      Usage: myapp.pl command [arguments]
  
      Available Commands:
         exclude
         help
         include
  
  
  
  =head2 default()
  
  If no command is given to your application, it will fall in here. Please note that invalid (non-existant) command will fall here too, but you can change this behavior with the invalid() function below (although usually you don't want to).
  
  Default's default (grin) is just an alias for the help command.
  
      sub default {
          my $c = shift;
  
          # will fall here if the given
          # command isn't valid.
      }
  
  You are free (and encouraged) to change the default behavior to whatever you want. This is rather useful for when your program will only do one thing, and as such it receives only parameters instead of command names. In those cases, use the "C<< default() >>" sub as your main program's sub and parse the parameters with C<< $c->argv >> and C<< $c->getopt >> as you would in any other command.
  
  =head2 invalid()
  
  This is a special function to provide even more flexibility while creating your command line applications. This is called when the user requests a command that does not exist. The built-in C<< invalid() >> will simply redirect itself to C<< default() >> (see above), so usually you just have to worry about this when you want to differentiate between "no command given" (with or without getopt-like arguments) and "invalid command given" (with or without getopt-like arguments).
  
  =head2 teardown()
  
  If implemented, this function is called automatically after your application runs. It can be used to clean up after your operations, removing temporary files, disconnecting a database connection established in the setup function, logging, sending data over a network, or even storing state information via Storable or whatever.
  
  
  =head2 pre_process()
  
  If implemented, this function is called automatically right before the actual wanted command is called. This way you have an optional pre-run hook, which permits functionality to be added, such as preventing some commands to be run from a specific uid (e.g. I<root>): 
  
      sub pre_process {
          my $c = shift;
  
          if ( $c->cmd eq 'some_command' and $> != 0 ) {
              $c->cmd = 'default'; # or some standard error message
          }
      }
      
  
  =head2 post_process()
  
  If implemented, this function is called automatically right after the requested function returned. It receives the Controller object right after a given command has been executed (and hopefully with some output returned), so you can manipulate it at will. In fact, the default "post_process" function is as goes:
  
      sub post_process {
          my $c = shift;
  
          if ( $c->output() ) {
              print $c->output() . "\n";
          }
      }
  
  You can override this function to include a default header/footer for your programs (either a label or perhaps a "Content-type: " string), parse the output in any ways you see fit (CPAN is your friend, as usual), etc.
  
  
  
  =head1 IMPORTANT NOTE ON PRINTING INSIDE YOUR COMMANDS
  
  B<The post_process() function above is why your application should *NEVER* print to STDOUT>. Using I<print> (or I<say>, in 5.10) to send output to STDOUT is exclusively the domain of the post_process() function. Breaking this rule is a common source of errors. If you want your functions to be interactive (for instance) and print everything themselves, you should disable post-processing in setup(), or create an empty post_process function or make your functions return I<undef> (so I<post_process()> will only add a blank line to the output).
  
  
  =head1 DIAGNOSTICS
  
  If you see a '1' printed on the screen after a command is issued, it's probably because that command is returning a "true" value instead of an output string. If you don't want to return the command output for post processing(you'll loose some nice features, though) you can return undef or make post_process() empty.
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  App::Rad requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  App::Rad depends only on 5.8 core modules (Carp for errors, Getopt::Long for "$c->getopt", Attribute::Handlers for "help" and O/B::Deparse for the "include" command).
  
  If you have Perl::Tidy installed, the "include" command will tidy up your code before inclusion.
  
  The test suite depends on Test::More, FindBin and File::Temp, also core modules.
  
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  
  =head1 BUGS AND LIMITATIONS
  
  Please report any bugs or feature requests to 
  C<bug-app-easy at rt.cpan.org>, or through the web interface at 
  L<http://rt.cpan.org/garu/ReportBug.html?Queue=App-Rad>.  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
  
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc App::Rad
  
  Although this Module comes without any warraties whatsoever (see DISCLAIMER below), I try really hard to provide some quality assurance for the users. This means I not only try to close all reported bugs in the minimum amount of time but I also try to find some on my own.
  
  This version of App::Rad comes with 183 tests and I keep my eye constantly on CPAN Testers L<http://www.cpantesters.org/show/App-Rad.html> to ensure it passes all of them, in all platforms. You can send me your own App::Rad tests if you feel I'm missing something and I'll hapilly add them to the distribution.
  
  Since I take user's feedback very seriously, I really hope you send me any wishlist/TODO you'd like App::Rad to have (please try to send them via RT so other people can give their own suggestions).
  
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/garu/Bugs.html?Dist=App-Rad>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/App-Rad>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/App-Rad>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/App-Rad>
  
  =back
  
  =head2 IRC
  
     #app-rad  on irc.perl.org
  
  
  =head1 TODO
  
  This is a small list of features I plan to add in the near future (in no particular order). Feel free to contribute with your wishlist and comentaries!
  
  =over 4
  
  =item * Shell-like environment
  
  =item * Loadable commands (in an external container file)
  
  =item * Modularized commands (similar to App::Cmd::Commands ?)
  
  =item * app-starter
  
  =item * command inclusion by prefix, suffix and regexp (feature request by fco)
  
  =item * command inclusion and exclusion also by attributes
  
  =item * some extra integration, maybe IPC::Cmd and IO::Prompt
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 CONTRIBUTORS
  
  (in alphabetical order)
  
  Ben Hengst
  
  Fernando Correa
  
  Flavio Glock
  
  Thanks to everyone for contributing! Please let me know if I've skipped your name by accident.
  
  
  =head1 ACKNOWLEDGEMENTS
  
  This module was inspired by Kenichi Ishigaki's presentation I<"Web is not the only one that requires frameworks"> during YAPC::Asia::2008 and the modules it exposed (mainly App::Cmd and App::CLI).
  
  Also, many thanks to CGI::App(now Titanium)'s Mark Stosberg and all the Catalyst developers, as some of App::Rad's functionality was taken from those (web) frameworks.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD

$fatpacked{"App/Rad/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_CONFIG';
  package App::Rad::Config;
  
  sub load_config {
      my ($c, @files) = (@_);
  
      foreach my $filename (@files) {
  
          $c->debug("loading configuration from $filename");
          open my $CONFIG, '<', $filename
              or Carp::croak "error opening $filename: $!\n";
  
          while (<$CONFIG>) {
              chomp;
              s/#.*//;
              s/^\s+//;
              s/\s+$//;
              next unless length;
  
              if ( m/^([^\=\:\s]+)        # key
                  (?:                     # (value is optional)
                     (?:\s*[\=\:]\s*|\s+) # separator ('=', ':' or whitespace)
                     (.+)                 # value
                  )?
                  /x
              ) {
                  $c->config->{$1} = $2;
              }
          }
          close $CONFIG;
      }
  }
  
  42;
APP_RAD_CONFIG

$fatpacked{"App/Rad/Exclude.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_EXCLUDE';
  package App::Rad::Exclude;
  use Carp qw/carp croak/;
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('exclude', \&exclude, 'completely erase command from your program');
  }
  
  # removes given sub from the
  # main program
  sub _remove_code_from_file {
      my $sub = shift;
  
      #TODO: I really should be using PPI
      #if the user has it installed...
      open my $fh, '+<', $0
          or croak "error updating file $0: $!\n";
  
  #    flock($fh, LOCK_EX) or carp "could not lock file $0: $!\n";
  
      my @file = <$fh>;
      my $ret = _remove_code_from_array(\@file, $sub);
  
      # TODO: only change the file if it's eval'd without errors
      seek ($fh, 0, 0) or croak "error seeking file $0: $!\n";
      print $fh @file or croak "error writing to file $0: $!\n";
      truncate($fh, tell($fh)) or croak "error truncating file $0: $!\n";
  
      close $fh;
  
      return $ret;
  }
  
  sub _remove_code_from_array {
      my $file_array_ref = shift;
      my $sub = shift;
  
      my $index = 0;
      my $open_braces = 0;
      my $close_braces = 0;
      my $sub_start = 0;
      while ( $file_array_ref->[$index] ) {
          if ($file_array_ref->[$index] =~ m/\s*sub\s+$sub(\s+|\s*\{)/) {
              $sub_start = $index;
          }
          if ($sub_start) {
              # in order to see where the sub ends, we'll
              # try to count the number of '{' against
              # the number of '}' available
  
              #TODO:I should use an actual LR parser or
              #something. This would be greatly enhanced
              #and much less error-prone, specially for
              #nested symbols in the same line.
              $open_braces++ while $file_array_ref->[$index] =~ m/\{/g;
              $close_braces++ while $file_array_ref->[$index] =~ m/\}/g;
              if ( $open_braces > 0 ) {
                  if ( $close_braces > $open_braces ) {
                      croak "Error removing $sub: could not parse $0 correctly.";
                  }
                  elsif ( $open_braces == $close_braces ) {
                      # remove lines from array
                      splice (@{$file_array_ref}, $sub_start, ($index + 1 - $sub_start));
                      last;
                  }
              }
          }
      }
      continue {
          $index++;
      }
  
      if ($sub_start == 0) {
          return "Error finding '$sub' command. Built-in?";
      }
      else {
          return "Command '$sub' successfuly removed.";
      }
  }
  
  sub exclude {
      my $c = shift;
      if ( $c->argv->[0] ) {
          if ( $c->is_command( $c->argv->[0] ) ) {
              return _remove_code_from_file($c->argv->[0]);
          }
          else {
              return $c->argv->[0] . ' is not an available command';
          }
      }
      else {
          return "Sintax: $0 exclude command_name"
      }
  }
  
  42;
  __END__
  =head1 NAME
  
  App::Rad::Exclude - 'exclude' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.01
  
  =head1 SYNOPSIS
  
  'exclude' is an opt-in command for you App::Rad programs (myapp.pl):
  
      use App::Rad qw(exclude);  # add the 'exclude' command
      App::Rad->run();
      
      sub mycmd {
          print "hello, world\n";
      }
      
  and now you can permanently remove a command from your application
  
      [user@host]$ myapp.pl exclude mycmd
      
  Note that this B<*will*> edit the program's source code and try to remove the command (subroutine) automatically, so use it with extreme caution.
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately. Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 exclude
  
  Removes given command (subroutine) from your App::Rad program.
  
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * Carp, which is core in Perl 5.8.
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_EXCLUDE

$fatpacked{"App/Rad/Help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_HELP';
  package App::Rad::Help;
  use Attribute::Handlers;
  use strict;
  use warnings;
  
  our $VERSION = '0.03';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('help', \&help, 'show syntax and available commands');
  }
  
  # shows specific help commands
  # TODO: context specific help, 
  # such as "myapp.pl help command"
  sub help {
      my $c = shift;
      return usage() . "\n\n" . helpstr($c);
  }
  
  sub usage {
      return "Usage: $0 command [arguments]";
  }
  
  sub helpstr {
      my $c = shift;
      
      my $string = "Available Commands:\n";
  
      # get length of largest command name
      my $len = 0;
      foreach ( sort $c->commands() ) {
          $len = length($_) if (length($_) > $len);
      }
  
      # format help string
      foreach ( sort $c->commands() ) {
          $string .= sprintf "    %-*s\t%s\n", $len, $_, 
                             defined ($c->{'_commands'}->{$_}->{'help'})
                             ? $c->{'_commands'}->{$_}->{'help'}
                             : ''
                             ;
                  ;
      }
      return $string;
  }
      
  
  {
  my %help_attr = ();
  sub UNIVERSAL::Help :ATTR(CODE) {
       my ($package, $symbol, $ref, $attr, $data, $phase, $filename, $linenum) = @_;
  
      if ($package eq 'main') {
          # If data is a single word, it is received as an array ref. Don't ask.
          $data = join(' ', @$data) if ref($data) eq 'ARRAY';
          $help_attr{ *{$symbol}{NAME} } = $data;
      }
  }
  
  sub register_help {
      my ($self, $c, $cmd, $helptext) = @_;
  
      if ((not defined $helptext) && (defined $help_attr{$cmd})) {
          $helptext = $help_attr{$cmd};
      }
  
      # we do $helptext // undef as it would issue a warning otherwise
      $c->{'_commands'}->{$cmd}->{'help'} = defined $helptext
                                          ? $helptext
                                          : undef
                                          ;
  }
  
  }
  42;
  __END__
  
  =head1 NAME
  
  App::Rad::Help - 'help' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.02
  
  =head1 SYNOPSIS
  
  you can add inline help for your App::Rad commands via C<< $c->register() >> or C<< $c->register_commands() >>:
  
      use App::Rad;
      App::Rad->run();
      
      sub setup {
          my $c = shift;
          
          $c->register_commands( {
                  foo => 'expand your foo!',
                  bar => 'have a drink! arguments: --drink=DRINK',
              });
              
          $c->register('baz', \&baz, 'do your thing');
      }
      
  you can also do it with the attribute 'Help' in your subs
  
      sub my_command :Help(this is my command) {
          ...
      }
      
      sub another_cmd
      :Help(yet another command)
      {
          ...
      }
      
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately (unless, perhaps, you want to use one of its methods to customize your own 'help' command). Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 help
  
  Show help text
  
  =head2 register_help
  
  Associates help text with command
  
  =head2 usage
  
  Prints usage string. Default is "Usage: $0 command [arguments]", where $0 is your program's name.
  
  =head2 helpstr
  
  Prints a help string with all available commands and their help description.
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * Attribute::Handlers, which is core as of Perl 5.8.
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 ACKNOWLEDGEMENTS
  
  The attribute handling was *much* easened because of the nice C<< Attribute::Handlers >> module. So many thanks to Damian Conway, Rafael Garcia-Suarez and Steffen Mueller.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_HELP

$fatpacked{"App/Rad/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_INCLUDE';
  package App::Rad::Include;
  use Carp qw/carp croak/;
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  sub load {
      my ($self, $c) = @_;
      $c->register('include', \&include, 'include one-liner as a command');
  }
  
  # translates one-liner into
  # a complete, readable code
  sub _get_oneliner_code {
      return _sanitize( _deparse($_[0]) );
  }
  
  
  #TODO: option to do it saving a backup file
  # (behavior probably set via 'setup')
  # inserts the string received
  # (hopefully code) inside the
  # user's program file as a 'sub'
  sub _insert_code_in_file {
      my ($command_name, $code_text) = @_;
  
      my $sub =<<"EOSUB";
  sub $command_name {
  $code_text
  }
  EOSUB
  
      # tidy up the code, if Perl::Tidy is available
      eval "use Perl::Tidy ()";
      if (! $@) {
          my $new_code = '';
          Perl::Tidy::perltidy( argv => '', source => \$sub, destination => \$new_code );
          $sub = $new_code;
      }
  
  #TODO: flock
  #    eval {
  #        use 'Fcntl qw(:flock)';
  #    }
  #    if ($@) {
  #        carp 'Could not load file locking module';
  #    }
  
      #TODO: I really should be using PPI
      #if the user has it installed...
      #or at least a decent parser
      open my $fh, '+<', $0
          or croak "error updating file $0: $!\n";
  
  #    flock($fh, LOCK_EX) or carp "could not lock file $0: $!\n";
  
      my @file = <$fh>;
      _insert_code_into_array(\@file, $sub);
  
      # TODO: only change the file if
      # it's eval'd without errors
      seek ($fh, 0, 0) or croak "error seeking file $0: $!\n";
      print $fh @file or croak "error writing to file $0: $!\n";
      truncate($fh, tell($fh)) or croak "error truncating file $0: $!\n";
  
      close $fh;
  }
  
  
  sub _insert_code_into_array {
      my ($file_array_ref, $sub) = @_;
      my $changed = 0;
  
      $sub = "\n\n" . $sub . "\n\n";
  
      my $line_id = 0;
      while ( $file_array_ref->[$line_id] ) {
  
          # this is a very rudimentary parser. It assumes a simple
          # vanilla application as shown in the main example, and
          # tries to include the given subroutine just after the
          # App::Rad->run(); call.
          next unless $file_array_ref->[$line_id] =~ /App::Rad->run/;
  
          # now we add the sub (hopefully in the right place)
          splice (@{$file_array_ref}, $line_id + 1, 0, $sub);
          $changed = 1;
          last;
      }
      continue {
          $line_id++;
      }
      if ( not $changed ) {
          croak "error finding 'App::Rad->run' call. $0 does not seem a valid App::Rad application.\n";
      }
  }
  
  
  # deparses one-liner into a working subroutine code
  sub _deparse {
  
      my $arg_ref = shift;
  
      # create array of perl command-line 
      # parameters passed to this one-liner
      my @perl_args = ();
      while ( $arg_ref->[0] =~ m/^-/o ) {
          push @perl_args, (shift @{$arg_ref});
      }
  
      #TODO: I don't know if "O" and
      # "B::Deparse" can actually run the same way as
      # a module as it does via -MO=Deparse.
      # and while I can't figure out how to use B::Deparse
      # to do exactly what it does via 'compile', I should
      # at least catch the stderr buffer from qx via 
      # IPC::Cmd's run(), but that's another TODO
      my $deparse = join ' ', @perl_args;
      my $code = $arg_ref->[0];
      my $body = qx{perl -MO=Deparse $deparse '$code'};
      return $body;
  }
  
  
  # tries to adjust a subroutine into
  # App::Rad's API for commands
  sub _sanitize {
      my $code = shift;
  
      # turns BEGIN variables into local() ones
      $code =~ s{(?:local\s*\(?\s*)?(\$\^I|\$/|\$\\)}
                {local ($1)}g;
  
      # and then we just strip any BEGIN blocks
      $code =~ s{BEGIN\s*\{\s*(.+)\s*\}\s*$}
                {$1}mg;
  
      my $codeprefix =<<'EOCODE';
  my $c = shift;
  
  EOCODE
      $code = $codeprefix . $code;
  
      return $code;
  }
  
  
  # includes a one-liner as a command.
  # TODO: don't let the user include
  # a control function!!!!
  sub include {
      my $c = shift;
  
      my @args = @ARGV;
  
      if( @args < 3 ) {
          return "Sintax: $0 include [name] -perl_params 'code'.\n";
      }
  
      # figure out the name of
      # the command to insert.
      # Either the user chose it already
      # or we choose it for the user
      my $command_name = '';
      if ( $args[0] !~ m/^-/o ) {
          $command_name = shift @args;
  
          # don't let the user add a command
          # that already exists
          if ( $c->is_command($command_name) ) {
              return "Command '$command_name' already exists. Please remove it first with '$0 exclude $command_name";
          }
      }
      else {
          $command_name = $c->create_command_name();
      }
      $c->debug("including command '$command_name'...");
  
      my $code_text = _get_oneliner_code(\@args);
  
      _insert_code_in_file($command_name, $code_text);
  
      # turns code string into coderef so we
      # can register it (just in case the user
      # needs to run it right away)
      my $code_ref = sub { eval $code_text};
      $c->register($command_name, $code_ref);
  
      return; 
  }
  
  42;
  __END__
  =head1 NAME
  
  App::Rad::Include - 'include' command extension for App::Rad
  
  =head1 VERSION
  
  Version 0.01
  
  =head1 SYNOPSIS
  
  'include' is an opt-in command for you App::Rad programs (myapp.pl):
  
      use App::Rad qw(include);  # add the 'include' command
      App::Rad->run();
      
  and now you can turn your one-liners (e.g:)
  
      [user@host]$ perl -i -pe 's/\r//' file.txt
  
  into nice scalable commands, simply replacing 'perl' for 'yourapp include <NAME>'
  
      [user@host]$ myapp.pl include dos2unix -i -pe 's/\r//'
      
  and there you go, a brand new 'dos2unix' command:
  
      [user@host]$ myapp.pl dos2unix file.txt
  
  
  =head1 DESCRIPTION
  
  This is an internal module for App::Rad and should not be used separately. Please refer to L<< App::Rad >> for further documentation.
  
  
  =head1 INTERNAL METHODS
  
  =head2 load
  
  Loads the module into App::Rad
  
  =head2 include
  
  Translates perl one-liner into self-contained command (subroutine) and adds it to your App::Rad program.
  
  
  =head1 DEPENDENCIES
  
  =over 4
  
  =item * O, which is core in Perl 5.8.
  
  =item * B::Deparse, also core in 5.8.
  
  =item * Perl::Tidy (optional)
  
  =back
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira, C<< <garu at cpan.org> >>
  
  
  =head1 ACKNOWLEDGEMENTS
  
  The one-liner conversion and beautification was *much* easened because of the nice C<< O >> , C<< B::Deparse >> and C<< Perl::Tidy >> modules. So many thanks to Malcolm Beattie, Nicholas Clark, Stephen McCamant, Steve Hancock, and everyone that helped those projects.
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2008 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
APP_RAD_INCLUDE

$fatpacked{"App/Rad/Plugin/MoreHelp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RAD_PLUGIN_MOREHELP';
  package App::Rad::Plugin::MoreHelp;
  use strict;
  use warnings;
  
  our $VERSION = '0.0001'; # VERSION
  
  sub more_help {
      my ($c, $msg) = @_;
      $c->register(help => sub { App::Rad::Help::help($c) . "\n$msg" },
          'show syntax and available commands');
  }
  
  # ABSTRACT: App::Rad plugin for providing extra help info.
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Rad::Plugin::MoreHelp - App::Rad plugin for providing extra help info.
  
  =head1 VERSION
  
  version 0.0001
  
  =head1 SYNOPSIS
  
      use App::Rad qw(MoreHelp);
  
      sub setup {
          my $c = shift;
          $c->more_help('This string gets appended to the main help message.');
      }
  
      App::Rad->run();
  
  =head1 DESCRIPTION
  
  This is an L<App::Rad> plugin for providing extra help info.
  It provides a C<more_help> method which can be used to provide extra info
  that will be appended to to bottom of the help message.
  
  =head1 METHODS
  
  =head2 more_help
  
      $c->more_help('This string gets appended to the help message.');
  
  =head1 AUTHOR
  
  Naveed Massjouni <naveedm9@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Naveed Massjouni.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_RAD_PLUGIN_MOREHELP

$fatpacked{"Config/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_TINY';
  package Config::Tiny;
  
  # If you thought Config::Simple was small...
  
  use strict;
  our $VERSION = '2.19'; # Also change version # in t/02.main.t.
  BEGIN {
  	require 5.008001;
  	$Config::Tiny::errstr  = '';
  }
  
  # Create an empty object
  sub new { bless {}, shift }
  
  # Create an object from a file
  sub read {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $file  = shift or return $class->_error('No file name provided');
  
  	# Slurp in the file.
  
  	my $encoding = shift;
  	$encoding    = $encoding ? "<:$encoding" : '<';
  	local $/     = undef;
  
  	open( CFG, $encoding, $file ) or return $class->_error( "Failed to open file '$file' for reading: $!" );
  	my $contents = <CFG>;
  	close( CFG );
  
  	return $class -> _error("Reading from '$file' returned undef") if (! defined $contents);
  
  	return $class->read_string( $contents );
  }
  
  # Create an object from a string
  sub read_string {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $self  = bless {}, $class;
  	return undef unless defined $_[0];
  
  	# Parse the file
  	my $ns      = '_';
  	my $counter = 0;
  	foreach ( split /(?:\015{1,2}\012|\015|\012)/, shift ) {
  		$counter++;
  
  		# Skip comments and empty lines
  		next if /^\s*(?:\#|\;|$)/;
  
  		# Remove inline comments
  		s/\s\;\s.+$//g;
  
  		# Handle section headers
  		if ( /^\s*\[\s*(.+?)\s*\]\s*$/ ) {
  			# Create the sub-hash if it doesn't exist.
  			# Without this sections without keys will not
  			# appear at all in the completed struct.
  			$self->{$ns = $1} ||= {};
  			next;
  		}
  
  		# Handle properties
  		if ( /^\s*([^=]+?)\s*=\s*(.*?)\s*$/ ) {
  			$self->{$ns}->{$1} = $2;
  			next;
  		}
  
  		return $self->_error( "Syntax error at line $counter: '$_'" );
  	}
  
  	$self;
  }
  
  # Save an object to a file
  sub write {
  	my $self     = shift;
  	my $file     = shift or return $self->_error('No file name provided');
  	my $encoding = shift;
  	$encoding    = $encoding ? ">:$encoding" : '>';
  
  	# Write it to the file
  	my $string = $self->write_string;
  	return undef unless defined $string;
  	open( CFG, $encoding, $file ) or return $self->_error(
  		"Failed to open file '$file' for writing: $!"
  		);
  	print CFG $string;
  	close CFG;
  
  	return 1;
  }
  
  # Save an object to a string
  sub write_string {
  	my $self = shift;
  
  	my $contents = '';
  	foreach my $section ( sort { (($b eq '_') <=> ($a eq '_')) || ($a cmp $b) } keys %$self ) {
  		# Check for several known-bad situations with the section
  		# 1. Leading whitespace
  		# 2. Trailing whitespace
  		# 3. Newlines in section name
  		return $self->_error(
  			"Illegal whitespace in section name '$section'"
  		) if $section =~ /(?:^\s|\n|\s$)/s;
  		my $block = $self->{$section};
  		$contents .= "\n" if length $contents;
  		$contents .= "[$section]\n" unless $section eq '_';
  		foreach my $property ( sort keys %$block ) {
  			return $self->_error(
  				"Illegal newlines in property '$section.$property'"
  			) if $block->{$property} =~ /(?:\012|\015)/s;
  			$contents .= "$property=$block->{$property}\n";
  		}
  	}
  
  	$contents;
  }
  
  # Error handling
  sub errstr { $Config::Tiny::errstr }
  sub _error { $Config::Tiny::errstr = $_[1]; undef }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Config::Tiny - Read/Write .ini style files with as little code as possible
  
  =head1 SYNOPSIS
  
  	# In your configuration file
  	rootproperty=blah
  
  	[section]
  	one=twp
  	three= four
  	Foo =Bar
  	empty=
  
  	# In your program
  	use Config::Tiny;
  
  	# Create a config
  	my $Config = Config::Tiny->new;
  
  	# Open the config
  	$Config = Config::Tiny->read( 'file.conf' );
  	$Config = Config::Tiny->read( 'file.conf', 'utf8' ); # Neither ':' nor '<:' prefix!
  	$Config = Config::Tiny->read( 'file.conf', 'encoding(iso-8859-1)');
  
  	# Reading properties
  	my $rootproperty = $Config->{_}->{rootproperty};
  	my $one = $Config->{section}->{one};
  	my $Foo = $Config->{section}->{Foo};
  
  	# Changing data
  	$Config->{newsection} = { this => 'that' }; # Add a section
  	$Config->{section}->{Foo} = 'Not Bar!';     # Change a value
  	delete $Config->{_};                        # Delete a value or section
  
  	# Save a config
  	$Config->write( 'file.conf' );
  	$Config->write( 'file.conf', 'utf8' ); # Neither ':' nor '>:' prefix!
  
  	# Shortcuts
  	my($rootproperty) = $$Config{_}{rootproperty};
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  	my($config) = Config::Tiny -> read_string("[init]\nalpha=bet");
  	my($value)  = $$config{init}{alpha}; # $value is 'bet'.
  
  =head1 DESCRIPTION
  
  C<Config::Tiny> is a Perl class to read and write .ini style configuration
  files with as little code as possible, reducing load time and memory
  overhead.
  
  Most of the time it is accepted that Perl applications use a lot
  of memory and modules.
  
  The C<*::Tiny> family of modules is specifically intended to provide an ultralight alternative to the
  standard modules.
  
  This module is primarily for reading human written files, and anything we write shouldn't need to have
  documentation/comments. If you need something with more power move up to L<Config::Simple>, L<Config::General>
  or one of the many other C<Config::*> modules.
  
  Lastly, L<Config::Tiny> does B<not> preserve your comments, whitespace, or the order of your config file.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 CONFIGURATION FILE SYNTAX
  
  Files are the same format as for MS Windows C<*.ini> files. For example:
  
  	[section]
  	var1=value1
  	var2=value2
  
  If a property is outside of a section at the beginning of a file, it will
  be assigned to the C<"root section">, available at C<$Config-E<gt>{_}>.
  
  Lines starting with C<'#'> or C<';'> are considered comments and ignored,
  as are blank lines.
  
  When writing back to the config file, all comments, custom whitespace,
  and the ordering of your config file elements is discarded. If you need
  to keep the human elements of a config when writing back, upgrade to
  something better, this module is not for you.
  
  =head1 METHODS
  
  =head2 errstr()
  
  Returns a string representing the most recent error, or the empty string.
  
  You can also retrieve the error message from the C<$Config::Tiny::errstr> variable.
  
  =head2 new()
  
  The constructor C<new> creates and returns an empty C<Config::Tiny> object.
  
  =head2 read($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<read> constructor reads a config file, $filename, and returns a new
  C<Config::Tiny> object containing the properties in the file.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '<' or '<:'.
  
  Returns the object on success, or C<undef> on error.
  
  When C<read> fails, C<Config::Tiny> sets an error message internally
  you can recover via C<Config::Tiny-E<gt>errstr>. Although in B<some>
  cases a failed C<read> will also set the operating system error
  variable C<$!>, not all errors do and you should not rely on using
  the C<$!> variable.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 read_string($string)
  
  The C<read_string> method takes as argument the contents of a config file
  as a string and returns the C<Config::Tiny> object for it.
  
  =head2 write($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<write> method generates the file content for the properties, and
  writes it to disk to the filename specified.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '>' or '>:'.
  
  Returns true on success or C<undef> on error.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 write_string()
  
  Generates the file content for the object and returns it as a string.
  
  =head1 FAQ
  
  =head2 Why can't I put comments at the ends of lines?
  
  Because a line like:
  
  	key=value # A comment
  
  Sets key to 'value # A comment' :-(.
  
  This conforms to the syntax discussed in L</CONFIGURATION FILE SYNTAX>.
  
  =head2 Why can't I omit the '=' signs?
  
  E.g.:
  
  	[Things]
  	my =
  	list =
  	of =
  	things =
  
  Instead of:
  
  	[Things]
  	my
  	list
  	of
  	things
  
  Because the use of '=' signs is a type of mandatory documentation. It indicates that that section contains 4 items,
  and not 1 odd item split over 4 lines.
  
  =head2 Why do I have to assign the result of a method call to a variable?
  
  This question comes from RT#85386.
  
  Yes, the syntax may seem odd, but you don't have to call both new() and read_string().
  
  Try:
  
  	perl -MData::Dumper -MConfig::Tiny -E 'my $c=Config::Tiny->read_string("one=s"); say Dumper $c'
  
  Or:
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  Or even, a bit ridiculously:
  
  	my($value) = ${Config::Tiny -> read_string('alpha=bet')}{_}{alpha}; # $value is 'bet'.
  
  =head1 CAVEATS
  
  =head2 Unsupported Section Headers
  
  Some edge cases in section headers are not supported, and additionally may not
  be detected when writing the config file.
  
  Specifically, section headers with leading whitespace, trailing whitespace,
  or newlines anywhere in the section header, will not be written correctly
  to the file and may cause file corruption.
  
  =head2 Setting an option more than once
  
  C<Config::Tiny> will only recognize the first time an option is set in a
  config file. Any further attempts to set the same option later in the config
  file are ignored.
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Maintanence from V 2.15: Ron Savage L<http://savage.net.au/>.
  
  =head1 ACKNOWLEGEMENTS
  
  Thanks to Sherzod Ruzmetov E<lt>sherzodr@cpan.orgE<gt> for
  L<Config::Simple>, which inspired this module by being not quite
  "simple" enough for me :).
  
  =head1 SEE ALSO
  
  See, amongst many: L<Config::Simple> and L<Config::General>.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 COPYRIGHT
  
  Copyright 2002 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
CONFIG_TINY

$fatpacked{"Data/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_COMPARE';
  # Data::Compare - compare perl data structures
  # Author: Fabien Tassin <fta@sofaraway.org>
  # updated by David Cantrell <david@cantrell.org.uk>
  # Copyright 1999-2001 Fabien Tassin <fta@sofaraway.org>
  # portions Copyright 2003 - 2013 David Cantrell
  
  package Data::Compare;
  
  use strict;
  use warnings;
  
  use vars qw(@ISA @EXPORT $VERSION $DEBUG %been_there);
  use Exporter;
  use Carp;
  use Scalar::Util qw(tainted);
  use File::Find::Rule;
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(Compare);
  $VERSION = 1.23;
  $DEBUG   = $ENV{PERL_DATA_COMPARE_DEBUG} || 0;
  
  my %handler;
  
  use Cwd;
  
  sub import {
    register_plugins() unless tainted getcwd();
    __PACKAGE__->export_to_level(1, @EXPORT);
  }
  
  # finds and registers plugins
  sub register_plugins {
    foreach my $file (
      File::Find::Rule->file()->name('*.pm')->in(
        map { "$_/Data/Compare/Plugins" }
        grep { -d "$_/Data/Compare/Plugins" }
        @INC
      )
    ) {
      # all of this just to avoid loading the same plugin twice and
      # generating a pile of warnings. Grargh!
      $file =~ s!.*(Data/Compare/Plugins/.*)\.pm$!$1!;
      $file =~ s!/!::!g;
      # ignore badly named example from earlier version, oops
      next if($file eq 'Data::Compare::Plugins::Scalar-Properties');
      my $requires = eval "require $file";
      next if($requires eq '1'); # already loaded this plugin?
  
      # not an arrayref? bail
      if(ref($requires) ne 'ARRAY') {
        warn("$file isn't a valid Data::Compare plugin (didn't return arrayref)\n");
        return;
      }
      # coerce into arrayref of arrayrefs if necessary
      if(ref((@{$requires})[0]) ne 'ARRAY') { $requires = [$requires] }
  
      # register all the handlers
      foreach my $require (@{$requires}) {
        my($handler, $type1, $type2, $cruft) = reverse @{$require};
        $type2 = $type1 unless(defined($type2));
        ($type1, $type2) = sort($type1, $type2);
        if(!defined($type1) || ref($type1) ne '' || !defined($type2) || ref($type2) ne '') {
          warn("$file isn't a valid Data::Compare plugin (invalid type)\n");
        } elsif(defined($cruft)) {
          warn("$file isn't a valid Data::Compare plugin (extra data)\n");
        } elsif(ref($handler) ne 'CODE') {
          warn("$file isn't a valid Data::Compare plugin (no coderef)\n");
        } else {
          $handler{$type1}{$type2} = $handler;
        }
      }
    }
  }
  
  sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my $self = {};
    bless $self, $class;
    $self->{'x'} = shift;
    $self->{'y'} = shift;
    return $self;
  }
  
  sub Cmp {
    my $self = shift;
  
    croak "Usage: DataCompareObj->Cmp(x, y)" unless $#_ == 1 || $#_ == -1;
    my $x = shift || $self->{'x'};
    my $y = shift || $self->{'y'};
  
    return Compare($x, $y);
  }
  
  sub Compare {
    croak "Usage: Data::Compare::Compare(x, y, [opts])\n" unless $#_ == 1 || $#_ == 2;
  
    my $x = shift;
    my $y = shift;
    my $opts = shift || {};
    my($xparent, $xpos, $yparent, $ypos) = map {
      $opts->{$_} || ''
    } qw(xparent xpos yparent ypos);
  
    my $rval = '';
  
    if(!exists($opts->{recursion_detector})) {
      %been_there = ();
      $opts->{recursion_detector} = 0;
    }
    $opts->{recursion_detector}++;
  
    warn "Yaroo! deep recursion!\n" if($opts->{recursion_detector} == 99);
    
    if(
      (ref($x) && exists($been_there{"$x-$xpos-$xparent"}) && $been_there{"$x-$xpos-$xparent"} > 1) ||
      (ref($y) && exists($been_there{"$y-$ypos-$yparent"}) && $been_there{"$y-$ypos-$yparent"} > 1)
    ) {
      $opts->{recursion_detector}--;
      return 1; # we bail as soon as possible, so if we've *not* bailed and have got here, say we're OK and go to the next sub-structure
    } else {
      $been_there{"$x-$xpos-$xparent"}++ if(ref($x));
      $been_there{"$y-$ypos-$yparent"}++ if(ref($y));
  
      $opts->{ignore_hash_keys} = { map {
        ($_, 1)
      } @{$opts->{ignore_hash_keys}} } if(ref($opts->{ignore_hash_keys}) eq 'ARRAY');
  
      my $refx = ref $x;
      my $refy = ref $y;
  
      if(exists($handler{$refx}) && exists($handler{$refx}{$refy})) {
        $rval = &{$handler{$refx}{$refy}}($x, $y, $opts);
      } elsif(exists($handler{$refy}) && exists($handler{$refy}{$refx})) {
        $rval = &{$handler{$refy}{$refx}}($x, $y, $opts);
      }
  
      elsif(!$refx && !$refy) { # both are scalars
        if(defined $x && defined $y) { # both are defined
          $rval = $x eq $y;
        } else { $rval = !(defined $x || defined $y); }
      }
      elsif ($refx ne $refy) { # not the same type
        $rval = 0;
      }
      elsif ($x == $y) { # exactly the same reference
        $rval = 1;
      }
      elsif ($refx eq 'SCALAR' || $refx eq 'REF') {
        $rval = Compare(${$x}, ${$y}, $opts);
      }
      elsif ($refx eq 'ARRAY') {
        if ($#{$x} == $#{$y}) { # same length
          my $i = -1;
          $rval = 1;
          for (@$x) {
            $i++;
            $rval = 0 unless Compare($x->[$i], $y->[$i], { %{$opts}, xparent => $x, xpos => $i, yparent => $y, ypos => $i});
          }
        }
        else {
          $rval = 0;
        }
      }
      elsif ($refx eq 'HASH') {
        my @kx = grep { !$opts->{ignore_hash_keys}->{$_} } keys %$x;
        my @ky = grep { !$opts->{ignore_hash_keys}->{$_} } keys %$y; # heh, KY
        $rval = 1;
        $rval = 0 unless scalar @kx == scalar @ky;
  
        for (@kx) {
          next unless defined $x->{$_} || defined $y->{$_};
          $rval = 0 unless defined $y->{$_} && Compare($x->{$_}, $y->{$_}, { %{$opts}, xparent => $x, xpos => $_, yparent => $y, ypos => $_});
        }
      }
      elsif($refx eq 'Regexp') {
        $rval = Compare($x.'', $y.'', $opts);
      }
      elsif ($refx eq 'CODE') {
        $rval = 0;
      }
      elsif ($refx eq 'GLOB') {
        $rval = 0;
      }
      else { # a package name (object blessed)
        my ($type) = "$x" =~ m/^$refx=(\S+)\(/;
        if ($type eq 'HASH') {
          my %x = %$x;
          my %y = %$y;
          $rval = Compare(\%x, \%y, { %{$opts}, xparent => $xparent, xpos => $xpos, yparent => $yparent, ypos => $ypos});
          $been_there{\%x."-$xpos-$xparent"}--; # decrement count for temp structures
          $been_there{\%y."-$ypos-$yparent"}--;
        }
        elsif ($type eq 'ARRAY') {
          my @x = @$x;
          my @y = @$y;
          $rval = Compare(\@x, \@y, { %{$opts}, xparent => $xparent, xpos => $xpos, yparent => $yparent, ypos => $ypos});
          $been_there{\@x."-$xpos-$xparent"}--;
          $been_there{\@y."-$ypos-$yparent"}--;
        }
        elsif ($type eq 'SCALAR' || $type eq 'REF') {
          my $x = ${$x};
          my $y = ${$y};
          $rval = Compare($x, $y, $opts);
          # $been_there{\$x}--;
          # $been_there{\$y}--;
        }
        elsif ($type eq 'GLOB') {
          $rval = 0;
        }
        elsif ($type eq 'CODE') {
          $rval = 0;
        }
        else {
          croak "Can't handle $type type.";
          $rval = 0;
        }
      }
    }
    $opts->{recursion_detector}--;
    return $rval;
  }
  
  sub plugins {
    return { map { (($_ eq '') ? '[scalar]' : $_, [map { $_ eq '' ? '[scalar]' : $_ } keys %{$handler{$_}}]) } keys %handler };
  }
  
  sub plugins_printable {
    my $r = "The following comparisons are available through plugins\n\n";
    foreach my $key (sort keys %handler) {
      foreach(sort keys %{$handler{$key}}) {
        $r .= join(":\t", map { $_ eq '' ? '[scalar]' : $_ } ($key, $_))."\n";
      }
    }
    return $r;
  }
  
  1;
  
  =head1 NAME
  
  Data::Compare - compare perl data structures
  
  =head1 SYNOPSIS
  
      use Data::Compare;
  
      my $h1 = { 'foo' => [ 'bar', 'baz' ],  'FOO' => [ 'one', 'two' ] };
      my $h2 = { 'foo' => [ 'bar', 'barf' ], 'FOO' => [ 'one', 'two' ] };
      my @a1 = ('one', 'two');
      my @a2 = ('bar', 'baz');
      my %v = ( 'FOO', \@a1, 'foo', \@a2 );
  
      # simple procedural interface
      print 'structures of $h1 and \%v are ',
        Compare($h1, \%v) ? "" : "not ", "identical.\n";
  
      print 'structures of $h1 and $h2 are ',
        Compare($h1, $h2, { ignore_hash_keys => [qw(foo)] }) ? '' : 'not ',
        "close enough to identical.\n";
  
      # OO usage
      my $c = new Data::Compare($h1, \%v);
      print 'structures of $h1 and \%v are ',
        $c->Cmp ? "" : "not ", "identical.\n";
      # or
      my $c = new Data::Compare;
      print 'structures of $h and \%v are ',
        $c->Cmp($h1, \%v) ? "" : "not ", "identical.\n";
  
  =head1 DESCRIPTION
  
  Compare two perl data structures recursively. Returns 0 if the
  structures differ, else returns 1.
  
  A few data types are treated as special cases:
  
  =over 4
  
  =item Scalar::Properties objects
  
  This has been moved into a plugin, although functionality remains the
  same as with the previous version.  Full documentation is in
  L<Data::Compare::Plugins::Scalar::Properties>.
  
  =item Compiled regular expressions, eg qr/foo/
  
  These are stringified before comparison, so the following will match:
  
      $r = qr/abc/i;
      $s = qr/abc/i;
      Compare($r, $s);
  
  and the following won't, despite them matching *exactly* the same text:
  
      $r = qr/abc/i;
      $s = qr/[aA][bB][cC]/;
      Compare($r, $s);
  
  Sorry, that's the best we can do.
  
  =item CODE and GLOB references
  
  These are assumed not to match unless the references are identical - ie,
  both are references to the same thing.
  
  =back
  
  You may also customise how we compare structures by supplying options in
  a hashref as a third parameter to the C<Compare()> function.  This is not
  yet available through the OO-ish interface.  These options will be in
  force for the *whole* of your comparison, so will apply to structures
  that are lurking deep down in your data as well as at the top level, so
  beware!
  
  =over 4
  
  =item ignore_hash_keys
  
  an arrayref of strings. When comparing two hashes, any keys mentioned in
  this list will be ignored.
  
  =back
  
  =head1 CIRCULAR STRUCTURES
  
  Comparing a circular structure to itself returns true:
  
      $x = \$y;
      $y = \$x;
      Compare([$x, $y], [$x, $y]);
  
  And on a sort-of-related note, if you try to compare insanely deeply nested
  structures, the module will spit a warning.  For this to affect you, you need to go
  around a hundred levels deep though, and if you do that you have bigger
  problems which I can't help you with ;-)
  
  =head1 PLUGINS
  
  The module takes plug-ins so you can provide specialised routines for
  comparing your own objects and data-types.  For details see
  L<Data::Compare::Plugins>.
  
  Plugins are *not* available when running in "taint" mode.  You may
  also make it not load plugins by providing an empty list as the
  argument to import() - ie, by doing this:
  
      use Data::Compare ();
  
  A couple of functions are provided to examine what goodies have been
  made available through plugins:
  
  =over 4
  
  =item plugins
  
  Returns a structure (a hash ref) describing all the comparisons made
  available through plugins.
  This function is *not* exported, so should be called as Data::Compare::plugins().
  It takes no parameters.
  
  =item plugins_printable
  
  Returns formatted text
  
  =back
  
  =head1 EXPORTS
  
  For historical reasons, the Compare() function is exported.  If you
  don't want this, then pass an empty list to import() as explained
  under PLUGINS.  If you want no export but do want plugins, then pass
  the empty list, and then call the register_plugins class method:
  
      use Data::Compare ();
      Data::Compare->register_plugins;
  
  or you could call it as a function if that floats your boat.
  
  =head1 SOURCE CODE REPOSITORY
  
  L<git://github.com/DrHyde/perl-modules-Data-Compare.git>
  
  =head1 BUGS
  
  Plugin support is not quite finished (see the TODO file for details) but
  is usable.  The missing bits are bells and whistles rather than core
  functionality.
  
  Please report any other bugs either by email to David Cantrell (see below
  for address) or using rt.cpan.org:
  
  L<https://rt.cpan.org/Ticket/Create.html?Queue=Data-Compare>
  
  =head1 AUTHOR
  
  Fabien Tassin E<lt>fta@sofaraway.orgE<gt>
  
  Portions by David Cantrell E<lt>david@cantrell.org.ukE<gt>
  
  =head1 COPYRIGHT and LICENCE
  
  Copyright (c) 1999-2001 Fabien Tassin. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Some parts copyright 2003 - 2013 David Cantrell.
  
  Seeing that Fabien seems to have disappeared, David Cantrell has become
  a co-maintainer so he can apply needed patches.  The licence, of course,
  remains the same.  As the "perl licence" is "Artistic or GPL, your choice",
  you can find them as the files ARTISTIC.txt and GPL2.txt in the
  distribution.
  
  =head1 SEE ALSO
  
  perl(1), perlref(1)
  
  =cut
DATA_COMPARE

$fatpacked{"Data/Compare/Plugins/Scalar/Properties.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_COMPARE_PLUGINS_SCALAR_PROPERTIES';
  package Data::Compare::Plugins::Scalar::Properties;
  
  use strict;
  use vars qw($VERSION);
  use Data::Compare;
  
  $VERSION = 1.0;
  
  sub register {
      return [
          ['Scalar::Properties', \&sp_scalar_compare],
          ['', 'Scalar::Properties', \&sp_scalar_compare],
      ];
  }
  
  # note that when S::Ps are involved we can't use Data::Compare's default
  # Compare function, so we use eq to check that values are the same.  But
  # we *do* use D::C::Compare whenever possible.
  
  # Compare a S::P and a scalar, or if we figure out that we've got two
  # S::Ps, call sp_sp_compare instead
  
  sub sp_scalar_compare {
      my($scalar, $sp) = @_;
  
      # we don't care what order the two params are, so swap if necessary
      ($scalar, $sp) = ($sp, $scalar) if(ref($scalar));
  
      # got two S::Ps?
      return sp_sp_compare($scalar, $sp) if(ref($scalar));
  
      # we've really got a scalar and an S::P, so just compare values
      return 1 if($scalar eq $sp);
      return 0;
  }
  
  # Compare two S::Ps
  
  sub sp_sp_compare {
      my($sp1, $sp2) = @_;
  
      # first check the values
      return 0 unless($sp1 eq $sp2);
      
      # now check that we have all the same properties
      return 0 unless(Data::Compare::Compare([sort $sp1->get_props()], [sort $sp2->get_props()]));
  
      # and that all properties have the same values
      return 0 if(
          grep { !Data::Compare::Compare(eval "\$sp1->$_()", eval "\$sp2->$_()") } $sp1->get_props()
      );
  
      # if we get here, all is tickety-boo
      return 1;
  }
  
  register();
  
  =head1 NAME
  
  Data::Compare::Plugin::Scalar::Properties - plugin for Data::Compare to
  handle Scalar::Properties objects.
  
  =head1 DESCRIPTION
  
  Enables Data::Compare to Do The Right Thing for Scalar::Properties
  objects.
  
  =over 4
  
  =item comparing a Scalar::Properties object and an ordinary scalar
  
  If you compare
  a scalar and a Scalar::Properties, then they will be considered the same
  if the two values are the same, regardless of the presence of properties.
  
  =item comparing two Scalar::Properties objects
  
  If you compare two Scalar::Properties objects, then they will only be
  considered the same if the values and the properties match.
  
  =back
  
  =head1 AUTHOR
  
  Copyright (c) 2004 David Cantrell. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Data::Compare>
  
  =cut
DATA_COMPARE_PLUGINS_SCALAR_PROPERTIES

$fatpacked{"Data/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_TABLE';
  package Data::Table;
  BEGIN { die "Your perl version is old, see README for instructions" if $] < 5.005; }
  
  use strict;
  use vars qw($VERSION %DEFAULTS);
  use Carp;
  #use Data::Dumper;
  
  $VERSION = '1.72';
  %DEFAULTS = (
    "CSV_DELIMITER"=>',', # controls how to read/write CSV file
    "CSV_QUALIFIER"=>'"',
    "OS"=>0,
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    # this controls how to read and write CSV/TSV file
    "ENCODING"=>'UTF-8'
    # default encoding for fromFile, fromCSV, fromTSV
  );
  %Data::Table::TSV_ESC = ( '0'=>"\0", 'n'=>"\n", 't'=>"\t", 'r'=>"\r", 'b'=>"\b",
                "'"=>"'", '"'=>"\"", '\\'=>"\\" );
  %Data::Table::TSV_ENC = ( "\0"=>'0', "\n"=>'n', "\t"=>'t', "\r"=>'r', "\b"=>'b',
                "'"=>"'", "\""=>'"', "\\"=>'\\' );
  use constant ROW_BASED => 0;
  use constant COL_BASED => 1;
  use constant NUMBER => 0;
  use constant STRING => 1;
  use constant ASC => 0;
  use constant DESC => 1;
  use constant INNER_JOIN => 0;
  use constant LEFT_JOIN => 1;
  use constant RIGHT_JOIN => 2;
  use constant FULL_JOIN => 3;
  use constant OS_UNIX => 0;
  use constant OS_PC => 1;
  use constant OS_MAC => 2;
  
  sub new {
    my ($pkg, $data, $header, $type, $enforceCheck) = @_;
    my $class = ref($pkg) || $pkg;
    $type = 0 unless defined($type); 
    $header=[] unless defined($header);
    $data=[] unless defined($data);
    $enforceCheck = 1 unless defined($enforceCheck);
    confess "new Data::Table: Size of data does not match header\n"
      if (($type && (scalar @$data) && $#{$data} != $#{$header}) ||
          (!$type && (scalar @$data) && $#{$data->[0]} != $#{$header}));
    my $colHash = checkHeader($header);
    if ($enforceCheck && scalar @$data > 0) {
      my $size=scalar @{$data->[0]};
      for (my $j =1; $j<scalar @$data; $j++) {
        confess "Inconsistent array size at data[$j]" unless (scalar @{$data->[$j]} == $size);
      }
    } elsif (scalar @$data == 0) {
      $type = 0;
    }
    my $self={ data=>$data, header=>$header, type=>$type, colHash=>$colHash, OK=>[], MATCH=>[]};
    return bless $self, $class;
  }
  
  sub checkHeader {
    my $header = shift;
    my $colHash = {};
    for (my $i = 0; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      #warn "Column name: $elm at column ".($i+1)." is an integer, using an integer column name will mask the corresponding column index!" if ($elm =~ /^\d+$/);
      confess "Undefined column name (empty or all space) at column ".($i+1) unless $elm;
      #confess "Header name ".$colHash->{$elm}." appears more than once" if defined($colHash->{$elm});
      if (defined($colHash->{$elm})) {
        confess "Header name ($elm) appears more than once: in column ".($colHash->{$elm}+1)." and column ".($i+1).".";
      }
      $colHash->{$elm} = $i;
    }
    return $colHash;
  }
  
  # translate a column name into its position in the header
  # (also in column-based table)
  sub colIndex {
    my ($self, $colID) = @_;
    return $self->{colHash}->{$colID} if exists $self->{colHash}->{$colID};
    return $colID if $colID =~ /^\d+$/;
    return -1;
    #if ($colID =~ /\D/) {
    #  my $i = $self->{colHash}->{$colID};
    #  return -1 unless defined($i);
    #  return $i;
    #}
    #return $colID; # assume an index already
  }
  
  sub hasCol {
    my ($self, $col) = @_;
    return $self->colIndex($col) >= 0;
  }
  
  sub nofCol {
    my $self = shift;
    return scalar @{$self->{header}};
  }
  
  sub isEmpty {
    my $self  = shift;
    return $self->nofCol == 0;
  }
  
  sub nofRow {
    my $self = shift;
    return 0 if (scalar @{$self->{data}} == 0);
    return ($self->{type})?
      scalar @{$self->{data}->[0]} : scalar @{$self->{data}};
  }
  
  sub lastRow {
    my $self = shift;
    return $self->nofRow - 1;
  }
  
  sub lastCol {
    my $self = shift;
    return $self->nofCol - 1;
  }
  
  sub colName {
    my ($self, $colNumericIndex) = @_;
    return ($self->header())[$colNumericIndex];
  }
  
  sub iterator {
    my ($self, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{reverse} = 0 unless exists $arg{reverse};
    my $current_row = $arg{reverse} ? $self->lastRow : 0;
  
    return sub {
      my $rowIdx = shift;
      if (defined $rowIdx) { # return row index for previously returned record
        my $prevRow = $arg{reverse} ? $current_row+1 : $current_row-1;
        return ($prevRow<0 or $prevRow > $self->nofRow-1)? undef: $prevRow;
      }
      return undef if $current_row < 0 or $current_row > $self->nofRow - 1;
      my $oldRow = $current_row;
      $arg{reverse} ? $current_row-- : $current_row++;
      return $self->rowHashRef($oldRow);
    }
  }
  
  # still need to consider quotes and comma in string
  # need to get csv specification
  sub csvEscape {
    my ($s, $arg_ref) = @_;
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    $delimiter = $arg_ref->{'delimiter'} if (defined($arg_ref) && defined($arg_ref->{'delimiter'}));
    $qualifier = $arg_ref->{'qualifier'} if (defined($arg_ref) && defined($arg_ref->{'qualifier'}));
    return '' unless defined($s);
    my $qualifier2 = $qualifier;
    $qualifier2 = substr($qualifier, 1, 1) if length($qualifier)>1; # in case qualifier is a special symbol for regular expression
    $s =~ s/$qualifier/$qualifier2$qualifier2/g;
    if ($s =~ /[$qualifier$delimiter\r\n]/) { return "$qualifier2$s$qualifier2"; }
    return $s;
  }
  
  sub tsvEscape {
    my $s = shift;
    #my %ESC = ( "\0"=>'0', "\n"=>'n', "\t"=>'t', "\r"=>'r', "\b"=>'b',
    #            "'"=>"'", "\""=>'"', "\\"=>'\\' );
    ## what about \f? MySQL treats \f as f.
    return "\\N" unless defined($s);
    $s =~ s/([\0\\\b\r\n\t"'])/\\$Data::Table::TSV_ENC{$1}/g;
    return $s;
  }
  
  # output table in CSV format
  sub csv {
    my ($self, $header, $arg_ref)=@_;
    my ($status, @t);
    my $s = '';
    my ($OS, $fileName_or_handler) = ($Data::Table::DEFAULTS{OS}, undef);
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    if (defined($arg_ref)) {
      $delimiter = $arg_ref->{'delimiter'} if defined($arg_ref->{'delimiter'});
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $fileName_or_handler = $arg_ref->{'file'} if defined($arg_ref->{'file'});
    }
    my $delimiter2 = $delimiter; $delimiter2 = substr($delimiter, 1, 1) if length($delimiter)>1;
    my $endl = ($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    $header=1 unless defined($header);
    $s=join($delimiter2, map {csvEscape($_, {delimiter=>$delimiter, qualifier=>$qualifier})} @{$self->{header}}) . $endl if $header;
  ######  $self->rotate if $self->{type};
    if ($self->{data}) {
      $self->rotate() if ($self->{type});
      my $data=$self->{data};
      for (my $i=0; $i<=$#{$data}; $i++) {
        $s .= join($delimiter2, map {csvEscape($_, {delimiter=>$delimiter, qualifier=>$qualifier})} @{$data->[$i]}) . $endl;
      }
    }
    if (defined($fileName_or_handler)) {
      my $OUT;
      my $isFileHandler = ref($fileName_or_handler) ne '';
      if ($isFileHandler) {
        $OUT = $fileName_or_handler;
      } else {
        open($OUT, "> $fileName_or_handler") or confess "Cannot open $fileName_or_handler to write.\n";
        binmode $OUT;
      }
      print $OUT $s;
      close($OUT) unless $isFileHandler;
    }
    return $s;
  }
  
  # output table in TSV format
  sub tsv {
    my ($self, $header, $arg_ref)=@_;
    my ($status, @t);
    my $s = '';
    my ($OS, $fileName_or_handler, $transform_element) = ($Data::Table::DEFAULTS{OS}, undef, 1);
    if (defined($arg_ref)) {
      $OS = $arg_ref->{'OS'} if (defined($arg_ref->{'OS'}));
      $fileName_or_handler = $arg_ref->{'file'} if (defined($arg_ref->{'file'}));
      $transform_element = $arg_ref->{'transform_element'} if (defined($arg_ref->{'transform_element'}));
    }
    my $endl = ($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    $header=1 unless defined($header);
    if ($header) {
      if ($transform_element) {
        $s=join("\t", map {tsvEscape($_)} @{$self->{header}}) . $endl;
      } else {
        $s=join("\t",@{$self->{header}}) . $endl;
      }
    }
  ######  $self->rotate if $self->{type};
    if ($self->{data}) {
      $self->rotate() if ($self->{type});
      my $data=$self->{data};
      for (my $i=0; $i<=$#{$data}; $i++) {
        if ($transform_element) {
          $s .= join("\t", map {tsvEscape($_)} @{$data->[$i]}) . $endl;
        } else {
          $s .= join("\t", @{$data->[$i]}) . $endl;
        }
      }
    }
    if (defined($fileName_or_handler)) {
      my $OUT;
      my $isFileHandler = ref($fileName_or_handler) ne '';
      if ($isFileHandler) {
        $OUT = $fileName_or_handler;
      } else {
        open($OUT, "> $fileName_or_handler") or confess "Cannot open $fileName_or_handler to write.\n";
        binmode $OUT;
      }
      print $OUT $s;
      close($OUT) unless $isFileHandler;;
    }
    return $s;
  }
  
  # output table in HTML format
  sub html {
    my ($self, $colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td, $portrait) = @_;
    my ($s, $s_tr, $s_td, $s_th) = ("", "tr", "", "th");
    my $key;
    $tag_tbl = { class => "data_table" } unless (ref $tag_tbl eq 'HASH');
    $tag_tr = {} unless (ref $tag_tr eq 'HASH');
    $tag_th = {} unless (ref $tag_th eq 'HASH');
    $tag_td = {} unless (ref $tag_td eq 'HASH');
    $portrait = 1 unless defined($portrait);
  
    $s = "<table";
    foreach $key (keys %$tag_tbl) {
      $s .= " $key=\"$tag_tbl->{$key}\"";
    }
    $s .= ">\n";
    $s .= "<thead>\n" if ($portrait);
    my $header=$self->{header};
    my $l_colorByClass = 0;
    my @BG_COLOR=("#D4D4BF","#ECECE4","#CCCC99");
    my @CELL_CLASSES=("data_table_odd","data_table_even","data_table_header");
    if (ref($colorArrayRef_or_classHashRef) eq "HASH") {
      $l_colorByClass = 1;
      $CELL_CLASSES[1]=$colorArrayRef_or_classHashRef->{even} if defined($colorArrayRef_or_classHashRef->{even});
      $CELL_CLASSES[0]=$colorArrayRef_or_classHashRef->{odd} if defined($colorArrayRef_or_classHashRef->{odd});
      $CELL_CLASSES[2]=$colorArrayRef_or_classHashRef->{header} if defined($colorArrayRef_or_classHashRef->{header});
    } elsif ((ref($colorArrayRef_or_classHashRef) eq "ARRAY") && (scalar @$colorArrayRef_or_classHashRef==3)) {
      @BG_COLOR=@$colorArrayRef_or_classHashRef;
    }
    foreach $key (keys %$tag_tr) {
      $s_tr .= " $key=\"$tag_tr->{$key}\"";
    }
    foreach $key (keys %$tag_th) {
      $s_th .= " $key=\"$tag_th->{$key}\"";
    }
    if ($portrait) {
      $s .= "<$s_tr ".($l_colorByClass? ("class=\"".$CELL_CLASSES[2]."\""):("bgcolor=\"".$BG_COLOR[2]."\""))."><$s_th>".
        join("</th><$s_th>", @$header) . "</th></tr>\n";
      $s .= "</thead>\n";
      $self->rotate() if $self->{type};
      my $data=$self->{data};
      $s .= "<tbody>\n";
      for (my $i=0; $i<=$#{$data}; $i++) {
        $s .= "<$s_tr ".($l_colorByClass? ("class=\"".$CELL_CLASSES[$i%2]."\""):("bgcolor=\"".$BG_COLOR[$i%2]."\"")).">";
        for (my $j=0; $j<=$#{$header}; $j++) {
          my $s_td = $tag_td->{$j} || $tag_td->{$header->[$j]};
          $s .= defined($s_td)? "<td $s_td>":"<td>";
          $s .= (defined($data->[$i][$j]) && $data->[$i][$j] ne '')?$data->[$i][$j]:"&nbsp;";
          $s .= "</td>";
        }
        $s .= "</tr>\n";
      }
      $s .= "</tbody>\n";
    } else {
      $self->rotate() unless $self->{type};
      my $data=$self->{data};
      for (my $i = 0; $i <= $#{$header}; $i++) {
        $s .= "<$s_tr><$s_th ".($l_colorByClass? ("class=\"".$CELL_CLASSES[2]."\""):("bgcolor=\"".$BG_COLOR[2]."\"")).">".
              $header->[$i] . "</th>";
        my $s_td = $tag_td->{$i} || $tag_td->{$header->[$i]};
        for (my $j=0; $j<=$#{$data->[0]}; $j++) {
          $s .= defined($s_td)? "<td $s_td":"<td";
          $s .= ($l_colorByClass?(" class=\"".$CELL_CLASSES[$j%2]."\""):(" bgcolor=\"".$BG_COLOR[$j%2]."\"")).">";
          $s .= (defined($data->[$i][$j]) && $data->[$i][$j] ne '')?$data->[$i][$j]:'&nbsp;';
          $s .= "</td>";
        }
        $s .= "</tr>\n";
      }
    }
    $s .= "</table>\n";
    return $s;
  }
  
  # output table in HTML format, with table orientation rotated,
  # so that each HTML table row is a column in the table
  # This is useful for a slim table (few columns but many rows)
  sub html2 {
    my ($self, $colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td) = @_;
    return $self->html($colorArrayRef_or_classHashRef, $tag_tbl, $tag_tr, $tag_th, $tag_td, 0);
  }
  
  # apply a $fun to each elm in a col 
  # function only has access to one element per row
  sub colMap {
    my ($self, $colID, $fun) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    my $ref = $self->{data}->[$c];
    my @tmp = map {scalar $fun->($_)} @$ref;
    $self->{data}->[$c] = \@tmp;
    return 1;
  } 
  
  # apply a $fun to each row in the table
  # function has access to all elements in that row
  sub colsMap {
    my ($self, $fun) = @_;
    $self->rotate() if $self->{type};
    map {&$fun} @{$self->{data}};
    return 1;
  }
  
  sub addRow {
    my ($self, $rowRef, $rowIdx, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{addNewCol} = 0 unless exists $arg{addNewCol};
  
    my $numRow=$self->nofRow();
    my @t;
    my $myRowRef = $rowRef;
  
    if ($arg{addNewCol}) {
      if (ref $myRowRef eq 'HASH') {
        foreach my $key (keys %$myRowRef) {
          next if $self->colIndex($key) >= 0;
          my @col = (undef) x $self->nofRow;
          $self->addCol(\@col, $key);
        }
      } elsif (ref $myRowRef eq 'ARRAY') {
        for (my $i=$self->nofCol; $i< scalar @$myRowRef; $i++) {
          my @col = (undef) x $self->nofRow;
          $self->addCol(\@col, "col".($i+1));
        }
      }
    }
  
    if (ref $myRowRef eq 'HASH') {
      if ($self->isEmpty) {
        my $i = 0;
        foreach my $s (keys %$myRowRef) {
          push @{$self->{header}}, $s;
          $self->{colHash}->{$s} = $i++;
        }
      }
      my @one = ();
      my @header = $self->header;
      for (my $i=0; $i< scalar @header; $i++) {
        $one[$i] = $myRowRef->{$header[$i]};
      }
      $myRowRef = \@one;
    } elsif (ref $myRowRef eq 'ARRAY') {
      confess "addRow: size of added row does not match those in the table\n"
  	if scalar @$myRowRef != $self->nofCol();
    } else {
      confess "addRow: parameter rowRef has to be either an array_ref or a hash_ref\n";
    }
    $rowIdx=$numRow unless defined($rowIdx);
    return undef unless defined $self->checkNewRow($rowIdx);
    $self->rotate() if $self->{type};
    my $data=$self->{data};
    if ($rowIdx == 0) {
      unshift @$data, $myRowRef;
    } elsif ($rowIdx == $numRow) {
      push @$data, $myRowRef;
     } else {
      @t = splice @$data, $rowIdx;
      push @$data, $myRowRef, @t;
    }
    return 1;
  }
  
  sub delRow {
    my ($self, $rowIdx ) = @_;
    return undef unless defined $self->checkOldRow($rowIdx);
    $self->rotate() if $self->{type};
    my $data=$self->{data};
    my @dels=splice(@$data, $rowIdx, 1);
    return shift @dels;
  }                                                                               
  
  sub delRows {
    my ($self, $rowIdcsRef) = @_;
    my $rowIdx;
    $self->rotate() if $self->{type};
    my @dels = @{$self->{data}}[@$rowIdcsRef];
    my @indices = sort { $b <=> $a } @$rowIdcsRef;
    #my @dels=();
    foreach $rowIdx (@indices) {
      #push @dels, $self->delRow($rowIdx);
      $self->delRow($rowIdx);
    }
    return @dels;
  }   
  
  # append a column to the table, input is a referenceof_array
  
  sub addCol {
    my ($self, $colRef, $colName, $colIdx) = @_;
    my $numCol=$self->nofCol();
    my @t;
    if (!defined($colRef) || ref($colRef) eq '') {
      # fill the new column with $colRef as the default value
      my @col = ($colRef) x $self->nofRow;
      $colRef = \@col;
    } else {
      confess "addCol: size of added col does not match rows in the table\n" 
      if @$colRef != $self->nofRow() and $numCol > 0; 
    }
    $colIdx=$numCol unless defined($colIdx);
    return undef unless defined $self->checkNewCol($colIdx, $colName);
    $self->rotate() unless $self->{type};
    my $data=$self->{data};
    my $header=$self->{header};
    if ($colIdx == 0) {
      unshift @$header, $colName;
    } elsif ($colIdx == $numCol) {
      push @$header, $colName;
    } else {
      @t = splice @$header, $colIdx;
      push @$header, $colName, @t;
    }
  
    if ($colIdx == 0) {
      unshift @$data, $colRef;
    } elsif ($colIdx == $numCol) {
      push @$data, $colRef;
    } else {
      @t = splice @$data, $colIdx;
      push @$data, $colRef, @t;
    }
  
    for (my $i = 0; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      $self->{colHash}->{$elm} = $i;
    }
    return 1;
  }
  
  sub delCol {
    my ($self, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    my $header=$self->{header};
    my $name=$self->{header}->[$c];
    splice @$header, $c, 1;
    my $data=$self->{data};
    my @dels=splice @$data, $c, 1;
    delete $self->{colHash}->{$name};
    for (my $i = $c; $i < scalar @$header; $i++) {
      my $elm = $header->[$i];
      $self->{colHash}->{$elm} = $i;
    }
    return shift @dels;
  }                                                                               
  
  sub delCols {
    my ($self, $colIDsRef) = @_;
    my $idx;
    my @indices = map { $self->colIndex($_) } @$colIDsRef;
    $self->rotate() unless $self->{type};
    my @dels = @{$self->{data}}[@indices];
    @indices = sort { $b <=> $a } @indices;
    #my @dels=();
    foreach my $colIdx (@indices) {
      $self->delCol($colIdx);
    }
    return @dels;
  }  
  
  
  sub rowRef {
    my ($self, $rowIdx) = @_;
    return undef unless defined $self->checkOldRow($rowIdx);
    $self->rotate if $self->{type};
    return $self->{data}->[$rowIdx];
  }
  
  sub rowRefs {
    my ($self, $rowIdcsRef) = @_;
    $self->rotate if $self->{type};
    return $self->{data} unless defined $rowIdcsRef;
    my @ones = ();
    my $rowIdx;
    foreach $rowIdx (@$rowIdcsRef) {
      push @ones, $self->rowRef($rowIdx);
    }
    return \@ones;
  }
  
  sub row {
    my ($self, $rowIdx) = @_;
    my $data = $self->{data};
    return undef unless defined $self->checkOldRow($rowIdx);
    if ($self->{type}) {
      my @one=(); 
      for (my $i = 0; $i < scalar @$data; $i++) {
        push @one, $data->[$i]->[$rowIdx];
      }
      return @one;
    } else {
      return @{$data->[$rowIdx]};
    }
  }
  
  sub rowHashRef {
    my ($self, $rowIdx) = @_;
    my $data = $self->{data};
    return undef unless defined $self->checkOldRow($rowIdx);
    my $header=$self->{header};
    my $one = {};
    for (my $i = 0; $i < scalar @$header; $i++) {
      $one->{$header->[$i]} = ($self->{type})?
        $self->{data}->[$i]->[$rowIdx]:$self->{data}->[$rowIdx]->[$i];
    }
    return $one;
  }
  
  sub colRef {
    my ($self, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $self->rotate() unless $self->{type};
    return $self->{data}->[$c];
  }
  
  sub colRefs {
    my ($self, $colIDsRef) = @_;
    $self->rotate unless $self->{type};
    return $self->{data} unless defined $colIDsRef;
    my @ones = ();
    my $colID;
    foreach $colID (@$colIDsRef) {
      push @ones, $self->colRef($colID);
    }
    return \@ones;
  }
  
  sub col {
    my ($self, $colID) = @_;
    my $data = $self->{data};
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    if (!$self->{type}) {
      my @one=();
      for (my $i = 0; $i < scalar @$data; $i++) {
        push @one, $data->[$i]->[$c];
      }
      return @one;
    } else {
      return () unless ref($data->[$c]) eq "ARRAY";
      return @{$data->[$c]};
    }
  }
  
  sub rename {
    my ($self, $colID, $name) = @_;
    my $oldName;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    $oldName=$self->{header}->[$c];
    return if ($oldName eq $name);
    return undef unless defined $self->checkNewCol($c, $name);
    $self->{header}->[$c]=$name;
    # $self->{colHash}->{$oldName}=undef; # undef still keeps the entry, use delete instead!
    delete $self->{colHash}->{$oldName};
    $self->{colHash}->{$name}=$c;
    return 1;
  }
  
  sub replace{
    my ($self, $oldColID, $newColRef, $newName) = @_;
    my $oldName;
    my $c=$self->checkOldCol($oldColID);
    return undef unless defined $c;
    $oldName=$self->{header}->[$c];
    $newName=$oldName unless defined($newName);
    unless ($oldName eq $newName) {
    	return undef unless defined $self->checkNewCol($c, $newName);
    }
    confess "New column size ".(scalar @$newColRef)." must be ".$self->nofRow() unless (scalar @$newColRef==$self->nofRow());
    $self->rename($c, $newName);
    $self->rotate() unless $self->{type};
    my $old=$self->{data}->[$c];
    $self->{data}->[$c]=$newColRef;
    return $old;
  }
  
  sub swap{
    my ($self, $colID1, $colID2) = @_;
    my $c1=$self->checkOldCol($colID1);
    return undef unless defined $c1;
    my $c2=$self->checkOldCol($colID2);
    return undef unless defined $c2;
    my $name1=$self->{header}->[$c1];
    my $name2=$self->{header}->[$c2];
  
    $self->{header}->[$c1]=$name2;
    $self->{header}->[$c2]=$name1;
    $self->{colHash}->{$name1}=$c2;
    $self->{colHash}->{$name2}=$c1;
    $self->rotate() unless $self->{type};
    my $data1=$self->{data}->[$c1];
    my $data2=$self->{data}->[$c2];
    $self->{data}->[$c1]=$data2;
    $self->{data}->[$c2]=$data1;
    return 1;
  }
  
  sub moveCol {
    my ($self, $colID, $colIdx, $newColName) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    confess "New column location out of bound!" unless ($colIdx >= 0 && $colIdx < $self->nofCol);
    return if $c == $colIdx;
    my $colName = $self->{header}->[$c];
    my $col = $self->delCol($colID);
    $self->addCol($col, $colName, $colIdx);
    $self->rename($colIdx, $newColName) if defined $newColName;
    return 1;
  }
  
  sub checkOldRow {
    my ($self, $rowIdx) = @_;
    my $maxIdx=$self->nofRow()-1;
    unless (defined $rowIdx) {
  	print STDERR " Invalid row index in call to checkOldRow\n";
  	return undef;
    }
    if ($rowIdx<0 || $rowIdx>$maxIdx) {
  	print STDERR  "Row index out of range [0..$maxIdx]" ;
  	return undef;
    }
    return $rowIdx;
  }
  
  sub checkNewRow {
    my ($self, $rowIdx) = @_;
    my $maxIdx=$self->nofRow()-1;
    unless (defined $rowIdx) {
  	print STDERR "Invalid row index: $rowIdx \n";
  	return undef;
    } 
    $maxIdx+=1;
    if ($rowIdx<0 || $rowIdx>$maxIdx) {
    	print STDERR  "Row index out of range [0..$maxIdx]" ;
  	return undef;
    }
    return $rowIdx;
  }
  
  sub checkOldCol {
    my ($self, $colID) = @_;
    my $c=$self->colIndex($colID);
    if ($c < 0) {
    	print STDERR "Invalid column $colID";
  	return undef;
    } 
    return $c;
  }
  
  sub checkNewCol {
    my ($self, $colIdx, $colName) = @_;
    my $numCol=$self->nofCol();
    unless (defined $colIdx) { 
        	print STDERR "Invalid column index $colIdx";
        	return undef;
    }	
    if ($colIdx<0 || $colIdx>$numCol) {
        	print STDERR "Column index $colIdx out of range [0..$numCol]";
    	return undef;
    }	
    if (defined $self->{colHash}->{$colName} ) {
  	print STDERR "Column name $colName already exists" ;
  	return undef;
    }
    unless ($colName =~ /\D/) { 
      	print STDERR "Invalid column name $colName" ;
  	return undef;
    }
    return $colIdx;
  }
  
  sub elm {
    my ($self, $rowIdx, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    return undef unless defined $self->checkOldRow($rowIdx);
    return ($self->{type})?
      $self->{data}->[$c]->[$rowIdx]:
      $self->{data}->[$rowIdx]->[$c];
  }
  
  sub elmRef {
    my ($self, $rowIdx, $colID) = @_;
    my $c=$self->checkOldCol($colID);
    return undef unless defined $c;
    return undef unless defined $self->checkOldRow($rowIdx);
    return ($self->{type})?
      \$self->{data}->[$c]->[$rowIdx]:
      \$self->{data}->[$rowIdx]->[$c];
  }
  
  sub setElm {
    my ($self, $rowIdx, $colID, $val) = @_;
    $rowIdx = [$rowIdx] if ref($rowIdx) eq '';
    $colID = [$colID] if ref($colID) eq '';
    foreach my $col (@$colID) {
      my $c=$self->checkOldCol($col);
      return undef unless defined $c;
      foreach my $row (@$rowIdx) {
        return undef unless defined $self->checkOldRow($row);
        if ($self->{type}) {
          $self->{data}->[$c]->[$row]=$val;
        } else {
          $self->{data}->[$row]->[$c]=$val;
        }
      }
    }
    return 1;
  }
  
  # convert the internal structure of a table between row-based and column-based
  sub rotate {
    my $self=shift;
    my $newdata=[];
    my $data=$self->{data};
    $self->{type} = ($self->{type})?0:1;
    if ($self->{type} && scalar @$data == 0) {
      for (my $i=0; $i < $self->nofCol; $i++) {
        $newdata->[$i] = [];
      }
    } else {
      for (my $i=$#{$data->[0]}; $i>=0; $i--) {
        for (my $j=$#{$data}; $j>=0;  $j--) {
          $newdata->[$i][$j]=$data->[$j][$i];
        }
      }
    }
    $self->{data}=$newdata;
    return 1;
  }
  
  sub header {
    my ($self, $header) = @_;
    unless (defined($header)) {
      return @{$self->{header}};
    } else {
      if (scalar @$header != scalar @{$self->{header}}) {
        confess "Header array should have size ".(scalar @{$self->{header}});
      } else {
        my $colHash = checkHeader($header);
        $self->{header} = $header;
        $self->{colHash} = $colHash;
      }
    }
  }
  
  sub type {
    my $self=shift;
    return $self->{type};
  }
  
  sub data {
    my $self=shift;
    return $self->{data};
  }
  
  #  $t->sort(colID1, type1, order1, colID2, type2, order2, ... );
  #  where
  #    colID is a column index (integer) or name (string),
  #    type is 0 for numerical and 1 for others
  #    order is 0 for ascending and 1 for descending
  #    Sorting is done with priority of colname1, colname2, ...
  
  sub sort_v0 {
    my $self = shift;
    my ($str, $i) = ("", 0);
    my @cols = ();
    while (scalar @_) {
      my $c = shift;
      my $col = $self->checkOldCol($c);
      return undef unless defined $col;
      push @cols, $col;
      my $op = '<=>';
      $op = 'cmp' if shift;  				# string 
      $str .=(shift)?  "(\$b->[$i] $op \$a->[$i]) || " :
        "(\$a->[$i] $op \$b->[$i]) || " ;
      $i++;
    }
    substr($str, -3) = "";  	# removes ||  from the end of $str
    $self->rotate() if $self->{type};
    # construct a pre-ordered array
    my $fun = sub { my ($cols, $data) = @_;
    		  my @ext;
    		  @ext = map {$data->[$_]} @$cols;
    		  push @ext, $data;
    		  return \@ext;
  		};
    my @preordered = map {&$fun(\@cols, $_)} @{$self->{data}};
    $self->{data} = [ map {$_->[$i]} eval "sort {$str} \@preordered;" ];
    return 1;
  } 
    
  sub sort {
      my $self = shift;
      my @cols = @_;
      confess "Parameters be in groups of three!\n" if ($#cols % 3 != 2);
      foreach (0 .. ($#cols/3)) {
        my $col = $self->checkOldCol($cols[$_*3]);
        return undef unless defined $col;
        $cols[$_*3]=$col;
      }
      my @subs=();
      for (my $i=0; $i<=$#cols; $i+=3) {
        my $mysub;
        if ($cols[$i+1] == 0) {
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $_[1] <=> $_[0]:1):(defined($_[0])?-1:0)} : sub {defined($_[1])?(defined($_[0])? $_[0] <=> $_[1]:-1):(defined($_[0])?1:0)});
        } elsif ($cols[$i+1] == 1) {
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $_[1] cmp $_[0]:1):(defined($_[0])?-1:0)} : sub {defined($_[1])?(defined($_[0])? $_[0] cmp $_[1]:-1):(defined($_[0])?1:0)});
        } elsif (ref $cols[$i+1] eq 'CODE') {
          my $predicate=$cols[$i+1];
          $mysub = ($cols[$i+2]? sub {defined($_[1])?(defined($_[0])? $predicate->($_[1],$_[0]) : 1): (defined($_[0])?-1:0)} : 
                                 sub {defined($_[1])?(defined($_[0])? $predicate->($_[0],$_[1]) : -1): (defined($_[0])?1:0)} );
        } else {
          confess "Sort method should be 0 (numerical), 1 (other type), or a subroutine reference!\n";
        }
        push @subs, $mysub;
      }
      my $func = sub {
        my $res = 0;
        foreach (0 .. ($#cols/3)) {
          $res ||= $subs[$_]->($a->[$cols[$_*3]], $b->[$cols[$_*3]]);
          return $res unless $res==0;
        }
        return $res;
      };
      $self->rotate() if $self->{type};
      $self->{data} = [sort $func @{$self->{data}}];
      return 1;
  }
  
  # return rows as sub table in which
  # a pattern $pattern is matched 
  sub match_pattern {
    my ($self, $pattern, $countOnly) = @_;
    my @data=();
    $countOnly=0 unless defined($countOnly);
    my $cnt=0;
    $self->rotate() if $self->{type};
    @Data::Table::OK= eval "map { $pattern?1:0; } \@{\$self->{data}};";
    my @ok = @Data::Table::OK;
  	$self->{OK} = \@ok;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($self->{OK}->[$i]) {
        push @data, $self->{data}->[$i] unless $countOnly;
        $cnt++;
        $self->{OK}->[$i] = 1;
        $Data::Table::OK[$i] = 1;
      } else {
        # in case sometimes eval results is '' instead of 0
        $self->{OK}->[$i] = 0;
        $Data::Table::OK[$i] = 0;
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#ok;
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  # return rows as sub table in which
  # a pattern $pattern is matched
  # each row is passed to the patern as a hash, where column names are keys
  sub match_pattern_hash {
    my ($self, $pattern, $countOnly) = @_;
    my @data=();
    $countOnly=0 unless defined($countOnly);
    my $cnt=0;
    $self->rotate() if $self->{type};
    @Data::Table::OK = ();
    for (my $i=0; $i<$self->nofRow(); $i++) {
      local %_ = %{$self->rowHashRef($i)};
      $Data::Table::OK[$i] = eval "$pattern?1:0";
    }
    #@Data::Table::OK= eval "map { $pattern?1:0; } \@{\$self->{data}};";
    my @ok = @Data::Table::OK;
    $self->{OK} = \@ok;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($self->{OK}->[$i]) {
        push @data, $self->{data}->[$i] unless $countOnly;
        $cnt++;
        $self->{OK}->[$i] = 1;
        $Data::Table::OK[$i] = 1;
      } else {
        # in case sometimes eval results is '' instead of 0
        $self->{OK}->[$i] = 0;
        $Data::Table::OK[$i] = 0;
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#ok;
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  # return rows as sub table in which 
  # a string elm in an array @$s is matched 
  sub match_string {
    my ($self, $s, $caseIgn, $countOnly) = @_;
    confess unless defined($s);
    $countOnly=0 unless defined($countOnly);
    my @data=();
    my $r;
    $self->rotate() if $self->{type};
    @Data::Table::OK=();
    $self->{OK} = [];
    $caseIgn=0 unless defined($caseIgn);
  
    ### comment out next line if your perl version < 5.005 ###
    $r = ($caseIgn)?qr/$s/i : qr/$s/;
    my $cnt=0;
  
    foreach my $row_ref (@{$self->data}) {
      push @Data::Table::OK, 0;
      push @{$self->{OK}}, 0;
      foreach my $elm (@$row_ref) {
        next unless defined($elm);
          
          ### comment out the next line if your perl version < 5.005
        if ($elm =~ /$r/) {
          ### uncomment the next line if your perl version < 5.005
  	# if ($elm =~ /$s/ || ($elm=~ /$s/i && $caseIgn)) {
  
          push @data, $row_ref unless $countOnly;
          $Data::Table::OK[$#Data::Table::OK]=1;
          $self->{OK}->[$#{$self->{OK}}]=1;
          $cnt++;
          last;
        }
      }
    }
    $self->{MATCH} = [];
    map { push @{$self->{MATCH}}, $_ if $self->{OK}->[$_] } 0 .. $#{$self->{OK}};
    return $cnt if $countOnly;
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  	
  sub rowMask {
    my ($self, $OK, $c) = @_;
    confess unless defined($OK);
    $c = 0 unless defined ($c);
    my @data=();
    $self->rotate() if $self->{type};
    my $data0=$self->data;
    for (my $i=0; $i<$self->nofRow(); $i++) {
      if ($c) {
        push @data, $data0->[$i] unless $OK->[$i];
      } else {
        push @data, $data0->[$i] if $OK->[$i];
      }
    }
    my @header=@{$self->{header}};
    return new Data::Table(\@data, \@header, 0);
  }
  
  sub rowMerge {
    my ($self, $tbl, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{byName} =0 unless exists $arg{byName};
    $arg{addNewCol} = 0 unless exists $arg{addNewCol};
    if ($self->isEmpty && !$tbl->isEmpty) {
      my @header = $tbl->header;
      my $i = 0;
      foreach my $s (@header) {
        push @{$self->{header}}, $s;
        $self->{colHash}->{$s} = $i++;
      }
    }
    if ($arg{byName} == 0 && $arg{addNewCol} == 0) {
      confess "Tables must have the same number of columns" unless ($self->nofCol()==$tbl->nofCol());
    } else {
      if ($arg{addNewCol}) {
        unless ($arg{byName}) { # add extra column by index
          if ($self->nofCol < $tbl->nofCol) {
            my @header = $tbl->header;
            my $nCols = $self->nofCol();
            my $nRows = $self->nofRow();
            for (my $i = $nCols; $i<@header; $i++) {
              my @one = (undef) x $nRows;
              $self->addCol(\@one, $header[$i]);
            }
          } elsif ($self->nofCol > $tbl->nofCol) {
            my @header = $self->header;
            my %h = ();
            my @header2 = $tbl->header;
            map {$h{$_} = 1} @header2;
            my $nCols = $tbl->nofCol();
            my $nRows = $tbl->nofRow();
            for (my $i = $nCols; $i<$self->nofCol; $i++) {
              my @one = (undef) x $nRows;
              # make sure new col name is unique
              my $s = $header[$i];
              my $cnt = 2;
              while (exists $h{$s}) {
                $s = $header[$i]."_".$cnt ++;
              }
              $tbl->addCol(\@one, $s);
              $h{$s} = 1;
            }
          }
        } else {
          my @header = $tbl->header;
          my $nRows = $self->nofRow();
          foreach my $col (@header) {
            if ($self->colIndex($col) < 0) {
              my @one = (undef) x $nRows;
              $self->addCol(\@one, $col);
            }
          }
        }
      }
    }
    $self->rotate() if $self->{type};
    $tbl->rotate() if $tbl->{type};
    my $data=$self->{data};
    if ($arg{byName} == 0) {
      push @$data, @{$tbl->{data}};
    } else {
      my @header = $self->header;
      my $nCols = scalar @header;
      my @colIndex = map { $tbl->colIndex($_) } @header;
      foreach my $rowRef (@{$tbl->{data}}) {
        my @one = ();
        for (my $j=0; $j< $nCols; $j++) {
          $one[$j] = $colIndex[$j]>=0 ? $rowRef->[$colIndex[$j]]:undef;
        }
        push @$data, \@one;
      }
    }
    return 1;
  }
  
  sub colMerge {
    my ($self, $tbl, $arg_ref) = @_;
    my %arg = defined $arg_ref ? %$arg_ref : ();
    $arg{renameCol} =0 unless exists $arg{renameCol};
    confess "Tables must have the same number of rows" unless ($self->isEmpty || $self->nofRow()==$tbl->nofRow());
    my $col;
    my %h = ();
  	map {$h{$_} = 1} @{$self->{header}};
    my @header2 = ();
    foreach $col ($tbl->header) {
      my $s = $col;
      if (exists $h{$s}) {
        confess "Duplicate column $col in two tables" unless $arg{renameCol};
        my $cnt = 2;
        while (exists $h{$s}) {
          $s = $col ."_". $cnt++;
        }
      }
      $h{$s} = 1;
      push @header2, $s;
    }
    $self->rotate() unless $self->{type};
    $tbl->rotate() unless $tbl->{type};
    my $i = $self->nofCol();
    for my $s (@header2) {
      push @{$self->{header}}, $s;
      $self->{colHash}->{$s} = $i++;
    }
    my $data=$self->{data};
    for ($i=0; $i<$tbl->nofCol(); $i++) {
      push @$data, $tbl->{data}->[$i];
    }
    return 1;
  }
  
  sub subTable {
    my ($self, $rowIdcsRef, $colIDsRef, $arg_ref) = @_;
    my @newdata=();
    my @newheader=();
    # to avoid the side effect of modifying $colIDsRef, 4/30/2012
    my $useRowMask = 0;
    $useRowMask = $arg_ref->{useRowMask} if defined $arg_ref->{useRowMask};
    my @rowIdcs = ();
    @rowIdcs = defined $rowIdcsRef ? @$rowIdcsRef : 0..($self->nofRow()-1) unless $useRowMask;
    my @colIDs = defined $colIDsRef ? @$colIDsRef : 0..($self->nofCol()-1);
    ##$rowIdcsRef = [0..($self->nofRow()-1)] unless defined $rowIdcsRef;
    #$colIDsRef = [0..($self->nofCol()-1)] unless defined $colIDsRef; 
    for (my $i = 0; $i < scalar @colIDs; $i++) {
      $colIDs[$i]=$self->checkOldCol($colIDs[$i]);
      #return undef unless defined $colIDsRef;
      push @newheader, $self->{header}->[$colIDs[$i]];
    }
    if ($useRowMask) {
      my @OK = @$rowIdcsRef;
      my $n = $self->nofRow;
      for (my $i = 0; $i < $n; $i++) {
        push @rowIdcs, $i if $OK[$i];
      }
    }
    if ($self->{type}) {
      for (my $i = 0; $i < scalar @colIDs; $i++) {
        my @one=();
        for (my $j = 0; $j < scalar @rowIdcs; $j++) {
  	      return undef unless defined $self->checkOldRow($rowIdcs[$j]);
          push @one, $self->{data}->[$colIDs[$i]]->[$rowIdcs[$j]];
        }
        push @newdata, \@one;
      }
    } else {
      for (my $i = 0; $i < scalar @rowIdcs; $i++) {
        return undef unless defined $self->checkOldRow($rowIdcs[$i]);	
        my @one=();
        for (my $j = 0; $j < scalar @colIDs; $j++) {
          push @one, $self->{data}->[$rowIdcs[$i]]->[$colIDs[$j]];
        }
        push @newdata, \@one;
      }
    }
    return new Data::Table(\@newdata, \@newheader, $self->{type});
  }
  
  sub reorder {
    my ($self, $colIDsRef, $arg_ref) = @_;
    return unless defined $colIDsRef;
    $arg_ref = {keepRest => 1} unless defined $arg_ref;
    my @newdata=();
    my @newheader=();
    my @colIDs = ();
    my %inNew = ();
    for (my $i = 0; $i < scalar @$colIDsRef; $i++) {
      my $idx = $self->checkOldCol($colIDsRef->[$i]);
      confess "Invalide column $colIDsRef->[$i]" unless defined $idx;
      $colIDs[$i] = $idx;
      $inNew{$idx} = 1;
      #return undef unless defined $colIDsRef;
      push @newheader, $self->{header}->[$idx];
    }
    if ($arg_ref->{keepRest}) {
      for (my $i = 0; $i<$self->nofCol; $i++) {
        unless (exists $inNew{$i}) {
          push @colIDs, $i;
          push @newheader, $self->{header}->[$i];
        }
      }
    }
    
    if ($self->{type}) {
      for (my $i = 0; $i < scalar @colIDs; $i++) {
        push @newdata, $self->{data}->[$colIDs[$i]];
      }
    } else {
      my $n = $self->nofRow;
      for (my $i = 0; $i < $n; $i++) {
        my @one=();
        for (my $j = 0; $j < scalar @colIDs; $j++) {
          push @one, $self->{data}->[$i]->[$colIDs[$j]];
        }
        push @newdata, \@one;
      }
    }
    $self->{header} = \@newheader;
    $self->{colHash} = ();
    for (my $i = 0; $i < scalar @colIDs; $i++) {
      $self->{colHash}->{$newheader[$i]} = $i;
    }
    $self->{data} = \@newdata;
  }
  
  sub clone {
    my $self = shift;
    my $data = $self->{data};
    my @newheader = @{$self->{header}};
    my @newdata = ();
    for (my $i = 0; $i < scalar @{$data}; $i++) {
      my @one=();
      for (my $j = 0; $j < scalar @{$data->[$i]}; $j++) {
        push @one, $data->[$i]->[$j];
      }
      push @newdata, \@one;
    }
    return new Data::Table(\@newdata, \@newheader, $self->{type});
  }
  
  sub fromCSVi {
    my $self = shift;
    return fromCSV(@_);
  }
  
  sub getOneLine {
    my ($fh, $linebreak, $qualifier) = @_;
    my $s = '';
    $qualifier = '' unless defined $qualifier;
    local($/) = $linebreak;
    return <$fh> unless $qualifier;
    while (my $s2 = <$fh>) {
      $s .= $s2;
      my @S = ($s =~ /$qualifier/g);
      return $s if (scalar @S % 2 == 0);
    }
    return $s;
  }
  
  sub fromCSV {
    my ($name_or_handler, $includeHeader, $header, $arg_ref) = @_;
    $includeHeader = 1 unless defined($includeHeader);
    my ($OS, $delimiter, $qualifier, $skip_lines, $skip_pattern, $encoding) = ($Data::Table::DEFAULTS{OS}, $Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER}, 0, undef, $Data::Table::DEFAULTS{ENCODING});
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    # OS: 0 for UNIX (\n as linebreak), 1 for Windows (\r\n as linebreak)
    ###   2 for MAC  (\r as linebreak)
    if (defined($arg_ref)) {
      $delimiter = $arg_ref->{'delimiter'} if defined($arg_ref->{'delimiter'});
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $skip_lines = $arg_ref->{'skip_lines'} if (defined($arg_ref->{'skip_lines'}) && $arg_ref->{'skip_lines'}>0);
      $skip_pattern = $arg_ref->{'skip_pattern'} if defined($arg_ref->{'skip_pattern'});
      $encoding = $arg_ref->{'encoding'} if defined($arg_ref->{'encoding'});
    }
    my @header;
    my $givenHeader = 0;
    if (defined($header) && ref($header) eq 'ARRAY') {
      $givenHeader = 1;
      @header= @$header;
    }
    my $SRC=openFileWithEncoding($name_or_handler, $encoding);
    my @data = ();
    my $oldRowDelimiter=$/;
    my $newRowDelimiter=($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    my $n_endl = length($newRowDelimiter);
    $/=$newRowDelimiter;
    my $s;
    for (my $i=0; $i<$skip_lines; $i++) {
      #$s=<$SRC>;
      $s = getOneLine($SRC, $newRowDelimiter, $qualifier);
    }
    #$s=<$SRC>;
    $s = getOneLine($SRC, $newRowDelimiter, $qualifier);
    if (defined($skip_pattern)) { while (defined($s) && $s =~ /$skip_pattern/) { $s = getOneLine($SRC, $newRowDelimiter, $qualifier); }}
    #{ $s = <$SRC> }; }
    if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
    # $_=~ s/$newRowDelimiter$//;
    unless ($s) {
      #confess "Empty data file" unless $givenHeader;
      return undef unless $givenHeader;
      $/=$oldRowDelimiter;
      return new Data::Table(\@data, \@header, 0);
    }
    my $one;
    if ($s =~ /$delimiter$/) { # if the line ends by ',', the size of @one will be incorrect
                # due to the tailing of split function in perl
      $s .= ' '; # e.g., split $s="a," will only return a list of size 1.
      $one = parseCSV($s, undef, {delimiter=>$delimiter, qualifier=>$qualifier});
      $one->[$#{@$one}]=undef;
    } else {
      $one = parseCSV($s, undef, {delimiter=>$delimiter, qualifier=>$qualifier});
    }
    #print join("|", @$one), scalar @$one, "\n";
    my $size = scalar @$one;
    unless ($givenHeader) {
      if ($includeHeader) {
        @header = @$one;
      } else {
        @header = map {"col$_"} (1..$size); # name each column as col1, col2, .. etc
      }
    }
    push @data, $one unless ($includeHeader);
  
    #while($s = <$SRC>) {
    while($s = getOneLine($SRC, $newRowDelimiter, $qualifier)) {
      next if (defined($skip_pattern) && $s =~ /$skip_pattern/);
      if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
      # $_=~ s/$newDelimiter$//;
      my $one = parseCSV($s, $size, {delimiter=>$delimiter, qualifier=>$qualifier});
      confess "Inconsistent column number at data entry: ".($#data+1) unless ($size==scalar @$one);
      push @data, $one;
    }
    close($SRC);
    $/=$oldRowDelimiter;
    return new Data::Table(\@data, \@header, 0);
  }
  
  # Idea: use \ as the escape char to encode a CSV string,
  # replace \ by \\ and comma inside a field by \c.
  # A comma inside a field must have odd number of " in front of it,
  # therefore it can be distinguished from comma used as the deliminator.
  # After escape, and split by comma, we unescape each field string.
  #
  # This parser will never be crashed by any illegal CSV format,
  # it always return an array!
  sub parseCSV {
    my ($s, $size, $arg_ref)=@_;
    $size = 0 unless defined $size;
    my ($delimiter, $qualifier) = ($Data::Table::DEFAULTS{CSV_DELIMITER}, $Data::Table::DEFAULTS{CSV_QUALIFIER});
    $delimiter = $arg_ref->{'delimiter'} if (defined($arg_ref) && defined($arg_ref->{'delimiter'}));
    $qualifier = $arg_ref->{'qualifier'} if (defined($arg_ref) && defined($arg_ref->{'qualifier'}));
    my $delimiter2 = $delimiter; $delimiter2 = substr($delimiter, 1, 1) if length($delimiter)>1;
    my $qualifier2 = $qualifier; $qualifier2 = substr($qualifier, 1, 1) if length($qualifier)>1;
    # $s =~ s/\n$//; # chop" # assume extra characters has been cleaned before
    if (-1==index $s, $qualifier) {
      if ($size == 0) {
        my $s2 = $s;
        $s2 =~ s/$delimiter//g;
        $size = length($s)-length($s2)+1;
      }
      return [split /$delimiter/, $s , $size];
    }
    $s =~ s/\\/\\\\/g; # escape \ => \\
    my $n = length($s);
    my ($q, $i)=(0, 0);
    while ($i < $n) {
      my $ch=substr($s, $i, 1);
      $i++;
      if ($ch eq $delimiter2 && ($q%2)) {
        substr($s, $i-1, 1)='\\c'; # escape , => \c if it's not a deliminator
        $i++;
        $n++;
      } elsif ($ch eq $qualifier2) {
        $q++;
      }
    }
    $s =~ s/(^$qualifier)|($qualifier\s*$)//g; # get rid of boundary ", then restore "" => "
    $s =~ s/$qualifier\s*$delimiter/$delimiter2/g;
    $s =~ s/$delimiter\s*$qualifier/$delimiter2/g;
    $s =~ s/$qualifier$qualifier/$qualifier2/g;
    if ($size == 0) {
      my $s2 = $s;
      $s2 =~ s/$delimiter//g;
      $size = length($s)-length($s2)+1;
    }
    my @parts=split(/$delimiter/, $s, $size);
    @parts = map {$_ =~ s/(\\c|\\\\)/$1 eq '\c'?$delimiter2:'\\'/eg; $_ } @parts;
  #  my @parts2=();
  #  foreach $s2 (@parts) {
  #    $s2 =~ s/\\c/,/g;   # restore \c => ,
  #    $s2 =~ s/\\\\/\\/g; # restore \\ => \
  #    push @parts2, $s2;
  #  }
    return \@parts;
  }
  
  sub transformElement {
    my $one = shift;
    for (my $i=0; $i < scalar @$one; $i++) {
      next unless defined($one->[$i]);
      if ($one->[$i] eq "\\N") {
        $one->[$i]=undef;
      } else {
        $one->[$i] =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g;
      }
    }
    return $one;
  }
  
  sub fromTSVi {
    my $self = shift;
    return fromTSV(@_);
  }
  
  sub fromTSV {
    my ($name_or_handler, $includeHeader, $header, $arg_ref) = @_;
    my ($OS, $skip_lines, $skip_pattern, $transform_element, $encoding) = ($Data::Table::DEFAULTS{OS}, 0, undef, 1, $Data::Table::DEFAULTS{ENCODING});
    $OS = $arg_ref->{'OS'} if (defined($arg_ref) && defined($arg_ref->{'OS'}));
    # OS: 0 for UNIX (\n as linebreak), 1 for Windows (\r\n as linebreak)
    ###   2 for MAC  (\r as linebreak)
    $skip_lines = $arg_ref->{'skip_lines'} if (defined($arg_ref) && defined($arg_ref->{'skip_lines'}) && $arg_ref->{'skip_lines'}>0);
    $skip_pattern = $arg_ref->{'skip_pattern'} if defined($arg_ref->{'skip_pattern'});
    $transform_element = $arg_ref->{'transform_element'} if (defined($arg_ref->{'transform_element'}));
    $encoding = $arg_ref->{'encoding'} if (defined($arg_ref->{'encoding'}));
    #my %ESC = ( '0'=>"\0", 'n'=>"\n", 't'=>"\t", 'r'=>"\r", 'b'=>"\b",
    #            "'"=>"'", '"'=>"\"", '\\'=>"\\" );
    ## what about \f? MySQL treats \f as f.
  
    $includeHeader = 1 unless defined($includeHeader);
    $OS=0 unless defined($OS);
   
    my @header;
    my $givenHeader = 0;
    if (defined($header) && ref($header) eq 'ARRAY') {
      $givenHeader = 1;
      @header= @$header;
    }
    my $SRC=openFileWithEncoding($name_or_handler, $encoding);
    my @data = ();
    my $oldRowDelimiter=$/;
    my $newRowDelimiter=($OS==2)?"\r":(($OS==1)?"\r\n":"\n");
    my $n_endl = length($newRowDelimiter);
    $/=$newRowDelimiter;
    my $s;
    for (my $i=0; $i<$skip_lines; $i++) {
      $s=<$SRC>;
    }
    $s=<$SRC>;
    if (defined($skip_pattern)) { while (defined($s) && $s =~ /$skip_pattern/) { $s = <$SRC> }; }
    if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
    # $_=~ s/$newRowDelimiter$//;
    unless ($s) {
      confess "Empty data file" unless $givenHeader;
      $/=$oldRowDelimiter;
      return new Data::Table(\@data, \@header, 0);
    }
    #chop;
    my $one;
    if ($s =~ /\t$/) { # if the line ends by ',', the size of @$one will be incorrect
                # due to the tailing of split function in perl
      $s .= ' '; # e.g., split $s="a," will only return a list of size 1.
      @$one = split(/\t/, $s);
      $one->[$#{@$one}]='';
    } else {
      @$one = split(/\t/, $s);
    }
    # print join("|", @$one), scalar @$one, "\n";
    my $size = scalar @$one;
    unless ($givenHeader) {
      if ($includeHeader) {
        if ($transform_element) {
          @header = map { $_ =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g; $_ } @$one;
        } else {
          @header = @$one;
        }
      } else {
        @header = map {"col$_"} (1..$size); # name each column as col1, col2, .. etc
      }
    }
    unless ($includeHeader) {
      transformElement($one) if $transform_element;
      push @data, $one;
    }
    while($s = <$SRC>) {
      #chop;
      # $_=~ s/$newRowDelimiter$//;
      next if (defined($skip_pattern) && $s =~ /$skip_pattern/);
      if (substr($s, -$n_endl, $n_endl) eq $newRowDelimiter) { for (1..$n_endl) { chop $s }}
      my @one = split(/\t/, $s, $size);
      transformElement(\@one) if $transform_element;
      #for (my $i=0; $i < $size; $i++) {
      #  next unless defined($one[$i]);
      #  if ($one[$i] eq "\\N") {
      #    $one[$i]=undef;
      #  } else {
      #    $one[$i] =~ s/\\([0ntrb'"\\])/$Data::Table::TSV_ESC{$1}/g;
      #  }
      #}
      confess "Inconsistent column number at data entry: ".($#data+1) unless ($size==scalar @one);
      push @data, \@one;
    }
    close($SRC);
    $/=$oldRowDelimiter;
    return new Data::Table(\@data, \@header, 0);
  }
  
  sub fromSQLi {
    my $self = shift;
    return fromSQL(@_);
  }
  
  sub fromSQL {
    my ($dbh, $sql, $vars) = @_;
    my ($sth, $header, $t);
    if (ref $sql eq 'DBI::st') {
      $sth = $sql;
    } else {
      $sth = $dbh->prepare($sql) or confess "Preparing: , ".$dbh->errstr;
    }
    my @vars=() unless defined $vars;
    $sth->execute(@$vars) or confess "Executing: ".$dbh->errstr;
  #  $Data::Table::ID = undef;
  #  $Data::Table::ID = $sth->{'mysql_insertid'};
    if ($sth->{NUM_OF_FIELDS}) {
      $header=$sth->{'NAME'};
      $t = new Data::Table($sth->fetchall_arrayref(), $header, 0);
    } else {
      $t = undef;
    }
    $sth->finish;
    return $t;
  }
  
  sub join {
    my ($self, $tbl, $type, $cols1, $cols2, $arg_ref) = @_;
    my $n1 = scalar @$cols1;
    my %arg= ( renameCol => 0, matchNULL => 0, NULLasEmpty => 0);
    $arg{renameCol} = $arg_ref->{renameCol} if exists $arg_ref->{renameCol};
    $arg{matchNULL} = $arg_ref->{matchNULL} if exists $arg_ref->{matchNULL};
    $arg{NULLasEmpty} = $arg_ref->{NULLasEmpty} if exists $arg_ref->{NULLasEmpty};
    #%arg = %$arg_ref if defined $arg_ref;
    # default cols2 to cols1 if not specified
    if (!defined($cols2) && $n1>0) {
      $cols2 = [];
      foreach my $c (@$cols1) {
        push @$cols2, $c;
      }
    }
    my $n2 = scalar @$cols2;
    confess "The number of join columns must be the same: $n1 != $n2" unless $n1==$n2;
    confess "At least one join column must be specified" unless $n1;
    my ($i, $j, $k);
    my @cols3 = ();
    for ($i = 0; $i < $n1; $i++) {
      $cols1->[$i]=$self->checkOldCol($cols1->[$i]);
      confess "Unknown column ". $cols1->[$i] unless defined($cols1->[$i]);
      $cols2->[$i]=$tbl->checkOldCol($cols2->[$i]);
      confess "Unknown column ". $cols2->[$i] unless defined($cols2->[$i]);
      $cols3[$cols2->[$i]]=1;
    }
    my @cols4 = (); # the list of remaining columns
    my @header2 = ();
    for ($i = 0; $i < $tbl->nofCol; $i++) {
      unless (defined($cols3[$i])) {
        push @cols4, $i;
        push @header2, $tbl->{header}->[$i];
      }
    }
  
    $self->rotate() if $self->{type};
    $tbl->rotate() if $tbl->{type};
    my $data1 = $self->{data};
    my $data2 = $tbl->{data};
    my %H=();
    my $key;
    my @subRow;
    for ($i = 0; $i < $self->nofRow; $i++) {
      @subRow = @{$data1->[$i]}[@$cols1];
      my @S = map {tsvEscape($_)} @subRow;
      map { $_ = '' if $_ eq '\\N' } @S if $arg{NULLasEmpty};
      $key = join("\t", @S);
      unless (defined($H{$key})) {
        $H{$key} = [[$i], []];
      } else {
        push @{$H{$key}->[0]}, $i;
      }
    }
    for ($i = 0; $i < $tbl->nofRow; $i++) {
      @subRow = @{$data2->[$i]}[@$cols2];
      # we intentionally make the second table undef keys to be '\\N\\N',
      # so that they are different from the first table undef keys
      # avoid NULL == NULL in the join
      my @S = map {tsvEscape($_)} @subRow;
      map { $_ = ($arg{NULLasEmpty})? '':($arg{matchNULL} ? $_ : '\\N\\N') if $_ eq '\\N' } @S;
      #if ($j>= @S) {
      $key = join("\t", @S);
      #} else {
      #  $key = $arg{matchNULL} ? '\\N' : '\\N\\N';
      #}
      unless (defined($H{$key})) {
        $H{$key} = [[], [$i]];
      } else {
        push @{$H{$key}->[1]}, $i;
      }
    }
  # $type
  # 0: inner join
  # 1: left outer join
  # 2: right outer join
  # 3: full outer join
    my @ones = ();
    my @null1 = ();
    my @null2 = ();
    my @null3 = ();
    $null1[$self->nofCol-1]=undef;
    $null3[$self->nofCol-1]=undef;
    if ($#cols4>=0) { $null2[$#cols4]=undef; }
    foreach $key (keys %H) {
      my ($rows1, $rows2) = @{$H{$key}};
      my $nr1 = scalar @$rows1;
      my $nr2 = scalar @$rows2;
      next if ($nr1 == 0 && ($type == 0 || $type == 1));
      next if ($nr2 == 0 && ($type == 0 || $type == 2));
      if ($nr2 == 0 && ($type == 1 || $type == 3)) {
        for ($i = 0; $i < $nr1; $i++) {
          push @ones, [$self->row($rows1->[$i]), @null2];
        }
        next;
      }
      if ($nr1 == 0 && ($type == 2 || $type == 3)) {
        for ($j = 0; $j < $nr2; $j++) {
          my @row2 = $tbl->row($rows2->[$j]);
          for ($k = 0; $k< scalar @$cols1; $k++) {
            $null3[$cols1->[$k]] = $row2[$cols2->[$k]];
          }
          if ($#cols4>=0) {
            push @ones, [@null3, @row2[@cols4]];
          } else {
            push @ones, [@null3];
          } 
        }
        next;
      }
      for ($i = 0; $i < $nr1; $i++) {
        for ($j = 0; $j < $nr2; $j++) {
          my @row2 = $tbl->row($rows2->[$j]);
          push @ones, [$self->row($rows1->[$i]), @row2[@cols4]];
        }
      }
    }
    if ($arg{renameCol}) {
      my %h = ();
      map {$h{$_} = 1} @{$self->{header}};
      for (my $i=0; $i<@header2; $i++) {
        my $s = $header2[$i];
        my $cnt = 2;
        while (exists $h{$s}) {
          $s = $header2[$i] ."_". $cnt++;
        }
        $header2[$i] = $s;
        $h{$s} = 1;
      }
    }
    my $header = [@{$self->{header}}, @header2];
    return new Data::Table(\@ones, $header, 0);
  }
  
  sub melt {
    my ($self, $keyCols, $variableCols, $arg_ref) = @_;
    confess "key columns have to be specified!" unless defined($keyCols) && ref($keyCols) eq "ARRAY";
    my $variableColName = 'variable';
    my $valueColName = 'value';
    my $skip_NULL = 1;
    my $skip_empty = 0;
    $variableColName = $arg_ref->{'variableColName'} if (defined($arg_ref) && defined($arg_ref->{'variableColName'}));
    $valueColName = $arg_ref->{'valueColName'} if (defined($arg_ref) && defined($arg_ref->{'valueColName'}));
    $skip_NULL = $arg_ref->{'skip_NULL'} if (defined($arg_ref) && defined($arg_ref->{'skip_NULL'}));
    $skip_empty= $arg_ref->{'skip_empty'} if (defined($arg_ref) && defined($arg_ref->{'skip_empty'}));
    my @X = ();
    my %X = ();
    foreach my $x (@$keyCols) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $X{$x_idx} = 1;
    }
    my @Y = ();
    my %Y = ();
    unless (defined($variableCols)) {
      $variableCols = [];
      foreach my $x (0 .. $self->nofCol-1) {
        next if $X{$x};
        push @$variableCols, $x;
      }
    }
    unless (scalar @$variableCols) {
      confess "Variable columns have to be specified!";
    }
    foreach my $y (@$variableCols) {
      my $y_idx = $self->checkOldCol($y);
      confess "Unknown column ". $y unless defined($y_idx);
      push @Y, $y_idx;
      $Y{$y_idx} = 1;
    }
  
    my @newHeader = ();
    my @header = $self->header;
    for (my $i=0; $i<= $#X; $i++) {
      push @newHeader, $header[$X[$i]];
    }
    push @newHeader, $variableColName;
    push @newHeader, $valueColName;
    my @newRows = ();
    for (my $i=0; $i<$self->nofRow; $i++) {
      my $row = $self->rowRef($i);
      my @key = @$row[@X];
      foreach my $y (@Y) {
        next if (!defined($row->[$y]) && $skip_NULL);
        next if ($row->[$y] eq '' && $skip_empty);
        my @one = @key;
        push @one, $header[$y], $row->[$y];
        push @newRows, \@one;
      }
    }
    return new Data::Table(\@newRows, \@newHeader, 0);
  }
  
  sub cast {
    my ($self, $colsToGroupBy, $colToSplit, $colToSplitIsStringOrNumeric, $colToCalculate, $funToApply) = @_;
    #$colToSplit = 'variable' unless defined $colToSplit;
    #$colToCalculate = 'value' unless defined $colToCalculate;
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    my $tmpColName = '_calcColumn';
    my $cnt = 2;
    my $s = $tmpColName;
    while ($self->hasCol($s)) {
      $s = $tmpColName."_".$cnt++;
    }
    $tmpColName = $s;
    my %grpBy = ();
    map {$grpBy{$_} = 1} @$colsToGroupBy;
    my @grpBy = @$colsToGroupBy;
    confess "colToSplit cannot be contained in the list of colsToGroupBy!" if defined $colToSplit and $grpBy{$colToSplit};
    push @grpBy, $colToSplit if defined $colToSplit;
    my $t = $self->group(\@grpBy, [$colToCalculate], [$funToApply], [$tmpColName], 0);
    $t = $t->pivot($colToSplit, $colToSplitIsStringOrNumeric, $tmpColName, $colsToGroupBy);
    return $t;
  }
  
  sub each_group {
    my ($self, $colsToGroupBy, $funToApply) = @_;
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    confess "colsToGroupBy has to be specified!" unless defined($colsToGroupBy) && ref($colsToGroupBy) eq "ARRAY";
    confess "funToApply has to be a reference to CODE!" unless ref($funToApply) eq "CODE";
    unless (scalar @$colsToGroupBy) { # all rows are treated as one group
      $funToApply->($self->clone, 0 .. $self->nofRow - 1);
      return;
    }
    my @X = ();
    my %grpBy = ();
    foreach my $x (@$colsToGroupBy) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $grpBy{$x_idx} = 1;
    }
    my %X = ();
    for (my $i=0; $i<$self->nofRow; $i++) {
      my $myRow = $self->rowRef($i);
      #my @val = ();
      #foreach my $x (@X) {
      #  push @val, defined($myRow->[$x])?$myRow->[$x]:"";
      #}
      my @val = map {tsvEscape($_)} @{$myRow}[@X];
      my $myKey = CORE::join("\t", @val);
      push @{$X{$myKey}}, $i;
    }
    foreach my $myKey ( sort {$a cmp $b} keys %X) {
      $funToApply->($self->subTable($X{$myKey}, undef), $X{$myKey});
    }
  }
  
  sub group {
    my ($self, $colsToGroupBy, $colsToCalculate, $funsToApply, $newColNames, $keepRestCols) = @_;
    $keepRestCols = 1 unless defined($keepRestCols);
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    confess "colsToGroupBy has to be specified!" unless defined($colsToGroupBy) && ref($colsToGroupBy) eq "ARRAY";
    my @X = ();
    my %grpBy = ();
    foreach my $x (@$colsToGroupBy) {
      my $x_idx = $self->checkOldCol($x);
      confess "Unknown column ". $x unless defined($x_idx);
      push @X, $x_idx;
      $grpBy{$x_idx} = 1;
    }
    my @Y = ();
    my %Y= ();
    if (defined($colsToCalculate)) {
      foreach my $y (@$colsToCalculate) {
        my $y_idx = $self->checkOldCol($y);
        confess "Unknown column ". $y unless defined($y_idx);
        push @Y, $y_idx;
        $Y{$y_idx} = 1;
      }
    }
    if (scalar @Y) {
      confess "The size of colsToCalculate, funcsToApply and newColNames should be the same!\n"
        unless (scalar @Y == scalar @$funsToApply && scalar @Y == scalar @$newColNames);
    }
  
    my @header = ();
    my @X_name = ();
    my $cnt = 0;
    my $i;
    for ($i=0; $i<$self->nofCol; $i++) {
      if ($grpBy{$i} || ($keepRestCols && !defined($Y{$i}))) {
        push @X_name, $i;
        push @header, $self->{header}->[$i];
        $cnt += 1;
      }
    }
    if (defined($newColNames)) {
      foreach my $y (@$newColNames) {
        push @header, $y;
        $cnt += 1;
      }
    }
    my @ones = ();
    my %X = ();
    my %val = ();
    my %rowIdx = ();
    my $idx = 0;
    for ($i=0; $i<$self->nofRow; $i++) {
      my @row = ();
      my $myRow = $self->rowRef($i);
      my $myKey = '(all)';
      if (@X) {
        # if colsToGroupBy is not specified, all rows has myKey = '(all)', therefore treated as one group
        my @val = map {tsvEscape($_)} @{$myRow}[@X];
        #foreach my $x (@X) {
        #  push @val, defined($myRow->[$x])?$myRow->[$x]:"";
        #}
        $myKey = CORE::join("\t", @val);
      }
      if (scalar @Y) {
        my %Y = ();
        foreach my $y (@Y) {
          next if defined($Y{$y});
          $Y{$y} = 1;
          if (defined($val{$y}->{$myKey})) {
            push @{$val{$y}->{$myKey}}, $myRow->[$y];
          } else {
            $val{$y}->{$myKey} = [$myRow->[$y]];
          }
        }
      }
      next if defined($X{$myKey});
      $X{$myKey} = 1;
      foreach my $j (@X_name) {
        push @row, $myRow->[$j];
      }
      $row[$cnt-1] = undef if (scalar @row < $cnt);
      push @ones, \@row;
      $rowIdx{$myKey} = $idx++;
    }
  
    if (scalar @Y) {
      $cnt -= scalar @Y;
      for($i=0; $i<scalar @Y; $i++) {
        foreach my $s (keys %X) {
          if (ref($funsToApply->[$i]) eq "CODE") {
            $ones[$rowIdx{$s}]->[$cnt+$i] = $funsToApply->[$i]->(@{$val{$Y[$i]}->{$s}});
          } else {
            $ones[$rowIdx{$s}]->[$cnt+$i] = scalar @{$val{$Y[$i]}->{$s}};
            #confess "The ${i}th element in the function array is not a valid reference!\n";
          }
        }
      }
    }
  
    return new Data::Table(\@ones, \@header, 0);
  }
  
  sub pivot {
    my ($self, $colToSplit, $colToSplitIsStringOrNumeric, $colToFill, $colsToGroupBy, $keepRestCols) = @_;
    $keepRestCols = 0 unless defined($keepRestCols);
    $colToSplitIsStringOrNumeric = 0 unless defined($colToSplitIsStringOrNumeric);
    $colsToGroupBy = [] unless defined $colsToGroupBy;
    my $y = undef;
    $y = $self->checkOldCol($colToSplit) if defined $colToSplit;
    my $y_name = defined($y)?$self->{header}->[$y]:undef;
    confess "Unknown column ". $colToSplit if (!defined($y) && defined($colToSplit));
    my $z = undef;
    $z = $self->checkOldCol($colToFill) if defined($colToFill);
    my $z_name = defined($z)?$self->{header}->[$z]:undef;
    confess "Unknown column ". $colToFill if (!defined($z) && defined($colToFill));
    #confess "Cannot take colToFill, if colToSplit is 'undef'" if (defined($z) && !defined($y));
    my @X = ();
    if (defined($colsToGroupBy)) {
      foreach my $x (@$colsToGroupBy) {
        my $x_idx = $self->checkOldCol($x);
        confess "Unknown column ". $x unless defined($x_idx);
        push @X, $self->{header}->[$x_idx];
      }
    }
    my (@Y, %Y);
  
    if (defined($colToSplit)) {
      @Y = $self->col($y);
      %Y = ();
      foreach my $val (@Y) {
        $val = "NULL" unless defined($val);
        $Y{$val} = 1;
      }
    } else {
      @Y = ('(all)') x $self->nofCol;
      %Y = ('(all)' => 1);
      $colToSplitIsStringOrNumeric = 1;
    }
    if ($colToSplitIsStringOrNumeric == 0) {
      foreach my $y (keys %Y) {
        if ($y =~ /\D/) {
          $colToSplitIsStringOrNumeric = 1;
          last;
        }
      }
    }
    if ($colToSplitIsStringOrNumeric) {
      @Y = sort { $a cmp $b } (keys %Y);
    } else {
      @Y = sort { $a <=> $b } (keys %Y);
    }
  
    my @header = ();
    my $i;
    my @X_name = ();
  
    if (!$keepRestCols) {
      foreach my $x (@X) {
        push @X_name, $x;
      }
    } else {
      for ($i=0; $i<$self->nofCol; $i++) {
        next if ((defined($y) && $i==$y) || (defined($z) && $i==$z));
        push @X_name, $self->{header}->[$i];
      }
    }
    my $cnt = 0;
    for ($i=0; $i < @X_name; $i++) {
      my $s = $X_name[$i];
      while (defined($Y{$s})) {
        $s = "_".$s;
      }
      push @header, $s;
      $Y{$s} = $cnt++;
    }
  
    #if (defined($y)) {
      foreach my $val (@Y) {
        push @header, ($colToSplitIsStringOrNumeric?"":"$y_name=") . $val;
        $Y{$val} = $cnt++;
      }
    #}
  
    my @ones = ();
    my %X = ();
    my $rowIdx = 0;
    for ($i=0; $i<$self->nofRow; $i++) {
      my @row = ();
      my $myRow = $self->rowHashRef($i);
      my $myKey = '(all)'; # set to '' to work with total agreegation (group all rows into one)
      if (scalar @X) {
        my @val = ();
        foreach my $x (@X) {
          push @val, tsvEscape($myRow->{$x});
        }
        $myKey = CORE::join("\t", @val);
      }
      unless (defined($X{$myKey})) {
        foreach my $s (@X_name) {
          push @row, $myRow->{$s};
        }
        for (my $j = scalar @row; $j<$cnt; $j++) {
          $row[$j] = undef;
        }
        #$row[$cnt-1] = undef if (scalar @row < $cnt);
      }
      #if (defined($y)) {
        my $val = defined($y) ? $myRow->{$y_name} : "(all)";
        $val = "NULL" unless defined($val);
        if (!defined($X{$myKey})) {
          $row[$Y{$val}] = defined($z)?$myRow->{$z_name}: $row[$Y{$val}]+1;
        } else {
          $ones[$X{$myKey}][$Y{$val}] = defined($z)?$myRow->{$z_name}: $ones[$X{$myKey}][$Y{$val}]+1;
        }
      #}
      unless (defined($X{$myKey})) {
        push @ones, \@row;
        $X{$myKey} = $rowIdx++;
      }
    }
    return new Data::Table(\@ones, \@header, 0);
  }
  
  sub fromFileGuessOS {
    my ($name, $arg_ref) = @_;
    my @OS=("\n", "\r\n", "\r");
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    my $qualifier = '';
    my $encoding = $Data::Table::DEFAULTS{ENCODING};
    $qualifier = $arg_ref->{qualifier} if (defined($arg_ref) && exists $arg_ref->{qualifier});
    $encoding = $arg_ref->{encoding} if (defined($arg_ref) && exists $arg_ref->{encoding});
    my ($len, $os)=(-1, -1);
    my $SRC=openFileWithEncoding($name, $encoding);
    #local($/)="\n";
    my $s = getOneLine($SRC, "\n", $qualifier); #<$SRC>;
    close($SRC);
    #$s =~ s/\n$//;
    #my $myLen=length($s);
    #$s =~ s/\r$//;
    if ($s =~ /\r\n$/) {
      return 1;
    } elsif ($s =~ /\n$/) {
      return 0;
    } elsif ($s =~ /\r/) {
      return 2;
    }
    return 0;
    #if (length($s) == $myLen) {
    #  return 0;
    #} elsif (length($s) == $myLen - 1) {
    #  return 1;
    #} else {
    #  return 2;
    #}
  #  for (my $i=0; $i<@OS; $i++) {
  #    open($SRC, $name) or confess "Cannot open $name to read";
  #    binmode $SRC;
  #    local($/)=$OS[$i];
  #    my $s = <$SRC>;
  #    #print ">> $i => ". (length($s)-length($OS[$i]))."\n";
  #    my $myLen=length($s)-length($OS[$i]);
  #    if ($len<0 || ($myLen>0 && $myLen<$len)) {
  #      $len=length($s)-length($OS[$i]);
  #      $os=$i;
  #    }
  #    close($SRC);
  #  }
  #  # find the OS linebreak that gives the shortest first line
  #  return $os;
  }
  
  sub openFileWithEncoding {
    my ($name_or_handler, $encoding) = @_;
    my $isFileHandler=ref($name_or_handler) ne "";
    my $SRC;
    if ($isFileHandler) {
      $SRC = $name_or_handler; # a file handler
    } else {
      open($SRC, $name_or_handler) or confess "Cannot open $name_or_handler to read";
    }
    # check if Perl version is recent enough to support encoding
    $encoding ='' if (!$^V or $^V lt v5.8.1);
    if ($encoding) {
      $encoding='UTF-8' if ($encoding =~ /^utf-?8$/i);
      binmode($SRC, ":encoding($encoding)");
    } else {
      binmode $SRC;
    }
    return $SRC;
  }
  
  sub fromFileGetTopLines {
    my ($name, $os, $numLines, $arg_ref) = @_;
    $os = fromFileGuessOS($name) unless defined($os);
    $numLines = 2 unless defined($numLines);
    my @OS=("\n", "\r\n", "\r"); 
    # operatoring system: 0 for UNIX (\n as linebreak), 1 for Windows
    # (\r\n as linebreak), 2 for MAC  (\r as linebreak)
    my $encoding = $Data::Table::DEFAULTS{ENCODING};
    $encoding = $arg_ref->{encoding} if (defined($arg_ref) && exists $arg_ref->{encoding});
    my @lines=();
    my $SRC = openFileWithEncoding($name, $encoding);
    local($/)=$OS[$os];
    my $n_endl = length($OS[$os]);
    my $cnt=0;
    while(my $line = <$SRC>) {
      $cnt++;
      for (1..$n_endl) { chop($line); }
      push @lines, $line;
      last if ($numLines>0 && $cnt>=$numLines);
    }
    close($SRC);
    return @lines;
  }
  
  sub fromFileIsHeader {
    my ($s, $delimiter, $allowNumericHeader) = @_;
    $delimiter=$Data::Table::DEFAULTS{'CSV_DELIMITER'} unless defined($delimiter);
    return 0 if (!defined($s) || $s eq "" || $s=~ /$delimiter$/);
    my $fields=parseCSV($s, 0, {delimiter=>$delimiter});
    my $allNumbers = 1;
    foreach my $name (@$fields) {
      return 0 unless $name;
      #next if $name=~/[^0-9.eE\-+]/;
      return 0 if $name=~/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/ && !$allowNumericHeader;
      # modified, so that we allow some columns to be numeric, but not all columns
      $allNumbers = 0 unless $name =~ /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/;
    }
    #return 0 if $allNumbers;
    return 1;
  }
  
  sub fromFileGuessDelimiter {
    my $s_line= shift;
    my @DELIMITER=(",","\t",":");
    my $numCol=-1; my $i=-1;
    return $Data::Table::DEFAULTS{CSV_DELIMITER} unless @$s_line;
    for (my $d=0; $d<@DELIMITER; $d++) {
      my $colFound=-1;
      foreach my $line (@$s_line) {
        unless (defined($line)) {
          return $Data::Table::DEFAULTS{CSV_DELIMITER};
        } else {
          my $header = parseCSV($line, 0, {delimiter=>$DELIMITER[$d]});
          if ($colFound<0) {
            $colFound = scalar @$header;
          } elsif ($colFound != scalar @$header) {
            $colFound = -1;
            last;
          }
        }
      }
      next if $colFound<0;
      if ($colFound>$numCol) {
        $numCol=$colFound; $i=$d;
      }
    }
    return ($i<0)?$Data::Table::DEFAULTS{CSV_DELIMITER}:$DELIMITER[$i];
  }
  
  sub fromFile {
    my ($name, $arg_ref) = @_;
    my $linesChecked = 2;
    my $os = undef;
    my $hasHeader = undef;
    my $delimiter = undef;
    my $format = undef;
    my $qualifier = $Data::Table::DEFAULTS{CSV_QUALIFIER};
    my $allowNumericHeader = 0;
    my $encoding=$Data::Table::DEFAULTS{ENCODING};
  
    if (defined($arg_ref)) {
      $linesChecked = $arg_ref->{'linesChecked'} if defined($arg_ref->{'linesChecked'});
      $os = $arg_ref->{'OS'};
      $hasHeader = $arg_ref->{'has_header'};
      $delimiter = $arg_ref->{'delimiter'};
      $format = $arg_ref->{'format'};
      $qualifier = $arg_ref->{'qualifier'} if defined($arg_ref->{'qualifier'});
      $allowNumericHeader = $arg_ref->{'allowNumericHeader'};
      $encoding = $arg_ref->{'encoding'};
    }
  
    $qualifier = '' if ($format and uc($format) eq 'TSV');
    unless (defined($os)) {
      $os = fromFileGuessOS($name, {qualifier=>$qualifier, encoding=>$encoding});
      $arg_ref->{'OS'}=$os;
    }
    my @S = fromFileGetTopLines($name, $os, $linesChecked, {encoding=>$encoding});
    return undef unless scalar @S;
    unless (defined($delimiter)) {
      $delimiter = fromFileGuessDelimiter(\@S);
      $arg_ref->{'delimiter'} = $delimiter;
    }
    unless (defined($hasHeader)) {
      $hasHeader = fromFileIsHeader($S[0], $delimiter, $allowNumericHeader);
    }
    my $t = undef;
    #print ">>>". join("\n", @S)."\n";
    #print "OS=$os, hasHeader=$hasHeader, delimiter=$delimiter\n";
    if ($delimiter eq "\t") {
      $t=fromTSV($name, $hasHeader, undef, $arg_ref);
    } else {
      $t=fromCSV($name, $hasHeader, undef, $arg_ref);
    }
    return $t;
  }
  
  ## interface to GD::Graph
  # use GD::Graph::points;
  # $graph = GD::Graph::points->new(400, 300);
  # $graph->plot([$t->colRef(1), $t->colRef(2)]);
   
  1;
  
  __END__
  
  
  =head1 NAME
  
  Data::Table - Data type related to database tables, spreadsheets, CSV/TSV files, HTML table displays, etc.
  
  =head1 SYNOPSIS
  
    News: The package now includes "Perl Data::Table Cookbook" (PDF), which may serve as a better learning material.
    To download the free Cookbook, visit https://sites.google.com/site/easydatabase/
  
    # some cool ways to use Table.pm
    use Data::Table;
  
    $header = ["name", "age"];
    $data = [
      ["John", 20],
      ["Kate", 18],
      ["Mike", 23]
    ];
    $t = Data::Table->new($data, $header, 0);	# Construct a table object with
  					# $data, $header, $type=0 (consider 
  					# $data as the rows of the table).
    print $t->csv;                        # Print out the table as a csv file.
  
    $t = Data::Table::fromCSV("aaa.csv");       # Read a csv file into a table object
    ### Since version 1.51, a new method fromFile can automatically guess the correct file format
    # either CSV or TSV file, file with or without a column header line
    # e.g.
    #   $t = Data::Table::fromFile("aaa.csv");
    # is equivalent.
    print $t->html;                       # Display a 'portrait' HTML TABLE on web. 
  
    use DBI;
    $dbh= DBI->connect("DBI:mysql:test", "test", "") or die $DBI::errstr;
    my $minAge = 10;
    $t = Data::Table::fromSQL($dbh, "select * from mytable where age >= ?", [$minAge]);
  					# Construct a table form an SQL 
  					# database query.
  
    $t->sort("age", 0, 0);                # Sort by col 'age',numerical,ascending
    print $t->html2;                      # Print out a 'landscape' HTML Table.  
  
    $row = $t->delRow(2);			# Delete the third row (index=2).
    $t->addRow($row, 4);			# Add the deleted row back as fifth row. 
    @rows = $t->delRows([0..2]);		# Delete three rows (row 0 to 2).
    $col = $t->delCol("age");		# Delete column 'age'.
    $t->addCol($col, "age",2);		# Add column 'age' as the third column
    @cols = $t->delCols(["name","phone","ssn"]); 
  					# Delete 3 columns at the same time. 
  
    $name =  $t->elm(2,"name");	        # Element access
    $t2=$t->subTable([1, 3..4],['age', 'name']);	
  					# Extract a sub-table 
  
    $t->rename("Entry", "New Entry");	# Rename column 'Entry' by 'New Entry'
    $t->replace("Entry", [1..$t->nofRow()], "New Entry");	
  					# Replace column 'Entry' by an array of
  					# numbers and rename it as 'New Entry'
    $t->swap("age","ssn");		# Swap the positions of column 'age' 
  					# with column 'ssn' in the table.
  
    $t->colMap('name', sub {return uc});  # Map a function to a column 
    $t->sort('age',0,0,'name',1,0);	# Sort table first by the numerical 
  					# column 'age' and then by the 
  					# string column 'name' in ascending
  					# order
    $t2=$t->match_pattern('$_->[0] =~ /^L/ && $_->[3]<0.2'); 
  					# Select the rows that matched the 
  					# pattern specified 
    $t2=$t->match_pattern_hash('$_{"Amino acid"} =~ /^L-a/ && $_{"Grams \"(a.a.)\""}<0.2'));
            # use column name in the pattern, method added in 1.62
    $t2=$t->match_string('John');		# Select the rows that matches 'John'   
  					# in any column
  
    $t2=$t->clone();			# Make a copy of the table.
    $t->rowMerge($t2);			# Merge two tables
    $t->colMerge($t2);
  
    $t = Data::Table->new(                 # create an employ salary table
      [
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Peter', 'male', 'HR', 85000],
        ['Mary', 'female', 'HR', 80000],
        ['Nancy', 'female', 'IT', 55000],
        ['Jack', 'male', 'IT', 88000],
        ['Susan', 'female', 'HR', 92000]
      ],
      ['Name', 'Sex', 'Department', 'Salary'], 0);
    
    sub average {  # this is an subroutine calculate mathematical average, ignore NULL
      my @data = @_;
      my ($sum, $n) = (0, 0);
      foreach $x (@data) {
        next unless $x;
        $sum += $x; $n++;
      }
      return ($n>0)?$sum/$n:undef;
    }
  
    $t2 = $t->group(["Department","Sex"],["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"]);
    # For each (Department,Sex) pair, calculate the number of employees and average salary
    $t2 = $t2->pivot("Sex", 0, "Average Salary", ["Department"]);
    # Show average salary information in a Department by Sex spreadsheet
  
  =head1 ABSTRACT
  
  This perl package uses perl5 objects to make it easy for
  manipulating spreadsheet data among disk files, database, and Web
  publishing.
  
  A table object contains a header and a two-dimensional array of scalars.
  Four class methods Data::fromFile, Data::Table::fromCSV, Data::Table::fromTSV, and Data::Table::fromSQL allow users
  to create a table object from a CSV/TSV file or a database SQL selection in a snap.
  
  Table methods provide basic access, add, delete row(s) or column(s) operations, as well as more advanced sub-table extraction, table sorting,
  record matching via keywords or patterns, table merging, and web publishing.   
  Data::Table class also provides a straightforward interface to other
  popular Perl modules such as DBI and GD::Graph.
  
  The most updated version of the Perl Data::Table Cookbook is available at
   https://sites.google.com/site/easydatabase/
  
  We use Data::Table instead of Table, because Table.pm has already been used inside PerlQt module in CPAN.
  
  =head1 INTRODUCTION
  
  =over 4
  
  A table object has three data members:
  
  =item 1. $data:
  
  a reference to an array of array-references.
  It's basically a reference to a two-dimensional array.
  
  =item 2. $header:
  
  a reference to a string array. The array contains all the column names.
  
  =item 3. $type = 1 or 0.
  
  1 means that @$data is an array of table columns (fields) (column-based);
  0 means that @$data is an array of table rows (records) (row-based);
  
  =back
  
  Row-based/Column-based are two internal implementations for a table object.
  E.g., if a spreadsheet consists of two columns lastname and age.
  In a row-based table, $data = [ ['Smith', 29], ['Dole', 32] ].
  In a column-based table, $data = [ ['Smith', 'Dole'], [29, 32] ].
  
  Two implementations have their pros and cons for different operations.
  Row-based implementation is better for sorting and pattern matching,
  while column-based one is better for adding/deleting/swapping columns.
  
  Users only need to specify the implementation type of the table upon its
  creation via Data::Table::new, and can forget about it afterwards.
  Implementation type of a table should be considered volatile, because
  methods switch table objects from one type into another internally.
  Be advised that row/column/element references gained via table::rowRef,
  table::rowRefs, table::colRef, table::colRefs, or table::elmRef may
  become stale after other method calls afterwards.
  
  For those who want to inherit from the Data::Table class, internal method
  table::rotate is used to switch from one implementation type into another.
  There is an additional internal assistant data structure called
  colHash in our current implementation. This hash
  table stores all column names and their corresponding column index number as
  key-value pairs for fast conversion. This gives users an option to use
  column name wherever a column ID is expected, so that user don't have to use
  table::colIndex all the time. E.g., you may say
  $t->rename('oldColName', 'newColName')
  instead of $t->rename($t->colIndex('oldColName'), 'newColIdx').
  
  =head1 DESCRIPTION
  
  =head2 Field Summary
  
  =over 4
  
  =item data refto_arrayof_refto_array
  
  contains a two-dimensional spreadsheet data.
  
  =item header refto_array
  
  contains all column names.
  
  =item type 0/1
  
  0 is row-based, 1 is column-based, describe the orientation of @$data.
  
  =back
  
  =head2 Package Variables
  
  =over 4
  
  =item $Data::Table::VERSION
  
  =item @Data::Table::OK
  
  see table::match_string, table::match_pattern, and table::match_pattern_hash
  Since 1.62, we recommend you to use $table->{OK} instead, which is a local array reference.
  
  =item @Data::Table::MATCH
  
  see table::match_string, table::match_pattern, and table::match_pattern_hash
  Since 1.67, we return the matched row indices in an array.  Data::Table::MATCH is this array reference.
  Here is an example of setting a max price of 20 to all items with UnitPrice > 20.
  
      $t_product->match_pattern_hash('$_{UnitPrice} > 20');
      $t_product->setElm($t_product->{MATCH}, 'UnitPrice', 20);
  
  =item %Data::Table::DEFAULTS
  
  Store default settings, currently it contains CSV_DELIMITER (set to ','), CSV_QUALIFER (set to '"'), and OS (set to 0).
  see table::fromCSV, table::csv, table::fromTSV, table::tsv for details.
  
  =back
  
  =head2 Class Methods
  
  Syntax: return_type method_name ( [ parameter [ = default_value ]] [, parameter [ = default_value ]] )
  
  If method_name starts with table::, this is an instance method, it can be used as $t->method( parameters ), where $t is a table reference.
  
  If method_name starts with Data::Table::, this is a class method, it should be called as
    Data::Table::method, e.g., $t = Data::Table::fromCSV("filename.csv").
  
  Conventions for local variables:
  
    colID: either a numerical column index or a column name;
    rowIdx: numerical row index;
    rowIDsRef: reference to an array of column IDs;
    rowIdcsRef: reference to an array of row indices;
    rowRef, colRef: reference to an array of scalars;
    data: ref_to_array_of_ref_to_array of data values;
    header: ref to array of column headers;
    table: a table object, a blessed reference.
  
  =head2 Table Creation
  
  =over 4
  
  =item table Data::Table::new ( $data = [], $header = [], $type = 0, $enforceCheck = 1)
  
  create a new table.
  It returns a table object upon success, undef otherwise.
  $data: points to the spreadsheet data.
  $header: points to an array of column names. Before version 1.69, a column name must have at least one non-digit character. Since verison 1.69, this is relaxed. Although integer and numeric column names can now be accepted, when accessing a column by integer, it is first interpreted as a column name.
  $type: 0 or 1 for row-based/column-based spreadsheet. 
  $enforceCheck: 1/0 to turn on/off initial checking on the size of each row/column to make sure the data arguement indeed points to a valid structure.
  In 1.63, we introduce constants Data::Table::ROW_BASED and Data::Table::COL_BASED as synonyms for $type.  To create an empty Data::Table, use new Data::Table([], [], Data::Table::ROW_BASED);
  
  =item table table::subTable ($rowIdcsRef, $colIDsRef, $arg_ref)
  
  create a new table, which is a subset of the original.
  It returns a table object.
  $rowIdcsRef: points to an array of row indices (or a true/false row mask array).
  $colIDsRef: points to an array of column IDs.
  The function make a copy of selected elements from the original table. 
  Undefined $rowIdcsRef or $colIDsRef is interpreted as all rows or all columns.
  The elements in $colIDsRef may be modified as a side effect before version 1.62, fixed in 1.62.
  If $arg_ref->{useRowMask} is set to 1, $rowIdcsRef is a true/false row mask array, where rows marked as TRUE will be returned.  Row mask array is typically the Data::Table::OK set by match_string/match_pattern/match_pattern_hash methods.
  
  =item table table::clone
  
  make a clone of the original.
  It return a table object, equivalent to table::subTable(undef,undef).
  
  =item table Data::Table::fromCSV ($name_or_handler, $includeHeader = 1, $header = ["col1", ... ], {OS=>$Data::Table::DEFAULTS{'OS'}, delimiter=>$Data::Table::DEFAULTS{'CSV_DELIMITER'}, qualifier=>$Data::Table::DEFAULTS{'CSV_QUALIFIER'}, skip_lines=>0, skip_pattern=>undef, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a CSV file.
  return a table object.
  $name_or_handler: the CSV file name or an already opened file handler. If a handler is used, it's not closed upon return. To read from STDIN, use Data::Table::fromCSV(\*STDIN, 1).
  $includeHeader: 0 or 1 to ignore/interpret the first line in the file as column names,
  If it is set to 0, the array in $header is used. If $header is not supplied, the default column names are "col1", "col2", ...
  optional named argument OS specifies under which operating system the CSV file was generated. 0 for UNIX, 1 for PC and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used, which defaults to UNIX. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  
  optional name argument delimiter and qualifier let user replace comma and double-quote by other meaningful single characters. <b>Exception</b>: if the delimiter or the qualifier is a special symbol in regular expression, you must escape it by '\'. For example, in order to use pipe symbol as the delimiter, you must specify the delimiter as '\|'.
  
  optional name argument skip_lines let you specify how many lines in the csv file should be skipped, before the data are interpretted.
  
  optional name argument skip_pattern let you specify a regular expression. Lines that match the regular expression will be skipped.
  
  optional name argument encoding let you specify an encoding method of the csv file.  This option is added to fromCSV, fromTSV, fromFile since version 1.69.
  
  The following example reads a DOS format CSV file and writes a MAC format:
  
    $t = Data::Table:fromCSV('A_DOS_CSV_FILE.csv', 1, undef, {OS=>1});
    $t->csv(1, {OS=>2, file=>'A_MAC_CSV_FILE.csv'});
    open(SRC, 'A_DOS_CSV_FILE.csv') or die "Cannot open A_DOS_CSV_FILE.csv to read!";
    $t = Data::Table::fromCSV(\*SRC, 1);
    close(SRC);
  
  The following example reads a non-standard CSV file with : as the delimiter, ' as the qaulifier
  
    my $s="col_A:col_B:col_C\n1:2, 3 or 5:3.5\none:'one:two':'double\", single'''";
    open my $fh, "<", \$s or die "Cannot open in-memory file\n";
    my $t_fh=Data::Table::fromCSV($fh, 1, undef, {delimiter=>':', qualifier=>"'"});
    close($fh);
    print $t_fh->csv;
    # convert to the standard CSV (comma as the delimiter, double quote as the qualifier)
    # col_A,col_B,col_C
    # 1,"2, 3 or 5",3.5
    # one,one:two,"double"", single'"
    print $t->csv(1, {delimiter=>':', qualifier=>"'"}); # prints the csv file use the original definition
  
  The following example reads bbb.csv file (included in the package) by skipping the first line (skip_lines=>1), then treats any line that starts with '#' (or space comma) as comments (skip_pattern=>'^\s*#'), use ':' as the delimiter.
  
    $t = Data::Table::fromCSV("bbb.csv", 1, undef, {skip_lines=>1, delimiter=>':', skip_pattern=>'^\s*#'});
  
  Use the optional name argument encoding to specify file encoding method.
    $t = Data::Table::fromCSV("bbb.csv", 1, undef, {encoding=>'UTF-8'});
  
  =item table table::fromCSVi ($name, $includeHeader = 1, $header = ["col1", ... ])
  
  Same as Data::Table::fromCSV. However, this is an instant method (that's what 'i' stands for), which can be inherited.
  
  =item table Data::Table::fromTSV ($name, $includeHeader = 1, $header = ["col1", ... ], {OS=>$Data::Table::DEFAULTS{'OS'}, skip_lines=>0, skip_pattern=>undef, transform_element=>1, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a TSV file.
  return a table object.
  $name: the TSV file name or an already opened file handler. If a handler is used, it's not closed upon return.  To read from STDIN, use Data::Table::fromTSV(\*STDIN, 1).
  $includeHeader: 0 or 1 to ignore/interpret the first line in the file as column names,
  If it is set to 0, the array in $header is used. If $header is not supplied, the default column names are "col1", "col2", ...
  optional named argument OS specifies under which operating system the TSV file was generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used, which defaults to UNIX. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.  <b>Exception</b>: if the delimiter or the qualifier is a special symbol in regular expression, you must escape it by '\'. For example, in order to use pipe symbol as the delimiter, you must specify the delimiter as '\|'.
  
  optional name argument skip_lines let you specify how many lines in the csv file should be skipped, before the data are interpretted.
  
  optional name argument skip_pattern let you specify a regular expression. Lines that match the regular expression will be skipped.
  
  optional name argument transform_element let you switch on/off \t to tab, \N to undef (etc.) transformation. See TSV FORMAT for details. However, elements are always transformed when export table to tsv format, because not escaping an element containing a tab will be disasterous.
  
  optional name arugment encoding enables one to provide an encoding method when open the tsv file.
  
  See similar examples under Data::Table::fromCSV;
  
  Note: read "TSV FORMAT" section for details.
  
  =item table table::fromTSVi ($name, $includeHeader = 1, $header = ["col1", ... ])
  
  Same as Data::Table::fromTSV. However, this is an instant method (that's what 'i' stands for), which can be inherited.
  
  =item table Data::Table::fromFile ($file_name, $arg_ref = {linesChecked=>2, allowNumericHeader=>0, encoding=>$Data::Table::DEFAULTS{'ENCODING'}})
  
  create a table from a text file.
  return a table object.
  $file_name: the file name (cannot take a file handler).
  linesChecked: the first number of lines used for guessing the input format. The delimiter will have to produce the same number of columns for these lines. By default only check the first 2 lines, 0 means all lines in the file.
  $arg_ref can take additional parameters, such as OS, has_header, delimiter, transform_element, etc. Encoding allows one to specify encoding methods used to open the file, which defaults to UTF-8.
  
  fromFile is added after version 1.51. It relies on the following new methods to automatically figure out the correct file format in order to call fromCSV or fromTSV internally:
  
    fromFileGuessOS($file_name, {encoding=>'UTF-8'})
      returns integer, 0 for UNIX, 1 for PC, 2 for MAC
    fromFileGetTopLines($file_name, $os, $lineNumber, {encoding=>'UTF-8'}) # $os defaults to fromFileGuessOS($file_name), if not specified
      returns an array of strings, each string represents each row with linebreak removed.
    fromFileGuessDelimiter($lineArrayRef)       # guess delimiter from ",", "\t", ":";
      returns the guessed delimiter string.
    fromFileIsHeader($line_concent, $delimiter, $allowNumericHeader) # $delimiter defaults to $Data::Table::DEFAULTS{'CSV_DELIMITER'}
      returns 1 or 0.
  
  It first ask fromFileGuessOS to figure out which OS (UNIX, PC or MAC) generated the input file. The fetch the first linesChecked lines using fromFileGetTopLines. It then guesses the best delimiter using fromFileGuessDelimiter, then it checks if the first line looks like a column header row using fromFileIsHeader. Since fromFileGuessOS and fromFileGetTopLines needs to open/close the input file, these methods can only take file name, not file handler. If user specify formatting parameters in $arg_ref, the routine will skip the corresponding guess work. At the end, fromFile simply calls either fromCSV or fromTSV with $arg_ref forwarded. So if you call fromFile({transform_element=>0}) on a TSV file, transform_elment will be passed onto fromTSV calls internally.
  
  fromFileGuessOS finds the linebreak that gives shortest first line (in the priority of UNIX, PC, MAC upon tie).
  fromFileGuessDelimiter works based on the assumption that the correct delimiter will produce equal number of columns for the given rows. If multiple matches, it chooses the delimiter that gives maximum number of columns. If none matches, it returns the default delimiter.
  fromFileIsHeader works based on the assumption that no column header can be empty or numeric values.  However, if we allow numeric column names (especially integer column names), set {allowNumericHeader => 1}
  
  =item table Data::Table::fromSQL ($dbh, $sql, $vars)
  
  create a table from the result of an SQL selection query.
  It returns a table object upon success or undef otherwise.
  $dbh: a valid database handler. 
  Typically $dbh is obtained from DBI->connect, see "Interface to Database" or DBI.pm.
  $sql: an SQL query string or a DBI::st object (starting in version 1.61).
  $vars: optional reference to an array of variable values, 
  required if $sql contains '?'s which need to be replaced 
  by the corresponding variable values upon execution, see DBI.pm for details.
  Hint: in MySQL, Data::Table::fromSQL($dbh, 'show tables from test') will also create a valid table object.
  
  Data::Table::fromSQL now can take DBI::st instead of a SQL string. This is introduced, so that variable binding (such as CLOB/BLOB) can be done outside the method, for example:
  
    $sql = 'insert into test_table (id, blob_data) values (1, :val)';
    $sth = $dbh->prepare($sql);
    $sth->bind_param(':val', $blob, {ora_type => SQLT_BIN});
    Data::Table::fromSQL($dbh, $sth);
  
  =item table Data::Table::fromSQLi ($dbh, $sql, $vars)
  
  Same as Data::Table::fromSQL. However, this is an instant method (that's what 'i' stands for), whic
  h can be inherited.
  
  =back
  
  =head2 Table Access and Properties
  
  =over 4
  
  =item int table::colIndex ($colID)
  
  translate a column name into its numerical position, the first column has index 0 as in as any perl array.
  return -1 for invalid column names.
  
  Since 1.69, we allow integer to be used as a column header.  The integer $colID will first be checked against column names, if matched, the corresponding column index is returned. E.g., if column name for the 3rd column is "1", colIndex(1) will return 2 instead of 1! In such case, if one need to access the second column, one has to access it by column name, i.e., $t->col(($t->header)[1]).
  
  =item int table::nofCol
  
  return number of columns.
  
  =item int table::nofRow
  
  return number of rows.
  
  =item int table::lastCol
  
  return the index of the last columns, i.e., nofCol - 1.
  
  =item int table::lastRow
  
  return the index of the last rows, i.e., nofRow - 1; This is syntax sugar.
  
     # these two are equivalent
     foreach my $i (0 .. $t->lastRow)
     foreach my $i (0 .. $t->nofRow - 1)
  
  =item bool table::isEmpty
  
  return whether the table has any column, introduced in 1.63.
  
  =item bool table::hasCol($colID)
  
  returns whether the colID is a table column, introduced in 1.63.
  
  =item bool table::colName($colNumericIndex)
  
  returns the column name for a numeric column index, notice the first column has an index of 0. Introduced in 1.68.
  
  =item scalar table::elm ($rowIdx, $colID)
  
  return the value of a table element at [$rowIdx, $colID],
  undef if $rowIdx or $colID is invalid. 
  
  =item refto_scalar table::elmRef ($rowIdx, $colID)
  
  return the reference to a table element at [$rowIdx, $colID], to allow possible modification.
  It returns undef for invalid $rowIdx or $colID. 
  
  =item array table::header ($header)
  
  Without argument, it returns an array of column names.
  Otherwise, use the new header.
  
  =item int table::type
  
  return the implementation type of the table (row-based/column-based) at the time,
  be aware that the type of a table should be considered as volatile during method calls.
  
  =back
  
  =head2 Table Formatting
  
  =over 4
  
  =item string table::csv ($header, {OS=>$Data::Table::DEFAULTS{'OS'}, file=>undef, delimiter=>$Data::Table::DEFAULTS{'CSV_DELIMITER'}, qualifier=>$Data::Table::DEFAULTS{'CSV_QAULIFIER'}})
  
  return a string corresponding to the CSV representation of the table.
  $header controls whether to print the header line, 1 for yes, 0 for no.
  optional named argument OS specifies for which operating system the CSV file is generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  if 'file' is given, the csv content will be written into it, besides returning the string.
  One may specify custom delimiter and qualifier if the other than default are desired.
  
  =item string table::tsv
  
  return a string corresponding to the TSV representation of the table.
  $header controls whether to print the header line, 1 for yes, 0 for no.
  optional named argument OS specifies for which operating system the TSV file is generated. 0 for UNIX, 1 for P
  C and 2 for MAC. If not specified, $Data::Table::DEFAULTS{'OS'} is used. Basically linebreak is defined as "\n", "\r\n" and "\r" for three systems, respectively.
  if 'file' is given, the tsv content will be written into it, besides returning the string.
  
  Note: read "TSV FORMAT" section for details.
  
  =item string table::html ($colorArrayRef_or_colorHashRef = ["#D4D4BF","#ECECE4","#CCCC99"], 
  			  $tag_tbl = {border => '1'},
                            $tag_tr  = {align => 'left'},
                            $tag_th  = {align => 'center'},
                            $tag_td  = {col3 => 'align="right" valign="bottom"', 4 => 'align="left"'},
                            $l_portrait = 1
                          )
  
  return a string corresponding to a 'Portrait/Landscape'-style html-tagged table.
  $colorArrayRef_or_colorHashRef: If a hash reference is provided, it will take three CSS class names for odd data rows, even data rows and for the header row.  The default hash is {even=>"data_table_even", odd=>"data_table_odd", header=>"data_table_header").
  If a hash reference is not found, a reference to an array of three color strings is expected to provided for backgrounds for even-row records, odd-row records, and -der row, respectively.  A default color array ("#D4D4BF","#ECECE4","#CCCC99") will be used if $colors isn't defined. 
  
  Before version 1.59, the parameter can only accept an array reference. 
  
  $tag_tbl: a reference to a hash that specifies any legal attributes such as name, border,
  id, class, etc. for the TABLE tag.
  
  $tag_tr: a reference to a hash that specifies any legal attributes for the TR tag.
  
  $tag_th: a reference to a hash that specifies any legal attributes for the TH tag.
  
  $tag_td: a reference to a hash that specifies any legal attributes for the TD tag.
  
  Notice $tag_tr and $tag_th controls all the rows and columns of the whole table. The keys of the hash are the attribute names in these cases. However, $tag_td is column specific, i.e., you should specify TD attributes for every column separately.
  The key of %$tag_td are either column names or column indices, the value is the full string to be inserted into the TD tag. E.g., $tag_td  = {col3 => 'align=right valign=bottom} only change the TD tag in "col3" to be &lt;TD align=right valign=bottom&gt;.
  
  $portrait controls the layout of the table. The default is 1, i.e., the table is shown in the
  "Portrait" style, like in Excel. 0 means "Landscape". Since version 1.59, tbody and thead tags are added to the portrait mode output.
  
  Attention: You will have to escape HTML-Entities yourself (for example '<' as '&lt;'), if you have characters in you table which need to be escaped. You can do this for example with the escapeHTML-function from CGI.pm (or the HTML::Entities module).
  
    use CGI qw(escapeHTML);
    [...]
    $t->colMap($columnname, sub{escapeHTML($_)}); # for every column, where HTML-Entities occur.
  
  =item string table::html2 ($colors = ["#D4D4BF","#ECECE4","#CCCC99"],
  		 	   $specs = {'name' => '', 'border' => '1', ...})
  
  This method is deprecated. It's here for compatibility. It now simple call html method with $portrait = 0, see previous description.
  
  return a string corresponding to a "Landscape" html-tagged table.
  This is useful to present a table with many columns, but very few entries.
  Check the above table::html for parameter descriptions.
  
  =back
  
  =head2 Table Operations
  
  =over 4
  
  =item int table::setElm ($rowIdx, $colID, $val)
  
  modify the value of a table element at [$rowIdx, $colID] to a new value $val.
  It returns 1 upon success, undef otherwise. 
  In 1.68, setElm can manipulate multiple elements, i.e., $rowIdx and $colIdx can be references to an index array, and setElm() will modifies all cells defined by the grid.
  
      $t->setElm([0..2], ['ColA', 'ColB'], 'new value');
      $t->setElm(0, [1..2], 'new value');
  
      # puts a limit on the price of all expensive items
      $t_product->match_pattern_hash('$_{UnitPrice} > 20');
      $t_product->setElm($t_product->{MATCH}, 'UnitPrice', 20);
  
  =item int table::addRow ($rowRef, $rowIdx = table::nofRow, $arg_ref = {addNewCol => 0})
  
  add a new row ($rowRef may point to the actual list of scalars, or it can be a hash_ref (supported since version 1.60)).  If $rowRef points to a hash, the method will lookup the value of a field by ts column name: $rowRef->{colName}, if not found, undef is used for that field.
  The new row will be referred as $rowIdx as the result. E.g., addRow($aRow, 0) will put the new row as the very first row. By default, it appends a row to the end.
  In 1.67, we support {addNewCol => 1}, if specified, a new column will be automatically created for each new element encountered in the $rowRef.
  
      # automatically add a new column "aNewColumn" to $t, in order to hold the new value
      $t->addRow({anExistingColumn => 123, aNewColumn => "XYZ"}, undef, {addNewCol => 1});
      # $t only had one column, after this call, it will contain a new column 'col2', in order to hold the new value
      $t->addRow([123, "XYZ"], undef, {addNewCol => 1});
  
  It returns 1 upon success, undef otherwise.
  
  =item refto_array table::delRow ( $rowIdx )
  
  delete a row at $rowIdx. It will the reference to the deleted row.
  
  =item refto_array table::delRows ( $rowIdcsRef )
  
  delete rows in @$rowIdcsRef. It will return an array of deleted rows in the same order of $rowIdcsRef upon success.
  upon success.
  
  =item int table::addCol ($colRef, $colName, $colIdx = numCol)
  
  add a new column ($colRef points to the actual data), the new column will be referred as $colName or $colIdx as the result. E.g., addCol($aCol, 'newCol', 0) will put the new column as the very first column.
  By default, append a column to the end.
  It will return 1 upon success or undef otherwise.
  In 1.68, $colRef can be a scalar, which is the default value that can be used to create the new column.  E.g., to create a new column with default value of undef, 0, 'default', respectively, one can do:
  
     $t->addCol(undef, 'NewCol');
     $t->addCol(0, 'NewIntCol');
     $t->addCol('default', 'NewStringCol');
  
  
  =item refto_array table::delCol ($colID)
  
  delete a column at $colID
  return the reference to the deleted column.
  
  =item arrayof_refto_array table::delCols ($colIDsRef)
  
  delete a list of columns, pointed by $colIDsRef. It will
  return an array of deleted columns in the same order of $colIDsRef  upon success.
  
  =item refto_array table::rowRef ($rowIdx)
  
  return a reference to the row at $rowIdx
  upon success or undef otherwise.
  
  =item refto_arrayof_refto_array table::rowRefs ($rowIdcsRef)
  
  return a reference to array of row references upon success, undef otherwise.
  
  =item array table::row ($rowIdx)
  
  return a copy of the row at $rowIdx 
  upon success or undef otherwise.
  
  =item refto_hash table::rowHashRef ($rowIdx)
  
  return a reference to a hash, which contains a copy of the row at $rowIdx,
  upon success or undef otherwise. The keys in the hash are column names, and
  the values are corresponding elements in that row. The hash is a copy, therefore modifying the hash values doesn't change the original table.
  
  =item refto_array table::colRef ($colID)
  
  return a reference to the column at $colID
  upon success.
  
  =item refto_arrayof_refto_array table::colRefs ($colIDsRef)
  
  return a reference to array of column references upon success.
  
  =item array table::col ($colID)
  
  return a copy to the column at $colID
  upon success or undef otherwise.
  
  =item int table::rename ($colID, $newName)
  
  rename the column at $colID to a $newName 
  (the newName must be valid, 
  and should not be identical to any other existing column names).
  It returns 1 upon success
  or undef otherwise.
  
  =item refto_array table::replace ($oldColID, $newColRef, $newName)
  
  replace the column at $oldColID by the array pointed by $newColRef, and renamed it to $newName. $newName is optional if you don't want to rename the column.
  It returns 1 upon success or undef otherwise.
  
  =item int table::swap ($colID1, $colID2)
  
  swap two columns referred by $colID1 and $colID2.
  It returns 1 upon success or undef otherwise.
  
  =item int table::moveCol($colID, $colIdx, $newColName)
  
  move column referred by $colID to a new location $colIdx.
  If $newColName is specified, the column will be renamed as well.
  It returns 1 upon success or undef otherwise.
  
  =item int table::reorder($colIDRefs, $arg_ref)
  
  Rearrange the columns according to the order specified in $colIDRef.  Columns not specified in the reference array will be appended to the end!
  If one would like to drop columns not specified, set $arg_ref to {keepRest => 0}.
  reorder() changes the table itself, while subTable(undef, $colIDRefs) will return a new table.  reorder() might also runs faster than subTable, as elements may not need to be copied.
  
  =item int table::colMap ($colID, $fun)
  
  foreach element in column $colID, map a function $fun to it.
  It returns 1 upon success or undef otherwise.
  This is a handy way to format a column. E.g. if a column named URL contains URL strings, colMap("URL", sub {"<a href='$_'>$_</a>"}) before html() will change each URL into a clickable hyper link while displayed in a web browser.
  
  =item int table::colsMap ($fun)
  
  foreach row in the table, map a function $fun to it.
  It can do whatever colMap can do and more.
  It returns 1 upon success or undef otherwise.
  colMap function only give $fun access to the particular element per row, while colsMap give $fun full access to all elements per row. E.g. if two columns named duration and unit (["2", "hrs"], ["30", "sec"]). colsMap(sub {$_->[0] .= " (".$_->[1].")"; } will change each row into (["2 hrs", "hrs"], ["30 sec", "sec"]).
  As show, in the $func, a column element should be referred as $_->[$colIndex].
  
  =item int table::sort($colID1, $type1, $order1, $colID2, $type2, $order2, ... )
  
  sort a table in place.
  First sort by column $colID1 in $order1 as $type1, then sort by $colID2 in $order2 as $type2, ...
  $type is 0 for numerical and 1 for others;
  $order is 0 for ascending and 1 for descending;
  
  In 1.62, instead of memorize these numbers, you can use constants instead (notice constants do not start with '$').
    Data::Table::NUMBER
    Data::Table::STRING
    Data::Table::ASC
    Data::Table::DESC
  
  Sorting is done in the priority of colID1, colID2, ...
  It returns 1 upon success or undef otherwise. 
  Notice the table is rearranged as a result! This is different from perl's list sort, which returns a sorted copy while leave the original list untouched, 
  the authors feel inplace sorting is more natural.
  
  table::sort can take a user supplied operator, this is useful when neither numerical nor alphabetic order is correct.
  
    $Well=["A_1", "A_2", "A_11", "A_12", "B_1", "B_2", "B_11", "B_12"];
    $t = Data::Table->new([$Well], ["PlateWell"], 1);
    $t->sort("PlateWell", 1, 0);
    print join(" ", $t->col("PlateWell"));
    # prints: A_1 A_11 A_12 A_2 B_1 B_11 B_12 B_2
    # in string sorting, "A_11" and "A_12" appears before "A_2";
    my $my_sort_func = sub {
      my @a = split /_/, $_[0];
      my @b = split /_/, $_[1];
      my $res = ($a[0] cmp $b[0]) || (int($a[1]) <=> int($b[1]));
    };
    $t->sort("PlateWell", $my_sort_func, 0);
    print join(" ", $t->col("PlateWell"));
    # prints the correct order: A_1 A_2 A_11 A_12 B_1 B_2 B_11 B_12
  
  =item table table::match_pattern ($pattern, $countOnly)
  
  return a new table consisting those rows evaluated to be true by $pattern 
  upon success or undef otherwise. If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK (should use $t->{OK} after 1.62) stores a true/false array for the original table rows. Using it, users can find out what are the rows being selected/unselected.
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  
  In the $pattern string, a column element should be referred as $_->[$colIndex]. E.g., match_pattern('$_->[0]>3 && $_->[1]=~/^L') retrieve all the rows where its first column is greater than 3 and second column starts with letter 'L'. Notice it only takes colIndex, column names are not acceptable here!
  
  =item table table::match_pattern_hash ($pattern, $countOnly)
  
  return a new table consisting those rows evaluated to be true by $pattern
  upon success or undef otherwise. If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK stores a reference to a true/false array for the original table rows. Using it, users can find out what are the rows being selected/unselected.
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  
  In the $pattern string, a column element should be referred as ${column_name}.
  match_pattern_hash() is added in 1.62. The difference between this method and match_pattern is each row is fed to the pattern as a hash %_.
  In the case of match_pattern, each row is fed as an array ref $_.  The pattern for match_pattern_hash() becomes much cleaner.
  
  If a table has two columns: Col_A as the 1st column and Col_B as the 2nd column, a filter "Col_A>2 AND Col_B<2" is written before as
  	$t->match_pattern('$_->[0] > 2 && $_->[1] <2');
  where we need to figure out $t->colIndex('Col_A') is 0 and $t->colIndex('Col_B') is 1, in order to build the pattern.
  Now you can use column name directly in the pattern:
  	$t->match_pattern_hash('$_{Col_A} >2 && $_{Col_B} <2');
  This method creates $t->{OK}, as well as @Data::Table::OK, same as match_pattern().
  
  =item table table::match_string ($s, $caseIgnore, $countOnly)
  
  return a new table consisting those rows contains string $s in any of its fields upon success, undef otherwise. if $caseIgnore evaluated to true, case will is be ignored (s/$s/i). If $countOnly is set to 1, it simply returns the number of rows that matches the string without making a new copy of table. $countOnly is 0 by default.
  
  Side effect: @Data::Table::OK stores a reference to a true/false array for the original table rows. 
  Side effect: @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.
  Using it, users can find out what are the rows being selected/unselected.
  The $s string is actually treated as a regular expression and 
  applied to each row element, therefore one can actually specify several keywords 
  by saying, for instance, match_string('One|Other').
  
  =item table table::rowMask($mask, $complement)
  
  mask is reference to an array, where elements are evaluated to be true or false. The size of the mask must be equal to the nofRow of the table. return a new table consisting those rows where the corresponding mask element is true (or false, when complement is set to true).
  
  E.g., $t1=$tbl->match_string('keyword'); $t2=$tbl->rowMask(\@Data::Table::OK, 1) creates two new tables. $t1 contains all rows match 'keyword', while $t2 contains all other rows.
  
  mask is reference to an array, where elements are evaluated to be true or false. The size of the mask must be equal to the nofRow of the table. return
   a new table consisting those rows where the corresponding mask element is true (or false, when complement is set to true).
  
  E.g., $t1=$tbl->match_string('keyword'); $t2=$tbl->rowMask(\@Data::Table::OK, 1) creates two new tables. $t1 contains all rows match 'keyword', while 
  $t2 contains all other rows.
  
  =item table table::iterator({$reverse => 0})
  
  Returns a reference to a enumerator routine, which enables one to loop through each table row. If $reverse is set to 1, it will enumerate backward.  The convenience here is each row is fetch as a rowHashRef, so one can easily access row elements by name.
  
      my $next = $t_product->iterator();
      while (my $row = $next->()) {
        # have access to a row as a hash reference, access row number by &$next(1);
        $t_product->setElm($next->(1), 'ProductName', 'New! '.$row->{ProductName});
      }
  
  In this example, each $row is fetched as a hash reference, so one can access the elements by $row->{colName}.
  Be aware that the elements in the hash is a copy of the original table elements, so modifying $row->{colName} does not modify the original table.  If table modification is intended, one needs to obtain the row index of the returned row.  $next->(1) call with a non-empty argument returns the row index of the record that was previously fetched with $next->().  In this example, one uses the row index to modify the original table.
  
  =item table table::each_group($colsToGroupBy, $funsToApply)
  
  Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first (keys sorted as string). Then for each group, subroutines $funToAppy is applied to corresponding rows.
  $funToApply are passed with two parameters ($tableRef, $rowIDsRef). All rows sharing the key are passed in as a Data::Table object (with all columns and in the order of ascending row index) in the first parameter.
  The second optional parameter contains an array of row indices of the group members.  Since all rows in the passed-in table contains the same keys, the key value can be obtained from its first table row.
  
  =item table table::group($colsToGroupBy, $colsToCalculate, $funsToApply, $newColNames, $keepRestCols)
  
  Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first. Then for each group, an array of subroutines (in $funsToAppy) are applied to corresponding columns and yield a list of new columns (specified in $newColNames).
  
  $colsToGroupBy, $colsToCalculate are references to array of colIDs. $funsToApply is a reference to array of subroutine references. $newColNames are a
  reference to array of new column name strings. If specified, the size of arrays pointed by $colsToCalculate, $funsToApply and $newColNames should be i
  dentical. A column may be used more than once in $colsToCalculate. 
  
  $keepRestCols is default to 1 (was introduced as 0 in 1.64, changed to 1 in 1.66 for backward compatibility) introduced in 1.64), otherwise, the remaining columns are returned with the first encountered value of that group.
  
  E.g., an employee salary table $t contains the following columns: Name, Sex, Department, Salary. (see examples in the SYNOPSIS)
  
    $t2 = $t->group(["Department","Sex"],["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"], 0);
  
  Department, Sex are used together as the primary key columns, a new column "Nof Employee" is created by counting the number of employee names in each group, a new column "Average Salary" is created by averaging the Salary data falled into each group. As the result, we have the head count and average salary information for each (Department, Sex) pair. With your own functions (such as sum, product, average, standard deviation, etc), group method is very handy for accounting purpose.
  If primary key columns are not defined, all records will be treated as one group.
  
    $t2 = $t->group(undef,["Name", "Salary"], [sub {scalar @_}, \&average], ["Nof Employee", "Average Salary"], 0);
  
  The above statement will output the total number of employees and their average salary as one line.
  
  =item table table::pivot($colToSplit, $colToSplitIsStringOrNumeric, $colToFill, $colsToGroupBy, $keepRestCols)
  
  Every unique values in a column (specified by $colToSplit) become a new column. undef value become "NULL".  $colToSplitIsStringOrNumeric is set to numeric (0 or Data::Table:NUMBER), the new column names are prefixed by "oldColumnName=". The new cell element is filled by the value specified by $colToFill (was 1/0 before version 1.63).
  
  Note: yes, it seems I made an incompatible change in version 1.64, where $colToSplitIsStringOrNumber used to be $colToSplitIsNumeric, where 0 meant STRING and 1 meant NUMBER.  Now it is opposite.  However, I also added auto-type detection code, that this parameter essentially is auto-guessed and most old code should behave the same as before.
  
  When primary key columns are specified by $colsToGroupBy, all records sharing the same primary key collapse into one row, with values in $colToFill filling the corresponding new columns. If $colToFill is not specified, a cell is filled with the number of records fall into that cell.
  
  $colToSplit and $colToFill are colIDs. $colToSplitIsNumeric is 1/0. $colsToGroupBy is a reference to array of colIDs. $keepRestCols is 1/0, by default is 0. If $keepRestCols is off, only primary key columns and new columns are exported, otherwise, all the rest columns are exported as well.
  
  E.g., applying pivot method to the resultant table of the example of the group method.
  
    $t2->pivot("Sex", 0, "Average Salary",["Department"]);
  
  This creates a 2x3 table, where Departments are use as row keys, Sex (female and male) become two new columns. "Average Salary" values are used to fill the new table elements. Used together with group method, pivot method is very handy for accounting type of analysis.
  If $colsToGroupBy is left as undef, all rows are treated as one group.  If $colToSplit is left as undef, the method will generate a column named "(all)" that matches all records share the corresponding primary key.
  
  =item table table::melt($keyCols, $variableCols, $arg_ref)
  
  The idea of melt() and cast() are taken from Hadley Wickham's Reshape package in R language.
  A table is first melt() into a tall-skiny format, where measurements are stored in the format of a variable-value pair per row.
  Such a format can then be easily cast() into various contingency tables.
  
  One needs to specify the columns consisting of primary keys, columns that are consider as variable columns.  The output variable column is named 'variable' unless specified by $arg_ref{variableColName}.  The output value column is named 'value', unless specified in $arg_ref{valueColName}.  By default NULL values are not output, unless $arg_ref{skip_NULL} is set to false.  By default empty string values are kept, unless one sets skip_empty to `.
  
    For each object (id), we measure variable x1 and x2 at two time points
    $t = new Data::Table([[1,1,5,6], [1,2,3,5], [2,1,6,1], [2,2,2,4]], ['id','time','x1','x2'], Data::Table::ROW_BASED);
    # id	time	x1	x2
    # 1	1	5	6
    # 1	2	3	5
    # 2	1	6	1
    # 2	2	2	4
  
    # melting a table into a tall-and-skinny table
    $t2 = $t->melt(['id','time']);
    #id      time    variable        value
    # 1       1       x1      5
    # 1       1       x2      6
    # 1       2       x1      3
    # 1       2       x2      5
    # 2       1       x1      6
    # 2       1       x2      1
    # 2       2       x1      2
    # 2       2       x2      4
    
    # casting the table, &average is a method to calculate mean
    # for each object (id), we calculate average value of x1 and x2 over time
    $t3 = $t2->cast(['id'],'variable',Data::Table::STRING,'value', \&average);
    # id      x1      x2
    # 1       4       5.5
    # 2       4       2.5
   
  
  =item table table::cast($colsToGroupBy, $colToSplit, $colToSplitIsStringOrNumeric, $colToCalculate, $funToApply)
  
  see melt(), as melt() and cast() are meant to use together.
  
  The table has been melten before.  cast() group the table according to primary keys specified in $colsToGroupBy. For each group of objects sharing the same id,
  it further groups values (specified by $colToCalculate) according to unique variable names (specified by $colToSplit).  Then it applies subroutine $funToApply to obtain an aggregate value.
  For the output, each unique primary key will be a row, each unique variable name will become a column, the cells are the calculated aggregated value.
  
  If $colsToGroupBy is undef, all rows are treated as within the same group.  If $colToSplit is undef, a new column "(all)" is used to hold the results.
  
    $t = Data::Table->new( # create an employ salary table
      [
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Tom', 'male', 'IT', 65000],
        ['John', 'male', 'IT', 75000],
        ['Peter', 'male', 'HR', 85000],
        ['Mary', 'female', 'HR', 80000],
        ['Nancy', 'female', 'IT', 55000],
        ['Jack', 'male', 'IT', 88000],
        ['Susan', 'female', 'HR', 92000]
      ],
      ['Name', 'Sex', 'Department', 'Salary'], Data::Table::ROW_BASED);
  
    # get a Department x Sex contingency table, get average salary across all four groups
    print $t->cast(['Department'], 'Sex', Data::Table::STRING, 'Salary', \&average)->csv(1);
    Department,female,male
    IT,55000,73600
    HR,86000,85000
    # get average salary for each department
    print $t->cast(['Department'], undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    Department,(all)
    IT,70500
    HR,85666.6666666667
  
    # get average salary for each gender
    print $t->cast(['Sex'], undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    Sex,(all)
    male,75500
    female,75666.6666666667
    
    # get average salary for all records
    print $t->cast(undef, undef, Data::Table::STRING, 'Salary', \&average)->csv(1);
    (all)
    75555.5555555556
  
  =back
  
  =head2 Table-Table Manipulations
  
  =over 4
  
  =item int table::rowMerge ($tbl, $argRef)
  
  Append all the rows in the table object $tbl to the original rows.
  Before 1.62, the merging table $tbl must have the same number of columns as the original, as well as the columns are in exactly the same order.
  It returns 1 upon success, undef otherwise.
  The table object $tbl should not be used afterwards, since it becomes part of
  the new table.
  
  Since 1.62, you may provide {byName =>1, addNewCol=>1} as $argRef.  If byName is set to 1, the columns in in $tbl do not need to be in the same order as they are in the first table, instead the column name is used for the matching.  If addNewCol is set to 1, if $tbl contains a new column name that does not already exist in the first table, this new column will be automatically added to the resultant table.  Typically, you want to specify there two options simultaneously.
  
  =item int table::colMerge ($tbl, $argRef)
  
  Append all the columns in table object $tbl to the original columns. 
  Table $tbl must have the same number of rows as the original.
  It returns 1 upon success, undef otherwise.
  Table $tbl should not be used afterwards, since it becomes part of
  the new table.
  
  Since 1.62, you can specify {renameCol => 1} as $argRef. This is to auto fix any column name collision.  If $tbl contains a column that already exists in the first table, it will be renamed (by a suffix _2) to avoid the collision.
  
  =item table table::join ($tbl, $type, $cols1, $cols2, $argRef)
  
  Join two tables. The following join types are supported (defined by $type):
  
  0: inner join
  1: left outer join
  2: right outer join
  3: full outer join
  
  In 1.62, instead of memorize these numbers, you can use constants instead (notice constants do not start with '$').
    Data::Table::INNER_JOIN
    Data::Table::LEFT_JOIN
    Data::Table::RIGHT_JOIN
    Data::Table::FULL_JOIN
  
  $cols1 and $cols2 are references to array of colIDs, where rows with the same elements in all listed columns are merged. As the result table, columns listed in $cols2 are deleted, before a new table is returned.
  
  The implementation is hash-join, the running time should be linear with respect to the sum of number of rows in the two tables (assume both tables fit in memory).
  
  If the non-key columns of the two tables share the same name, the routine will fail, as the result table cannot contain two columns of the same name.  In 1.62, one can specify {renameCol=>1} as $argRef, so that the second column will be automatically renamed (with suffix _2) to avoid collision.
  
  If you would like to treat the NULLs in the key columns as empty string, set {NULLasEmpty => 1}.  If you do not want to treat NULLs as empty strings, but you still like the NULLs in two tables to be considered as equal (but not equal to ''), set {matchNULL => 1}.  Obviously if NULLasEmpty is set to 1, matchNULL will have no effect.
  
  =back
  
  =head2 Internal Methods
  
  All internal methods are mainly implemented for used by 
  other methods in the Table class. Users should avoid using them.
  Nevertheless, they are listed here for developers who 
  would like to understand the code and may derive a new class from Data::Table.
  
  =over 4
  
  =item int table::rotate
  
  convert the internal structure of a table between row-based and column-based.
  return 1 upon success, undef otherwise.
  
  =item string csvEscape($string, {delimiter=>, qualifier})
  
  Encode a scalar into a CSV-formatted field.
  
  optional named arguments: delimiter and qualifier, in case user wants to use characters other than the defaults. 
  The default delimiter and qualifier is taken from $Data::Table::DEFAULTS{'CSV_DELIMITER'} (defaults to ',') and $Data::Table::DEFAULTS{'CSV_QUALIFIER'} (defaults to '"'), respectively.
  
  Please note that this function only escape one element in a table. To escape the whole table row, you need to
    join($delimiter, map {csvEscape($_)} @row . $endl;
  $endl refers to End-of-Line, which you may or may not want to add, and it is OS-dependent. Therefore, csvEscape method is kept to the simplest form as an element transformer.
  
  =item refto_array parseCSV($string)
  
  Break a CSV encoded string to an array of scalars (check it out, we did it the cool way).
  
  optional argument size: specify the expected number of fields after csv-split.
  optional named arguments: delimiter and qualifier, in case user wants to use characters other than the defaults.
  respectively. The default delimiter and qualifier is taken from $Data::Table::DEFAULTS{'CSV_DELIMITER'} (defaults to ',') and $Data::Table::DEFAULTS{'CSV_QUALIFIER'} (defaults to '"'), respectively.
  
  =item string tsvEscape($rowRef)
  
  Encode a scalar into a TSV-formatted string.
  
  =back
  
  =head1 TSV FORMAT
  
  There is no standard for TSV format as far as we know. CSV format can't handle binary data very well, therefore, we choose the TSV format to overcome this limitation.
  
  We define TSV based on MySQL convention.
  
    "\0", "\n", "\t", "\r", "\b", "'", "\"", and "\\" are all escaped by '\' in the TSV file.
    (Warning: MySQL treats '\f' as 'f', and it's not escaped here)
    Undefined values are represented as '\N'.
  
  However, you can switch off this transformation by setting {transform_element => 0} in the fromTSV or tsv method.
  Before if a cell reads 'A line break is \n', it is read in as 'A link break is [return]' in memory. When use tsv method to export, it is transformed back to 'A line break is \n'. However, if it is exported as a csv, the [return] will break the format. Now if transform_element is set to 0, the cell is stored as 'A line break is \n' in memory, so that csv export will be correct. However, do remember to set {transform_element => 0} in tsv export method, otherwise, the cell will become 'A line break is \\n'. Be aware that trasform_element controls column headers as well.
  
  =head1 INTERFACE TO OTHER SOFTWARES
  
  Spreadsheet is a very generic type, therefore Data::Table class provides an easy
  interface between databases, web pages, CSV/TSV files, graphics packages, etc.
  
  Here is a summary (partially repeat) of some classic usages of Data::Table.
  
  =head2 Interface to Database and Web
  
    use DBI;
  
    $dbh= DBI->connect("DBI:mysql:test", "test", "") or die $DBI::errstr;
    my $minAge = 10;
    $t = Data::Table::fromSQL($dbh, "select * from mytable where age >= ?", [$minAge]);
    print $t->html;
  
  =head2 Interface to CSV/TSV
  
    $t = fromFile("mydata.csv"); # after version 1.51
    $t = fromFile("mydata.tsv"); # after version 1.51
  
    $t = fromCSV("mydata.csv");
    $t->sort(1,1,0);
    print $t->csv;
  
    Same for TSV
  
  =head2 Interface to Excel XLS/XLSX
  
  Read in two tables from NorthWind.xls file, writes them out to XLSX format.  See Data::Table::Excel module for details.
  
    use Data::Table::Excel;
  
    my ($tableObjects, $tableNames)=xls2tables("NorthWind.xls");
    $t_category = $tableObjects[0];
    $t_product = $tableObjects[1];
  
    tables2xlsx("NorthWind.xlsx", [$t_category, $t_product]);
  
  =head2 Interface to Graphics Package
  
    use GD::Graph::points;
  
    $graph = GD::Graph::points->new(400, 300);
    $t2 = $t->match('$_->[1] > 20 && $_->[3] < 35.7');
    my $gd = $graph->plot($t->colRefs([0,2]));
    open(IMG, '>mygraph.png') or die $!;
    binmode IMG;
    print IMG $gd->png;
    close IMG;
  
  =head1 AUTHOR
  
  Copyright 1998-2008, Yingyao Zhou & Guangzhou Zou. All rights reserved.
  
  It was first written by Zhou in 1998, significantly improved and maintained by Zou since 1999. The authors thank Tong Peng and Yongchuang Tao for valuable suggestions. We also thank those who kindly reported bugs, some of them are acknowledged in the "Changes" file.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please send bug reports and comments to: easydatabase at gmail dot com. When sending
  bug reports, please provide the version of Table.pm, the version of
  Perl.
  
  =head1 SEE ALSO
  
    DBI, GD::Graph, Data::Table::Excel.
  
  =cut
  
DATA_TABLE

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  {
    $Devel::StackTrace::VERSION = '1.30';
  }
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      # Backwards compatibility - this parameter was renamed to no_refs
      # ages ago.
      $p{no_refs} = delete $p{no_object_refs}
          if exists $p{no_object_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data();
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      # We exclude this method by starting one frame back.
      my $x = 1;
      while (
          my @c
          = $self->{no_args}
          ? caller( $x++ )
          : do {
              package    # the newline keeps dzil from adding a version here
                  DB;
              @DB::args = ();
              caller( $x++ );
          }
          ) {
  
          my @args;
  
          unless ( $self->{no_args} ) {
              @args = @DB::args;
  
              if ( $self->{no_refs} ) {
                  @args = map { ref $_ ? $self->_ref_to_string($_) : $_ } @args;
              }
          }
  
          push @{ $self->{raw} },
              {
              caller => \@c,
              args   => \@args,
              };
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      local $@;
      local $SIG{__DIE__};
  
      my $str = eval { $ref . '' };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next unless $filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub { 1 };
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          local $@;
          local $SIG{__DIE__};
  
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless eval { @{ $self->{ignore_package} } };
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $p    = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $p,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames();
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames();
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  }
  
  sub frames {
      my $self = shift;
  
      if (@_) {
          die
              "Devel::StackTrace->frames() can only take Devel::StackTrace::Frame args\n"
              if grep { !$_->isa('Devel::StackTrace::Frame') } @_;
  
          $self->{frames} = \@_;
      }
      else {
          $self->_make_frames() if $self->{raw};
      }
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames() )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames() );
  }
  
  sub as_string {
      my $self = shift;
      my $p    = shift;
  
      my $st    = '';
      my $first = 1;
      foreach my $f ( $self->frames() ) {
          $st .= $f->as_string( $first, $p ) . "\n";
          $first = 0;
      }
  
      return $st;
  }
  
  {
      package
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 1.30
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new;
  
    print $trace->as_string; # like carp
  
    # from top (most recent) of stack to bottom.
    while (my $frame = $trace->next_frame) {
        print "Has args\n" if $frame->hasargs;
    }
  
    # from bottom (least recent) of stack to top.
    while (my $frame = $trace->prev_frame) {
        print "Sub: ", $frame->subroutine, "\n";
    }
  
  =head1 DESCRIPTION
  
  The Devel::StackTrace module contains two classes, Devel::StackTrace
  and Devel::StackTrace::Frame.  The goal of this object is to encapsulate
  the information that can found through using the caller() function, as
  well as providing a simple interface to this data.
  
  The Devel::StackTrace object contains a set of Devel::StackTrace::Frame
  objects, one for each level of the stack.  The frames contain all the
  data available from C<caller()>.
  
  This code was created to support my L<Exception::Class::Base> class
  (part of Exception::Class) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top'
  and 'bottom'.  In this context, the 'top' frame on the stack is the
  most recent frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new;  # top frame is here.
    }
  
  =head1 Devel::StackTrace METHODS
  
  =over 4
  
  =item * Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 8
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the
  call to its its constructor.
  
  However, you may want to filter out some frames with more granularity
  than 'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data
  for each frame. This is a hash reference with two keys, "caller", and
  "args", both of which are array references. The "caller" key is the
  raw data as returned by Perl's C<caller()> function, and the "args"
  key are the subroutine arguments found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or
  false if it should be skipped.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on
  the stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages
  (or is the same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package'
  parameter, meaning that the Devel::StackTrace package is B<ALWAYS>
  ignored.  However, if you create a subclass of Devel::StackTrace it
  will not be ignored.
  
  =item * no_refs => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store
  references internally when generating stacktrace frames.  This lets
  your objects go out of scope.
  
  Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * no_args => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store caller
  arguments in stack trace frames at all.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef()> to get
  the underlying string representation of an object, instead of
  respecting the object's stringification overloading.  If you would
  prefer to see the overloaded representation of objects in stack
  traces, then set this parameter to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for each
  subroutine call. Setting this parameter causes truncates each subroutine
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess()>.
  
  =back
  
  =item * $trace->next_frame
  
  Returns the next Devel::StackTrace::Frame object down on the stack.  If
  it hasn't been called before it returns the first frame.  It returns
  undef when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<next_frame> or C<prev_frame> will work
  properly.
  
  =item * $trace->prev_frame
  
  Returns the next Devel::StackTrace::Frame object up on the stack.  If it
  hasn't been called before it returns the last frame.  It returns undef
  when it reaches the top of the stack and then resets its pointer so
  pointer so the next call to C<next_frame> or C<prev_frame> will work
  properly.
  
  =item * $trace->reset_pointer
  
  Resets the pointer so that the next call C<next_frame> or
  C<prev_frame> will start at the top or bottom of the stack, as
  appropriate.
  
  =item * $trace->frames
  
  When this method is called with no arguments, it returns a list of
  L<Devel::StackTrace::Frame> objects. They are returned in order from top (most
  recent) to bottom.
  
  This method can also be used to set the object's frames if you pass it a list
  of L<Devel::StackTrace::Frame> objects objects.
  
  This is useful if you want to filter the list of frames in ways that are more
  complex than can be handled by C<filter_frames>:
  
    $stacktrace->frames( my_filter( $stacktrace->frames() ) );
  
  =item * $trace->frame ($index)
  
  Given an index, returns the relevant frame or undef if there is not
  frame at that index.  The index is exactly like a Perl array.  The
  first frame is 0 and negative indexes are allowed.
  
  =item * $trace->frame_count
  
  Returns the number of frames in the trace object.
  
  =item * $trace->as_string(\%p)
  
  Calls as_string on each frame from top to bottom, producing output
  quite similar to the Carp module's cluck/confess methods.
  
  The optional C<\%p> parameter only has one useful option. The
  C<max_arg_length> parameter truncates each subroutine argument's string
  representation if it is longer than this number of characters.
  
  =back
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AStackTrace
  or via email at bug-devel-stacktrace@rt.cpan.org.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  {
    $Devel::StackTrace::Frame::VERSION = '1.30';
  }
  
  use strict;
  use warnings;
  
  # Create accessor routines
  BEGIN {
      no strict 'refs';
      foreach my $f (
          qw( package filename line subroutine hasargs
          wantarray evaltext is_require hints bitmask args )
          ) {
          next if $f eq 'args';
          *{$f} = sub { my $s = shift; return $s->{$f} };
      }
  }
  
  {
      my @fields = (
          qw( package filename line subroutine hasargs wantarray
              evaltext is_require hints bitmask )
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@fields} = @{ shift() };
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          $self->{args} = shift;
  
          $self->{respect_overload} = shift;
  
          $self->{max_arg_length} = shift;
  
          $self->{message} = shift;
  
          $self->{indent} = shift;
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
      my $p     = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked.  All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  $_ = "undef", next unless defined $_;
  
                  # hack!
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
  
                  local $SIG{__DIE__};
                  local $@;
  
                  eval {
                      my $max_arg_length
                          = exists $p->{max_arg_length}
                          ? $p->{max_arg_length}
                          : $self->{max_arg_length};
  
                      if ( $max_arg_length
                          && length $_ > $max_arg_length ) {
                          substr( $_, $max_arg_length ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 1.30
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =head1 METHODS
  
  See the L<caller> documentation for more information on what these
  methods return.
  
  =over 4
  
  =item * $frame->package
  
  =item * $frame->filename
  
  =item * $frame->line
  
  =item * $frame->subroutine
  
  =item * $frame->hasargs
  
  =item * $frame->wantarray
  
  =item * $frame->evaltext
  
  Returns undef if the frame was not part of an eval.
  
  =item * $frame->is_require
  
  Returns undef if the frame was not part of a require.
  
  =item * $frame->args
  
  Returns the arguments passed to the frame.  Note that any arguments
  that are references are returned as references, not copies.
  
  =item * $frame->hints
  
  =item * $frame->bitmask
  
  =back
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE_FRAME

$fatpacked{"Devel/TypeTiny/Perl56Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL56COMPAT';
  package Devel::TypeTiny::Perl56Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';
  
  #### B doesn't provide perlstring() in 5.6. Monkey patch it.
  
  use B ();
  
  unless (exists &B::perlstring)
  {
  	my $d;
  	*B::perlstring = sub {
  		no warnings 'uninitialized';
  		require Data::Dumper;
  		$d ||= 'Data::Dumper'->new([])->Indent(0)->Purity(0)->Pad('')->Useqq(1)->Terse(1)->Freezer('')->Toaster('');
  		my $perlstring = $d->Values([''.shift])->Dump;
  		($perlstring =~ /^"/) ? $perlstring : qq["$perlstring"];
  	};
  }
  
  push @B::EXPORT_OK, 'perlstring';
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl56Compat - shims to allow Type::Tiny to run on Perl 5.6.x
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<B> to export a
  C<perlstring> function, as this was only added in Perl 5.8.0.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL56COMPAT

$fatpacked{"Devel/TypeTiny/Perl58Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL58COMPAT';
  package Devel::TypeTiny::Perl58Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';
  
  #### re doesn't provide is_regexp in Perl < 5.10
  
  eval 'require re';
  
  unless (exists &re::is_regexp)
  {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object($_[0])->MAGIC->TYPE eq 'r' };
  	};
  }
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl58Compat - shims to allow Type::Tiny to run on Perl 5.8.x
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<re> to provide a
  C<is_regexp> function, as this was only added in Perl 5.9.5.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL58COMPAT

$fatpacked{"Error/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY';
  package Error::TypeTiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::VERSION   = '1.000005';
  }
  
  use overload
  	q[""]    => sub { $_[0]->to_string },
  	q[bool]  => sub { 1 },
  	fallback => 1,
  ;
  
  our %CarpInternal;
  $CarpInternal{$_}++ for qw(
  	Eval::TypeTiny
  	Eval::TypeTiny::Sandbox
  	Exporter::Tiny
  	Test::TypeTiny
  	Type::Coercion
  	Type::Coercion::Union
  	Error::TypeTiny
  	Type::Library
  	Type::Params
  	Type::Registry
  	Types::Standard
  	Types::Standard::_Stringable
  	Types::TypeTiny
  	Type::Tiny
  	Type::Tiny::Class
  	Type::Tiny::Duck
  	Type::Tiny::Enum
  	Type::Tiny::Intersection
  	Type::Tiny::Role
  	Type::Tiny::Union
  	Type::Utils
  );
  
  sub new
  {
  	my $class = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	return bless \%params, $class;
  }
  
  sub throw
  {
  	my $class = shift;
  	
  	my ($level, @caller, %ctxt) = 0;
  	while (
  		defined scalar caller($level) and $CarpInternal{scalar caller($level)}
  	) { $level++ };
  	if ( ((caller($level - 1))[1]||"") =~ /^parameter validation for '(.+?)'$/ )
  	{
  		my ($pkg, $func) = ($1 =~ m{^(.+)::(\w+)$});
  		$level++ if caller($level) eq ($pkg||"");
  	}
  	@ctxt{qw/ package file line /} = caller($level);
  	
  	my $stack = undef;
  	if (our $StackTrace)
  	{
  		require Devel::StackTrace;
  		$stack = "Devel::StackTrace"->new(
  			ignore_package => [ keys %CarpInternal ],
  		);
  	}
  	
  	die(
  		our $LastError = $class->new(
  			context     => \%ctxt,
  			stack_trace => $stack,
  			@_,
  		)
  	);
  }
  
  sub message     { $_[0]{message} ||= $_[0]->_build_message };
  sub context     { $_[0]{context} };
  sub stack_trace { $_[0]{stack_trace} };
  
  sub to_string
  {
  	my $e = shift;
  	my $c = $e->context;
  	my $m = $e->message;
  	
  	$m =~ /\n\z/s ? $m :
  	$c            ? sprintf("%s at %s line %s.\n", $m, $c->{file}||'file?', $c->{line}||'NaN') :
  	sprintf("%s\n", $m);
  }
  
  sub _build_message
  {
  	return 'An exception has occurred';
  }
  
  sub croak
  {
  	my ($fmt, @args) = @_;
  	@_ = (
  		__PACKAGE__,
  		message => sprintf($fmt, @args),
  	);
  	goto \&throw;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny - exceptions for Type::Tiny and friends
  
  =head1 SYNOPSIS
  
     use Data::Dumper;
     use Try::Tiny;
     use Types::Standard qw(Str);
     
     try {
        Str->assert_valid(undef);
     }
     catch {
        my $exception = shift;
        warn "Encountered Error: $exception";
        warn Dumper($exception->explain)
           if $exception->isa("Error::TypeTiny::Assertion");
     };
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  When Type::Tiny and its related modules encounter an error, they throw an
  exception object. These exception objects inherit from Error::TypeTiny.
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< throw(%attributes) >>
  
  Constructs an exception and passes it to C<die>.
  
  Automatically populates C<context> and C<stack_trace> if appropriate.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<message>
  
  The error message.
  
  =item C<context>
  
  Hashref containing the package, file and line that generated the error.
  
  =item C<stack_trace>
  
  A more complete stack trace. This feature requires L<Devel::StackTrace>;
  use the C<< $StackTrace >> package variable to switch it on.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<to_string>
  
  Returns the message, followed by the context if it is set.
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< Error::TypeTiny::croak($format, @args) >>
  
  Functional-style shortcut to C<throw> method. Takes an C<sprintf>-style
  format string and optional arguments to construct the C<message>.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to call C<to_string>.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< %Error::TypeTiny::CarpInternal >>
  
  Serves a similar purpose to C<< %Carp::CarpInternal >>.
  
  =item C<< $Error::TypeTiny::StackTrace >>
  
  Boolean to toggle stack trace generation.
  
  =item C<< $Error::TypeTiny::LastError >>
  
  A reference to the last exception object thrown.
  
  =back
  
  =head1 CAVEATS
  
  Although Error::TypeTiny objects are thrown for errors produced by
  Type::Tiny, that doesn't mean every time you use Type::Tiny you'll get
  Error::TypeTinys whenever you want.
  
  For example, if you use a Type::Tiny type constraint in a Moose attribute,
  Moose will not call the constraint's C<assert_valid> method (which throws
  an exception). Instead it will call C<check> and C<get_message> (which do
  not), and will C<confess> an error message of its own. (The C<< $LastError >>
  package variable may save your bacon.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>,
  L<Error::TypeTiny::WrongNumberOfParameters>.
  
  L<Try::Tiny>, L<Try::Tiny::ByClass>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY

$fatpacked{"Error/TypeTiny/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_ASSERTION';
  package Error::TypeTiny::Assertion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Error::TypeTiny::Assertion::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Assertion::VERSION   = '1.000005';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub type               { $_[0]{type} };
  sub value              { $_[0]{value} };
  sub varname            { $_[0]{varname} ||= '$_' };
  sub attribute_step     { $_[0]{attribute_step} };
  sub attribute_name     { $_[0]{attribute_name} };
  
  sub has_type           { defined $_[0]{type} }; # sic
  sub has_attribute_step { exists $_[0]{attribute_step} };
  sub has_attribute_name { exists $_[0]{attribute_name} };
  
  sub new
  {
  	my $class = shift;
  	my $self  = $class->SUPER::new(@_);
  	
  	if (ref $Method::Generate::Accessor::CurrentAttribute)
  	{
  		require B;
  		my %d = %{$Method::Generate::Accessor::CurrentAttribute};
  		$self->{attribute_name} = $d{name} if defined $d{name};
  		$self->{attribute_step} = $d{step} if defined $d{step};
  		
  		if (defined $d{init_arg})
  		{
  			$self->{varname} = sprintf('$args->{%s}', B::perlstring($d{init_arg}));
  		}
  		elsif (defined $d{name})
  		{
  			$self->{varname} = sprintf('$self->{%s}', B::perlstring($d{name}));
  		}
  	}
  	
  	return $self;
  }
  
  sub message
  {
  	my $e = shift;
  	$e->varname eq '$_'
  		? $e->SUPER::message
  		: sprintf('%s (in %s)', $e->SUPER::message, $e->varname);
  }
  
  sub _build_message
  {
  	my $e = shift;
  	$e->has_type
  		? sprintf('%s did not pass type constraint "%s"', Type::Tiny::_dd($e->value), $e->type)
  		: sprintf('%s did not pass type constraint', Type::Tiny::_dd($e->value))
  }
  
  *to_string = sub
  {
  	my $e = shift;
  	my $msg = $e->message;
  	
  	my $c = $e->context;
  	$msg .= sprintf(" at %s line %s", $c->{file}||'file?', $c->{line}||'NaN') if $c;
  	
  	my $explain = $e->explain;
  	return $msg unless @{ $explain || [] };
  	
  	$msg .= "\n";
  	for my $line (@$explain) {
  		$msg .= "    $line\n";
  	}
  	
  	return $msg;
  } if $] >= 5.008;
  
  sub explain
  {
  	my $e = shift;
  	return undef unless $e->has_type;
  	$e->type->validate_explain($e->value, $e->varname);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Assertion - exception when a value fails a type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This exception is thrown when a value fails a type constraint assertion.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type>
  
  The type constraint that was checked against. Weakened links are involved,
  so this may end up being C<undef>.
  
  =item C<value>
  
  The value that was tested.
  
  =item C<varname>
  
  The name of the variable that was checked, if known. Defaults to C<< '$_' >>.
  
  =item C<attribute_name>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will tell you which attribute (if
  your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =item C<attribute_step>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will contain either C<< "isa check" >>
  or C<< "coercion" >> to indicate which went wrong (if your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_type>, C<has_attribute_name>, C<has_attribute_step>
  
  Predicate methods.
  
  =item C<message>
  
  Overridden to add C<varname> to the message if defined.
  
  =item C<explain>
  
  Attempts to explain why the value did not pass the type constraint. Returns
  an arrayref of strings providing step-by-step reasoning; or returns undef if
  no explanation is possible.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_ASSERTION

$fatpacked{"Error/TypeTiny/Compilation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_COMPILATION';
  package Error::TypeTiny::Compilation;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::Compilation::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Compilation::VERSION   = '1.000005';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub code        { $_[0]{code} };
  sub environment { $_[0]{environment} ||= {} };
  sub errstr      { $_[0]{errstr} };
  
  sub _build_message
  {
  	my $self = shift;
  	sprintf("Failed to compile source because: %s", $self->errstr);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Compilation - exception for Eval::TypeTiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Thrown when compiling a closure fails. Common causes are problems with
  inlined type constraints, and syntax errors when coercions are given as
  strings of Perl code.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<code>
  
  The Perl source code being compiled.
  
  =item C<environment>
  
  Hashref of variables being closed over.
  
  =item C<errstr>
  
  Error message from Perl compiler.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_COMPILATION

$fatpacked{"Error/TypeTiny/WrongNumberOfParameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS';
  package Error::TypeTiny::WrongNumberOfParameters;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::WrongNumberOfParameters::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::WrongNumberOfParameters::VERSION   = '1.000005';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub minimum    { $_[0]{minimum} };
  sub maximum    { $_[0]{maximum} };
  sub got        { $_[0]{got} };
  
  sub has_minimum { exists $_[0]{minimum} };
  sub has_maximum { exists $_[0]{maximum} };
  
  sub _build_message
  {
  	my $e = shift;
  	if ($e->has_minimum and $e->has_maximum and $e->minimum == $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	elsif ($e->has_minimum and $e->has_maximum and $e->minimum < $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d to %d",
  			$e->got,
  			$e->minimum,
  			$e->maximum,
  		);
  	}
  	elsif ($e->has_minimum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected at least %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	else
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d",
  			$e->got,
  		);
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::WrongNumberOfParameters - exception for Type::Params
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Thrown when a Type::Params compiled check is called with the wrong number
  of parameters.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<minimum>
  
  The minimum expected number of parameters.
  
  =item C<maximum>
  
  The maximum expected number of parameters.
  
  =item C<got>
  
  The number of parameters actually passed to the compiled check.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_minimum>, C<has_maximum>
  
  Predicate methods.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS

$fatpacked{"Eval/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_TYPETINY';
  package Eval::TypeTiny;
  
  use strict;
  
  BEGIN {
  	*HAS_LEXICAL_SUBS = ($] >= 5.018) ? sub(){!!1} : sub(){!!0};
  };
  
  {
  	my $hlv;
  	sub HAS_LEXICAL_VARS () {
  		$hlv = !! eval {
  			require Devel::LexAlias;
  			exists(&Devel::LexAlias::lexalias);
  		} unless defined $hlv;
  		$hlv;
  	}
  }
  
  sub _clean_eval
  {
  	local $@;
  	local $SIG{__DIE__};
  	my $r = eval $_[0];
  	my $e = $@;
  	return ($r, $e);
  }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';
  our @EXPORT    = qw( eval_closure );
  our @EXPORT_OK = qw( HAS_LEXICAL_SUBS HAS_LEXICAL_VARS );
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  use warnings;
  
  sub eval_closure
  {
  	my (%args) = @_;
  	my $src    = ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source};
  	
  	$args{alias}  = 0 unless defined $args{alias};
  	$args{line}   = 1 unless defined $args{line};
  	$args{description} =~ s/[^\w .:-\[\]\(\)\{\}\']//g if defined $args{description};
  	$src = qq{#line $args{line} "$args{description}"\n$src} if defined $args{description} && !($^P & 0x10);
  	$args{environment} ||= {};
  	
  #	for my $k (sort keys %{$args{environment}})
  #	{
  #		next if $k =~ /^\$/ && ref($args{environment}{$k}) =~ /^(SCALAR|REF)$/;
  #		next if $k =~ /^\@/ && ref($args{environment}{$k}) eq q(ARRAY);
  #		next if $k =~ /^\%/ && ref($args{environment}{$k}) eq q(HASH);
  #		
  #		require Error::TypeTiny;
  #		Error::TypeTiny::croak("Expected a variable name and ref; got %s => %s", $k, $args{environment}{$k});
  #	}
  	
  	my $sandpkg   = 'Eval::TypeTiny::Sandbox';
  	my $alias     = exists($args{alias}) ? $args{alias} : 0;
  	my @keys      = sort keys %{$args{environment}};
  	my $i         = 0;
  	my $source    = join "\n" => (
  		"package $sandpkg;",
  		"sub {",
  		map(_make_lexical_assignment($_, $i++, $alias), @keys),
  		$src,
  		"}",
  	);
  	
  	_manufacture_ties() if $alias && !HAS_LEXICAL_VARS;
  	
  	my ($compiler, $e) = _clean_eval($source);
  	if ($e)
  	{
  		chomp $e;
  		require Error::TypeTiny::Compilation;
  		"Error::TypeTiny::Compilation"->throw(
  			code        => (ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source}),
  			errstr      => $e,
  			environment => $args{environment},
  		);
  	}
  	
  	my $code = $compiler->(@{$args{environment}}{@keys});
  	undef($compiler);
  
  	if ($alias && HAS_LEXICAL_VARS) {
  		Devel::LexAlias::lexalias($code, $_, $args{environment}{$_}) for grep !/^\&/, @keys;
  	}
  	
  	return $code;
  }
  
  my $tmp;
  sub _make_lexical_assignment
  {
  	my ($key, $index, $alias) = @_;
  	my $name = substr($key, 1);
  	
  	if (HAS_LEXICAL_SUBS and $key =~ /^\&/) {
  		$tmp++;
  		my $tmpname = '$__LEXICAL_SUB__'.$tmp;
  		return
  			"no warnings 'experimental::lexical_subs';".
  			"use feature 'lexical_subs';".
  			"my $tmpname = \$_[$index];".
  			"my sub $name { goto $tmpname };";
  	}
  	
  	if (!$alias) {
  		my $sigil = substr($key, 0, 1);
  		return "my $key = $sigil\{ \$_[$index] };";
  	}
  	elsif (HAS_LEXICAL_VARS) {
  		return "my $key;";
  	}
  	else {
  		my $tieclass = {
  			'@' => 'Eval::TypeTiny::_TieArray',
  			'%' => 'Eval::TypeTiny::_TieHash',
  			'$' => 'Eval::TypeTiny::_TieScalar',
  		}->{ substr($key, 0, 1) };
  		
  		return sprintf(
  			'tie(my(%s), "%s", $_[%d]);',
  			$key,
  			$tieclass,
  			$index,
  		);
  	}
  }
  
  { my $tie; sub _manufacture_ties { $tie ||= eval <<'FALLBACK'; } }
  no warnings qw(void once uninitialized numeric);
  
  {
  	package #
  		Eval::TypeTiny::_TieArray;
  	require Tie::Array;
  	our @ISA = qw( Tie::StdArray );
  	sub TIEARRAY {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(@$self) and return tied(@$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(@$self) and tied(@$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied @{$_[0]} },
  		q[""]    => sub { '' . tied @{$_[0]} },
  		q[0+]    => sub { 0  + tied @{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieHash;
  	require Tie::Hash;
  	our @ISA = qw( Tie::StdHash );
  	sub TIEHASH {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(%$self) and return tied(%$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(%$self) and tied(%$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied %{$_[0]} },
  		q[""]    => sub { '' . tied %{$_[0]} },
  		q[0+]    => sub { 0  + tied %{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieScalar;
  	require Tie::Scalar;
  	our @ISA = qw( Tie::StdScalar );
  	sub TIESCALAR {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied($$self) and return tied($$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied($$self) and tied($$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied ${$_[0]} },
  		q[""]    => sub { '' . tied ${$_[0]} },
  		q[0+]    => sub { 0  + tied ${$_[0]} },
  		fallback => 1,
  	;
  }
  
  1;
  FALLBACK
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas coderefs
  
  =head1 NAME
  
  Eval::TypeTiny - utility to evaluate a string of Perl code in a clean environment
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This module is used by Type::Tiny to compile coderefs from strings of
  Perl code, and hashrefs of variables to close over.
  
  =head2 Functions
  
  This module exports one function, which works much like the similarly named
  function from L<Eval::Closure>:
  
  =over
  
  =item C<< eval_closure(source => $source, environment => \%env, %opt) >>
  
  =back
  
  =head2 Constants
  
  The following constants may be exported, but are not by default.
  
  =over
  
  =item C<< HAS_LEXICAL_SUBS >>
  
  Boolean indicating whether Eval::TypeTiny has support for lexical subs.
  (This feature requires Perl 5.18.)
  
  =item C<< HAS_LEXICAL_VARS >>
  
  Don't worry; closing over lexical variables in the closures is always
  supported! However, if this constant is true, it means that
  L<Devel::LexAlias> is available, which makes them slightly faster than
  the fallback solution which uses tied variables. (This only makes any
  difference when the C<< alias => 1 >> option is used.)
  
  =back
  
  =head1 EVALUATION ENVIRONMENT
  
  The evaluation is performed in the presence of L<strict>, but the absence of
  L<warnings>. (This is different to L<Eval::Closure> which enables warnings for
  compiled closures.)
  
  The L<feature> pragma is not active in the evaluation environment, so the
  following will not work:
  
     use feature qw(say);
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { say for @_ }',
     );
     $say_all->("Hello", "World");
  
  The L<feature> pragma does not "carry over" into the stringy eval. It is
  of course possible to import pragmas into the evaluated string as part of the
  string itself:
  
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { use feature qw(say); say for @_ }',
     );
     $say_all->("Hello", "World");
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Eval::Closure>, L<Error::TypeTiny::Compilation>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EVAL_TYPETINY

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.042';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  It does the following:
  
  =over
  
  =item * Marks your package as loaded in C<< %INC >>;
  
  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and
  
  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.
  
  =back
  
  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.042';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
  
  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		($name =~ m{\A\!(/.+/[msixpodual]+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp($1, $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]+\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };
  
  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	$global_opts->{is_unimport} = 1;
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);
  	
  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}
  		
  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }
  
  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }
  
  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;
  	
  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as};
  	
  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
  		
  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  # 
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");
  	
  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};
  	
  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name = $value->{-as} || $name;
  	unless (ref($name) eq q(SCALAR))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return ($$name = $sym)                       if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym)               if ref($into) eq q(HASH);
  	
  	no strict qw(refs);
  	
  	if (exists &{"$into\::$name"} and \&{"$into\::$name"} != $sym)
  	{
  		my ($level) = grep defined, $value->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};
  		
  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",
  			$into,
  			$name,
  			$_[0],
  			$class,
  		);
  	}
  	
  	our %TRACKED;
  	$TRACKED{$class}{$into}{$name} = $sym;
  	
  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$name, $sym])
  		: (*{"$into\::$name"} = $sym);
  }
  
  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;
  	
  	no strict qw(refs);
  	
  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;
  	
  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}
  	
  	delete $TRACKED{$class}{$into}{$name};
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords frobnicate greps regexps
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { my $n = shift; ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installler >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  Exporter::Tiny performs most of its internal duties (including resolution
  of tag names to sub names, resolution of sub names to coderefs, and
  installation of coderefs into the target package) as method calls, which
  means they can be overridden to provide interesting behaviour.
  
  =head2 Utility Functions
  
  These are really for internal use, but can be exported if you need them.
  
  =over
  
  =item C<< mkopt(\@array) >>
  
  Similar to C<mkopt> from L<Data::OptList>. It doesn't support all the
  fancy options that Data::OptList does (C<moniker>, C<require_unique>,
  C<must_be> and C<name_test>) but runs about 50% faster.
  
  =item C<< mkopt_hash(\@array) >>
  
  Similar to C<mkopt_hash> from L<Data::OptList>. See also C<mkopt>.
  
  =back
  
  =head1 TIPS AND TRICKS IMPORTING FROM EXPORTER::TINY
  
  For the purposes of this discussion we'll assume we have a module called
  C<< MyUtils >> which exports one function, C<< frobnicate >>. C<< MyUtils >>
  inherits from Exporter::Tiny.
  
  Many of these tricks may seem familiar from L<Sub::Exporter>. That is
  intentional. Exporter::Tiny doesn't attempt to provide every feature of
  Sub::Exporter, but where it does it usually uses a fairly similar API.
  
  =head2 Basic importing
  
     # import "frobnicate" function
     use MyUtils "frobnicate";
  
     # import all functions that MyUtils offers
     use MyUtils -all;
  
  =head2 Renaming imported functions
  
     # call it "frob"
     use MyUtils "frobnicate" => { -as => "frob" };
  
     # call it "my_frobnicate"
     use MyUtils "frobnicate" => { -prefix => "my_" };
  
     # can set a prefix for *all* functions imported from MyUtils
     # by placing the options hashref *first*.
     use MyUtils { prefix => "my_" }, "frobnicate";
     # (note the lack of hyphen before `prefix`.)
  
     # call it "frobnicate_util"
     use MyUtils "frobnicate" => { -suffix => "_util" };
     use MyUtils { suffix => "_util" }, "frobnicate";
  
     # import it twice with two different names
     use MyUtils
        "frobnicate" => { -as => "frob" },
        "frobnicate" => { -as => "frbnct" };
  
  =head2 Lexical subs
  
     {
        use Sub::Exporter::Lexical lexical_installer => { -as => "lex" };
        use MyUtils { installer => lex }, "frobnicate";
        
        frobnicate(...);  # ok
     }
     
     frobnicate(...);  # not ok
  
  =head2 Import functions into another package
  
     use MyUtils { into => "OtherPkg" }, "frobnicate";
     
     OtherPkg::frobincate(...);
  
  =head2 Import functions into a scalar
  
     my $func;
     use MyUtils "frobnicate" => { -as => \$func };
     
     $func->(...);
  
  =head2 Import functions into a hash
  
  OK, Sub::Exporter doesn't do this...
  
     my %funcs;
     use MyUtils { into => \%funcs }, "frobnicate";
     
     $funcs{frobnicate}->(...);
  
  =head2 DO NOT WANT!
  
  This imports everything except "frobnicate":
  
     use MyUtils qw( -all !frobnicate );
  
  Negated imports always "win", so the following will not import
  "frobnicate", no matter how many times you repeat it...
  
     use MyUtils qw( !frobnicate frobnicate frobnicate frobnicate );
  
  =head2 Importing by regexp
  
  Here's how you could import all functions beginning with an "f":
  
     use MyUtils qw( /^F/i );
  
  Or import everything except functions beginning with a "z":
  
     use MyUtils qw( -all !/^Z/i );
  
  Note that regexps are always supplied as I<strings> starting with
  C<< "/" >>, and not as quoted regexp references (C<< qr/.../ >>).
  
  =head2 Unimporting
  
  You can unimport the functions that MyUtils added to your namespace:
  
     no MyUtils;
  
  Or just specific ones:
  
     no MyUtils qw(frobnicate);
  
  If you renamed a function when you imported it, you should unimport by
  the new name:
  
     use MyUtils frobnicate => { -as => "frob" };
     ...;
     no MyUtils "frob";
  
  Unimporting using tags and regexps should mostly do what you want.
  
  =head1 TIPS AND TRICKS EXPORTING USING EXPORTER::TINY
  
  Simple configuration works the same as L<Exporter>; inherit from this module,
  and use the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables to list subs to export.
  
  =head2 Generators
  
  Exporter::Tiny has always allowed exported subs to be generated (like
  L<Sub::Exporter>), but until version 0.025 did not have an especially nice
  API for it.
  
  Now, it's easy. If you want to generate a sub C<foo> to export, list it in
  C<< @EXPORT >> or C<< @EXPORT_OK >> as usual, and then simply give your
  exporter module a class method called C<< _generate_foo >>.
  
     push @EXPORT_OK, 'foo';
     
     sub _generate_foo {
        my $class = shift;
        my ($name, $args, $globals) = @_;
        
        return sub {
           ...;
        }
     }
  
  You can also generate tags:
  
     my %constants;
     BEGIN {
        %constants = (FOO => 1, BAR => 2);
     }
     use constant \%constants;
     
     $EXPORT_TAGS{constants} = sub {
        my $class = shift;
        my ($name, $args, $globals) = @_;
        
        return keys(%constants);
     };
  
  =head2 Overriding Internals
  
  An important difference between L<Exporter> and Exporter::Tiny is that
  the latter calls all its internal functions as I<< class methods >>. This
  means that your subclass can I<< override them >> to alter their behaviour.
  
  The following methods are available to be overridden. Despite being named
  with a leading underscore, they are considered public methods. (The underscore
  is there to avoid accidentally colliding with any of your own function names.)
  
  =over
  
  =item C<< _exporter_validate_opts($globals) >>
  
  This method is called once each time C<import> is called. It is passed a
  reference to the global options hash. (That is, the optional leading hashref
  in the C<use> statement, where the C<into> and C<installer> options can be
  provided.)
  
  You may use this method to munge the global options, or validate them,
  throwing an exception or printing a warning.
  
  The default implementation does nothing interesting.
  
  =item C<< _exporter_validate_unimport_opts($globals) >>
  
  Like C<_exporter_validate_opts>, but called for C<unimport>.
  
  =item C<< _exporter_merge_opts($tag_opts, $globals, @exports) >>
  
  Called to merge options which have been provided for a tag into the
  options provided for the exports that the tag expanded to.
  
  =item C<< _exporter_expand_tag($name, $args, $globals) >>
  
  This method is called to expand an import tag (e.g. C<< ":constants" >>).
  It is passed the tag name (minus the leading ":"), an optional hashref
  of options (like C<< { -prefix => "foo_" } >>), and the global options
  hashref.
  
  It is expected to return a list of ($name, $args) arrayref pairs. These
  names can be sub names to export, or further tag names (which must have
  their ":"). If returning tag names, be careful to avoid creating a tag
  expansion loop!
  
  The default implementation uses C<< %EXPORT_TAGS >> to expand tags, and
  provides fallbacks for the C<< :default >> and C<< :all >> tags.
  
  =item C<< _exporter_expand_regexp($regexp, $args, $globals) >>
  
  Like C<_exporter_expand_regexp>, but given a regexp-like string instead
  of a tag name.
  
  The default implementation greps through C<< @EXPORT_OK >> for imports,
  and the list of already-imported functions for exports.
  
  =item C<< _exporter_expand_sub($name, $args, $globals) >>
  
  This method is called to translate a sub name to a hash of name => coderef
  pairs for exporting to the caller. In general, this would just be a hash with
  one key and one value, but, for example, L<Type::Library> overrides this
  method so that C<< "+Foo" >> gets expanded to:
  
     (
        Foo         => sub { $type },
        is_Foo      => sub { $type->check(@_) },
        to_Foo      => sub { $type->assert_coerce(@_) },
        assert_Foo  => sub { $type->assert_return(@_) },
     )
  
  The default implementation checks that the name is allowed to be exported
  (using the C<_exporter_permitted_regexp> method), gets the coderef using
  the generator if there is one (or by calling C<< can >> on your exporter
  otherwise) and calls C<_exporter_fail> if it's unable to generate or
  retrieve a coderef.
  
  =item C<< _exporter_permitted_regexp($globals) >>
  
  This method is called to retrieve a regexp for validating the names of
  exportable subs. If a sub doesn't match the regexp, then the default
  implementation of C<_exporter_expand_sub> will refuse to export it. (Of
  course, you may override the default C<_exporter_expand_sub>.)
  
  The default implementation of this method assembles the regexp from
  C<< @EXPORT >> and C<< @EXPORT_OK >>.
  
  =item C<< _exporter_fail($name, $args, $globals) >>
  
  Called by C<_exporter_expand_sub> if it can't find a coderef to export.
  
  The default implementation just throws an exception. But you could emit
  a warning instead, or just ignore the failed export.
  
  If you don't throw an exception then you should be aware that this
  method is called in list context, and any list it returns will be treated
  as an C<_exporter_expand_sub>-style hash of names and coderefs for
  export.
  
  =item C<< _exporter_install_sub($name, $args, $globals, $coderef) >>
  
  This method actually installs the exported sub into its new destination.
  Its return value is ignored.
  
  The default implementation handles sub renaming (i.e. the C<< -as >>,
  C<< -prefix >> and C<< -suffix >> functions. This method does a lot of
  stuff; if you need to override it, it's probably a good idea to just
  pre-process the arguments and then call the super method rather than
  trying to handle all of it yourself.
  
  =item C<< _exporter_uninstall_sub($name, $args, $globals) >>
  
  The opposite of C<_exporter_install_sub>.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item B<< Overwriting existing sub '%s::%s' with sub '%s' exported by %s >>
  
  A warning issued if Exporter::Tiny is asked to export a symbol which
  will result in an existing sub being overwritten. This warning can be
  suppressed using either of the following:
  
     use MyUtils { replace => 1 }, "frobnicate";
     use MyUtils "frobnicate" => { -replace => 1 };
  
  Or can be upgraded to a fatal error:
  
     use MyUtils { replace => "die" }, "frobnicate";
     use MyUtils "frobnicate" => { -replace => "die" };
  
  =item B<< Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s >>
  
  The fatal version of the above warning.
  
  =item B<< Could not find sub '%s' exported by %s >>
  
  You requested to import a sub which the package does not provide.
  
  =item B<< Cannot provide an -as option for tags >>
  
  Because a tag may provide more than one function, it does not make sense
  to request a single name for it. Instead use C<< -prefix >> or C<< -suffix >>.
  
  =item B<< Passing options to unimport '%s' makes no sense >>
  
  When you import a sub, it occasionally makes sense to pass some options
  for it. However, when unimporting, options do nothing, so this warning
  is issued.
  
  =back
  
  =head1 HISTORY
  
  L<Type::Library> had a bunch of custom exporting code which poked coderefs
  into its caller's stash. It needed this to be something more powerful than
  most exporters so that it could switch between exporting Moose, Mouse and
  Moo-compatible objects on request. L<Sub::Exporter> would have been capable,
  but had too many dependencies for the Type::Tiny project.
  
  Meanwhile L<Type::Utils>, L<Types::TypeTiny> and L<Test::TypeTiny> each
  used the venerable L<Exporter.pm|Exporter>. However, this meant they were
  unable to use the features like L<Sub::Exporter>-style function renaming
  which I'd built into Type::Library:
  
     ## import "Str" but rename it to "String".
     use Types::Standard "Str" => { -as => "String" };
  
  And so I decided to factor out code that could be shared by all Type-Tiny's
  exporters into a single place: Exporter::TypeTiny.
  
  As of version 0.026, Exporter::TypeTiny was also made available as
  L<Exporter::Tiny>, distributed independently on CPAN. CHOCOLATEBOY had
  convinced me that it was mature enough to live a life of its own.
  
  As of version 0.030, Type-Tiny depends on Exporter::Tiny and
  Exporter::TypeTiny is being phased out.
  
  =head1 OBLIGATORY EXPORTER COMPARISON
  
  Exporting is unlikely to be your application's performance bottleneck, but
  nonetheless here are some comparisons.
  
  B<< Comparative sizes according to L<Devel::SizeMe>: >>
  
     Exporter                     217.1Kb
     Sub::Exporter::Progressive   263.2Kb
     Exporter::Tiny               267.7Kb
     Exporter + Exporter::Heavy   281.5Kb
     Exporter::Renaming           406.2Kb
     Sub::Exporter                701.0Kb
  
  B<< Performance exporting a single sub: >>
  
                Rate     SubExp    ExpTiny SubExpProg      ExpPM
  SubExp      2489/s         --       -56%       -85%       -88%
  ExpTiny     5635/s       126%         --       -67%       -72%
  SubExpProg 16905/s       579%       200%         --       -16%
  ExpPM      20097/s       707%       257%        19%         --
  
  (Exporter::Renaming globally changes the behaviour of Exporter.pm, so could
  not be included in the same benchmarks.)
  
  B<< (Non-Core) Dependencies: >>
  
     Exporter                    -1
     Exporter::Renaming           0
     Exporter::Tiny               0
     Sub::Exporter::Progressive   0
     Sub::Exporter                3
  
  B<< Features: >>
  
                                        ExpPM   ExpTiny SubExp  SubExpProg
   Can export code symbols............. Yes     Yes     Yes     Yes      
   Can export non-code symbols......... Yes                              
   Groups/tags......................... Yes     Yes     Yes     Yes      
   Export by regexp.................... Yes     Yes                      
   Bang prefix......................... Yes     Yes                      
   Allows renaming of subs.............         Yes     Yes     Maybe    
   Install code into scalar refs.......         Yes     Yes     Maybe    
   Can be passed an "into" parameter...         Yes     Yes     Maybe    
   Can be passed an "installer" sub....         Yes     Yes     Maybe    
   Config avoids package variables.....                 Yes              
   Supports generators.................         Yes     Yes              
   Sane API for generators.............         Yes     Yes              
   Unimport............................         Yes                      
  
  (Certain Sub::Exporter::Progressive features are only available if
  Sub::Exporter is installed.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  L<Exporter::Shiny>,
  L<Sub::Exporter>,
  L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"File/Find/Rule.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_FIND_RULE';
  #       $Id$
  
  package File::Find::Rule;
  use strict;
  use File::Spec;
  use Text::Glob 'glob_to_regex';
  use Number::Compare;
  use Carp qw/croak/;
  use File::Find (); # we're only wrapping for now
  
  our $VERSION = '0.33';
  
  # we'd just inherit from Exporter, but I want the colon
  sub import {
      my $pkg = shift;
      my $to  = caller;
      for my $sym ( qw( find rule ) ) {
          no strict 'refs';
          *{"$to\::$sym"} = \&{$sym};
      }
      for (grep /^:/, @_) {
          my ($extension) = /^:(.*)/;
          eval "require File::Find::Rule::$extension";
          croak "couldn't bootstrap File::Find::Rule::$extension: $@" if $@;
      }
  }
  
  =head1 NAME
  
  File::Find::Rule - Alternative interface to File::Find
  
  =head1 SYNOPSIS
  
    use File::Find::Rule;
    # find all the subdirectories of a given directory
    my @subdirs = File::Find::Rule->directory->in( $directory );
  
    # find all the .pm files in @INC
    my @files = File::Find::Rule->file()
                                ->name( '*.pm' )
                                ->in( @INC );
  
    # as above, but without method chaining
    my $rule =  File::Find::Rule->new;
    $rule->file;
    $rule->name( '*.pm' );
    my @files = $rule->in( @INC );
  
  =head1 DESCRIPTION
  
  File::Find::Rule is a friendlier interface to File::Find.  It allows
  you to build rules which specify the desired files and directories.
  
  =cut
  
  # the procedural shim
  
  *rule = \&find;
  sub find {
      my $object = __PACKAGE__->new();
      my $not = 0;
  
      while (@_) {
          my $method = shift;
          my @args;
  
          if ($method =~ s/^\!//) {
              # jinkies, we're really negating this
              unshift @_, $method;
              $not = 1;
              next;
          }
          unless (defined prototype $method) {
              my $args = shift;
              @args = ref $args eq 'ARRAY' ? @$args : $args;
          }
          if ($not) {
              $not = 0;
              @args = $object->new->$method(@args);
              $method = "not";
          }
  
          my @return = $object->$method(@args);
          return @return if $method eq 'in';
      }
      $object;
  }
  
  
  =head1 METHODS
  
  =over
  
  =item C<new>
  
  A constructor.  You need not invoke C<new> manually unless you wish
  to, as each of the rule-making methods will auto-create a suitable
  object if called as class methods.
  
  =cut
  
  sub new {
      my $referent = shift;
      my $class = ref $referent || $referent;
      bless {
          rules    => [],
          subs     => {},
          iterator => [],
          extras   => {},
          maxdepth => undef,
          mindepth => undef,
      }, $class;
  }
  
  sub _force_object {
      my $object = shift;
      $object = $object->new()
        unless ref $object;
      $object;
  }
  
  =back
  
  =head2 Matching Rules
  
  =over
  
  =item C<name( @patterns )>
  
  Specifies names that should match.  May be globs or regular
  expressions.
  
   $set->name( '*.mp3', '*.ogg' ); # mp3s or oggs
   $set->name( qr/\.(mp3|ogg)$/ ); # the same as a regex
   $set->name( 'foo.bar' );        # just things named foo.bar
  
  =cut
  
  sub _flatten {
      my @flat;
      while (@_) {
          my $item = shift;
          ref $item eq 'ARRAY' ? push @_, @{ $item } : push @flat, $item;
      }
      return @flat;
  }
  
  sub name {
      my $self = _force_object shift;
      my @names = map { ref $_ eq "Regexp" ? $_ : glob_to_regex $_ } _flatten( @_ );
  
      push @{ $self->{rules} }, {
          rule => 'name',
          code => join( ' || ', map { "m{$_}" } @names ),
          args => \@_,
      };
  
      $self;
  }
  
  =item -X tests
  
  Synonyms are provided for each of the -X tests. See L<perlfunc/-X> for
  details.  None of these methods take arguments.
  
    Test | Method               Test |  Method
   ------|-------------        ------|----------------
     -r  |  readable             -R  |  r_readable
     -w  |  writeable            -W  |  r_writeable
     -w  |  writable             -W  |  r_writable
     -x  |  executable           -X  |  r_executable
     -o  |  owned                -O  |  r_owned
         |                           |
     -e  |  exists               -f  |  file
     -z  |  empty                -d  |  directory
     -s  |  nonempty             -l  |  symlink
         |                       -p  |  fifo
     -u  |  setuid               -S  |  socket
     -g  |  setgid               -b  |  block
     -k  |  sticky               -c  |  character
         |                       -t  |  tty
     -M  |  modified                 |
     -A  |  accessed             -T  |  ascii
     -C  |  changed              -B  |  binary
  
  Though some tests are fairly meaningless as binary flags (C<modified>,
  C<accessed>, C<changed>), they have been included for completeness.
  
   # find nonempty files
   $rule->file,
        ->nonempty;
  
  =cut
  
  use vars qw( %X_tests );
  %X_tests = (
      -r  =>  readable           =>  -R  =>  r_readable      =>
      -w  =>  writeable          =>  -W  =>  r_writeable     =>
      -w  =>  writable           =>  -W  =>  r_writable      =>
      -x  =>  executable         =>  -X  =>  r_executable    =>
      -o  =>  owned              =>  -O  =>  r_owned         =>
  
      -e  =>  exists             =>  -f  =>  file            =>
      -z  =>  empty              =>  -d  =>  directory       =>
      -s  =>  nonempty           =>  -l  =>  symlink         =>
                                 =>  -p  =>  fifo            =>
      -u  =>  setuid             =>  -S  =>  socket          =>
      -g  =>  setgid             =>  -b  =>  block           =>
      -k  =>  sticky             =>  -c  =>  character       =>
                                 =>  -t  =>  tty             =>
      -M  =>  modified                                       =>
      -A  =>  accessed           =>  -T  =>  ascii           =>
      -C  =>  changed            =>  -B  =>  binary          =>
     );
  
  for my $test (keys %X_tests) {
      my $sub = eval 'sub () {
          my $self = _force_object shift;
          push @{ $self->{rules} }, {
              code => "' . $test . ' \$_",
              rule => "'.$X_tests{$test}.'",
          };
          $self;
      } ';
      no strict 'refs';
      *{ $X_tests{$test} } = $sub;
  }
  
  
  =item stat tests
  
  The following C<stat> based methods are provided: C<dev>, C<ino>,
  C<mode>, C<nlink>, C<uid>, C<gid>, C<rdev>, C<size>, C<atime>,
  C<mtime>, C<ctime>, C<blksize>, and C<blocks>.  See L<perlfunc/stat>
  for details.
  
  Each of these can take a number of targets, which will follow
  L<Number::Compare> semantics.
  
   $rule->size( 7 );         # exactly 7
   $rule->size( ">7Ki" );    # larger than 7 * 1024 * 1024 bytes
   $rule->size( ">=7" )
        ->size( "<=90" );    # between 7 and 90, inclusive
   $rule->size( 7, 9, 42 );  # 7, 9 or 42
  
  =cut
  
  use vars qw( @stat_tests );
  @stat_tests = qw( dev ino mode nlink uid gid rdev
                    size atime mtime ctime blksize blocks );
  {
      my $i = 0;
      for my $test (@stat_tests) {
          my $index = $i++; # to close over
          my $sub = sub {
              my $self = _force_object shift;
  
              my @tests = map { Number::Compare->parse_to_perl($_) } @_;
  
              push @{ $self->{rules} }, {
                  rule => $test,
                  args => \@_,
                  code => 'do { my $val = (stat $_)['.$index.'] || 0;'.
                    join ('||', map { "(\$val $_)" } @tests ).' }',
              };
              $self;
          };
          no strict 'refs';
          *$test = $sub;
      }
  }
  
  =item C<any( @rules )>
  
  =item C<or( @rules )>
  
  Allows shortcircuiting boolean evaluation as an alternative to the
  default and-like nature of combined rules.  C<any> and C<or> are
  interchangeable.
  
   # find avis, movs, things over 200M and empty files
   $rule->any( File::Find::Rule->name( '*.avi', '*.mov' ),
               File::Find::Rule->size( '>200M' ),
               File::Find::Rule->file->empty,
             );
  
  =cut
  
  sub any {
      my $self = _force_object shift;
      # compile all the subrules to code fragments
      push @{ $self->{rules} }, {
          rule => "any",
          code => '(' . join( ' || ', map '( ' . $_->_compile . ' )', @_ ). ')',
          args => \@_,
      };
      
      # merge all the subs hashes of the kids into ourself
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *or = \&any;
  
  =item C<none( @rules )>
  
  =item C<not( @rules )>
  
  Negates a rule.  (The inverse of C<any>.)  C<none> and C<not> are
  interchangeable.
  
    # files that aren't 8.3 safe
    $rule->file
         ->not( $rule->new->name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );
  
  =cut
  
  sub not {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'not',
          args => \@_,
          code => '(' . join ( ' && ', map { "!(". $_->_compile . ")" } @_ ) . ")",
      };
      
      # merge all the subs hashes into us
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *none = \&not;
  
  =item C<prune>
  
  Traverse no further.  This rule always matches.
  
  =cut
  
  sub prune () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} },
        {
         rule => 'prune',
         code => '$File::Find::prune = 1'
        };
      $self;
  }
  
  =item C<discard>
  
  Don't keep this file.  This rule always matches.
  
  =cut
  
  sub discard () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'discard',
          code => '$discarded = 1',
      };
      $self;
  }
  
  =item C<exec( \&subroutine( $shortname, $path, $fullname ) )>
  
  Allows user-defined rules.  Your subroutine will be invoked with C<$_>
  set to the current short name, and with parameters of the name, the
  path you're in, and the full relative filename.
  
  Return a true value if your rule matched.
  
   # get things with long names
   $rules->exec( sub { length > 20 } );
  
  =cut
  
  sub exec {
      my $self = _force_object shift;
      my $code = shift;
  
      push @{ $self->{rules} }, {
          rule => 'exec',
          code => $code,
      };
      $self;
  }
  
  =item C<grep( @specifiers )>
  
  Opens a file and tests it each line at a time.
  
  For each line it evaluates each of the specifiers, stopping at the
  first successful match.  A specifier may be a regular expression or a
  subroutine.  The subroutine will be invoked with the same parameters
  as an ->exec subroutine.
  
  It is possible to provide a set of negative specifiers by enclosing
  them in anonymous arrays.  Should a negative specifier match the
  iteration is aborted and the clause is failed.  For example:
  
   $rule->grep( qr/^#!.*\bperl/, [ sub { 1 } ] );
  
  Is a passing clause if the first line of a file looks like a perl
  shebang line.
  
  =cut
  
  sub grep {
      my $self = _force_object shift;
      my @pattern = map {
          ref $_
            ? ref $_ eq 'ARRAY'
              ? map { [ ( ref $_ ? $_ : qr/$_/ ) => 0 ] } @$_
              : [ $_ => 1 ]
            : [ qr/$_/ => 1 ]
        } @_;
  
      $self->exec( sub {
          local *FILE;
          open FILE, $_ or return;
          local ($_, $.);
          while (<FILE>) {
              for my $p (@pattern) {
                  my ($rule, $ret) = @$p;
                  return $ret
                    if ref $rule eq 'Regexp'
                      ? /$rule/
                        : $rule->(@_);
              }
          }
          return;
      } );
  }
  
  =item C<maxdepth( $level )>
  
  Descend at most C<$level> (a non-negative integer) levels of directories
  below the starting point.
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =item C<mindepth( $level )>
  
  Do not apply any tests at levels less than C<$level> (a non-negative
  integer).
  
  =item C<extras( \%extras )>
  
  Specifies extra values to pass through to C<File::File::find> as part
  of the options hash.
  
  For example this allows you to specify following of symlinks like so:
  
   my $rule = File::Find::Rule->extras({ follow => 1 });
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =cut
  
  for my $setter (qw( maxdepth mindepth extras )) {
      my $sub = sub {
          my $self = _force_object shift;
          $self->{$setter} = shift;
          $self;
      };
      no strict 'refs';
      *$setter = $sub;
  }
  
  
  =item C<relative>
  
  Trim the leading portion of any path found
  
  =cut
  
  sub relative () {
      my $self = _force_object shift;
      $self->{relative} = 1;
      $self;
  }
  
  =item C<not_*>
  
  Negated version of the rule.  An effective shortand related to ! in
  the procedural interface.
  
   $foo->not_name('*.pl');
  
   $foo->not( $foo->new->name('*.pl' ) );
  
  =cut
  
  sub DESTROY {}
  sub AUTOLOAD {
      our $AUTOLOAD;
      $AUTOLOAD =~ /::not_([^:]*)$/
        or croak "Can't locate method $AUTOLOAD";
      my $method = $1;
  
      my $sub = sub {
          my $self = _force_object shift;
          $self->not( $self->new->$method(@_) );
      };
      {
          no strict 'refs';
          *$AUTOLOAD = $sub;
      }
      &$sub;
  }
  
  =back
  
  =head2 Query Methods
  
  =over
  
  =item C<in( @directories )>
  
  Evaluates the rule, returns a list of paths to matching files and
  directories.
  
  =cut
  
  sub in {
      my $self = _force_object shift;
  
      my @found;
      my $fragment = $self->_compile;
      my %subs = %{ $self->{subs} };
  
      warn "relative mode handed multiple paths - that's a bit silly\n"
        if $self->{relative} && @_ > 1;
  
      my $topdir;
      my $code = 'sub {
          (my $path = $File::Find::name)  =~ s#^(?:\./+)+##;
          my @args = ($_, $File::Find::dir, $path);
          my $maxdepth = $self->{maxdepth};
          my $mindepth = $self->{mindepth};
          my $relative = $self->{relative};
  
          # figure out the relative path and depth
          my $relpath = $File::Find::name;
          $relpath =~ s{^\Q$topdir\E/?}{};
          my $depth = scalar File::Spec->splitdir($relpath);
          #print "name: \'$File::Find::name\' ";
          #print "relpath: \'$relpath\' depth: $depth relative: $relative\n";
  
          defined $maxdepth && $depth >= $maxdepth
             and $File::Find::prune = 1;
  
          defined $mindepth && $depth < $mindepth
             and return;
  
          #print "Testing \'$_\'\n";
  
          my $discarded;
          return unless ' . $fragment . ';
          return if $discarded;
          if ($relative) {
              push @found, $relpath if $relpath ne "";
          }
          else {
              push @found, $path;
          }
      }';
  
      #use Data::Dumper;
      #print Dumper \%subs;
      #warn "Compiled sub: '$code'\n";
  
      my $sub = eval "$code" or die "compile error '$code' $@";
      for my $path (@_) {
          # $topdir is used for relative and maxdepth
          $topdir = $path;
          # slice off the trailing slash if there is one (the
          # maxdepth/mindepth code is fussy)
          $topdir =~ s{/?$}{}
            unless $topdir eq '/';
          $self->_call_find( { %{ $self->{extras} }, wanted => $sub }, $path );
      }
  
      return @found;
  }
  
  sub _call_find {
      my $self = shift;
      File::Find::find( @_ );
  }
  
  sub _compile {
      my $self = shift;
  
      return '1' unless @{ $self->{rules} };
      my $code = join " && ", map {
          if (ref $_->{code}) {
              my $key = "$_->{code}";
              $self->{subs}{$key} = $_->{code};
              "\$subs{'$key'}->(\@args) # $_->{rule}\n";
          }
          else {
              "( $_->{code} ) # $_->{rule}\n";
          }
      } @{ $self->{rules} };
  
      #warn $code;
      return $code;
  }
  
  =item C<start( @directories )>
  
  Starts a find across the specified directories.  Matching items may
  then be queried using L</match>.  This allows you to use a rule as an
  iterator.
  
   my $rule = File::Find::Rule->file->name("*.jpeg")->start( "/web" );
   while ( defined ( my $image = $rule->match ) ) {
       ...
   }
  
  =cut
  
  sub start {
      my $self = _force_object shift;
  
      $self->{iterator} = [ $self->in( @_ ) ];
      $self;
  }
  
  =item C<match>
  
  Returns the next file which matches, false if there are no more.
  
  =cut
  
  sub match {
      my $self = _force_object shift;
  
      return shift @{ $self->{iterator} };
  }
  
  1;
  
  __END__
  
  =back
  
  =head2 Extensions
  
  Extension modules are available from CPAN in the File::Find::Rule
  namespace.  In order to use these extensions either use them directly:
  
   use File::Find::Rule::ImageSize;
   use File::Find::Rule::MMagic;
  
   # now your rules can use the clauses supplied by the ImageSize and
   # MMagic extension
  
  or, specify that File::Find::Rule should load them for you:
  
   use File::Find::Rule qw( :ImageSize :MMagic );
  
  For notes on implementing your own extensions, consult
  L<File::Find::Rule::Extending>
  
  =head2 Further examples
  
  =over
  
  =item Finding perl scripts
  
   my $finder = File::Find::Rule->or
    (
     File::Find::Rule->name( '*.pl' ),
     File::Find::Rule->exec(
                            sub {
                                if (open my $fh, $_) {
                                    my $shebang = <$fh>;
                                    close $fh;
                                    return $shebang =~ /^#!.*\bperl/;
                                }
                                return 0;
                            } ),
    );
  
  Based upon this message http://use.perl.org/comments.pl?sid=7052&cid=10842
  
  =item ignore CVS directories
  
   my $rule = File::Find::Rule->new;
   $rule->or($rule->new
                  ->directory
                  ->name('CVS')
                  ->prune
                  ->discard,
             $rule->new);
  
  Note here the use of a null rule.  Null rules match anything they see,
  so the effect is to match (and discard) directories called 'CVS' or to
  match anything.
  
  =back
  
  =head1 TWO FOR THE PRICE OF ONE
  
  File::Find::Rule also gives you a procedural interface.  This is
  documented in L<File::Find::Rule::Procedural>
  
  =head1 EXPORTS
  
  L</find>, L</rule>
  
  =head1 TAINT MODE INTERACTION
  
  As of 0.32 File::Find::Rule doesn't capture the current working directory in
  a taint-unsafe manner.  File::Find itself still does operations that the taint
  system will flag as insecure but you can use the L</extras> feature to ask
  L<File::Find> to internally C<untaint> file paths with a regex like so:
  
      my $rule = File::Find::Rule->extras({ untaint => 1 });
      
  Please consult L<File::Find>'s documentation for C<untaint>,
  C<untaint_pattern>, and C<untaint_skip> for more information.
  
  =head1 BUGS
  
  The code makes use of the C<our> keyword and as such requires perl version
  5.6.0 or newer.
  
  Currently it isn't possible to remove a clause from a rule object.  If
  this becomes a significant issue it will be addressed.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net> with input gained from this
  use.perl discussion: http://use.perl.org/~richardc/journal/6467
  
  Additional proofreading and input provided by Kake, Greg McCarroll,
  and Andy Lester andy@petdance.com.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Find>, L<Text::Glob>, L<Number::Compare>, find(1)
  
  If you want to know about the procedural interface, see
  L<File::Find::Rule::Procedural>, and if you have an idea for a neat
  extension L<File::Find::Rule::Extending>
  
  =cut
  
  Implementation notes:
  
  $self->rules is an array of hashrefs.  it may be a code fragment or a call
  to a subroutine.
  
  Anonymous subroutines are stored in the $self->subs hashref keyed on the
  stringfied version of the coderef.
  
  When one File::Find::Rule object is combined with another, such as in the any
  and not operations, this entire hash is merged.
  
  The _compile method walks the rules element and simply glues the code
  fragments together so they can be compiled into an anyonymous File::Find
  match sub for speed
  
  
  [*] There's probably a win to be made with the current model in making
  stat calls use C<_>.  For
  
    find( file => size => "> 20M" => size => "< 400M" );
  
  up to 3 stats will happen for each candidate.  Adding a priming _
  would be a bit blind if the first operation was C< name => 'foo' >,
  since that can be tested by a single regex.  Simply checking what the
  next type of operation doesn't work since any arbritary exec sub may
  or may not stat.  Potentially worse, they could stat something else
  like so:
  
    # extract from the worlds stupidest make(1)
    find( exec => sub { my $f = $_; $f =~ s/\.c$/.o/ && !-e $f } );
  
  Maybe the best way is to treat C<_> as invalid after calling an exec,
  and doc that C<_> will only be meaningful after stat and -X tests if
  they're wanted in exec blocks.
FILE_FIND_RULE

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;
  
  # See POD at end for documentation
  
  use 5.00503;
  use strict;
  use Carp        ();
  use Config      ();
  use File::Spec  ();
  use File::Which ();
  
  # Globals
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};
  BEGIN {
  	$VERSION = '1.00';
  
  	# Inherit manually
  	require Exporter;
  	@ISA       = qw{ Exporter };
  	@EXPORT    = qw{ home     };
  	@EXPORT_OK = qw{
  		home
  		my_home
  		my_desktop
  		my_documents
  		my_music
  		my_pictures
  		my_videos
  		my_data
  		my_dist_config
  		my_dist_data
  		users_home
  		users_desktop
  		users_documents
  		users_music
  		users_pictures
  		users_videos
  		users_data
  	};
  
  	# %~ doesn't need (and won't take) exporting, as it's a magic
  	# symbol name that's always looked for in package 'main'.
  }
  
  # Inlined Params::Util functions
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  
  # Platform detection
  if ( $IMPLEMENTED_BY ) {
  	# Allow for custom HomeDir classes
  	# Leave it as the existing value
  } elsif ( $^O eq 'MSWin32' ) {
  	# All versions of Windows
  	$IMPLEMENTED_BY = 'File::HomeDir::Windows';
  } elsif ( $^O eq 'darwin') {
  	# 1st: try Mac::SystemDirectory by chansen
  	if ( eval { require Mac::SystemDirectory; 1 } ) {
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Cocoa';
  	} elsif ( eval { require Mac::Files; 1 } ) {
  		# 2nd try Mac::Files: Carbon - unmaintained since 2006 except some 64bit fixes
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Carbon';
  	} else {
  		# 3rd: fallback: pure perl
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin';
  	}
  } elsif ( $^O eq 'MacOS' ) {
  	# Legacy Mac OS
  	$IMPLEMENTED_BY = 'File::HomeDir::MacOS9';
  } elsif ( File::Which::which('xdg-user-dir') ) {
  	# freedesktop unixes
  	$IMPLEMENTED_BY = 'File::HomeDir::FreeDesktop';
  } else {
  	# Default to Unix semantics
  	$IMPLEMENTED_BY = 'File::HomeDir::Unix';
  }
  unless ( _DRIVER($IMPLEMENTED_BY, 'File::HomeDir::Driver') ) {
  	Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY");
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	$IMPLEMENTED_BY->my_home;
  }
  
  sub my_desktop {
  	$IMPLEMENTED_BY->can('my_desktop')
  		? $IMPLEMENTED_BY->my_desktop
  		: Carp::croak("The my_desktop method is not implemented on this platform");
  }
  
  sub my_documents {
  	$IMPLEMENTED_BY->can('my_documents')
  		? $IMPLEMENTED_BY->my_documents
  		: Carp::croak("The my_documents method is not implemented on this platform");
  }
  
  sub my_music {
  	$IMPLEMENTED_BY->can('my_music')
  		? $IMPLEMENTED_BY->my_music
  		: Carp::croak("The my_music method is not implemented on this platform");
  }
  
  sub my_pictures {
  	$IMPLEMENTED_BY->can('my_pictures')
  		? $IMPLEMENTED_BY->my_pictures
  		: Carp::croak("The my_pictures method is not implemented on this platform");
  }
  
  sub my_videos {
  	$IMPLEMENTED_BY->can('my_videos')
  		? $IMPLEMENTED_BY->my_videos
  		: Carp::croak("The my_videos method is not implemented on this platform");
  }
  
  sub my_data {
  	$IMPLEMENTED_BY->can('my_data')
  		? $IMPLEMENTED_BY->my_data
  		: Carp::croak("The my_data method is not implemented on this platform");
  }
  
  
  sub my_dist_data {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_data method requires an argument");
  	my $data   = my_data();
  
          # If datadir is not defined, there's nothing we can do: bail out
          # and return nothing...	
  	return undef unless defined $data;
  
          # On traditional unixes, hide the top-level directory
  	my $var = $data eq home()
  		? File::Spec->catdir( $data, '.perl', 'dist', $dist )
  		: File::Spec->catdir( $data, 'Perl',  'dist', $dist );
  
  	# directory exists: return it
  	return $var if -d $var;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $var );
  	return $var;
  }
  
  sub my_dist_config {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_config method requires an argument");
  
  	# not all platforms support a specific my_config() method
  	my $config = $IMPLEMENTED_BY->can('my_config')
  		? $IMPLEMENTED_BY->my_config
  		: $IMPLEMENTED_BY->my_documents;
  
  	# If neither configdir nor my_documents is defined, there's
  	# nothing we can do: bail out and return nothing...	
  	return undef unless defined $config;
  
  	# On traditional unixes, hide the top-level dir
  	my $etc = $config eq home()
  		? File::Spec->catdir( $config, '.perl', $dist )
  		: File::Spec->catdir( $config, 'Perl',  $dist );
  
  	# directory exists: return it
  	return $etc if -d $etc;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $etc );
  	return $etc;
  }
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	$IMPLEMENTED_BY->can('users_home')
  		? $IMPLEMENTED_BY->users_home( $_[-1] )
  		: Carp::croak("The users_home method is not implemented on this platform");
  }
  
  sub users_desktop {
  	$IMPLEMENTED_BY->can('users_desktop')
  		? $IMPLEMENTED_BY->users_desktop( $_[-1] )
  		: Carp::croak("The users_desktop method is not implemented on this platform");
  }
  
  sub users_documents {
  	$IMPLEMENTED_BY->can('users_documents')
  		? $IMPLEMENTED_BY->users_documents( $_[-1] )
  		: Carp::croak("The users_documents method is not implemented on this platform");
  }
  
  sub users_music {
  	$IMPLEMENTED_BY->can('users_music')
  		? $IMPLEMENTED_BY->users_music( $_[-1] )
  		: Carp::croak("The users_music method is not implemented on this platform");
  }
  
  sub users_pictures {
  	$IMPLEMENTED_BY->can('users_pictures')
  		? $IMPLEMENTED_BY->users_pictures( $_[-1] )
  		: Carp::croak("The users_pictures method is not implemented on this platform");
  }
  
  sub users_videos {
  	$IMPLEMENTED_BY->can('users_videos')
  		? $IMPLEMENTED_BY->users_videos( $_[-1] )
  		: Carp::croak("The users_videos method is not implemented on this platform");
  }
  
  sub users_data {
  	$IMPLEMENTED_BY->can('users_data')
  		? $IMPLEMENTED_BY->users_data( $_[-1] )
  		: Carp::croak("The users_data method is not implemented on this platform");
  }
  
  
  
  
  
  #####################################################################
  # Legacy Methods
  
  # Find the home directory of an arbitrary user
  sub home (;$) {
  	# Allow to be called as a method
  	if ( $_[0] and $_[0] eq 'File::HomeDir' ) {
  		shift();
  	}
  
  	# No params means my home
  	return my_home() unless @_;
  
  	# Check the param
  	my $name = shift;
  	if ( ! defined $name ) {
  		Carp::croak("Can't use undef as a username");
  	}
  	if ( ! length $name ) {
  		Carp::croak("Can't use empty-string (\"\") as a username");
  	}
  
  	# A dot also means my home
  	### Is this meant to mean File::Spec->curdir?
  	if ( $name eq '.' ) {
  		return my_home();
  	}
  
  	# Now hand off to the implementor
  	$IMPLEMENTED_BY->users_home($name);
  }
  
  
  
  
  
  #####################################################################
  # Tie-Based Interface
  
  # Okay, things below this point get scary
  
  CLASS: {
  	# Make the class for the %~ tied hash:
  	package File::HomeDir::TIE;
  
  	# Make the singleton object.
  	# (We don't use the hash for anything, though)
  	### THEN WHY MAKE IT???
  	my $SINGLETON = bless {};
  
  	sub TIEHASH { $SINGLETON }
  
  	sub FETCH {
  		# Catch a bad username
  		unless ( defined $_[1] ) {
  			Carp::croak("Can't use undef as a username");
  		}
  
  		# Get our homedir
  		unless ( length $_[1] ) {
  			return File::HomeDir::my_home();
  		}
  
  		# Get a named user's homedir
  		Carp::carp("The tied %~ hash has been deprecated");
  		return File::HomeDir::home($_[1]);
  	}
  
  	sub STORE    { _bad('STORE')    }
  	sub EXISTS   { _bad('EXISTS')   }
  	sub DELETE   { _bad('DELETE')   }
  	sub CLEAR    { _bad('CLEAR')    }
  	sub FIRSTKEY { _bad('FIRSTKEY') }
  	sub NEXTKEY  { _bad('NEXTKEY')  }
  
  	sub _bad ($) {
  		Carp::croak("You can't $_[0] with the %~ hash")
  	}
  }
  
  # Do the actual tie of the global %~ variable
  tie %~, 'File::HomeDir::TIE';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir - Find your home and other directories on any platform
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Modern Interface (Current User)
    $home     = File::HomeDir->my_home;
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $dist     = File::HomeDir->my_dist_data('File-HomeDir');
    $dist     = File::HomeDir->my_dist_config('File-HomeDir');
    
    # Modern Interface (Other Users)
    $home    = File::HomeDir->users_home('foo');
    $desktop = File::HomeDir->users_desktop('foo');
    $docs    = File::HomeDir->users_documents('foo');
    $music   = File::HomeDir->users_music('foo');
    $pics    = File::HomeDir->users_pictures('foo');
    $video   = File::HomeDir->users_videos('foo');
    $data    = File::HomeDir->users_data('foo');
  
  =head1 DESCRIPTION
  
  B<File::HomeDir> is a module for locating the directories that are "owned"
  by a user (typicaly your user) and to solve the various issues that arise
  trying to find them consistently across a wide variety of platforms.
  
  The end result is a single API that can find your resources on any platform,
  making it relatively trivial to create Perl software that works elegantly
  and correctly no matter where you run it.
  
  This module provides two main interfaces.
  
  The first is a modern L<File::Spec>-style interface with a consistent
  OO API and different implementation modules to support various
  platforms. You are B<strongly> recommended to use this interface.
  
  The second interface is for legacy support of the original 0.07 interface
  that exported a C<home()> function by default and tied the C<%~> variable.
  
  It is generally not recommended that you use this interface, but due to
  back-compatibility reasons they will remain supported until at least 2010.
  
  The C<%~> interface has been deprecated. Documentation was removed in 2009,
  Unit test were removed in 2011, usage will issue warnings from 2012, and the
  interface will be removed entirely in 2015  (in line with the general Perl
  toolchain convention of a 10 year support period for legacy APIs that
  are potentially or actually in common use).
  
  =head2 Platform Neutrality
  
  In the Unix world, many different types of data can be mixed together
  in your home directory (although on some Unix platforms this is no longer
  the case, particularly for "desktop"-oriented platforms).
  
  On some non-Unix platforms, separate directories are allocated for
  different types of data and have been for a long time.
  
  When writing applications on top of B<File::HomeDir>, you should thus
  always try to use the most specific method you can. User documents should
  be saved in C<my_documents>, data that supports an application but isn't
  normally editing by the user directory should go into C<my_data>.
  
  On platforms that do not make any distinction, all these different
  methods will harmlessly degrade to the main home directory, but on
  platforms that care B<File::HomeDir> will always try to Do The Right
  Thing(tm).
  
  =head1 METHODS
  
  Two types of methods are provided. The C<my_method> series of methods for
  finding resources for the current user, and the C<users_method> (read as
  "user's method") series for finding resources for arbitrary users.
  
  This split is necessary, as on most platforms it is B<much> easier to find
  information about the current user compared to other users, and indeed
  on a number you cannot find out information such as C<users_desktop> at
  all, due to security restrictions.
  
  All methods will double check (using a C<-d> test) that a directory
  actually exists before returning it, so you may trust in the values
  that are returned (subject to the usual caveats of race conditions of
  directories being deleted at the moment between a directory being returned
  and you using it).
  
  However, because in some cases platforms may not support the concept of home
  directories at all, any method may return C<undef> (both in scalar and list
  context) to indicate that there is no matching directory on the system.
  
  For example, most untrusted 'nobody'-type users do not have a home
  directory. So any modules that are used in a CGI application that
  at some level of recursion use your code, will result in calls to
  File::HomeDir returning undef, even for a basic home() call.
  
  =head2 my_home
  
  The C<my_home> method takes no arguments and returns the main home/profile
  directory for the current user.
  
  If the distinction is important to you, the term "current" refers to the
  real user, and not the effective user.
  
  This is also the case for all of the other "my" methods.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a home directory, or dies on error.
  
  =head2 my_desktop
  
  The C<my_desktop> method takes no arguments and returns the "desktop"
  directory for the current user.
  
  Due to the diversity and complexity of implementions required to deal with
  implementing the required functionality fully and completely, the
  C<my_desktop> method may or may not be implemented on each platform.
  
  That said, I am extremely interested in code to implement C<my_desktop> on
  Unix, as long as it is capable of dealing (as the Windows implementation
  does) with internationalisation. It should also avoid false positive
  results by making sure it only returns the appropriate directories for the
  appropriate platforms.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a desktop directory, or dies on error.
  
  =head2 my_documents
  
  The C<my_documents> method takes no arguments and returns the directory (for
  the current user) where the user's documents are stored.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a documents directory, or dies on error.
  
  =head2 my_music
  
  The C<my_music> method takes no arguments and returns the directory
  where the current user's music is stored.
  
  No bias is made to any particular music type or music program, rather the
  concept of a directory to hold the user's music is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_pictures
  
  The C<my_pictures> method takes no arguments and returns the directory
  where the current user's pictures are stored.
  
  No bias is made to any particular picture type or picture program, rather the
  concept of a directory to hold the user's pictures is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_videos
  
  The C<my_videos> method takes no arguments and returns the directory
  where the current user's videos are stored.
  
  No bias is made to any particular video type or video program, rather the
  concept of a directory to hold the user's videos is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_data
  
  The C<my_data> method takes no arguments and returns the directory where
  local applications should stored their internal data for the current
  user.
  
  Generally an application would create a subdirectory such as C<.foo>,
  beneath this directory, and store its data there. By creating your
  directory this way, you get an accurate result on the maximum number of
  platforms. But see the documentation about C<my_dist_config()> or
  C<my_dist_data()> below.
  
  For example, on Unix you get C<~/.foo> and on Win32 you get
  C<~/Local Settings/Application Data/.foo>
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a data directory, or dies on error.
  
  
  =head2 my_dist_config
  
    File::HomeDir->my_dist_config( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_config( 'File-HomeDir' );
    File::HomeDir->my_dist_config( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_config> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal configuration.
  
  The base directory will be either C<my_config> if the platform supports
  it, or C<my_documents> otherwise. The subdirectory itself will be 
  C<BASE/Perl/Dist-Name>. If the base directory is the user's homedir,
  C<my_dist_config> will be in C<~/.perl/Dist-Name> (and thus be hidden on
  all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  
  =head2 my_dist_data
  
    File::HomeDir->my_dist_data( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_data( 'File-HomeDir' );
    File::HomeDir->my_dist_data( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_data> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal data.
  
  This directory will be of course a subdirectory of C<my_data>. Platforms
  supporting data-specific directories will use
  C<DATA_DIR/perl/dist/Dist-Name> following the common
  "DATA/vendor/application" pattern. If the C<my_data> directory is the
  user's homedir, C<my_dist_data> will be in C<~/.perl/dist/Dist-Name>
  (and thus be hidden on all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  =head2 users_home
  
    $home = File::HomeDir->users_home('foo');
  
  The C<users_home> method takes a single param and is used to locate the
  parent home/profile directory for an identified user on the system.
  
  While most of the time this identifier would be some form of user name,
  it is permitted to vary per-platform to support user ids or UUIDs as
  applicable for that platform.
  
  Returns the directory path as a string, C<undef> if that user
  does not have a home directory, or dies on error.
  
  =head2 users_documents
  
    $docs = File::HomeDir->users_documents('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a documents directory, or dies on error.
  
  =head2 users_data
  
    $data = File::HomeDir->users_data('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a data directory, or dies on error.
  
  =head1 FUNCTIONS
  
  =head2 home
  
    use File::HomeDir;
    $home = home();
    $home = home('foo');
    $home = File::HomeDir::home();
    $home = File::HomeDir::home('foo');
  
  The C<home> function is exported by default and is provided for
  compatibility with legacy applications. In new applications, you should
  use the newer method-based interface above.
  
  Returns the directory path to a named user's home/profile directory.
  
  If provided no param, returns the directory path to the current user's
  home/profile directory.
  
  =head1 TO DO
  
  =over 4
  
  =item * Add more granularity to Unix, and add support to VMS and other
  esoteric platforms, so we can consider going core.
  
  =item * Add consistent support for users_* methods 
  
  =back
  
  =head1 SUPPORT
  
  This module is stored in an Open Repository at the following address.
  
  L<http://svn.ali.as/cpan/trunk/File-HomeDir>
  
  Write access to the repository is made available automatically to any
  published CPAN author, and to most other volunteers on request.
  
  If you are able to submit your bug report in the form of new (failing)
  unit tests, or can apply your fix directly instead of submitting a patch,
  you are B<strongly> encouraged to do so as the author currently maintains
  over 100 modules and it can take some time to deal with non-Critical bug
  reports or patches.
  
  This will guarantee that your issue will be addressed in the next
  release of the module.
  
  If you cannot provide a direct test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the CPAN
  bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-HomeDir>
  
  For other issues, for commercial enhancement or support, or to have your
  write access enabled for the repository, contact the author at the email
  address above.
  
  =head1 ACKNOWLEDGEMENTS
  
  The biggest acknowledgement goes to Chris Nandor, who wielded his
  legendary Mac-fu and turned my initial fairly ordinary Darwin
  implementation into something that actually worked properly everywhere,
  and then donated a Mac OS X license to allow it to be maintained properly.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  Chris Nandor E<lt>cnandor@cpan.orgE<gt>
  
  Stephen Steneker E<lt>stennie@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  Some parts copyright 2006 Chris Nandor.
  
  Some parts copyright 2006 Stephen Steneker.
  
  Some parts copyright 2009-2011 Jérôme Quelin.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;
  
  use 5.00503;
  use strict;
  use Cwd                 ();
  use Carp                ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	my $home = (getpwuid($<))[7];
  	return $home if $home && -d $home;
  
  	return undef;
  }
  
  sub _my_home {
  	my($class, $path) = @_;
  	my $home = $class->my_home;
  	return undef unless defined $home;
  
  	my $folder = "$home/$path";
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  sub my_desktop {
  	my $class = shift;
  	$class->_my_home('Desktop');
  }
  
  sub my_documents {
  	my $class = shift;
  	$class->_my_home('Documents');
  }
  
  sub my_data {
  	my $class = shift;
  	$class->_my_home('Library/Application Support');
  }
  
  sub my_music {
  	my $class = shift;
  	$class->_my_home('Music');
  }
  
  sub my_pictures {
  	my $class = shift;
  	$class->_my_home('Pictures');
  }
  
  sub my_videos {
  	my $class = shift;
  	$class->_my_home('Movies');
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Mac OS X specific file path for determining
  common user directories in pure perl, by just using C<$ENV{HOME}>
  without Carbon nor Cocoa API calls. In normal usage this module will
  always be used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;
  
  # Basic implementation for the Dawin family of operating systems.
  # This includes (most prominently) Mac OS X.
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  
  	# This is only a child class of the pure Perl darwin
  	# class so that we can do homedir detection of all three
  	# drivers at one via ->isa.
  	@ISA = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kCurrentUserFolderType(),
  	);
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDesktopFolderType(),
  	);
  }
  
  sub my_documents {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDocumentsFolderType(),
  	);
  }
  
  sub my_data {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kApplicationSupportFolderType(),
  	);
  }
  
  sub my_music {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMusicDocumentsFolderType(),
  	);
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kPictureDocumentsFolderType(),
  	);
  }
  
  sub my_videos {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMovieDocumentsFolderType(),
  	);
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::Files;
  	my $folder = Mac::Files::FindFolder(
  		Mac::Files::kUserDomain(),
  		$name,
  	);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  # in theory this can be done, but for now, let's cheat, since the
  # rest is Hard
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Note -- since this module requires Mac::Carbon and Mac::Carbon does
  not work with 64-bit perls, on such systems, File::HomeDir will try
  L<File::HomeDir::Darwin::Cocoa> and then fall back to the (pure Perl)
  L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
  
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =head1 TODO
  
  =over 4
  
  =item * Test with Mac OS (versions 7, 8, 9)
  
  =item * Some better way for users_* ?
  
  =back
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::SystemDirectory'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::SystemDirectory;
  	return Mac::SystemDirectory::HomeDirectory();
  }
  
  # from 10.4
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())
  	}
  	||
  	$class->SUPER::my_desktop;
  }
  
  # from 10.2
  sub my_documents {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())
  	}
  	||
  	$class->SUPER::my_documents;
  }
  
  # from 10.4
  sub my_data {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())
  	}
  	||
  	$class->SUPER::my_data;
  }
  
  # from 10.6
  sub my_music {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())
  	}
  	||
  	$class->SUPER::my_music;
  }
  
  # from 10.6
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())
  	}
  	||
  	$class->SUPER::my_pictures;
  }
  
  # from 10.6
  sub my_videos {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())
  	}
  	||
  	$class->SUPER::my_videos;
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::SystemDirectory;
  	my $folder = Mac::SystemDirectory::FindDirectory($name);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin::Cocoa - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories using Cocoa API through
  L<Mac::SystemDirectory>.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Theoretically, this should return the same paths as both of the other
  Darwin drivers.
  
  Because this module requires L<Mac::SystemDirectory>, if the module
  is not installed, L<File::HomeDir> will fall back to L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;
  
  # Abstract base class that provides no functionality,
  # but confirms the class is a File::HomeDir driver class.
  
  use 5.00503;
  use strict;
  use Carp ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.00';
  }
  
  sub my_home {
  	Carp::croak("$_[0] does not implement compulsory method $_[1]");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Driver - Base class for all File::HomeDir drivers
  
  =head1 DESCRIPTION
  
  This module is the base class for all L<File::HomeDir> drivers, and must
  be inherited from to identify a class as a driver.
  
  It is primarily provided as a convenience for this specific identification
  purpose, as L<File::HomeDir> supports the specification of custom drivers
  and an C<-E<gt>isa> check is used during the loading of the driver.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;
  
  # Specific functionality for unixes running free desktops
  # compatible with (but not using) File-BaseDir-0.03
  
  # See POD at the end of the file for more documentation.
  
  use 5.00503;
  use strict;
  use Carp                ();
  use File::Spec          ();
  use File::Which         ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  # xdg uses $ENV{XDG_CONFIG_HOME}/user-dirs.dirs to know where are the
  # various "my xxx" directories. That is a shell file. The official API
  # is the xdg-user-dir executable. It has no provision for assessing
  # the directories of a user that is different than the one we are
  # running under; the standard substitute user mechanisms are needed to
  # overcome this.
  
  my $xdgprog = File::Which::which('xdg-user-dir');
  
  sub _my {
  	# No quoting because input is hard-coded and only comes from this module
  	my $thingy = qx($xdgprog $_[1]);
  	chomp $thingy;
  	return $thingy;
  }
  
  # Simple stuff
  sub my_desktop   { shift->_my('DESKTOP')   }
  sub my_documents { shift->_my('DOCUMENTS') }
  sub my_music     { shift->_my('MUSIC')     }
  sub my_pictures  { shift->_my('PICTURES')  }
  sub my_videos    { shift->_my('VIDEOS')    }
  
  sub my_data {
  	$ENV{XDG_DATA_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .local share }
  	);
  }
  
  sub my_config {
  	$ENV{XDG_CONFIG_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .config }
  	);
  }
  
  # Custom locations (currently undocumented)
  sub my_download    { shift->_my('DOWNLOAD')    }
  sub my_publicshare { shift->_my('PUBLICSHARE') }
  sub my_templates   { shift->_my('TEMPLATES')   }
  
  sub my_cache {
      $ENV{XDG_CACHE_HOME}
      ||
      File::Spec->catdir(shift->my_home, qw{ .cache });
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_desktop   { Carp::croak('The users_desktop method is not available on an XDG based system.');   }
  sub users_documents { Carp::croak('The users_documents method is not available on an XDG based system.'); }
  sub users_music     { Carp::croak('The users_music method is not available on an XDG based system.');     }
  sub users_pictures  { Carp::croak('The users_pictures method is not available on an XDG based system.');  }
  sub users_videos    { Carp::croak('The users_videos method is not available on an XDG based system.');    }
  sub users_data      { Carp::croak('The users_data method is not available on an XDG based system.');      }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::FreeDesktop - Find your home and other directories on FreeDesktop.org Unix
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;
    $docs    = File::HomeDir->my_documents;
    $music   = File::HomeDir->my_music;
    $pics    = File::HomeDir->my_pictures;
    $videos  = File::HomeDir->my_videos;
    $data    = File::HomeDir->my_data;
  
  =head1 AUTHORS
  
  Jerome Quelin E<lt>jquellin@cpan.org<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Jerome Quelin.
  
  Some parts copyright 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;
  
  # Half-assed implementation for the legacy Mac OS9 operating system.
  # Provided mainly to provide legacy compatibility. May be removed at
  # a later date.
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  # Load early if in a forking environment and we have
  # prefork, or at run-time if not.
  SCOPE: {
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# Try for $ENV{HOME} if we have it
  	if ( defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	### DESPERATION SETS IN
  
  	# We could use the desktop
  	SCOPE: {
  		local $@;
  		eval {
  			my $home = $class->my_desktop;
  			return $home if $home and -d $home;
  		};
  	}
  
  	# Desperation on any platform
  	SCOPE: {
  		# On some platforms getpwuid dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	Carp::croak("Could not locate current user's home directory");
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# Find the desktop via Mac::Files
  	local $SIG{'__DIE__'} = '';
  	require Mac::Files;
  	my $home = Mac::Files::FindFolder(
  		Mac::Files::kOnSystemDisk(),
  		Mac::Files::kDesktopFolderType(),
  		);
  	return $home if $home and -d $home;
  
  	Carp::croak("Could not locate current user's desktop");
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	SCOPE: {
  		# On some platforms getpwnam dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwnam($name))[7];
  		return $home if defined $home and -d $home;
  	}
  
  	Carp::croak("Failed to find home directory for user '$name'");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::MacOS9 - Find your home and other directories on legacy Macs
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;
    $desktop = File::HomeDir->my_desktop;
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories on legacy Mac hosts. In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module is no longer actively maintained, and is included only for
  extreme back-compatibility.
  
  Only the C<my_home> and C<my_desktop> methods are supported.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::Temp            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA %DIR $ENABLED};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  	%DIR     = ();
  	$ENABLED = 0;
  }
  
  # Special magic use in test scripts
  sub import {
  	my $class = shift;
  	die "Attempted to initialise File::HomeDir::Test trice" if %DIR;
  
  	# Fill the test directories
  	my $BASE  = File::Temp::tempdir( CLEANUP => 1 );
  	%DIR = map { $_ => File::Spec->catdir( $BASE, $_ ) } qw{
  		my_home
  		my_desktop
  		my_documents
  		my_data
  		my_music
  		my_pictures
  		my_videos
  	};
  
  	# Hijack HOME to the home directory
  	$ENV{HOME} = $DIR{my_home};
  
  	# Make File::HomeDir load us instead of the native driver
  	$File::HomeDir::IMPLEMENTED_BY = # Prevent a warning
  	$File::HomeDir::IMPLEMENTED_BY = 'File::HomeDir::Test';
  
  	# Ready to go
  	$ENABLED = 1;
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	mkdir($DIR{my_home}, 0755) unless -d $DIR{my_home};
  	return $DIR{my_home};
  }
  
  sub my_desktop {
  	mkdir($DIR{my_desktop}, 0755) unless -d $DIR{my_desktop};
  	return $DIR{my_desktop};
  }
  
  sub my_documents {
  	mkdir($DIR{my_documents}, 0755) unless -f $DIR{my_documents};
  	return $DIR{my_documents};
  }
  
  sub my_data {
  	mkdir($DIR{my_data}, 0755) unless -d $DIR{my_data};
  	return $DIR{my_data};
  }
  
  sub my_music {
  	mkdir($DIR{my_music}, 0755) unless -d $DIR{my_music};
  	return $DIR{my_music};
  }
  
  sub my_pictures {
  	mkdir($DIR{my_pictures}, 0755) unless -d $DIR{my_pictures};
  	return $DIR{my_pictures};
  }
  
  sub my_videos {
  	mkdir($DIR{my_videos}, 0755) unless -d $DIR{my_videos};
  	return $DIR{my_videos};
  }
  
  sub users_home {
  	return undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Test - Prevent the accidental creation of user-owned files during testing
  
  =head1 SYNOPSIS
  
    use Test::More test => 1;
    use File::HomeDir::Test;
    use File::HomeDir;
  
  =head1 DESCRIPTION
  
  B<File::HomeDir::Test> is a L<File::HomeDir> driver intended for use in the test scripts
  of modules or applications that write files into user-owned directories.
  
  It is designed to prevent the pollution of user directories with files that are not part
  of the application install itself, but were created during testing. These files can leak
  state information from the tests into the run-time usage of an application, and on Unix
  systems also prevents tests (which may be executed as root via sudo) from writing files
  which cannot later be modified or removed by the regular user.
  
  =head1 SUPPORT
  
  See the support section of the main L<File::HomeDir> documentation.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  	my $home  = $class->_my_home(@_);
  
  	# On Unix in general, a non-existant home means "no home"
  	# For example, "nobody"-like users might use /nonexistant
  	if ( defined $home and ! -d $home ) {
  		$home = undef;
  	}
  
  	return $home;
  }
  
  sub _my_home {
  	my $class = shift;
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# This is from the original code, but I'm guessing
  	# it means "login directory" and exists on some Unixes.
  	if ( exists $ENV{LOGDIR} and $ENV{LOGDIR} ) {
  		return $ENV{LOGDIR};
  	}
  
  	### More-desperate methods
  
  	# Light desperation on any (Unixish) platform
  	SCOPE: {
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  # On unix by default, everything is under the same folder
  sub my_desktop {
  	shift->my_home;
  }
  
  sub my_documents {
  	shift->my_home;
  }
  
  sub my_data {
  	shift->my_home;
  }
  
  sub my_music {
  	shift->my_home;
  }
  
  sub my_pictures {
  	shift->my_home;
  }
  
  sub my_videos {
  	shift->my_home;
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	# IF and only if we have getpwuid support, and the
  	# name of the user is our own, shortcut to my_home.
  	# This is needed to handle HOME environment settings.
  	if ( $name eq getpwuid($<) ) {
  		return $class->my_home;
  	}
  
  	SCOPE: {
  		my $home = (getpwnam($name))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  sub users_desktop {
  	shift->users_home(@_);
  }
  
  sub users_documents {
  	shift->users_home(@_);
  }
  
  sub users_data {
  	shift->users_home(@_);
  }
  
  sub users_music {
  	shift->users_home(@_);
  }
  
  sub users_pictures {
  	shift->users_home(@_);
  }
  
  sub users_videos {
  	shift->users_home(@_);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Unix - Find your home and other directories on legacy Unix
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;     # All of these will... 
    $docs    = File::HomeDir->my_documents;   # ...default to home...
    $music   = File::HomeDir->my_music;       # ...directory
    $pics    = File::HomeDir->my_pictures;    #
    $videos  = File::HomeDir->my_videos;      #
    $data    = File::HomeDir->my_data;        # 
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  sub CREATE () { 1 }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# Do we have a user profile?
  	if ( exists $ENV{USERPROFILE} and $ENV{USERPROFILE} ) {
  		return $ENV{USERPROFILE};
  	}
  
  	# Some Windows use something like $ENV{HOME}
  	if ( exists $ENV{HOMEDRIVE} and exists $ENV{HOMEPATH} and $ENV{HOMEDRIVE} and $ENV{HOMEPATH} ) {
  		return File::Spec->catpath(
  			$ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '',
  		);
  	}
  
  	return undef;
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# The most correct way to find the desktop
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_DESKTOP(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	# MSWindows sets WINDIR, MS WinNT sets USERPROFILE.
  	foreach my $e ( 'USERPROFILE', 'WINDIR' ) {
  		next unless $ENV{$e};
  		my $desktop = File::Spec->catdir($ENV{$e}, 'Desktop');
  		return $desktop if $desktop and $class->_d($desktop);
  	}
  
  	# As a last resort, try some hard-wired values
  	foreach my $fixed (
  		# The reason there are both types of slash here is because
  		# this set of paths has been kept from thethe original version
  		# of File::HomeDir::Win32 (before it was rewritten).
  		# I can only assume this is Cygwin-related stuff.
  		"C:\\windows\\desktop",
  		"C:\\win95\\desktop",
  		"C:/win95/desktop",
  		"C:/windows/desktop",
  	) {
  		return $fixed if $class->_d($fixed);
  	}
  
  	return undef;
  }
  
  sub my_documents {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_PERSONAL(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_data {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_music {
  	my $class = shift;
  
  	# The most correct way to find my music
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	# The most correct way to find my pictures
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_videos {
  	my $class = shift;
  
  	# The most correct way to find my videos
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  # Special case version of -d
  sub _d {
  	my $self = shift;
  	my $path = shift;
  
  	# Window can legally return a UNC path from GetFolderPath.
  	# Not only is the meaning of -d complicated in this situation,
  	# but even on a local network calling -d "\\\\cifs\\path" can
  	# take several seconds. UNC can also do even weirder things,
  	# like launching processes and such.
  	# To avoid various crazy bugs caused by this, we do NOT attempt
  	# to validate UNC paths at all so that the code that is calling
  	# us has an opportunity to take special actions without our 
  	# blundering getting in the way.
  	if ( $path =~ /\\\\/ ) {
  		return 1;
  	}
  
  	# Otherwise do a stat as normal
  	return -d $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Windows - Find your home and other directories on Windows
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user (eg. using Windows XP Professional)
    $home    = File::HomeDir->my_home;        # C:\Documents and Settings\mylogin
    $desktop = File::HomeDir->my_desktop;     # C:\Documents and Settings\mylogin\Desktop
    $docs    = File::HomeDir->my_documents;   # C:\Documents and Settings\mylogin\My Documents
    $music   = File::HomeDir->my_music;       # C:\Documents and Settings\mylogin\My Documents\My Music
    $pics    = File::HomeDir->my_pictures;    # C:\Documents and Settings\mylogin\My Documents\My Pictures
    $videos  = File::HomeDir->my_videos;      # C:\Documents and Settings\mylogin\My Documents\My Video
    $data    = File::HomeDir->my_data;        # C:\Documents and Settings\mylogin\Local Settings\Application Data
  
  =head1 DESCRIPTION
  
  This module provides Windows-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Internally this module will use L<Win32>::GetFolderPath to fetch the location
  of your directories. As a result of this, in certain unusual situations
  (usually found inside large organisations) the methods may return UNC paths
  such as C<\\cifs.local\home$>.
  
  If your application runs on Windows and you want to have it work comprehensively
  everywhere, you may need to implement your own handling for these paths as they
  can cause strange behaviour.
  
  For example, stat calls to UNC paths may work but block for several seconds, but
  opendir() may not be able to read any files (creating the appearance of an existing
  but empty directory).
  
  To avoid complicating the problem any further, in the rare situation that a UNC path
  is returned by C<GetFolderPath> the usual -d validation checks will B<not> be done.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use 5.004;
  use strict;
  use Exporter   ();
  use File::Spec ();
  
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK};
  BEGIN {
  	$VERSION   = '1.09';
  	@ISA       = 'Exporter';
  	@EXPORT    = 'which';
  	@EXPORT_OK = 'where';
  }
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
  	# WinNT. PATHEXT might be set on Cygwin, but not used.
  	if ( $ENV{PATHEXT} ) {
  		push @PATHEXT, split ';', $ENV{PATHEXT};
  	} else {
  		# Win9X or other: doesn't have PATHEXT, so needs hardcoded.
  		push @PATHEXT, qw{.com .exe .bat};
  	}
  } elsif ( IS_VMS ) {
  	push @PATHEXT, qw{.exe .com};
  }
  
  sub which {
  	my ($exec) = @_;
  
  	return undef unless $exec;
  
  	my $all = wantarray;
  	my @results = ();
  
  	# check for aliases first
  	if ( IS_VMS ) {
  		my $symbol = `SHOW SYMBOL $exec`;
  		chomp($symbol);
  		unless ( $? ) {
  			return $symbol unless $all;
  			push @results, $symbol;
  		}
  	}
  	if ( IS_MAC ) {
  		my @aliases = split /\,/, $ENV{Aliases};
  		foreach my $alias ( @aliases ) {
  			# This has not been tested!!
  			# PPT which says MPW-Perl cannot resolve `Alias $alias`,
  			# let's just hope it's fixed
  			if ( lc($alias) eq lc($exec) ) {
  				chomp(my $file = `Alias $alias`);
  				last unless $file;  # if it failed, just go on the normal way
  				return $file unless $all;
  				push @results, $file;
  				# we can stop this loop as if it finds more aliases matching,
  				# it'll just be the same result anyway
  				last;
  			}
  		}
  	}
  
  	my @path = File::Spec->path;
  	if ( IS_DOS or IS_VMS or IS_MAC ) {
  		unshift @path, File::Spec->curdir;
  	}
  
  	foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
  		for my $ext ( @PATHEXT ) {
  			my $file = $base.$ext;
  
  			# We don't want dirs (as they are -x)
  			next if -d $file;
  
  			if (
  				# Executable, normal case
  				-x _
  				or (
  					# MacOS doesn't mark as executable so we check -e
  					IS_MAC
  					||
  					(
  						IS_DOS
  						and
  						grep {
  							$file =~ /$_\z/i
  						} @PATHEXT[1..$#PATHEXT]
  					)
  					# DOSish systems don't pass -x on
  					# non-exe/bat/com files. so we check -e.
  					# However, we don't want to pass -e on files
  					# that aren't in PATHEXT, like README.
  					and -e _
  				)
  			) {
  				return $file unless $all;
  				push @results, $file;
  			}
  		}
  	}
  
  	if ( $all ) {
  		return @results;
  	} else {
  		return undef;
  	}
  }
  
  sub where {
  	# force wantarray
  	my @res = which($_[0]);
  	return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::Which - Portable implementation of the `which' utility
  
  =head1 SYNOPSIS
  
    use File::Which;                  # exports which()
    use File::Which qw(which where);  # exports which() and where()
    
    my $exe_path = which('perldoc');
    
    my @paths = where('perl');
    - Or -
    my @paths = which('perl'); # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  C<File::Which> was created to be able to get the paths to executable programs
  on systems under which the `which' program wasn't implemented in the shell.
  
  C<File::Which> searches the directories of the user's C<PATH> (as returned by
  C<File::Spec-E<gt>path()>), looking for executable files having the name
  specified as a parameter to C<which()>. Under Win32 systems, which do not have a
  notion of directly executable files, but uses special extensions such as C<.exe>
  and C<.bat> to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head1 Steps Used on Win32, DOS, OS2 and VMS
  
  =head2 Windows NT
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head2 Windows 9x and other ancient Win/DOS/OS2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  =head2 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  =head1 Functions
  
  =head2 which($short_exe_name)
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where($short_exe_name)
  
  Not exported by default.
  
  Same as C<which($short_exe_name)> in array context. Same as the
  C<`where'> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 BUGS AND CAVEATS
  
  Not tested on VMS or MacOS, although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  File::Spec adds the current directory to the front of PATH if on
  Win32, VMS or MacOS. I have no knowledge of those so don't know if the
  current directory is searced first or not. Could someone please tell
  me?
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-Which>
  
  For other issues, contact the maintainer.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Per Einar Ellefsen E<lt>pereinar@cpan.orgE<gt>
  
  Originated in F<modperl-2.0/lib/Apache/Build.pm>. Changed for use in DocSet
  (for the mod_perl site) and Win32-awareness by me, with slight modifications
  by Stas Bekman, then extracted to create C<File::Which>.
  
  Version 0.04 had some significant platform-related changes, taken from
  the Perl Power Tools C<`which'> implementation by Abigail with
  enhancements from Peter Prymmer. See
  L<http://www.perl.com/language/ppt/src/which/index.html> for more
  information.
  
  =head1 COPYRIGHT
  
  Copyright 2002 Per Einar Ellefsen.
  
  Some parts copyright 2009 Adam Kennedy.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<which(1)>, Perl Power Tools:
  L<http://www.perl.com/language/ppt/index.html>.
  
  =cut
FILE_WHICH

$fatpacked{"FindBin/libs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FINDBIN_LIBS';
  ########################################################################
  # libs_curr_pm
  #
  # use $FindBin::Bin to search for 'lib' directories and use them.
  #
  # default action is to look for dir's named "lib" and silently use
  # the lib's without exporting anything. print turns on a short 
  # message with the abs_path results, export pushes out a variable
  # (default name is the base value), verbose turns on decision output
  # and print. export takes an optional argument with the name of a
  # variable to export.
  #
  # 
  ########################################################################
  
  ########################################################################
  # housekeeping
  ########################################################################
  
  package FindBin::libs;
  
  use v5.10;
  use strict;
  
  use FindBin;
  
  use File::Basename;
  
  use Carp    qw( croak                   );
  use Symbol  qw( qualify qualify_to_ref  );
  
  use File::Spec::Functions
  qw
  (
      &splitpath
      &splitdir
      &catpath
      &catdir
  );
  
  BEGIN
  {
      # however... there have been complaints of 
      # places where abs_path does not work. 
      #
      # if abs_path fails on the working directory
      # then replace it with rel2abs and live with 
      # possibly slower, redundant directories.
      #
      # the abs_path '//' hack allows for testing 
      # broken abs_path on primitive systems that
      # cannot handle the rooted system being linked
      # back to itself.
  
      use Cwd qw( &abs_path &cwd );
  
      unless( eval {abs_path '//';  abs_path cwd } )
      {
          # abs_path seems to be having problems,
          # fix is to stub it out.
          #
          # undef avoids nastygram.
  
          my $ref = qualify_to_ref 'abs_path', __PACKAGE__;
  
          my $sub = File::Spec::Functions->can( 'rel2abs' );
  
          undef &{ $ref };
  
          *$ref = $sub
      };
  }
  
  ########################################################################
  # package variables 
  ########################################################################
  
  our $VERSION    = '2.10';
  $VERSION = eval $VERSION;
  
  my %defaultz = 
  (
      base    => 'lib',
      use     => undef,
      blib    => undef,   # prefer ./blib at the first level
  
      subdir  => '',      # add this subdir also if found.
      subonly => undef,   # leave out lib's, use only subdir.
      export  => undef,   # push variable into caller's space.
      append  => undef,   # push onto existing array (vs. overwrite)
      verbose => undef,   # boolean: print inputs, results.
      debug   => undef,   # boolean: set internal breakpoints.
  
      print   => 1,       # display the results
  
      p5lib   => undef,   # prefix PERL5LIB with the results
  
      ignore => '/,/usr', # dir's to skip looking for ./lib
  );
  
  # only new directories are used, ignore pre-loads
  # this with unwanted values.
  
  my %found = ();
  
  # saves passing this between import and $handle_args.
  
  my %argz    = ();
  my $verbose = '';
  my $empty   = q{};
  
  ########################################################################
  # subroutines
  ########################################################################
  
  # HAK ALERT: $Bin is an absolute path, there are cases
  # where splitdir does not add the leading '' onto the
  # directory path for it on VMS. Fix is to unshift a leading
  # '' into @dirpath where the leading entry is true.
  
  my $find_libs
  = sub
  {
      my $base    = basename ( shift || $argz{ base } );
  
      my $subdir  = $argz{ subdir } || '';
  
      my $subonly = defined $argz{ subonly };
  
      # for some reason, RH Enterprise V/4 has a 
      # trailing '/'; I havn't seen another copy of 
      # FindBin that does this. fix is quick enough: 
      # strip the trailing '/'.
      #
      # using a regex to extract the value untaints it
      # (not useful for anything much, just helps the
      # poor slobs stuck in taint mode).
      #
      # after that splitpath can grab the directory 
      # portion for future use.
  
      my ( $Bin ) = ( $argz{ Bin } =~ m{^ (.+) }xs );
  
      print STDERR "\nSearching $Bin for '$base'...\n"
      if $verbose;
  
      my( $vol, $dir ) = splitpath $Bin, 1;
  
      my @dirpath = splitdir $dir;
  
      # fix for File::Spec::VMS missing the leading empty
      # string on a split. this can be removed once File::Spec
      # is fixed.
  
      unshift @dirpath, '' if $dirpath[ 0 ];
  
      my @libz    = ();
  
      PATH:
      for( 1 .. @dirpath )
      {
          # note that catpath is extraneous on *NIX; the 
          # volume only means something on DOS- & VMS-based
          # filesystems, and adding an empty basename on 
          # *nix is unnecessary.
          #
          # HAK ALERT: the poor slobs stuck on windog have an
          # abs_path that croaks on missing directories. have
          # to eval the check for subdir's. 
  
          my $abs
          = eval
          {
              abs_path
              catpath $vol, ( catdir @dirpath, $base ), $empty
          }
          || '';
  
          my $sub
          = $subdir
          ? eval { abs_path ( catpath '', $abs, $subdir ) } || ''
          : ''
          ;
  
          my @search = $subonly ? ( $sub ) : ( $abs, $sub );
  
          for my $dir ( @search )
          {
              if( $dir && -d $dir && ! exists $found{ $dir } )
              {
                  $found{ $dir } = ();
  
                  push @libz, $dir;
  
                  last if $argz{ scalar };
              }
          }
  
          pop @dirpath
      }
  
      # caller gets back the existing lib paths 
      # (including volume) walking up the path 
      # from $FindBin::Bin -> root.
      #
      # passing it back as a list isn't all that
      # painful for a few paths.
  
      wantarray ? @libz : \@libz
  };
  
  # break out the messy part into a separate block.
  
  my $handle_args 
  = sub
  {
      # discard the module, rest are arguments.
  
      shift;
  
      # anything after the module are options with arguments
      # assigned via '='.
  
      %argz
      = map
      {
          my $use_undef
          = do
          {
              my %a   = ();
              @a{ qw( export ignore ) } = ();
              \%a
          };
  
          my ( $k, $v ) = split '=', $_, 2;
  
          exists $use_undef->{ $k }
          or $v //= 1;
  
          # "no" inverts the sense of the test.
  
          $k =~ s{^no}{}
          and $v  = ! $v;
  
          ( $k => $v )
      }
      @_;
  
      # stuff "debug=1" into your arguments and perl -d will stop here.
  
      $DB::single = 1 if defined $argz{ debug };
  
      # default if nothing is supplied is to use the result;
      # otherwise, without use supplied either of export or
      # p5lib will turn off use.
  
      if( exists $argz{ use } )
      {
          # nothing further to do
      }
      elsif( defined $argz{ export } || defined $argz{ p5lib } )
      {
          $argz{ use } = undef;
      }
      else
      {
          $argz{ use } = 1;
      }
  
      local $defaultz{ Bin }
      = exists $argz{ realbin }
      ? $FindBin::RealBin
      : $FindBin::Bin
      ;
  
      # now apply the defaults, then sanity check the result.
      # base is a special case since it always has to exist.
      #
      # if $argz{ export } is defined but false then it takes
      # its default from $argz{ base }.
  
      while( my($k,$v) = each %defaultz )
      {
          # //= doesn't work here since undef may be a 
          # legit default.
  
          exists $argz{ $k }
          or
          $argz{ $k } = $v;
      }
  
      exists $argz{ base } && $argz{ base } 
      or croak "Bogus FindBin::libs: missing/false base argument, should be 'base=NAME'";
  
      exists $argz{ export }
      and
      $argz{ export } //= $argz{ base };
  
      $argz{ ignore } =
      [
          grep { $_ } split /\s*,\s*/, $argz{ ignore }
      ];
  
      $verbose = defined $argz{ verbose };
  
      my $base = $argz{ base };
  
      # now locate the libraries.
      #
      # %found contains the abs_path results for each directory to 
      # avoid double-including directories.
      #
      # note: loop short-curcuts for the (usually) list.
  
      %found = ();
  
      for( @{ $argz{ ignore } } )
      {
          if( my $dir = eval { abs_path catdir $_, $base } )
          {
              if( -d $dir )
              {
                  $found{ $dir } = 1;
              }
          }
      }
  };
  
  sub import
  {
      &$handle_args;
  
      my @libz = $find_libs->();
  
      # HAK ALERT: the regex does nothing for security,
      # just dodges -T. putting this down here instead
      # of inside find_libs allows people to use saner
      # untainting plans via find_libs.
  
      @libz   = map { m{ (.+) }xs } @libz;
  
      my $caller = caller;
  
      if( $verbose || defined $argz{ print } )
      {
          local $\ = "\n";
          local $, = "\n\t";
  
          print STDERR "Found */$argz{ base }:", @libz
          if $verbose;
      }
  
      if( $argz{ export } )
      {
          my $ref     = qualify_to_ref $argz{ export }, $caller;
  
          if( $verbose )
          {
              my $dest    = qualify $argz{ export }, $caller;
  
              $argz{ scalar }
              ? print STDERR "\nExporting: \$$dest\n"
              : print STDERR "\nExporting: \@$dest\n"
              ;
          }
  
          if( $argz{ scalar } )
          {
              *$ref = \$libz[0]
          }
          elsif
          (
              $argz{ append } 
              and
              my $ary = *{ $ref }{ ARRAY }
          )
          {
              push @$ary, @libz;
          }
          else
          {
              *$ref = \@libz
          }
      }
  
      if( defined $argz{ p5lib } )
      {
          # stuff the lib's found at the front of $ENV{ PERL5LIB }
  
          ( substr $ENV{ PERL5LIB }, 0, 0 ) = join ':', @libz, ''
          if @libz;
  
          print STDERR "\nUpdated PERL5LIB:\t$ENV{ PERL5LIB }\n"
          if $verbose;
      }
  
      if( $argz{ use } && @libz )
      {
          # this obviously won't work if lib ever depends 
          # on the caller's package.
          #
          # it does avoids issues with -T blowing up on the
          # old eval technique.
  
          require lib;
  
          lib->import( @libz );
      }
  
      0
  }
  
  # keep require happy
  
  1
  
  __END__
  
  =head1 NAME
  
  FindBin::libs - locate and a 'use lib' or export 
  directories based on $FindBin::Bin.
  
  =head1 SYNOPSIS
  
  This version of FindBin::libs is suitable for 
  Perl v5.10+.
  
      # search up $FindBin::Bin looking for ./lib directories
      # and "use lib" them.
  
      use FindBin::libs;
  
      # same as above with explicit defaults.
  
      use FindBin::libs qw( base=lib use=1 noexport noprint );
  
      # print the lib dir's before using them.
  
      use FindBin::libs qw( print );
  
      # find and use lib "altlib" dir's
  
      use FindBin::libs qw( base=altlib );
  
      # move starting point from $FindBin::Bin to '/tmp'
  
      use FindBin::libs qw( Bin=/tmp base=altlib );
  
      # skip "use lib", export "@altlib" instead.
  
      use FindBin::libs qw( base=altlib export );
  
      # find altlib directories, use lib them and export @mylibs
  
      use FindBin::libs qw( base=altlib export=mylibs use );
  
      # "export" defaults to "nouse", these two are identical:
  
      use FindBin::libs qw( export nouse );
      use FindBin::libs qw( export       );
  
      # use and export are not exclusive:
  
      use FindBin::libs qw( use export            ); # do both
      use FindBin::libs qw( nouse noexport print  ); # print only
      use FindBin::libs qw( nouse noexport        ); # do nothting at all
  
      # print a few interesting messages about the 
      # items found.
  
      use FindBinlibs qw( verbose );
  
      # turn on a breakpoint after the args are prcoessed, before
      # any search/export/use lib is handled.
  
      use FindBin::libs qw( debug );
  
      # prefix PERL5LIB with the lib's found.
  
      use FindBin::libs qw( perl5lib );
  
      # find a subdir of the lib's looked for.
      # the first example will use both ../lib and
      # ../lib/perl5; the second ../lib/perl5/frobnicate
      # (if they exist). it can also be used with export
      # and base to locate special configuration dir's.
      #
      # subonly with a base is useful for locating config
      # files. this finds any "./config/mypackage" dir's
      # without including any ./config dir's. the result
      # ends up in @config (see also "export=", above).
  
      use FindBin::libs qw( subdir=perl5 );
  
      use FindBin::libs qw( subdir=perl5/frobnicate );
  
      use FindBin::libs qw( base=config subdir=mypackage subonly export );
  
      # base and subonly are also useful if your 
      # project is stored in multiple git 
      # repositories. 
      #
      # say you need libs under api_foo/lib from api_bar: a
      # base of the git repository directory with subdir of
      # lib and subonly will pull in those lib dirs.
  
      use FindBin::libs qw( base=api_foo subdir=lib subonly );
  
      # no harm in using this multiple times to use
      # or export multple layers of libs.
  
      use FindBin::libs qw( export                                            );
      use FindBin::libs qw( export=found base=lib                             );
      use FindBin::libs qw( export=binz  base=bin            ignore=/foo,/bar );
      use FindBin::libs qw( export=junk  base=frobnicatorium                  );
      use FindBin::libs qw( export       base=foobar                          );
  
  =head1 DESCRIPTION
  
  =head2 General Use
  
  This module will locate directories along the path to $FindBin::Bin
  and "use lib" or export an array of the directories found. The default
  is to locate "lib" directories and "use lib" them without printing
  the list.
  
  Options controll whether the lib's found are exported into the caller's
  space, exported to PERL5LIB, or printed. Exporting or setting perl5lib
  will turn off the default of "use lib" so that:
  
      use FindBin::libs qw( export );
      use FindBin::libs qw( p5lib  );
  
  are equivalent to 
  
      use FindBin::libs qw( export nouse );
      use FindBin::libs qw( p5lib  nouse );
  
  Combining export with use or p5lib may be useful, p5lib and
  use are probably not all that useful together.
  
  =head3 Alternate directory name: 'base'
  
  The basename searched for can be changed via 'base=name' so
  that
  
      use FindBin::libs qw( base=altlib );
  
  will search for directories named "altlib" and "use lib" them.
  
  =head3 Exporting a variable: "export", "scalar", "append"
  
  =over 4
  
  =item "export"
  
  This installs the results of locating directories into the caller's 
  space. Without any argument, export pushes out a variable named after 
  the located [sub]dir; an argument can be supplied to give the variable 
  name. Without the "scalar" option, the exported variable will be an 
  array in increasing order of "distance" (i.e., "up" the file tree); 
  with the "scalar" option only the first (i.e., "nearest") path is 
  exported.
  
  If "export" is given then "nouse" is assumed; using both leaves the 
  variable exported and its contents handed to "use lib".
  
  For example:
  
      use FindBin::libs qw( export );
  
  will find "lib" directories and export @lib with the
  list of directories found.
  
      use FindBin::libs qw( export=mylibs );
  
  will find "lib" directories and export them as "@mylibs" to
  the caller.
  
  If "export" only is given then the "use" option defaults to 
  false. So:
  
      use FindBin::libs qw( export );
      use FindBin::libs qw( export nouse );
  
  are equivalent. This is mainly for use when looking for data
  directories with the "base=" argument.
  
  If base is used with export the default array name is the base
  directory value:
  
      use FindBin::libs qw( export base=meta );
  
  exports @meta while
  
      use FindBin::libs qw( export=metadirs base=meta );
  
  exports @metadirs as a list of paths ending in "/meta".
  
  The use and export switches are not exclusive:
  
      use FindBin::libs qw( use export=mylibs );
  
  will locate "lib" directories, use lib them, and export 
  @mylibs into the caller's package. 
  
  =item "scalar"
  
  Only searches for the first directory, which is exported (or
  overwritten) as a scalar rather than array. For example, if
  a project directory has ./bin and ./etc dir's then #! code in
  bin with
  
      use FindBin::libs qw( export scalar base=etc );
  
  will have an $etc variable with the absolute path to ./bin/../etc.
  For configuration varibles this is usually what you want and allows
  for "$etc/Foo.conf" rather than "$etc[0]/Foo.conf".
  
  =item "append"
  
  Sometimes it's simpler to accumulate multiple searches into a 
  single array. Say for ./etc dir's in collection of standard
  locations.
  
  In that case:
  
      use FindBin::libs qw( export=etc base=foo subdir=etc );
      use FindBin::libs qw( export=etc base=bar subdir=etc append );
  
  produces something like
  
      (
          /path/to/foo/etc
          /path/to/bar/etc
      )
  
  without append @etc will have only ./bar/etc since the array would
  be overwritten with each call to FB::l::import.
  
  =back
  
  =head3 Subdirectories
  
  The "subdir" and "subonly" settings will add or 
  exclusively use subdir's. This is useful if some
  of your lib's are in ../lib/perl5 along with 
  ../lib or all of the lib's are in ../lib/perl5.
  
  These could be handled with:
  
      use FindBin::libs;
      use FindBin::libs qw( subdir=perl5 subonly );
  
  which uses the "lib" dir's along with any lib/perl5 dirs.
  
  This can also be handy for locating subdir's used
  for configuring packages:
  
      use FindBin::libs qw( export base=config subonly=mypackage );
  
  Will leave @config containing any mypackage dir's found up
  the tree, nearest to closest.
  
  The array format is convienent for locating configuration files
  shared between projects in separate, sibling directories. For
  example given:
  
      ./proj/Foo/etc
      ./proj/etc
  
  with
  
      use FindBin::libs qw( export subdir=etc subonly )
  
  will export @etc with qw( ../proj/Foo/etc ../proj/etc ) in lexical
  order by distance from the #! code. At that point
  
      use List::Util qw( first );
  
      my $path = first { -e "$_/Global.config" } @etc;
  
  will locate the nearest "Global.confg" file. Note that this is 
  not the same as using "scalar" since that will export 
  $etc with only ./Foo/etc. 
  
  =head3 Setting PERL5LIB: p5lib
  
  For cases where the environment is more useful for setting
  up library paths "p5lib" can be used to preload this variable.
  This is mainly useful for automatically including directories
  outside of the parent tree of $FindBin::bin.
  
  For example, using:
  
      $ export PERL5LIB="/usr/local/foo:/usr/local/bar";
  
      $ myprog;
  
  or simply
  
      $ PERL5LIB="/usr/local/lib/foo:/usr/lib/bar" myprog;
  
  (depending on your shell) with #! code including:
  
      use FindBin::libs qw( p5lib );
  
  will not "use lib" any dir's found but will update PERL5LIB
  to something like:
  
      /home/me/sandbox/branches/lib:/usr/local/lib/foo:/usr/lib/bar
  
  This can make controlling the paths used simpler and avoid
  the use of symlinks for some testing (see examples below).
  
  =head2 Skipping directories
  
  By default, lib directories under / and /usr are
  sliently ignored. This normally means that /lib, /usr/lib, and
  '/usr/local/lib' are skipped. The "ignore" parameter provides
  a comma-separated list of directories to ignore:
  
      use FindBin::libs qw( ignore=/skip/this,/and/this/also );
  
  will replace the standard list and thus skip "/skip/this/lib"
  and "/and/this/also/lib". It will search "/lib" and "/usr/lib"
  since the argument ignore list replaces the original one.
  
  =head2 Homegrown Library Management 
  
  An all-too-common occurrance managing perly projects is
  being unable to install new modules becuse "it might 
  break things", and being unable to test them because
  you can't install them. The usual outcome of this is a 
  collection of hard-coded
  
      use lib qw( /usr/local/projectX ... )
  
  code at the top of each #! file that has to be updated by
  hand for each new project.
  
  To get away from this you'll often see relative paths
  for the lib's, which require running the code from one
  specific place. All this does is push the hard-coding
  into cron, shell wrappers, and begin blocks.
  
  With FindBin::libs you need suffer no more.
  
  Automatically finding libraries in and above the executable
  means you can put your modules into cvs/svn and check them
  out with the project, have multiple copies shared by developers,
  or easily move a module up the directory tree in a testbed
  to regression test the module with existing code. All without
  having to modify a single line of code.
  
  =over 4
  
  =item Code-speicfic modules.
  
  Say your sandbox is in ./sandbox and you are currently
  working in ./sandbox/projects/package/bin on a perl
  executable. You may have some number of modules that
  are specific -- or customized -- for this pacakge, 
  share some modules within the project, and may want 
  to use company-wide modules that are managed out of 
  ./sandbox in development. All of this lives under a 
  ./qc tree on the test boxes and under ./production 
  on production servers.
  
  For simplicity, say that your sandbox lives in your
  home direcotry, /home/jowbloe, as a directory or a
  symlink.
  
  If your #! uses FindBin::libs in it then it will
  effectively
  
      use lib
      qw(
          /home/jowbloe/sandbox/lib
          /home/jowbloe/sandbox/project/lib
          /home/jowbloe/sandbox/project/package/lib
      );
  
  if you run /home/jowbloe/sandbox/project/package/bin/foobar.
  This will happen the same way if you use a relative or
  absolute path, perl -d the thing, or if any of the lib
  directories are symlinks outside of your sandbox.
  
  This means that the most specific module directories
  ("closest" to your executable) will be picked up first.
  
  If you have a version of Frobnicate.pm in your ./package/lib
  for modifications fine: you'll use it before the one in 
  ./project or ./sandbox. 
  
  Using the "p5lib" argument can help in case where some of 
  the code lives outside of the sandbox. To test a sandbox
  version of some other module:
  
      use FindBin::libs qw( p5lib );
  
  and
  
      $ PERL5LIB=/other/sandbox/module foobar;
  
  =item Regression Testing
  
  Everntually, however, you'll need to regression test 
  Frobnicate.pm with other modules. 
  
  Fine: move, copy, or symlink it into ./project/lib and
  you can merrily run ./project/*/bin/* with it and see 
  if there are any problems. In fact, so can the nice 
  folks in QC. 
  
  If you want to install and test a new module just 
  prefix it into, say, ./sandbox/lib and all the code
  that has FindBin::libs will simply use it first. 
  
  =item Testing with Symlinks
  
  $FindBin::Bin is relative to where an executable is started from.
  This allows a symlink to change the location of directories used
  by FindBin::libs. Full regression testing of an executable can be
  accomplished with a symlink:
  
      ./sandbox
          ./lib -> /homegrown/dir/lib
          ./lib/What/Ever.pm
  
          ./pre-change
              ./bin/foobar
  
          ./post-change
              ./lib/What/Ever.pm
              ./bin/foobar -> ../../pre-last-change/bin/foobar
  
  Running foobar symlinked into the post-change directory will
  test it with whatever collection of modules is in the post-change
  directory. A large regression test on some collection of 
  changed modules can be performed with a few symlinks into a 
  sandbox area.
  
  =item Managing Configuration and Meta-data Files
  
  The "base" option alters FindBin::libs standard base directory.
  This allows for a heirarchical set of metadata directories:
  
      ./sandbox
          ./meta
          ./project/
              ./meta
  
          ./project/package
              ./bin
              ./meta
  
  with
  
      use FindBin::libs qw( base=meta export );
  
      sub read_meta
      {
          my $base = shift;
  
          for my $dir ( @meta )
          {
              # open the first one and return
              ...
          }
  
          # caller gets back empty list if nothing was read.
  
          ()
      }
  
  =item using "prove" with local modules.
  
  Modules that are not intended for CPAN will not usually have
  a Makefile.PL or Build setup. This makes it harder to check
  the code via "make test". Instead of hacking a one-time 
  Makefile, FindBin::libs can be used to locate modules in 
  a "lib" directory adjacent to the "t: directory. The setup
  for this module would look like:
  
  
      ./t/01.t
      ./t/02.t
      ...
  
      ./lib/FindBin/libs.pm
  
  since the *.t files use FindBin::libs they can locate the 
  most recent version of code without it having to be copied
  into a ./blib directory (usually via make) before being
  processed. If the module did not have a Makefile this would
  allow:
  
      prove t/*.t;
  
  to check the code.
  
  =back
  
  =head1 Notes
  
  =head2 Alternatives
  
  FindBin::libs was developed to avoid pitfalls with
  the items listed below. As of FindBin::libs-1.20,
  this is also mutli-platform, where other techniques
  may be limited to *NIX or at least less portable.
  
  =over 4
  
  =item PERL5LIBS
  
  PERL5LIB can be used to accomplish the same directory
  lookups as FindBin::libs.  The problem is PERL5LIB often
  contains absolte paths and does not automatically change
  depending on where tests are run. This can leave you 
  modifying a file, changing directory to see if it works
  with some other code and testing an unmodified version of 
  the code via PERL5LIB. FindBin::libs avoids this by using
  $FindBin::bin to reference where the code is running from.
  
  The same is true of trying to use almost any environmental
  solution, with Perl's built in mechanism or one based on
  $ENV{ PWD } or qx( pwd ).
  
  Aside: Combining an existing PERL5LIB for 
  out-of-tree lookups with the "p5lib" option 
  works well for most development situations. 
  
  =item use lib qw( ../../../../Lib );
  
  This works, but how many dots do you need to get all
  the working lib's into a module or #! code? Class
  distrubuted among several levels subdirectories may
  have qw( ../../../lib ) vs. qw( ../../../../lib )
  or various combinations of them. Validating these by
  hand (let alone correcting them) leaves me crosseyed
  after only a short session.
  
  =item Anchor on a fixed lib directory.
  
  Given a standard directory, it is possible to use
  something like:
  
      BEGIN
      {
          my ( $libdir ) = $0 =~ m{ ^( .+? )/SOMEDIR/ }x;
  
          eval "use lib qw( $libdir )";
      }
  
  This looks for a standard location (e.g., /path/to/Mylib)
  in the executable path (or cwd) and uses that. 
  
  The main problem here is that if the anchor ever changes
  (e.g., when moving code between projects or relocating 
  directories now that SVN supports it) the path often has
  to change in multiple files. The regex also may have to
  support multiple platforms, or be broken into more complicated
  File::Spec code that probably looks pretty much like what
  
      use FindBin::libs qw( base=Mylib )
  
  does anyway.
  
  =back
  
  =head2 FindBin::libs-1.2+ uses File::Spec
  
  In order to accmodate a wider range of filesystems, 
  the code has been re-written to use File::Spec for
  all directory and volume manglement. 
  
  There is one thing that File::Spec does not handle,
  hoever, which is fully reolving absolute paths. That
  still has to be handled via abs_path, when it works.
  
  The issue is that File::Spec::rel2abs and 
  Cwd::abs_path work differently: abs_path only 
  returns true for existing directories and 
  resolves symlinks; rel2abs simply prepends cwd() 
  to any non-absolute paths.
  
  The difference for FinBin::libs is that 
  including redundant directories can lead to 
  unexpected results in what gets included; 
  looking up the contents of heavily-symlinked 
  paths is slow (and has some -- admittedly 
  unlikely -- failures at runtime). So, abs_path() 
  is the preferred way to find where the lib's 
  really live after they are found looking up the 
  tree. Using abs_path() also avoids problems 
  where the same directory is included twice in a 
  sandbox' tree via symlinks.
  
  Due to previous complaints that abs_path did not 
  work properly on all systems, the current 
  version of FindBin::libs uses File::Spec to 
  break apart and re-assemble directories, with 
  abs_path used optinally. If "abs_path cwd" works 
  then abs_path is used on the directory paths 
  handed by File::Spec::catpath(); otherwise the 
  paths are used as-is. This may leave users on 
  systms with non-working abs_path() having extra
  copies of external library directories in @INC.
  
  Another issue is that I've heard reports of 
  some systems failing the '-d' test on symlinks,
  where '-e' would have succeded. 
  
  =head1 See Also
  
  =over 4
  
  =item File::Spec
  
  This is used for portability in dis- and re-assembling 
  directory paths based on $FindBin::Bin.
  
  =item Older code.
  
  FindBin::libs_5_8.pm is installed if $^V indicates
  that the running perl is prior to v5.10.
  
  =back
  
  =head1 BUGS
  
  =over 4
  
  =item 
  
  In order to avoid including junk, FindBin::libs
  uses '-d' to test the items before including
  them on the library list. This works fine so 
  long as abs_path() is used to disambiguate any
  symlinks first. If abs_path() is turned off
  then legitimate directories may be left off in
  whatever local conditions might cause a valid
  symlink to fail the '-d' test."
  
  =item
  
  File::Spec 3.16 and prior have a bug in VMS of
  not returning an absolute paths in splitdir for
  dir's without a leading '.'. Fix for this is to
  unshift '', @dirpath if $dirpath[0]. While not a
  bug, this is obviously a somewhat kludgy workaround
  and should be removed (with an added test for a 
  working version) once the File::Spec is fixed.
  
  =item 
  
  The hack for prior-to-5.12 versions of perl is 
  messy, but is the only I've found that works for
  the moment on *NIX, VMS, and MSW. I am not sure
  whether any of these systems are normally configured
  to share perl modules between versions. If the 
  moduels are not shared on multiple platforms then
  I can make this work by managing the installation
  rather than checking this every time at startup.
  
  For the moment, at least, this seems to work.
  
  =back
  
  =head1 AUTHOR
  
  Steven Lembark, Workhorse Computing <lembark@wrkhors.com>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2003-2014, Steven Lembark, Workhorse Computing.
  This code is released under the same terms as Perl-5.20
  or any later version of Perl.
FINDBIN_LIBS

$fatpacked{"Log/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE';
  package Log::Message;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  
  use Params::Check qw[check];
  use Log::Message::Item;
  use Log::Message::Config;
  use Locale::Maketext::Simple Style => 'gettext';
  
  local $Params::Check::VERBOSE = 1;
  
  BEGIN {
      use vars        qw[$VERSION @ISA $STACK $CONFIG];
      $VERSION    =   '0.08';
      $STACK      =   [];
  }
  
  
  =pod
  
  =head1 NAME
  
  Log::Message - A generic message storing mechanism;
  
  =head1 SYNOPSIS
  
      use Log::Message private => 0, config => '/our/cf_file';
  
      my $log = Log::Message->new(    private => 1,
                                      level   => 'log',
                                      config  => '/my/cf_file',
                                 );
  
      $log->store('this is my first message');
  
      $log->store(    message => 'message #2',
                      tag     => 'MY_TAG',
                      level   => 'carp',
                      extra   => ['this is an argument to the handler'],
                 );
  
      my @last_five_items = $log->retrieve(5);
  
      my @items = $log->retrieve( tag     => qr/my_tag/i,
                                  message => qr/\d/,
                                  remove  => 1,
                                );
  
      my @items = $log->final( level => qr/carp/, amount => 2 );
  
      my $first_error = $log->first()
  
      # croak with the last error on the stack
      $log->final->croak;
  
      # empty the stack
      $log->flush();
  
  
  =head1 DESCRIPTION
  
  Log::Message is a generic message storage mechanism.
  It allows you to store messages on a stack -- either shared or private
  -- and assign meta-data to it.
  Some meta-data will automatically be added for you, like a timestamp
  and a stack trace, but some can be filled in by the user, like a tag
  by which to identify it or group it, and a level at which to handle
  the message (for example, log it, or die with it)
  
  Log::Message also provides a powerful way of searching through items
  by regexes on messages, tags and level.
  
  =head1 Hierarchy
  
  There are 4 modules of interest when dealing with the Log::Message::*
  modules:
  
  =over 4
  
  =item Log::Message
  
  Log::Message provides a few methods to manipulate the stack it keeps.
  It has the option of keeping either a private or a public stack.
  More on this below.
  
  =item Log::Message::Item
  
  These are individual message items, which are objects that contain
  the user message as well as the meta-data described above.
  See the L<Log::Message::Item> manpage to see how to extract this
  meta-data and how to work with the Item objects.
  You should never need to create your own Item objects, but knowing
  about their methods and accessors is important if you want to write
  your own handlers. (See below)
  
  =item Log::Message::Handlers
  
  These are a collection of handlers that will be called for a level
  that is used on a L<Log::Message::Item> object.
  For example, if a message is logged with the 'carp' level, the 'carp'
  handler from L<Log::Message::Handlers> will be called.
  See the L<Log::Message::Handlers> manpage for more explanation about how
  handlers work, which one are available and how to create your own.
  
  =item Log::Message::Config
  
  Per Log::Message object, there is a configuration required that will
  fill in defaults if the user did not specify arguments to override
  them (like for example what tag will be set if none was provided),
  L<Log::Message::Config> handles the creation of these configurations.
  
  Configuration can be specified in 4 ways:
  
  =over 4
  
  =item *
  
  As a configuration file when you C<use Log::Message>
  
  =item *
  
  As arguments when you C<use Log::Message>
  
  =item *
  
  As a configuration file when you create a new L<Log::Message> object.
  (The config will then only apply to that object if you marked it as
  private)
  
  =item *
  
  As arguments when you create a new Log::Message object.
  
  You should never need to use the L<Log::Message::Config> module yourself,
  as this is transparently done by L<Log::Message>, but its manpage does
  provide an explanation of how you can create a config file.
  
  =back
  
  =back
  
  =head1 Options
  
  When using Log::Message, or creating a new Log::Message object, you can
  supply various options to alter its behaviour.
  Of course, there are sensible defaults should you choose to omit these
  options.
  
  Below an explanation of all the options and how they work.
  
  =over 4
  
  =item config
  
  The path to a configuration file to be read.
  See the manpage of L<Log::Message::Config> for the required format
  
  These options will be overridden by any explicit arguments passed.
  
  =item private
  
  Whether to create, by default, private or shared objects.
  If you choose to create shared objects, all Log::Message objects will
  use the same stack.
  
  This means that even though every module may make its own $log object
  they will still be sharing the same error stack on which they are
  putting errors and from which they are retrieving.
  
  This can be useful in big projects.
  
  If you choose to create a private object, then the stack will of
  course be private to this object, but it will still fall back to the
  shared config should no private config or overriding arguments be
  provided.
  
  =item verbose
  
  Log::Message makes use of another module to validate its arguments,
  which is called L<Params::Check>, which is a lightweight, yet
  powerful input checker and parser. (See the L<Params::Check>
  manpage for details).
  
  The verbose setting will control whether this module will
  generate warnings if something improper is passed as input, or merely
  silently returns undef, at which point Log::Message will generate a
  warning.
  
  It's best to just leave this at its default value, which is '1'
  
  =item tag
  
  The tag to add to messages if none was provided. If neither your
  config, nor any specific arguments supply a tag, then Log::Message will
  set it to 'NONE'
  
  Tags are useful for searching on or grouping by. For example, you
  could tag all the messages you want to go to the user as 'USER ERROR'
  and all those that are only debug information with 'DEBUG'.
  
  At the end of your program, you could then print all the ones tagged
  'USER ERROR' to STDOUT, and those marked 'DEBUG' to a log file.
  
  =item level
  
  C<level> describes what action to take when a message is logged. Just
  like C<tag>, Log::Message will provide a default (which is 'log') if
  neither your config file, nor any explicit arguments are given to
  override it.
  
  See the Log::Message::Handlers manpage to see what handlers are
  available by default and what they do, as well as to how to add your
  own handlers.
  
  =item remove
  
  This indicates whether or not to automatically remove the messages
  from the stack when you've retrieved them.
  The default setting provided by Log::Message is '0': do not remove.
  
  =item chrono
  
  This indicates whether messages should always be fetched in
  chronological order or not.
  This simply means that you can choose whether, when retrieving items,
  the item most recently added should be returned first, or the one that
  had been added most long ago.
  
  The default is to return the newest ones first
  
  =back
  
  =cut
  
  
  ### subs ###
  sub import {
      my $pkg     = shift;
      my %hash    = @_;
  
      $CONFIG = new Log::Message::Config( %hash )
                  or die loc(qq[Problem initialising %1], __PACKAGE__);
  
  }
  
  =head1 Methods
  
  =head2 new
  
  This creates a new Log::Message object; The parameters it takes are
  described in the C<Options> section below and let it just be repeated
  that you can use these options like this:
  
      my $log = Log::Message->new( %options );
  
  as well as during C<use> time, like this:
  
      use Log::Message option1 => value, option2 => value
  
  There are but 3 rules to keep in mind:
  
  =over 4
  
  =item *
  
  Provided arguments take precedence over a configuration file.
  
  =item *
  
  Arguments to new take precedence over options provided at C<use> time
  
  =item *
  
  An object marked private will always have an empty stack to begin with
  
  =back
  
  =cut
  
  sub new {
      my $class   = shift;
      my %hash    = @_;
  
      my $conf = new Log::Message::Config( %hash, default => $CONFIG ) or return undef;
  
      if( $conf->private || $CONFIG->private ) {
  
          return _new_stack( $class, config => $conf );
  
      } else {
          my $obj = _new_stack( $class, config => $conf, stack => $STACK );
  
          ### if it was an empty stack, this was the first object
          ### in that case, set the global stack to match it for
          ### subsequent new, non-private objects
          $STACK = $obj->{STACK} unless scalar @$STACK;
  
          return $obj;
      }
  }
  
  sub _new_stack {
      my $class = shift;
      my %hash  = @_;
  
      my $tmpl = {
          stack   => { default        => [] },
          config  => { default        => bless( {}, 'Log::Message::Config'),
                       required       => 1,
                       strict_type    => 1
                  },
      };
  
      my $args = check( $tmpl, \%hash, $CONFIG->verbose ) or (
          warn(loc(q[Could not create a new stack object: %1],
                  Params::Check->last_error)
          ),
          return
      );
  
  
      my %self = map { uc, $args->{$_} } keys %$args;
  
      return bless \%self, $class;
  }
  
  sub _get_conf {
      my $self = shift;
      my $what = shift;
  
      return defined $self->{CONFIG}->$what()
                  ?  $self->{CONFIG}->$what()
                  :  defined $CONFIG->$what()
                          ?  $CONFIG->$what()
                          :  undef;           # should never get here
  }
  
  =head2 store
  
  This will create a new Item object and store it on the stack.
  
  Possible arguments you can give to it are:
  
  =over 4
  
  =item message
  
  This is the only argument that is required. If no other arguments
  are given, you may even leave off the C<message> key. The argument
  will then automatically be assumed to be the message.
  
  =item tag
  
  The tag to add to this message. If not provided, Log::Message will look
  in your configuration for one.
  
  =item level
  
  The level at which this message should be handled. If not provided,
  Log::Message will look in your configuration for one.
  
  =item extra
  
  This is an array ref with arguments passed to the handler for this
  message, when it is called from store();
  
  The handler will receive them as a normal list
  
  =back
  
  store() will return true upon success and undef upon failure, as well
  as issue a warning as to why it failed.
  
  =cut
  
  ### should extra be stored in the item object perhaps for later retrieval?
  sub store {
      my $self = shift;
      my %hash = ();
  
      my $tmpl = {
          message => {
                  default     => '',
                  strict_type => 1,
                  required    => 1,
              },
          tag     => { default => $self->_get_conf('tag')     },
          level   => { default => $self->_get_conf('level'),  },
          extra   => { default => [], strict_type => 1 },
      };
  
      ### single arg means just the message
      ### otherwise, they are named
      if( @_ == 1 ) {
          $hash{message} = shift;
      } else {
          %hash = @_;
      }
  
      my $args = check( $tmpl, \%hash ) or (
          warn( loc(q[Could not store error: %1], Params::Check->last_error) ),
          return
      );
  
      my $extra = delete $args->{extra};
      my $item = Log::Message::Item->new(   %$args,
                                          parent  => $self,
                                          id      => scalar @{$self->{STACK}}
                                      )
              or ( warn( loc(q[Could not create new log item!]) ), return undef );
  
      push @{$self->{STACK}}, $item;
  
      {   no strict 'refs';
  
          my $sub = $args->{level};
  
          $item->$sub( @$extra );
      }
  
      return 1;
  }
  
  =head2 retrieve
  
  This will retrieve all message items matching the criteria specified
  from the stack.
  
  Here are the criteria you can discriminate on:
  
  =over 4
  
  =item tag
  
  A regex to which the tag must adhere. For example C<qr/\w/>.
  
  =item level
  
  A regex to which the level must adhere.
  
  =item message
  
  A regex to which the message must adhere.
  
  =item amount
  
  Maximum amount of errors to return
  
  =item chrono
  
  Return in chronological order, or not?
  
  =item remove
  
  Remove items from the stack upon retrieval?
  
  =back
  
  In scalar context it will return the first item matching your criteria
  and in list context, it will return all of them.
  
  If an error occurs while retrieving, a warning will be issued and
  undef will be returned.
  
  =cut
  
  sub retrieve {
      my $self = shift;
      my %hash = ();
  
      my $tmpl = {
          tag     => { default => qr/.*/ },
          level   => { default => qr/.*/ },
          message => { default => qr/.*/ },
          amount  => { default => '' },
          remove  => { default => $self->_get_conf('remove')  },
          chrono  => { default => $self->_get_conf('chrono')  },
      };
  
      ### single arg means just the amount
      ### otherwise, they are named
      if( @_ == 1 ) {
          $hash{amount} = shift;
      } else {
          %hash = @_;
      }
  
      my $args = check( $tmpl, \%hash ) or (
          warn( loc(q[Could not parse input: %1], Params::Check->last_error) ),
          return
      );
  
      my @list =
              grep { $_->tag      =~ /$args->{tag}/       ? 1 : 0 }
              grep { $_->level    =~ /$args->{level}/     ? 1 : 0 }
              grep { $_->message  =~ /$args->{message}/   ? 1 : 0 }
              grep { defined }
                  $args->{chrono}
                      ? @{$self->{STACK}}
                      : reverse @{$self->{STACK}};
  
      my $amount = $args->{amount} || scalar @list;
  
      my @rv = map {
                  $args->{remove} ? $_->remove : $_
             } scalar @list > $amount
                              ? splice(@list,0,$amount)
                              : @list;
  
      return wantarray ? @rv : $rv[0];
  }
  
  =head2 first
  
  This is a shortcut for retrieving the first item(s) stored on the
  stack. It will default to only retrieving one if called with no
  arguments, and will always return results in chronological order.
  
  If you only supply one argument, it is assumed to be the amount you
  wish returned.
  
  Furthermore, it can take the same arguments as C<retrieve> can.
  
  =cut
  
  sub first {
      my $self = shift;
  
      my $amt = @_ == 1 ? shift : 1;
      return $self->retrieve( amount => $amt, @_, chrono => 1 );
  }
  
  =head2 last
  
  This is a shortcut for retrieving the last item(s) stored on the
  stack. It will default to only retrieving one if called with no
  arguments, and will always return results in reverse chronological
  order.
  
  If you only supply one argument, it is assumed to be the amount you
  wish returned.
  
  Furthermore, it can take the same arguments as C<retrieve> can.
  
  =cut
  
  sub final {
      my $self = shift;
  
      my $amt = @_ == 1 ? shift : 1;
      return $self->retrieve( amount => $amt, @_, chrono => 0 );
  }
  
  =head2 flush
  
  This removes all items from the stack and returns them to the caller
  
  =cut
  
  sub flush {
      my $self = shift;
  
      return splice @{$self->{STACK}};
  }
  
  =head1 SEE ALSO
  
  L<Log::Message::Item>, L<Log::Message::Handlers>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE

$fatpacked{"Log/Message/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_CONFIG';
  package Log::Message::Config;
  use if $] > 5.017, 'deprecate';
  use strict;
  
  use Params::Check qw[check];
  use Module::Load;
  use FileHandle;
  use Locale::Maketext::Simple Style => 'gettext';
  
  BEGIN {
      use vars        qw[$VERSION $AUTOLOAD];
      $VERSION    =   '0.08';
  }
  
  sub new {
      my $class = shift;
      my %hash  = @_;
  
      ### find out if the user specified a config file to use
      ### and/or a default configuration object
      ### and remove them from the argument hash
      my %special =   map { lc, delete $hash{$_} }
                      grep /^config|default$/i, keys %hash;
  
      ### allow provided arguments to override the values from the config ###
      my $tmpl = {
          private => { default => undef,  },
          verbose => { default => 1       },
          tag     => { default => 'NONE', },
          level   => { default => 'log',  },
          remove  => { default => 0       },
          chrono  => { default => 1       },
      };
  
      my %lc_hash = map { lc, $hash{$_} } keys %hash;
  
      my $file_conf;
      if( $special{config} ) {
          $file_conf = _read_config_file( $special{config} )
                          or ( warn( loc(q[Could not parse config file!]) ), return );
      }
  
      my $def_conf = \%{ $special{default} || {} };
  
      ### make sure to only include keys that are actually defined --
      ### the checker will assign even 'undef' if you have provided that
      ### as a value
      ### priorities goes as follows:
      ### 1: arguments passed
      ### 2: any config file passed
      ### 3: any default config passed
      my %to_check =  map     { @$_ }
                      grep    { defined $_->[1] }
                      map     {   [ $_ =>
                                      defined $lc_hash{$_}        ? $lc_hash{$_}      :
                                      defined $file_conf->{$_}    ? $file_conf->{$_}  :
                                      defined $def_conf->{$_}     ? $def_conf->{$_}   :
                                      undef
                                  ]
                              } keys %$tmpl;
  
      my $rv = check( $tmpl, \%to_check, 1 )
                  or ( warn( loc(q[Could not validate arguments!]) ), return );
  
      return bless $rv, $class;
  }
  
  sub _read_config_file {
      my $file = shift or return;
  
      my $conf = {};
      my $FH = new FileHandle;
      $FH->open("$file", 'r') or (
                          warn(loc(q[Could not open config file '%1': %2],$file,$!)),
                          return {}
                      );
  
      while(<$FH>) {
          next if     /\s*#/;
          next unless /\S/;
  
          chomp; s/^\s*//; s/\s*$//;
  
          my ($param,$val) = split /\s*=\s*/;
  
          if( (lc $param) eq 'include' ) {
              load $val;
              next;
          }
  
          ### add these to the config hash ###
          $conf->{ lc $param } = $val;
      }
      close $FH;
  
      return $conf;
  }
  
  sub AUTOLOAD {
      $AUTOLOAD =~ s/.+:://;
  
      my $self = shift;
  
      return $self->{ lc $AUTOLOAD } if exists $self->{ lc $AUTOLOAD };
  
      die loc(q[No such accessor '%1' for class '%2'], $AUTOLOAD, ref $self);
  }
  
  sub DESTROY { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Log::Message::Config - Configuration options for Log::Message
  
  =head1 SYNOPSIS
  
      # This module is implicitly used by Log::Message to create a config
      # which it uses to log messages.
      # For the options you can pass, see the C<Log::Message new()> method.
  
      # Below is a sample of a config file you could use
  
      # comments are denoted by a single '#'
      # use a shared stack, or have a private instance?
      # if none provided, set to '0',
      private = 1
  
      # do not be verbose
      verbose = 0
  
      # default tag to set on new items
      # if none provided, set to 'NONE'
      tag = SOME TAG
  
      # default level to handle items
      # if none provided, set to 'log'
      level = carp
  
      # extra files to include
      # if none provided, no files are auto included
      include = mylib.pl
      include = ../my/other/lib.pl
  
      # automatically delete items
      # when you retrieve them from the stack?
      # if none provided, set to '0'
      remove = 1
  
      # retrieve errors in chronological order, or not?
      # if none provided, set to '1'
      chrono = 0
  
  =head1 DESCRIPTION
  
  Log::Message::Config provides a standardized config object for
  Log::Message objects.
  
  It can either read options as perl arguments, or as a config file.
  See the Log::Message manpage for more information about what arguments
  are valid, and see the Synopsis for an example config file you can use
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Item>, L<Log::Message::Handlers>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_CONFIG

$fatpacked{"Log/Message/Handlers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_HANDLERS';
  package Log::Message::Handlers;
  use if $] > 5.017, 'deprecate';
  use strict;
  use vars qw[$VERSION];
  
  $VERSION = '0.08';
  
  =pod
  
  =head1 NAME
  
  Log::Message::Handlers - Message handlers for Log::Message
  
  =head1 SYNOPSIS
  
      # Implicitly used by Log::Message to serve as handlers for
      # Log::Message::Item objects
  
      # Create your own file with a package called
      # Log::Message::Handlers to add to the existing ones, or to even
      # overwrite them
  
      $item->carp;
  
      $item->trace;
  
  
  =head1 DESCRIPTION
  
  Log::Message::Handlers provides handlers for Log::Message::Item objects.
  The handler corresponding to the level (see Log::Message::Item manpage
  for an explanation about levels) will be called automatically upon
  storing the error.
  
  Handlers may also explicitly be called on an Log::Message::Item object
  if one so desires (see the Log::Message manpage on how to retrieve the
  Item objects).
  
  =head1 Default Handlers
  
  =head2 log
  
  Will simply log the error on the stack, and do nothing special
  
  =cut
  
  sub log { 1 }
  
  =head2 carp
  
  Will carp (see the Carp manpage) with the error, and add the timestamp
  of when it occurred.
  
  =cut
  
  sub carp {
      my $self = shift;
      warn join " ", $self->message, $self->shortmess, 'at', $self->when, "\n";
  }
  
  =head2 croak
  
  Will croak (see the Carp manpage) with the error, and add the
  timestamp of when it occurred.
  
  =cut
  
  sub croak {
      my $self = shift;
      die join " ", $self->message, $self->shortmess, 'at', $self->when, "\n";
  }
  
  =head2 cluck
  
  Will cluck (see the Carp manpage) with the error, and add the
  timestamp of when it occurred.
  
  =cut
  
  sub cluck {
      my $self = shift;
      warn join " ", $self->message, $self->longmess, 'at', $self->when, "\n";
  }
  
  =head2 confess
  
  Will confess (see the Carp manpage) with the error, and add the
  timestamp of when it occurred
  
  =cut
  
  sub confess {
      my $self = shift;
      die join " ", $self->message, $self->longmess, 'at', $self->when, "\n";
  }
  
  =head2 die
  
  Will simply die with the error message of the item
  
  =cut
  
  sub die  { die  shift->message; }
  
  
  =head2 warn
  
  Will simply warn with the error message of the item
  
  =cut
  
  sub warn { warn shift->message; }
  
  
  =head2 trace
  
  Will provide a traceback of this error item back to the first one that
  occurred, clucking with every item as it comes across it.
  
  =cut
  
  sub trace {
      my $self = shift;
  
      for my $item( $self->parent->retrieve( chrono => 0 ) ) {
          $item->cluck;
      }
  }
  
  =head1 Custom Handlers
  
  If you wish to provide your own handlers, you can simply do the
  following:
  
  =over 4
  
  =item *
  
  Create a file that holds a package by the name of
  C<Log::Message::Handlers>
  
  =item *
  
  Create subroutines with the same name as the levels you wish to
  handle in the Log::Message module (see the Log::Message manpage for
  explanation on levels)
  
  =item *
  
  Require that file in your program, or add it in your configuration
  (see the Log::Message::Config manpage for explanation on how to use a
  config file)
  
  =back
  
  And that is it, the handler will now be available to handle messages
  for you.
  
  The arguments a handler may receive are those specified by the
  C<extra> key, when storing the message.
  See the Log::Message manpage for details on the arguments.
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Item>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_HANDLERS

$fatpacked{"Log/Message/Item.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_ITEM';
  package Log::Message::Item;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  use vars qw[$VERSION];
  use Params::Check qw[check];
  use Log::Message::Handlers;
  
  ### for the messages to store ###
  use Carp ();
  
  BEGIN {
      use vars qw[$AUTOLOAD $VERSION];
  
      $VERSION    =   '0.08';
  }
  
  ### create a new item.
  ### note that only an id (position on the stack), message and a reference
  ### to its parent are required. all the other things it can fill in itself
  sub new {
      my $class   = shift;
      my %hash    = @_;
  
      my $tmpl = {
          when        => { no_override    => 1,   default    => scalar localtime },
          id          => { required       => 1    },
          message     => { required       => 1    },
          parent      => { required        => 1    },
          level       => { default        => ''   },      # default may be conf dependant
          tag         => { default        => ''   },      # default may be conf dependant
          longmess    => { default        => _clean(Carp::longmess()) },
          shortmess   => { default        => _clean(Carp::shortmess())},
      };
  
      my $args = check($tmpl, \%hash) or return undef;
  
      return bless $args, $class;
  }
  
  sub _clean { map { s/\s*//; chomp; $_ } shift; }
  
  sub remove {
      my $item = shift;
      my $self = $item->parent;
  
      return splice( @{$self->{STACK}}, $item->id, 1, undef );
  }
  
  sub AUTOLOAD {
      my $self = $_[0];
  
      $AUTOLOAD =~ s/.+:://;
  
      return $self->{$AUTOLOAD} if exists $self->{$AUTOLOAD};
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 3;
  
      {   no strict 'refs';
          return *{"Log::Message::Handlers::${AUTOLOAD}"}->(@_);
      }
  }
  
  sub DESTROY { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Log::Message::Item  - Message objects for Log::Message
  
  =head1 SYNOPSIS
  
      # Implicitly used by Log::Message to create Log::Message::Item objects
  
      print "this is the message's id: ",     $item->id;
  
      print "this is the message stored: ",   $item->message;
  
      print "this is when it happened: ",     $item->when;
  
      print "the message was tagged: ",       $item->tag;
  
      print "this was the severity level: ",  $item->level;
  
      $item->remove;  # delete the item from the stack it was on
  
      # Besides these methods, you can also call the handlers on
      # the object specifically.
      # See the Log::Message::Handlers manpage for documentation on what
      # handlers are available by default and how to add your own
  
  
  =head1 DESCRIPTION
  
  Log::Message::Item is a class that generates generic Log items.
  These items are stored on a Log::Message stack, so see the Log::Message
  manpage about details how to retrieve them.
  
  You should probably not create new items by yourself, but use the
  storing mechanism provided by Log::Message.
  
  However, the accessors and handlers are of interest if you want to do
  fine tuning of how your messages are handled.
  
  The accessors and methods are described below, the handlers are
  documented in the Log::Message::Handlers manpage.
  
  =head1 Methods and Accessors
  
  =head2 remove
  
  Calling remove will remove the object from the stack it was on, so it
  will not show up any more in subsequent fetches of messages.
  
  You can still call accessors and handlers on it however, to handle it
  as you will.
  
  =head2 id
  
  Returns the internal ID of the item. This may be useful for comparing
  since the ID is incremented each time a new item is created.
  Therefore, an item with ID 4 must have been logged before an item with
  ID 9.
  
  =head2 when
  
  Returns the timestamp of when the message was logged
  
  =head2 message
  
  The actual message that was stored
  
  =head2 level
  
  The severity type of this message, as well as the name of the handler
  that was called upon storing it.
  
  =head2 tag
  
  Returns the identification tag that was put on the message.
  
  =head2 shortmess
  
  Returns the equivalent of a C<Carp::shortmess> for this item.
  See the C<Carp> manpage for details.
  
  =head2 longmess
  
  Returns the equivalent of a C<Carp::longmess> for this item, which
  is essentially a stack trace.
  See the C<Carp> manpage for details.
  
  =head2 parent
  
  Returns a reference to the Log::Message object that stored this item.
  This is useful if you want to have access to the full stack in a
  handler.
  
  =head1 SEE ALSO
  
  L<Log::Message>, L<Log::Message::Handlers>, L<Log::Message::Config>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 Acknowledgements
  
  Thanks to Ann Barcomb for her suggestions.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2002 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_ITEM

$fatpacked{"Log/Message/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_MESSAGE_SIMPLE';
  package Log::Message::Simple;
  use if $] > 5.017, 'deprecate';
  
  use strict;
  use Log::Message private => 0;;
  
  BEGIN {
      use vars qw[$VERSION];
      $VERSION = '0.10';
  }
  
  
  =pod
  
  =head1 NAME
  
  Log::Message::Simple - Simplified interface to Log::Message
  
  =head1 SYNOPSIS
  
      use Log::Message::Simple qw[msg error debug
                                  carp croak cluck confess];
  
      use Log::Message::Simple qw[:STD :CARP];
  
      ### standard reporting functionality
      msg(    "Connecting to database",           $verbose );
      error(  "Database connection failed: $@",   $verbose );
      debug(  "Connection arguments were: $args", $debug );
  
      ### standard carp functionality
      carp(   "Wrong arguments passed: @_" );
      croak(  "Fatal: wrong arguments passed: @_" );
      cluck(  "Wrong arguments passed -- including stacktrace: @_" );
      confess("Fatal: wrong arguments passed -- including stacktrace: @_" );
  
      ### retrieve individual message
      my @stack = Log::Message::Simple->stack;
      my @stack = Log::Message::Simple->flush;
  
      ### retrieve the entire stack in printable form
      my $msgs  = Log::Message::Simple->stack_as_string;
      my $trace = Log::Message::Simple->stack_as_string(1);
  
      ### redirect output
      local $Log::Message::Simple::MSG_FH     = \*STDERR;
      local $Log::Message::Simple::ERROR_FH   = \*STDERR;
      local $Log::Message::Simple::DEBUG_FH   = \*STDERR;
  
      ### force a stacktrace on error
      local $Log::Message::Simple::STACKTRACE_ON_ERROR = 1
  
  =head1 DESCRIPTION
  
  This module provides standardized logging facilities using the
  C<Log::Message> module.
  
  =head1 FUNCTIONS
  
  =head2 msg("message string" [,VERBOSE])
  
  Records a message on the stack, and prints it to C<STDOUT> (or actually
  C<$MSG_FH>, see the C<GLOBAL VARIABLES> section below), if the
  C<VERBOSE> option is true.
  The C<VERBOSE> option defaults to false.
  
  Exported by default, or using the C<:STD> tag.
  
  =head2 debug("message string" [,VERBOSE])
  
  Records a debug message on the stack, and prints it to C<STDOUT> (or
  actually C<$DEBUG_FH>, see the C<GLOBAL VARIABLES> section below),
  if the C<VERBOSE> option is true.
  The C<VERBOSE> option defaults to false.
  
  Exported by default, or using the C<:STD> tag.
  
  =head2 error("error string" [,VERBOSE])
  
  Records an error on the stack, and prints it to C<STDERR> (or actually
  C<$ERROR_FH>, see the C<GLOBAL VARIABLES> sections below), if the
  C<VERBOSE> option is true.
  The C<VERBOSE> options defaults to true.
  
  Exported by default, or using the C<:STD> tag.
  
  =cut
  
  {   package Log::Message::Handlers;
  
      sub msg {
          my $self    = shift;
          my $verbose = shift || 0;
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::MSG_FH;
          print '['. $self->tag (). '] ' . $self->message . "\n";
          select $old_fh;
  
          return;
      }
  
      sub debug {
          my $self    = shift;
          my $verbose = shift || 0;
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::DEBUG_FH;
          print '['. $self->tag (). '] ' . $self->message . "\n";
          select $old_fh;
  
          return;
      }
  
      sub error {
          my $self    = shift;
          my $verbose = shift;
             $verbose = 1 unless defined $verbose;    # default to true
  
          ### so you don't want us to print the error? ###
          return if defined $verbose && $verbose == 0;
  
          my $old_fh = select $Log::Message::Simple::ERROR_FH;
  
          my $msg     = '['. $self->tag . '] ' . $self->message;
  
          print $Log::Message::Simple::STACKTRACE_ON_ERROR
                      ? Carp::shortmess($msg)
                      : $msg . "\n";
  
          select $old_fh;
  
          return;
      }
  }
  
  =head2 carp();
  
  Provides functionality equal to C<Carp::carp()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 croak();
  
  Provides functionality equal to C<Carp::croak()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 confess();
  
  Provides functionality equal to C<Carp::confess()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head2 cluck();
  
  Provides functionality equal to C<Carp::cluck()> while still logging
  to the stack.
  
  Exported by using the C<:CARP> tag.
  
  =head1 CLASS METHODS
  
  =head2 Log::Message::Simple->stack()
  
  Retrieves all the items on the stack. Since C<Log::Message::Simple> is
  implemented using C<Log::Message>, consult its manpage for the
  function C<retrieve> to see what is returned and how to use the items.
  
  =head2 Log::Message::Simple->stack_as_string([TRACE])
  
  Returns the whole stack as a printable string. If the C<TRACE> option is
  true all items are returned with C<Carp::longmess> output, rather than
  just the message.
  C<TRACE> defaults to false.
  
  =head2 Log::Message::Simple->flush()
  
  Removes all the items from the stack and returns them. Since
  C<Log::Message::Simple> is  implemented using C<Log::Message>, consult its
  manpage for the function C<retrieve> to see what is returned and how
  to use the items.
  
  =cut
  
  BEGIN {
      use Exporter;
      use Params::Check   qw[ check ];
      use vars            qw[ @EXPORT @EXPORT_OK %EXPORT_TAGS @ISA ];;
  
      @ISA            = 'Exporter';
      @EXPORT         = qw[error msg debug];
      @EXPORT_OK      = qw[carp cluck croak confess];
  
      %EXPORT_TAGS    = (
          STD     => \@EXPORT,
          CARP    => \@EXPORT_OK,
          ALL     => [ @EXPORT, @EXPORT_OK ],
      );
  
      my $log         = new Log::Message;
  
      for my $func ( @EXPORT, @EXPORT_OK ) {
          no strict 'refs';
  
                          ### up the carplevel for the carp emulation
                          ### functions
          *$func = sub {  local $Carp::CarpLevel += 2
                              if grep { $_ eq $func } @EXPORT_OK;
  
                          my $msg     = shift;
                          $log->store(
                                  message => $msg,
                                  tag     => uc $func,
                                  level   => $func,
                                  extra   => [@_]
                          );
                  };
      }
  
      sub flush {
          return reverse $log->flush;
      }
  
      sub stack {
          return $log->retrieve( chrono => 1 );
      }
  
      sub stack_as_string {
          my $class = shift;
          my $trace = shift() ? 1 : 0;
  
          return join $/, map {
                          '[' . $_->tag . '] [' . $_->when . '] ' .
                          ($trace ? $_->message . ' ' . $_->longmess
                                  : $_->message);
                      } __PACKAGE__->stack;
      }
  }
  
  =head1 GLOBAL VARIABLES
  
  =over 4
  
  =item $ERROR_FH
  
  This is the filehandle all the messages sent to C<error()> are being
  printed. This defaults to C<*STDERR>.
  
  =item $MSG_FH
  
  This is the filehandle all the messages sent to C<msg()> are being
  printed. This default to C<*STDOUT>.
  
  =item $DEBUG_FH
  
  This is the filehandle all the messages sent to C<debug()> are being
  printed. This default to C<*STDOUT>.
  
  =item $STACKTRACE_ON_ERROR
  
  If this option is set to C<true>, every call to C<error()> will
  generate a stacktrace using C<Carp::shortmess()>.
  Defaults to C<false>
  
  =back
  
  =cut
  
  BEGIN {
      use vars qw[ $ERROR_FH $MSG_FH $DEBUG_FH $STACKTRACE_ON_ERROR ];
  
      local $| = 1;
      $ERROR_FH               = \*STDERR;
      $MSG_FH                 = \*STDOUT;
      $DEBUG_FH               = \*STDOUT;
  
      $STACKTRACE_ON_ERROR    = 0;
  }
  
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
LOG_MESSAGE_SIMPLE

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use Moo::_strictures;
  use Moo::_Utils;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quoted_from_sub quotify);
  use Scalar::Util 'blessed';
  use overload ();
  use Module::Runtime qw(use_module);
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  
  my $module_name_only = qr/\A$Module::Runtime::module_name_rx\z/;
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    die "You cannot overwrite a locally defined method ($method) with "
      . ( $type || 'an accessor' );
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless exists $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      die "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ $module_name_only;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
    if (($spec->{coerce}||0) eq 1) {
      my $isa = $spec->{isa};
      if (blessed $isa and $isa->can('coercion')) {
        $spec->{coerce} = $isa->coercion;
      } elsif (blessed $isa and $isa->can('coerce')) {
        $spec->{coerce} = sub { $isa->coerce(@_) };
      } else {
        die "Invalid coercion for $into->$name - no appropriate type constraint";
      }
    }
  
    foreach my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name",
          'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      foreach my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && defined &{"${into}::${reader}"};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && defined &{"${into}::${accessor}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${writer}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && defined &{"${into}::${pred}"};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $methods{$pred} =
          quote_sub "${into}::${pred}" =>
            '    '.$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
          ;
      }
    }
    if (my $pred = $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $spec->{builder_sub} );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${cl}"};
      $methods{$cl} =
        quote_sub "${into}::${cl}" =>
          $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], use_module('Moo::Role')->methods_provided_by(use_module($hspec))
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && defined &{"${into}::${proxy}"};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
  
  
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" =>
          $self->_generate_asserter($name, $spec),
          delete $self->{captures};
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_default {
    my ($self, $name, $spec) = @_;
    $spec->{builder} or exists $spec->{default} or (($spec->{is}||'') eq 'lazy');
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\quotify $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\quotify $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa} ?
         "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n"
    );
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
      : quotify $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_simple_get(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $value_store = '$_[0]';
      my $code;
      if ($coerce) {
        $value_store = '$value';
        $code = "do { my (\$self, \$value) = \@_;\n"
          ."        \$value = "
          .$self->_generate_coerce($name, $value_store, $coerce).";\n";
      }
      else {
        $code = "do { my \$self = shift;\n";
      }
      if ($isa_check) {
        $code .=
          "        ".$self->_generate_isa_check($name, $value_store, $isa_check).";\n";
      }
      my $simple = $self->_generate_simple_set('$self', $name, $spec, $value_store);
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', $value_store, $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        $value_store;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return quotify($name) if !defined($init_arg) or $init_arg eq $name;
    return quotify($name).' (constructor argument: '.quotify($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce),
      1,
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _wrap_attr_exception {
    my ($self, $name, $step, $arg, $code, $want_return) = @_;
    my $prefix = quotify("${step} for "._attr_desc($name, $arg).' failed: ');
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n"
    .'    init_arg => '.quotify($arg).",\n"
    .'    name     => '.quotify($name).",\n"
    .'    step     => '.quotify($step).",\n"
    ."  };\n"
    .($want_return ? '  my $_return;'."\n" : '')
    .'  my $_error;'."\n"
    ."  {\n"
    .'    my $_old_error = $@;'."\n"
    ."    if (!eval {\n"
    .'      $@ = $_old_error;'."\n"
    .($want_return ? '      $_return ='."\n" : '')
    .'      '.$code.";\n"
    ."      1;\n"
    ."    }) {\n"
    .'      $_error = $@;'."\n"
    .'      if (!ref $_error) {'."\n"
    .'        $_error = '.$prefix.'.$_error;'."\n"
    ."      }\n"
    ."    }\n"
    .'    $@ = $_old_error;'."\n"
    ."  }\n"
    .'  die $_error if $_error;'."\n"
    .($want_return ? '  $_return;'."\n" : '')
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.$self->_sanitize_name($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify($code, $values,
          Sub::Quote::capture_unroll($cap_name, $captures, 6), $local);
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.$self->_sanitize_name($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name {
    my ($self, $name) = @_;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $name, $spec
                        );
      my $get_value =
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n"
              ."${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ($spec->{coerce}) {
        $get_value = $self->_generate_coerce(
          $name, $get_value,
          $spec->{coerce}, $init_arg
        )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}, $init_arg
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name, $spec),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $source,
              $spec->{coerce}, $init_arg
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}, $init_arg
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name, $spec),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      # &Internals::SvREADONLY($foo, 0);
      # Scalar::Util::weaken($foo);
      # &Internals::SvREADONLY($foo, 1);
      #
      # but requires Internal functions and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : $weak_simple;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
  
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  unless (".$self->_generate_simple_has('$_[0]', $name, $spec).") {\n"
     .qq!    die "Attempted to access '${name}' but it is not set";\n!
     ."  }\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using quotify
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      die "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      die "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{mro::get_linear_isa($into)};
    '    unless (('.$args.')[0]->{__no_BUILD__}) {'."\n"
    .join('', map qq{      ${me}->${_}(${args});\n}, @builds)
    ."   }\n";
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use Moo::_strictures;
  use Sub::Quote qw(quote_sub unquote_sub quotify);
  use Sub::Defer;
  use Moo::_Utils qw(_getstash _getglob);
  use Moo;
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    $self->assert_constructor;
    my $specs = $self->{attribute_specs}||={};
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        die "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        foreach my $key (keys %$old_spec) {
          if (!exists $new_spec->{$key}) {
            $new_spec->{$key} = $old_spec->{$key}
              unless $key eq 'handles';
          }
          elsif ($key eq 'moosify') {
            $new_spec->{$key} = [
              map { ref $_ eq 'ARRAY' ? @$_ : $_ }
                ($old_spec->{$key}, $new_spec->{$key})
            ];
          }
        }
      }
      if ($new_spec->{required}
        && !(
          $self->accessor_generator->has_default($name, $new_spec)
          || !exists $new_spec->{init_arg}
          || defined $new_spec->{init_arg}
        )
      ) {
        die "You cannot have a required attribute (${name})"
          . " without a default, builder, or an init_arg";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    $self->assert_constructor;
    my $package = $self->{package};
    my (undef, @isa) = @{mro::get_linear_isa($package)};
    my $isa = join ',', @isa;
    $self->{deferred_constructor} = defer_sub "${package}::new" => sub {
      my (undef, @new_isa) = @{mro::get_linear_isa($package)};
      if (join(',', @new_isa) ne $isa) {
        my ($expected_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa;
        my ($found_new) = grep { *{_getglob($_.'::new')}{CODE} } @new_isa;
        if (($found_new||'') ne ($expected_new||'')) {
          $found_new ||= 'none';
          $expected_new ||= 'none';
          die "Expected parent constructor of $package expected to be"
          . " $expected_new, but found $found_new: changing the inheritance"
          . " chain (\@ISA) at runtime is unsupported";
        }
      }
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub current_constructor {
    my ($self, $package) = @_;
    return *{_getglob("${package}::new")}{CODE};
  }
  
  sub assert_constructor {
    my ($self) = @_;
    my $package = $self->{package} or return 1;
    my $current = $self->current_constructor($package)
      or return 1;
    my $deferred = $self->{deferred_constructor}
      or die "Unknown constructor for $package already exists";
    return 1
      if $deferred == $current;
    my $current_deferred = (Sub::Defer::defer_info($current)||[])->[3];
    if ($current_deferred && $current_deferred == $deferred) {
      die "Constructor for $package has been inlined and cannot be updated";
    }
    die "Constructor for $package has been replaced with an unknown sub";
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      $body .= $self->buildall_generator->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.quotify($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg_key = quotify($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $test{$_},
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or exists $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, '
      .join(', ', map quotify($_), @required_init).') {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  # bootstrap our own constructor
  sub new {
    my $class = shift;
    delete _getstash(__PACKAGE__)->{new};
    bless $class->BUILDARGS(@_), $class;
  }
  Moo->_constructor_maker_for(__PACKAGE__)
  ->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'bare' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'bare' },
  );
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{mro::get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;
  
  use Moo::_strictures;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
          $fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use Moo::_strictures;
  use Moo::_Utils;
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  Moo::sification->import;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
  
    strict->import;
    warnings->import;
  
    if ($INC{'Role/Tiny.pm'} and Role::Tiny->is_role($target)) {
      die "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map { *$_{CODE}||() } grep !ref($_), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{'Role/Tiny.pm'} && Role::Tiny->is_role($superclass)) {
        require Carp;
        Carp::croak("Can't extend role '$superclass'");
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      $old->assert_constructor;
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    no warnings 'once'; # piss off. -- mst
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              require Sub::Defer;
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
      require Sub::Defer;
  
      my %construct_opts = (
        package => $target,
        accessor_generator => $class->_accessor_maker_for($target),
        subconstructor_handler => (
          '      if ($Moo::MAKERS{$class}) {'."\n"
          .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n"
          .'          return $class->'.$target.'::SUPER::new(@_);'."\n"
          .'        }'."\n"
          .'        '.$class.'->_constructor_maker_for($class);'."\n"
          .'        return $class->new(@_)'.";\n"
          .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
          .'        return $meta->new_object('."\n"
          .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n"
          .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n"
          .'        );'."\n"
          .'      }'."\n"
        ),
      );
  
      my $con;
      my @isa = @{mro::get_linear_isa($target)};
      shift @isa;
      if (my ($parent_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa) {
        if ($parent_new eq 'Moo::Object') {
          # no special constructor needed
        }
        elsif (my $makers = $MAKERS{$parent_new}) {
          $con = $makers->{constructor};
          $construct_opts{construction_string} = $con->construction_string
            if $con;
        }
        elsif ($parent_new->can('BUILDALL')) {
          $construct_opts{construction_builder} = sub {
            my $inv = $target->can('BUILDARGS') ? '' : 'Moo::Object::';
            'do {'
            .'  my $args = $class->'.$inv.'BUILDARGS(@_);'
            .'  $args->{__no_BUILD__} = 1;'
            .'  $class->'.$target.'::SUPER::new($args);'
            .'}'
          };
        }
        else {
          $construct_opts{construction_builder} = sub {
            '$class->'.$target.'::SUPER::new('
              .($target->can('FOREIGNBUILDARGS') ?
                '$class->FOREIGNBUILDARGS(@_)' : '@_')
              .')'
          };
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(%construct_opts)
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $makers = $MAKERS{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
   use strictures 2;
   use namespace::clean;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
   );
  
   has pounds => (
     is  => 'rw',
     isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  And elsewhere:
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  C<Moo> is an extremely light-weight Object Orientation system. It allows one to
  concisely define objects and roles with a convenient syntax that avoids the
  details of Perl's object system.  C<Moo> contains a subset of L<Moose> and is
  optimised for rapid startup.
  
  C<Moo> avoids depending on any XS modules to allow for simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite --
  two thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead to provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  But if you don't want to use L<Moose>, you may not want "less metaprotocol"
  like L<Mouse> offers, but you probalby want "no metaprotocol", which is what
  Moo provides. C<Moo> is ideal for some situations where deployment or startup
  time precludes using L<Moose> and L<Mouse>:
  
  =over 2
  
  =item a command line or CGI script where fast startup is essential
  
  =item code designed to be deployed as a single file via L<App::FatPacker>
  
  =item a CPAN module that may be used by others in the above situations
  
  =back
  
  C<Moo> maintains transparent compatibility with L<Moose> so if you install and
  load L<Moose> you can use Moo clases and roles in L<Moose> code without
  modification.
  
  Moo -- Minimal Object Orientation -- aims to make it smooth to upgrade to
  L<Moose> when you need more than the minimal features offered by Moo.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without modification.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  L<Moo> classes and roles, so that in Moose classes C<< isa => 'MyMooClass' >>
  and C<< isa => 'MyMooRole' >> work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  Extending a L<Mouse> class or consuming a L<Mouse::Role> will also work. But
  note that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  global and turns the mechanism off entirely so don't put this in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it
  will be used to generate simple accessors, readers, and writers for
  better performance.  Simple accessors are those without lazy defaults,
  type checks/coercions, or triggers.  Readers and writers generated
  by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   sub BUILDARGS {
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return { @args };
   }
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as C<BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares a base class. Multiple superclasses can be passed for multiple
  inheritance but please consider using L<roles|Moo::Role> instead.  The class
  will be loaded but no errors will be triggered if the class can't be found and
  there are already subs in the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
  
  or
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles cannot be composed because they
  have conflicting method definitions.  The roles will be loaded using the same
  mechansim as C<extends> uses.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
   package Foo;
   use Moo;
   has 'attr' => (
     is => 'ro'
   );
  
   package Bar;
   use Moo;
   extends 'Foo';
   has '+attr' => (
     default => sub { "blah" },
   );
  
  Using the C<+> notation, it's possible to override an attribute.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * C<is>
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> stands for "read-only" and generates an accessor that dies if you attempt
  to write to it - i.e.  a getter only - by defaulting C<reader> to the name of
  the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> stands for "read-write protected" and generates a reader like C<ro>, but
  also sets C<writer> to C<_set_${attribute_name}> for attributes that are
  designed to be written from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> stands for "read-write" and generates a normal getter/setter by
  defaulting the C<accessor> to the name of the attribute specified.
  
  =item * C<isa>
  
  Takes a coderef which is used to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   use Scalar::Util qw(looks_like_number);
   ...
   isa => sub {
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  Note that the return value for C<isa> is discarded. Only if the sub dies does
  type validation fail.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<Moose> compatible or L<MooseX::Types> style named types, look at
  L<Type::Tiny>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item * C<coerce>
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always execute your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  If the C<isa> option is a blessed object providing a C<coerce> or
  C<coercion> method, then the C<coerce> option may be set to just C<1>.
  
  =item * C<handles>
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a L<role|Moo::Role> that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. The coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<default>
  
  Takes a coderef which will get called with $self as its only argument to
  populate an attribute if no value for that attribute was supplied to the
  constructor. Alternatively, if the attribute is lazy, C<default> executes when
  the attribute is first retrieved if no value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item * C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  B<NOTE:> If the attribute is C<lazy>, it will be regenerated from C<default> or
  C<builder> the next time it is accessed. If it is not lazy, it will be C<undef>.
  
  =item * C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on object instantiation.
  
  =item * C<reader>
  
  The name of the method that returns the value of the attribute.  If you like
  Java style methods, you might set this to C<get_foo>
  
  =item * C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item * C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened. Use this when circular references, which cause memory leaks, are
  possible.
  
  =item * C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item * C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... }; >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
   package Record;
  
   use Digest::MD5 qw(md5_hex);
  
   use Moo;
   use namespace::clean;
  
   has name => (is => 'ro', required => 1);
   has id => (is => 'lazy');
   sub _build_id {
     my ($self) = @_;
     return md5_hex($self->name);
   }
  
   1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> Older versions of L<namespace::autoclean> would
  inflate Moo classes to full L<Moose> classes, losing the benefits of Moo.  If
  you want to use L<namespace::autoclean> with a Moo class, make sure you are
  using version 0.16 or newer.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, L<Type::Tiny> can provide types, type libraries, and
  will work seamlessly with both L<Moo> and L<Moose>.  L<Type::Tiny> can be
  considered the successor to L<MooseX::Types> and provides a similar API, so
  that you can write
  
    use Types::Standard;
    has days_to_live => (is => 'ro', isa => Int);
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you need
  L<Moose> - Moo is small because it explicitly does not provide a metaprotocol.
  However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and
  L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  C<BUILDARGS> is not triggered if your class does not have any attributes.
  Without attributes, C<BUILDARGS> return value would be ignored, so we just
  skip calling the method instead.
  
  Handling of warnings: when you C<use Moo> we enable strict and warnings, in a
  similar way to Moose. The authors recommend the use of C<strictures>, which
  enables FATAL warnings, and several extra pragmas when used in development:
  L<indirect>, L<multidimensional>, and L<bareword::filehandles>.
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
      package MyClass;
      use Moo;
      use strictures 2;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
      package MyClass;
  
      use Moose;
      use MooseX::NonMoose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
      __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  bubaflub - Bob Kuo (cpan:BUBAFLUB) <bubaflub@cpan.org>
  
  ether = Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2015 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  use Moo::_strictures;
  no warnings 'once';
  use Moo::_Utils;
  use Sub::Quote qw(quotify);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    die "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', do { no warnings 'once'; keys %Moo::MAKERS };
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
    @Moo::HandleMoose::FakeMeta::ISA = 'Moose::Meta::Method::Meta';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $am_class, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, 0, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, 1, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, 0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    foreach my $spec (values %$attr_specs) {
      if (my $inflators = delete $spec->{moosify}) {
        $_->($spec) for @$inflators;
      }
    }
  
    my %methods
      = %{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};
  
    # if stuff gets added afterwards, _maybe_reset_handlemoose should
    # trigger the recreation of the metaclass but we need to ensure the
    # Moo::Role cache is cleared so we don't confuse Moo itself.
    if (my $info = $Moo::Role::INFO{$name}) {
      delete $info->{methods};
    }
  
    # needed to ensure the method body is stable and get things named
    Sub::Defer::undefer_sub($_) for grep defined, values %methods;
    my @attrs;
    {
      # This local is completely not required for roles but harmless
      local @{_getstash($name)}{keys %methods};
      my %seen_name;
      foreach my $name (@$attr_order) {
        $seen_name{$name} = 1;
        my %spec = %{$attr_specs->{$name}};
        my %spec_map = (
          map { $_->name => $_->init_arg||$_->name }
          (
            (grep { $_->has_init_arg }
               $meta->attribute_metaclass->meta->get_all_attributes),
            grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
            map {
              my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                           ->meta;
              map $meta->get_attribute($_), $meta->get_attribute_list
            }  @{$spec{traits}||[]}
          )
        );
        # have to hard code this because Moose's role meta-model is lacking
        $spec_map{traits} ||= 'traits';
  
        $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
        my $coerce = $spec{coerce};
        if (my $isa = $spec{isa}) {
          my $tc = $spec{isa} = do {
            if (my $mapped = $TYPE_MAP{$isa}) {
              my $type = $mapped->();
              unless ( Scalar::Util::blessed($type)
                  && $type->isa("Moose::Meta::TypeConstraint") ) {
                die "error inflating attribute '$name' for package '$_[0]': "
                  ."\$TYPE_MAP{$isa} did not return a valid type constraint'";
              }
              $coerce ? $type->create_child_type(name => $type->name) : $type;
            } else {
              Moose::Meta::TypeConstraint->new(
                constraint => sub { eval { &$isa; 1 } }
              );
            }
          };
          if ($coerce) {
            $tc->coercion(Moose::Meta::TypeCoercion->new)
               ->_compiled_type_coercion($coerce);
            $spec{coerce} = 1;
          }
        } elsif ($coerce) {
          my $attr = quotify($name);
          my $tc = Moose::Meta::TypeConstraint->new(
                     constraint => sub { die "This is not going to work" },
                     inlined => sub {
                        'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                     },
                   );
          $tc->coercion(Moose::Meta::TypeCoercion->new)
             ->_compiled_type_coercion($coerce);
          $spec{isa} = $tc;
          $spec{coerce} = 1;
        }
        %spec =
          map { $spec_map{$_} => $spec{$_} }
          grep { exists $spec_map{$_} }
          keys %spec;
        push @attrs, $meta->add_attribute($name => %spec);
      }
      foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
        foreach my $attr ($mouse->get_all_attributes) {
          my %spec = %{$attr};
          delete @spec{qw(
            associated_class associated_methods __METACLASS__
            provides curries
          )};
          my $name = delete $spec{name};
          next if $seen_name{$name}++;
          push @attrs, $meta->add_attribute($name => %spec);
        }
      }
    }
    foreach my $meth_name (keys %methods) {
      my $meth_code = $methods{$meth_name};
      $meta->add_method($meth_name, $meth_code) if $meth_code;
    }
  
    if ($am_role) {
      my $info = $Moo::Role::INFO{$name};
      $meta->add_required_methods(@{$info->{requires}});
      foreach my $modifier (@{$info->{modifiers}}) {
        my ($type, @args) = @$modifier;
        my $code = pop @args;
        $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
      }
    }
    elsif ($am_class) {
      foreach my $attr (@attrs) {
        foreach my $method (@{$attr->associated_methods}) {
          $method->{body} = $name->can($method->name);
        }
      }
      bless(
        $meta->find_method_by_name('new'),
        'Moo::HandleMoose::FakeConstructor',
      );
      my $meta_meth;
      if (
        $meta_meth = $meta->find_method_by_name('meta')
        and $meta_meth->body == \&Moo::Object::meta
      ) {
        bless($meta_meth, 'Moo::HandleMoose::FakeMeta');
      }
      # a combination of Moo and Moose may bypass a Moo constructor but still
      # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
      # global destruction.
      require Method::Generate::DemolishAll;
    }
    $meta->add_role(Class::MOP::class_of($_))
      for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
        do { no warnings 'once'; keys %{$Moo::Role::APPLIED_TO{$name}} };
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  use Moo::_strictures;
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    my $self = shift;
    die "Can't call $meth without object instance"
      if !ref $self;
    die "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)
  }
  sub can {
    my $self = shift;
    return $self->SUPER::can(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)
  }
  sub isa {
    my $self = shift;
    return $self->SUPER::isa(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use Moo::_strictures;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  use Config;
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)[A-Z]+\(0x([0-9a-zA-Z]+)\)$/) {
      my $id = do { no warnings 'portable'; hex "$1" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  if ($Config{useithreads}) {
    my @types = %TYPE_MAP;
    tie %TYPE_MAP, __PACKAGE__;
    %TYPE_MAP = @types;
  }
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use Moo::_strictures;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    my $proto = $class->BUILDARGS(@_);
    $NO_BUILD{$class} and
      return bless({}, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({}, $class)
      : bless({}, $class)->BUILDALL($proto);
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    return !!0
      unless ($INC{'Moose/Role.pm'} || $INC{'Role/Tiny.pm'});
    require Moo::Role;
    my $does = Moo::Role->can("does_role");
    { no warnings 'redefine'; *does = $does }
    goto &$does;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use Moo::_strictures;
  use Moo::_Utils;
  use Role::Tiny ();
  our @ISA = qw(Role::Tiny);
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  Moo::sification->import;
  
  BEGIN {
      *INFO = \%Role::Tiny::INFO;
      *APPLIED_TO = \%Role::Tiny::APPLIED_TO;
      *ON_ROLE_CREATE = \@Role::Tiny::ON_ROLE_CREATE;
  }
  
  our %INFO;
  our %APPLIED_TO;
  our %APPLY_DEFAULTS;
  our @ON_ROLE_CREATE;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my ($me) = @_;
  
    _set_loaded(caller);
    strict->import;
    warnings->import;
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      die "Cannot import Moo::Role into a Moo class";
    }
    $INFO{$target} ||= {};
    # get symbol table reference
    my $stash = _getstash($target);
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    *{_getglob("${target}::meta")} = $me->can('meta');
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later) with a map to the coderefs in case of copying or re-use
    my @not_methods = ('', map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
  
    $_->($target)
      for @ON_ROLE_CREATE;
  }
  
  push @ON_ROLE_CREATE, sub {
    my $target = shift;
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  };
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    _load_module($role);
    $self->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $self->is_role($role);
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub is_role {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    $self->SUPER::is_role($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    my $meta;
    if (!$self->SUPER::is_role($role)
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
  
            $spec->{isa} = sub {
              &$check or die "Type constraint failed for $_[0]"
            };
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      require Class::Method::Modifiers if @$mods;
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      die "${role} is not a Moo::Role" unless $me->is_role($role);
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    _load_module($role);
    $me->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $me->is_role($role);
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
        _load_module($role);
        $me->_inhale_if_moose($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      *{_getglob("${new_name}::ISA")} = [ $superclass ];
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->apply_roles_to_package($new_name, @roles);
      _set_loaded($new_name, (caller)[1]);
      return $new_name;
    }
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Moo::Role" unless $me->is_role($role);
    }
  
    $Moo::MAKERS{$new_name} = {is_class => 1};
  
    $me->_handle_constructor($new_name, $_) for @roles;
  
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    _set_loaded(ref $new, (caller)[1]);
  
    my $apply_defaults = $APPLY_DEFAULTS{ref $new} ||= do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for(ref $new)
          and my $m = Moo->_accessor_maker_for(ref $new)) {
        require Sub::Quote;
  
        my $specs = $con_gen->all_attribute_specs;
  
        my $assign = "{no warnings 'void';\n";
        my %captures;
        foreach my $name ( keys %attrs ) {
          my $spec = $specs->{$name};
          if ($m->has_eager_default($name, $spec)) {
            my ($has, $has_cap)
              = $m->generate_simple_has('$_[0]', $name, $spec);
            my ($code, $pop_cap)
              = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
            $assign .= $code . ";\n";
            @captures{keys %$has_cap, keys %$pop_cap}
              = (values %$has_cap, values %$pop_cap);
          }
        }
        $assign .= "}";
        Sub::Quote::quote_sub($assign, \%captures);
      }
      else {
        sub {};
      }
    };
    $new->$apply_defaults;
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $Role::Tiny::COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _install_does {
      my ($me, $to) = @_;
  
      # If Role::Tiny actually installed the DOES, give it a name
      my $new = $me->SUPER::_install_does($to) or return;
      return _name_coderef("${to}::DOES", $new);
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    return 1
      if Role::Tiny::does_role($proto, $role);
    my $meta;
    if ($INC{'Moose.pm'}
        and $meta = Class::MOP::class_of($proto)
        and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
        and $meta->can('does_role')
    ) {
      return $meta->does_role($role);
    }
    return 0;
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    my $info = $INFO{$to};
    my $con = $INC{"Moo.pm"} && Moo->_constructor_maker_for($to);
    my %existing
      = $info ? @{$info->{attributes} || []}
      : $con  ? %{$con->all_attribute_specs || {}}
      : ();
  
    my @attr_info =
      map { @{$attr_info}[$_, $_+1] }
      grep { ! $existing{$attr_info->[$_]} }
      map { 2 * $_ } 0..@$attr_info/2-1;
  
    if ($info) {
      push @{$info->{attributes}||=[]}, @attr_info;
    }
    elsif ($con) {
      # shallow copy of the specs since the constructor will assign an index
      $con->register_attribute_specs(map ref() ? { %$_ } : $_, @attr_info);
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
   use strictures 2;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  And elsewhere:
  
   package Some::Class;
  
   use Moo;
   use strictures 2;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
   package My::Role::ID;
  
   use Digest::MD5 qw(md5_hex);
   use Moo::Role;
   use Digest::SHA qw(sha1_hex);
  
   requires 'name';
  
   sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
   sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
   1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  
  no warnings 'once'; # guard against -w
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use constant lt_5_8_3 => ( $] < 5.008003 or $ENV{MOO_TEST_PRE_583} ) ? 1 : 0;
  use constant can_haz_subutil => (
      $INC{"Sub/Util.pm"}
      || ( !$INC{"Sub/Name.pm"} && eval { require Sub::Util } )
    ) && defined &Sub::Util::set_subname;
  use constant can_haz_subname => (
      $INC{"Sub/Name.pm"}
      || ( !$INC{"Sub/Util.pm"} && eval { require Sub::Name } )
    ) && defined &Sub::Name::subname;
  
  use Moo::_strictures;
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use Exporter qw(import);
  use Moo::_mro;
  use Config;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa _getstash _install_coderef _name_coderef
      _unimport_coderefs _in_global_destruction _set_loaded
  );
  
  sub _in_global_destruction ();
  *_in_global_destruction = \&Devel::GlobalDestruction::in_global_destruction;
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      require Sub::Defer;
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  sub _load_module {
    my $module = $_[0];
    my $file = module_notional_filename($module);
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    die $error;
  }
  
  sub _maybe_load_module {
    my $module = $_[0];
    return $MAYBE_LOADED{$module}
      if exists $MAYBE_LOADED{$module};
    if(! eval { use_package_optimistically($module) }) {
      warn "$module exists but failed to load with error: $@";
    }
    elsif ( $INC{module_notional_filename($module)} ) {
      return $MAYBE_LOADED{$module} = 1;
    }
    return $MAYBE_LOADED{$module} = 0;
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _get_linear_isa {
    return mro::get_linear_isa($_[0]);
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    can_haz_subutil ? Sub::Util::set_subname(@_) :
      can_haz_subname ? Sub::Name::subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  use Moo::_strictures;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;
  use strict;
  use warnings;
  
  sub import {
    if ($ENV{MOO_FATAL_WARNINGS}) {
      require strictures;
      strictures->VERSION(2);
      @_ = ('strictures');
      goto &strictures::import;
    }
    else {
      strict->import;
      warnings->import;
    }
  }
  
  1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use Moo::_strictures;
  no warnings 'once';
  use Devel::GlobalDestruction qw(in_global_destruction);
  
  sub unimport {
    die "Can't disable Moo::sification after inflation has been done"
      if $Moo::HandleMoose::SETUP_DONE;
    our $disabled = 1;
  }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disabled or in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  sub import {
    return
      if our $setup_done;
    if ($INC{"Moose.pm"}) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    } else {
      $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
    }
    $setup_done = 1;
  }
  
  1;
MOO_SIFICATION

$fatpacked{"MooX/late.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOX_LATE';
  use 5.008;
  use strict;
  use warnings;
  
  package MooX::late;
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.015';
  
  use Moo              qw( );
  use Carp             qw( carp croak );
  use Scalar::Util     qw( blessed );
  use Module::Runtime  qw( is_module_name );
  
  BEGIN {
  	package MooX::late::DefinitionContext;
  	our $AUTHORITY = 'cpan:TOBYINK';
  	our $VERSION   = '0.015';
  	
  	use Moo;
  	use overload (
  		q[""]    => 'to_string',
  		q[bool]  => sub { 1 },
  		fallback => 1,
  	);
  	
  	has package  => (is => 'ro');
  	has filename => (is => 'ro');
  	has line     => (is => 'ro');
  	
  	sub to_string
  	{
  		my $self = shift;
  		sprintf(
  			'%s:%d, package %s',
  			$self->filename,
  			$self->line,
  			$self->package,
  		);
  	}
  	
  	sub new_from_caller
  	{
  		my ($class, $level) = @_;
  		$level = 0 unless defined $level;
  		
  		my ($p, $f, $c) = caller($level + 1);
  		return $class->new(
  			package  => $p,
  			filename => $f,
  			line     => $c,
  		);
  	}
  };
  
  # SUBCLASSING
  # This is a hook for people subclassing MooX::late.
  # It should be easy to tack on your own handlers
  # to the end of the list. A handler is only called
  # if exists($spec{$handler_name}) in the attribute
  # spec.
  # 
  sub _handlers
  {
  	qw( isa does lazy_build traits );
  }
  
  # SUBCLASSING
  # Not really sure why you'd want to override
  # this.
  #
  sub _definition_context_class
  {
  	"MooX::late::DefinitionContext";
  }
  
  sub import
  {
  	my $me = shift;
  	my $caller = caller;
  	
  	my $install_tracked;
  	{
  		no warnings;
  		if ($Moo::MAKERS{$caller})
  		{
  			$install_tracked = \&Moo::_install_tracked;
  		}
  		elsif ($Moo::Role::INFO{$caller})
  		{
  			$install_tracked = \&Moo::Role::_install_tracked;
  		}
  		else
  		{
  			croak "MooX::late applied to a non-Moo package"
  				. "(need: use Moo or use Moo::Role)";
  		}
  	}
  	
  	my $orig = $caller->can('has')  # lolcat
  		or croak "Could not locate 'has' function to alter";
  	
  	my @handlers = $me->_handlers;
  	
  	# SUBCLASSING
  	# MooX::late itself does not provide a
  	# `_finalize_attribute` method. Your subclass
  	# can, in which case it will be called right
  	# before setting up the attribute.
  	# 
  	my $finalize = $me->can("_finalize_attribute");
  	
  	$install_tracked->(
  		$caller, has => sub
  		{
  			my ($proto, %spec) = @_;
  			my $context = $me->_definition_context_class->new_from_caller(0);
  			
  			for my $name (ref $proto ? @$proto : $proto)
  			{
  				my $spec = +{ %spec }; # shallow clone
  				
  				for my $option (@handlers)
  				{
  					next unless exists $spec->{$option};
  					my $handler = $me->can("_handle_$option");
  					
  					# SUBCLASSING
  					# Note that handlers are called as methods, and
  					# get passed:
  					# 1. the attribute name
  					# 2. the attribute spec (hashref, modifiable)
  					# 3. a context object
  					# 4. the name of the caller class/role
  					#
  					$me->$handler($name, $spec, $context, $caller);
  				}
  				
  				$me->$finalize($name, $spec, $context, $caller) if $finalize;
  				$orig->($name, %$spec);
  			}
  			return;
  		},
  	);
  	
  	$me->_install_sugar($caller, $install_tracked);
  }
  
  # SUBCLASSING
  # This can be used to install additional functions
  # into the caller package.
  #
  sub _install_sugar
  {
  	my $me = shift;
  	my ($caller, $installer) = @_;
  	$installer->($caller, blessed => \&Scalar::Util::blessed);
  	$installer->($caller, confess => \&Carp::confess);
  }
  
  sub _handle_isa
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	return if ref $spec->{isa};
  	
  	require Type::Utils;
  	$spec->{isa} = Type::Utils::dwim_type($spec->{isa}, for => $class);
  	
  	return;
  }
  
  sub _handle_does
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	return unless defined $spec->{does};
  	
  	require Types::Standard;
  	$spec->{isa} = Types::Standard::ConsumerOf()->of($spec->{does});
  	
  	return;
  }
  
  sub _handle_lazy_build
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	return unless delete $spec->{lazy_build};
  	
  	$spec->{is}      ||= "ro";
  	$spec->{lazy}    ||= 1;
  	$spec->{builder} ||= "_build_$name";
  	
  	if ($name =~ /^_/)
  	{
  		$spec->{clearer}   ||= "_clear$name";
  		$spec->{predicate} ||= "_has$name";
  	}
  	else
  	{
  		$spec->{clearer}   ||= "clear_$name";
  		$spec->{predicate} ||= "has_$name";
  	}
  	
  	return;
  }
  
  sub _handle_traits
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	my @new;
  	foreach my $trait (@{ $spec->{traits} || [] })
  	{
  		my $handler = $me->can("_handletrait_$trait");
  		croak "$me cannot process trait $trait" unless $handler;
  		
  		# SUBCLASSING
  		# There is a second level of handlers for traits.
  		# Just add a method called "_handletrait_Foo"
  		# and it will be called to handle the trait "Foo".
  		# These handlers should normally return the empty
  		# list, but may return a list of strings to add to
  		# a *new* traits arrayref.
  		#
  		push @new, $me->$handler(@_);
  	}
  	
  	$spec->{traits} = \@new;
  	
  	if ($spec->{handles_via})
  	{
  		eval "require MooX::HandlesVia"
  			or croak("Requires MooX::HandlesVia for attribute trait defined at $context");
  		
  		my ($name, %spec) = MooX::HandlesVia::process_has($name, %$spec);
  		%$spec = %spec;
  	}
  	
  	return;
  }
  
  sub _handletrait_Array
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Collection::Array::MooseLike";
  	
  	return;
  }
  
  sub _handletrait_Hash
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Collection::Hash::MooseLike";
  	
  	return;
  }
  
  sub _handletrait_Code
  {
  	my $me = shift;
  	my ($name, $spec, $context, $class) = @_;
  	
  	$spec->{handles_via} = "Data::Perl::Code";
  	
  	# Special handling for execute_method!
  	while (my ($k, $v) = each %{ $spec->{handles} })
  	{
  		next unless $v eq q(execute_method);
  		
  		# MooX::HandlesVia can't handle this right yet.
  		delete $spec->{handles}{$k};
  		
  		# ... so we handle it ourselves.
  		eval qq{
  			package ${class};
  			sub ${k} {
  				my \$self = shift;
  				return \$self->${name}->(\$self, \@_);
  			}
  		};
  	}
  	
  	return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf8
  
  =for stopwords superset MooX
  
  =head1 NAME
  
  MooX::late - easily translate Moose code to Moo
  
  =head1 SYNOPSIS
  
     package Foo;
     use Moo;
     use MooX::late;
     has bar => (is => "ro", isa => "Str", default => "MacLaren's Pub");
  
  (Examples for Moo roles in section below.)
  
  =head1 DESCRIPTION
  
  L<Moo> is a light-weight object oriented programming framework which aims
  to be compatible with L<Moose>. It does this by detecting when Moose has
  been loaded, and automatically "inflating" its classes and roles to full
  Moose classes and roles. This way, Moo classes can consume Moose roles,
  Moose classes can extend Moo classes, and so forth.
  
  However, the surface syntax of Moo differs somewhat from Moose. For example
  the C<isa> option when defining attributes in Moose must be either a string
  or a blessed L<Moose::Meta::TypeConstraint> object; but in Moo must be a
  coderef. These differences in surface syntax make porting code from Moose to
  Moo potentially tricky. L<MooX::late> provides some assistance by enabling a
  slightly more Moosey surface syntax.
  
  MooX::late does the following:
  
  =over
  
  =item 1.
  
  Supports C<< isa => $stringytype >>.
  
  =item 2.
  
  Supports C<< does => $rolename >> .
  
  =item 3.
  
  Supports C<< lazy_build => 1 >>.
  
  =item 4.
  
  Exports C<blessed> and C<confess> functions to your namespace.
  
  =item 5.
  
  Handles certain attribute traits. Currently C<Hash>, C<Array> and C<Code>
  are supported. This feature requires L<MooX::HandlesVia>. 
  
  C<String>, C<Number>, C<Counter> and C<Bool> are unlikely to ever be
  supported because of internal implementation details of Moo. If you need
  another attribute trait to be supported, let me know and I will consider
  it.
  
  =back
  
  Five features. It is not the aim of C<MooX::late> to make every aspect of
  Moo behave exactly identically to Moose. It's just going after the low-hanging
  fruit. So it does five things right now, and I promise that future versions
  will never do more than seven.
  
  Previous releases of MooX::late added support for C<< coerce => 1 >> and
  C<< default => $nonref >>. These features have now been added to Moo itself,
  so MooX::late no longer has to deal with them.
  
  =head2 Use in Moo::Roles
  
  MooX::late should work in Moo::Roles, with no particular caveats.
  
     package MyRole;
     use Moo::Role;
     use MooX::late;
  
  L<Package::Variant> can be used to build the Moo equivalent of
  parameterized roles. MooX::late should work in roles built with
  Package::Variant.
  
     use Package::Variant
        importing => [ qw( Moo::Role MooX::late ) ],
        subs      => [ qw( has with ) ];
  
  =head2 Type constraints
  
  Type constraint strings are interpreted using L<Type::Parser>, using the
  type constraints defined in L<Types::Standard>. This provides a very slight
  superset of Moose's type constraint syntax and built-in type constraints.
  
  Any unrecognized string that looks like it might be a class name is
  interpreted as a class type constraint.
  
  =head2 Subclassing
  
  MooX::late is designed to be reasonably easy to subclass. There are comments
  in the source code explaining hooks for extensibility.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=MooX-late>.
  
  =head1 SEE ALSO
  
  C<MooX::late> uses L<Types::Standard> to check type constraints.
  
  C<MooX::late> uses L<MooX::HandlesVia> to provide native attribute traits
  support.
  
  The following modules bring additional Moose functionality to Moo:
  
  =over
  
  =item *
  
  L<MooX::Override> - support override/super
  
  =item *
  
  L<MooX::Augment> - support augment/inner
  
  =back
  
  L<MooX> allows you to load Moo plus multiple MooX extension modules in a
  single line.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2012-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MOOX_LATE

$fatpacked{"Number/Bytes/Human.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_BYTES_HUMAN';
  package Number::Bytes::Human;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.09';
  
  require Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(format_bytes parse_bytes);
  
  require POSIX;
  use Carp qw(croak carp);
  
  #my $DEFAULT_BLOCK = 1024;
  #my $DEFAULT_ZERO = '0';
  #my $DEFAULT_ROUND_STYLE = 'ceil';
  my %DEFAULT_SUFFIXES = (
    1024 => ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'],
    1000 => ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'],
    1024000 => ['', 'M', 'T', 'E', 'Y'],
    si_1024 => ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],
    si_1000 => ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
  );
  my @DEFAULT_PREFIXES = @{$DEFAULT_SUFFIXES{1024}};
  
  sub _default_suffixes {
    my $set = shift || 1024;
    if (exists $DEFAULT_SUFFIXES{$set}) {
      return @{$DEFAULT_SUFFIXES{$set}} if wantarray;
      return [ @{$DEFAULT_SUFFIXES{$set}} ];
    }
    croak "unknown suffix set '$set'";
  }
  
  my %ROUND_FUNCTIONS = (
    ceil => sub { return POSIX::ceil($_[0] * (10 ** $_[1])) / 10**$_[1]; },
    floor => sub { return POSIX::floor($_[0] * (10 ** $_[1])) / 10**$_[1]; },
    round => sub { return sprintf( "%." . ( $_[1] || 0 ) . "f", $_[0] ); },
    trunc => sub { return sprintf( "%d", $_[0] * (10 ** $_[1])) / 10**$_[1]; },
    # what about 'ceiling'?
  );
  
  sub _round_function {
    my $style = shift;
    if (exists $ROUND_FUNCTIONS{$style}) {
      return $ROUND_FUNCTIONS{$style}
    }
    croak "unknown round style '$style'";
  }
  
  # options
  #   block | block_size | base | bs => 1024 | 1000
  #   base_1024 | block_1024 | 1024 => $true
  #   base_1000 | block_1000 | 1000 => $true
  #
  #   round_function => \&
  #   round_style => 'ceiling', 'round', 'floor', 'trunc'
  #
  #   suffixes => 1024 | 1000 | si_1024 | si_1000 | 1024000 | \@
  #   si => 1
  #   unit => string (eg., 'B' | 'bps' | 'b')
  #
  #   zero => '0' (default) | '-' | '0%S' | undef
  #
  #
  #   supress_point_zero | no_point_zero =>
  #   b_to_i => 1
  #   to_s => \&
  #
  #   allow_minus => 0 | 1
  #   too_large => string
  #   quiet => 1 (supresses "too large number" warning)
  
  
  
  #  PROBABLY CRAP:
  #   precision => integer
  
  # parsed options
  #   BLOCK => 1024 | 1000
  #   ROUND_STYLE => 'ceil', 'round', 'floor', 'trunc'
  #   ROUND_FUNCTION => \&
  #   SUFFIXES => \@
  #   ZERO =>
  #   SI => undef | 1			Parse SI compatible
  
  
  =begin private
  
    $options = _parse_args($seed, $args)
    $options = _parse_args($seed, arg1 => $val1, ...)
  
  $seed is undef or a hashref
  $args is a hashref
  
  =end private
  
  =cut
  
  sub _parse_args {
    my $seed = shift;
    my %args;
  
    my %options;
    unless (defined $seed) { # use defaults
      $options{BLOCK} = 1024;
      $options{ROUND_STYLE} = 'ceil';
      $options{ROUND_FUNCTION} = _round_function($options{ROUND_STYLE});
      $options{ZERO} = '0';
      $options{SI} = undef;
      $options{PRECISION} = 1;
      $options{PRECISION_CUTOFF} = 1;
      #$options{SUFFIXES} = # deferred to the last minute when we know BLOCK, seek [**]
      $options{UNIT} = undef;
    }
    # else { %options = %$seed } # this is set if @_!=0, down below
  
    if (@_==0) { # quick return for default values (no customized args)
      return (defined $seed) ? $seed : \%options;
    } elsif (@_==1 && ref $_[0]) { # \%args
      %args = %{$_[0]};
    } else { # arg1 => $val1, arg2 => $val2
      %args = @_;
    }
  
    # this is done here so this assignment/copy doesn't happen if @_==0
    %options = %$seed unless %options;
  
  # block | block_size | base | bs => 1024 | 1000
  # block_1024 | base_1024 | 1024 => $true
  # block_1000 | base_1000 | 1024 => $true
    if ($args{block} ||
        $args{block_size} ||
        $args{base} ||
        $args{bs}
      ) {
      my $block = $args{block} ||
                  $args{block_size} ||
                  $args{base} ||
                  $args{bs};
      unless ($block==1000 || $block==1024 || $block==1_024_000) {
        croak "invalid base: $block (should be 1024, 1000 or 1024000)";
      }
      $options{BLOCK} = $block;
  
    } elsif ($args{block_1024} ||
             $args{base_1024}  ||
             $args{1024}) {
  
      $options{BLOCK} = 1024;
    } elsif ($args{block_1000} ||
             $args{base_1000}  ||
             $args{1000}) {
  
      $options{BLOCK} = 1000;
    }
  
  # round_function => \&
  # round_style => 'ceil' | 'floor' | 'round' | 'trunc'
    if ($args{round_function}) {
      unless (ref $args{round_function} eq 'CODE') {
        croak "round function ($args{round_function}) should be a code ref";
      }
      $options{ROUND_FUNCTION} = $args{round_function};
      $options{ROUND_STYLE} = $args{round_style} || 'unknown';
    } elsif ($args{round_style}) {
      $options{ROUND_FUNCTION} = _round_function($args{round_style});
      $options{ROUND_STYLE} = $args{round_style};
    }
  
  # SI compatibility (mostly for parsing)
    if ($args{si}) {
      $options{SI} = 1;
    }
  
  # suffixes => 1024 | 1000 | si_1024 | si_1000 | 1024000 | \@
    if ($args{suffixes}) {
      if (ref $args{suffixes} eq 'ARRAY') {
        $options{SUFFIXES} = $args{suffixes};
      } elsif ($args{suffixes} =~ /^(si_)?(1000|1024)$/) {
        $options{SUFFIXES} = _default_suffixes($args{suffixes});
      } else {
        croak "suffixes ($args{suffixes}) should be 1024, 1000, si_1024, si_1000, 1024000 or an array ref";
      }
    }
    if (defined $args{unit}) {
      $options{UNIT} = $args{unit};
    }
  
  # zero => undef | string
    if (exists $args{zero}) {
      $options{ZERO} = $args{zero};
      if (defined $options{ZERO}) {
        $options{ZERO} =~ s/%S/$options{SUFFIXES}->[0]/g
      }
    }
  
  # precision => <integer>
    if (exists $args{precision} and $args{precision} =~ /\A\d+\z/) {
      $options{PRECISION} = $args{precision};
    }
  
  # precision_cutoff => <intenger>
    if (exists $args{precision_cutoff} and ($args{precision_cutoff} =~ /\A\d+\z/ or $args{precision_cutoff} = '-1')) {
      $options{PRECISION_CUTOFF} = $args{precision_cutoff};
    }
  
  # quiet => 1
    if ($args{quiet}) {
      $options{QUIET} = 1;
    }
  
    if (defined $seed) {
      %$seed = %options;
      return $seed;
    }
    return \%options
  }
  
  # NOTE. _format_bytes() SHOULD not change $options - NEVER.
  
  sub _format_bytes {
    my $bytes = shift;
    return undef unless defined $bytes;
    my $options = shift;
    my %options = %$options;
  
    local *human_round = $options{ROUND_FUNCTION};
  
    return $options{ZERO} if ($bytes==0 && defined $options{ZERO});
  
    my $block = $options{BLOCK};
  
    # if a suffix set was not specified, pick a default [**]
    my @suffixes = $options{SUFFIXES} ? @{$options{SUFFIXES}} : _default_suffixes( ($options{SI} ? 'si_' : '') . $block);
  
    # WHAT ABOUT NEGATIVE NUMBERS: -1K ?
    my $sign = '';
    if ($bytes<0) {
       $bytes = -$bytes;
       $sign = '-';
    }
  
    my $suffix = $suffixes[0];
    my $x = $bytes;
    my $magnitude = 0;
    if($bytes >= $block) {
    #  return "$sign$bytes" if $bytes<$block;
      do {
        $x /= $block;
        $magnitude++;
      } while ( human_round($x, $options{PRECISION}) >= $block );
      if($magnitude >= (0 + @suffixes)) {
        carp "number too large (>= $block**$magnitude)" unless ($options{QUIET});
      }
      $suffix = $suffixes[$magnitude];
    }
    #$x = human_round( $x, $options{PRECISION} );
  
    $x = _precision_cutoff($x, $options);
    #reasses encase the precision_cutoff caused the value to cross the block size
    if($x >= $block) {
      $x /= $block;
      $magnitude++;
      if($magnitude >= (0 + @suffixes)) {
        carp "number too large (>= $block**$magnitude)" unless ($options{QUIET});
      }
      $suffix = $suffixes[$magnitude];
      $x = _precision_cutoff($x, $options);
    }
  
    my $unit = $options{UNIT} || '';
  
    return $sign . $x . $suffix . $unit;
  
  }
  
  sub _precision_cutoff {
   my $bytes   = shift;
   my $options = shift;
   my %options = %$options;
   if ( $options{PRECISION_CUTOFF} != -1 and ( length( sprintf( "%d", $bytes ) ) > $options{PRECISION_CUTOFF} ) ) {
     $bytes = sprintf( "%d", human_round( $bytes, 0 ) );
   } else {
     $bytes = sprintf( "%." . $options{PRECISION} . "f", human_round( $bytes, $options{PRECISION} ) );
   }
   return $bytes;
  }
  
  sub _parse_bytes {
    my $human = shift;
    my $options = shift;
    my %options = %$options;
  
    return 0 if( exists $options{ZERO} && ((!defined $options{ZERO} && !defined $human) || (defined $human && $human eq $options{ZERO})) );
    return undef unless defined $human;
  
    my %suffix_mult;
    my %suffix_block;
    my $m;
  
    if( $options{SUFFIXES} ) {
      $m = 1;
      foreach my $s (@{$options{SUFFIXES}}) {
        $suffix_mult{$s} = $m;
        $suffix_block{$s} = $options{BLOCK};
        $m *= $suffix_block{$s};
      }
    } else {
      if( !defined $options{SI} || $options{SI} == 1 ) {
        # If SI compatibility has been set BLOCK is ignored as it is infered from the unit
        $m = 1;
        foreach my $s (@{$DEFAULT_SUFFIXES{si_1000}}) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = 1000;
          $m *= $suffix_block{$s};
        }
      
        $m = 1;
        foreach my $s (@{$DEFAULT_SUFFIXES{si_1024}}) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = 1024;
          $m *= $suffix_block{$s};
        }
      }
  
      # The regular suffixes are only taken into account in default mode without specifically asking for SI compliance
      if( !defined $options{SI} ) {
        $m = 1;
        foreach my $s (_default_suffixes( $options{BLOCK} )) {
          $suffix_mult{$s} = $m;
          $suffix_block{$s} = $options{BLOCK};
          $m *= $suffix_block{$s};
        }
      }
    }
  
    my ($sign, $int, $frac, $unit) = ($human =~ /^\s*(-?)\s*(\d*)(?:\.(\d*))?\s*(\D*)$/);
  
    $frac ||= 0;
  
  #  print STDERR "S: $sign I: $int F: $frac U: $unit\n";
  
  
    my $mult;
    my $block;
    my $u = $options{UNIT} || '';
    foreach my $s (keys %suffix_block) {
      if( $unit =~ /^${s}${u}$/i ) {
        $mult = ($sign eq '-' ? -1 : 1) * $suffix_mult{$s};
        $block = $suffix_block{$s};
        last;
      }
    }
  
    if( !defined $mult ) {
      carp "Could not parse human readable byte value '$human'";
  use Data::Dumper;
  print STDERR Dumper( %suffix_block );
      return undef;
    }
  
    my $bytes = int( ($int + ($frac / $block)) * $mult );
  
    return $bytes;
  }
  
  
  # convert byte count (file size) to human readable format
  sub format_bytes {
    my $bytes = shift;
    my $options = _parse_args(undef, @_);
    #use YAML; print Dump $options;
    return _format_bytes($bytes, $options);
  }
  
  # convert human readable format to byte count (file size)
  sub parse_bytes {
    my $human = shift;
    my $options = _parse_args(undef, @_);
    #use YAML; print Dump $options;
    return _parse_bytes($human, $options);
  }
  
  ### the OO way
  
  # new()
  sub new {
    my $proto = shift;
    my $class = ref $proto || $proto;
    my $opts = _parse_args(undef, @_);
    return bless $opts, $class;
  }
  
  # set_options()
  sub set_options {
    my $self = shift;
    return $self->_parse_args(@_);
  }
  
  # format()
  sub format {
    my $self = shift;
    my $bytes = shift;
    return _format_bytes($bytes, $self);
  }
  
  # parse()
  sub parse {
    my $self = shift;
    my $human = shift;
    return _parse_bytes($human, $self);
  }
  
  # the solution by COG in Filesys::DiskUsage
  # convert size to human readable format
  #sub _convert {
  #  defined (my $size = shift) || return undef;
  #  my $config = {@_};
  #  $config->{human} || return $size;
  #  my $block = $config->{'Human-readable'} ? 1000 : 1024;
  #  my @args = qw/B K M G/;
  #
  #  while (@args && $size > $block) {
  #    shift @args;
  #    $size /= $block;
  #  }
  #
  #  if ($config->{'truncate-readable'} > 0) {
  #    $size = sprintf("%.$config->{'truncate-readable'}f",$size);
  #  }
  #
  #  "$size$args[0]";
  #}
  #
  # not exact: 1024 => 1024B instead of 1K
  # not nicely formatted => 1.00 instead of 1K
  
  1;
  
  __END__
  
  =head1 NAME
  
  Number::Bytes::Human - Convert byte count to human readable format
  
  =head1 SYNOPSIS
  
    use Number::Bytes::Human qw(format_bytes parse_bytes);
    $size = format_bytes(0); # '0'
    $size = format_bytes(2*1024); # '2.0K'
  
    $size = format_bytes(1_234_890, bs => 1000); # '1.3M'
    $size = format_bytes(1E9, bs => 1000); # '1.0G'
  
    my $bytes = parse_bytes('1.0K');   # 1024
    my $bytes = parse_bytes('1.0KB');  # 1000, SI unit
    my $bytes = parse_bytes('1.0KiB'); # 1024, SI unit
  
    # the OO way
    $human = Number::Bytes::Human->new(bs => 1000, si => 1);
    $size = $human->format(1E7); # '10MB'
  
    $bytes = $human->parse('10MB');   # 10*1000*1000
    $bytes = $human->parse('10MiB');  # 10*1024*1024
    $bytes = $human->parse('10M');    # Error, no SI unit
  
    $human->set_options(zero => '-');
    $size = $human->format(0);    # '-'
    $bytes = $human->parse('-');  # 0
  
    $human = Number::Bytes::Human->new(bs => 1000, round_style => 'round', precision => 2);
    $size = $human->format(10240000); # '10.24MB'
  
  =head1 DESCRIPTION
  
  THIS IS ALPHA SOFTWARE: THE DOCUMENTATION AND THE CODE WILL SUFFER
  CHANGES SOME DAY (THANKS, GOD!).
  
  This module provides a formatter which turns byte counts
  to usual readable format, like '2.0K', '3.1G', '100B'.
  It was inspired in the C<-h> option of Unix
  utilities like C<du>, C<df> and C<ls> for "human-readable" output.
  
  From the FreeBSD man page of C<df>: http://www.freebsd.org/cgi/man.cgi?query=df
  
    "Human-readable" output.  Use unit suffixes: Byte, Kilobyte,
    Megabyte, Gigabyte, Terabyte and Petabyte in order to reduce the
    number of digits to four or fewer using base 2 for sizes.
  
    byte      B
    kilobyte  K = 2**10 B = 1024 B
    megabyte  M = 2**20 B = 1024 * 1024 B
    gigabyte  G = 2**30 B = 1024 * 1024 * 1024 B
    terabyte  T = 2**40 B = 1024 * 1024 * 1024 * 1024 B
  
    petabyte  P = 2**50 B = 1024 * 1024 * 1024 * 1024 * 1024 B
    exabyte   E = 2**60 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
    zettabyte Z = 2**70 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
    yottabyte Y = 2**80 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
  
  I have found this link to be quite useful:
  
    http://www.t1shopper.com/tools/calculate/
  
  If you feel like a hard-drive manufacturer, you can start
  counting bytes by powers of 1000 (instead of the generous 1024).
  Just use C<< bs => 1000 >>.
  
  But if you are a floppy disk manufacturer and want to start
  counting in units of 1024000 (for your "1.44 MB" disks)?
  Then use C<< bs => 1_024_000 >>.
  
  If you feel like a purist academic, you can force the use of
  metric prefixes
  according to the Dec 1998 standard by the IEC. Never mind the units for base 1000
  are C<('B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB')> and,
  even worse, the ones for base 1024 are
  C<('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB')>
  with the horrible names: bytes, kibibytes, mebibytes, etc.
  All you have to do is to use C<< si => 1 >>. Ain't that beautiful
  the SI system? Read about it:
  
    http://physics.nist.gov/cuu/Units/binary.html
  
  You can try a pure Perl C<"ls -lh">-inspired command with the one-liner, er, two-liner:
  
    $ perl -MNumber::Bytes::Human=format_bytes \
           -e 'printf "%5s %s\n", format_bytes(-s), $_ for @ARGV' *
  
  Why to write such a module? Because if people can write such things
  in C, it can be written much easier in Perl and then reused,
  refactored, abused. And then, when it is much improved, some
  brave soul can port it back to C (if only for the warm feeling
  of painful programming).
  
  It is also possible to parse human readable formatted bytes. The 
  automatic format detection recognizes SI units with the blocksizes
  of 1000 and 1024 respectively and additionally the customary K / M / G etc. with
  blocksize 1024. When si => 1 is added to the options only SI units
  are recognized. Explicitly specifying a blocksize changes it
  for all detected units.
  
  =head2 OBJECTS
  
  An alternative to the functional style of this module
  is the OO fashion. This is useful for avoiding the
  unnecessary parsing of the arguments over and over
  if you have to format lots of numbers
  
  
    for (@sizes) {
      my $fmt_size = format_bytes($_, @args);
      ...
    }
  
  versus
  
    my $human = Number::Format::Bytes->new(@args);
    for (@sizes) {
      my $fmt_size = $human->format($_);
      ...
    }
  
  for TODO
  [TODO] MAKE IT JUST A MATTER OF STYLE: memoize _parse_args()
  $seed == undef
  
  =head2 FUNCTIONS
  
  =over 4
  
  =item B<format_bytes>
  
    $h_size = format_bytes($size, @options);
  
  Turns a byte count (like 1230) to a readable format like '1.3K'.
  You have a bunch of options to play with. See the section
  L</"OPTIONS"> to know the details.
  
  =item B<parse_bytes>
  
    $size = parse_bytes($h_size, @options);
  
  Turns a human readable byte count into a number of the equivalent bytes.
  
  =back
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
    $h = Number::Bytes::Human->new(@options);
  
  The constructor. For details on the arguments, see the section
  L</"OPTIONS">.
  
  =item B<format>
  
    $h_size = $h->format($size);
  
  Turns a byte count (like 1230) to a readable format like '1.3K'.
  The statements
  
    $h = Number::Bytes::Human->new(@options);
    $h_size = $h->format($size);
  
  are equivalent to C<$h_size = format_bytes($size, @options)>,
  with only one pass for the option arguments.
  
  =item B<parse>
  
    $size = $h->parse($h_size)
  
  Turns a human readable byte count into the number of bytes.
  The statements
  
    $h = Number::Bytes::Human->new(@options);
    $size = $h->format($h_size);
  
  are equivalent to C<$size = parse_bytes($h_size, @options)>,
  with only one pass for the option arguments.
  
  =item B<set_options>
  
    $h->set_options(@options);
  
  To alter the options of a C<Number::Bytes::Human> object.
  See L</"OPTIONS">.
  
  =back
  
  =head2 OPTIONS
  
  =over 4
  
  =item BASE
  
    block | base | block_size | bs => 1000 | 1024 | 1024000
    base_1024 | block_1024 | 1024 => 1
    base_1000 | block_1000 | 1000 => 1
  
  The base to be used: 1024 (default), 1000 or 1024000.
  
  Any other value throws an exception.
  
  =item SUFFIXES
  
    suffixes => 1000 | 1024 | 1024000 | si_1000 | si_1024 | $arrayref
  
  By default, the used suffixes stand for '', 'K', 'M', ...
  for base 1024 and '', 'k', 'M', ... for base 1000
  (which are indeed the usual metric prefixes with implied unit
  as bytes, 'B'). For the weird 1024000 base, suffixes are
  '', 'M', 'T', etc.
  
  =item ZERO
  
    zero => string | undef
  
  The string C<0> maps to ('0' by default). If C<undef>, the general case is used.
  The string may contain '%S' in which case the suffix for byte is used.
  
    format_bytes(0, zero => '-') => '-'
  
  =item METRIC SYSTEM
  
    si => 1
  
  =item ROUND
  
    round_function => $coderef
    round_style => 'ceil' | 'floor' | 'round' | 'trunc'
  
  =item TO_S
  
  =item QUIET
  
    quiet => 1
  
  Suppresses the warnings emitted. Currently, the only case is
  when the number is large than C<$base**(@suffixes+1)>.
  
  =item PRECISION
  
    precision => <integer>
  
  default = 1
  sets the precicion of digits, only apropreacte for round_style 'round' or if you
  want to accept it in as the second parameter to your custome round_function.
  
  =item PRECISION_CUTOFF
  
    precision_cutoff => <integer>
  
  default = 1
  when the number of digits exceeds this number causes the precision to be cutoff
  (was default behaviour in 0.07 and below)
  
  =back
  
  =head2 EXPORT
  
  It is alright to import C<format_bytes> and C<parse_bytes>, but nothing is exported by default.
  
  =head1 DIAGNOSTICS
  
    "unknown round style '$style'";
  
    "invalid base: $block (should be 1024, 1000 or 1024000)";
  
    "round function ($args{round_function}) should be a code ref";
  
    "suffixes ($args{suffixes}) should be 1000, 1024, 1024000 or an array ref";
  
    "negative numbers are not allowed" (??)
  
  =head1 TO DO
  
  A function C<parse_bytes>
  
    parse_bytes($str, $options)
  
  which transforms '1k' to 1000, '1K' to 1024, '1MB' to 1E6,
  '1M' to 1024*1024, etc. (like gnu du).
  
    $str =~ /^\s*(\d*\.?\d*)\s*(\S+)/ # $num $suffix
  
  =head1 SEE ALSO
  
  F<lib/human.c> and F<lib/human.h> in GNU coreutils.
  
  The C<_convert()> solution by COG in Filesys::DiskUsage.
  
  =head1 BUGS
  
  Please report bugs via CPAN RT L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Number-Bytes-Human>
  or L<mailto://bug-Number-Bytes-Human@rt.cpan.org>. I will not be able to close the bug
  as BestPractical ignore my claims that I cannot log in, but I will answer anyway.
  
  =head1 AUTHOR
  
  Adriano R. Ferreira, E<lt>ferreira@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2005-2007 by Adriano R. Ferreira
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
NUMBER_BYTES_HUMAN

$fatpacked{"Number/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_COMPARE';
  package Number::Compare;
  use strict;
  use Carp qw(croak);
  use vars qw/$VERSION/;
  $VERSION = '0.03';
  
  sub new  {
      my $referent = shift;
      my $class = ref $referent || $referent;
      my $expr = $class->parse_to_perl( shift );
  
      bless eval "sub { \$_[0] $expr }", $class;
  }
  
  sub parse_to_perl {
      shift;
      my $test = shift;
  
      $test =~ m{^
                 ([<>]=?)?   # comparison
                 (.*?)       # value
                 ([kmg]i?)?  # magnitude
                $}ix
         or croak "don't understand '$test' as a test";
  
      my $comparison = $1 || '==';
      my $target     = $2;
      my $magnitude  = $3 || '';
      $target *=           1000 if lc $magnitude eq 'k';
      $target *=           1024 if lc $magnitude eq 'ki';
      $target *=        1000000 if lc $magnitude eq 'm';
      $target *=      1024*1024 if lc $magnitude eq 'mi';
      $target *=     1000000000 if lc $magnitude eq 'g';
      $target *= 1024*1024*1024 if lc $magnitude eq 'gi';
  
      return "$comparison $target";
  }
  
  sub test { $_[0]->( $_[1] ) }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Number::Compare - numeric comparisons
  
  =head1 SYNOPSIS
  
   Number::Compare->new(">1Ki")->test(1025); # is 1025 > 1024
  
   my $c = Number::Compare->new(">1M");
   $c->(1_200_000);                          # slightly terser invocation
  
  =head1 DESCRIPTION
  
  Number::Compare compiles a simple comparison to an anonymous
  subroutine, which you can call with a value to be tested again.
  
  Now this would be very pointless, if Number::Compare didn't understand
  magnitudes.
  
  The target value may use magnitudes of kilobytes (C<k>, C<ki>),
  megabytes (C<m>, C<mi>), or gigabytes (C<g>, C<gi>).  Those suffixed
  with an C<i> use the appropriate 2**n version in accordance with the
  IEC standard: http://physics.nist.gov/cuu/Units/binary.html
  
  =head1 METHODS
  
  =head2 ->new( $test )
  
  Returns a new object that compares the specified test.
  
  =head2 ->test( $value )
  
  A longhanded version of $compare->( $value ).  Predates blessed
  subroutine reference implementation.
  
  =head2 ->parse_to_perl( $test )
  
  Returns a perl code fragment equivalent to the test.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002,2011 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  http://physics.nist.gov/cuu/Units/binary.html
  
  =cut
NUMBER_COMPARE

$fatpacked{"Ouch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OUCH';
  use strict;
  use warnings;
  package Ouch;
  $Ouch::VERSION = '0.0409';
  use Carp qw(longmess shortmess);
  use parent 'Exporter';
  use overload bool => sub {1}, q{""} => 'scalar', fallback => 1;
  use Scalar::Util qw(blessed);
  
  our @EXPORT = qw(bleep ouch kiss hug barf);
  our @EXPORT_OK = qw(try throw catch catch_all caught caught_all);
  our %EXPORT_TAGS = ( traditional => [qw(try throw catch catch_all)], trytiny => [qw( throw caught caught_all )] );
  
  sub new {
    my ($class, $code, $message, $data) = @_;
    bless {code => $code, message => $message, data => $data, shortmess => shortmess($message), trace => longmess($message) }, $class;
  }
  
  sub try (&) {
    my $try = shift;
    eval { $try->() };
    return $@;
  }
  
  sub ouch {
    my ($code, $message, $data) = @_;
    my $self = __PACKAGE__->new($code, $message, $data);
    die $self;
  }
  
  sub throw {  # alias
    ouch @_;
  }
  
  sub kiss {
    my ($code, $e) = @_;
    $e ||= $@;
    if (blessed $e && $e->isa('Ouch') && $e->code eq $code) {
      return 1;
    }
    return 0;
  }
  
  sub catch {
    kiss @_;
  }
  
  sub caught {
    kiss @_;
  }
  
  sub hug {
    my ($e) = @_;
    $e ||= $@;
    return $@ ? 1 : 0;
  }
  
  sub catch_all {
    hug @_;
  }
  
  sub caught_all {
    hug @_;
  }
  
  sub bleep {
    my ($e) = @_;
    $e ||= $@;
    if (blessed $e && $e->isa('Ouch')) {
      return $e->message;
    }
    else {
      my $message = $@;
      if ($message =~ m{^(.*)\s+at\s.*line\s\d+.}xms) {
          return $1;
      }
      else {
          return $message;
      }
    }
  }
  
  sub barf {
      my ($e) = @_;
      my $code;
      $e ||= $@;
      if (blessed $e && $e->isa('Ouch')) {
          $code = $e->code;
      } 
      else {
          $code = 1;
      }
  
      print STDERR bleep($e)."\n";
      exit $code;
  }
  
  sub scalar {
    my $self = shift;
    return $self->{shortmess};
  }
  
  sub trace {
    my $self = shift;
    return $self->{trace};
  }
  
  sub hashref {
    my $self = shift;
    return {
      code    => $self->{code},
      message => $self->{message},
      data    => $self->{data},
    };
  }
  
  sub code {
    my $self = shift;
    return $self->{code};
  }
  
  sub message {
    my $self = shift;
    return $self->{message};
  }
  
  sub data {
    my $self = shift;
    return $self->{data};
  }
  
  =head1 NAME
  
  Ouch - Exceptions that don't hurt.
  
  =head1 VERSION
  
  version 0.0409
  
  =head1 SYNOPSIS
  
   use Ouch;
  
   eval { ouch(404, 'File not found.'); };
  
   if (kiss 404) {
     check_elsewhere();
   }
  
   say $@;           # These two lines do the
   say $@->scalar;   # same thing.
  
  =head1 DESCRIPTION
  
  Ouch provides a class for exception handling that doesn't require a lot of boilerplate, nor any up front definition. If L<Exception::Class>
  is working for you, great! But if you want something that is faster, easier to use, requires less typing, and has no prereqs, but still gives 
  you much of that same functionality, then Ouch is for you.
  
  =head2 Why another exception handling module?
  
  It really comes down to L<Carp> isn't enough for me, and L<Exception::Class> does what I want but makes me type way too much. Also, I tend to work on a lot of protocol-based systems that use error codes (HTTP, FTP, SMTP, JSON-RPC) rather than error classes, so that feels more natural to me. Consider the difference between these:
  
  B<Ouch>
  
   use Ouch;
   ouch 404, 'File not found.', 'file';
  
  B<Exception::Class>
  
   use Exception::Class (
      'FileNotFound' => {
          fields  => [ 'code', 'field' ],
      },
   );
   FileNotFound->throw( error => 'File not found.', code => 404, field => 'file' );
  
  And if you want to catch the exception you're looking at:
  
  B<Ouch>
  
   if (kiss 404) {
     # do something
   }
  
  B<Exception::Class>
  
   my $e;
   if ($e = Exception::Class->caught('FileNotFound')) {
     # do something
   }
  
  Those differences may not seem like a lot, but over any substantial program with lots of exceptions it can become a big deal. 
  
  =head2 Usage
  
  Most of the time, all you need to do is:
  
   ouch $code, $message, $data;
   ouch -32700, 'Parse error.', $request; # JSON-RPC 2.0 error
   ouch 441, 'You need to specify an email address.', 'email'; # form processing error
   ouch 'missing_param', 'You need to specify an email address.', 'email';
  
  You can also go long form if you prefer:
  
   die Ouch->new($code, $message, $data);
  
  If you want to rethrow an Ouch, you can simply C<die> it.
  
   eval { ouch(404, 'File not found.'); } ;
   die $@;
  
  =head2 Functional Interface
  
  =head3 ouch
  
  Some nice sugar instead of using the object oriented interface.
  
   ouch 2121, 'Did not do the big thing.';
  
  =over
  
  =item code
  
  An error code. An integer or string representing error type. Try to stick to codes used in whatever domain you happen to be working in. HTTP Status codes. JSON-RPC error codes, etc.
  
  =item message
  
  A human readable error message.
  
  =item data
  
  Optional. Anything you want to attach to the exception to help a developer catching it decide what to do. For example, if you're doing form processing, you might want this to be the name of the field that caused the exception. 
  
  B<WARNING:> Do not include objects or code refs in your data. This should only be stuff that is easily serializable like scalars, array refs, and hash refs.
  
  =back
  
  =head3 kiss
  
  Some nice sugar to trap an Ouch.
  
   if (kiss $code) {
      # make it go
   }
  
  =over
  
  =item code
  
  The code you're looking for.
  
  =item exception
  
  Optional. If you like you can pass the exception into C<kiss>. If not, it will just use whatever is in C<$@>. You might want to do this if you've saved the exception before running another C<eval>, for example.
  
  =back
  
  
  =head3 hug
  
  Some nice sugar to trap any exception.
  
   if (hug) {
     # make it stop
   }
  
  =over 
  
  =item exception
  
  Optional. If you like you can pass the exception into C<hug>. If not, it will just use whatever is in C<$@>.
  
  =back
  
  
  =head3 bleep 
  
  A little sugar to make exceptions human friendly. Returns a clean error message from any exception, including an Ouch.
  
   File not found.
  
  Rather than:
  
   File not found. at /Some/File.pm line 63.
  
  =over
  
  =item exception
  
  Optional. If you like you can pass the exception into C<bleep>. If not, it will just use whatever is in C<$@>.
  
  =back
  
  =head3 barf
  
  Calls C<bleep>, and then exits with error code
  
  =over
  
  =item exception
  
  Optional. You can pass an exception into C<barf> which then gets passed to C<bleep> otherwise it will use whatever's in C<$@>
  
  =back
  
  
  =head2 Object-Oriented Interface
  
  =head3 new
  
  Constructor for the object-oriented interface. Takes the same parameters as C<ouch>.
  
   Ouch->new($code, $message, $data);
  
  =head3 scalar
  
  Returns the scalar form of the error message:
  
   Crap! at /Some/File.pm line 43.
  
  Just as if you had done:
  
   die 'Crap!';
  
  Rather than:
  
   ouch $code, 'Crap!'; 
  
  =head3 trace
  
  Call this if you want the full stack trace that lead up to the ouch.
  
  =head3 hashref
  
  Returns a formatted hash reference of the exception, which can be useful for handing off to a serializer like L<JSON>.
  
   {
     code     => $code,
     message  => $message,
     data     => $data,
   }
  
  =head3 code
  
  Returns the C<code> passed into the constructor.
  
  =head3 message
  
  Returns the C<messsage> passed into the constructor.
  
  =head3 data
  
  Returns the C<data> passed into the constructor.
  
  =head2 Try::Tiny
  
  Many Ouch users like to use Ouch with L<Try::Tiny>.
  
   use Try::Tiny;
   use Ouch;
  
   try {
      ouch 404, 'File not found!';
   }
   catch {
      if (kiss(401, $_)) {
          # do something
      }
      else {
          die $_; # rethrow
      }
   };
  
  Some users are sticks in the mud who can't bring themselves to C<ouch> and C<kiss>. For them, there is the C<:trytiny> interface. Here's how it works:
  
   use Try::Tiny;
   use Ouch qw(:trytiny);
  
   try {
      throw(404, 'File not found!';
   }
   catch {
      if (caught(401, $_)) {
          # do something
      }
      else {
          die $_; # rethrow
      }
   };
  
  =head3 throw
  
  See C<ouch> for details.
  
  =head3 caught
  
  See C<kiss> for details.
  
  =head3 caught_all
  
  See C<hug> for details.
  
  =head1 DEPRECATED
  
  This functionality is deprecated and will be removed in a future release. Use Try::Tiny instead.
  
  =head2 Traditional Interface
  
  Some people just can't bring themselves to use the sugary cuteness of Ouch. For them there is the C<:traditional> interface. Here's how it works:
  
   use Ouch qw(:traditional);
  
   my $e = try {
     throw 404, 'File not found.';
   };
  
   if ( catch 404, $e ) {
     # do the big thing
   }
   elsif ( catch_all $e ) {
     # make it stop
   }
   else {
     # make it go
   }
  
  B<NOTE:> C<try> also populates C<$@>, and C<catch> and C<catch_all> will also use C<$@> if you don't specify an exception.
  
  =head3 try
  
  Returns an exception. Is basically just a nice wrapper around C<eval>.
  
  =over
  
  =item block
  
  Try accepts a code ref, anonymous subroutine, or a block. 
  
  B<NOTE:> You need a semi-colon at the end of a C<try> block.
  
  =back
  
  =head3 throw
  
  Works exactly like C<ouch>. See C<ouch> for details.
  
  =head3 catch
  
  Works exactly like C<kiss>. See C<kiss> for details.
  
  =head3 catch_all
  
  Works exactly like C<hug>. See C<hug> for details.
  
  
  =head1 REQUIREMENTS
  
  Requires Perl 5.12 or higher.
  
  
  
  =head1 SUPPORT
  
  =over
  
  =item Repository
  
  L<http://github.com/rizen/Ouch>
  
  =item Bug Reports
  
  L<http://github.com/rizen/Ouch/issues>
  
  =back
  
  
  =head1 SEE ALSO
  
  If you're looking for something lighter, check out L<Carp> that ships with Perl. Or if you're looking for something heavier check out L<Exception::Class>.
  
  =head1 AUTHOR
  
  JT Smith <jt_at_plainblack_dot_com>
  
  =head1 LEGAL
  
  Ouch is Copyright 2011 Plain Black Corporation (L<http://www.plainblack.com>) and is licensed under the same terms as Perl itself.
  
  =cut
  
  1;
OUCH

$fatpacked{"Params/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_CHECK';
  package Params::Check;
  
  use strict;
  
  use Carp                        qw[carp croak];
  use Locale::Maketext::Simple    Style => 'gettext';
  
  BEGIN {
      use Exporter    ();
      use vars        qw[ @ISA $VERSION @EXPORT_OK $VERBOSE $ALLOW_UNKNOWN
                          $STRICT_TYPE $STRIP_LEADING_DASHES $NO_DUPLICATES
                          $PRESERVE_CASE $ONLY_ALLOW_DEFINED $WARNINGS_FATAL
                          $SANITY_CHECK_TEMPLATE $CALLER_DEPTH $_ERROR_STRING
                      ];
  
      @ISA        =   qw[ Exporter ];
      @EXPORT_OK  =   qw[check allow last_error];
  
      $VERSION                = '0.38';
      $VERBOSE                = $^W ? 1 : 0;
      $NO_DUPLICATES          = 0;
      $STRIP_LEADING_DASHES   = 0;
      $STRICT_TYPE            = 0;
      $ALLOW_UNKNOWN          = 0;
      $PRESERVE_CASE          = 0;
      $ONLY_ALLOW_DEFINED     = 0;
      $SANITY_CHECK_TEMPLATE  = 1;
      $WARNINGS_FATAL         = 0;
      $CALLER_DEPTH           = 0;
  }
  
  my %known_keys = map { $_ => 1 }
                      qw| required allow default strict_type no_override
                          store defined |;
  
  =pod
  
  =head1 NAME
  
  Params::Check - A generic input parsing/checking mechanism.
  
  =head1 SYNOPSIS
  
      use Params::Check qw[check allow last_error];
  
      sub fill_personal_info {
          my %hash = @_;
          my $x;
  
          my $tmpl = {
              firstname   => { required   => 1, defined => 1 },
              lastname    => { required   => 1, store => \$x },
              gender      => { required   => 1,
                               allow      => [qr/M/i, qr/F/i],
                             },
              married     => { allow      => [0,1] },
              age         => { default    => 21,
                               allow      => qr/^\d+$/,
                             },
  
              phone       => { allow => [ sub { return 1 if /$valid_re/ },
                                          '1-800-PERL' ]
                             },
              id_list     => { default        => [],
                               strict_type    => 1
                             },
              employer    => { default => 'NSA', no_override => 1 },
          };
  
          ### check() returns a hashref of parsed args on success ###
          my $parsed_args = check( $tmpl, \%hash, $VERBOSE )
                              or die qw[Could not parse arguments!];
  
          ... other code here ...
      }
  
      my $ok = allow( $colour, [qw|blue green yellow|] );
  
      my $error = Params::Check::last_error();
  
  
  =head1 DESCRIPTION
  
  Params::Check is a generic input parsing/checking mechanism.
  
  It allows you to validate input via a template. The only requirement
  is that the arguments must be named.
  
  Params::Check can do the following things for you:
  
  =over 4
  
  =item *
  
  Convert all keys to lowercase
  
  =item *
  
  Check if all required arguments have been provided
  
  =item *
  
  Set arguments that have not been provided to the default
  
  =item *
  
  Weed out arguments that are not supported and warn about them to the
  user
  
  =item *
  
  Validate the arguments given by the user based on strings, regexes,
  lists or even subroutines
  
  =item *
  
  Enforce type integrity if required
  
  =back
  
  Most of Params::Check's power comes from its template, which we'll
  discuss below:
  
  =head1 Template
  
  As you can see in the synopsis, based on your template, the arguments
  provided will be validated.
  
  The template can take a different set of rules per key that is used.
  
  The following rules are available:
  
  =over 4
  
  =item default
  
  This is the default value if none was provided by the user.
  This is also the type C<strict_type> will look at when checking type
  integrity (see below).
  
  =item required
  
  A boolean flag that indicates if this argument was a required
  argument. If marked as required and not provided, check() will fail.
  
  =item strict_type
  
  This does a C<ref()> check on the argument provided. The C<ref> of the
  argument must be the same as the C<ref> of the default value for this
  check to pass.
  
  This is very useful if you insist on taking an array reference as
  argument for example.
  
  =item defined
  
  If this template key is true, enforces that if this key is provided by
  user input, its value is C<defined>. This just means that the user is
  not allowed to pass C<undef> as a value for this key and is equivalent
  to:
      allow => sub { defined $_[0] && OTHER TESTS }
  
  =item no_override
  
  This allows you to specify C<constants> in your template. ie, they
  keys that are not allowed to be altered by the user. It pretty much
  allows you to keep all your C<configurable> data in one place; the
  C<Params::Check> template.
  
  =item store
  
  This allows you to pass a reference to a scalar, in which the data
  will be stored:
  
      my $x;
      my $args = check(foo => { default => 1, store => \$x }, $input);
  
  This is basically shorthand for saying:
  
      my $args = check( { foo => { default => 1 }, $input );
      my $x    = $args->{foo};
  
  You can alter the global variable $Params::Check::NO_DUPLICATES to
  control whether the C<store>'d key will still be present in your
  result set. See the L<Global Variables> section below.
  
  =item allow
  
  A set of criteria used to validate a particular piece of data if it
  has to adhere to particular rules.
  
  See the C<allow()> function for details.
  
  =back
  
  =head1 Functions
  
  =head2 check( \%tmpl, \%args, [$verbose] );
  
  This function is not exported by default, so you'll have to ask for it
  via:
  
      use Params::Check qw[check];
  
  or use its fully qualified name instead.
  
  C<check> takes a list of arguments, as follows:
  
  =over 4
  
  =item Template
  
  This is a hash reference which contains a template as explained in the
  C<SYNOPSIS> and C<Template> section.
  
  =item Arguments
  
  This is a reference to a hash of named arguments which need checking.
  
  =item Verbose
  
  A boolean to indicate whether C<check> should be verbose and warn
  about what went wrong in a check or not.
  
  You can enable this program wide by setting the package variable
  C<$Params::Check::VERBOSE> to a true value. For details, see the
  section on C<Global Variables> below.
  
  =back
  
  C<check> will return when it fails, or a hashref with lowercase
  keys of parsed arguments when it succeeds.
  
  So a typical call to check would look like this:
  
      my $parsed = check( \%template, \%arguments, $VERBOSE )
                      or warn q[Arguments could not be parsed!];
  
  A lot of the behaviour of C<check()> can be altered by setting
  package variables. See the section on C<Global Variables> for details
  on this.
  
  =cut
  
  sub check {
      my ($utmpl, $href, $verbose) = @_;
  
      ### clear the current error string ###
      _clear_error();
  
      ### did we get the arguments we need? ###
      if ( !$utmpl or !$href ) {
        _store_error(loc('check() expects two arguments'));
        return unless $WARNINGS_FATAL;
        croak(__PACKAGE__->last_error);
      }
  
      ### sensible defaults ###
      $verbose ||= $VERBOSE || 0;
  
      ### XXX what type of template is it? ###
      ### { key => { } } ?
      #if (ref $args eq 'HASH') {
      #    1;
      #}
  
      ### clean up the template ###
      my $args;
  
      ### don't even bother to loop, if there's nothing to clean up ###
      if( $PRESERVE_CASE and !$STRIP_LEADING_DASHES ) {
          $args = $href;
      } else {
          ### keys are not aliased ###
          for my $key (keys %$href) {
              my $org = $key;
              $key = lc $key unless $PRESERVE_CASE;
              $key =~ s/^-// if $STRIP_LEADING_DASHES;
              $args->{$key} = $href->{$org};
          }
      }
  
      my %defs;
  
      ### which template entries have a 'store' member
      my @want_store;
  
      ### sanity check + defaults + required keys set? ###
      my $fail;
      for my $key (keys %$utmpl) {
          my $tmpl = $utmpl->{$key};
  
          ### check if required keys are provided
          ### keys are now lower cased, unless preserve case was enabled
          ### at which point, the utmpl keys must match, but that's the users
          ### problem.
          if( $tmpl->{'required'} and not exists $args->{$key} ) {
              _store_error(
                  loc(q|Required option '%1' is not provided for %2 by %3|,
                      $key, _who_was_it(), _who_was_it(1)), $verbose );
  
              ### mark the error ###
              $fail++;
              next;
          }
  
          ### next, set the default, make sure the key exists in %defs ###
          $defs{$key} = $tmpl->{'default'}
                          if exists $tmpl->{'default'};
  
          if( $SANITY_CHECK_TEMPLATE ) {
              ### last, check if they provided any weird template keys
              ### -- do this last so we don't always execute this code.
              ### just a small optimization.
              map {   _store_error(
                          loc(q|Template type '%1' not supported [at key '%2']|,
                          $_, $key), 1, 0 );
              } grep {
                  not $known_keys{$_}
              } keys %$tmpl;
  
              ### make sure you passed a ref, otherwise, complain about it!
              if ( exists $tmpl->{'store'} ) {
                  _store_error( loc(
                      q|Store variable for '%1' is not a reference!|, $key
                  ), 1, 0 ) unless ref $tmpl->{'store'};
              }
          }
  
          push @want_store, $key if $tmpl->{'store'};
      }
  
      ### errors found ###
      return if $fail;
  
      ### flag to see if anything went wrong ###
      my $wrong;
  
      ### flag to see if we warned for anything, needed for warnings_fatal
      my $warned;
  
      for my $key (keys %$args) {
          my $arg = $args->{$key};
  
          ### you gave us this key, but it's not in the template ###
          unless( $utmpl->{$key} ) {
  
              ### but we'll allow it anyway ###
              if( $ALLOW_UNKNOWN ) {
                  $defs{$key} = $arg;
  
              ### warn about the error ###
              } else {
                  _store_error(
                      loc("Key '%1' is not a valid key for %2 provided by %3",
                          $key, _who_was_it(), _who_was_it(1)), $verbose);
                  $warned ||= 1;
              }
              next;
          }
  
          ### copy of this keys template instructions, to save derefs ###
          my %tmpl = %{$utmpl->{$key}};
  
          ### check if you're even allowed to override this key ###
          if( $tmpl{'no_override'} ) {
              _store_error(
                  loc(q[You are not allowed to override key '%1'].
                      q[for %2 from %3], $key, _who_was_it(), _who_was_it(1)),
                  $verbose
              );
              $warned ||= 1;
              next;
          }
  
          ### check if you were supposed to provide defined() values ###
          if( ($tmpl{'defined'} || $ONLY_ALLOW_DEFINED) and not defined $arg ) {
              _store_error(loc(q|Key '%1' must be defined when passed|, $key),
                  $verbose );
              $wrong ||= 1;
              next;
          }
  
          ### check if they should be of a strict type, and if it is ###
          if( ($tmpl{'strict_type'} || $STRICT_TYPE) and
              (ref $arg ne ref $tmpl{'default'})
          ) {
              _store_error(loc(q|Key '%1' needs to be of type '%2'|,
                          $key, ref $tmpl{'default'} || 'SCALAR'), $verbose );
              $wrong ||= 1;
              next;
          }
  
          ### check if we have an allow handler, to validate against ###
          ### allow() will report its own errors ###
          if( exists $tmpl{'allow'} and not do {
                  local $_ERROR_STRING;
                  allow( $arg, $tmpl{'allow'} )
              }
          ) {
              ### stringify the value in the error report -- we don't want dumps
              ### of objects, but we do want to see *roughly* what we passed
              _store_error(loc(q|Key '%1' (%2) is of invalid type for '%3' |.
                               q|provided by %4|,
                              $key, "$arg", _who_was_it(),
                              _who_was_it(1)), $verbose);
              $wrong ||= 1;
              next;
          }
  
          ### we got here, then all must be OK ###
          $defs{$key} = $arg;
  
      }
  
      ### croak with the collected errors if there were errors and
      ### we have the fatal flag toggled.
      croak(__PACKAGE__->last_error) if ($wrong || $warned) && $WARNINGS_FATAL;
  
      ### done with our loop... if $wrong is set, something went wrong
      ### and the user is already informed, just return...
      return if $wrong;
  
      ### check if we need to store any of the keys ###
      ### can't do it before, because something may go wrong later,
      ### leaving the user with a few set variables
      for my $key (@want_store) {
          next unless exists $defs{$key};
          my $ref = $utmpl->{$key}{'store'};
          $$ref = $NO_DUPLICATES ? delete $defs{$key} : $defs{$key};
      }
  
      return \%defs;
  }
  
  =head2 allow( $test_me, \@criteria );
  
  The function that handles the C<allow> key in the template is also
  available for independent use.
  
  The function takes as first argument a key to test against, and
  as second argument any form of criteria that are also allowed by
  the C<allow> key in the template.
  
  You can use the following types of values for allow:
  
  =over 4
  
  =item string
  
  The provided argument MUST be equal to the string for the validation
  to pass.
  
  =item regexp
  
  The provided argument MUST match the regular expression for the
  validation to pass.
  
  =item subroutine
  
  The provided subroutine MUST return true in order for the validation
  to pass and the argument accepted.
  
  (This is particularly useful for more complicated data).
  
  =item array ref
  
  The provided argument MUST equal one of the elements of the array
  ref for the validation to pass. An array ref can hold all the above
  values.
  
  =back
  
  It returns true if the key matched the criteria, or false otherwise.
  
  =cut
  
  sub allow {
      ### use $_[0] and $_[1] since this is hot code... ###
      #my ($val, $ref) = @_;
  
      ### it's a regexp ###
      if( ref $_[1] eq 'Regexp' ) {
          local $^W;  # silence warnings if $val is undef #
          return if $_[0] !~ /$_[1]/;
  
      ### it's a sub ###
      } elsif ( ref $_[1] eq 'CODE' ) {
          return unless $_[1]->( $_[0] );
  
      ### it's an array ###
      } elsif ( ref $_[1] eq 'ARRAY' ) {
  
          ### loop over the elements, see if one of them says the
          ### value is OK
          ### also, short-circuit when possible
          for ( @{$_[1]} ) {
              return 1 if allow( $_[0], $_ );
          }
  
          return;
  
      ### fall back to a simple, but safe 'eq' ###
      } else {
          return unless _safe_eq( $_[0], $_[1] );
      }
  
      ### we got here, no failures ###
      return 1;
  }
  
  ### helper functions ###
  
  sub _safe_eq {
      ### only do a straight 'eq' if they're both defined ###
      return defined($_[0]) && defined($_[1])
                  ? $_[0] eq $_[1]
                  : defined($_[0]) eq defined($_[1]);
  }
  
  sub _who_was_it {
      my $level = $_[0] || 0;
  
      return (caller(2 + $CALLER_DEPTH + $level))[3] || 'ANON'
  }
  
  =head2 last_error()
  
  Returns a string containing all warnings and errors reported during
  the last time C<check> was called.
  
  This is useful if you want to report then some other way than
  C<carp>'ing when the verbose flag is on.
  
  It is exported upon request.
  
  =cut
  
  {   $_ERROR_STRING = '';
  
      sub _store_error {
          my($err, $verbose, $offset) = @_[0..2];
          $verbose ||= 0;
          $offset  ||= 0;
          my $level   = 1 + $offset;
  
          local $Carp::CarpLevel = $level;
  
          carp $err if $verbose;
  
          $_ERROR_STRING .= $err . "\n";
      }
  
      sub _clear_error {
          $_ERROR_STRING = '';
      }
  
      sub last_error { $_ERROR_STRING }
  }
  
  1;
  
  =head1 Global Variables
  
  The behaviour of Params::Check can be altered by changing the
  following global variables:
  
  =head2 $Params::Check::VERBOSE
  
  This controls whether Params::Check will issue warnings and
  explanations as to why certain things may have failed.
  If you set it to 0, Params::Check will not output any warnings.
  
  The default is 1 when L<warnings> are enabled, 0 otherwise;
  
  =head2 $Params::Check::STRICT_TYPE
  
  This works like the C<strict_type> option you can pass to C<check>,
  which will turn on C<strict_type> globally for all calls to C<check>.
  
  The default is 0;
  
  =head2 $Params::Check::ALLOW_UNKNOWN
  
  If you set this flag, unknown options will still be present in the
  return value, rather than filtered out. This is useful if your
  subroutine is only interested in a few arguments, and wants to pass
  the rest on blindly to perhaps another subroutine.
  
  The default is 0;
  
  =head2 $Params::Check::STRIP_LEADING_DASHES
  
  If you set this flag, all keys passed in the following manner:
  
      function( -key => 'val' );
  
  will have their leading dashes stripped.
  
  =head2 $Params::Check::NO_DUPLICATES
  
  If set to true, all keys in the template that are marked as to be
  stored in a scalar, will also be removed from the result set.
  
  Default is false, meaning that when you use C<store> as a template
  key, C<check> will put it both in the scalar you supplied, as well as
  in the hashref it returns.
  
  =head2 $Params::Check::PRESERVE_CASE
  
  If set to true, L<Params::Check> will no longer convert all keys from
  the user input to lowercase, but instead expect them to be in the
  case the template provided. This is useful when you want to use
  similar keys with different casing in your templates.
  
  Understand that this removes the case-insensitivity feature of this
  module.
  
  Default is 0;
  
  =head2 $Params::Check::ONLY_ALLOW_DEFINED
  
  If set to true, L<Params::Check> will require all values passed to be
  C<defined>. If you wish to enable this on a 'per key' basis, use the
  template option C<defined> instead.
  
  Default is 0;
  
  =head2 $Params::Check::SANITY_CHECK_TEMPLATE
  
  If set to true, L<Params::Check> will sanity check templates, validating
  for errors and unknown keys. Although very useful for debugging, this
  can be somewhat slow in hot-code and large loops.
  
  To disable this check, set this variable to C<false>.
  
  Default is 1;
  
  =head2 $Params::Check::WARNINGS_FATAL
  
  If set to true, L<Params::Check> will C<croak> when an error during
  template validation occurs, rather than return C<false>.
  
  Default is 0;
  
  =head2 $Params::Check::CALLER_DEPTH
  
  This global modifies the argument given to C<caller()> by
  C<Params::Check::check()> and is useful if you have a custom wrapper
  function around C<Params::Check::check()>. The value must be an
  integer, indicating the number of wrapper functions inserted between
  the real function call and C<Params::Check::check()>.
  
  Example wrapper function, using a custom stacktrace:
  
      sub check {
          my ($template, $args_in) = @_;
  
          local $Params::Check::WARNINGS_FATAL = 1;
          local $Params::Check::CALLER_DEPTH = $Params::Check::CALLER_DEPTH + 1;
          my $args_out = Params::Check::check($template, $args_in);
  
          my_stacktrace(Params::Check::last_error) unless $args_out;
  
          return $args_out;
      }
  
  Default is 0;
  
  =head1 Acknowledgements
  
  Thanks to Richard Soderberg for his performance improvements.
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-params-check@rt.cpan.orgE<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
PARAMS_CHECK

$fatpacked{"Reply/Plugin/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REPLY_PLUGIN_TYPETINY';
  package Reply::Plugin::TypeTiny;
  
  use strict;
  use warnings;
  
  BEGIN {
  	$Reply::Plugin::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Reply::Plugin::TypeTiny::VERSION   = '1.000005';
  };
  
  require Reply::Plugin;
  our @ISA = 'Reply::Plugin';
  
  use Scalar::Util qw(blessed);
  use Term::ANSIColor;
  
  sub mangle_error {
  	my $self  = shift;
  	my ($err) = @_;
  	
  	if (blessed $err and $err->isa("Error::TypeTiny::Assertion"))
  	{
  		my $explain = $err->explain;
  		if ($explain)
  		{
  			print color("cyan");
  			print "Error::TypeTiny::Assertion explain:\n";
  			$self->_explanation($explain, "");
  			local $| = 1;
  			print "\n";
  			print color("reset");
  		}
  	}
  	
  	return @_;
  }
  
  sub _explanation
  {
  	my $self = shift;
  	my ($ex, $indent)  = @_;
  	
  	for my $line (@$ex)
  	{
  		if (ref($line) eq q(ARRAY))
  		{
  			print "$indent * Explain:\n";
  			$self->_explanation($line, "$indent   ");
  		}
  		else
  		{
  			print "$indent * $line\n";
  		}
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Reply::Plugin::TypeTiny - improved type constraint exceptions in Reply
  
  =head1 STATUS
  
  This module is not covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is a small plugin to improve error messages in L<Reply>.
  Not massively tested.
  
  =begin trustme
  
  =item mangle_error
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>, L<Reply>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
REPLY_PLUGIN_TYPETINY

$fatpacked{"SHARYANTO/String/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SHARYANTO_STRING_UTIL';
  package SHARYANTO::String::Util;
  
  use 5.010001;
  use strict;
  use warnings;
  
  our $VERSION = '0.28'; # VERSION
  
  use Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(
                         ltrim
                         rtrim
                         trim
                         ltrim_lines
                         rtrim_lines
                         trim_lines
                         trim_blank_lines
                         ellipsis
                         indent
                         linenum
                         pad
                         qqquote
                         single_quote
                         double_quote
                         common_prefix
                         common_suffix
                 );
  
  sub ltrim {
      my $str = shift;
      $str =~ s/\A\s+//s;
      $str;
  }
  
  sub rtrim {
      my $str = shift;
      $str =~ s/\s+\z//s;
      $str;
  }
  
  sub trim {
      my $str = shift;
      $str =~ s/\A\s+//s;
      $str =~ s/\s+\z//s;
      $str;
  }
  
  sub ltrim_lines {
      my $str = shift;
      $str =~ s/^[ \t]+//mg; # XXX other unicode non-newline spaces
      $str;
  }
  
  sub rtrim_lines {
      my $str = shift;
      $str =~ s/[ \t]+$//mg;
      $str;
  }
  
  sub trim_lines {
      my $str = shift;
      $str =~ s/^[ \t]+//mg;
      $str =~ s/[ \t]+$//mg;
      $str;
  }
  
  sub trim_blank_lines {
      local $_ = shift;
      return $_ unless defined;
      s/\A(?:\n\s*)+//;
      s/(?:\n\s*){2,}\z/\n/;
      $_;
  }
  
  sub ellipsis {
      my ($str, $maxlen, $ellipsis) = @_;
      $maxlen   //= 80;
      $ellipsis //= "...";
  
      if (length($str) <= $maxlen) {
          return $str;
      } else {
          return substr($str, 0, $maxlen-length($ellipsis)) . $ellipsis;
      }
  }
  
  sub indent {
      my ($indent, $str, $opts) = @_;
      $opts //= {};
  
      if ($opts->{indent_blank_lines} // 1) {
          $str =~ s/^/$indent/mg;
      } else {
          $str =~ s/^([^\r\n]*\S[^\r\n]*)/$indent$1/mg;
      }
      $str;
  }
  
  sub linenum {
      my ($str, $opts) = @_;
      $opts //= {};
      $opts->{width}      //= 4;
      $opts->{zeropad}    //= 0;
      $opts->{skip_empty} //= 1;
  
      my $i = 0;
      $str =~ s/^(([\t ]*\S)?.*)/
          sprintf(join("",
                       "%",
                       ($opts->{zeropad} && !($opts->{skip_empty}
                                                  && !defined($2)) ? "0" : ""),
                       $opts->{width}, "s",
                       "|%s"),
                  ++$i && $opts->{skip_empty} && !defined($2) ? "" : $i,
                  $1)/meg;
  
      $str;
  }
  
  sub pad {
      my ($text, $width, $which, $padchar, $is_trunc) = @_;
      if ($which) {
          $which = substr($which, 0, 1);
      } else {
          $which = "r";
      }
      $padchar //= " ";
  
      my $w = length($text);
      if ($is_trunc && $w > $width) {
          $text = substr($text, 0, $width, 1);
      } else {
          if ($which eq 'l') {
              $text = ($padchar x ($width-$w)) . $text;
          } elsif ($which eq 'c') {
              my $n = int(($width-$w)/2);
              $text = ($padchar x $n) . $text . ($padchar x ($width-$w-$n));
          } else {
              $text .= ($padchar x ($width-$w));
          }
      }
      $text;
  }
  
  # BEGIN COPY PASTE FROM Data::Dump
  my %esc = (
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  # put a string value in double quotes
  sub double_quote {
    local($_) = $_[0];
    # If there are many '"' we might want to use qq() instead
    s/([\\\"\@\$])/\\$1/g;
    return qq("$_") unless /[^\040-\176]/;  # fast exit
  
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    # no need for 3 digits in escape for these
    s/([\0-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
    s/([\0-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
    s/([^\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
    return qq("$_");
  }
  # END COPY PASTE FROM Data::Dump
  
  # old name, deprecated, will be removed in the future
  sub qqquote { goto &double_quote; }
  
  # will write this in the future, will produce "qq(...)" and "q(...)" literal
  # representation
  #sub qq_quote {}
  #sub q_quote {}
  
  sub single_quote {
    local($_) = $_[0];
    s/([\\'])/\\$1/g;
    return qq('$_');
  }
  
  sub common_prefix {
      return undef unless @_;
      my $i;
    L1:
      for ($i=0; $i < length($_[0]); $i++) {
          for (@_[1..$#_]) {
              if (length($_) < $i) {
                  $i--; last L1;
              } else {
                  last L1 if substr($_, $i, 1) ne substr($_[0], $i, 1);
              }
          }
      }
      substr($_[0], 0, $i);
  }
  
  sub common_suffix {
      require List::Util;
  
      return undef unless @_;
      my $i;
    L1:
      for ($i = 0; $i < length($_[0]); $i++) {
          for (@_[1..$#_]) {
              if (length($_) < $i) {
                  $i--; last L1;
              } else {
                  last L1 if substr($_, -($i+1), 1) ne substr($_[0], -($i+1), 1);
              }
          }
      }
      $i ? substr($_[0], -$i) : "";
  }
  
  1;
  # ABSTRACT: String utilities
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  SHARYANTO::String::Util - String utilities
  
  =head1 VERSION
  
  This document describes version 0.28 of SHARYANTO::String::Util (from Perl distribution SHARYANTO-String-Util), released on 2014-07-25.
  
  =for Pod::Coverage ^(qqquote)$
  
  =head1 FUNCTIONS
  
  =head2 ltrim($str) => STR
  
  Trim whitespaces (including newlines) at the beginning of string. Equivalent to:
  
   $str =~ s/\A\s+//s;
  
  =head2 ltrim_lines($str) => STR
  
  Trim whitespaces (not including newlines) at the beginning of each line of
  string. Equivalent to:
  
   $str =~ s/^\s+//mg;
  
  =head2 rtrim($str) => STR
  
  Trim whitespaces (including newlines) at the end of string. Equivalent to:
  
   $str =~ s/[ \t]+\z//s;
  
  =head2 rtrim_lines($str) => STR
  
  Trim whitespaces (not including newlines) at the end of each line of
  string. Equivalent to:
  
   $str =~ s/[ \t]+$//mg;
  
  =head2 trim($str) => STR
  
  ltrim + rtrim.
  
  =head2 trim_lines($str) => STR
  
  ltrim_lines + rtrim_lines.
  
  =head2 trim_blank_lines($str) => STR
  
  Trim blank lines at the beginning and the end. Won't trim blank lines in the
  middle. Blank lines include lines with only whitespaces in them.
  
  =head2 ellipsis($str[, $maxlen, $ellipsis]) => STR
  
  Return $str unmodified if $str's length is less than $maxlen (default 80).
  Otherwise cut $str to ($maxlen - length($ellipsis)) and append $ellipsis
  (default '...') at the end.
  
  =head2 indent($indent, $str, \%opts) => STR
  
  Indent every line in $str with $indent. Example:
  
   indent('  ', "one\ntwo\nthree") # "  one\n  two\n  three"
  
  %opts is optional. Known options:
  
  =over 4
  
  =item * indent_blank_lines => BOOL (default 1)
  
  If set to false, does not indent blank lines (i.e., lines containing only zero
  or more whitespaces).
  
  =back
  
  =head2 linenum($str, \%opts) => STR
  
  Add line numbers. For example:
  
       1|line1
       2|line2
        |
       4|line4
  
  Known options:
  
  =over 4
  
  =item * width => INT (default: 4)
  
  =item * zeropad => BOOL (default: 0)
  
  If turned on, will output something like:
  
    0001|line1
    0002|line2
        |
    0004|line4
  
  =item * skip_empty => BOOL (default: 1)
  
  If set to false, keep printing line number even if line is empty:
  
       1|line1
       2|line2
       3|
       4|line4
  
  =back
  
  =head2 pad($text, $width[, $which[, $padchar[, $truncate]]]) => STR
  
  Return C<$text> padded with C<$padchar> to C<$width> columns. C<$which> is
  either "r" or "right" for padding on the right (the default if not specified),
  "l" or "left" for padding on the right, or "c" or "center" or "centre" for
  left+right padding to center the text.
  
  C<$padchar> is whitespace if not specified. It should be string having the width
  of 1 column.
  
  =head2 double_quote($str) => STR
  
  Quote or encode C<$str> to the Perl double quote (C<">) literal representation
  of the string. Example:
  
   say double_quote("a");        # => "a"     (with the quotes)
   say double_quote("a\n");      # => "a\n"
   say double_quote('"');        # => "\""
   say double_quote('$foo');     # => "\$foo"
  
  This code is taken from C<quote()> in L<Data::Dump>. Maybe I didn't look more
  closely, but I couldn't a module that provides a function to do something like
  this. L<String::Escape>, for example, provides C<qqbackslash> but it does not
  escape C<$>.
  
  =head2 single_quote($str) => STR
  
  Like C<double_quote> but will produce a Perl single quote literal representation
  instead of the double quote ones. In single quotes, only literal backslash C<\>
  and single quote character C<'> are escaped, the rest are displayed as-is, so
  the result might span multiple lines or contain other non-printable characters.
  
   say single_quote("Mom's");    # => 'Mom\'s' (with the quotes)
   say single_quote("a\\");      # => 'a\\"
   say single_quote('"');        # => '"'
   say single_quote("\$foo");    # => '$foo'
  
  =head2 common_prefix(@LIST) => STR
  
  Given a list of strings, return common prefix.
  
  =head2 common_suffix(@LIST) => STR
  
  Given a list of strings, return common suffix.
  
  =head1 SEE ALSO
  
  L<SHARYANTO>
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/SHARYANTO-String-Util>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/sharyanto/perl-SHARYANTO-String-Util>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=SHARYANTO-String-Util>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SHARYANTO_STRING_UTIL

$fatpacked{"Sort/Naturally.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SORT_NATURALLY';
  
  require 5;
  package Sort::Naturally;  # Time-stamp: "2004-12-29 18:30:03 AST"
  $VERSION = '1.03';
  @EXPORT = ('nsort', 'ncmp');
  require Exporter;
  @ISA = ('Exporter');
  
  use strict;
  use locale;
  use integer;
  
  #-----------------------------------------------------------------------------
  # constants:
  BEGIN { *DEBUG = sub () {0} unless defined &DEBUG }
  
  use Config ();
  BEGIN {
    # Make a constant such that if a whole-number string is that long
    #  or shorter, we KNOW it's treatable as an integer
    no integer;
    my $x = length(256 ** $Config::Config{'intsize'} / 2) - 1;
    die "Crazy intsize: <$Config::Config{'intsize'}>" if $x < 4;
    eval 'sub MAX_INT_SIZE () {' . $x . '}';
    die $@ if $@;
    print "intsize $Config::Config{'intsize'} => MAX_INT_SIZE $x\n" if DEBUG;
  }
  
  sub X_FIRST () {-1}
  sub Y_FIRST () { 1}
  
  my @ORD = ('same', 'swap', 'asis');
  
  #-----------------------------------------------------------------------------
  # For lack of a preprocessor:
  
  my($code, $guts);
  $guts = <<'EOGUTS';  # This is the guts of both ncmp and nsort:
  
      if($x eq $y) {
        # trap this expensive case first, and then fall thru to tiebreaker
        $rv = 0;
  
      # Convoluted hack to get numerics to sort first, at string start:
      } elsif($x =~ m/^\d/s) {
        if($y =~ m/^\d/s) {
          $rv = 0;    # fall thru to normal comparison for the two numbers
        } else {
          $rv = X_FIRST;
          DEBUG > 1 and print "Numeric-initial $x trumps letter-initial $y\n";
        }
      } elsif($y =~ m/^\d/s) {
        $rv = Y_FIRST;
        DEBUG > 1 and print "Numeric-initial $y trumps letter-initial $x\n";
      } else {
        $rv = 0;
      }
  
      unless($rv) {
        # Normal case:
        $rv = 0;
        DEBUG and print "<$x> and <$y> compared...\n";
  
       Consideration:
        while(length $x and length $y) {
  
          DEBUG > 2 and print " <$x> and <$y>...\n";
  
          # First, non-numeric comparison:
          $x2 = ($x =~ m/^(\D+)/s) ? length($1) : 0;
          $y2 = ($y =~ m/^(\D+)/s) ? length($1) : 0;
          # Now make x2 the min length of the two:
          $x2 = $y2 if $x2 > $y2;
          if($x2) {
            DEBUG > 1 and printf " <%s> and <%s> lexically for length $x2...\n",
              substr($x,0,$x2), substr($y,0,$x2);
            do {
             my $i = substr($x,0,$x2);
             my $j = substr($y,0,$x2);
             my $sv = $i cmp $j;
             print "SCREAM! on <$i><$j> -- $sv != $rv \n" unless $rv == $sv;
             last;
            }
  
  
             if $rv =
             # The ''. things here force a copy that seems to work around a
             #  mysterious intermittent bug that 'use locale' provokes in
             #  many versions of Perl.
                     $cmp
                     ? $cmp->(substr($x,0,$x2) . '',
                              substr($y,0,$x2) . '',
                             )
                     :
                     scalar(( substr($x,0,$x2) . '' ) cmp
                            ( substr($y,0,$x2) . '' )
                            )
            ;
            # otherwise trim and keep going:
            substr($x,0,$x2) = '';
            substr($y,0,$x2) = '';
          }
  
          # Now numeric:
          #  (actually just using $x2 and $y2 as scratch)
  
          if( $x =~ s/^(\d+)//s ) {
            $x2 = $1;
            if( $y =~ s/^(\d+)//s ) {
              # We have two numbers here.
              DEBUG > 1 and print " <$x2> and <$1> numerically\n";
              if(length($x2) < MAX_INT_SIZE and length($1) < MAX_INT_SIZE) {
                # small numbers: we can compare happily
                last if $rv = $x2 <=> $1;
              } else {
                # ARBITRARILY large integers!
  
                # This saves on loss of precision that could happen
                #  with actual stringification.
                # Also, I sense that very large numbers aren't too
                #  terribly common in sort data.
  
                # trim leading 0's:
                ($y2 = $1) =~ s/^0+//s;
                $x2 =~ s/^0+//s;
                print "   Treating $x2 and $y2 as bigint\n" if DEBUG;
  
                no locale; # we want the dumb cmp back.
                last if $rv = (
                   # works only for non-negative whole numbers:
                   length($x2) <=> length($y2)
                     # the longer the numeral, the larger the value
                   or $x2 cmp $y2
                     # between equals, compare lexically!!  amazing but true.
                );
              }
            } else {
              # X is numeric but Y isn't
              $rv = Y_FIRST;
              last;
            }
          } elsif( $y =~ s/^\d+//s ) {  # we don't need to capture the substring
            $rv = X_FIRST;
            last;
          }
           # else one of them is 0-length.
  
         # end-while
        }
      }
  EOGUTS
  
  sub maker {
    my $code = $_[0];
    $code =~ s/~COMPARATOR~/$guts/g || die "Can't find ~COMPARATOR~";
    eval $code;
    die $@ if $@;
  }
  
  ##############################################################################
  
  maker(<<'EONSORT');
  sub nsort {
    # get options:
    my($cmp, $lc);
    ($cmp,$lc) = @{shift @_} if @_ and ref($_[0]) eq 'ARRAY';
  
    return @_ unless @_ > 1 or wantarray; # be clever
  
    my($x, $x2, $y, $y2, $rv);  # scratch vars
  
    # We use a Schwartzian xform to memoize the lc'ing and \W-removal
  
    map $_->[0],
    sort {
      if($a->[0] eq $b->[0]) { 0 }   # trap this expensive case
      else {
  
      $x = $a->[1];
      $y = $b->[1];
  
  ~COMPARATOR~
  
      # Tiebreakers...
      DEBUG > 1 and print " -<${$a}[0]> cmp <${$b}[0]> is $rv ($ORD[$rv])\n";
      $rv ||= (length($x) <=> length($y))  # shorter is always first
          ||  ($cmp and $cmp->($x,$y) || $cmp->($a->[0], $b->[0]))
          ||  ($x      cmp $y     )
          ||  ($a->[0] cmp $b->[0])
      ;
  
      DEBUG > 1 and print "  <${$a}[0]> cmp <${$b}[0]> is $rv ($ORD[$rv])\n";
      $rv;
    }}
  
    map {;
      $x = $lc ? $lc->($_) : lc($_); # x as scratch
      $x =~ s/\W+//s;
      [$_, $x];
    }
    @_
  }
  EONSORT
  
  #-----------------------------------------------------------------------------
  maker(<<'EONCMP');
  sub ncmp {
    # The guts are basically the same as above...
  
    # get options:
    my($cmp, $lc);
    ($cmp,$lc) = @{shift @_} if @_ and ref($_[0]) eq 'ARRAY';
  
    if(@_ == 0) {
      @_ = ($a, $b); # bit of a hack!
      DEBUG > 1 and print "Hacking in <$a><$b>\n";
    } elsif(@_ != 2) {
      require Carp;
      Carp::croak("Not enough options to ncmp!");
    }
    my($a,$b) = @_;
    my($x, $x2, $y, $y2, $rv);  # scratch vars
  
    DEBUG > 1 and print "ncmp args <$a><$b>\n";
    if($a eq $b) { # trap this expensive case
      0;
    } else {
      $x = ($lc ? $lc->($a) : lc($a));
      $x =~ s/\W+//s;
      $y = ($lc ? $lc->($b) : lc($b));
      $y =~ s/\W+//s;
  
  ~COMPARATOR~
  
  
      # Tiebreakers...
      DEBUG > 1 and print " -<$a> cmp <$b> is $rv ($ORD[$rv])\n";
      $rv ||= (length($x) <=> length($y))  # shorter is always first
          ||  ($cmp and $cmp->($x,$y) || $cmp->($a,$b))
          ||  ($x cmp $y)
          ||  ($a cmp $b)
      ;
  
      DEBUG > 1 and print "  <$a> cmp <$b> is $rv\n";
      $rv;
    }
  }
  EONCMP
  
  # clean up:
  undef $guts;
  undef &maker;
  
  #-----------------------------------------------------------------------------
  1;
  
  ############### END OF MAIN SOURCE ###########################################
  __END__
  
  =head1 NAME
  
  Sort::Naturally -- sort lexically, but sort numeral parts numerically
  
  =head1 SYNOPSIS
  
    @them = nsort(qw(
     foo12a foo12z foo13a foo 14 9x foo12 fooa foolio Foolio Foo12a
    ));
    print join(' ', @them), "\n";
  
  Prints:
  
    9x 14 foo fooa foolio Foolio foo12 foo12a Foo12a foo12z foo13a
  
  (Or "foo12a" + "Foo12a" and "foolio" + "Foolio" and might be
  switched, depending on your locale.)
  
  =head1 DESCRIPTION
  
  This module exports two functions, C<nsort> and C<ncmp>; they are used
  in implementing my idea of a "natural sorting" algorithm.  Under natural
  sorting, numeric substrings are compared numerically, and other
  word-characters are compared lexically.
  
  This is the way I define natural sorting:
  
  =over
  
  =item *
  
  Non-numeric word-character substrings are sorted lexically,
  case-insensitively: "Foo" comes between "fish" and "fowl".
  
  =item *
  
  Numeric substrings are sorted numerically:
  "100" comes after "20", not before.
  
  =item *
  
  \W substrings (neither words-characters nor digits) are I<ignored>.
  
  =item *
  
  Our use of \w, \d, \D, and \W is locale-sensitive:  Sort::Naturally
  uses a C<use locale> statement.
  
  =item *
  
  When comparing two strings, where a numeric substring in one
  place is I<not> up against a numeric substring in another,
  the non-numeric always comes first.  This is fudged by
  reading pretending that the lack of a number substring has
  the value -1, like so:
  
    foo       =>  "foo",  -1
    foobar    =>  "foo",  -1,  "bar"
    foo13     =>  "foo",  13,
    foo13xyz  =>  "foo",  13,  "xyz"
  
  That's so that "foo" will come before "foo13", which will come
  before "foobar".
  
  =item *
  
  The start of a string is exceptional: leading non-\W (non-word,
  non-digit)
  components are are ignored, and numbers come I<before> letters.
  
  =item *
  
  I define "numeric substring" just as sequences matching m/\d+/ --
  scientific notation, commas, decimals, etc., are not seen.  If
  your data has thousands separators in numbers
  ("20,000 Leagues Under The Sea" or "20.000 lieues sous les mers"),
  consider stripping them before feeding them to C<nsort> or
  C<ncmp>.
  
  =back
  
  =head2 The nsort function
  
  This function takes a list of strings, and returns a copy of the list,
  sorted.
  
  This is what most people will want to use:
  
    @stuff = nsort(...list...);
  
  When nsort needs to compare non-numeric substrings, it
  uses Perl's C<lc> function in scope of a <use locale>.
  And when nsort needs to lowercase things, it uses Perl's
  C<lc> function in scope of a <use locale>.  If you want nsort
  to use other functions instead, you can specify them in
  an arrayref as the first argument to nsort:
  
    @stuff = nsort( [
                      \&string_comparator,   # optional
                      \&lowercaser_function  # optional
                    ],
                    ...list...
                  );
  
  If you want to specify a string comparator but no lowercaser,
  then the options list is C<[\&comparator, '']> or
  C<[\&comparator]>.  If you want to specify no string comparator
  but a lowercaser, then the options list is
  C<['', \&lowercaser]>.
  
  Any comparator you specify is called as
  C<$comparator-E<gt>($left, $right)>,
  and, like a normal Perl C<cmp> replacement, must return
  -1, 0, or 1 depending on whether the left argument is stringwise
  less than, equal to, or greater than the right argument.
  
  Any lowercaser function you specify is called as
  C<$lowercased = $lowercaser-E<gt>($original)>.  The routine
  must not modify its C<$_[0]>.
  
  =head2 The ncmp function
  
  Often, when sorting non-string values like this:
  
     @objects_sorted = sort { $a->tag cmp $b->tag } @objects;
  
  ...or even in a Schwartzian transform, like this:
  
     @strings =
       map $_->[0]
       sort { $a->[1] cmp $b->[1] }
       map { [$_, make_a_sort_key_from($_) ]
       @_
     ;
  
  ...you wight want something that replaces not C<sort>, but C<cmp>.
  That's what Sort::Naturally's C<ncmp> function is for.  Call it with
  the syntax C<ncmp($left,$right)> instead of C<$left cmp $right>,
  but otherwise it's a fine replacement:
  
     @objects_sorted = sort { ncmp($a->tag,$b->tag) } @objects;
  
     @strings =
       map $_->[0]
       sort { ncmp($a->[1], $b->[1]) }
       map { [$_, make_a_sort_key_from($_) ]
       @_
     ;
  
  Just as with C<nsort> can take different a string-comparator
  and/or lowercaser, you can do the same with C<ncmp>, by passing
  an arrayref as the first argument:
  
    ncmp( [
            \&string_comparator,   # optional
            \&lowercaser_function  # optional
          ],
          $left, $right
        )
  
  You might get string comparators from L<Sort::ArbBiLex|Sort::ArbBiLex>.
  
  =head1 NOTES
  
  =over
  
  =item *
  
  This module is not a substitute for
  L<Sort::Versions|Sort::Versions>!  If
  you just need proper version sorting, use I<that!>
  
  =item *
  
  If you need something that works I<sort of> like this module's
  functions, but not quite the same, consider scouting thru this
  module's source code, and adapting what you see.  Besides
  the functions that actually compile in this module, after the POD,
  there's several alternate attempts of mine at natural sorting
  routines, which are not compiled as part of the module, but which you
  might find useful.  They should all be I<working> implementations of
  slightly different algorithms
  (all of them based on Martin Pool's C<nsort>) which I eventually
  discarded in favor of my algorithm.  If you are having to
  naturally-sort I<very large> data sets, and sorting is getting
  ridiculously slow, you might consider trying one of those
  discarded functions -- I have a feeling they might be faster on
  large data sets.  Benchmark them on your data and see.  (Unless
  you I<need> the speed, don't bother.  Hint: substitute C<sort>
  for C<nsort> in your code, and unless your program speeds up
  drastically, it's not the sorting that's slowing things down.
  But if it I<is> C<nsort> that's slowing things down, consider
  just:
  
        if(@set >= SOME_VERY_BIG_NUMBER) {
          no locale; # vroom vroom
          @sorted = sort(@set);  # feh, good enough
        } elsif(@set >= SOME_BIG_NUMBER) {
          use locale;
          @sorted = sort(@set);  # feh, good enough
        } else {
          # but keep it pretty for normal cases
          @sorted = nsort(@set);
        }
  
  =item *
  
  If you do adapt the routines in this module, email me; I'd
  just be interested in hearing about it.
  
  =item *
  
  Thanks to the EFNet #perl people for encouraging this module,
  especially magister and a-mused.
  
  =back
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  Copyright 2001, Sean M. Burke C<sburke@cpan.org>, all rights
  reserved.  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Sean M. Burke C<sburke@cpan.org>
  
  =cut
  
  ############   END OF DOCS   ############
  
  ############################################################################
  ############################################################################
  
  ############ BEGIN OLD STUFF ############
  
  # We can't have "use integer;", or else (5 <=> 5.1) comes out "0" !
  
  #-----------------------------------------------------------------------------
  sub nsort {
    my($cmp, $lc);
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      if($x =~ m/^[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee](?:[+-]?\d+))?\z/s) {
        # It's entirely purely numeric, so treat it specially:
        push @bit, '', $x;
      } else {
        # Consume the string.
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          push @bit, ($x =~ s/^(\d+)//s) ?    $1  :  0;
        }
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      # End result: [original bit         , (text, number), (text, number), ...]
      # Minimally:  [0-length original bit,]
      # Examples:
      #    ['10'         => ''   ,  10,              ]
      #    ['fo900'      => 'fo' , 900,              ]
      #    ['foo10'      => 'foo',  10,              ]
      #    ['foo9.pl'    => 'foo',   9,   , '.pl', 0 ]
      #    ['foo32.pl'   => 'foo',  32,   , '.pl', 0 ]
      #    ['foo325.pl'  => 'foo', 325,   , '.pl', 0 ]
      #  Yes, always an ODD number of elements.
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Same as before, except without the pure-number trap.
  
  sub nsorts {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      while(length $x) {
        push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
        push @bit, ($x =~ s/^(\d+)//s) ?    $1  :  0;
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      # End result: [original bit         , (text, number), (text, number), ...]
      # Minimally:  [0-length original bit,]
      # Examples:
      #    ['10'         => ''   ,  10,              ]
      #    ['fo900'      => 'fo' , 900,              ]
      #    ['foo10'      => 'foo',  10,              ]
      #    ['foo9.pl'    => 'foo',   9,   , '.pl', 0 ]
      #    ['foo32.pl'   => 'foo',  32,   , '.pl', 0 ]
      #    ['foo325.pl'  => 'foo', 325,   , '.pl', 0 ]
      #  Yes, always an ODD number of elements.
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Same as before, except for the sort-key-making
  
  sub nsort0 {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      if($x =~ m/^[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee](?:[+-]?\d+))?\z/s) {
        # It's entirely purely numeric, so treat it specially:
        push @bit, '', $x;
      } else {
        # Consume the string.
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          # Secret sauce:
          if($x =~ s/^(\d+)//s) {
            if(substr($1,0,1) eq '0' and $1 != 0) {
              push @bit, $1 / (10 ** length($1));
            } else {
              push @bit, $1;
            }
          } else {
            push @bit, 0;
          }
        }
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Like nsort0, but WITHOUT pure number handling, and WITH special treatment
  # of pulling off extensions and version numbers.
  
  sub nsortf {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 3;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a     <=> @$b    ) || ($a->[1] cmp $b->[1])
         || ($a->[2] <=> $b->[2]) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use the
        #  lc'd extension, otherwise the verison, otherwise use
        #  the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ( ($x = defined($_) ? $_ : ''), '',0 );
  
      {
        # Consume the string.
  
        # First, pull off any VAX-style version
        $bit[2] = $1 if $x =~ s/;(\d+)$//;
  
        # Then pull off any apparent extension
        if( $x !~ m/^\.+$/s and     # don't mangle ".", "..", or "..."
            $x =~ s/(\.[^\.\;]*)$//sg
            # We could try to avoid catching all-digit extensions,
            #  but I think that's getting /too/ clever.
        ) {
          $i = $1;
          if($x =~ m<[^\\\://]$>s) {
            # We didn't take the whole basename.
            $bit[1] = lc $i;
            DEBUG and print "Consuming extension \"$1\"\n";
          } else {
            # We DID take the whole basename.  Fix it.
            $x = $1;  # Repair it.
          }
        }
  
        push @bit, '', -1   if $x =~ m/^\./s;
         # A hack to make .-initial filenames sort first, regardless of locale.
         # And -1 is always a sort-firster, since in the code below, there's
         # no allowance for filenames containing negative numbers: -1.dat
         # will be read as string '-' followed by number 1.
  
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          # Secret sauce:
          if($x =~ s/^(\d+)//s) {
            if(substr($1,0,1) eq '0' and $1 != 0) {
              push @bit, $1 / (10 ** length($1));
            } else {
              push @bit, $1;
            }
          } else {
            push @bit, 0;
          }
        }
      }
  
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      \@bit;
    }
    @_;
  }
  
  # yowza yowza yowza.
  
SORT_NATURALLY

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  
  use Moo::_strictures;
  use Exporter qw(import);
  use Moo::_Utils qw(_getglob _install_coderef);
  use Scalar::Util qw(weaken);
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  our @EXPORT_OK = qw(undefer_package);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    $DEFERRED{$made} = $DEFERRED{$deferred};
    weaken $DEFERRED{$made}
      unless $target;
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub undefer_package {
    my $package = shift;
    my @subs = grep { $DEFERRED{$_}[0] =~ /^${package}::[^:]+$/ } keys %DEFERRED;
    undefer_sub($_) for @subs;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    my $info = $DEFERRED{$deferred||''} or return undef;
    [ @$info ];
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_info;
    my $deferred = sub {
      $undeferred ||= undefer_sub($deferred_info->[3]);
      goto &$undeferred;
    };
    $deferred_info = [ $target, $maker, \$undeferred, $deferred ];
    weaken($deferred_info->[3]);
    weaken($DEFERRED{$deferred} = $deferred_info);
    _install_coderef($target => $deferred) if defined $target;
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map { defined $_ && $_->[3] ? ($_->[3] => $_) : () } values %DEFERRED;
    foreach my $info (values %DEFERRED) {
      weaken($info)
        unless $info->[0] && ${$info->[2]};
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  Exported by default.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  Exported by default.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all defered subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.  Note this may bake the behavior of some subs that were intended to
  calculate their behavior later, so it shouldn't be used midway through a
  module load or class definition.
  
  Exported by default.
  
  =head2 undefer_package
  
    undefer_package($package);
  
  This undefers all defered subs in a package.
  
  Not exported by default.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  sub _clean_eval { eval $_[0] }
  
  use Moo::_strictures;
  
  use Sub::Defer qw(defer_sub);
  use Scalar::Util qw(weaken);
  use Exporter qw(import);
  use B ();
  BEGIN {
    *_HAVE_PERLSTRING = defined &B::perlstring ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub qsub);
  our @EXPORT_OK = qw(quotify capture_unroll inlinify);
  
  our %QUOTED;
  
  sub quotify {
    ! defined $_[0]     ? 'undef()'
    : _HAVE_PERLSTRING  ? B::perlstring($_[0])
    : qq["\Q$_[0]\E"];
  }
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms) {
      my ($pre, $indent, $code_args) = ($1, $2, $3);
      $do .= $pre;
      if ($code_args ne $args) {
        $do .= $indent . 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $do .= ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my ($package, $hints, $bitmask, $hintshash) = (caller(0))[0,8,9,10];
    my $context
      ="# BEGIN quote_sub PRELUDE\n"
      ."package $package;\n"
      ."BEGIN {\n"
      ."  \$^H = ".quotify($hints).";\n"
      ."  \${^WARNING_BITS} = ".quotify($bitmask).";\n"
      ."  \%^H = (\n"
      . join('', map
       "    ".quotify($_)." => ".quotify($hintshash->{$_}).",",
        keys %$hintshash)
      ."  );\n"
      ."}\n"
      ."# END quote_sub PRELUDE\n";
    $code = "$context$code";
    my $quoted_info;
    my $unquoted;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      $unquoted if 0;
      unquote_sub($quoted_info->[4]);
    };
    $quoted_info = [ $name, $code, $captures, \$unquoted, $deferred ];
    weaken($quoted_info->[3]);
    weaken($quoted_info->[4]);
    weaken($QUOTED{$deferred} = $quoted_info);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub||''} or return undef;
    my ($name, $code, $captured, $unquoted, $deferred) = @{$quoted_info};
    $unquoted &&= $$unquoted;
    if (($deferred && $deferred eq $sub)
        || ($unquoted && $unquoted eq $sub)) {
      return [ $name, $code, $captured, $unquoted, $deferred ];
    }
    return undef;
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    my $quoted = $QUOTED{$sub} or return undef;
    my $unquoted = $quoted->[3];
    unless ($unquoted && $$unquoted) {
      my ($name, $code, $captures) = @$quoted;
  
      my $make_sub = "{\n";
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_UNQUOTED'} = \$unquoted;
      $captures{'$_QUOTED'} = \$quoted;
      $make_sub .= capture_unroll("\$_[1]", \%captures, 2);
  
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$\$_UNQUOTED = sub {\n"
      );
      $make_sub .= "  \$_QUOTED if 0;\n";
      $make_sub .= "  \$_UNQUOTED if 0;\n";
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$\$_UNQUOTED = \\&${name}\n";
      }
      $make_sub .= "}\n1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{$name} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          die "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
        weaken($QUOTED{$$unquoted} = $quoted);
      }
    }
    $$unquoted;
  }
  
  sub qsub ($) {
    goto &quote_sub;
  }
  
  sub CLONE {
    %QUOTED = map { defined $_ ? (
      $_->[3] && ${$_->[3]} ? (${ $_->[3] } => $_) : (),
      $_->[4] ? ($_->[4] => $_) : (),
    ) : () } values %QUOTED;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 quotify
  
   my $quoted_value = quotify $value;
  
  Quotes a single (non-reference) scalar value for use in a code string.  Numbers
  aren't treated specially and will be quoted as strings, but undef will quoted as
  C<undef()>.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head2 qsub
  
   my $hash = {
    coderef => qsub q{ print "hello"; },
    other   => 5,
   };
  
  Arguments: $code
  
  Works exactly like L</quote_sub>, but includes a prototype to only accept a
  single parameter.  This makes it easier to include in hash structures or lists.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few
  caveats apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_QUOTE

$fatpacked{"Term/ReadLine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_READLINE';
  =head1 NAME
  
  Term::ReadLine - Perl interface to various C<readline> packages.
  If no real package is found, substitutes stubs instead of basic functions.
  
  =head1 SYNOPSIS
  
    use Term::ReadLine;
    my $term = Term::ReadLine->new('Simple Perl calc');
    my $prompt = "Enter your arithmetic expression: ";
    my $OUT = $term->OUT || \*STDOUT;
    while ( defined ($_ = $term->readline($prompt)) ) {
      my $res = eval($_);
      warn $@ if $@;
      print $OUT $res, "\n" unless $@;
      $term->addhistory($_) if /\S/;
    }
  
  =head1 DESCRIPTION
  
  This package is just a front end to some other packages. It's a stub to
  set up a common interface to the various ReadLine implementations found on
  CPAN (under the C<Term::ReadLine::*> namespace).
  
  =head1 Minimal set of supported functions
  
  All the supported functions should be called as methods, i.e., either as 
  
    $term = Term::ReadLine->new('name');
  
  or as 
  
    $term->addhistory('row');
  
  where $term is a return value of Term::ReadLine-E<gt>new().
  
  =over 12
  
  =item C<ReadLine>
  
  returns the actual package that executes the commands. Among possible
  values are C<Term::ReadLine::Gnu>, C<Term::ReadLine::Perl>,
  C<Term::ReadLine::Stub>.
  
  =item C<new>
  
  returns the handle for subsequent calls to following
  functions. Argument is the name of the application. Optionally can be
  followed by two arguments for C<IN> and C<OUT> filehandles. These
  arguments should be globs.
  
  =item C<readline>
  
  gets an input line, I<possibly> with actual C<readline>
  support. Trailing newline is removed. Returns C<undef> on C<EOF>.
  
  =item C<addhistory>
  
  adds the line to the history of input, from where it can be used if
  the actual C<readline> is present.
  
  =item C<IN>, C<OUT>
  
  return the filehandles for input and output or C<undef> if C<readline>
  input and output cannot be used for Perl.
  
  =item C<MinLine>
  
  If argument is specified, it is an advice on minimal size of line to
  be included into history.  C<undef> means do not include anything into
  history. Returns the old value.
  
  =item C<findConsole>
  
  returns an array with two strings that give most appropriate names for
  files for input and output using conventions C<"E<lt>$in">, C<"E<gt>out">.
  
  =item Attribs
  
  returns a reference to a hash which describes internal configuration
  of the package. Names of keys in this hash conform to standard
  conventions with the leading C<rl_> stripped.
  
  =item C<Features>
  
  Returns a reference to a hash with keys being features present in
  current implementation. Several optional features are used in the
  minimal interface: C<appname> should be present if the first argument
  to C<new> is recognized, and C<minline> should be present if
  C<MinLine> method is not dummy.  C<autohistory> should be present if
  lines are put into history automatically (maybe subject to
  C<MinLine>), and C<addhistory> if C<addhistory> method is not dummy.
  
  If C<Features> method reports a feature C<attribs> as present, the
  method C<Attribs> is not dummy.
  
  =back
  
  =head1 Additional supported functions
  
  Actually C<Term::ReadLine> can use some other package, that will
  support a richer set of commands.
  
  All these commands are callable via method interface and have names
  which conform to standard conventions with the leading C<rl_> stripped.
  
  The stub package included with the perl distribution allows some
  additional methods: 
  
  =over 12
  
  =item C<tkRunning>
  
  makes Tk event loop run when waiting for user input (i.e., during
  C<readline> method).
  
  =item C<event_loop>
  
  Registers call-backs to wait for user input (i.e., during C<readline>
  method).  This supersedes tkRunning.
  
  The first call-back registered is the call back for waiting.  It is
  expected that the callback will call the current event loop until
  there is something waiting to get on the input filehandle.  The parameter
  passed in is the return value of the second call back.
  
  The second call-back registered is the call back for registration.  The
  input filehandle (often STDIN, but not necessarily) will be passed in.
  
  For example, with AnyEvent:
  
    $term->event_loop(sub {
      my $data = shift;
      $data->[1] = AE::cv();
      $data->[1]->recv();
    }, sub {
      my $fh = shift;
      my $data = [];
      $data->[0] = AE::io($fh, 0, sub { $data->[1]->send() });
      $data;
    });
  
  The second call-back is optional if the call back is registered prior to
  the call to $term-E<gt>readline.
  
  Deregistration is done in this case by calling event_loop with C<undef>
  as its parameter:
  
      $term->event_loop(undef);
  
  This will cause the data array ref to be removed, allowing normal garbage
  collection to clean it up.  With AnyEvent, that will cause $data->[0] to
  be cleaned up, and AnyEvent will automatically cancel the watcher at that
  time.  If another loop requires more than that to clean up a file watcher,
  that will be up to the caller to handle.
  
  =item C<ornaments>
  
  makes the command line stand out by using termcap data.  The argument
  to C<ornaments> should be 0, 1, or a string of a form
  C<"aa,bb,cc,dd">.  Four components of this string should be names of
  I<terminal capacities>, first two will be issued to make the prompt
  standout, last two to make the input line standout.
  
  =item C<newTTY>
  
  takes two arguments which are input filehandle and output filehandle.
  Switches to use these filehandles.
  
  =back
  
  One can check whether the currently loaded ReadLine package supports
  these methods by checking for corresponding C<Features>.
  
  =head1 EXPORTS
  
  None
  
  =head1 ENVIRONMENT
  
  The environment variable C<PERL_RL> governs which ReadLine clone is
  loaded. If the value is false, a dummy interface is used. If the value
  is true, it should be tail of the name of the package to use, such as
  C<Perl> or C<Gnu>.  
  
  As a special case, if the value of this variable is space-separated,
  the tail might be used to disable the ornaments by setting the tail to
  be C<o=0> or C<ornaments=0>.  The head should be as described above, say
  
  If the variable is not set, or if the head of space-separated list is
  empty, the best available package is loaded.
  
    export "PERL_RL=Perl o=0" # Use Perl ReadLine sans ornaments
    export "PERL_RL= o=0"     # Use best available ReadLine sans ornaments
  
  (Note that processing of C<PERL_RL> for ornaments is in the discretion of the 
  particular used C<Term::ReadLine::*> package).
  
  =cut
  
  use strict;
  
  package Term::ReadLine::Stub;
  our @ISA = qw'Term::ReadLine::Tk Term::ReadLine::TermCap';
  
  $DB::emacs = $DB::emacs;	# To pacify -w
  our @rl_term_set;
  *rl_term_set = \@Term::ReadLine::TermCap::rl_term_set;
  
  sub PERL_UNICODE_STDIN () { 0x0001 }
  
  sub ReadLine {'Term::ReadLine::Stub'}
  sub readline {
    my $self = shift;
    my ($in,$out,$str) = @$self;
    my $prompt = shift;
    print $out $rl_term_set[0], $prompt, $rl_term_set[1], $rl_term_set[2];
    $self->register_Tk
       if not $Term::ReadLine::registered and $Term::ReadLine::toloop;
    #$str = scalar <$in>;
    $str = $self->get_line;
    utf8::upgrade($str)
        if (${^UNICODE} & PERL_UNICODE_STDIN || defined ${^ENCODING}) &&
           utf8::valid($str);
    print $out $rl_term_set[3];
    # bug in 5.000: chomping empty string creates length -1:
    chomp $str if defined $str;
    $str;
  }
  sub addhistory {}
  
  sub findConsole {
      my $console;
      my $consoleOUT;
  
      if (-e "/dev/tty" and $^O ne 'MSWin32') {
  	$console = "/dev/tty";
      } elsif (-e "con" or $^O eq 'MSWin32' or $^O eq 'msys') {
         $console = 'CONIN$';
         $consoleOUT = 'CONOUT$';
      } elsif ($^O eq 'VMS') {
  	$console = "sys\$command";
      } elsif ($^O eq 'os2' && !$DB::emacs) {
  	$console = "/dev/con";
      } else {
  	$console = undef;
      }
  
      $consoleOUT = $console unless defined $consoleOUT;
      $console = "&STDIN" unless defined $console;
      if ($console eq "/dev/tty" && !open(my $fh, "<", $console)) {
        $console = "&STDIN";
        undef($consoleOUT);
      }
      if (!defined $consoleOUT) {
        $consoleOUT = defined fileno(STDERR) && $^O ne 'MSWin32' ? "&STDERR" : "&STDOUT";
      }
      ($console,$consoleOUT);
  }
  
  sub new {
    die "method new called with wrong number of arguments" 
      unless @_==2 or @_==4;
    #local (*FIN, *FOUT);
    my ($FIN, $FOUT, $ret);
    if (@_==2) {
      my($console, $consoleOUT) = $_[0]->findConsole;
  
  
      # the Windows CONIN$ needs GENERIC_WRITE mode to allow
      # a SetConsoleMode() if we end up using Term::ReadKey
      open FIN, (  $^O eq 'MSWin32' && $console eq 'CONIN$' ) ? "+<$console" :
                                                                "<$console";
      open FOUT,">$consoleOUT";
  
      #OUT->autoflush(1);		# Conflicts with debugger?
      my $sel = select(FOUT);
      $| = 1;				# for DB::OUT
      select($sel);
      $ret = bless [\*FIN, \*FOUT];
    } else {			# Filehandles supplied
      $FIN = $_[2]; $FOUT = $_[3];
      #OUT->autoflush(1);		# Conflicts with debugger?
      my $sel = select($FOUT);
      $| = 1;				# for DB::OUT
      select($sel);
      $ret = bless [$FIN, $FOUT];
    }
    if ($ret->Features->{ornaments} 
        and not ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/)) {
      local $Term::ReadLine::termcap_nowarn = 1;
      $ret->ornaments(1);
    }
    return $ret;
  }
  
  sub newTTY {
    my ($self, $in, $out) = @_;
    $self->[0] = $in;
    $self->[1] = $out;
    my $sel = select($out);
    $| = 1;				# for DB::OUT
    select($sel);
  }
  
  sub IN { shift->[0] }
  sub OUT { shift->[1] }
  sub MinLine { undef }
  sub Attribs { {} }
  
  my %features = (tkRunning => 1, ornaments => 1, 'newTTY' => 1);
  sub Features { \%features }
  
  #sub get_line {
  #  my $self = shift;
  #  my $in = $self->IN;
  #  local ($/) = "\n";
  #  return scalar <$in>;
  #}
  
  package Term::ReadLine;		# So late to allow the above code be defined?
  
  our $VERSION = '1.14';
  
  my ($which) = exists $ENV{PERL_RL} ? split /\s+/, $ENV{PERL_RL} : undef;
  if ($which) {
    if ($which =~ /\bgnu\b/i){
      eval "use Term::ReadLine::Gnu;";
    } elsif ($which =~ /\bperl\b/i) {
      eval "use Term::ReadLine::Perl;";
    } elsif ($which =~ /^(Stub|TermCap|Tk)$/) {
      # it is already in memory to avoid false exception as seen in:
      # PERL_RL=Stub perl -e'$SIG{__DIE__} = sub { print @_ }; require Term::ReadLine'
    } else {
      eval "use Term::ReadLine::$which;";
    }
  } elsif (defined $which and $which ne '') {	# Defined but false
    # Do nothing fancy
  } else {
    eval "use Term::ReadLine::Gnu; 1" or eval "use Term::ReadLine::EditLine; 1" or eval "use Term::ReadLine::Perl; 1";
  }
  
  #require FileHandle;
  
  # To make possible switch off RL in debugger: (Not needed, work done
  # in debugger).
  our @ISA;
  if (defined &Term::ReadLine::Gnu::readline) {
    @ISA = qw(Term::ReadLine::Gnu Term::ReadLine::Stub);
  } elsif (defined &Term::ReadLine::EditLine::readline) {
    @ISA = qw(Term::ReadLine::EditLine Term::ReadLine::Stub);
  } elsif (defined &Term::ReadLine::Perl::readline) {
    @ISA = qw(Term::ReadLine::Perl Term::ReadLine::Stub);
  } elsif (defined $which && defined &{"Term::ReadLine::$which\::readline"}) {
    @ISA = "Term::ReadLine::$which";
  } else {
    @ISA = qw(Term::ReadLine::Stub);
  }
  
  package Term::ReadLine::TermCap;
  
  # Prompt-start, prompt-end, command-line-start, command-line-end
  #     -- zero-width beautifies to emit around prompt and the command line.
  our @rl_term_set = ("","","","");
  # string encoded:
  our $rl_term_set = ',,,';
  
  our $terminal;
  sub LoadTermCap {
    return if defined $terminal;
    
    require Term::Cap;
    $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
  }
  
  sub ornaments {
    shift;
    return $rl_term_set unless @_;
    $rl_term_set = shift;
    $rl_term_set ||= ',,,';
    $rl_term_set = 'us,ue,md,me' if $rl_term_set eq '1';
    my @ts = split /,/, $rl_term_set, 4;
    eval { LoadTermCap };
    unless (defined $terminal) {
      warn("Cannot find termcap: $@\n") unless $Term::ReadLine::termcap_nowarn;
      $rl_term_set = ',,,';
      return;
    }
    @rl_term_set = map {$_ ? $terminal->Tputs($_,1) || '' : ''} @ts;
    return $rl_term_set;
  }
  
  
  package Term::ReadLine::Tk;
  
  # This package inserts a Tk->fileevent() before the diamond operator.
  # The Tk watcher dispatches Tk events until the filehandle returned by
  # the$term->IN() accessor becomes ready for reading.  It's assumed
  # that the diamond operator will return a line of input immediately at
  # that point.
  
  my ($giveup);
  
  # maybe in the future the Tk-specific aspects will be removed.
  sub Tk_loop{
      if (ref $Term::ReadLine::toloop)
      {
          $Term::ReadLine::toloop->[0]->($Term::ReadLine::toloop->[2]);
      }
      else
      {
          Tk::DoOneEvent(0) until $giveup;
          $giveup = 0;
      }
  };
  
  sub register_Tk {
      my $self = shift;
      unless ($Term::ReadLine::registered++)
      {
          if (ref $Term::ReadLine::toloop)
          {
              $Term::ReadLine::toloop->[2] = $Term::ReadLine::toloop->[1]->($self->IN) if $Term::ReadLine::toloop->[1];
          }
          else
          {
              Tk->fileevent($self->IN,'readable',sub { $giveup = 1});
          }
      }
  };
  
  sub tkRunning {
    $Term::ReadLine::toloop = $_[1] if @_ > 1;
    $Term::ReadLine::toloop;
  }
  
  sub event_loop {
      shift;
  
      # T::RL::Gnu and T::RL::Perl check that this exists, if not,
      # it doesn't call the loop.  Those modules will need to be
      # fixed before this can be removed.
      if (not defined &Tk::DoOneEvent)
      {
          *Tk::DoOneEvent = sub {
              die "what?"; # this shouldn't be called.
          }
      }
  
      # store the callback in toloop, again so that other modules will
      # recognise it and call us for the loop.
      $Term::ReadLine::toloop = [ @_ ] if @_ > 0; # 0 because we shifted off $self.
      $Term::ReadLine::toloop;
  }
  
  sub PERL_UNICODE_STDIN () { 0x0001 }
  
  sub get_line {
    my $self = shift;
    my ($in,$out,$str) = @$self;
  
    if ($Term::ReadLine::toloop) {
      $self->register_Tk if not $Term::ReadLine::registered;
      $self->Tk_loop;
    }
  
    local ($/) = "\n";
    $str = <$in>;
  
    utf8::upgrade($str)
        if (${^UNICODE} & PERL_UNICODE_STDIN || defined ${^ENCODING}) &&
           utf8::valid($str);
    print $out $rl_term_set[3];
    # bug in 5.000: chomping empty string creates length -1:
    chomp $str if defined $str;
  
    $str;
  }
  
  1;
  
TERM_READLINE

$fatpacked{"Term/ReadLine/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_READLINE_PERL';
  package Term::ReadLine::Perl;
  use Carp;
  @ISA = qw(Term::ReadLine::Stub Term::ReadLine::Compa Term::ReadLine::Perl::AU);
  #require 'readline.pl';
  
  $VERSION = $VERSION = 1.0303;
  
  sub readline {
    shift; 
    #my $in = 
    &readline::readline(@_);
    #$loaded = defined &Term::ReadKey::ReadKey;
    #print STDOUT "\nrl=`$in', loaded = `$loaded'\n";
    #if (ref \$in eq 'GLOB') {	# Bug under debugger
    #  ($in = "$in") =~ s/^\*(\w+::)+//;
    #}
    #print STDOUT "rl=`$in'\n";
    #$in;
  }
  
  #sub addhistory {}
  *addhistory = \&AddHistory;
  
  #$term;
  $readline::minlength = 1;	# To peacify -w
  $readline::rl_readline_name = undef; # To peacify -w
  $readline::rl_basic_word_break_characters = undef; # To peacify -w
  
  sub new {
    if (defined $term) {
      warn "Cannot create second readline interface, falling back to dumb.\n";
      return Term::ReadLine::Stub::new(@_);
    }
    shift;			# Package
    if (@_) {
      if ($term) {
        warn "Ignoring name of second readline interface.\n" if defined $term;
        shift;
      } else {
        $readline::rl_readline_name = shift; # Name
      }
    }
    if (!@_) {
      if (!defined $term) {
        ($IN,$OUT) = Term::ReadLine->findConsole();
        # Old Term::ReadLine did not have a workaround for a bug in Win devdriver
        $IN = 'CONIN$' if $^O eq 'MSWin32' and "\U$IN" eq 'CON';
        open IN,
  	# A workaround for another bug in Win device driver
  	(($IN eq 'CONIN$' and $^O eq 'MSWin32') ? "+< $IN" : "< $IN")
  	  or croak "Cannot open $IN for read";
        open(OUT,">$OUT") || croak "Cannot open $OUT for write";
        $readline::term_IN = \*IN;
        $readline::term_OUT = \*OUT;
      }
    } else {
      if (defined $term and ($term->IN ne $_[0] or $term->OUT ne $_[1]) ) {
        croak "Request for a second readline interface with different terminal";
      }
      $readline::term_IN = shift;
      $readline::term_OUT = shift;    
    }
    eval {require Term::ReadLine::readline}; die $@ if $@;
    # The following is here since it is mostly used for perl input:
    # $readline::rl_basic_word_break_characters .= '-:+/*,[])}';
    $term = bless [$readline::term_IN,$readline::term_OUT];
    unless ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/) {
      local $Term::ReadLine::termcap_nowarn = 1; # With newer Perls
      local $SIG{__WARN__} = sub {}; # With older Perls
      $term->ornaments(1);
    }
    return $term;
  }
  sub newTTY {
    my ($self, $in, $out) = @_;
    $readline::term_IN   = $self->[0] = $in;
    $readline::term_OUT  = $self->[1] = $out;
    my $sel = select($out);
    $| = 1;				# for DB::OUT
    select($sel);
  }
  sub ReadLine {'Term::ReadLine::Perl'}
  sub MinLine {
    my $old = $readline::minlength;
    $readline::minlength = $_[1] if @_ == 2;
    return $old;
  }
  sub SetHistory {
    shift;
    @readline::rl_History = @_;
    $readline::rl_HistoryIndex = @readline::rl_History;
  }
  sub GetHistory {
    @readline::rl_History;
  }
  sub AddHistory {
    shift;
    push @readline::rl_History, @_;
    $readline::rl_HistoryIndex = @readline::rl_History + @_;
  }
  %features =  (appname => 1, minline => 1, autohistory => 1, getHistory => 1,
  	      setHistory => 1, addHistory => 1, preput => 1, 
  	      attribs => 1, 'newTTY' => 1,
  	      tkRunning => Term::ReadLine::Stub->Features->{'tkRunning'},
  	      ornaments => Term::ReadLine::Stub->Features->{'ornaments'},
  	     );
  sub Features { \%features; }
  # my %attribs;
  tie %attribs, 'Term::ReadLine::Perl::Tie' or die ;
  sub Attribs {
    \%attribs;
  }
  sub DESTROY {}
  
  package Term::ReadLine::Perl::AU;
  
  sub AUTOLOAD {
    { $AUTOLOAD =~ s/.*:://; }		# preserve match data
    my $name = "readline::rl_$AUTOLOAD";
    die "Unknown method `$AUTOLOAD' in Term::ReadLine::Perl" 
      unless exists $readline::{"rl_$AUTOLOAD"};
    *$AUTOLOAD = sub { shift; &$name };
    goto &$AUTOLOAD;
  }
  
  package Term::ReadLine::Perl::Tie;
  
  sub TIEHASH { bless {} }
  sub DESTROY {}
  
  sub STORE {
    my ($self, $name) = (shift, shift);
    $ {'readline::rl_' . $name} = shift;
  }
  sub FETCH {
    my ($self, $name) = (shift, shift);
    $ {'readline::rl_' . $name};
  }
  
  package Term::ReadLine::Compa;
  
  sub get_c {
    my $self = shift;
    getc($self->[0]);
  }
  
  sub get_line {
    my $self = shift;
    my $fh = $self->[0];
    scalar <$fh>;
  }
  
  1;
TERM_READLINE_PERL

$fatpacked{"Term/ReadLine/readline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_READLINE_READLINE';
  ##
  ## Perl Readline -- The Quick Help
  ## (see the manual for complete info)
  ##
  ## Once this package is included (require'd), you can then call
  ##	$text = &readline'readline($input);
  ## to get lines of input from the user.
  ##
  ## Normally, it reads ~/.inputrc when loaded... to suppress this, set
  ## 	$readline'rl_NoInitFromFile = 1;
  ## before requiring the package.
  ##
  ## Call rl_bind to add your own key bindings, as in
  ##	&readline'rl_bind('C-L', 'possible-completions');
  ##
  ## Call rl_set to set mode variables yourself, as in
  ##	&readline'rl_set('TcshCompleteMode', 'On');
  ##
  ## To change the input mode (emacs or vi) use ~/.inputrc or call
  ## 	   &readline::rl_set('EditingMode', 'vi');
  ## 	or &readline::rl_set('EditingMode', 'emacs');
  ##
  ## Call rl_basic_commands to set your own command completion, as in
  ##      &readline'rl_basic_commands('print', 'list', 'quit', 'run', 'status');
  ##
  ##
  
  # Wrap the code below (initially Perl4, now partially Perl4) into a fake
  # Perl5 pseudo-module; mismatch of package and file name is intentional
  # to make is harder to abuse this (very fragile) code...
  package readline;
  
  my $autoload_broken = 1;	# currently: defined does not work with a-l
  my $useioctl = 1;
  my $usestty = 1;
  my $max_include_depth = 10;     # follow $include's in init files this deep
  
  BEGIN {			# Some old systems have ioctl "unsupported"
    *ioctl = sub ($$$) { eval { ioctl $_[0], $_[1], $_[2] } };
  }
  
  ##
  ## BLURB:
  ## A pretty full-function package similar to GNU's readline.
  ## Includes support for EUC-encoded Japanese text.
  ##
  ## Written by Jeffrey Friedl, Omron Corporation (jfriedl@omron.co.jp)
  ##
  ## Comments, corrections welcome.
  ##
  ## Thanks to the people at FSF for readline (and the code I referenced
  ## while writing this), and for Roland Schemers whose line_edit.pl I used
  ## as an early basis for this.
  ##
  $VERSION = $VERSION = '1.0303';
  
  ##            - Changes from Slaven Rezic (slaven@rezic.de):
  ##		* reverted the usage of $ENV{EDITOR} to set startup mode
  ##		  only ~/.inputrc or an explicit call to rl_set should
  ##		  be used to set startup mode
  ##
  # 1011109.011 - Changes from Russ Southern (russ@dvns.com):
  ##             * Added $rl_vi_replace_default_on_insert
  # 1000510.010 - Changes from Joe Petolino (petolino@eng.sun.com), requested
  ##              by Ilya:
  ##
  ##              * Make it compatible with perl 5.003.
  ##              * Rename getc() to getc_with_pending().
  ##              * Change unshift(@Pending) to push(@Pending).
  ##
  ## 991109.009 - Changes from Joe Petolino (petolino@eng.sun.com):
  ##              Added vi mode.  Also added a way to set the keymap default
  ##      	action for multi-character keymaps, so that a 2-character
  ##      	sequence (e.g. <esc>A) can be treated as two one-character
  ##      	commands (<esc>, then A) if the sequence is not explicitly
  ##              mapped.
  ##      
  ##              Changed subs:
  ##
  ##              * preinit(): Initialize new keymaps and other data structures.
  ##		             Use $ENV{EDITOR} to set startup mode.
  ##
  ##              * init():    Sets the global *KeyMap, since &F_ReReadInitFile
  ##                           may have changed the key map.
  ##
  ##		* InitKeymap(): $KeyMap{default} is now optional - don't
  ##			     set it if $_[1] eq '';
  ##
  ##		* actually_do_binding(): Set $KeyMap{default} for '\*' key;
  ##			     warning if double-defined.
  ##
  ##		* rl_bind(): Implement \* to set the keymap default.  Also fix
  ##			     some existing regex bugs that I happened to notice.
  ##
  ##		* readline(): No longer takes input from $pending before
  ##                           calling &$rl_getc(); instead, it calls getc_with_pending(),
  ##                           which takes input from the new array @Pending
  ##			     before calling &$rl_getc().  Sets the global
  ##			     *KeyMap after do_command(), since do_command()
  ##			     may change the keymap now.  Does some cursor
  ##			     manipulation after do_command() when at the end
  ##			     of the line in vi command mode, to match the
  ##			     behavior of vi.
  ##
  ##		* rl_getc(): Added a my declaration for $key, which was
  ##			     apparently omitted by the author.  rl_getc() is 
  ##			     no longer called directly; instead, getc_with_pending() calls
  ##			     it only after exhausting any requeued characters
  ##			     in @Pending.  @Pending is used to implement the
  ##			     vi '.' command, as well as the emacs DoSearch
  ##			     functionality.
  ##
  ##		* do_command(): Now defaults the command to 'F_Ding' if
  ##			     $KeyMap{default} is undefined.  This is part
  ##			     of the new \* feature.
  ##
  ##		* savestate()/getstate(): Now use an anonymous array instead
  ##		             of packing the fields into a string.
  ##
  ##		* F_AcceptLine(): Code moved to new sub add_line_to_history(),
  ##			     so that it may be called by F_SaveLine()
  ##			     as well as by F_AcceptLine().
  ##
  ##		* F_QuotedInsert(): Calls getc_with_pending() instead of &$rl_getc().
  ##
  ##		* F_UnixWordRubout(): Fixed bug: changed 'my' declaration of
  ##		             global $rl_basic_word_break_characters to 'local'.
  ##
  ##		* DoSearch(): Calls getc_with_pending() instead of &$rl_getc().  Ungets
  ##			     character onto @Pending instead of $pending.
  ##
  ##		* F_EmacsEditingMode(): Resets global $Vi_mode;
  ##
  ##		* F_ToggleEditingMode(): Deleted.  We use F_ViInput() and
  ##                           F_EmacsEditingMode() instead.
  ##
  ##		* F_PrefixMeta(): Calls getc_with_pending() instead of &$rl_getc().
  ##
  ##		* F_DigitArgument(): Calls getc_with_pending() instead of &$rl_getc().
  ##
  ##		* F_Ding(): Returns undef, for testing by vi commands.
  ##
  ##		* F_Complete(): Returns true if a completion was done, false
  ##                           otherwise, so vi completion routines can test it.
  ##
  ##		* complete_internal(): Returns true if a completion was done,
  ##                           false otherwise, so vi completion routines can
  ##                           test it.  Does a little cursor massaging in vi
  ##                           mode, to match the behavior of ksh vi mode.
  ##
  ##              Disclaimer: the original code dates from the perl 4 days, and
  ##              isn't very pretty by today's standards (for example,
  ##              extensive use of typeglobs and localized globals).  In the
  ##              interests of not breaking anything, I've tried to preserve
  ##              the old code as much as possible, and I've avoided making
  ##              major stylistic changes.  Since I'm not a regular emacs user,
  ##              I haven't done much testing to see that all the emacs-mode
  ##              features still work.
  ##
  ## 940817.008 - Added $var_CompleteAddsuffix.
  ##		Now recognizes window-change signals (at least on BSD).
  ##              Various typos and bug fixes.
  ##	Changes from Chris Arthur (csa@halcyon.com):
  ##		Added a few new keybindings.
  ##              Various typos and bug fixes.
  ##		Support for use from a dumb terminal.
  ##		Pretty-printing of filename-completion matches.
  ##		
  ## 930306.007 - Added rl_start_default_at_beginning.
  ##		Added optional message arg to &redisplay.
  ##		Added explicit numeric argument var to functions that use it.
  ##		Redid many commands to simplify.
  ##		Added TransposeChars, UpcaseWord, CapitalizeWord, DownCaseWord.
  ##		Redid key binding specs to better match GNU.. added
  ##		  undocumented "new-style" bindings.... can now bind
  ##		  arrow keys and other arbitrairly long key sequences.
  ##		Added if/else/then to .inputrc.
  ##		
  ## 930305.006 - optional "default" added (from mmuegel@cssmp.corp.mot.com).
  ##
  ## 930211.005 - fixed strange problem with eval while keybinding
  ##
  
  ##
  ## Ilya: 
  ##
  ## Added support for ReadKey, 
  ##
  ## Added customization variable $minlength
  ## to denote minimal lenth of a string to be put into history buffer.
  ##
  ## Added support for a bug in debugger: preinit cannot be a subroutine ?!!!
  ## (See immendiately below)
  ##
  ## Added support for WINCH hooks. The subroutine references should be put into
  ## @winchhooks.
  ##
  ## Added F_ToggleInsertMode, F_HistorySearchBackward,
  ## F_HistorySearchForward, PC keyboard bindings.
  ## 0.93: Updates to Operate, couple of keybindings added.
  ## $rl_completer_terminator_character, $rl_correct_sw added.
  ## Reload-init-file moved to C-x C-x.
  ## C-x ? and C-x * list/insert possible completions.
  
  $rl_getc = \&rl_getc;
  
  &preinit;
  &init;
  
  # # # # use strict 'vars';
  
  # # # # # Separation into my and vars needs some thought...
  
  # # # # use vars qw(@KeyMap %KeyMap $rl_screen_width $rl_start_default_at_beginning
  # # # # 	    $rl_completion_function $rl_basic_word_break_characters
  # # # # 	    $rl_completer_word_break_characters $rl_special_prefixes
  # # # # 	    $rl_readline_name @rl_History $rl_MaxHistorySize
  # # # #             $rl_max_numeric_arg $rl_OperateCount
  # # # # 	    $KillBuffer $dumb_term $stdin_not_tty $InsertMode 
  # # # # 	    $rl_NoInitFromFile);
  
  # # # # my ($InputLocMsg, $term_OUT, $term_IN);
  # # # # my ($winsz_t, $TIOCGWINSZ, $winsz, $rl_margin, $hooj, $force_redraw);
  # # # # my ($hook, %var_HorizontalScrollMode, %var_EditingMode, %var_OutputMeta);
  # # # # my ($var_HorizontalScrollMode, $var_EditingMode, $var_OutputMeta);
  # # # # my (%var_ConvertMeta, $var_ConvertMeta, %var_MarkModifiedLines, $var_MarkModifiedLines);
  # # # # my ($term_readkey, $inDOS);
  # # # # my (%var_PreferVisibleBell, $var_PreferVisibleBell);
  # # # # my (%var_TcshCompleteMode, $var_TcshCompleteMode);
  # # # # my (%var_CompleteAddsuffix, $var_CompleteAddsuffix);
  # # # # my ($minlength, @winchhooks);
  # # # # my ($BRKINT, $ECHO, $FIONREAD, $ICANON, $ICRNL, $IGNBRK, $IGNCR, $INLCR,
  # # # #     $ISIG, $ISTRIP, $NCCS, $OPOST, $RAW, $TCGETS, $TCOON, $TCSETS, $TCXONC,
  # # # #     $TERMIOS_CFLAG, $TERMIOS_IFLAG, $TERMIOS_LFLAG, $TERMIOS_NORMAL_IOFF,
  # # # #     $TERMIOS_NORMAL_ION, $TERMIOS_NORMAL_LOFF, $TERMIOS_NORMAL_LON, 
  # # # #     $TERMIOS_NORMAL_OOFF, $TERMIOS_NORMAL_OON, $TERMIOS_OFLAG, 
  # # # #     $TERMIOS_READLINE_IOFF, $TERMIOS_READLINE_ION, $TERMIOS_READLINE_LOFF, 
  # # # #     $TERMIOS_READLINE_LON, $TERMIOS_READLINE_OOFF, $TERMIOS_READLINE_OON, 
  # # # #     $TERMIOS_VMIN, $TERMIOS_VTIME, $TIOCGETP, $TIOCGWINSZ, $TIOCSETP, 
  # # # #     $fion, $fionread_t, $mode, $sgttyb_t, 
  # # # #     $termios, $termios_t, $winsz, $winsz_t);
  # # # # my ($line, $initialized, $term_readkey);
  
  
  # # # # # Global variables added for vi mode (I'm leaving them all commented
  # # # # #     out, like the declarations above, until SelfLoader issues
  # # # # #     are resolved).
  
  # # # # # True when we're in one of the vi modes.
  # # # # my $Vi_mode;
  
  # # # # # Array refs: saves keystrokes for '.' command.  Undefined when we're
  # # # # #     not doing a '.'-able command.
  # # # # my $Dot_buf;                # Working buffer
  # # # # my $Last_vi_command;        # Gets $Dot_buf when a command is parsed
  
  # # # # # These hold state for vi 'u' and 'U'.
  # # # # my($Dot_state, $Vi_undo_state, $Vi_undo_all_state);
  
  # # # # # Refs to hashes used for cursor movement
  # # # # my($Vi_delete_patterns, $Vi_move_patterns,
  # # # #    $Vi_change_patterns, $Vi_yank_patterns);
  
  # # # # # Array ref: holds parameters from the last [fFtT] command, for ';'
  # # # # #     and ','.
  # # # # my $Last_findchar;
  
  # # # # # Globals for history search commands (/, ?, n, N)
  # # # # my $Vi_search_re;       # Regular expression (compiled by qr{})
  # # # # my $Vi_search_reverse;  # True for '?' search, false for '/'
  
  
  ##
  ## What's Cool
  ## ----------------------------------------------------------------------
  ## * hey, it's in perl.
  ## * Pretty full GNU readline like library...
  ## *	support for ~/.inputrc
  ## *    horizontal scrolling
  ## *	command/file completion
  ## *	rebinding
  ## *	history (with search)
  ## *	undo
  ## *	numeric prefixes
  ## * supports multi-byte characters (at least for the Japanese I use).
  ## * Has a tcsh-like completion-function mode.
  ##     call &readline'rl_set('tcsh-complete-mode', 'On') to turn on.
  ##
  
  ##
  ## What's not Cool
  ## ----------------------------------------------------------------------
  ## Can you say HUGE?
  ## I can't spell, so comments riddled with misspellings.
  ## Written by someone that has never really used readline.
  ## History mechanism is slightly different than GNU... may get fixed
  ##     someday, but I like it as it is now...
  ## Killbuffer not a ring.. just one level.
  ## Obviously not well tested yet.
  ## Written by someone that doesn't have a bell on his terminal, so
  ##     proper readline use of the bell may not be here.
  ##
  
  
  ##
  ## Functions beginning with F_ are functions that are mapped to keys.
  ## Variables and functions beginning rl_ may be accessed/set/called/read
  ## from outside the package.  Other things are internal.
  ##
  ## Some notable internal-only variables of global proportions:
  ##   $prompt -- line prompt (passed from user)
  ##   $line  -- the line being input
  ##   $D     -- ``Dot'' -- index into $line of the cursor's location.
  ##   $InsertMode -- usually true. False means overwrite mode.
  ##   $InputLocMsg -- string for error messages, such as "[~/.inputrc line 2]"
  ##   *emacs_keymap -- keymap for emacs-mode bindings:
  ##	@emacs_keymap - bindings indexed by ASCII ordinal
  ##      $emacs_keymap{'name'} = "emacs_keymap"
  ##      $emacs_keymap{'default'} = "SelfInsert"  (default binding)
  ##   *vi_keymap -- keymap for vi input mode bindings
  ##   *vicmd_keymap -- keymap for vi command mode bindings
  ##   *vipos_keymap -- keymap for vi positioning command bindings
  ##   *visearch_keymap -- keymap for vi search pattern input mode bindings
  ##   *KeyMap -- current keymap in effect.
  ##   $LastCommandKilledText -- needed so that subsequent kills accumulate
  ##   $lastcommand -- name of command previously run
  ##   $lastredisplay -- text placed upon screen during previous &redisplay
  ##   $si -- ``screen index''; index into $line of leftmost char &redisplay'ed
  ##   $force_redraw -- if set to true, causes &redisplay to be verbose.
  ##   $AcceptLine -- when set, its value is returned from &readline.
  ##   $ReturnEOF -- unless this also set, in which case undef is returned.
  ##   @Pending -- characters to be used as input.
  ##   @undo -- array holding all states of current line, for undoing.
  ##   $KillBuffer -- top of kill ring (well, don't have a kill ring yet)
  ##   @tcsh_complete_selections -- for tcsh mode, possible selections
  ##
  ## Some internal variables modified by &rl_set (see comment at &rl_set for
  ## info about how these set'able variables work)
  ##   $var_EditingMode -- a keymap typeglob like *emacs_keymap or *vi_keymap
  ##   $var_TcshCompleteMode -- if true, the completion function works like
  ##      in tcsh.  That is, the first time you try to complete something,
  ##	the common prefix is completed for you. Subsequent completion tries
  ##	(without other commands in between) cycles the command line through
  ##	the various possibilities.  If/when you get the one you want, just
  ##	continue typing.
  ## Other $var_ things not supported yet.
  ##
  ## Some variables used internally, but may be accessed from outside...
  ##   $VERSION -- just for good looks.
  ##   $rl_readline_name = name of program -- for .initrc if/endif stuff.
  ##   $rl_NoInitFromFile -- if defined when package is require'd, ~/.inputrc
  ##  	will not be read.
  ##   @rl_History -- array of previous lines input
  ##   $rl_HistoryIndex -- history pointer (for moving about history array)
  ##   $rl_completion_function -- see "How Command Completion Works" (way) below.
  ##   $rl_basic_word_break_characters -- string of characters that can cause
  ##	a word break for forward-word, etc.
  ##   $rl_start_default_at_beginning --
  ##	Normally, the user's cursor starts at the end of any default text
  ##	passed to readline.  If this variable is true, it starts at the
  ##	beginning.
  ##   $rl_completer_word_break_characters --
  ##	like $rl_basic_word_break_characters (and in fact defaults to it),
  ##	but for the completion function.
  ##   $rl_completer_terminator_character -- what to insert to separate
  ##      a completed token from the rest.  Reset at beginning of
  ##      completion to ' ' so completion function can change it.
  ##   $rl_special_prefixes -- characters that are part of this string as well
  ##      as of $rl_completer_word_break_characters cause a word break for the
  ##	completer function, but remain part of the word.  An example: consider
  ##      when the input might be perl code, and one wants to be able to
  ##      complete on variable and function names, yet still have the '$',
  ##	'&', '@',etc. part of the $text to be completed. Then set this var
  ## 	to '&@$%' and make sure each of these characters is in
  ## 	$rl_completer_word_break_characters as well....
  ##   $rl_MaxHistorySize -- maximum size that the history array may grow.
  ##   $rl_screen_width -- width readline thinks it can use on the screen.
  ##   $rl_correct_sw -- is substructed from the real width of the terminal
  ##   $rl_margin -- scroll by moving to within this far from a margin.
  ##   $rl_CLEAR -- what to output to clear the screen.
  ##   $rl_max_numeric_arg -- maximum numeric arg allowed.
  ##   $rl_vi_replace_default_on_insert
  ##     Normally, the text you enter is added to any default text passed to
  ##     readline.  If this variable is true, default text will start out 
  ##     highlighted (if supported by your terminal) and text entered while the 
  ##     default is highlighted (during the _first_ insert mode only) will 
  ##     replace the entire default line.  Once you have left insert mode (hit 
  ##     escape), everything works as normal.  
  ##     - This is similar to many GUI controls' behavior, which select the 
  ##       default text so that new text replaces the old.
  ##     - Use with $rl_start_default_at_beginning for normal-looking behavior
  ##       (though it works just fine without it).
  ##     Notes/Bugs: 
  ##     - Control characters (like C-w) do not actually terminate this replace
  ##       mode, for the same reason it does not work in emacs mode.
  ##     - Spine-crawlingly scary subroutine redefinitions
  ##   $rl_mark - start of the region
  ##   $line_rl_mark - the line on which $rl_mark is active
  ##   $_rl_japanese_mb - For character movement suppose Japanese (which?!)
  ##     multi-byte encoding.  (How to make a sane default?)
  ##
  
  sub get_window_size
  {
      my $sig = shift;
      local($., $@, $!, $^E, $?);		# Preserve $! etc; the rest for hooks
      my ($num_cols,$num_rows);
  
      if (defined $term_readkey) {
  	 ($num_cols,$num_rows) =  Term::ReadKey::GetTerminalSize($term_OUT);
  	 $rl_screen_width = $num_cols - $rl_correct_sw
  	   if defined($num_cols) && $num_cols;
      } elsif (defined $TIOCGWINSZ and &ioctl($term_IN,$TIOCGWINSZ,$winsz)) {
  	 ($num_rows,$num_cols) = unpack($winsz_t,$winsz);
  	 $rl_screen_width = $num_cols - $rl_correct_sw
  	   if defined($num_cols) && $num_cols;
      }
      $rl_margin = int($rl_screen_width/3);
      if (defined $sig) {
  	$force_redraw = 1;
  	&redisplay();
      }
  
      for $hook (@winchhooks) {
        eval {&$hook()}; warn $@ if $@ and $^W;
      }
      local $^W = 0;		# WINCH may be illegal...
      $SIG{'WINCH'} = "readline::get_window_size";
  }
  
  # Fix: case-sensitivity of inputrc on/off keywords in
  #      `set' commands. readline lib doesn't care about case.
  # changed case of keys 'On' and 'Off' to 'on' and 'off'
  # &rl_set changed so that it converts the value to
  # lower case before hash lookup.
  sub preinit
  {
      ## Set up the input and output handles
  
      $term_IN = \*STDIN unless defined $term_IN;
      $term_OUT = \*STDOUT unless defined $term_OUT;
      ## not yet supported... always on.
      $var_HorizontalScrollMode = 1;
      $var_HorizontalScrollMode{'On'} = 1;
      $var_HorizontalScrollMode{'Off'} = 0;
  
      $var_EditingMode{'emacs'}    = *emacs_keymap;
      $var_EditingMode{'vi'}       = *vi_keymap;
      $var_EditingMode{'vicmd'}    = *vicmd_keymap;
      $var_EditingMode{'vipos'}    = *vipos_keymap;
      $var_EditingMode{'visearch'} = *visearch_keymap;
  
      ## this is an addition. Very nice.
      $var_TcshCompleteMode = 0;
      $var_TcshCompleteMode{'On'} = 1;
      $var_TcshCompleteMode{'Off'} = 0;
  
      $var_CompleteAddsuffix = 1;
      $var_CompleteAddsuffix{'On'} = 1;
      $var_CompleteAddsuffix{'Off'} = 0;
  
      $var_DeleteSelection = $var_DeleteSelection{'On'} = 1;
      $var_DeleteSelection{'Off'} = 0;
      *rl_delete_selection = \$var_DeleteSelection; # Alias
  
      ## not yet supported... always on
      for ('InputMeta', 'OutputMeta') {
  	${"var_$_"} = 1;
  	${"var_$_"}{'Off'} = 0;
  	${"var_$_"}{'On'} = 1;
      }
  
      ## not yet supported... always off
      for ('ConvertMeta', 'MetaFlag', 'MarkModifiedLines', 'PreferVisibleBell',
  	 'BlinkMatchingParen', 'VisibleStats', 'ShowAllIfAmbiguous',
  	 'PrintCompletionsHorizontally', 'MarkDirectories', 'ExpandTilde',
  	 'EnableKeypad', 'DisableCompletion', 'CompletionIgnoreCase') {
  	${"var_$_"} = 0;
  	${"var_$_"}{'Off'} = 0;
  	${"var_$_"}{'On'} = 1;
      }
  
      # To conform to interface
      $minlength = 1 unless defined $minlength;
  
      # WINCH hooks
      @winchhooks = ();
  
      $inDOS = $^O eq 'os2' || defined $ENV{OS2_SHELL} unless defined $inDOS;
      eval {
        require Term::ReadKey; $term_readkey++;
      } unless defined $ENV{PERL_RL_USE_TRK}
  	     and not $ENV{PERL_RL_USE_TRK};
      unless ($term_readkey) {
        eval {require "ioctl.pl"}; ## try to get, don't die if not found.
        eval {require "sys/ioctl.ph"}; ## try to get, don't die if not found.
        eval {require "sgtty.ph"}; ## try to get, don't die if not found.
        if ($inDOS and !defined $TIOCGWINSZ) {
  	  $TIOCGWINSZ=0;
  	  $TIOCGETP=1;
  	  $TIOCSETP=2;
  	  $sgttyb_t="I5 C8";
  	  $winsz_t="";
  	  $RAW=0xf002;
  	  $ECHO=0x0008;
        }
        $TIOCGETP = &TIOCGETP if defined(&TIOCGETP);
        $TIOCSETP = &TIOCSETP if defined(&TIOCSETP);
        $TIOCGWINSZ = &TIOCGWINSZ if defined(&TIOCGWINSZ);
        $FIONREAD = &FIONREAD if defined(&FIONREAD);
        $TCGETS = &TCGETS if defined(&TCGETS);
        $TCSETS = &TCSETS if defined(&TCSETS);
        $TCXONC = &TCXONC if defined(&TCXONC);
        $TIOCGETP   = 0x40067408 if !defined($TIOCGETP);
        $TIOCSETP   = 0x80067409 if !defined($TIOCSETP);
        $TIOCGWINSZ = 0x40087468 if !defined($TIOCGWINSZ);
        $FIONREAD   = 0x4004667f if !defined($FIONREAD);
        $TCGETS     = 0x40245408 if !defined($TCGETS);
        $TCSETS     = 0x80245409 if !defined($TCSETS);
        $TCXONC     = 0x20005406 if !defined($TCXONC);
  
        ## TTY modes
        $ECHO = &ECHO if defined(&ECHO);
        $RAW = &RAW if defined(&RAW);
        $RAW	= 040 if !defined($RAW);
        $ECHO	= 010 if !defined($ECHO);
        #$CBREAK    = 002 if !defined($CBREAK);
        $mode = $RAW; ## could choose CBREAK for testing....
  
        $IGNBRK     = 1 if !defined($IGNBRK);
        $BRKINT     = 2 if !defined($BRKINT);
        $ISTRIP     = 040 if !defined($ISTRIP);
        $INLCR      = 0100 if !defined($INLCR);
        $IGNCR      = 0200 if !defined($IGNCR);
        $ICRNL      = 0400 if !defined($ICRNL);
        $OPOST      = 1 if !defined($OPOST);
        $ISIG       = 1 if !defined($ISIG);
        $ICANON     = 2 if !defined($ICANON);
        $TCOON      = 1 if !defined($TCOON);
        $TERMIOS_READLINE_ION = $BRKINT;
        $TERMIOS_READLINE_IOFF = $IGNBRK | $ISTRIP | $INLCR | $IGNCR | $ICRNL;
        $TERMIOS_READLINE_OON = 0;
        $TERMIOS_READLINE_OOFF = $OPOST;
        $TERMIOS_READLINE_LON = 0;
        $TERMIOS_READLINE_LOFF = $ISIG | $ICANON | $ECHO;
        $TERMIOS_NORMAL_ION = $BRKINT;
        $TERMIOS_NORMAL_IOFF = $IGNBRK;
        $TERMIOS_NORMAL_OON = $OPOST;
        $TERMIOS_NORMAL_OOFF = 0;
        $TERMIOS_NORMAL_LON = $ISIG | $ICANON | $ECHO;
        $TERMIOS_NORMAL_LOFF = 0;
  
        #$sgttyb_t   = 'C4 S';
        #$winsz_t = "S S S S";  # rows,cols, xpixel, ypixel
        $sgttyb_t   = 'C4 S' if !defined($sgttyb_t);
        $winsz_t = "S S S S" if !defined($winsz_t);  
        # rows,cols, xpixel, ypixel
        $winsz = pack($winsz_t,0,0,0,0);
        $fionread_t = "L";
        $fion = pack($fionread_t, 0);
        $NCCS = 17;
        $termios_t = "LLLLc" . ("c" x $NCCS);  # true for SunOS 4.1.3, at least...
        $termios = ''; ## just to shut up "perl -w".
        $termios = pack($termios, 0);  # who cares, just make it long enough
        $TERMIOS_IFLAG = 0;
        $TERMIOS_OFLAG = 1;
        $TERMIOS_CFLAG = 2;
        $TERMIOS_LFLAG = 3;
        $TERMIOS_VMIN = 5 + 4;
        $TERMIOS_VTIME = 5 + 5;
      }
      $rl_delete_selection = 1;
      $rl_correct_sw = ($inDOS ? 1 : 0);
      $rl_scroll_nextline = 1 unless defined $rl_scroll_nextline;
      $rl_last_pos_can_backspace = ($inDOS ? 0 : 1) # Can backspace when the 
        unless defined $rl_last_pos_can_backspace;  # whole line is filled?
  
      $rl_start_default_at_beginning = 0;
      $rl_vi_replace_default_on_insert = 0;
      $rl_screen_width = 79; ## default
  
      $rl_completion_function = "rl_filename_list"
  	unless defined($rl_completion_function);
      $rl_basic_word_break_characters = "\\\t\n' \"`\@\$><=;|&{(";
      $rl_completer_word_break_characters = $rl_basic_word_break_characters;
      $rl_special_prefixes = '';
      ($rl_readline_name = $0) =~ s#.*[/\\]## if !defined($rl_readline_name);
  
      @rl_History=() if !(@rl_History);
      $rl_MaxHistorySize = 100 if !defined($rl_MaxHistorySize);
      $rl_max_numeric_arg = 200 if !defined($rl_max_numeric_arg);
      $rl_OperateCount = 0 if !defined($rl_OperateCount);
  
      $rl_term_set = \@Term::ReadLine::TermCap::rl_term_set;
      @$rl_term_set or $rl_term_set = ["","","",""];
  
      $InsertMode=1;
      $KillBuffer='';
      $line='';
      $D = 0;
      $InputLocMsg = ' [initialization]';
  
      &InitKeymap(*emacs_keymap, 'SelfInsert', 'emacs_keymap',
  		($inDOS ? () : ('C-@',	'SetMark') ),
  		'C-a',	'BeginningOfLine',
  		'C-b',	'BackwardChar',
  		'C-c',	'Interrupt',
  		'C-d',	'DeleteChar',
  		'C-e',	'EndOfLine',
  		'C-f',	'ForwardChar',
  		'C-g',	'Abort',
  		'M-C-g',	'Abort',
  		'C-h',	'BackwardDeleteChar',
  		"TAB" ,	'Complete',
  		"C-j" ,	'AcceptLine',
  		'C-k',	'KillLine',
  		'C-l',	'ClearScreen',
  		"C-m" ,	'AcceptLine',
  		'C-n',	'NextHistory',
  		'C-o',  'OperateAndGetNext',
  		'C-p',	'PreviousHistory',
  		'C-q',	'QuotedInsert',
  		'C-r',	'ReverseSearchHistory',
  		'C-s',	'ForwardSearchHistory',
  		'C-t',	'TransposeChars',
  		'C-u',	'UnixLineDiscard',
  		##'C-v',	'QuotedInsert',
  		'C-v',	'HistorySearchForward',
  		'C-w',	'UnixWordRubout',
  		qq/"\cX\cX"/,	'ExchangePointAndMark',
  		qq/"\cX\cR"/,	'ReReadInitFile',
  		qq/"\cX?"/,	'PossibleCompletions',
  		qq/"\cX*"/,	'InsertPossibleCompletions',
  		qq/"\cX\cU"/,	'Undo',
  		qq/"\cXu"/,	'Undo',
  		qq/"\cX\cW"/,	'KillRegion',
  		qq/"\cXw"/,	'CopyRegionAsKill',
  		qq/"\cX\ec\\*"/,	'DoControlVersion',
  		qq/"\cX\ec\0"/,	'SetMark',
  		qq/"\cX\ec\@"/,	'SetMark',
  		qq/"\cX\ec "/,	'SetMark',
  		qq/"\cX\em\\*"/,	'DoMetaVersion',
  		qq/"\cX\@c\\*"/,	'DoControlVersion',
  		qq/"\cX\@c\0"/,	'SetMark',
  		qq/"\cX\@c\@"/,	'SetMark',
  		qq/"\cX\@c "/,	'SetMark',
  		qq/"\cX\@m\\*"/,	'DoMetaVersion',
  		'C-y',	'Yank',
  		'C-z',	'Suspend',
  		'C-\\',	'Ding',
  		'C-^',	'Ding',
  		'C-_',	'Undo',
  		'DEL',	($inDOS ?
  			 'BackwardKillWord' : # <Control>+<Backspace>
  			 'BackwardDeleteChar'
  			),
  		'M-<',	'BeginningOfHistory',
  		'M->',	'EndOfHistory',
  		'M-DEL',	'BackwardKillWord',
  		'M-C-h',	'BackwardKillWord',
  		'M-C-j',	'ViInput',
  		'M-C-v',	'QuotedInsert',
  		'M-b',	'BackwardWord',
  		'M-c',	'CapitalizeWord',
  		'M-d',	'KillWord',
  		'M-f',	'ForwardWord',
  		'M-h',	'PrintHistory',
  		'M-l',	'DownCaseWord',
  		'M-r',	'RevertLine',
  		'M-t',	'TransposeWords',
  		'M-u',	'UpcaseWord',
  		'M-v',	'HistorySearchBackward',
  		'M-y',	'YankPop',
  		"M-?",	'PossibleCompletions',
  		"M-TAB",	'TabInsert',
  		'M-#',	'SaveLine',
  		qq/"\e[A"/,  'previous-history',
  		qq/"\e[B"/,  'next-history',
  		qq/"\e[C"/,  'forward-char',
  		qq/"\e[D"/,  'backward-char',
  		qq/"\eOA"/,  'previous-history',
  		qq/"\eOB"/,  'next-history',
  		qq/"\eOC"/,  'forward-char',
  		qq/"\eOD"/,  'backward-char',
  		qq/"\eOy"/,  'HistorySearchBackward',	# vt: PageUp
  		qq/"\eOs"/,  'HistorySearchForward',	# vt: PageDown
  		qq/"\e[[A"/,  'previous-history',
  		qq/"\e[[B"/,  'next-history',
  		qq/"\e[[C"/,  'forward-char',
  		qq/"\e[[D"/,  'backward-char',
  		qq/"\e[2~"/,   'ToggleInsertMode', # X: <Insert>
  		# Mods: 1 + bitmask: 1 Shift, 2 Alt, 4 Control, 8 (sometimes) Meta
  		qq/"\e[2;2~"/,  'YankClipboard',    # <Shift>+<Insert>
  		qq/"\e[3;2~"/,  'KillRegionClipboard',    # <Shift>+<Delete>
  		#qq/"\0\16"/, 'Undo', # <Alt>+<Backspace>
  		qq/"\eO5D"/, 'BackwardWord', # <Ctrl>+<Left arrow>
  		qq/"\eO5C"/, 'ForwardWord', # <Ctrl>+<Right arrow>
  		qq/"\e[5D"/, 'BackwardWord', # <Ctrl>+<Left arrow>
  		qq/"\e[5C"/, 'ForwardWord', # <Ctrl>+<Right arrow>
  		qq/"\eO5F"/, 'KillLine', # <Ctrl>+<End>
  		qq/"\e[5F"/, 'KillLine', # <Ctrl>+<End>
  		qq/"\e[4;5~"/, 'KillLine', # <Ctrl>+<End>
  		qq/"\eO5s"/, 'EndOfHistory', # <Ctrl>+<Page Down>
  		qq/"\e[6;5~"/, 'EndOfHistory', # <Ctrl>+<Page Down>
  		qq/"\e[5H"/, 'BackwardKillLine', # <Ctrl>+<Home>
  		qq/"\eO5H"/, 'BackwardKillLine', # <Ctrl>+<Home>
  		qq/"\e[1;5~"/, 'BackwardKillLine', # <Ctrl>+<Home>
  		qq/"\eO5y"/, 'BeginningOfHistory', # <Ctrl>+<Page Up>
  		qq/"\e[5;5y"/, 'BeginningOfHistory', # <Ctrl>+<Page Up>
  		qq/"\e[2;5~"/, 'CopyRegionAsKillClipboard', # <Ctrl>+<Insert>
  		qq/"\e[3;5~"/, 'KillWord', # <Ctrl>+<Delete>
  
  		# XTerm mouse editing (f202/f203 not in mainstream yet):
  		# Paste may be:         move f200 STRING f201
  		# or		   f202 move f200 STRING f201 f203;
  		# and Cut may be   f202 move delete f203
  		qq/"\e[200~"/, 'BeginPasteGroup', # Pre-paste
  		qq/"\e[201~"/, 'EndPasteGroup', # Post-paste
  		qq/"\e[202~"/, 'BeginEditGroup', # Pre-edit
  		qq/"\e[203~"/, 'EndEditGroup', # Post-edit
  
  		# OSX xterm:
  		# OSX xterm: home \eOH end \eOF delete \e[3~ help \e[28~ f13 \e[25~
  		# gray- \eOm gray+ \eOk gray-enter \eOM gray* \eOj gray/ \eOo gray= \eO
  		# grayClear \e\e.
  
  		qq/"\eOH"/,   'BeginningOfLine',        # home
  		qq/"\eOF"/,   'EndOfLine',        	# end
  
  		# HP xterm
  		#qq/"\e[A"/,   'PreviousHistory',	# up    arrow
  		#qq/"\e[B"/,   'NextHistory',		# down  arrow
  		#qq/"\e[C"/,   'ForwardChar',		# right arrow
  		#qq/"\e[D"/,   'BackwardChar',		# left  arrow
  		qq/"\e[H"/,   'BeginningOfLine',        # home
  		#'C-k',        'KillLine',		# clear display
  		qq/"\e[5~"/,  'HistorySearchBackward',	# prev
  		qq/"\e[6~"/,  'HistorySearchForward',	# next
  		qq/"\e[\0"/,  'BeginningOfLine',	# home
  
  		# These contradict:
  		($^O =~ /^hp\W?ux/i ? (
  		  qq/"\e[1~"/,  'HistorySearchForward',   # find
  		  qq/"\e[3~"/,  'ToggleInsertMode',	# insert char
  		  qq/"\e[4~"/,  'ToggleInsertMode',	# select
  		 ) : (		# "Normal" xterm
  		  qq/"\e[1~"/,  'BeginningOfLine',	# home
  		  qq/"\e[3~"/,  'DeleteChar',		# delete
  		  qq/"\e[4~"/,  'EndOfLine',	# end
  		)),
  
  		# hpterm
  
  		(($ENV{'TERM'} and $ENV{'TERM'} eq 'hpterm') ?
  		 (
  		  qq/"\eA"/,    'PreviousHistory',     # up    arrow
  		  qq/"\eB"/,    'NextHistory',	       # down  arrow
  		  qq/"\eC"/,    'ForwardChar',	       # right arrow
  		  qq/"\eD"/,    'BackwardChar',	       # left  arrow
  		  qq/"\eS"/,    'BeginningOfHistory',  # shift up    arrow
  		  qq/"\eT"/,    'EndOfHistory',	       # shift down  arrow
  		  qq/"\e&r1R"/, 'EndOfLine',	       # shift right arrow
  		  qq/"\e&r1L"/, 'BeginningOfLine',     # shift left  arrow
  		  qq/"\eJ"/,    'ClearScreen',	       # clear display
  		  qq/"\eM"/,    'UnixLineDiscard',     # delete line
  		  qq/"\eK"/,    'KillLine',	       # clear  line
  		  qq/"\eG\eK"/, 'BackwardKillLine',    # shift clear line
  		  qq/"\eP"/,    'DeleteChar',	       # delete char
  		  qq/"\eL"/,    'Yank',		       # insert line
  		  qq/"\eQ"/,    'ToggleInsertMode',    # insert char
  		  qq/"\eV"/,    'HistorySearchBackward',# prev
  		  qq/"\eU"/,    'HistorySearchForward',# next
  		  qq/"\eh"/,    'BeginningOfLine',     # home
  		  qq/"\eF"/,    'EndOfLine',	       # shift home
  		  qq/"\ei"/,    'Suspend',	       # shift tab
  		 ) :
  		 ()
  		),
  		($inDOS ?
  		 (
  		  qq/"\0\2"/,  'SetMark', # 2: <Control>+<Space>
  		  qq/"\0\3"/,  'SetMark', # 3: <Control>+<@>
  		  qq/"\0\4"/,  'YankClipboard',    # 4: <Shift>+<Insert>
  		  qq/"\0\5"/,  'KillRegionClipboard',    # 5: <Shift>+<Delete>
  		  qq/"\0\16"/, 'Undo', # 14: <Alt>+<Backspace>
  #		  qq/"\0\23"/, 'RevertLine', # 19: <Alt>+<R>
  #		  qq/"\0\24"/, 'TransposeWords', # 20: <Alt>+<T>
  #		  qq/"\0\25"/, 'YankPop', # 21: <Alt>+<Y>
  #		  qq/"\0\26"/, 'UpcaseWord', # 22: <Alt>+<U>
  #		  qq/"\0\31"/, 'ReverseSearchHistory', # 25: <Alt>+<P>
  #		  qq/"\0\40"/, 'KillWord', # 32: <Alt>+<D>
  #		  qq/"\0\41"/, 'ForwardWord', # 33: <Alt>+<F>
  #		  qq/"\0\46"/, 'DownCaseWord', # 38: <Alt>+<L>
  		  #qq/"\0\51"/, 'TildeExpand', # 41: <Alt>+<\'>
  #		  qq/"\0\56"/, 'CapitalizeWord', # 46: <Alt>+<C>
  #		  qq/"\0\60"/, 'BackwardWord', # 48: <Alt>+<B>
  #		  qq/"\0\61"/, 'ForwardSearchHistory', # 49: <Alt>+<N>
  		  #qq/"\0\64"/, 'YankLastArg', # 52: <Alt>+<.>
  		  qq/"\0\65"/,  'PossibleCompletions', # 53: <Alt>+</>
  		  qq/"\0\107"/, 'BeginningOfLine', # 71: <Home>
  		  qq/"\0\110"/, 'previous-history', # 72: <Up arrow>
  		  qq/"\0\111"/, 'HistorySearchBackward', # 73: <Page Up>
  		  qq/"\0\113"/, 'backward-char', # 75: <Left arrow>
  		  qq/"\0\115"/, 'forward-char', # 77: <Right arrow>
  		  qq/"\0\117"/, 'EndOfLine', # 79: <End>
  		  qq/"\0\120"/, 'next-history', # 80: <Down arrow>
  		  qq/"\0\121"/, 'HistorySearchForward', # 81: <Page Down>
  		  qq/"\0\122"/, 'ToggleInsertMode', # 82: <Insert>
  		  qq/"\0\123"/, 'DeleteChar', # 83: <Delete>
  		  qq/"\0\163"/, 'BackwardWord', # 115: <Ctrl>+<Left arrow>
  		  qq/"\0\164"/, 'ForwardWord', # 116: <Ctrl>+<Right arrow>
  		  qq/"\0\165"/, 'KillLine', # 117: <Ctrl>+<End>
  		  qq/"\0\166"/, 'EndOfHistory', # 118: <Ctrl>+<Page Down>
  		  qq/"\0\167"/, 'BackwardKillLine', # 119: <Ctrl>+<Home>
  		  qq/"\0\204"/, 'BeginningOfHistory', # 132: <Ctrl>+<Page Up>
  		  qq/"\0\x92"/, 'CopyRegionAsKillClipboard', # 146: <Ctrl>+<Insert>
  		  qq/"\0\223"/, 'KillWord', # 147: <Ctrl>+<Delete>
  		  qq/"\0#"/, 'PrintHistory', # Alt-H
  		 )
  		 : ( 'C-@',	'Ding')
  		)
  	       );
  
      *KeyMap = *emacs_keymap;
      my @add_bindings = ();
      foreach ('-', '0' .. '9') { push(@add_bindings, "M-$_", 'DigitArgument'); }
      foreach ("A" .. "Z") {
        next if  # defined($KeyMap[27]) && defined (%{"$KeyMap{name}_27"}) &&
  	defined $ {"$KeyMap{name}_27"}[ord $_];
        push(@add_bindings, "M-$_", 'DoLowercaseVersion');
      }
      if ($inDOS) {
  	# Default translation of Alt-char
  	$ {"$KeyMap{name}_0"}{'Esc'} = *{"$KeyMap{name}_27"};
  	$ {"$KeyMap{name}_0"}{'default'} = 'F_DoEscVersion';
      }
      &rl_bind(@add_bindings);
      
      # Vi input mode.
      &InitKeymap(*vi_keymap, 'SelfInsert', 'vi_keymap',
  
  		"\e",	'ViEndInsert',
  		'C-c',	'Interrupt',
  		'C-h',	'BackwardDeleteChar',
  		'C-w',	'UnixWordRubout',
  		'C-u',	'UnixLineDiscard',
  		'C-v',	'QuotedInsert',
  		'DEL',	'BackwardDeleteChar',
  		"\n",	'ViAcceptInsert',
  		"\r",	'ViAcceptInsert',
  	       );
  
      # Vi command mode.
      &InitKeymap(*vicmd_keymap, 'Ding', 'vicmd_keymap',
  
  		'C-c',	'Interrupt',
  		'C-e',	'EmacsEditingMode',
  		'C-h',	'ViMoveCursor',
  		'C-l',	'ClearScreen',
  		"\n",	'ViAcceptLine',
  		"\r",	'ViAcceptLine',
  
  		' ',	'ViMoveCursor',
  		'#',	'SaveLine',
  		'$',	'ViMoveCursor',
  		'%',	'ViMoveCursor',
  		'*',    'ViInsertPossibleCompletions',
  		'+',	'NextHistory',
  		',',	'ViMoveCursor',
  		'-',	'PreviousHistory',
  		'.',	'ViRepeatLastCommand',
  		'/',	'ViSearch',
  
  		'0',	'ViMoveCursor',
  		'1',	'ViDigit',
  		'2',	'ViDigit',
  		'3',	'ViDigit',
  		'4',	'ViDigit',
  		'5',	'ViDigit',
  		'6',	'ViDigit',
  		'7',	'ViDigit',
  		'8',	'ViDigit',
  		'9',	'ViDigit',
  
  		';',	'ViMoveCursor',
  		'=',    'ViPossibleCompletions',
  		'?',	'ViSearch',
  
  		'A',	'ViAppendLine',
  		'B',	'ViMoveCursor',
  		'C',	'ViChangeLine',
  		'D',	'ViDeleteLine',
  		'E',	'ViMoveCursor',
  		'F',	'ViMoveCursor',
  		'G',	'ViHistoryLine',
  		'H',	'PrintHistory',
  		'I',	'ViBeginInput',
  		'N',	'ViRepeatSearch',
  		'P',	'ViPutBefore',
  		'R',	'ViReplaceMode',
  		'S',	'ViChangeEntireLine',
  		'T',	'ViMoveCursor',
  		'U',	'ViUndoAll',
  		'W',	'ViMoveCursor',
  		'X',	'ViBackwardDeleteChar',
  		'Y',	'ViYankLine',
  
  		'\\',   'ViComplete',
  		'^',	'ViMoveCursor',
  
  		'a',	'ViAppend',
  		'b',	'ViMoveCursor',
  		'c',	'ViChange',
  		'd',	'ViDelete',
  		'e',	'ViMoveCursor',
  		'f',	'ViMoveCursorFind',
  		'h',	'ViMoveCursor',
  		'i',	'ViInput',
  		'j',	'NextHistory',
  		'k',	'PreviousHistory',
  		'l',	'ViMoveCursor',
  		'n',	'ViRepeatSearch',
  		'p',	'ViPut',
  		'r',	'ViReplaceChar',
  		's',	'ViChangeChar',
  		't',	'ViMoveCursorTo',
  		'u',	'ViUndo',
  		'w',	'ViMoveCursor',
  		'x',	'ViDeleteChar',
  		'y',	'ViYank',
  
  		'|',	'ViMoveCursor',
  		'~',	'ViToggleCase',
  
  		(($inDOS
  		  and (not $ENV{'TERM'} or $ENV{'TERM'} !~ /^(vt|xterm)/i)) ?
  		 (
  		  qq/"\0\110"/, 'PreviousHistory',   # 72: <Up arrow>
  		  qq/"\0\120"/, 'NextHistory',       # 80: <Down arrow>
  		  qq/"\0\113"/, 'BackwardChar',        # 75: <Left arrow>
  		  qq/"\0\115"/, 'ForwardChar',         # 77: <Right arrow>
  		  "\e",	        'ViCommandMode',
  		 ) :
  
  		 (('M-C-j','EmacsEditingMode'),	# Conflicts with \e otherwise
  		  (($ENV{'TERM'} and $ENV{'TERM'} eq 'hpterm') ?
  		   (
  		    qq/"\eA"/,    'PreviousHistory',   # up    arrow
  		    qq/"\eB"/,    'NextHistory',       # down  arrow
  		    qq/"\eC"/,    'ForwardChar',	       # right arrow
  		    qq/"\eD"/,    'BackwardChar',	       # left  arrow
  		    qq/"\e\\*"/,  'ViAfterEsc',
  		   ) :
  
  		   # Default
  		   (
  		    qq/"\e[A"/,   'PreviousHistory',	# up    arrow
  		    qq/"\e[B"/,   'NextHistory',	# down  arrow
  		    qq/"\e[C"/,   'ForwardChar',		# right arrow
  		    qq/"\e[D"/,   'BackwardChar',		# left  arrow
  		    qq/"\e\\*"/,  'ViAfterEsc', 
  		    qq/"\e[\\*"/, 'ViAfterEsc', 
  		   )
  		))),
  	       );
  
      # Vi positioning commands (suffixed to vi commands like 'd').
      &InitKeymap(*vipos_keymap, 'ViNonPosition', 'vipos_keymap',
  
  		'^',	'ViFirstWord',
  		'0',	'BeginningOfLine',
  		'1',	'ViDigit',
  		'2',	'ViDigit',
  		'3',	'ViDigit',
  		'4',	'ViDigit',
  		'5',	'ViDigit',
  		'6',	'ViDigit',
  		'7',	'ViDigit',
  		'8',	'ViDigit',
  		'9',	'ViDigit',
  		'$',	'EndOfLine',
  		'h',	'BackwardChar',
  		'l',	'ForwardChar',
  		' ',	'ForwardChar',
  		'C-h',	'BackwardChar',
  		'f',	'ViForwardFindChar',
  		'F',	'ViBackwardFindChar',
  		't',	'ViForwardToChar',
  		'T',	'ViBackwardToChar',
  		';',	'ViRepeatFindChar',
  		',',	'ViInverseRepeatFindChar',
  		'%',	'ViFindMatchingParens',
  		'|',	'ViMoveToColumn',
  
  		# Arrow keys
  		($inDOS ?
  		 (
  		  qq/"\0\115"/, 'ForwardChar',         # 77: <Right arrow>
  		  qq/"\0\113"/, 'BackwardChar',        # 75: <Left arrow>
  		  "\e",	        'ViPositionEsc',
  		 ) :
  
  		($ENV{'TERM'} and $ENV{'TERM'} eq 'hpterm') ?
  		 (
  		  qq/"\eC"/,    'ForwardChar',	       # right arrow
  		  qq/"\eD"/,    'BackwardChar',	       # left  arrow
  		  qq/"\e\\*"/,  'ViPositionEsc',
  		 ) :
  
  		# Default
  		 (
  		  qq/"\e[C"/,   'ForwardChar',		# right arrow
  		  qq/"\e[D"/,   'BackwardChar',		# left  arrow
  		  qq/"\e\\*"/,  'ViPositionEsc',
  		  qq/"\e[\\*"/, 'ViPositionEsc',
  		 )
  		),
  	       );
  
      # Vi search string input mode for '/' and '?'.
      &InitKeymap(*visearch_keymap, 'SelfInsert', 'visearch_keymap',
  
  		"\e",	'Ding',
  		'C-c',	'Interrupt',
  		'C-h',	'ViSearchBackwardDeleteChar',
  		'C-w',	'UnixWordRubout',
  		'C-u',	'UnixLineDiscard',
  		'C-v',	'QuotedInsert',
  		'DEL',	'ViSearchBackwardDeleteChar',
  		"\n",	'ViEndSearch',
  		"\r",	'ViEndSearch',
  	       );
  
      # These constant hashes hold the arguments to &forward_scan() or
      #     &backward_scan() for vi positioning commands, which all
      #     behave a little differently for delete, move, change, and yank.
      #
      # Note: I originally coded these as qr{}, but changed them to q{} for
      #       compatibility with older perls at the expense of some performance.
      #
      # Note: Some of the more obscure key combinations behave slightly
      #       differently in different vi implementation.  This module matches
      #       the behavior of /usr/ucb/vi, which is different from the
      #       behavior of vim, nvi, and the ksh command line.  One example is
      #       the command '2de', when applied to the string ('^' represents the
      #       cursor, not a character of the string):
      #
      #           ^5.6   7...88888888
      #
      #       With /usr/ucb/vi and with this module, the result is
      #
      #           ^...88888888
      #
      #       but with the other three vi implementations, the result is
      #
      #           ^   7...88888888
  
      $Vi_delete_patterns = {
  	ord('w')  =>  q{(?:\w+|[^\w\s]+|)\s*},
  	ord('W')  =>  q{\S*\s*},
  	ord('b')  =>  q{\w+\s*|[^\w\s]+\s*|^\s+},
  	ord('B')  =>  q{\S+\s*|^\s+},
  	ord('e')  =>  q{.\s*\w+|.\s*[^\w\s]+|.\s*$},
  	ord('E')  =>  q{.\s*\S+|.\s*$},
      };
  
      $Vi_move_patterns = {
  	ord('w')  =>  q{(?:\w+|[^\w\s]+|)\s*},
  	ord('W')  =>  q{\S*\s*},
  	ord('b')  =>  q{\w+\s*|[^\w\s]+\s*|^\s+},
  	ord('B')  =>  q{\S+\s*|^\s+},
  	ord('e')  =>  q{.\s*\w*(?=\w)|.\s*[^\w\s]*(?=[^\w\s])|.?\s*(?=\s$)},
  	ord('E')  =>  q{.\s*\S*(?=\S)|.?\s*(?=\s$)},
      };
  
      $Vi_change_patterns = {
  	ord('w')  =>  q{\w+|[^\w\s]+|\s},
  	ord('W')  =>  q{\S+|\s},
  	ord('b')  =>  q{\w+\s*|[^\w\s]+\s*|^\s+},
  	ord('B')  =>  q{\S+\s*|^\s+},
  	ord('e')  =>  q{.\s*\w+|.\s*[^\w\s]+|.\s*$},
  	ord('E')  =>  q{.\s*\S+|.\s*$},
      };
  
      $Vi_yank_patterns = {
  	ord('w')  =>  q{(?:\w+|[^\w\s]+|)\s*},
  	ord('W')  =>  q{\S*\s*},
  	ord('b')  =>  q{\w+\s*|[^\w\s]+\s*|^\s+},
  	ord('B')  =>  q{\S+\s*|^\s+},
  	ord('e')  =>  q{.\s*\w*(?=\w)|.\s*[^\w\s]*(?=[^\w\s])|.?\s*(?=\s$)},
  	ord('E')  =>  q{.\s*\S*(?=\S)|.?\s*(?=\s$)},
      };
  
      my $default_mode = 'emacs';
  
      *KeyMap = $var_EditingMode = $var_EditingMode{$default_mode};
  
  ##    my $name;
  ##    for $name ( keys %{'readline::'} ) {
  ##      # Create aliases accessible via tied interface
  ##      *{"rl_$1"} = \$ {"var_$1"} if $name =~ /$var_(.*)/;
  ##    }
  
      1;				# Returning a glob causes a bug in db5.001m
  }
  
  sub init
  {
      if ($ENV{'TERM'} and ($ENV{'TERM'} eq 'emacs' || $ENV{'TERM'} eq 'dumb')) {
  	$dumb_term = 1;
      } elsif (! -c $term_IN && $term_IN eq \*STDIN) { # Believe if it is given
      	$stdin_not_tty = 1;
      } else {
  	&get_window_size;
  	&F_ReReadInitFile if !defined($rl_NoInitFromFile);
  	$InputLocMsg = '';
  	*KeyMap = $var_EditingMode;
      }
  
      $initialized = 1;
  }
  
  
  ##
  ## InitKeymap(*keymap, 'default', 'name', bindings.....)
  ##
  sub InitKeymap
  {
      local(*KeyMap) = shift(@_);
      my $default = shift(@_);
      my $name = $KeyMap{'name'} = shift(@_);
  
      # 'default' is now optional - if '', &do_command() defaults it to
      #     'F_Ding'.  Meta-maps now don't set a default - this lets
      #     us detect multiple '\*' default declarations.              JP
      if ($default ne '') {
  	my $func = $KeyMap{'default'} = "F_$default";
  	### Temporarily disabled
  	die qq/Bad default function [$func] for keymap "$name"/
  	  if !$autoload_broken and !defined(&$func);
      }
  
      &rl_bind if @_ > 0;	## The rest of @_ gets passed silently.
  }
  
  ##
  ## Accepts an array as pairs ($keyspec, $function, [$keyspec, $function]...).
  ## and maps the associated bindings to the current KeyMap.
  ##
  ## keyspec should be the name of key sequence in one of two forms:
  ##
  ## Old (GNU readline documented) form:
  ##	     M-x	to indicate Meta-x
  ##	     C-x	to indicate Ctrl-x
  ##	     M-C-x	to indicate Meta-Ctrl-x
  ##	     x		simple char x
  ##      where 'x' above can be a single character, or the special:
  ##          special  	means
  ##         --------  	-----
  ##	     space	space   ( )
  ##	     spc	space   ( )
  ##	     tab	tab     (\t)
  ##	     del	delete  (0x7f)
  ##	     rubout	delete  (0x7f)
  ##	     newline 	newline (\n)
  ##	     lfd     	newline (\n)
  ##	     ret     	return  (\r)
  ##	     return  	return  (\r)
  ##	     escape  	escape  (\e)
  ##	     esc     	escape  (\e)
  ##
  ## New form:
  ##	  "chars"   (note the required double-quotes)
  ##   where each char in the list represents a character in the sequence, except
  ##   for the special sequences:
  ##	  \\C-x		Ctrl-x
  ##	  \\M-x		Meta-x
  ##	  \\M-C-x	Meta-Ctrl-x
  ##	  \\e		escape.
  ##	  \\x		x (if not one of the above)
  ##
  ##
  ## FUNCTION should be in the form 'BeginningOfLine' or 'beginning-of-line'.
  ## It is an error for the function to not be known....
  ##
  ## As an example, the following lines in .inputrc will bind one's xterm
  ## arrow keys:
  ##     "\e[[A": previous-history
  ##     "\e[[B": next-history
  ##     "\e[[C": forward-char
  ##     "\e[[D": backward-char
  ##
  
  sub filler_Pending ($) {
    my $keys = shift;
    sub {
      my $c = shift;
      push @Pending, map chr, @$keys;
      return if not @$keys or $c == 1 or not defined(my $in = &getc_with_pending);
      # provide the numeric argument
      local(*KeyMap) = $var_EditingMode;
      $doingNumArg = 1;		# Allow NumArg inside NumArg
      &do_command(*KeyMap, $c, ord $in);
      return;
    }
  }
  
  sub _unescape ($) {
    my($key, @keys) = shift;
    ## New-style bindings are enclosed in double-quotes.
    ## Characters are taken verbatim except the special cases:
    ##    \C-x    Control x (for any x)
    ##    \M-x    Meta x (for any x)
    ##    \e	  Escape
    ##    \*      Set the keymap default   (JP: added this)
    ##               (must be the last character of the sequence)
    ##
    ##    \x      x  (unless it fits the above pattern)
    ##
    ## Look for special case of "\C-\M-x", which should be treated
    ## like "\M-\C-x".
  
    while (length($key) > 0) {
  
      # JP: fixed regex bugs below: changed all 's#' to 's#^'
  
      if ($key =~ s#^\\C-\\M-(.)##) {
        push(@keys, ord("\e"), &ctrl(ord($1)));
      } elsif ($key =~ s#^\\(M-|e)##) {
        push(@keys, ord("\e"));
      } elsif ($key =~ s#^\\C-(.)##) {
        push(@keys, &ctrl(ord($1)));
      } elsif ($key =~ s#^\\x([0-9a-fA-F]{2})##) {
        push(@keys, eval('0x'.$1));
      } elsif ($key =~ s#^\\([0-7]{3})##) {
        push(@keys, eval('0'.$1));
      } elsif ($key =~ s#^\\\*$##) {     # JP: added
        push(@keys, 'default');
      } elsif ($key =~ s#^\\([afnrtv])##) {
        push(@keys, ord(eval(qq("\\$1"))));
      } elsif ($key =~ s#^\\d##) {
        push(@keys, 4);		# C-d
      } elsif ($key =~ s#^\\b##) {
        push(@keys, 0x7f);	# Backspace
      } elsif ($key =~ s#^\\(.)##) {
        push(@keys, ord($1));
      } else {
        push(@keys, ord($key));
        substr($key,0,1) = '';
      }
    }
    @keys
  }
  
  sub RL_func ($) {
    my $name_or_macro = shift;
    if ($name_or_macro =~ /^"((?:\\.|[^\\\"])*)"|^'((?:\\.|[^\\\'])*)'/s) {
      filler_Pending [_unescape "$+"];
    } else {
      "F_$name_or_macro";
    }
  }
  
  sub actually_do_binding
  {
    ##
    ## actually_do_binding($function1, \@sequence1, ...)
    ##
    ## Actually inserts the binding for @sequence to $function into the
    ## current map.  @sequence is an array of character ordinals.
    ##
    ## If @sequence is more than one element long, all but the last will
    ## cause meta maps to be created.
    ##
    ## $Function will have an implicit "F_" prepended to it.
    ##
    while (@_) {
      my $func = shift;
      my ($key, @keys) = @{shift()};
      $key += 0;
      local(*KeyMap) = *KeyMap;
      my $map;
      while (@keys) {
        if (defined($KeyMap[$key]) && ($KeyMap[$key] ne 'F_PrefixMeta')) {
  	warn "Warning$InputLocMsg: ".
  	  "Re-binding char #$key from [$KeyMap[$key]] to meta for [@keys] => $func.\n" if $^W;
        }
        $KeyMap[$key] = 'F_PrefixMeta';
        $map = "$KeyMap{'name'}_$key";
        InitKeymap(*$map, '', $map) if !(%$map);
        *KeyMap = *$map;
        $key = shift @keys;
        #&actually_do_binding($func, \@keys);
      }
  
      my $name = $KeyMap{'name'};
      if ($key eq 'default') {      # JP: added
  	warn "Warning$InputLocMsg: ".
  	  " changing default action to $func in $name key map\n"
  	  if $^W && defined $KeyMap{'default'};
  
  	$KeyMap{'default'} = RL_func $func;
      }
      else {
  	if (defined($KeyMap[$key]) && $KeyMap[$key] eq 'F_PrefixMeta'
  	    && $func ne 'PrefixMeta')
  	  {
  	    warn "Warning$InputLocMsg: ".
  	      " Re-binding char #$key to non-meta ($func) in $name key map\n"
  	      if $^W;
  	  }
  	$KeyMap[$key] = RL_func $func;
      }
    }
  }
  
  sub rl_bind
  {
      my (@keys, $key, $func, $ord, @arr);
  
      while (defined($key = shift(@_)) && defined($func = shift(@_)))
      {
  	##
  	## Change the function name from something like
  	##	backward-kill-line
  	## to
  	##	BackwardKillLine
  	## if not already there.
  	##
          unless ($func =~ /^[\"\']/) {
  	  $func = "\u$func";
  	  $func =~ s/-(.)/\u$1/g;
  
  	  # Temporary disabled
  	  if (!$autoload_broken and !defined($ {'readline::'}{"F_$func"})) {
  	    warn "Warning$InputLocMsg: bad bind function [$func]\n" if $^W;
  	    next;
  	  }
  	}
  
  	## print "sequence [$key] func [$func]\n"; ##DEBUG
  
  	@keys = ();
   	## See if it's a new-style binding.
  	if ($key =~ m/"((?:\\.|[^\\])*)"/s) {
  	    @keys = _unescape "$1";
  	} else {
  	    ## ol-dstyle binding... only one key (or Meta+key)
  	    my ($isctrl, $orig) = (0, $key);
  	    $isctrl = $key =~ s/\b(C|Control|CTRL)-//i;
  	    push(@keys, ord("\e")) if $key =~ s/\b(M|Meta)-//i; ## is meta?
  	    ## Isolate key part. This matches GNU's implementation.
  	    ## If the key is '-', be careful not to delete it!
  	    $key =~ s/.*-(.)/$1/;
  	    if    ($key =~ /^(space|spc)$/i)   { $key = ' ';    }
  	    elsif ($key =~ /^(rubout|del)$/i)  { $key = "\x7f"; }
  	    elsif ($key =~ /^tab$/i)           { $key = "\t";   }
  	    elsif ($key =~ /^(return|ret)$/i)  { $key = "\r";   }
  	    elsif ($key =~ /^(newline|lfd)$/i) { $key = "\n";   }
  	    elsif ($key =~ /^(escape|esc)$/i)  { $key = "\e";   }
  	    elsif (length($key) > 1) {
  	        warn "Warning$InputLocMsg: strange binding [$orig]\n" if $^W;
  	    }
  	    $key = ord($key);
  	    $key = &ctrl($key) if $isctrl;
  	    push(@keys, $key);
  	}
  
  	# 
  	## Now do the mapping of the sequence represented in @keys
  	 #
  	# print "&actually_do_binding($func, @keys)\n"; ##DEBUG
  	push @arr, $func, [@keys];
  	#&actually_do_binding($func, \@keys);
      }
      &actually_do_binding(@arr);
  }
  
  sub read_an_init_file {
      my $file = shift;
      my $include_depth = shift;
      local *RC;
      $file =~ s/^~([\\\/])/$ENV{HOME}$1/ if not -f $file and exists $ENV{HOME};
      return unless open RC, "< $file";
      my (@action) = ('exec'); ## exec, skip, ignore (until appropriate endif)
      my (@level) = ();        ## if, else
  
      local $/ = "\n";
      while (<RC>) {
  	s/^\s+//;
  	next if m/^\s*(#|$)/;
  	$InputLocMsg = " [$file line $.]";
  	if (/^\$if\s+(.*)/) {
  	    my($test) = $1;
  	    push(@level, 'if');
  	    if ($action[$#action] ne 'exec') {
  		## We're supposed to be skipping or ignoring this level,
  		## so for subsequent levels we really ignore completely.
  		push(@action, 'ignore');
  	    } else {
  		## We're executing this IF... do the test.
  		## The test is either "term=xxxx", or just a string that
  		## we compare to $rl_readline_name;
  		if ($test =~ /term=([a-z0-9]+)/) {
  		    $test = ($ENV{'TERM'} && $1 eq $ENV{'TERM'});
  		} else {
  		    $test = $test =~ /^(perl|$rl_readline_name)\s*$/i;
  		}
  		push(@action, $test ? 'exec' : 'skip');
  	    }
  	    next;
  	} elsif (/^\$endif\b/) {
  	    die qq/\rWarning$InputLocMsg: unmatched endif\n/ if @level == 0;
  	    pop(@level);
  	    pop(@action);
  	    next;
  	} elsif (/^\$else\b/) {
  	    die qq/\rWarning$InputLocMsg: unmatched else\n/ if
  		@level == 0 || $level[$#level] ne 'if';
  	    $level[$#level] = 'else'; ## an IF turns into an ELSE
  	    if ($action[$#action] eq 'skip') {
  		$action[$#action] = 'exec'; ## if were SKIPing, now EXEC
  	    } else {
  		$action[$#action] = 'ignore'; ## otherwise, just IGNORE.
  	    }
  	    next;
  	} elsif (/^\$include\s+(\S+)/) {
  	    if ($include_depth > $max_include_depth) {
  		warn "Deep recursion in \$include directives in $file.\n";
  	    } else {
  		read_an_init_file($1, $include_depth + 1);
  	    }
  	} elsif ($action[$#action] ne 'exec') {
  	    ## skipping this one....
  	# readline permits trailing comments in inputrc
  	# this seems to solve the warnings caused by trailing comments in the
  	# default /etc/inputrc on Mandrake Linux boxes.
  	} elsif (m/\s*set\s+(\S+)\s+(\S*)/) {	# Allow trailing comment
  	    &rl_set($1, $2, $file);
  	} elsif (m/^\s*(\S+):\s+("(?:\\.|[^\\\"])*"|'(\\.|[^\\\'])*')/) {	# Allow trailing comment
  	    &rl_bind($1, $2);
  	} elsif (m/^\s*(\S+|"[^\"]+"):\s+(\S+)/) { # Allow trailing comment
  	    &rl_bind($1, $2);
  	} else {
  	    chomp;
  	    warn "\rWarning$InputLocMsg: Bad line [$_]\n" if $^W;
  	}
      }
      close(RC);
  }
  
  sub F_ReReadInitFile
  {
      my ($file) = $ENV{'TRP_INPUTRC'};
      $file = $ENV{'INPUTRC'} unless defined $file;
      unless (defined $file) {
  	return unless defined $ENV{'HOME'};
  	$file = "$ENV{'HOME'}/.inputrc";
      }
      read_an_init_file($file, 0);
  }
  
  sub get_ornaments_selected {
      return if @$rl_term_set >= 6;
      local $^W=0;
      my $Orig = $Term::ReadLine::Perl::term->ornaments(); 
      eval {
          # Term::ReadLine does not expose its $terminal, so make another
          require Term::Cap;
          my $terminal = Tgetent Term::Cap ({OSPEED=>9600});
          # and be sure the terminal supports highlighting
          $terminal->Trequire('mr');
      };
      if (!$@ and $Orig ne ',,,'){
  	my @set = @$rl_term_set;
  
          $Term::ReadLine::Perl::term->ornaments
              (join(',', (split(/,/, $Orig))[0,1]) . ',mr,me') ;
          @set[4,5] = @$rl_term_set[2,3];
          $Term::ReadLine::Perl::term->ornaments($Orig);
  	@$rl_term_set = @set;
      } else {
          @$rl_term_set[4,5] = @$rl_term_set[2,3];
      }
  }
  
  sub readline_dumb {
  	local $\ = '';
  	print $term_OUT $prompt;
  	local $/ = "\n";
  	return undef
            if !defined($line = $Term::ReadLine::Perl::term->get_line);
  	chomp($line);
  	$| = $oldbar;
  	select $old;
  	return $line;
  }
  
  ##
  ## This is it. Called as &readline'readline($prompt, $default),
  ## (DEFAULT can be omitted) the next input line is returned (undef on EOF).
  ##
  sub readline
  {
      $Term::ReadLine::Perl::term->register_Tk 
        if not $Term::ReadLine::registered and $Term::ReadLine::toloop
  	and defined &Tk::DoOneEvent;
      if ($stdin_not_tty) {
  	local $/ = "\n";
  	return undef if !defined($line = <$term_IN>);
  	chomp($line);
  	return $line;
      }
  
      $old = select $term_OUT;
      $oldbar = $|;
      local($|) = 1;
      local($input);
  
      ## prompt should be given to us....
      $prompt = defined($_[0]) ? $_[0] : 'INPUT> ';
  
      # Try to move cursor to the beginning of the next line if this line
      # contains anything.
  
      # On DOSish 80-wide console
      #	perl -we "print 1 x shift, qq(\b2\r3); sleep 2" 79
      # prints 3 on the same line,
      #	perl -we "print 1 x shift, qq(\b2\r3); sleep 2" 80
      # on the next; $rl_screen_width is 79.
  
      # on XTerm one needs to increase the number by 1.
  
      print $term_OUT ' ' x ($rl_screen_width - !$rl_last_pos_can_backspace) . "\b  \r"
        if $rl_scroll_nextline;
  
      if ($dumb_term) {
  	return readline_dumb;
      }
  
      # test if we resume an 'Operate' command
      if ($rl_OperateCount > 0 && (!defined $_[1] || $_[1] eq '')) {
  	## it's from a valid previous 'Operate' command and
  	## user didn't give a default line
  	## we leave $rl_HistoryIndex untouched
  	$line = $rl_History[$rl_HistoryIndex];
      } else {
  	## set history pointer at the end of history
  	$rl_HistoryIndex = $#rl_History + 1;
  	$rl_OperateCount = 0;
  	$line = defined $_[1] ? $_[1] : '';
      }
      $rl_OperateCount-- if $rl_OperateCount > 0;
  
      $line_for_revert = $line;
  
  # I don't think we need to do this, actually...
  #    while (&ioctl(STDIN,$FIONREAD,$fion))
  #    {
  #	local($n_chars_available) = unpack ($fionread_t, $fion);
  #	## print "n_chars = $n_chars_available\n";
  #	last if $n_chars_available == 0;
  #	$line .= getc_with_pending;  # should we prepend if $rl_start_default_at_beginning?
  #    }
  
      $D = $rl_start_default_at_beginning ? 0 : length($line); ## set dot.
      $LastCommandKilledText = 0;     ## heck, was no last command.
      $lastcommand = '';		    ## Well, there you go.
      $line_rl_mark = -1;
  
      ##
      ## some stuff for &redisplay.
      ##
      $lastredisplay = '';	## Was no last redisplay for this time.
      $lastlen = length($lastredisplay);
      $lastpromptlen = 0;
      $lastdelta = 0;		## Cursor was nowhere
      $si = 0;			## Want line to start left-justified
      $force_redraw = 1;		## Want to display with brute force.
      if (!eval {SetTTY()}) {	## Put into raw mode.
          warn $@ if $@;
          $dumb_term = 1;
  	return readline_dumb;
      }
  
      *KeyMap = $var_EditingMode;
      undef($AcceptLine);		## When set, will return its value.
      undef($ReturnEOF);		## ...unless this on, then return undef.
      @Pending = ();		## Contains characters to use as input.
      @undo = ();			## Undo history starts empty for each line.
      @undoGroupS = ();		## Undo groups start empty for each line.
      undef $memorizedArg;	## No digitArgument memorized
      undef $memorizedPos;	## No position memorized
  
      undef $Vi_undo_state;
      undef $Vi_undo_all_state;
  
      # We need to do some additional initialization for vi mode.
      # RS: bug reports/platform issues are welcome: russ@dvns.com
      if ($KeyMap{'name'} eq 'vi_keymap'){
          &F_ViInput();
          if ($rl_vi_replace_default_on_insert){
              local $^W=0;
             my $Orig = $Term::ReadLine::Perl::term->ornaments(); 
             eval {
                 # Term::ReadLine does not expose its $terminal, so make another
                 require Term::Cap;
                 my $terminal = Tgetent Term::Cap ({OSPEED=>9600});
                 # and be sure the terminal supports highlighting
                 $terminal->Trequire('mr');
             };
             if (!$@ and $Orig ne ',,,'){
                 $Term::ReadLine::Perl::term->ornaments
                     (join(',', (split(/,/, $Orig))[0,1]) . ',mr,me') 
             }
              my $F_SelfInsert_Real = \&F_SelfInsert;
              *F_SelfInsert = sub {
                 $Term::ReadLine::Perl::term->ornaments($Orig); 
                  &F_ViChangeEntireLine;
                  local $^W=0;
                  *F_SelfInsert = $F_SelfInsert_Real;
                  &F_SelfInsert;
              };
              my $F_ViEndInsert_Real = \&F_ViEndInsert;
              *F_ViEndInsert = sub {
                 $Term::ReadLine::Perl::term->ornaments($Orig); 
                  local $^W=0;
                  *F_SelfInsert = $F_SelfInsert_Real;
                  *F_ViEndInsert = $F_ViEndInsert_Real;
                  &F_ViEndInsert;
                 $force_redraw = 1;
                 redisplay();
              };
          }
      }
  
      if ($rl_default_selected) {
  	redisplay_high();
      } else {
  	&redisplay();          ## Show the line (prompt+default at this point).
      }
  
      # pretend input if we 'Operate' on more than one line
      &F_OperateAndGetNext($rl_OperateCount) if $rl_OperateCount > 0;
  
      $rl_first_char = 1;
      while (!defined($AcceptLine)) {
  	## get a character of input
  	$input = &getc_with_pending(); # bug in debugger, returns 42. - No more!
  
  	unless (defined $input) {
  	  # XXX What to do???  Until this is clear, just pretend we got EOF
  	  $AcceptLine = $ReturnEOF = 1;
  	  last;
  	}
  	preserve_state();
  
  	$ThisCommandKilledText = 0;
  	##print "\n\rline is @$D:[$line]\n\r"; ##DEBUG
  	my $cmd = get_command($var_EditingMode, ord($input));
  	if ( $rl_first_char && $cmd =~ /^F_(SelfInsert$|Yank)/
  	     && length $line && $rl_default_selected ) {
  	  # (Backward)?DeleteChar specialcased in the code
  	    $line = '';
  	    $D = 0;
  	    $cmd = 'F_BackwardDeleteChar' if $cmd eq 'F_DeleteChar';
  	}
  	undef $doingNumArg;
  	&$cmd(1, ord($input));			## actually execute input
  	$rl_first_char = 0;
  	$lastcommand = $cmd;
  	*KeyMap = $var_EditingMode;           # JP: added
  
  	# In Vi command mode, don't position the cursor beyond the last
  	#     character of the line buffer.
  	&F_BackwardChar(1) if $Vi_mode and $line ne ''
  	    and &at_end_of_line and $KeyMap{'name'} eq 'vicmd_keymap';
  
  	&redisplay();
  	$LastCommandKilledText = $ThisCommandKilledText;
      }
  
      undef @undo; ## Release the memory.
      undef @undoGroupS; ## Release the memory.
      &ResetTTY;   ## Restore the tty state.
      $| = $oldbar;
      select $old;
      return undef if defined($ReturnEOF);
      #print STDOUT "|al=`$AcceptLine'";
      $AcceptLine; ## return the line accepted.
  }
  
  ## ctrl(ord('a')) will return the ordinal for Ctrl-A.
  sub ctrl {
    $_[0] ^ (($_[0]>=ord('a') && $_[0]<=ord('z')) ? 0x60 : 0x40);
  }
  
  
  
  sub SetTTY {
      return if $dumb_term || $stdin_not_tty;
      #return system 'stty raw -echo' if defined &DB::DB;
      if (defined $term_readkey) {
        Term::ReadKey::ReadMode(4, $term_IN);
        if ($^O eq 'MSWin32') {
  	# If we reached this, Perl isn't cygwin; Enter sends \r; thus we need binmode
  	# XXXX Do we need to undo???  $term_IN is most probably private now...
  	binmode $term_IN;
        }
        return 1;
      }
  #   system 'stty raw -echo';
  
      $sgttyb = ''; ## just to quiet "perl -w";
    if ($useioctl && $^O ne 'solaris' && defined $TIOCGETP
        && &ioctl($term_IN,$TIOCGETP,$sgttyb)) {
      @tty_buf = unpack($sgttyb_t,$sgttyb);
      if (defined $ENV{OS2_SHELL}) {
        $tty_buf[3] &= ~$mode;
        $tty_buf[3] &= ~$ECHO;
      } else {
        $tty_buf[4] |= $mode;
        $tty_buf[4] &= ~$ECHO;
      }
      $sgttyb = pack($sgttyb_t,@tty_buf);
      &ioctl($term_IN,$TIOCSETP,$sgttyb) || die "Can't ioctl TIOCSETP: $!";
    } elsif (!$usestty) {
      return 0;
    } else {
       warn <<EOW if $useioctl and not defined $ENV{PERL_READLINE_NOWARN};
  Can't ioctl TIOCGETP: $!
  Consider installing Term::ReadKey from CPAN site nearby
  	at http://www.perl.com/CPAN
  Or use
  	perl -MCPAN -e shell
  to reach CPAN. Falling back to 'stty'.
  	If you do not want to see this warning, set PERL_READLINE_NOWARN
  in your environment.
  EOW
  					# '; # For Emacs. 
       $useioctl = 0;
       system 'stty raw -echo' and ($usestty = 0, die "Cannot call `stty': $!");
       if ($^O eq 'MSWin32') {
  	# If we reached this, Perl isn't cygwin, but STTY is present ==> cygwin
  	# The symptoms: now Enter sends \r; thus we need binmode
  	# XXXX Do we need to undo???  $term_IN is most probably private now...
  	binmode $term_IN;
       }
    }
    return 1;
  }
  
  sub ResetTTY {
      return if $dumb_term || $stdin_not_tty;
      #return system 'stty -raw echo' if defined &DB::DB;
      if (defined $term_readkey) {
        return Term::ReadKey::ReadMode(0, $term_IN);
      }
  
  #   system 'stty -raw echo';
    if ($useioctl) {
      &ioctl($term_IN,$TIOCGETP,$sgttyb) || die "Can't ioctl TIOCGETP: $!";
      @tty_buf = unpack($sgttyb_t,$sgttyb);
      if (defined $ENV{OS2_SHELL}) {
        $tty_buf[3] |= $mode;
        $tty_buf[3] |= $ECHO;
      } else {
        $tty_buf[4] &= ~$mode;
        $tty_buf[4] |= $ECHO;
      }
      $sgttyb = pack($sgttyb_t,@tty_buf);
      &ioctl($term_IN,$TIOCSETP,$sgttyb) || die "Can't ioctl TIOCSETP: $!";
    } elsif ($usestty) {
      system 'stty -raw echo' and die "Cannot call `stty': $!";
    }
  }
  
  # Substr_with_props: gives the substr of prompt+string with embedded
  # face-change commands
  
  sub substr_with_props {
    my ($p, $s, $from, $len, $ket, $bsel, $esel) = @_;
    my $lp = length $p;
  
    defined $from or $from = 0;
    defined $len or $len = length($p) + length($s) - $from;
    unless (defined $ket) {
      warn 'bug in Term::ReadLine::Perl, please report to its author cpan@ilyaz.org';
      $ket = '';
    }
    # We may draw over to put cursor in a correct position:
    $ket = '' if $len < length($p) + length($s) - $from; # Not redrawn
  
    if ($from >= $lp) {
      $p = '';
      $s = substr $s, $from - $lp;
      $lp = 0;
    } else {
      $p = substr $p, $from;
      $lp -= $from;
      $from = 0;
    }
    $s = substr $s, 0, $len - $lp;
    $p =~ s/^(\s*)//; my $bs = $1;
    $p =~ s/(\s*)$//; my $as = $1;
    $p = $rl_term_set->[0] . $p . $rl_term_set->[1] if length $p;
    $p = "$bs$p$as";
    $ket = chop $s if $ket;
    if (defined $bsel and $bsel != $esel) {
      $bsel = $len if $bsel > $len;
      $esel = $len if $esel > $len;
    }
    if (defined $bsel and $bsel != $esel) {
      get_ornaments_selected;
      $bsel -= $lp; $esel -= $lp;
      my ($pre, $sel, $post) =
        (substr($s, 0, $bsel),
         substr($s, $bsel, $esel-$bsel),
         substr($s, $esel));
      $pre  = $rl_term_set->[2] . $pre  . $rl_term_set->[3] if length $pre;
      $sel  = $rl_term_set->[4] . $sel  . $rl_term_set->[5] if length $sel;
      $post = $rl_term_set->[2] . $post . $rl_term_set->[3] if length $post;
      $s = "$pre$sel$post"
    } else {
      $s = $rl_term_set->[2] . $s . $rl_term_set->[3] if length $s;
    }
  
    if (!$lp) {			# Should not happen...
      return $s;
    } elsif (!length $s) {	# Should not happen
      return $p;
    } else {			# Do not underline spaces in the prompt
      return "$p$s"
        . (length $ket ? ($rl_term_set->[0] . $ket . $rl_term_set->[1]) : '');
    }
  }
  
  sub redisplay_high {
    get_ornaments_selected();
    @$rl_term_set[2,3,4,5] = @$rl_term_set[4,5,2,3];
    &redisplay();			## Show the line, default inverted.
    @$rl_term_set[2,3,4,5] = @$rl_term_set[4,5,2,3];
    $force_redraw = 1;
  }
  
  ##
  ## redisplay()
  ##
  ## Updates the screen to reflect the current $line.
  ##
  ## For the purposes of this routine, we prepend the prompt to a local copy of
  ## $line so that we display the prompt as well.  We then modify it to reflect
  ## that some characters have different sizes (i.e. control-C is represented
  ## as ^C, tabs are expanded, etc.)
  ##
  ## This routine is somewhat complicated by two-byte characters.... must
  ## make sure never to try do display just half of one.
  ##
  ## NOTE: If an argument is given, it is used instead of the prompt.
  ##
  ## This is some nasty code.
  ##
  sub redisplay
  {
      ## local $line has prompt also; take that into account with $D.
      local($prompt) = defined($_[0]) ? $_[0] : $prompt;
      my ($thislen, $have_bra);
      my($dline) = $prompt . $line;
      local($D) = $D + length($prompt);
      my ($bsel, $esel);
      if (defined pos $line) {
        $bsel = (pos $line) + length $prompt;
      }
      my ($have_ket) = '';
  
      ##
      ## If the line contains anything that might require special processing
      ## for displaying (such as tabs, control characters, etc.), we will
      ## take care of that now....
      ##
      if ($dline =~ m/[^\x20-\x7e]/)
      {
  	local($new, $Dinc, $c) = ('', 0);
  
  	## Look at each character of $dline in turn.....
          for ($i = 0; $i < length($dline); $i++) {
  	    $c = substr($dline, $i, 1);
  
  	    ## A tab to expand...
  	    if ($c eq "\t") {
  		$c = ' ' x  (8 - (($i-length($prompt)) % 8));
  
  	    ## A control character....
  	    } elsif ($c =~ tr/\000-\037//) {
  		$c = sprintf("^%c", ord($c)+ord('@'));
  
  	    ## the delete character....
  	    } elsif (ord($c) == 127) {
  		$c = '^?';
  	    }
  	    $new .= $c;
  
  	    ## Bump over $D if this char is expanded and left of $D.
  	    $Dinc += length($c) - 1 if (length($c) > 1 && $i < $D);
  	    ## Bump over $bsel if this char is expanded and left of $bsel.
  	    $bsel += length($c) - 1 if (defined $bsel && length($c) > 1 && $i < $bsel);
  	}
  	$dline = $new;
  	$D += $Dinc;
      }
  
      ##
      ## Now $dline is what we'd like to display (with a prepended prompt)
      ## $D is the position of the cursor on it.
      ##
      ## If it's too long to fit on the line, we must decide what we can fit.
      ##
      ## If we end up moving the screen index ($si) [index of the leftmost
      ## character on the screen], to some place other than the front of the
      ## the line, we'll have to make sure that it's not on the first byte of
      ## a 2-byte character, 'cause we'll be placing a '<' marker there, and
      ## that would screw up the 2-byte character.
      ##
      ## $si is preserved between several displays (if possible).
      ##
      ## Similarly, if the line needs chopped off, we make sure that the
      ## placement of the tailing '>' won't screw up any 2-byte character in
      ## the vicinity.
  
      # Now $si keeps the value from previous display
      if ($D == length($prompt)	# If prompts fits exactly, show only if need not show trailing '>'
  	and length($prompt) < $rl_screen_width - (0 != length $dline)) {
  	$si = 0;   ## prefer displaying the whole prompt
      } elsif ($si >= $D) {	# point to the left of what was displayed
  	$si = &max(0, $D - $rl_margin);
  	$si-- if $si > 0 && $si != length($prompt) && !&OnSecondByte($si);
      } elsif ($si + $rl_screen_width <= $D) { # Point to the right of ...
  	$si = &min(length($dline), ($D - $rl_screen_width) + $rl_margin);
  	$si-- if $si > 0 && $si != length($prompt) && !&OnSecondByte($si);
      } elsif (length($dline) - $si < $rl_screen_width - $rl_margin and $si) {
          # Too little of the line shown
          $si = &max(0, length($dline) - $rl_screen_width + 3);
  	$si-- if $si > 0 && $si != length($prompt) && !&OnSecondByte($si);
      } else {
  	## Fine as-is.... don't need to change $si.
      }
      $have_bra = 1 if $si != 0; # Need the "chopped-off" marker
  
      $thislen = &min(length($dline) - $si, $rl_screen_width);
      if ($si + $thislen < length($dline)) {
  	## need to place a '>'... make sure to place on first byte.
  	$thislen-- if &OnSecondByte($si+$thislen-1);
  	substr($dline, $si+$thislen-1,1) = '>';
  	$have_ket = 1;
      }
  
      ##
      ## Now know what to display.
      ## Must get substr($dline, $si, $thislen) on the screen,
      ## with the cursor at $D-$si characters from the left edge.
      ##
      $dline = substr($dline, $si, $thislen);
      $delta = $D - $si;	## delta is cursor distance from beginning of $dline.
      if (defined $bsel) {	# Highlight the selected part
        $bsel -= $si;
        $esel = $delta;
        ($bsel, $esel) = ($esel, $bsel) if $bsel > $esel;
        $bsel = 0 if $bsel < 0;
        if ($have_ket) {
  	$esel = $thislen - 1 if $esel > $thislen - 1;
        } else {
  	$esel = $thislen if $esel > $thislen;
        }
      }
      if ($si >= length($prompt)) { # Keep $dline for $lastredisplay...
        $prompt = ($have_bra ? "<" : "");
        $dline = substr $dline, 1;	# After prompt
        $bsel = 1 if defined $bsel and $bsel == 0;
      } else {
        $dline = substr($dline, (length $prompt) - $si);
        $prompt = substr($prompt,$si);
        substr($prompt, 0, 1) = '<' if $si > 0;
      }
      # Now $dline is the part after the prompt...
  
      ##
      ## Now must output $dline, with cursor $delta spaces from left of TTY
      ##
  
      local ($\, $,) = ('','');
  
      ##
      ## If $force_redraw is not set, we can attempt to optimize the redisplay
      ## However, if we don't happen to find an easy way to optimize, we just
      ## fall through to the brute-force method of re-drawing the whole line.
      ##
      if (not $force_redraw and not defined $bsel)
      {
  	## can try to optimize here a bit.
  
  	## For when we only need to move the cursor
  	if ($lastredisplay eq $dline and $lastpromptlen == length $prompt) {
  	    ## If we need to move forward, just overwrite as far as we need.
  	    if ($lastdelta < $delta) {
  		print $term_OUT 
  		  substr_with_props($prompt, $dline,
  				    $lastdelta, $delta-$lastdelta, $have_ket);
  	    ## Need to move back.
  	    } elsif($lastdelta > $delta) {
  		## Two ways to move back... use the fastest. One is to just
  		## backspace the proper amount. The other is to jump to the
  		## the beginning of the line and overwrite from there....
  		my $out = substr_with_props($prompt, $dline, 0, $delta, $have_ket);
  		if ($lastdelta - $delta <= length $out) {
  		    print $term_OUT "\b" x ($lastdelta - $delta);
  		} else {
  		    print $term_OUT "\r", $out;
  		}
  	    }
  	    ($lastlen, $lastredisplay, $lastdelta, $lastpromptlen)
  	      = ($thislen, $dline, $delta, length $prompt);
  	    # print $term_OUT "\a"; # Debugging
  	    return;
  	}
  
  	## for when we've just added stuff to the end
  	if ($thislen > $lastlen &&
  	    $lastdelta == $lastlen &&
  	    $delta == $thislen &&
  	    $lastpromptlen == length($prompt) &&
  	    substr($dline, 0, $lastlen - $lastpromptlen) eq $lastredisplay)
  	{
  	    print $term_OUT substr_with_props($prompt, $dline,
  					      $lastdelta, undef, $have_ket);
  	    # print $term_OUT "\a"; # Debugging
  	    ($lastlen, $lastredisplay, $lastdelta, $lastpromptlen)
  	      = ($thislen, $dline, $delta, length $prompt);
  	    return;
  	}
  
  	## There is much more opportunity for optimizing.....
  	## something to work on later.....
      }
  
      ##
      ## Brute force method of redisplaying... redraw the whole thing.
      ##
  
      print $term_OUT "\r", substr_with_props($prompt, $dline, 0, undef, $have_ket, $bsel, $esel);
      my $back = length ($dline) + length ($prompt) - $delta;
      $back += $lastlen - $thislen,
  	print $term_OUT ' ' x ($lastlen - $thislen) if $lastlen > $thislen;
  
      if ($back) {
  	my $out = substr_with_props($prompt, $dline, 0, $delta, $have_ket, $bsel, $esel);
  	if ($back <= length $out and not defined $bsel) {
  	    print $term_OUT "\b" x $back;
  	} else {
  	    print $term_OUT "\r", $out;
  	}
      }
  
      ($lastlen, $lastredisplay, $lastdelta, $lastpromptlen)
        = ($thislen, $dline, $delta, length $prompt);
  
      $force_redraw = 0;
  }
  
  sub min     { $_[0] < $_[1] ? $_[0] : $_[1]; }
  
  sub getc_with_pending {
  
      my $key = @Pending ? shift(@Pending) : &$rl_getc;
  
      # Save keystrokes for vi '.' command
      push(@$Dot_buf, $key) if $Dot_buf;
  
      $key;
  }
  
  sub rl_getc {
  	  my $key;                        # JP: Added missing declaration
  	  if (defined $term_readkey) { # XXXX ???
  	    $Term::ReadLine::Perl::term->Tk_loop 
  	      if $Term::ReadLine::toloop && defined &Tk::DoOneEvent;
  	    $key = Term::ReadKey::ReadKey(0, $term_IN);
  	  } else {
  	    $key = $Term::ReadLine::Perl::term->get_c;
  	  }
  }
  
  ##
  ## get_command(keymap, ord_command_char)
  ##
  ## If the KEYMAP has an entry for COMMAND, it is returned.
  ## Otherwise, the default command is returned.
  ##
  sub get_command
  {
      local *KeyMap = shift;
      my ($key) = @_;
      my $cmd = defined($KeyMap[$key]) ? $KeyMap[$key]
                                       : ($KeyMap{'default'} || 'F_Ding');
      if (!defined($cmd) || $cmd eq ''){
  	warn "internal error (key=$key)";
  	$cmd = 'F_Ding';
      }
      $cmd
  }
  
  ##
  ## do_command(keymap, numericarg, command)
  ##
  ## If the KEYMAP has an entry for COMMAND, it is executed.
  ## Otherwise, the default command for the keymap is executed.
  ##
  sub do_command
  {
      my ($keymap, $count, $key) = @_;
      my $cmd = get_command($keymap, $key);
  
      local *KeyMap = $keymap;		# &$cmd may expect it...
      &$cmd($count, $key);
      $lastcommand = $cmd;
  }
  
  ##
  ## Save whatever state we wish to save as an anonymous array.
  ## The only other function that needs to know about its encoding is getstate/preserve_state.
  ##
  sub savestate
  {
      [$D, $si, $LastCommandKilledText, $KillBuffer, $line, @_];
  }
  
  # consolidate only-movement changes together...
  sub preserve_state {
      return if $Vi_mode;
      push(@undo, savestate()), return unless @undo;
      my $last = $undo[-1];
      my @only_movement;
      if ( #$last->[1] == $si and $last->[2] eq $LastCommandKilledText
  	 # and $last->[3] eq $KillBuffer and
  	 $last->[4] eq $line ) {
  	# Only position changed; remove old only-position-changed records
  	pop @undo if $undo[-1]->[5];
  	@only_movement = 1;
      }
      push(@undo, savestate(@only_movement));
  }
  
  ##
  ## $_[1] is an ASCII ordinal; inserts as per $count.
  ##
  sub F_SelfInsert
  {
      remove_selection();
      my ($count, $ord) = @_;
      my $text2add = pack('C', $ord) x $count;
      if ($InsertMode) {
  	substr($line,$D,0) .= $text2add;
      } else {
  	## note: this can screw up with 2-byte characters.
  	substr($line,$D,length($text2add)) = $text2add;
      }
      $D += length($text2add);
  }
  
  ##
  ## Return the line as-is to the user.
  ##
  sub F_AcceptLine
  {
      &add_line_to_history;
      $AcceptLine = $line;
      local $\ = '';
      print $term_OUT "\r\n";
      $force_redraw = 0;
      (pos $line) = undef;	# Another way to force redraw...
  }
  
  sub add_line_to_history
  {
      ## Insert into history list if:
      ##	 * bigger than the minimal length
      ##   * not same as last entry
      ##
      if (length($line) >= $minlength 
  	&& (!@rl_History || $rl_History[$#rl_History] ne $line)
         ) {
  	## if the history list is full, shift out an old one first....
  	while (@rl_History >= $rl_MaxHistorySize) {
  	    shift(@rl_History);
  	    $rl_HistoryIndex--;
  	}
  
  	push(@rl_History, $line); ## tack new one on the end
      }
  }
  
  
  sub remove_selection {
      if ( $rl_first_char && length $line && $rl_default_selected ) {
        $line = '';
        $D = 0;
        return 1;
      }
      if ($rl_delete_selection and defined pos $line and $D != pos $line) {
        kill_text(pos $line, $D);
        return 1;
      }
      return;
  }
  
  #sub F_ReReadInitFile;
  #sub rl_getc;
  sub F_ForwardChar;
  sub F_BackwardChar;
  sub F_BeginningOfLine;
  sub F_EndOfLine;
  sub F_ForwardWord;
  sub F_BackwardWord;
  sub F_RedrawCurrentLine;
  sub F_ClearScreen;
  # sub F_SelfInsert;
  sub F_QuotedInsert;
  sub F_TabInsert;
  #sub F_AcceptLine;
  sub F_OperateAndGetNext;
  sub F_BackwardDeleteChar;
  sub F_DeleteChar;
  sub F_UnixWordRubout;
  sub F_UnixLineDiscard;
  sub F_UpcaseWord;
  sub F_DownCaseWord;
  sub F_CapitalizeWord;
  sub F_TransposeWords;
  sub F_TransposeChars;
  sub F_PreviousHistory;
  sub F_NextHistory;
  sub F_BeginningOfHistory;
  sub F_EndOfHistory;
  sub F_ReverseSearchHistory;
  sub F_ForwardSearchHistory;
  sub F_HistorySearchBackward;
  sub F_HistorySearchForward;
  sub F_KillLine;
  sub F_BackwardKillLine;
  sub F_Yank;
  sub F_YankPop;
  sub F_YankNthArg;
  sub F_KillWord;
  sub F_BackwardKillWord;
  sub F_Abort;
  sub F_DoLowercaseVersion;
  sub F_DoMetaVersion;
  sub F_DoControlVersion;
  sub F_Undo;
  sub F_RevertLine;
  sub F_EmacsEditingMode;
  sub F_Interrupt;
  sub F_PrefixMeta;
  sub F_UniversalArgument;
  sub F_DigitArgument;
  sub F_OverwriteMode;
  sub F_InsertMode;
  sub F_ToggleInsertMode;
  sub F_Suspend;
  sub F_Ding;
  sub F_PossibleCompletions;
  sub F_Complete;
  sub F_YankClipboard;
  sub F_CopyRegionAsKillClipboard;
  sub F_KillRegionClipboard;
  sub clipboard_set;
  sub F_BeginUndoGroup;
  sub F_EndUndoGroup;
  sub F_DoNothing;
  sub F_ForceMemorizeDigitArgument;
  sub F_MemorizeDigitArgument;
  sub F_UnmemorizeDigitArgument;
  sub F_ResetDigitArgument;
  sub F_MergeInserts;
  sub F_MemorizePos;
  sub F_BeginPasteGroup;
  sub F_EndPasteGroup;
  sub F_BeginEditGroup;
  sub F_EndEditGroup;
  
  # Comment next line and __DATA__ line below to disable the selfloader.
  
  use SelfLoader;
  
  1;
  
  __DATA__
  
  # From here on anything may be autoloaded
  
  sub max     { $_[0] > $_[1] ? $_[0] : $_[1]; }
  sub isupper { ord($_[0]) >= ord('A') && ord($_[0]) <= ord('Z'); }
  sub islower { ord($_[0]) >= ord('a') && ord($_[0]) <= ord('z'); }
  sub toupper { &islower ? pack('c', ord($_[0])-ord('a')+ord('A')) : $_[0];}
  sub tolower { &isupper ? pack('c', ord($_[0])-ord('A')+ord('a')) : $_[0];}
  
  ##
  ## rl_set(var_name, value_string)
  ##
  ## Sets the named variable as per the given value, if both are appropriate.
  ## Allows the user of the package to set such things as HorizontalScrollMode
  ## and EditingMode.  Value_string may be of the form
  ##	HorizontalScrollMode
  ##      horizontal-scroll-mode
  ##
  ## Also called during the parsing of ~/.inputrc for "set var value" lines.
  ##
  ## The previous value is returned, or undef on error.
  ###########################################################################
  ## Consider the following example for how to add additional variables
  ## accessible via rl_set (and hence via ~/.inputrc).
  ##
  ## Want:
  ## We want an external variable called "FooTime" (or "foo-time").
  ## It may have values "January", "Monday", or "Noon".
  ## Internally, we'll want those values to translate to 1, 2, and 12.
  ##
  ## How:
  ## Have an internal variable $var_FooTime that will represent the current
  ## internal value, and initialize it to the default value.
  ## Make an array %var_FooTime whose keys and values are are the external
  ## (January, Monday, Noon) and internal (1, 2, 12) values:
  ##
  ##	    $var_FooTime = $var_FooTime{'January'} =  1; #default
  ##	                   $var_FooTime{'Monday'}  =  2;
  ##	                   $var_FooTime{'Noon'}    = 12;
  ##
  sub rl_set
  {
      local($var, $val) = @_;
  
      # &preinit's keys are all Capitalized
      $val = ucfirst lc $val if $val =~ /^(on|off)$/i;
  
      $var = 'CompleteAddsuffix' if $var eq 'visible-stats';
  
      ## if the variable is in the form "some-name", change to "SomeName"
      local($_) = "\u$var";
      local($return) = undef;
      s/-(.)/\u$1/g;
  
      # Skip unknown variables: 
      return unless defined $ {'readline::'}{"var_$_"};
      local(*V);    # avoid <Undefined value assign to typeglob> warning
      { local $^W; *V = $ {'readline::'}{"var_$_"}; }
      if (!defined($V)) {			# XXX Duplicate check?
  	warn("Warning$InputLocMsg:\n".
  	     "  Invalid variable `$var'\n") if $^W;
      } elsif (!defined($V{$val})) {
  	local(@selections) = keys(%V);
  	warn("Warning$InputLocMsg:\n".
  	     "  Invalid value `$val' for variable `$var'.\n".
  	     "  Choose from [@selections].\n") if $^W;
      } else {
  	$return = $V;
          $V = $V{$val}; ## make the setting
      }
      $return;
  }
  
  ##
  ## OnSecondByte($index)
  ##
  ## Returns true if the byte at $index into $line is the second byte
  ## of a two-byte character.
  ##
  sub OnSecondByte
  {
      return 0 if !$_rl_japanese_mb || $_[0] == 0 || $_[0] == length($line);
  
      die 'internal error' if $_[0] > length($line);
  
      ##
      ## must start looking from the beginning of the line .... can
      ## have one- and two-byte characters interspersed, so can't tell
      ## without starting from some know location.....
      ##
      local($i);
      for ($i = 0; $i < $_[0]; $i++) {
  	next if ord(substr($line, $i, 1)) < 0x80;
  	## We have the first byte... must bump up $i to skip past the 2nd.
  	## If that one we're skipping past is the index, it should be changed
  	## to point to the first byte of the pair (therefore, decremented).
          return 1 if ++$i == $_[0];
      }
      0; ## seemed to be OK.
  }
  
  ##
  ## CharSize(index)
  ##
  ## Returns the size of the character at the given INDEX in the
  ## current line.  Most characters are just one byte in length,
  ## but if the byte at the index and the one after has the high
  ## bit set those two bytes are one character of size=2.
  ##
  ## Assumes that index points to the first of a 2-byte char if not
  ## pointing to a 2-byte char.
  ##
  sub CharSize
  {
      return 2 if $_rl_japanese_mb &&
  		ord(substr($line, $_[0],   1)) >= 0x80 &&
                  ord(substr($line, $_[0]+1, 1)) >= 0x80;
      1;
  }
  
  sub GetTTY
  {
      $base_termios = $termios;  # make it long enough
      &ioctl($term_IN,$TCGETS,$base_termios) || die "Can't ioctl TCGETS: $!";
  }
  
  sub XonTTY
  {
      # I don't know which of these I actually need to do this to, so we'll
      # just cover all bases.
  
      &ioctl($term_IN,$TCXONC,$TCOON);    # || die "Can't ioctl TCXONC STDIN: $!";
      &ioctl($term_OUT,$TCXONC,$TCOON);   # || die "Can't ioctl TCXONC STDOUT: $!";
  }
  
  sub ___SetTTY
  {
  # print "before SetTTY\n\r";
  # system 'stty -a';
  
      &XonTTY;
  
      &GetTTY
  	if !defined($base_termios);
  
      @termios = unpack($termios_t,$base_termios);
      $termios[$TERMIOS_IFLAG] |= $TERMIOS_READLINE_ION;
      $termios[$TERMIOS_IFLAG] &= ~$TERMIOS_READLINE_IOFF;
      $termios[$TERMIOS_OFLAG] |= $TERMIOS_READLINE_OON;
      $termios[$TERMIOS_OFLAG] &= ~$TERMIOS_READLINE_OOFF;
      $termios[$TERMIOS_LFLAG] |= $TERMIOS_READLINE_LON;
      $termios[$TERMIOS_LFLAG] &= ~$TERMIOS_READLINE_LOFF;
      $termios[$TERMIOS_VMIN] = 1;
      $termios[$TERMIOS_VTIME] = 0;
      $termios = pack($termios_t,@termios);
      &ioctl($term_IN,$TCSETS,$termios) || die "Can't ioctl TCSETS: $!";
  
  # print "after SetTTY\n\r";
  # system 'stty -a';
  }
  
  sub normal_tty_mode
  {
      return if $stdin_not_tty || $dumb_term || !$initialized;
      &XonTTY;
      &GetTTY if !defined($base_termios);
      &ResetTTY;
  }
  
  sub ___ResetTTY
  {
  # print "before ResetTTY\n\r";
  # system 'stty -a';
  
      @termios = unpack($termios_t,$base_termios);
      $termios[$TERMIOS_IFLAG] |= $TERMIOS_NORMAL_ION;
      $termios[$TERMIOS_IFLAG] &= ~$TERMIOS_NORMAL_IOFF;
      $termios[$TERMIOS_OFLAG] |= $TERMIOS_NORMAL_OON;
      $termios[$TERMIOS_OFLAG] &= ~$TERMIOS_NORMAL_OOFF;
      $termios[$TERMIOS_LFLAG] |= $TERMIOS_NORMAL_LON;
      $termios[$TERMIOS_LFLAG] &= ~$TERMIOS_NORMAL_LOFF;
      $termios = pack($termios_t,@termios);
      &ioctl($term_IN,$TCSETS,$termios) || die "Can't ioctl TCSETS: $!";
  
  # print "after ResetTTY\n\r";
  # system 'stty -a';
  }
  
  ##
  ## WordBreak(index)
  ##
  ## Returns true if the character at INDEX into $line is a basic word break
  ## character, false otherwise.
  ##
  sub WordBreak
  {
      index($rl_basic_word_break_characters, substr($line,$_[0],1)) != -1;
  }
  
  sub getstate
  {
      ($D, $si, $LastCommandKilledText, $KillBuffer, $line) = @{$_[0]};
      $ThisCommandKilledText = $LastCommandKilledText;
  }
  
  ##
  ## kills from D=$_[0] to $_[1] (to the killbuffer if $_[2] is true)
  ##
  sub kill_text
  {
      my($from, $to, $save) = (&min($_[0], $_[1]), &max($_[0], $_[1]), $_[2]);
      my $len = $to - $from;
      if ($save) {
  	$KillBuffer = '' if !$LastCommandKilledText;
  	if ($from < $LastCommandKilledText - 1) {
  	  $KillBuffer = substr($line, $from, $len) . $KillBuffer;
  	} else {
  	  $KillBuffer .= substr($line, $from, $len);
  	}
  	$ThisCommandKilledText = 1 + $from;
      }
      substr($line, $from, $len) = '';
  
      ## adjust $D
      if ($D > $from) {
  	$D -= $len;
  	$D = $from if $D < $from;
      }
  }
  
  
  ###########################################################################
  ## Bindable functions... pretty much in the same order as in readline.c ###
  ###########################################################################
  
  ##
  ## Returns true if $D at the end of the line.
  ##
  sub at_end_of_line
  {
      ($D + &CharSize($D)) == (length($line) + 1);
  }
  
  
  ##
  ## Move forward (right) $count characters.
  ##
  sub F_ForwardChar
  {
      my $count = shift;
      return &F_BackwardChar(-$count) if $count < 0;
  
      while (!&at_end_of_line && $count-- > 0) {
  	$D += &CharSize($D);
      }
  }
  
  ##
  ## Move backward (left) $count characters.
  ##
  sub F_BackwardChar
  {
      my $count = shift;
      return &F_ForwardChar(-$count) if $count < 0;
  
      while (($D > 0) && ($count-- > 0)) {
  	$D--;  		           ## Move back one regardless,
  	$D-- if &OnSecondByte($D); ## another if over a big char.
      }
  }
  
  ##
  ## Go to beginning of line.
  ##
  sub F_BeginningOfLine
  {
      $D = 0;
  }
  
  ##
  ## Move to the end of the line.
  ##
  sub F_EndOfLine
  {
      &F_ForwardChar(100) while !&at_end_of_line;
  }
  
  ##
  ## Move to the end of this/next word.
  ## Done as many times as $count says.
  ##
  sub F_ForwardWord
  {
      my $count = shift;
      return &F_BackwardWord(-$count) if $count < 0;
  
      while (!&at_end_of_line && $count-- > 0)
      {
  	## skip forward to the next word (if not already on one)
  	&F_ForwardChar(1) while !&at_end_of_line && &WordBreak($D);
  	## skip forward to end of word
  	&F_ForwardChar(1) while !&at_end_of_line && !&WordBreak($D);
      }
  }
  
  ##
  ## 
  ## Move to the beginning of this/next word.
  ## Done as many times as $count says.
  ##
  sub F_BackwardWord
  {
      my $count = shift;
      return &F_ForwardWord(-$count) if $count < 0;
  
      while ($D > 0 && $count-- > 0) {
  	## skip backward to the next word (if not already on one)
  	&F_BackwardChar(1) while (($D > 0) && &WordBreak($D-1));
  	## skip backward to start of word
  	&F_BackwardChar(1) while (($D > 0) && !&WordBreak($D-1));
      }
  }
  
  ##
  ## Refresh the input line.
  ##
  sub F_RedrawCurrentLine
  {
      $force_redraw = 1;
  }
  
  ##
  ## Clear the screen and refresh the line.
  ## If given a numeric arg other than 1, simply refreshes the line.
  ##
  sub F_ClearScreen
  {
      my $count = shift;
      return &F_RedrawCurrentLine if $count != 1;
  
      $rl_CLEAR = `clear` if !defined($rl_CLEAR);
      local $\ = '';
      print $term_OUT $rl_CLEAR;
      $force_redraw = 1;
  }
  
  ##
  ## Insert the next character read verbatim.
  ##
  sub F_QuotedInsert
  {
      my $count = shift;
      &F_SelfInsert($count, ord(&getc_with_pending));
  }
  
  ##
  ## Insert a tab.
  ##
  sub F_TabInsert
  {
      my $count = shift;
      &F_SelfInsert($count, ord("\t"));
  }
  
  ## Operate - accept the current line and fetch from the
  ## history the next line relative to current line for default.
  sub F_OperateAndGetNext
  {
      my $count = shift;
  
      &F_AcceptLine;
  
      my $remainingEntries = $#rl_History - $rl_HistoryIndex;
      if ($count > 0 && $remainingEntries >= 0) {  # there is something to repeat
  	if ($remainingEntries > 0) {  # if we are not on last line
  	    $rl_HistoryIndex++;       # fetch next one
  	    $count = $remainingEntries if $count > $remainingEntries;
  	}
  	$rl_OperateCount = $count;
      }
  }
  
  ##
  ## Removes $count chars to left of cursor (if not at beginning of line).
  ## If $count > 1, deleted chars saved to kill buffer.
  ##
  sub F_BackwardDeleteChar
  {
      return if remove_selection();
  
      my $count = shift;
      return F_DeleteChar(-$count) if $count < 0;
      my $oldD = $D;
      &F_BackwardChar($count);
      return if $D == $oldD;
      &kill_text($oldD, $D, $count > 1);
  }
  
  ##
  ## Removes the $count chars from under the cursor.
  ## If there is no line and the last command was different, tells
  ## readline to return EOF.
  ## If there is a line, and the cursor is at the end of it, and we're in
  ## tcsh completion mode, then list possible completions.
  ## If $count > 1, deleted chars saved to kill buffer.
  ##
  sub F_DeleteChar
  {
      return if remove_selection();
  
      my $count = shift;
      return F_DeleteBackwardChar(-$count) if $count < 0;
      if (length($line) == 0) {	# EOF sent (probably OK in DOS too)
  	$AcceptLine = $ReturnEOF = 1 if $lastcommand ne 'F_DeleteChar';
  	return;
      }
      if ($D == length ($line))
      {
  	&complete_internal('?') if $var_TcshCompleteMode;
  	return;
      }
      my $oldD = $D;
      &F_ForwardChar($count);
      return if $D == $oldD;
      &kill_text($oldD, $D, $count > 1);
  }
  
  ##
  ## Kill to previous whitespace.
  ##
  sub F_UnixWordRubout
  {
      return &F_Ding if $D == 0;
      (my $oldD, local $rl_basic_word_break_characters) = ($D, "\t ");
  			     # JP:  Fixed a bug here - both were 'my'
      F_BackwardWord(1);
      kill_text($D, $oldD, 1);
  }
  
  ##
  ## Kill line from cursor to beginning of line.
  ##
  sub F_UnixLineDiscard
  {
      return &F_Ding if $D == 0;
      kill_text(0, $D, 1);
  }
  
  sub F_UpcaseWord     { &changecase($_[0], 'up');   }
  sub F_DownCaseWord   { &changecase($_[0], 'down'); }
  sub F_CapitalizeWord { &changecase($_[0], 'cap');  }
  
  ##
  ## Translated from GNUs readline.c
  ## One arg is 'up' to upcase $_[0] words,
  ##            'down' to downcase them,
  ##         or something else to capitolize them.
  ## If $_[0] is negative, the dot is not moved.
  ##
  sub changecase
  {
      my $op = $_[1];
  
      my ($start, $state, $c, $olddot) = ($D, 0);
      if ($_[0] < 0)
      {
  	$olddot = $D;
  	$_[0] = -$_[0];
      }
  
      &F_ForwardWord;  ## goes forward $_[0] words.
  
      while ($start < $D) {
  	$c = substr($line, $start, 1);
  
  	if ($op eq 'up') {
  	    $c = &toupper($c);
  	} elsif ($op eq 'down') {
  	    $c = &tolower($c);
  	} else { ## must be 'cap'
  	    if ($state == 1) {
  	        $c = &tolower($c);
  	    } else {
  	        $c = &toupper($c);
  		$state = 1;
  	    }
  	    $state = 0 if $c !~ tr/a-zA-Z//;
  	}
  
  	substr($line, $start, 1) = $c;
  	$start++;
      }
      $D = $olddot if defined($olddot);
  }
  
  sub F_TransposeWords {
      my $c = shift;
      return F_Ding() unless $c;
      # Find "this" word
      F_BackwardWord(1);
      my $p0 = $D;
      F_ForwardWord(1);
      my $p1 = $D;
      return F_Ding() if $p1 == $p0;
      my ($p2, $p3) = ($p0, $p1);
      if ($c > 0) {
        F_ForwardWord($c);
        $p3 = $D;
        F_BackwardWord(1);
        $p2 = $D;
      } else {
        F_BackwardWord(1 - $c);
        $p0 = $D;
        F_ForwardWord(1);
        $p1 = $D;
      }
      return F_Ding() if $p3 == $p2 or $p2 < $p1;
      my $r = substr $line, $p2, $p3 - $p2;
      substr($line, $p2, $p3 - $p2) = substr $line, $p0, $p1 - $p0;
      substr($line, $p0, $p1 - $p0) = $r;
      $D = $c > 0 ? $p3 : $p0 + $p3 - $p2; # End of "this" word after edit
      return 1;
  ## Exchange words: C-Left, C-right, C-right, C-left.  If positions do
  ## not overlap, we get two things to transpose.  Repeat count?
  }
  
  ##
  ## Switch char at dot with char before it.
  ## If at the end of the line, switch the previous two...
  ## (NOTE: this could screw up multibyte characters.. should do correctly)
  sub F_TransposeChars
  {
      if ($D == length($line) && $D >= 2) {
          substr($line,$D-2,2) = substr($line,$D-1,1).substr($line,$D-2,1);
      } elsif ($D >= 1) {
  	substr($line,$D-1,2) = substr($line,$D,1)  .substr($line,$D-1,1);
      } else {
  	&F_Ding;
      }
  }
  
  sub F_PreviousHistory {
      &get_line_from_history($rl_HistoryIndex - shift);
  }
  
  sub F_NextHistory {
      &get_line_from_history($rl_HistoryIndex + shift);
  }
  
  
  
  sub F_BeginningOfHistory
  {
      &get_line_from_history(0);
  }
  
  sub F_EndOfHistory
  {
      &get_line_from_history(@rl_History);
  }
  
  sub F_ReverseSearchHistory
  {
      &DoSearch($_[0] >= 0 ? 1 : 0);
  }
  
  sub F_ForwardSearchHistory
  {
      &DoSearch($_[0] >= 0 ? 0 : 1);
  }
  
  sub F_HistorySearchBackward
  {
      &DoSearchStart(($_[0] >= 0 ? 1 : 0),substr($line,0,$D));
  }
  
  sub F_HistorySearchForward
  {
      &DoSearchStart(($_[0] >= 0 ? 0 : 1),substr($line,0,$D));
  }
  
  ## returns a new $i or -1 if not found.
  sub search { 
    my ($i, $str) = @_;
    return -1 if $i < 0 || $i > $#rl_History; 	 ## for safety
    while (1) {
      return $i if rindex($rl_History[$i], $str) >= 0;
      if ($reverse) {
        return -1 if $i-- == 0;
      } else {
        return -1 if $i++ == $#rl_History;
      }
    }
  }
  
  sub DoSearch
  {
      local $reverse = shift;	# Used in search()
      my $oldline = $line;
      my $oldD = $D;
  
      my $searchstr = '';  ## string we're searching for
      my $I = -1;  	     ## which history line
  
      $si = 0;
  
      while (1)
      {
  	if ($I != -1) {
  	    $line = $rl_History[$I];
  	    $D += index($rl_History[$I], $searchstr);
  	}
  	&redisplay( '('.($reverse?'reverse-':'') ."i-search) `$searchstr': ");
  
  	$c = &getc_with_pending;
  	if (($KeyMap[ord($c)] || 0) eq 'F_ReverseSearchHistory') {
  	    if ($reverse && $I != -1) {
  		if ($tmp = &search($I-1,$searchstr), $tmp >= 0) {
  		    $I = $tmp;
  		} else {
  		    &F_Ding;
  		}
  	    }
  	    $reverse = 1;
  	} elsif (($KeyMap[ord($c)] || 0) eq 'F_ForwardSearchHistory') {
  	    if (!$reverse && $I != -1) {
  		if ($tmp = &search($I+1,$searchstr), $tmp >= 0) {
  		    $I = $tmp;
  		} else {
  		    &F_Ding;
  		}
  	    }
  	    $reverse = 0;
          } elsif ($c eq "\007") {  ## abort search... restore line and return
  	    $line = $oldline;
  	    $D = $oldD;
  	    return;
          } elsif (ord($c) < 32 || ord($c) > 126) {
  	    push(@Pending, $c) if $c ne "\e";
  	    if ($I < 0) {
  		## just restore
  		$line = $oldline;
  		$D = $oldD;
  	    } else {
  		#chose this line
  		$line = $rl_History[$I];
  		$D = index($rl_History[$I], $searchstr);
  	    }
  	    &redisplay();
  	    last;
  	} else {
  	    ## Add this character to the end of the search string and
  	    ## see if that'll match anything.
  	    $tmp = &search($I < 0 ? $rl_HistoryIndex-$reverse: $I, $searchstr.$c);
  	    if ($tmp == -1) {
  		&F_Ding;
  	    } else {
  		$searchstr .= $c;
  		$I = $tmp;
  	    }
  	}
      }
  }
  
  ## returns a new $i or -1 if not found.
  sub searchStart { 
    my ($i, $reverse, $str) = @_;
    $i += $reverse ? - 1: +1;
    return -1 if $i < 0 || $i > $#rl_History;  ## for safety
    while (1) {
      return $i if index($rl_History[$i], $str) == 0;
      if ($reverse) {
        return -1 if $i-- == 0;
      } else {
        return -1 if $i++ == $#rl_History;
      }
    }
  }
  
  sub DoSearchStart
  {
      my ($reverse,$what) = @_;
      my $i = searchStart($rl_HistoryIndex, $reverse, $what);
      return if $i == -1;
      $rl_HistoryIndex = $i;
      ($D, $line) = (0, $rl_History[$rl_HistoryIndex]);
      F_BeginningOfLine();
      F_ForwardChar(length($what));
  
  }
  
  ###########################################################################
  ###########################################################################
  
  ##
  ## Kill from cursor to end of line.
  ##
  sub F_KillLine
  {
      my $count = shift;
      return F_BackwardKillLine(-$count) if $count < 0;
      kill_text($D, length($line), 1);
  }
  
  ##
  ## Delete from cursor to beginning of line.
  ##
  sub F_BackwardKillLine
  {
      my $count = shift;
      return F_KillLine(-$count) if $count < 0;
      return F_Ding if $D == 0;
      kill_text(0, $D, 1);
  }
  
  ##
  ## TextInsert(count, string)
  ##
  sub TextInsert {
    my $count = shift;
    my $text2add = shift(@_) x $count;
    if ($InsertMode) {
      substr($line,$D,0) .= $text2add;
    } else {
      substr($line,$D,length($text2add)) = $text2add;
    }
    $D += length($text2add);
  }
  
  sub F_Yank
  {
      remove_selection();
      &TextInsert($_[0], $KillBuffer);
  }
  
  sub F_YankPop    {
     1;
     ## not implemented yet
  }
  
  sub F_YankNthArg {
     1;
     ## not implemented yet
  }
  
  ##
  ## Kill to the end of the current word. If not on a word, kill to
  ## the end of the next word.
  ##
  sub F_KillWord
  {
      my $count = shift;
      return &F_BackwardKillWord(-$count) if $count < 0;
      my $oldD = $D;
      &F_ForwardWord($count);	## moves forward $count words.
      kill_text($oldD, $D, 1);
  }
  
  ##
  ## Kill backward to the start of the current word, or, if currently
  ## not on a word (or just at the start of a word), to the start of the
  ## previous word.
  ##
  sub F_BackwardKillWord
  {
      my $count = shift;
      return F_KillWord(-$count) if $count < 0;
      my $oldD = $D;
      &F_BackwardWord($count);	## moves backward $count words.
      kill_text($D, $oldD, 1);
  }
  
  ###########################################################################
  ###########################################################################
  
  
  ##
  ## Abort the current input.
  ##
  sub F_Abort
  {
      &F_Ding;
  }
  
  
  ##
  ## If the character that got us here is upper case,
  ## do the lower-case equiv...
  ##
  sub F_DoLowercaseVersion
  {
      if ($_[1] >= ord('A') && $_[1] <= ord('Z')) {
  	&do_command(*KeyMap, $_[0], $_[1] - ord('A') + ord('a'));
      } else {
  	&F_Ding;
      }
  }
  
  ##
  ## do the equiv with control key...
  ##
  sub F_DoControlVersion
  {
      local *KeyMap = $var_EditingMode;
      my $key = $_[1];
  
      if ($key == ord('?')) {
  	$key = 0x7F;
      } else {
  	$key &= ~(0x80 | 0x60);
      }
      &do_command(*KeyMap, $_[0], $key);
  }
  
  ##
  ## do the equiv with meta key...
  ##
  sub F_DoMetaVersion
  {
      local *KeyMap = $var_EditingMode;
      unshift @Pending, chr $_[1];
  
      &do_command(*KeyMap, $_[0], ord "\e");
  }
  
  ##
  ## If the character that got us here is Alt-Char,
  ## do the Esc Char equiv...
  ##
  sub F_DoEscVersion
  {
      my ($ord, $t) = $_[1];
      &F_Ding unless $KeyMap{'Esc'};
      for $t (([ord 'w', '`1234567890-='],
  	     [ord ',', 'zxcvbnm,./\\'],
  	     [16,      'qwertyuiop[]'],
  	     [ord(' ') - 2, 'asdfghjkl;\''])) {
        next unless $ord >= $t->[0] and $ord < $t->[0] + length($t->[1]);
        $ord = ord substr $t->[1], $ord - $t->[0], 1;
        return &do_command($KeyMap{'Esc'}, $_[0], $ord);
      }
      &F_Ding;
  }
  
  ##
  ## Undo one level.
  ##
  sub F_Undo
  {
      pop(@undo); # unless $undo[-1]->[5]; ## get rid of the state we just put on, so we can go back one.
      if (@undo) {
  	&getstate(pop(@undo));
      } else {
  	&F_Ding;
      }
  }
  
  ##
  ## Replace the current line to some "before" state.
  ##
  sub F_RevertLine
  {
      if ($rl_HistoryIndex >= $#rl_History+1) {
  	$line = $line_for_revert;
      } else {
  	$line = $rl_History[$rl_HistoryIndex];
      }
      $D = length($line);
  }
  
  sub F_EmacsEditingMode
  {
      $var_EditingMode = $var_EditingMode{'emacs'};
      $Vi_mode = 0;
  }
  
  ###########################################################################
  ###########################################################################
  
  
  ##
  ## (Attempt to) interrupt the current program.
  ##
  sub F_Interrupt
  {
      local $\ = '';
      print $term_OUT "\r\n";
      &ResetTTY;
      kill ("INT", 0);
  
      ## We're back.... must not have died.
      $force_redraw = 1;
  }
  
  ##
  ## Execute the next character input as a command in a meta keymap.
  ##
  sub F_PrefixMeta
  {
      my($count, $keymap) = ($_[0], "$KeyMap{'name'}_$_[1]");
      ##print "F_PrefixMeta [$keymap]\n\r";
      die "<internal error, $_[1]>" unless %$keymap;
      do_command(*$keymap, $count, ord(&getc_with_pending));
  }
  
  sub F_UniversalArgument
  {
      &F_DigitArgument;
  }
  
  ##
  ## For typing a numeric prefix to a command....
  ##
  sub F_DigitArgument
  {
      my $in = chr $_[1];
      my ($NumericArg, $sawDigit) = (1, 0);
      my ($increment, $ord);
      ($NumericArg, $sawDigit) = ($_[0], $_[0] !~ /e0$/i)
  	if $doingNumArg;	# XXX What if Esc-- 1 ?
  
      do
      {
  	$ord = ord $in;
  	if (defined($KeyMap[$ord]) && $KeyMap[$ord] eq 'F_UniversalArgument') {
  	    $NumericArg *= 4;
  	} elsif ($ord == ord('-') && !$sawDigit) {
  	    $NumericArg = -$NumericArg;
  	} elsif ($ord >= ord('0') && $ord <= ord('9')) {
  	    $increment = ($ord - ord('0')) * ($NumericArg < 0 ? -1 : 1);
  	    if ($sawDigit) {
  		$NumericArg = $NumericArg * 10 + $increment;
  	    } else {
  		$NumericArg = $increment;
  		$sawDigit = 1;
  	    }
  	} else {
  	    local(*KeyMap) = $var_EditingMode;
  	    &redisplay();
  	    $doingNumArg = 1;		# Allow NumArg inside NumArg
  	    &do_command(*KeyMap, $NumericArg . ($sawDigit ? '': 'e0'), $ord);
  	    return;
  	}
  	## make sure it's not toooo big.
  	if ($NumericArg > $rl_max_numeric_arg) {
  	    $NumericArg = $rl_max_numeric_arg;
  	} elsif ($NumericArg < -$rl_max_numeric_arg) {
  	    $NumericArg = -$rl_max_numeric_arg;
  	}
  	&redisplay(sprintf("(arg %d) ", $NumericArg));
      } while defined($in = &getc_with_pending);
  }
  
  sub F_OverwriteMode
  {
      $InsertMode = 0;
  }
  
  sub F_InsertMode
  {
      $InsertMode = 1;
  }
  
  sub F_ToggleInsertMode
  {
      $InsertMode = !$InsertMode;
  }
  
  ##
  ## (Attempt to) suspend the program.
  ##
  sub F_Suspend
  {
      if ($inDOS && length($line)==0) { # EOF sent
  	$AcceptLine = $ReturnEOF = 1 if $lastcommand ne 'F_DeleteChar';
  	return;
      }
      local $\ = '';
      print $term_OUT "\r\n";
      &ResetTTY;
      eval { kill ("TSTP", 0) };
      ## We're back....
      &SetTTY;
      $force_redraw = 1;
  }
  
  ##
  ## Ring the bell.
  ## Should do something with $var_PreferVisibleBell here, but what?
  ##
  sub F_Ding {
      local $\ = '';
      print $term_OUT "\007";
      return;    # Undefined return value
  }
  
  ##########################################################################
  #### command/file completion  ############################################
  ##########################################################################
  
  ##
  ## How Command Completion Works
  ##
  ## When asked to do a completion operation, readline isolates the word
  ## to the immediate left of the cursor (i.e. what's just been typed).
  ## This information is then passed to some function (which may be supplied
  ## by the user of this package) which will return an array of possible
  ## completions.
  ##
  ## If there is just one, that one is used.  Otherwise, they are listed
  ## in some way (depends upon $var_TcshCompleteMode).
  ##
  ## The default is to do filename completion.  The function that performs
  ## this task is readline'rl_filename_list.
  ##
  ## A minimal-trouble way to have command-completion is to call
  ## readline'rl_basic_commands with an array of command names, such as
  ##    &readline'rl_basic_commands('quit', 'run', 'set', 'list')
  ## Those command names will then be used for completion if the word being
  ## completed begins the line. Otherwise, completion is disallowed.
  ##
  ## The way to have the most power is to provide a function to readline
  ## which will accept information about a partial word that needs completed,
  ## and will return the appropriate list of possibilities.
  ## This is done by setting $readline'rl_completion_function to the name of
  ## the function to run.
  ##
  ## That function will be called with three args ($text, $line, $start).
  ## TEXT is the partial word that should be completed.  LINE is the entire
  ## input line as it stands, and START is the index of the TEXT in LINE
  ## (i.e. zero if TEXT is at the beginning of LINE).
  ##
  ## A cool completion function will look at LINE and START and give context-
  ## sensitive completion lists. Consider something that will do completion
  ## for two commands
  ## 	cat FILENAME
  ##	finger USERNAME
  ##	status [this|that|other]
  ##
  ## It (untested) might look like:
  ##
  ##	$readline'rl_completion_function = "main'complete";
  ##	sub complete { local($text, $_, $start) = @_;
  ##	    ## return commands which may match if at the beginning....
  ##	    return grep(/^$text/, 'cat', 'finger') if $start == 0;
  ##	    return &rl_filename_list($text) if /^cat\b/;
  ##	    return &my_namelist($text) if /^finger\b/;
  ##	    return grep(/^text/, 'this', 'that','other') if /^status\b/;
  ##	    ();
  ##	}
  ## Of course, a real completion function would be more robust, but you
  ## get the idea (I hope).
  ##
  
  ##
  ## List possible completions
  ##
  sub F_PossibleCompletions
  {
      &complete_internal('?');
  }
  
  ##
  ## List possible completions
  ##
  sub F_InsertPossibleCompletions
  {
      &complete_internal('*');
  }
  
  ##
  ## Do a completion operation.
  ## If the last thing we did was a completion operation, we'll
  ## now list the options available (under normal emacs mode).
  ##
  ## Under TcshCompleteMode, each contiguous subsequent completion operation
  ## lists another of the possible options.
  ##
  ## Returns true if a completion was done, false otherwise, so vi completion
  ##     routines can test it.
  ##
  sub F_Complete
  {
      if ($lastcommand eq 'F_Complete') {
  	if ($var_TcshCompleteMode && @tcsh_complete_selections > 0) {
  	    substr($line, $tcsh_complete_start, $tcsh_complete_len)
  		= $tcsh_complete_selections[0];
  	    $D -= $tcsh_complete_len;
  	    $tcsh_complete_len = length($tcsh_complete_selections[0]);
  	    $D += $tcsh_complete_len;
  	    push(@tcsh_complete_selections, shift(@tcsh_complete_selections));
  	} else {
  	    &complete_internal('?') or return;
  	}
      } else {
  	@tcsh_complete_selections = ();
  	&complete_internal("\t") or return;
      }
  
      1;
  }
  
  ##
  ## The meat of command completion. Patterned closely after GNU's.
  ##
  ## The supposedly partial word at the cursor is "completed" as per the
  ## single argument:
  ##	"\t"	complete as much of the word as is unambiguous
  ##	"?"	list possibilities.
  ## 	"*"	replace word with all possibilities. (who would use this?)
  ##
  ## A few notable variables used:
  ##   $rl_completer_word_break_characters
  ##	-- characters in this string break a word.
  ##   $rl_special_prefixes
  ##	-- but if in this string as well, remain part of that word.
  ##
  ## Returns true if a completion was done, false otherwise, so vi completion
  ##     routines can test it.
  ##
  sub complete_internal
  {
      my $what_to_do = shift;
      my ($point, $end) = ($D, $D);
  
      # In vi mode, complete if the cursor is at the *end* of a word, not
      #     after it.
      ($point++, $end++) if $Vi_mode;
  
      if ($point)
      {
          ## Not at the beginning of the line; Isolate the word to be completed.
  	1 while (--$point && (-1 == index($rl_completer_word_break_characters,
  		substr($line, $point, 1))));
  
  	# Either at beginning of line or at a word break.
  	# If at a word break (that we don't want to save), skip it.
  	$point++ if (
      		(index($rl_completer_word_break_characters,
  		       substr($line, $point, 1)) != -1) &&
      		(index($rl_special_prefixes, substr($line, $point, 1)) == -1)
  	);
      }
  
      my $text = substr($line, $point, $end - $point);
      $rl_completer_terminator_character = ' ';
      @matches = &completion_matches($rl_completion_function,$text,$line,$point);
  
      if (@matches == 0) {
  	return &F_Ding;
      } elsif ($what_to_do eq "\t") {
  	my $replacement = shift(@matches);
  	$replacement .= $rl_completer_terminator_character if @matches == 1;
  	&F_Ding if @matches != 1;
  	if ($var_TcshCompleteMode) {
  	    @tcsh_complete_selections = (@matches, $text);
  	    $tcsh_complete_start = $point;
  	    $tcsh_complete_len = length($replacement);
  	}
  	if ($replacement ne '') {
  	    substr($line, $point, $end-$point) = $replacement;
  	    $D = $D - ($end - $point) + length($replacement);
  	}
      } elsif ($what_to_do eq '?') {
  	shift(@matches); ## remove prepended common prefix
  	local $\ = '';
  	print $term_OUT "\n\r";
  	# print "@matches\n\r";
  	&pretty_print_list (@matches);
  	$force_redraw = 1;
      } elsif ($what_to_do eq '*') {
  	shift(@matches); ## remove common prefix.
  	local $" = $rl_completer_terminator_character;
  	my $replacement = "@matches$rl_completer_terminator_character";
  	substr($line, $point, $end-$point) = $replacement; ## insert all.
  	$D = $D - ($end - $point) + length($replacement);
      } else {
  	warn "\r\n[Internal error]";
  	return &F_Ding;
      }
  
      1;
  }
  
  ##
  ## completion_matches(func, text, line, start)
  ##
  ## FUNC is a function to call as FUNC(TEXT, LINE, START)
  ## 	where TEXT is the item to be completed
  ##	      LINE is the whole command line, and
  ##	      START is the starting index of TEXT in LINE.
  ## The FUNC should return a list of items that might match.
  ##
  ## completion_matches will return that list, with the longest common
  ## prefix prepended as the first item of the list.  Therefor, the list
  ## will either be of zero length (meaning no matches) or of 2 or more.....
  ##
  
  ## Works with &rl_basic_commands. Return items from @rl_basic_commands
  ## that start with the pattern in $text.
  sub use_basic_commands {
    my ($text, $line, $start) = @_;
    return () if $start != 0;
    grep(/^$text/, @rl_basic_commands);
  }
  
  sub completion_matches
  {
      my ($func, $text, $line, $start) = @_;
  
      ## get the raw list
      my @matches;
  
      #print qq/\r\neval("\@matches = &$func(\$text, \$line, \$start)\n\r/;#DEBUG
      #eval("\@matches = &$func(\$text, \$line, \$start);1") || warn "$@ ";
      @matches = &$func($text, $line, $start);
  
      ## if anything returned , find the common prefix among them
      if (@matches) {
  	my $prefix = $matches[0];
  	my $len = length($prefix);
  	for ($i = 1; $i < @matches; $i++) {
  	    next if substr($matches[$i], 0, $len) eq $prefix;
  	    $prefix = substr($prefix, 0, --$len);
  	    last if $len == 0;
  	    $i--; ## retry this one to see if the shorter one matches.
  	}
  	unshift(@matches, $prefix); ## make common prefix the first thing.
      }
      @matches;
  }
  
  ##
  ## For use in passing to completion_matches(), returns a list of
  ## filenames that begin with the given pattern.  The user of this package
  ## can set $rl_completion_function to 'rl_filename_list' to restore the
  ## default of filename matching if they'd changed it earlier, either
  ## directly or via &rl_basic_commands.
  ##
  sub rl_filename_list
  {
      my $pattern = $_[0];
      my @files = (<$pattern*>);
      if ($var_CompleteAddsuffix) {
  	foreach (@files) {
  	    if (-l $_) {
  		$_ .= '@';
  	    } elsif (-d _) {
  		$_ .= '/';
  	    } elsif (-x _) {
  		$_ .= '*';
  	    } elsif (-S _ || -p _) {
  		$_ .= '=';
  	    }
  	}
      }
      return @files;
  }
  
  ##
  ## For use by the user of the package. Called with a list of possible
  ## commands, will allow command completion on those commands, but only
  ## for the first word on a line.
  ## For example: &rl_basic_commands('set', 'quit', 'type', 'run');
  ##
  ## This is for people that want quick and simple command completion.
  ## A more thoughtful implementation would set $rl_completion_function
  ## to a routine that would look at the context of the word being completed
  ## and return the appropriate possibilities.
  ##
  sub rl_basic_commands
  {
       @rl_basic_commands = @_;
       $rl_completion_function = 'use_basic_commands';
  }
  
  ##
  ## Print an array in columns like ls -C.  Originally based on stuff
  ## (lsC2.pl) by utashiro@sran230.sra.co.jp (Kazumasa Utashiro).
  ##
  sub pretty_print_list
  {
      my @list = @_;
      return unless @list;
      my ($lines, $columns, $mark, $index);
  
      ## find width of widest entry
      my $maxwidth = 0;
      grep(length > $maxwidth && ($maxwidth = length), @list);
      $maxwidth++;
  
      $columns = $maxwidth >= $rl_screen_width
  	       ? 1 : int($rl_screen_width / $maxwidth);
  
      ## if there's enough margin to interspurse among the columns, do so.
      $maxwidth += int(($rl_screen_width % $maxwidth) / $columns);
  
      $lines = int((@list + $columns - 1) / $columns);
      $columns-- while ((($lines * $columns) - @list + 1) > $lines);
  
      $mark = $#list - $lines;
      local $\ = '';
      for ($l = 0; $l < $lines; $l++) {
  	for ($index = $l; $index <= $mark; $index += $lines) {
  	    printf("%-$ {maxwidth}s", $list[$index]);
  	}
     	print $term_OUT $list[$index] if $index <= $#list;
  	print $term_OUT "\n\r";
      }
  }
  
  ##----------------- Vi Routines --------------------------------
  
  sub F_ViAcceptLine
  {
      &F_AcceptLine();
      &F_ViInput();
  }
  
  # Repeat the most recent one of these vi commands:
  #
  #   a A c C d D i I p P r R s S x X ~ 
  #
  sub F_ViRepeatLastCommand {
      my($count) = @_;
      return &F_Ding if !$Last_vi_command;
  
      my @lastcmd = @$Last_vi_command;
  
      # Multiply @lastcmd's numeric arg by $count.
      unless ($count == 1) {
  
  	my $n = '';
  	while (@lastcmd and $lastcmd[0] =~ /^\d$/) {
  	    $n *= 10;
  	    $n += shift(@lastcmd);
  	}
  	$count *= $n unless $n eq '';
  	unshift(@lastcmd, split(//, $count));
      }
  
      push(@Pending, @lastcmd);
  }
  
  sub F_ViMoveCursor
  {
      my($count, $ord) = @_;
  
      my $new_cursor = &get_position($count, $ord, undef, $Vi_move_patterns);
      return &F_Ding if !defined $new_cursor;
  
      $D = $new_cursor;
  }
  
  sub F_ViFindMatchingParens {
  
      # Move to the first parens at or after $D
      my $old_d = $D;
      &forward_scan(1, q/[^[\](){}]*/);
      my $parens = substr($line, $D, 1);
  
      my $mate_direction = {
  		    '('  =>  [ ')',  1 ],
  		    '['  =>  [ ']',  1 ],
  		    '{'  =>  [ '}',  1 ],
  		    ')'  =>  [ '(', -1 ],
  		    ']'  =>  [ '[', -1 ],
  		    '}'  =>  [ '{', -1 ],
  
  		}->{$parens};
  
      return &F_Ding() unless $mate_direction;
  
      my($mate, $direction) = @$mate_direction;
  
      my $lvl = 1;
      while ($lvl) {
  	last if !$D && ($direction < 0);
  	&F_ForwardChar($direction);
  	last if &at_end_of_line;
  	my $c = substr($line, $D, 1);
  	if ($c eq $parens) {
  	    $lvl++;
  	}
  	elsif ($c eq $mate) {
  	    $lvl--;
  	}
      }
  
      if ($lvl) {
  	# We didn't find a match
  	$D = $old_d;
  	return &F_Ding();
      }
  }
  
  sub F_ViForwardFindChar {
      &do_findchar(1, 1, @_);
  }
  
  sub F_ViBackwardFindChar {
      &do_findchar(-1, 0, @_);
  }
  
  sub F_ViForwardToChar {
      &do_findchar(1, 0, @_);
  }
  
  sub F_ViBackwardToChar {
      &do_findchar(-1, 1, @_);
  }
  
  sub F_ViMoveCursorTo
  {
      &do_findchar(1, -1, @_);
  }
  
  sub F_ViMoveCursorFind
  {
      &do_findchar(1, 0, @_);
  }
  
  
  sub F_ViRepeatFindChar {
      my($n) = @_;
      return &F_Ding if !defined $Last_findchar;
      &findchar(@$Last_findchar, $n);
  }
  
  sub F_ViInverseRepeatFindChar {
      my($n) = @_;
      return &F_Ding if !defined $Last_findchar;
      my($c, $direction, $offset) = @$Last_findchar;
      &findchar($c, -$direction, $offset, $n);
  }
  
  sub do_findchar {
      my($direction, $offset, $n) = @_;
      my $c = &getc_with_pending;
      $c = &getc_with_pending if $c eq "\cV";
      return &F_ViCommandMode if $c eq "\e";
      $Last_findchar = [$c, $direction, $offset];
      &findchar($c, $direction, $offset, $n);
  }
  
  sub findchar {
      my($c, $direction, $offset, $n) = @_;
      my $old_d = $D;
      while ($n) {
  	last if !$D && ($direction < 0);
  	&F_ForwardChar($direction);
  	last if &at_end_of_line;
  	my $char = substr($line, $D, 1);
  	$n-- if substr($line, $D, 1) eq $c;
      }
      if ($n) {
  	# Not found
  	$D = $old_d;
  	return &F_Ding;
      }
      &F_ForwardChar($offset);
  }
  
  sub F_ViMoveToColumn {
      my($n) = @_;
      $D = 0;
      my $col = 1;
      while (!&at_end_of_line and $col < $n) {
  	my $c = substr($line, $D, 1);
  	if ($c eq "\t") {
  	    $col += 7;
  	    $col -= ($col % 8) - 1;
  	}
  	else {
  	    $col++;
  	}
  	$D += &CharSize($D);
      }
  }
  
  sub start_dot_buf {
      my($count, $ord) = @_;
      $Dot_buf = [pack('c', $ord)];
      unshift(@$Dot_buf, split(//, $count)) if $count > 1;
      $Dot_state = savestate();
  }
  
  sub end_dot_buf {
      # We've recognized an editing command
  
      # Save the command keystrokes for use by '.'
      $Last_vi_command = $Dot_buf;
      undef $Dot_buf;
  
      # Save the pre-command state for use by 'u' and 'U';
      $Vi_undo_state     = $Dot_state;
      $Vi_undo_all_state = $Dot_state if !$Vi_undo_all_state;
  
      # Make sure the current line is treated as new line for history purposes.
      $rl_HistoryIndex = $#rl_History + 1;
  }
  
  sub save_dot_buf {
      &start_dot_buf(@_);
      &end_dot_buf;
  }
  
  sub F_ViUndo {
      return &F_Ding unless defined $Vi_undo_state;
      my $state = savestate();
      &getstate($Vi_undo_state);
      $Vi_undo_state = $state;
  }
  
  sub F_ViUndoAll {
      $Vi_undo_state = $Vi_undo_all_state;
      &F_ViUndo;
  }
  
  sub F_ViChange
  {
      my($count, $ord) = @_;
      &start_dot_buf(@_);
      &do_delete($count, $ord, $Vi_change_patterns) || return();
      &vi_input_mode;
  }
  
  sub F_ViDelete
  {
      my($count, $ord) = @_;
      &start_dot_buf(@_);
      &do_delete($count, $ord, $Vi_delete_patterns);
      &end_dot_buf;
  }
  
  sub do_delete {
  
      my($count, $ord, $poshash) = @_;
  
      my $other_end = &get_position($count, undef, $ord, $poshash);
      return &F_Ding if !defined $other_end;
  
      if ($other_end < 0) {
  	# dd - delete entire line
  	&kill_text(0, length($line), 1);
      }
      else {
  	&kill_text($D, $other_end, 1);
      }
  
      1;    # True return value
  }
  
  sub F_ViDeleteChar {
      my($count) = @_;
      &save_dot_buf(@_);
      my $other_end = $D + $count;
      $other_end = length($line) if $other_end > length($line);
      &kill_text($D, $other_end, 1);
  }
  
  sub F_ViBackwardDeleteChar {
      my($count) = @_;
      &save_dot_buf(@_);
      my $other_end = $D - $count;
      $other_end = 0 if $other_end < 0;
      &kill_text($other_end, $D, 1);
      $D = $other_end;
  }
  
  ##
  ## Prepend line with '#', add to history, and clear the input buffer
  ##     (this feature was borrowed from ksh).
  ##
  sub F_SaveLine
  {
      local $\ = '';
      $line = '#'.$line;
      &redisplay();
      print $term_OUT "\r\n";
      &add_line_to_history;
      $line_for_revert = '';
      &get_line_from_history(scalar @rl_History);
      &F_ViInput() if $Vi_mode;
  }
  
  #
  # Come here if we see a non-positioning keystroke when a positioning
  #     keystroke is expected.
  #
  sub F_ViNonPosition {
      # Not a positioning command - undefine the cursor to indicate the error
      #     to get_position().
      undef $D;
  }
  
  #
  # Come here if we see <esc><char>, but *not* an arrow key or other
  #     mapped sequence, when a positioning keystroke is expected.
  #
  sub F_ViPositionEsc {
      my($count, $ord) = @_;
  
      # We got <esc><char> in vipos mode.  Put <char> back onto the
      #     input stream and terminate the positioning command.
      unshift(@Pending, pack('c', $ord));
      &F_ViNonPosition;
  }
  
  # Interpret vi positioning commands
  sub get_position {
      my ($count, $ord, $fullline_ord, $poshash) = @_;
  
      # Manipulate a copy of the cursor, not the real thing
      local $D = $D;
  
      # $ord (first character of positioning command) is an optional argument.
      $ord = ord(&getc_with_pending) if !defined $ord;
  
      # Detect double character (for full-line operation, e.g. dd)
      return -1 if defined $fullline_ord and $ord == $fullline_ord;
  
      my $re = $poshash->{$ord};
  
      if ($re) {
  	my $c = pack('c', $ord);
  	if (lc($c) eq 'b') {
  	    &backward_scan($count, $re);
  	}
  	else {
  	    &forward_scan($count, $re);
  	}
      }
      else {
  	# Move the local copy of the cursor
  	&do_command($var_EditingMode{'vipos'}, $count, $ord);
      }
  
      # Return the new cursor (undef if illegal command)
      $D;
  }
  
  ##
  ## Go to first non-space character of line.
  ##
  sub F_ViFirstWord
  {
      $D = 0;
      &forward_scan(1, q{\s+});
  }
  
  sub forward_scan {
      my($count, $re) = @_;
      while ($count--) {
  	last unless substr($line, $D) =~ m{^($re)};
  	$D += length($1);
      }
  }
  
  sub backward_scan {
      my($count, $re) = @_;
      while ($count--) {
  	last unless substr($line, 0, $D) =~ m{($re)$};
  	$D -= length($1);
      }
  }
  
  # Note: like the emacs case transforms, this doesn't work for
  #       two-byte characters.
  sub F_ViToggleCase {
      my($count) = @_;
      &save_dot_buf(@_);
      while ($count-- > 0) {
  	substr($line, $D, 1) =~ tr/A-Za-z/a-zA-Z/;
  	&F_ForwardChar(1);
  	if (&at_end_of_line) {
  	    &F_BackwardChar(1);
  	    last;
  	}
      }
  }
  
  # Go to the numbered history line, as listed by the 'H' command, i.e. the
  #     current $line is line 1, the youngest line in @rl_History is 2, etc.
  sub F_ViHistoryLine {
      my($n) = @_;
      &get_line_from_history(@rl_History - $n + 1);
  }
  
  sub get_line_from_history {
      my($n) = @_;
      return &F_Ding if $n < 0 or $n > @rl_History;
      return if $n == $rl_HistoryIndex;
  
      # If we're moving from the currently-edited line, save it for later.
      $line_for_revert = $line if $rl_HistoryIndex == @rl_History;
  
      # Get line from history buffer (or from saved edit line).
      $line = ($n == @rl_History) ? $line_for_revert : $rl_History[$n];
      $D = $Vi_mode ? 0 : length $line;
  
      # Subsequent 'U' will bring us back to this point.
      $Vi_undo_all_state = savestate() if $Vi_mode;
  
      $rl_HistoryIndex = $n;
  }
  
  sub F_PrintHistory {
      my($count) = @_;
  
      $count = 20 if $count == 1;             # Default - assume 'H', not '1H'
      my $end = $rl_HistoryIndex + $count/2;
      $end = @rl_History if $end > @rl_History;
      my $start = $end - $count + 1;
      $start = 0 if $start < 0;
  
      my $lmh = length $rl_MaxHistorySize;
  
      my $lspace = ' ' x ($lmh+3);
      my $hdr = "$lspace-----";
      $hdr .= " (Use ESC <num> UP to retrieve command <num>) -----" unless $Vi_mode;
      $hdr .= " (Use '<num>G' to retrieve command <num>) -----" if $Vi_mode;
  
      local ($\, $,) = ('','');
      print "\n$hdr\n";
      print $lspace, ". . .\n" if $start > 0;
      my $i;
      my $shift = ($Vi_mode != 0);
      for $i ($start .. $end) {
  	print + ($i == $rl_HistoryIndex) ? '>' : ' ',
  
  		sprintf("%${lmh}d: ", @rl_History - $i + $shift),
  
  		($i < @rl_History)       ? $rl_History[$i] :
  		($i == $rl_HistoryIndex) ? $line           :
  		                           $line_for_revert,
  
  		"\n";
      }
      print $lspace, ". . .\n" if $end < @rl_History;
      print "$hdr\n";
  
      &force_redisplay();
  
      &F_ViInput() if $line eq '' && $Vi_mode;
  }
  
  # Redisplay the line, without attempting any optimization
  sub force_redisplay {
      local $force_redraw = 1;
      &redisplay(@_);
  }
  
  # Search history for matching string.  As with vi in nomagic mode, the
  #     ^, $, \<, and \> positional assertions, the \* quantifier, the \.
  #     character class, and the \[ character class delimiter all have special
  #     meaning here.
  sub F_ViSearch {
      my($n, $ord) = @_;
  
      my $c = pack('c', $ord);
  
      my $str = &get_vi_search_str($c);
      if (!defined $str) {
  	# Search aborted by deleting the '/' at the beginning of the line
  	return &F_ViInput() if $line eq '';
  	return();
      }
  
      # Null string repeats last search
      if ($str eq '') {
  	return &F_Ding unless defined $Vi_search_re;
      }
      else {
  	# Convert to a regular expression.  Interpret $str Like vi in nomagic
  	#     mode: '^', '$', '\<', and '\>' positional assertions, '\*' 
  	#     quantifier, '\.' and '\[]' character classes.
  
  	my @chars = ($str =~ m{(\\?.)}g);
  	my(@re, @tail);
  	unshift(@re,   shift(@chars)) if @chars and $chars[0]  eq '^';
  	push   (@tail, pop(@chars))   if @chars and $chars[-1] eq '$';
  	my $in_chclass;
  	my %chmap = (
  	    '\<' => '\b(?=\w)',
  	    '\>' => '(?<=\w)\b',
  	    '\*' => '*',
  	    '\[' => '[',
  	    '\.' => '.',
  	);
  	my $ch;
  	foreach $ch (@chars) {
  	    if ($in_chclass) {
  		# Any backslashes in vi char classes are literal
  		push(@re, "\\") if length($ch) > 1;
  		push(@re, $ch);
  		$in_chclass = 0 if $ch =~ /\]$/;
  	    }
  	    else {
  		push(@re, (length $ch == 2) ? ($chmap{$ch} || $ch) :
  			  ($ch =~ /^\w$/)   ? $ch                  :
  			                      ("\\", $ch));
  		$in_chclass = 1 if $ch eq '\[';
  	    }
  	}
  	my $re = join('', @re, @tail);
  	$Vi_search_re = q{$re};
      }
  
      local $reverse = $Vi_search_reverse = ($c eq '/') ? 1 : 0;
      &do_vi_search();
  }
  
  sub F_ViRepeatSearch {
      my($n, $ord) = @_;
      my $c = pack('c', $ord);
      return &F_Ding unless defined $Vi_search_re;
      local $reverse = $Vi_search_reverse;
      $reverse ^= 1 if $c eq 'N';
      &do_vi_search();
  }
  
  ## returns a new $i or -1 if not found.
  sub vi_search { 
      my ($i) = @_;
      return -1 if $i < 0 || $i > $#rl_History; 	 ## for safety
      while (1) {
  	return $i if $rl_History[$i] =~ /$Vi_search_re/;
  	if ($reverse) {
  	    return -1 if $i-- == 0;
  	} else {
  	    return -1 if $i++ == $#rl_History;
  	}
      }
  }
  
  sub do_vi_search {
      my $incr = $reverse ? -1 : 1;
  
      my $i = &vi_search($rl_HistoryIndex + $incr);
      return &F_Ding if $i < 0;                  # Not found.
  
      $rl_HistoryIndex = $i;
      ($D, $line) = (0, $rl_History[$rl_HistoryIndex]);
  }
  
  # Using local $line, $D, and $prompt, get and return the string to search for.
  sub get_vi_search_str {
      my($c) = @_;
  
      local $prompt = $prompt . $c;
      local ($line, $D) = ('', 0);
      &redisplay();
  
      # Gather a search string in our local $line.
      while ($lastcommand ne 'F_ViEndSearch') {
  	&do_command($var_EditingMode{'visearch'}, 1, ord(&getc_with_pending));
  	&redisplay();
  
  	# We've backspaced past beginning of line
  	return undef if !defined $line;
      }
      $line;
  }
  
  sub F_ViEndSearch {}
  
  sub F_ViSearchBackwardDeleteChar {
      if ($line eq '') {
  	# Backspaced past beginning of line - terminate search mode
  	undef $line;
      }
      else {
  	&F_BackwardDeleteChar(@_);
      }
  }
  
  ##
  ## Kill entire line and enter input mode
  ##
  sub F_ViChangeEntireLine
  {
      &start_dot_buf(@_);
      kill_text(0, length($line), 1);
      &vi_input_mode;
  }
  
  ##
  ## Kill characters and enter input mode
  ##
  sub F_ViChangeChar
  {
      &start_dot_buf(@_);
      &F_DeleteChar(@_);
      &vi_input_mode;
  }
  
  sub F_ViReplaceChar
  {
      &start_dot_buf(@_);
      my $c = &getc_with_pending;
      $c = &getc_with_pending if $c eq "\cV";   # ctrl-V
      return &F_ViCommandMode if $c eq "\e";
      &end_dot_buf;
  
      local $InsertMode = 0;
      local $D = $D;                  # Preserve cursor position
      &F_SelfInsert(1, ord($c));
  }
  
  ##
  ## Kill from cursor to end of line and enter input mode
  ##
  sub F_ViChangeLine
  {
      &start_dot_buf(@_);
      &F_KillLine(@_);
      &vi_input_mode;
  }
  
  sub F_ViDeleteLine
  {
      &save_dot_buf(@_);
      &F_KillLine(@_);
  }
  
  sub F_ViPut
  {
      my($count) = @_;
      &save_dot_buf(@_);
      my $text2add = $KillBuffer x $count;
      my $ll = length($line);
      $D++;
      $D = $ll if $D > $ll;
      substr($line, $D, 0) = $KillBuffer x $count;
      $D += length($text2add) - 1;
  }
  
  sub F_ViPutBefore
  {
      &save_dot_buf(@_);
      &TextInsert($_[0], $KillBuffer);
  }
  
  sub F_ViYank
  {
      my($count, $ord) = @_;
      my $pos = &get_position($count, undef, $ord, $Vi_yank_patterns);
      &F_Ding if !defined $pos;
      if ($pos < 0) {
  	# yy
  	&F_ViYankLine;
      }
      else {
  	my($from, $to) = ($pos > $D) ? ($D, $pos) : ($pos, $D);
  	$KillBuffer = substr($line, $from, $to-$from);
      }
  }
  
  sub F_ViYankLine
  {
      $KillBuffer = $line;
  }
  
  sub F_ViInput
  {
      @_ = (1, ord('i')) if !@_;
      &start_dot_buf(@_);
      &vi_input_mode;
  }
  
  sub F_ViBeginInput
  {
      &start_dot_buf(@_);
      &F_BeginningOfLine;
      &vi_input_mode;
  }
  
  sub F_ViReplaceMode
  {
      &start_dot_buf(@_);
      $InsertMode = 0;
      $var_EditingMode = $var_EditingMode{'vi'};
      $Vi_mode = 1;
  }
  
  sub vi_input_mode
  {
      $InsertMode = 1;
      $var_EditingMode = $var_EditingMode{'vi'};
      $Vi_mode = 1;
  }
  
  # The previous keystroke was an escape, but the sequence was not recognized
  #     as a mapped sequence (like an arrow key).  Enter vi comand mode and
  #     process this keystroke.
  sub F_ViAfterEsc {
      my($n, $ord) = @_;
      &F_ViCommandMode;
      &do_command($var_EditingMode, 1, $ord);
  }
  
  sub F_ViAppend
  {
      &start_dot_buf(@_);
      &vi_input_mode;
      &F_ForwardChar;
  }
  
  sub F_ViAppendLine
  {
      &start_dot_buf(@_);
      &vi_input_mode;
      &F_EndOfLine;
  }
  
  sub F_ViCommandMode
  {
      $var_EditingMode = $var_EditingMode{'vicmd'};
      $Vi_mode = 1;
  }
  
  sub F_ViAcceptInsert {
      local $in_accept_line = 1;
      &F_ViEndInsert;
      &F_ViAcceptLine;
  }
  
  sub F_ViEndInsert
  {
      if ($Dot_buf) {
  	if ($line eq '' and $Dot_buf->[0] eq 'i') {
  	    # We inserted nothing into an empty $line - assume it was a
  	    #     &F_ViInput() call with no arguments, and don't save command.
  	    undef $Dot_buf;
  	}
  	else {
  	    # Regardless of which keystroke actually terminated this insert
  	    #     command, replace it with an <esc> in the dot buffer.
  	    @{$Dot_buf}[-1] = "\e";
  	    &end_dot_buf;
  	}
      }
      &F_ViCommandMode;
      # Move cursor back to the last inserted character, but not when
      # we're about to accept a line of input
      &F_BackwardChar(1) unless $in_accept_line;
  }
  
  sub F_ViDigit {
      my($count, $ord) = @_;
  
      my $n = 0;
      my $ord0 = ord('0');
      while (1) {
  
  	$n *= 10;
  	$n += $ord - $ord0;
  
  	my $c = &getc_with_pending;
  	return unless defined $c;
  	$ord = ord($c);
  	last unless $c =~ /^\d$/;
      }
  
      $n *= $count;                   # So  2d3w  deletes six words
      $n = $rl_max_numeric_arg if $n > $rl_max_numeric_arg;
  
      &do_command($var_EditingMode, $n, $ord);
  }
  
  sub F_ViComplete {
      my($n, $ord) = @_;
  
      $Dot_state = savestate();     # Completion is undo-able
      undef $Dot_buf;              #       but not redo-able
  
      my $ch;
      while (1) {
  
  	&F_Complete() or return;
  
  	# Vi likes the cursor one character right of where emacs like it.
  	&F_ForwardChar(1);
  	&force_redisplay();
  
  	# Look ahead to the next input keystroke.
  	$ch = &getc_with_pending();
  	last unless ord($ch) == $ord;   # Not a '\' - quit.
  
  	# Another '\' was typed - put the cursor back where &F_Complete left
  	#     it, and try again.
  	&F_BackwardChar(1);
  	$lastcommand = 'F_Complete';   # Play along with &F_Complete's kludge
      }
      unshift(@Pending, $ch);      # Unget the lookahead keystroke
  
      # Successful completion - enter input mode with cursor beyond end of word.
      &vi_input_mode;
  }
  
  sub F_ViInsertPossibleCompletions {
      $Dot_state = savestate();     # Completion is undo-able
      undef $Dot_buf;              #       but not redo-able
  
      &complete_internal('*') or return;
  
      # Successful completion - enter input mode with cursor beyond end of word.
      &F_ForwardChar(1);
      &vi_input_mode;
  }
  
  sub F_ViPossibleCompletions {
  
      # List possible completions
      &complete_internal('?');
  
      # Enter input mode with cursor where we left off.
      &F_ForwardChar(1);
      &vi_input_mode;
  }
  
  sub F_SetMark {
      $rl_mark = $D;
      pos $line = $rl_mark;
      $line_rl_mark = $rl_HistoryIndex;
      $force_redraw = 1;
  }
  
  sub F_ExchangePointAndMark {
      return F_Ding unless $line_rl_mark == $rl_HistoryIndex;
      ($rl_mark, $D) = ($D, $rl_mark);
      pos $line = $rl_mark;
      $D = length $line if $D > length $line;
      $force_redraw = 1;
  }
  
  sub F_KillRegion {
      return F_Ding unless $line_rl_mark == $rl_HistoryIndex;
      $rl_mark = length $line if $rl_mark > length $line;
      kill_text($rl_mark, $D, 1);
      $line_rl_mark = -1;		# Disable mark
  }
  
  sub F_CopyRegionAsKill {
      return F_Ding unless $line_rl_mark == $rl_HistoryIndex;
      $rl_mark = length $line if $rl_mark > length $line;
      my ($s, $e) = ($rl_mark, $D);
      ($s, $e) = ($e, $s) if $s > $e;
      $ThisCommandKilledText = 1 + $s;
      $KillBuffer = '' if !$LastCommandKilledText;
      $KillBuffer .= substr($line, $s, $e - $s);
  }
  
  sub clipboard_set {
      my $in = shift;
      if ($^O eq 'os2') {
        eval {
  	require OS2::Process;
  	OS2::Process::ClipbrdText_set($in); # Do not disable \r\n-conversion
  	1
        } and return;
      } elsif ($^O eq 'MSWin32') {
        eval {
          require Win32::Clipboard;
          Win32::Clipboard::Set($in);
          1
        } and return;
      }
      my $mess;
      if ($ENV{RL_CLCOPY_CMD}) {
        $mess = "Writing to pipe `$ENV{RL_CLCOPY_CMD}'";
        open COPY, "| $ENV{RL_CLCOPY_CMD}" or warn("$mess: $!"), return;
      } elsif (defined $ENV{HOME}) {
        $mess = "Writing to file `$ENV{HOME}/.rl_cutandpaste'";
        open COPY, "> $ENV{HOME}/.rl_cutandpaste" or warn("$mess: $!"), return;
      } else {
        return;
      }
      print COPY $in;
      close COPY or warn("$mess: closing $!");
  }
  
  sub F_CopyRegionAsKillClipboard {
      return clipboard_set($line) unless $line_rl_mark == $rl_HistoryIndex;
      &F_CopyRegionAsKill;
      clipboard_set($KillBuffer);
  }
  
  sub F_KillRegionClipboard {
      &F_KillRegion;
      clipboard_set($KillBuffer);
  }
  
  sub F_YankClipboard
  {
      remove_selection();
      my $in;
      if ($^O eq 'os2') {
        eval {
  	require OS2::Process;
  	$in = OS2::Process::ClipbrdText();
  	$in =~ s/\r\n/\n/g;		# With old versions, or what?
        }
      } elsif ($^O eq 'MSWin32') {
        eval {
          require Win32::Clipboard;
          $in = Win32::Clipboard::GetText();
          $in =~ s/\r\n/\n/g;  # is this needed?
        }
      } else {
        my $mess;
        if ($ENV{RL_PASTE_CMD}) {
  	$mess = "Reading from pipe `$ENV{RL_PASTE_CMD}'";
  	open PASTE, "$ENV{RL_PASTE_CMD} |" or warn("$mess: $!"), return;
        } elsif (defined $ENV{HOME}) {
  	$mess = "Reading from file `$ENV{HOME}/.rl_cutandpaste'";
  	open PASTE, "< $ENV{HOME}/.rl_cutandpaste" or warn("$mess: $!"), return;
        }
        if ($mess) {
  	local $/;
  	$in = <PASTE>;
  	close PASTE or warn("$mess, closing: $!");
        }
      }
      if (defined $in) {
  	$in =~ s/\n+$//;
  	return &TextInsert($_[0], $in);
      }
      &TextInsert($_[0], $KillBuffer);
  }
  
  sub F_BeginUndoGroup {
      push @undoGroupS, $#undo;
  }
  
  sub F_EndUndoGroup {
      return F_Ding unless @undoGroupS;
      my $last = pop @undoGroupS;
      return unless $#undo > $last + 1;
      my $now = pop @undo;
      $#undo = $last;
      push @undo, $now;
  }
  
  sub F_DoNothing {		# E.g., reset digit-argument
      1;
  }
  
  sub F_ForceMemorizeDigitArgument {
      $memorizedArg = shift;
  }
  
  sub F_MemorizeDigitArgument {
      return if defined $memorizedArg;
      $memorizedArg = shift;
  }
  
  sub F_UnmemorizeDigitArgument {
      $memorizedArg = undef;
  }
  
  sub F_MemorizePos {
      $memorizedPos = $D;
  }
  
  # It is assumed that F_MemorizePos was called, then something was inserted,
  # then F_MergeInserts is called with a prefix argument to multiply
  # insertion by
  
  sub F_MergeInserts {
      my $n = shift;
      return F_Ding unless defined $memorizedPos and $n > 0;
      my ($b, $e) = ($memorizedPos, $D);
      ($b, $e) = ($e, $b) if $e < $b;
      if ($n) {
  	substr($line, $e, 0) = substr($line, $b, $e - $b) x ($n - 1);
      } else {
  	substr($line, $b, $e - $b) = '';
      }
      $D = $b + ($e - $b) * $n;
  }
  
  sub F_ResetDigitArgument {
      return F_Ding unless defined $memorizedArg;
      my $in = &getc_with_pending;
      return unless defined $in;
      my $ord = ord $in;
      local(*KeyMap) = $var_EditingMode;
      &do_command(*KeyMap, $memorizedArg, $ord);
  }
  
  sub F_BeginPasteGroup {
      my $c = shift;
      $memorizedArg = $c unless defined $memorizedArg;
      F_BeginUndoGroup(1);
      $memorizedPos = $D;
  }
  
  sub F_EndPasteGroup {
      my $c = $memorizedArg;
      undef $memorizedArg;
      $c = 1 unless defined $c;
      F_MergeInserts($c);
      F_EndUndoGroup(1);
  }
  
  sub F_BeginEditGroup {
      $memorizedArg = shift;
      F_BeginUndoGroup(1);
  }
  
  sub F_EndEditGroup {
      undef $memorizedArg;
      F_EndUndoGroup(1);
  }
  
  1;
  __END__
TERM_READLINE_READLINE

$fatpacked{"Term/UI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_UI';
  package Term::UI;
  
  use if $] > 5.017, 'deprecate';
  
  use Carp;
  use Params::Check qw[check allow];
  use Term::ReadLine;
  use Locale::Maketext::Simple Style => 'gettext';
  use Term::UI::History;
  
  use strict;
  
  BEGIN {
      use vars        qw[$VERSION $AUTOREPLY $VERBOSE $INVALID];
      $VERBOSE    =   1;
      $VERSION    =   '0.38';
      $INVALID    =   loc('Invalid selection, please try again: ');
  }
  
  push @Term::ReadLine::Stub::ISA, __PACKAGE__
          unless grep { $_ eq __PACKAGE__ } @Term::ReadLine::Stub::ISA;
  
  
  =pod
  
  =head1 NAME
  
  Term::UI - Term::ReadLine UI made easy
  
  =head1 SYNOPSIS
  
      use Term::UI;
      use Term::ReadLine;
  
      my $term = Term::ReadLine->new('brand');
  
      my $reply = $term->get_reply(
                      prompt => 'What is your favourite colour?',
                      choices => [qw|blue red green|],
                      default => 'blue',
      );
  
      my $bool = $term->ask_yn(
                          prompt => 'Do you like cookies?',
                          default => 'y',
                  );
  
  
      my $string = q[some_command -option --no-foo --quux='this thing'];
  
      my ($options,$munged_input) = $term->parse_options($string);
  
  
      ### don't have Term::UI issue warnings -- default is '1'
      $Term::UI::VERBOSE = 0;
  
      ### always pick the default (good for non-interactive terms)
      ### -- default is '0'
      $Term::UI::AUTOREPLY = 1;
  
      ### Retrieve the entire session as a printable string:
      $hist = Term::UI::History->history_as_string;
      $hist = $term->history_as_string;
  
  =head1 DESCRIPTION
  
  C<Term::UI> is a transparent way of eliminating the overhead of having
  to format a question and then validate the reply, informing the user
  if the answer was not proper and re-issuing the question.
  
  Simply give it the question you want to ask, optionally with choices
  the user can pick from and a default and C<Term::UI> will DWYM.
  
  For asking a yes or no question, there's even a shortcut.
  
  =head1 HOW IT WORKS
  
  C<Term::UI> places itself at the back of the C<Term::ReadLine>
  C<@ISA> array, so you can call its functions through your term object.
  
  C<Term::UI> uses C<Term::UI::History> to record all interactions
  with the commandline. You can retrieve this history, or alter
  the filehandle the interaction is printed to. See the
  C<Term::UI::History> manpage or the C<SYNOPSIS> for details.
  
  =head1 METHODS
  
  =head2 $reply = $term->get_reply( prompt => 'question?', [choices => \@list, default => $list[0], multi => BOOL, print_me => "extra text to print & record", allow => $ref] );
  
  C<get_reply> asks a user a question, and then returns the reply to the
  caller. If the answer is invalid (more on that below), the question will
  be reposed, until a satisfactory answer has been entered.
  
  You have the option of providing a list of choices the user can pick from
  using the C<choices> argument. If the answer is not in the list of choices
  presented, the question will be reposed.
  
  If you provide a C<default>  answer, this will be returned when either
  C<$AUTOREPLY> is set to true, (see the C<GLOBAL VARIABLES> section further
  below), or when the user just hits C<enter>.
  
  You can indicate that the user is allowed to enter multiple answers by
  toggling the C<multi> flag. Note that a list of answers will then be
  returned to you, rather than a simple string.
  
  By specifying an C<allow> handler, you can yourself validate the answer
  a user gives. This can be any of the types that the Params::Check C<allow>
  function allows, so please refer to that manpage for details.
  
  Finally, you have the option of adding a C<print_me> argument, which is
  simply printed before the prompt. It's printed to the same file handle
  as the rest of the questions, so you can use this to keep track of a
  full session of Q&A with the user, and retrieve it later using the
  C<< Term::UI->history_as_string >> function.
  
  See the C<EXAMPLES> section for samples of how to use this function.
  
  =cut
  
  sub get_reply {
      my $term = shift;
      my %hash = @_;
  
      my $tmpl = {
          default     => { default => undef,  strict_type => 1 },
          prompt      => { default => '',     strict_type => 1, required => 1 },
          choices     => { default => [],     strict_type => 1 },
          multi       => { default => 0,      allow => [0, 1] },
          allow       => { default => qr/.*/ },
          print_me    => { default => '',     strict_type => 1 },
      };
  
      my $args = check( $tmpl, \%hash, $VERBOSE )
                  or ( carp( loc(q[Could not parse arguments]) ), return );
  
  
      ### add this to the prompt to indicate the default
      ### answer to the question if there is one.
      my $prompt_add;
  
      ### if you supplied several choices to pick from,
      ### we'll print them separately before the prompt
      if( @{$args->{choices}} ) {
          my $i;
  
          for my $choice ( @{$args->{choices}} ) {
              $i++;   # the answer counter -- but humans start counting
                      # at 1 :D
  
              ### so this choice is the default? add it to 'prompt_add'
              ### so we can construct a "foo? [DIGIT]" type prompt
              $prompt_add = $i if (defined $args->{default} and $choice eq $args->{default});
  
              ### create a "DIGIT> choice" type line
              $args->{print_me} .= sprintf "\n%3s> %-s", $i, $choice;
          }
  
          ### we listed some choices -- add another newline for
          ### pretty printing
          $args->{print_me} .= "\n" if $i;
  
          ### allowable answers are now equal to the choices listed
          $args->{allow} = $args->{choices};
  
      ### no choices, but a default? set 'prompt_add' to the default
      ### to construct a 'foo? [DEFAULT]' type prompt
      } elsif ( defined $args->{default} ) {
          $prompt_add = $args->{default};
      }
  
      ### we set up the defaults, prompts etc, dispatch to the readline call
      return $term->_tt_readline( %$args, prompt_add => $prompt_add );
  
  }
  
  =head2 $bool = $term->ask_yn( prompt => "your question", [default => (y|1,n|0), print_me => "extra text to print & record"] )
  
  Asks a simple C<yes> or C<no> question to the user, returning a boolean
  indicating C<true> or C<false> to the caller.
  
  The C<default> answer will automatically returned, if the user hits
  C<enter> or if C<$AUTOREPLY> is set to true. See the C<GLOBAL VARIABLES>
  section further below.
  
  Also, you have the option of adding a C<print_me> argument, which is
  simply printed before the prompt. It's printed to the same file handle
  as the rest of the questions, so you can use this to keep track of a
  full session of Q&A with the user, and retrieve it later using the
  C<< Term::UI->history_as_string >> function.
  
  
  See the C<EXAMPLES> section for samples of how to use this function.
  
  =cut
  
  sub ask_yn {
      my $term = shift;
      my %hash = @_;
  
      my $tmpl = {
          default     => { default => undef, allow => [qw|0 1 y n|],
                                                              strict_type => 1 },
          prompt      => { default => '', required => 1,      strict_type => 1 },
          print_me    => { default => '',                     strict_type => 1 },
          multi       => { default => 0,                      no_override => 1 },
          choices     => { default => [qw|y n|],              no_override => 1 },
          allow       => { default => [qr/^y(?:es)?$/i, qr/^n(?:o)?$/i],
                           no_override => 1
                         },
      };
  
      my $args = check( $tmpl, \%hash, $VERBOSE ) or return undef;
  
      ### uppercase the default choice, if there is one, to be added
      ### to the prompt in a 'foo? [Y/n]' type style.
      my $prompt_add;
      {   my @list = @{$args->{choices}};
          if( defined $args->{default} ) {
  
              ### if you supplied the default as a boolean, rather than y/n
              ### transform it to a y/n now
              $args->{default} = $args->{default} =~ /\d/
                                  ? { 0 => 'n', 1 => 'y' }->{ $args->{default} }
                                  : $args->{default};
  
              @list = map { lc $args->{default} eq lc $_
                                  ? uc $args->{default}
                                  : $_
                      } @list;
          }
  
          $prompt_add .= join("/", @list);
      }
  
      my $rv = $term->_tt_readline( %$args, prompt_add => $prompt_add );
  
      return $rv =~ /^y/i ? 1 : 0;
  }
  
  
  
  sub _tt_readline {
      my $term = shift;
      my %hash = @_;
  
      local $Params::Check::VERBOSE = 0;  # why is this?
      local $| = 1;                       # print ASAP
  
  
      my ($default, $prompt, $choices, $multi, $allow, $prompt_add, $print_me);
      my $tmpl = {
          default     => { default => undef,  strict_type => 1,
                              store => \$default },
          prompt      => { default => '',     strict_type => 1, required => 1,
                              store => \$prompt },
          choices     => { default => [],     strict_type => 1,
                              store => \$choices },
          multi       => { default => 0,      allow => [0, 1], store => \$multi },
          allow       => { default => qr/.*/, store => \$allow, },
          prompt_add  => { default => '',     store => \$prompt_add },
          print_me    => { default => '',     store => \$print_me },
      };
  
      check( $tmpl, \%hash, $VERBOSE ) or return;
  
      ### prompts for Term::ReadLine can't be longer than one line, or
      ### it can display wonky on some terminals.
      history( $print_me ) if $print_me;
  
  
      if ($prompt_add) {
          ### we might have to add a default value to the prompt, to
          ### show the user what will be picked by default:
          $prompt .= " [$prompt_add]: " ;
      }
      else {
          $prompt .= " : ";
      }
  
  
      ### are we in autoreply mode?
      if ($AUTOREPLY) {
  
          ### you used autoreply, but didn't provide a default!
          carp loc(
              q[You have '%1' set to true, but did not provide a default!],
              '$AUTOREPLY'
          ) if( !defined $default && $VERBOSE);
  
          ### print it out for visual feedback
          history( join ' ', grep { defined } $prompt, $default );
  
          ### and return the default
          return $default;
      }
  
  
      ### so, no AUTOREPLY, let's see what the user will answer
      LOOP: {
  
          ### annoying bug in T::R::Perl that mucks up lines with a \n
          ### in them; So split by \n, save the last line as the prompt
          ### and just print the rest
          {   my @lines   = split "\n", $prompt;
              $prompt     = pop @lines;
  
              history( "$_\n" ) for @lines;
          }
  
          ### pose the question
          my $answer  = $term->readline($prompt);
          $answer     = $default unless length $answer;
  
          $term->addhistory( $answer ) if length $answer;
  
          ### add both prompt and answer to the history
          history( "$prompt $answer", 0 );
  
          ### if we're allowed to give multiple answers, split
          ### the answer on whitespace
          my @answers = $multi ? split(/\s+/, $answer) : $answer;
  
          ### the return value list
          my @rv;
  
          if( @$choices ) {
  
              for my $answer (@answers) {
  
                  ### a digit implies a multiple choice question,
                  ### a non-digit is an open answer
                  if( $answer =~ /\D/ ) {
                      push @rv, $answer if allow( $answer, $allow );
                  } else {
  
                      ### remember, the answer digits are +1 compared to
                      ### the choices, because humans want to start counting
                      ### at 1, not at 0
                      push @rv, $choices->[ $answer - 1 ]
                          if $answer > 0 && defined $choices->[ $answer - 1];
                  }
              }
  
          ### no fixed list of choices.. just check if the answers
          ### (or otherwise the default!) pass the allow handler
          } else {
              push @rv, grep { allow( $_, $allow ) }
                          scalar @answers ? @answers : ($default);
          }
  
          ### if not all the answers made it to the return value list,
          ### at least one of them was an invalid answer -- make the
          ### user do it again
          if( (@rv != @answers) or
              (scalar(@$choices) and not scalar(@answers))
          ) {
              $prompt = $INVALID;
              $prompt .= "[$prompt_add] " if $prompt_add;
              redo LOOP;
  
          ### otherwise just return the answer, or answers, depending
          ### on the multi setting
          } else {
              return $multi ? @rv : $rv[0];
          }
      }
  }
  
  =head2 ($opts, $munged) = $term->parse_options( STRING );
  
  C<parse_options> will convert all options given from an input string
  to a hash reference. If called in list context it will also return
  the part of the input string that it found no options in.
  
  Consider this example:
  
      my $str =   q[command --no-foo --baz --bar=0 --quux=bleh ] .
                  q[--option="some'thing" -one-dash -single=blah' arg];
  
      my ($options,$munged) =  $term->parse_options($str);
  
      ### $options would contain: ###
      $options = {
                  'foo'       => 0,
                  'bar'       => 0,
                  'one-dash'  => 1,
                  'baz'       => 1,
                  'quux'      => 'bleh',
                  'single'    => 'blah\'',
                  'option'    => 'some\'thing'
      };
  
      ### and this is the munged version of the input string,
      ### ie what's left of the input minus the options
      $munged = 'command arg';
  
  As you can see, you can either use a single or a double C<-> to
  indicate an option.
  If you prefix an option with C<no-> and do not give it a value, it
  will be set to 0.
  If it has no prefix and no value, it will be set to 1.
  Otherwise, it will be set to its value. Note also that it can deal
  fine with single/double quoting issues.
  
  =cut
  
  sub parse_options {
      my $term    = shift;
      my $input   = shift;
  
      my $return = {};
  
      ### there's probably a more elegant way to do this... ###
      while ( $input =~ s/(?:^|\s+)--?([-\w]+=("|').+?\2)(?=\Z|\s+)//  or
              $input =~ s/(?:^|\s+)--?([-\w]+=\S+)(?=\Z|\s+)//         or
              $input =~ s/(?:^|\s+)--?([-\w]+)(?=\Z|\s+)//
      ) {
          my $match = $1;
  
          if( $match =~ /^([-\w]+)=("|')(.+?)\2$/ ) {
              $return->{$1} = $3;
  
          } elsif( $match =~ /^([-\w]+)=(\S+)$/ ) {
              $return->{$1} = $2;
  
          } elsif( $match =~ /^no-?([-\w]+)$/i ) {
              $return->{$1} = 0;
  
          } elsif ( $match =~ /^([-\w]+)$/ ) {
              $return->{$1} = 1;
  
          } else {
              carp(loc(q[I do not understand option "%1"\n], $match)) if $VERBOSE;
          }
      }
  
      return wantarray ? ($return,$input) : $return;
  }
  
  =head2 $str = $term->history_as_string
  
  Convenience wrapper around C<< Term::UI::History->history_as_string >>.
  
  Consult the C<Term::UI::History> man page for details.
  
  =cut
  
  sub history_as_string { return Term::UI::History->history_as_string };
  
  1;
  
  =head1 GLOBAL VARIABLES
  
  The behaviour of Term::UI can be altered by changing the following
  global variables:
  
  =head2 $Term::UI::VERBOSE
  
  This controls whether Term::UI will issue warnings and explanations
  as to why certain things may have failed. If you set it to 0,
  Term::UI will not output any warnings.
  The default is 1;
  
  =head2 $Term::UI::AUTOREPLY
  
  This will make every question be answered by the default, and warn if
  there was no default provided. This is particularly useful if your
  program is run in non-interactive mode.
  The default is 0;
  
  =head2 $Term::UI::INVALID
  
  This holds the string that will be printed when the user makes an
  invalid choice.
  You can override this string from your program if you, for example,
  wish to do localization.
  The default is C<Invalid selection, please try again: >
  
  =head2 $Term::UI::History::HISTORY_FH
  
  This is the filehandle all the print statements from this module
  are being sent to. Please consult the C<Term::UI::History> manpage
  for details.
  
  This defaults to C<*STDOUT>.
  
  =head1 EXAMPLES
  
  =head2 Basic get_reply sample
  
      ### ask a user (with an open question) for their favourite colour
      $reply = $term->get_reply( prompt => 'Your favourite colour? );
  
  which would look like:
  
      Your favourite colour?
  
  and C<$reply> would hold the text the user typed.
  
  =head2 get_reply with choices
  
      ### now provide a list of choices, so the user has to pick one
      $reply = $term->get_reply(
                  prompt  => 'Your favourite colour?',
                  choices => [qw|red green blue|] );
  
  which would look like:
  
        1> red
        2> green
        3> blue
  
      Your favourite colour?
  
  C<$reply> will hold one of the choices presented. C<Term::UI> will repose
  the question if the user attempts to enter an answer that's not in the
  list of choices. The string presented is held in the C<$Term::UI::INVALID>
  variable (see the C<GLOBAL VARIABLES> section for details.
  
  =head2 get_reply with choices and default
  
      ### provide a sensible default option -- everyone loves blue!
      $reply = $term->get_reply(
                  prompt  => 'Your favourite colour?',
                  choices => [qw|red green blue|],
                  default => 'blue' );
  
  which would look like:
  
        1> red
        2> green
        3> blue
  
      Your favourite colour? [3]:
  
  Note the default answer after the prompt. A user can now just hit C<enter>
  (or set C<$Term::UI::AUTOREPLY> -- see the C<GLOBAL VARIABLES> section) and
  the sensible answer 'blue' will be returned.
  
  =head2 get_reply using print_me & multi
  
      ### allow the user to pick more than one colour and add an
      ### introduction text
      @reply = $term->get_reply(
                  print_me    => 'Tell us what colours you like',
                  prompt      => 'Your favourite colours?',
                  choices     => [qw|red green blue|],
                  multi       => 1 );
  
  which would look like:
  
      Tell us what colours you like
        1> red
        2> green
        3> blue
  
      Your favourite colours?
  
  An answer of C<3 2 1> would fill C<@reply> with C<blue green red>
  
  =head2 get_reply & allow
  
      ### pose an open question, but do a custom verification on
      ### the answer, which will only exit the question loop, if
      ### the answer matches the allow handler.
      $reply = $term->get_reply(
                  prompt  => "What is the magic number?",
                  allow   => 42 );
  
  Unless the user now enters C<42>, the question will be reposed over
  and over again. You can use more sophisticated C<allow> handlers (even
  subroutines can be used). The C<allow> handler is implemented using
  C<Params::Check>'s C<allow> function. Check its manpage for details.
  
  =head2 an elaborate ask_yn sample
  
      ### ask a user if he likes cookies. Default to a sensible 'yes'
      ### and inform him first what cookies are.
      $bool = $term->ask_yn( prompt   => 'Do you like cookies?',
                             default  => 'y',
                             print_me => 'Cookies are LOVELY!!!' );
  
  would print:
  
      Cookies are LOVELY!!!
      Do you like cookies? [Y/n]:
  
  If a user then simply hits C<enter>, agreeing with the default,
  C<$bool> would be set to C<true>. (Simply hitting 'y' would also
  return C<true>. Hitting 'n' would return C<false>)
  
  We could later retrieve this interaction by printing out the Q&A
  history as follows:
  
      print $term->history_as_string;
  
  which would then print:
  
      Cookies are LOVELY!!!
      Do you like cookies? [Y/n]:  y
  
  There's a chance we're doing this non-interactively, because a console
  is missing, the user indicated he just wanted the defaults, etc.
  
  In this case, simply setting C<$Term::UI::AUTOREPLY> to true, will
  return from every question with the default answer set for the question.
  Do note that if C<AUTOREPLY> is true, and no default is set, C<Term::UI>
  will warn about this and return C<undef>.
  
  =head1 See Also
  
  C<Params::Check>, C<Term::ReadLine>, C<Term::UI::History>
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-term-ui@rt.cpan.org<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  =cut
TERM_UI

$fatpacked{"Term/UI/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_UI_HISTORY';
  package Term::UI::History;
  
  use strict;
  use vars qw[$VERSION];
  use base 'Exporter';
  use base 'Log::Message::Simple';
  
  $VERSION = '0.38';
  
  =pod
  
  =head1 NAME
  
  Term::UI::History - history function
  
  =head1 SYNOPSIS
  
      use Term::UI::History qw[history];
  
      history("Some message");
  
      ### retrieve the history in printable form
      $hist  = Term::UI::History->history_as_string;
  
      ### redirect output
      local $Term::UI::History::HISTORY_FH = \*STDERR;
  
  =head1 DESCRIPTION
  
  This module provides the C<history> function for C<Term::UI>,
  printing and saving all the C<UI> interaction.
  
  Refer to the C<Term::UI> manpage for details on usage from
  C<Term::UI>.
  
  This module subclasses C<Log::Message::Simple>. Refer to its
  manpage for additional functionality available via this package.
  
  =head1 FUNCTIONS
  
  =head2 history("message string" [,VERBOSE])
  
  Records a message on the stack, and prints it to C<STDOUT>
  (or actually C<$HISTORY_FH>, see the C<GLOBAL VARIABLES> section
  below), if the C<VERBOSE> option is true.
  
  The C<VERBOSE> option defaults to true.
  
  =cut
  
  BEGIN {
      use Log::Message private => 0;
  
      use vars      qw[ @EXPORT $HISTORY_FH ];
      @EXPORT     = qw[ history ];
      my $log     = new Log::Message;
      $HISTORY_FH = \*STDOUT;
  
      for my $func ( @EXPORT ) {
          no strict 'refs';
  
          *$func = sub {  my $msg     = shift;
                          $log->store(
                                  message => $msg,
                                  tag     => uc $func,
                                  level   => $func,
                                  extra   => [@_]
                          );
                  };
      }
  
      sub history_as_string {
          my $class = shift;
  
          return join $/, map { $_->message } __PACKAGE__->stack;
      }
  }
  
  
  {
      package # hide this from PAUSE
        Log::Message::Handlers;
  
      sub history {
          my $self    = shift;
          my $verbose = shift;
             $verbose = 1 unless defined $verbose;    # default to true
  
          ### so you don't want us to print the msg? ###
          return if defined $verbose && $verbose == 0;
  
          local $| = 1;
          my $old_fh = select $Term::UI::History::HISTORY_FH;
  
          print $self->message . "\n";
          select $old_fh;
  
          return;
      }
  }
  
  
  =head1 GLOBAL VARIABLES
  
  =over 4
  
  =item $HISTORY_FH
  
  This is the filehandle all the messages sent to C<history()> are being
  printed. This defaults to C<*STDOUT>.
  
  =back
  
  =head1 See Also
  
  C<Log::Message::Simple>, C<Term::UI>
  
  =head1 AUTHOR
  
  This module by
  Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This module is
  copyright (c) 2005 Jos Boumans E<lt>kane@cpan.orgE<gt>.
  All rights reserved.
  
  This library is free software;
  you may redistribute and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
  1;
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
TERM_UI_HISTORY

$fatpacked{"Test/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TYPETINY';
  package Test::TypeTiny;
  
  use strict;
  use warnings;
  
  use Test::More qw();
  use Scalar::Util qw(blessed);
  use Types::TypeTiny qw(to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN {
  	*EXTENDED_TESTING = $ENV{EXTENDED_TESTING} ? sub(){!!1} : sub(){!!0};
  };
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';
  our @EXPORT    = qw( should_pass should_fail ok_subtype );
  our @EXPORT_OK = qw( EXTENDED_TESTING matchfor );
  
  sub matchfor
  {
  	my @matchers = @_;
  	bless \@matchers, do {
  		package #
  		Test::TypeTiny::Internal::MATCHFOR;
  		use overload
  			q[==] => 'match',
  			q[eq] => 'match',
  			q[""] => 'to_string',
  			fallback => 1;
  		sub to_string {
  			$_[0][0]
  		}
  		sub match {
  			my ($self, $e) = @_;
  			my $does = Scalar::Util::blessed($e) ? ($e->can('DOES') || $e->can('isa')) : undef;
  			for my $s (@$self) {
  				return 1 if  ref($s) && $e =~ $s;
  				return 1 if !ref($s) && $does && $e->$does($s);
  			}
  			return;
  		}
  		__PACKAGE__;
  	};
  }
  
  sub _mk_message
  {
  	require Type::Tiny;
  	my ($template, $value) = @_;
  	sprintf($template, Type::Tiny::_dd($value));
  }
  
  sub ok_subtype
  {
  	my ($type, @s) = @_;
  	@_ = (
  		not(scalar grep !$_->is_subtype_of($type), @s),
  		sprintf("%s subtype: %s", $type, join q[, ], @s),
  	);
  	goto \&Test::More::ok;
  }
  
  eval(EXTENDED_TESTING ? <<'SLOW' : <<'FAST');
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!!$type->check($value), '->check');
  	$test->ok(!!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!$type->check($value), '->check');
  	$test->ok(!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  SLOW
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!!$type->check($value),
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!$type->check($value),
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  FAST
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Test::TypeTiny - useful functions for testing the efficacy of type constraints
  
  =head1 SYNOPSIS
  
  =for test_synopsis
  BEGIN { die "SKIP: uses a module that doesn't exist as an example" };
  
     use strict;
     use warnings;
     use Test::More;
     use Test::TypeTiny;
     
     use Types::Mine qw(Integer Number);
     
     should_pass(1, Integer);
     should_pass(-1, Integer);
     should_pass(0, Integer);
     should_fail(2.5, Integer);
     
     ok_subtype(Number, Integer);
     
     done_testing;
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Test::TypeTiny> provides a few handy functions for testing type constraints.
  
  =head2 Functions
  
  =over
  
  =item C<< should_pass($value, $type, $test_name) >>
  
  =item C<< should_pass($value, $type) >>
  
  Test that passes iff C<< $value >> passes C<< $type->check >>.
  
  =item C<< should_fail($value, $type, $test_name) >>
  
  =item C<< should_fail($value, $type) >>
  
  Test that passes iff C<< $value >> fails C<< $type->check >>.
  
  =item C<< ok_subtype($type, @subtypes) >>
  
  Test that passes iff all C<< @subtypes >> are subtypes of C<< $type >>.
  
  =item C<< EXTENDED_TESTING >>
  
  Exportable boolean constant.
  
  =item C<< matchfor(@things) >>
  
  Assistant for matching exceptions. Not exported by default.
  See also L<Test::Fatal::matchfor>.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the C<EXTENDED_TESTING> environment variable is set to true, this
  module will promote each C<should_pass> or C<should_fail> test into a
  subtest block and test the type constraint in both an inlined and
  non-inlined manner.
  
  This variable must be set at compile time (i.e. before this module is
  loaded).
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  For an alternative to C<should_pass>, see L<Test::Deep::Type> which will
  happily accept a Type::Tiny type constraint instead of a MooseX::Types one.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TEST_TYPETINY

$fatpacked{"Test/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_YAML';
  package Test::YAML;
  
  use Test::Base 0.47 -Base;
  use lib 'lib';
  
  our $VERSION = '0.84';
  
  our $YAML    = 'YAML';
  our @EXPORT  = qw(
      no_diff
      run_yaml_tests
      run_roundtrip_nyn roundtrip_nyn
      run_load_passes load_passes
      dumper Load Dump LoadFile DumpFile
      XXX
  );
  
  delimiters('===', '+++');
  
  sub Dump     () { YAML(Dump => @_)     }
  sub Load     () { YAML(Load => @_)     }
  sub DumpFile () { YAML(DumpFile => @_) }
  sub LoadFile () { YAML(LoadFile => @_) }
  
  sub YAML () {
      load_yaml_pm();
      my $meth = shift;
      my $code = $YAML->can($meth) or die "$YAML cannot do $meth";
      goto &$code;
  }
  
  sub load_yaml_pm {
      my $file = "$YAML.pm";
      $file =~ s{::}{/}g;
      require $file;
  }
  
  sub run_yaml_tests() {
      run {
          my $block = shift;
          &{_get_function($block)}($block) unless 
            _skip_tests_for_now($block) or
            _skip_yaml_tests($block);
      };
  }
  
  sub run_roundtrip_nyn() {
      my @options = @_;
      run {
          my $block = shift;
          roundtrip_nyn($block, @options);
      };
  }
  
  sub roundtrip_nyn() {
      my $block = shift;
      my $option = shift || '';
      die "'perl' data section required"
          unless exists $block->{perl};
      my @values = eval $block->perl;
      die "roundtrip_nyn eval perl error: $@" if $@;
      my $config = $block->config || '';
      my $result = eval "$config; Dump(\@values)";
      die "roundtrip_nyn YAML::Dump error: $@" if $@;
      if (exists $block->{yaml}) {
          is $result, $block->yaml,
              $block->description . ' (n->y)';
      }
      else {
          pass $block->description . ' (n->y)';
      }
          
      return if exists $block->{no_round_trip} or
          not exists $block->{yaml};
  
      if ($option eq 'dumper') {
          is dumper(Load($block->yaml)), dumper(@values),
              $block->description . ' (y->n)';
      }
      else {
          is_deeply [Load($block->yaml)], [@values],
              $block->description . ' (y->n)';
      }
  }
  
  sub count_roundtrip_nyn() {
      my $block = shift or die "Bad call to count_roundtrip_nyn";
      return 1 if exists $block->{skip_this_for_now};
      my $count = 0;
      $count++ if exists $block->{perl};
      $count++ unless exists $block->{no_round_trip} or
          not exists $block->{yaml};
      die "Invalid test definition" unless $count;
      return $count;
  }
  
  sub run_load_passes() {
      run {
          my $block = shift;
          my $yaml = $block->yaml;
          eval { YAML(Load => $yaml) };
          is("$@", "");
      };
  }
  
  sub load_passes() {
      my $block = shift;
      my $yaml = $block->yaml;
      eval { YAML(Load => $yaml) };
      is "$@", "", $block->description;
  }
  
  sub count_load_passes() {1}
  
  sub dumper() {
      require Data::Dumper;
      $Data::Dumper::Sortkeys = 1;
      $Data::Dumper::Terse = 1;
      $Data::Dumper::Indent = 1;
      return Data::Dumper::Dumper(@_);
  }
  
  sub _count_tests() {
      my $block = shift or die "Bad call to _count_tests";
      no strict 'refs';
      &{'count_' . _get_function_name($block)}($block);
  }
  
  sub _get_function_name() {
      my $block = shift;
      return $block->function || 'roundtrip_nyn';
  }
  
  sub _get_function() {
      my $block = shift;
      no strict 'refs';
      \ &{_get_function_name($block)};
  }
  
  sub _skip_tests_for_now() {
      my $block = shift;
      if (exists $block->{skip_this_for_now}) {
          _skip_test(
              $block->description,
              _count_tests($block),
          );
          return 1;
      }
      return 0;
  }
  
  sub _skip_yaml_tests() {
      my $block = shift;
      if ($block->skip_unless_modules) {
          my @modules = split /[\s\,]+/, $block->skip_unless_modules;
          for my $module (@modules) {
              eval "require $module";
              if ($@) {
                  _skip_test(
                      "This test requires the '$module' module",
                      _count_tests($block),
                  );
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub _skip_test() {
      my ($message, $count) = @_;
      SKIP: {
          skip($message, $count);
      }
  }
  
  #-------------------------------------------------------------------------------
  package Test::YAML::Filter;
  
  use Test::Base::Filter ();
  
  our @ISA = 'Test::Base::Filter';
  
  sub yaml_dump {
      Test::YAML::Dump(@_);
  }
  
  sub yaml_load {
      Test::YAML::Load(@_);
  }
  
  sub Dump { goto &Test::YAML::Dump }
  sub Load { goto &Test::YAML::Load }
  sub DumpFile { goto &Test::YAML::DumpFile }
  sub LoadFile { goto &Test::YAML::LoadFile }
  
  sub yaml_load_or_fail {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $result;
  }
  
  sub yaml_load_error_or_warning {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub perl_eval_error_or_warning {
      my ($result, $error, $warning) =
        $self->_perl_eval_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub _yaml_load_result_error_warning {
      $self->assert_scalar(@_);
      my $yaml = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval {
          $self->yaml_load($yaml);
      };
      return ($result, $@, $warning);
  }
  
  sub _perl_eval_result_error_warning {
      $self->assert_scalar(@_);
      my $perl = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval $perl;
      return ($result, $@, $warning);
  }
  
  1;
  
  =head1 NAME
  
  Test::YAML - Testing Module for YAML Implementations
  
  =head1 SYNOPSIS
  
      use Test::YAML tests => 1;
  
      pass;
  
  =head1 DESCRIPTION
  
  Test::YAML is a subclass of Test::Base with YAML specific support.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST_YAML

$fatpacked{"Text/Glob.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_GLOB';
  package Text::Glob;
  use strict;
  use Exporter;
  use vars qw/$VERSION @ISA @EXPORT_OK
              $strict_leading_dot $strict_wildcard_slash/;
  $VERSION = '0.09';
  @ISA = 'Exporter';
  @EXPORT_OK = qw( glob_to_regex glob_to_regex_string match_glob );
  
  $strict_leading_dot    = 1;
  $strict_wildcard_slash = 1;
  
  use constant debug => 0;
  
  sub glob_to_regex {
      my $glob = shift;
      my $regex = glob_to_regex_string($glob);
      return qr/^$regex$/;
  }
  
  sub glob_to_regex_string
  {
      my $glob = shift;
      my ($regex, $in_curlies, $escaping);
      local $_;
      my $first_byte = 1;
      for ($glob =~ m/(.)/gs) {
          if ($first_byte) {
              if ($strict_leading_dot) {
                  $regex .= '(?=[^\.])' unless $_ eq '.';
              }
              $first_byte = 0;
          }
          if ($_ eq '/') {
              $first_byte = 1;
          }
          if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
              $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
              $regex .= "\\$_";
          }
          elsif ($_ eq '*') {
              $regex .= $escaping ? "\\*" :
                $strict_wildcard_slash ? "[^/]*" : ".*";
          }
          elsif ($_ eq '?') {
              $regex .= $escaping ? "\\?" :
                $strict_wildcard_slash ? "[^/]" : ".";
          }
          elsif ($_ eq '{') {
              $regex .= $escaping ? "\\{" : "(";
              ++$in_curlies unless $escaping;
          }
          elsif ($_ eq '}' && $in_curlies) {
              $regex .= $escaping ? "}" : ")";
              --$in_curlies unless $escaping;
          }
          elsif ($_ eq ',' && $in_curlies) {
              $regex .= $escaping ? "," : "|";
          }
          elsif ($_ eq "\\") {
              if ($escaping) {
                  $regex .= "\\\\";
                  $escaping = 0;
              }
              else {
                  $escaping = 1;
              }
              next;
          }
          else {
              $regex .= $_;
              $escaping = 0;
          }
          $escaping = 0;
      }
      print "# $glob $regex\n" if debug;
  
      return $regex;
  }
  
  sub match_glob {
      print "# ", join(', ', map { "'$_'" } @_), "\n" if debug;
      my $glob = shift;
      my $regex = glob_to_regex $glob;
      local $_;
      grep { $_ =~ $regex } @_;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::Glob - match globbing patterns against text
  
  =head1 SYNOPSIS
  
   use Text::Glob qw( match_glob glob_to_regex );
  
   print "matched\n" if match_glob( "foo.*", "foo.bar" );
  
   # prints foo.bar and foo.baz
   my $regex = glob_to_regex( "foo.*" );
   for ( qw( foo.bar foo.baz foo bar ) ) {
       print "matched: $_\n" if /$regex/;
   }
  
  =head1 DESCRIPTION
  
  Text::Glob implements glob(3) style matching that can be used to match
  against text, rather than fetching names from a filesystem.  If you
  want to do full file globbing use the File::Glob module instead.
  
  =head2 Routines
  
  =over
  
  =item match_glob( $glob, @things_to_test )
  
  Returns the list of things which match the glob from the source list.
  
  =item glob_to_regex( $glob )
  
  Returns a compiled regex which is the equivalent of the globbing
  pattern.
  
  =item glob_to_regex_string( $glob )
  
  Returns a regex string which is the equivalent of the globbing
  pattern.
  
  =back
  
  =head1 SYNTAX
  
  The following metacharacters and rules are respected.
  
  =over
  
  =item C<*> - match zero or more characters
  
  C<a*> matches C<a>, C<aa>, C<aaaa> and many many more.
  
  =item C<?> - match exactly one character
  
  C<a?> matches C<aa>, but not C<a>, or C<aaa>
  
  =item Character sets/ranges
  
  C<example.[ch]> matches C<example.c> and C<example.h>
  
  C<demo.[a-c]> matches C<demo.a>, C<demo.b>, and C<demo.c>
  
  =item alternation
  
  C<example.{foo,bar,baz}> matches C<example.foo>, C<example.bar>, and
  C<example.baz>
  
  =item leading . must be explictly matched
  
  C<*.foo> does not match C<.bar.foo>.  For this you must either specify
  the leading . in the glob pattern (C<.*.foo>), or set
  C<$Text::Glob::strict_leading_dot> to a false value while compiling
  the regex.
  
  =item C<*> and C<?> do not match /
  
  C<*.foo> does not match C<bar/baz.foo>.  For this you must either
  explicitly match the / in the glob (C<*/*.foo>), or set
  C<$Text::Glob::strict_wildcard_slash> to a false value with compiling
  the regex.
  
  =back
  
  =head1 BUGS
  
  The code uses qr// to produce compiled regexes, therefore this module
  requires perl version 5.005_03 or newer.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2006, 2007 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Glob>, glob(3)
  
  =cut
TEXT_GLOB

$fatpacked{"Type/Coercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION';
  package Type::Coercion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::VERSION   = '1.000005';
  }
  
  use Eval::TypeTiny qw<>;
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny qw<>;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	fallback   => 1,
  ;
  
  BEGIN {
  	require Type::Tiny;
  	overload->import(
  		q(~~)    => sub { $_[0]->has_coercion_for_value($_[1]) },
  		fallback => 1, # 5.10 loses the fallback otherwise
  	) if Type::Tiny::SUPPORT_SMARTMATCH();
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	
  	if ("Sub::Quote"->can("quote_sub") && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_coercion('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->coerce(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	$params{name} = '__ANON__' unless exists($params{name});
  	my $C = delete($params{type_coercion_map}) || [];
  	my $F = delete($params{frozen});
  	
  	my $self = bless \%params, $class;
  	$self->add_type_coercions(@$C) if @$C;
  	$self->_preserve_type_constraint;
  	Scalar::Util::weaken($self->{type_constraint}); # break ref cycle
  	$self->{frozen} = $F if $F;
  	
  	unless ($self->is_anon)
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$self->name =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $self->name =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid coercion name', $self->name;
  	}
  	
  	return $self;
  }
  
  sub name                   { $_[0]{name} }
  sub display_name           { $_[0]{display_name}      ||= $_[0]->_build_display_name }
  sub library                { $_[0]{library} }
  sub type_constraint        { $_[0]{type_constraint}   ||= $_[0]->_maybe_restore_type_constraint }
  sub type_coercion_map      { $_[0]{type_coercion_map} ||= [] }
  sub moose_coercion         { $_[0]{moose_coercion}    ||= $_[0]->_build_moose_coercion }
  sub compiled_coercion      { $_[0]{compiled_coercion} ||= $_[0]->_build_compiled_coercion }
  sub frozen                 { $_[0]{frozen}            ||= 0 }
  sub coercion_generator     { $_[0]{coercion_generator} }
  sub parameters             { $_[0]{parameters} }
  sub parameterized_from     { $_[0]{parameterized_from} }
  
  sub has_library            { exists $_[0]{library} }
  sub has_type_constraint    { defined $_[0]->type_constraint } # sic
  sub has_coercion_generator { exists $_[0]{coercion_generator} }
  sub has_parameters         { exists $_[0]{parameters} }
  
  sub _preserve_type_constraint
  {
  	my $self = shift;
  	$self->{_compiled_type_constraint_check} = $self->{type_constraint}->compiled_check
  		if $self->{type_constraint};
  }
  
  sub _maybe_restore_type_constraint
  {
  	my $self = shift;
  	if ( my $check = $self->{_compiled_type_constraint_check} )
  	{
  		return Type::Tiny->new(constraint => $check);
  	}
  	return;
  }
  
  sub add
  {
  	my $class = shift;
  	my ($x, $y, $swap) = @_;
  	
  	Types::TypeTiny::TypeTiny->check($x) and return $x->plus_fallback_coercions($y);
  	Types::TypeTiny::TypeTiny->check($y) and return $y->plus_coercions($x);
  	
  	_croak "Attempt to add $class to something that is not a $class"
  		unless blessed($x) && blessed($y) && $x->isa($class) && $y->isa($class);
  	
  	($y, $x) = ($x, $y) if $swap;
  	
  	my %opts;
  	if ($x->has_type_constraint and $y->has_type_constraint and $x->type_constraint == $y->type_constraint)
  	{
  		$opts{type_constraint} = $x->type_constraint;
  	}
  	elsif ($x->has_type_constraint and $y->has_type_constraint)
  	{
  #		require Type::Tiny::Union;
  #		$opts{type_constraint} = "Type::Tiny::Union"->new(
  #			type_constraints => [ $x->type_constraint, $y->type_constraint ],
  #		);
  	}
  	$opts{display_name} ||= "$x+$y";
  	delete $opts{display_name} if $opts{display_name} eq '__ANON__+__ANON__';
  	
  	my $new = $class->new(%opts);
  	$new->add_type_coercions( @{$x->type_coercion_map} );
  	$new->add_type_coercions( @{$y->type_coercion_map} );
  	return $new;
  }
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	
  	if ($self->has_library and not $self->is_anon)
  	{
  		return sprintf("%s::%s", $self->library, $self->name);
  	}
  	
  	return $self->name;
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub _clear_compiled_coercion
  {
  	delete $_[0]{_overload_coderef};
  	delete $_[0]{compiled_coercion};
  }
  
  sub freeze                    { $_[0]{frozen} = 1; $_[0] }
  sub i_really_want_to_unfreeze { $_[0]{frozen} = 0; $_[0] }
  
  sub coerce
  {
  	my $self = shift;
  	return $self->compiled_coercion->(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	my $r = $self->coerce(@_);
  	$self->type_constraint->assert_valid($r)
  		if $self->has_type_constraint;
  	return $r;
  }
  
  sub has_coercion_for_type
  {
  	my $self = shift;
  	my $type = Types::TypeTiny::to_TypeTiny($_[0]);
  	
  	return "0 but true"
  		if $self->has_type_constraint && $type->is_a_type_of($self->type_constraint);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $type->is_a_type_of($c->[$i]);
  	}
  	return;
  }
  
  sub has_coercion_for_value
  {
  	my $self = shift;
  	local $_ = $_[0];
  	
  	return "0 but true"
  		if $self->has_type_constraint && $self->type_constraint->check(@_);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $c->[$i]->check(@_);
  	}
  	return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	my @args = @_;
  	
  	_croak "Attempt to add coercion code to a Type::Coercion which has been frozen" if $self->frozen;
  	
  	while (@args)
  	{
  		my $type     = Types::TypeTiny::to_TypeTiny(shift @args);
  		my $coercion = shift @args;
  		
  		_croak "Types must be blessed Type::Tiny objects"
  			unless Types::TypeTiny::TypeTiny->check($type);
  		_croak "Coercions must be code references or strings"
  			unless Types::TypeTiny::StringLike->check($coercion) || Types::TypeTiny::CodeLike->check($coercion);
  		
  		push @{$self->type_coercion_map}, $type, $coercion;
  	}
  	
  	$self->_clear_compiled_coercion;
  	return $self;
  }
  
  sub _build_compiled_coercion
  {
  	my $self = shift;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return sub { $_[0] } unless @mishmash;
  
  	if ($self->can_be_inlined)
  	{
  		return Eval::TypeTiny::eval_closure(
  			source      => sprintf('sub ($) { %s }', $self->inline_coercion('$_[0]')),
  			description => sprintf("compiled coercion '%s'", $self),
  		);
  	}
  
  	# These arrays will be closed over.
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub,
  			$types[$i]->can_be_inlined ? sprintf('if (%s)', $types[$i]->inline_check('$_[0]')) :
  			sprintf('if ($checks[%d]->(@_))', $i);
  		push @sub,
  			!defined($codes[$i])
  				? sprintf('  { return $_[0] }') :
  			Types::TypeTiny::StringLike->check($codes[$i])
  				? sprintf('  { local $_ = $_[0]; return scalar(%s); }', $codes[$i]) :
  			sprintf('  { local $_ = $_[0]; return scalar($codes[%d]->(@_)) }', $i);
  	}
  	
  	push @sub, 'return $_[0];';
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', join qq[\n], @sub),
  		description => sprintf("compiled coercion '%s'", $self),
  		environment => {
  			'@checks' => [ map $_->compiled_check, @types ],
  			'@codes'  => \@codes,
  		},
  	);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	
  	return unless $self->frozen;
  	
  	return
  		if $self->has_type_constraint
  		&& !$self->type_constraint->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type, $converter) = splice(@mishmash, 0, 2);
  		return unless $type->can_be_inlined;
  		return unless Types::TypeTiny::StringLike->check($converter);
  	}
  	return !!1;
  }
  
  sub _source_type_union
  {
  	my $self = shift;
  	
  	my @r;
  	push @r, $self->type_constraint if $self->has_type_constraint;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type) = splice(@mishmash, 0, 2);
  		push @r, $type;
  	}
  	
  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@r, tmp => 1);
  }
  
  sub inline_coercion
  {
  	my $self = shift;
  	my $varname = $_[0];
  	
  	_croak "This coercion cannot be inlined" unless $self->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return "($varname)" unless @mishmash;
  	
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub, sprintf('(%s) ?', $types[$i]->inline_check($varname));
  		push @sub,
  			(defined($codes[$i]) && ($varname eq '$_'))
  				? sprintf('scalar(do { %s }) :', $codes[$i]) :
  			defined($codes[$i])
  				? sprintf('scalar(do { local $_ = %s; %s }) :', $varname, $codes[$i]) :
  			sprintf('%s :', $varname);
  	}
  	
  	push @sub, "$varname";
  	
  	"@sub";
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	my %options = ();
  	$options{type_coercion_map} = [ $self->freeze->_codelike_type_coercion_map('moose_type') ];
  	$options{type_constraint}   = $self->type_constraint if $self->has_type_constraint;
  	
  	require Moose::Meta::TypeCoercion;
  	my $r = "Moose::Meta::TypeCoercion"->new(%options);
  	
  	return $r;
  }
  
  sub _codelike_type_coercion_map
  {
  	my $self = shift;
  	my $modifier = $_[0];
  	
  	my @orig = @{ $self->type_coercion_map };
  	my @new;
  	
  	while (@orig)
  	{
  		my ($type, $converter) = splice(@orig, 0, 2);
  		
  		push @new, $modifier ? $type->$modifier : $type;
  		
  		if (Types::TypeTiny::CodeLike->check($converter))
  		{
  			push @new, $converter;
  		}
  		else
  		{
  			push @new, Eval::TypeTiny::eval_closure(
  				source      => sprintf('sub { local $_ = $_[0]; %s }', $converter),
  				description => sprintf("temporary compiled converter from '%s'", $type),
  			);
  		}
  	}
  	
  	return @new;
  }
  
  sub is_parameterizable
  {
  	shift->has_coercion_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  sub parameterize
  {
  	my $self = shift;
  	return $self unless @_;
  	$self->is_parameterizable
  		or _croak "Constraint '%s' does not accept parameters", "$self";
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  	
  	return ref($self)->new(
  		type_constraint    => $self->type_constraint,
  		type_coercion_map  => [ $self->coercion_generator->($self, $self->type_constraint, @_) ],
  		parameters         => \@_,
  		frozen             => 1,
  		parameterized_from => $self,
  	);
  }
  
  sub _reparameterize
  {
  	my $self = shift;
  	my ($target_type) = @_;
  	
  	$self->is_parameterized or return $self;
  	my $parent = $self->parameterized_from;
  	
  	return ref($self)->new(
  		type_constraint    => $target_type,
  		type_coercion_map  => [ $parent->coercion_generator->($parent, $target_type, @{$self->parameters}) ],
  		parameters         => \@_,
  		frozen             => 1,
  		parameterized_from => $parent,
  	);
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] eq 'Moose::Meta::TypeCoercion')
  	{
  		return !!1;
  	}
  	
  	if ($INC{"Moose.pm"}
  	and blessed($self)
  	and $_[0] =~ /^(Class::MOP|MooseX?)::/)
  	{
  		my $r = $self->moose_coercion->isa(@_);
  		return $r if $r;
  	}
  	
  	$self->SUPER::isa(@_);
  }
  
  sub can
  {
  	my $self = shift;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if ($INC{"Moose.pm"}
  	and blessed($self)
  	and my $method = $self->moose_coercion->can(@_))
  	{
  		return sub { $method->(shift->moose_coercion, @_) };
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can($m))
  	{
  		return $method->($self->moose_coercion, @_);
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  # Private Moose method, but Moo uses this...
  sub _compiled_type_coercion
  {
  	my $self = shift;
  	if (@_)
  	{
  		my $thing = $_[0];
  		if (blessed($thing) and $thing->isa("Type::Coercion"))
  		{
  			$self->add_type_coercions(@{$thing->type_coercion_map});
  		}
  		elsif (Types::TypeTiny::CodeLike->check($thing))
  		{
  			require Types::Standard;
  			$self->add_type_coercions(Types::Standard::Any(), $thing);
  		}
  	}
  	$self->compiled_coercion;
  }
  
  *compile_type_coercion = \&compiled_coercion;
  sub meta { _croak("Not really a Moose::Meta::TypeCoercion. Sorry!") }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion - a set of coercions to a particular target type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< add($c1, $c2) >>
  
  Create a Type::Coercion from two existing Type::Coercion objects.
  
  =back
  
  =head2 Attributes
  
  Attributes are named values that may be passed to the constructor. For
  each attribute, there is a corresponding reader method. For example:
  
     my $c = Type::Coercion->new( type_constraint => Int );
     my $t = $c->type_constraint;  # Int
  
  =head3 Important attributes
  
  These are the attributes you are likely to be most interested in
  providing when creating your own type coercions, and most interested
  in reading when dealing with coercion objects.
  
  =over
  
  =item C<type_constraint>
  
  Weak reference to the target type constraint (i.e. the type constraint which
  the output of coercion coderefs is expected to conform to).
  
  =item C<type_coercion_map>
  
  Arrayref of source-type/code pairs.
  
  =item C<frozen>
  
  Boolean; default false. A frozen coercion cannot have C<add_type_coercions>
  called upon it.
  
  =item C<name>
  
  A name for the coercion. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous coercion.
  
  =item C<display_name>
  
  A name to display for the coercion when stringified. These don't have
  to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<library>
  
  The package name of the type library this coercion is associated with.
  Optional. Informational only: setting this attribute does not install
  the coercion into the package.
  
  =back
  
  =head3 Attributes related to parameterizable and parameterized coercions
  
  The following attributes are used for parameterized coercions, but are not
  fully documented because they may change in the near future:
  
  =over
  
  =item C<< coercion_generator >>
  
  =item C<< parameters >>
  
  =item C<< parameterized_from >>
  
  =back
  
  =head3 Lazy generated attributes
  
  The following attributes should not be usually passed to the constructor;
  unless you're doing something especially unusual, you should rely on the
  default lazily-built return values.
  
  =over
  
  =item C<< compiled_coercion >>
  
  Coderef to coerce a value (C<< $_[0] >>).
  
  The general point of this attribute is that you should not set it, but
  rely on the lazily-built default. Type::Coerce will usually generate a
  pretty fast coderef, inlining all type constraint checks, etc.
  
  =item C<moose_coercion>
  
  A L<Moose::Meta::TypeCoercion> object equivalent to this one. Don't set this
  manually; rely on the default built one.
  
  =back
  
  =head2 Methods
  
  =head3 Predicate methods
  
  These methods return booleans indicating information about the coercion.
  They are each tightly associated with a particular attribute.
  (See L</"Attributes">.)
  
  =over
  
  =item C<has_type_constraint>, C<has_library>
  
  Simple Moose-style predicate methods indicating the presence or
  absence of an attribute.
  
  =item C<is_anon>
  
  Returns true iff the coercion does not have a C<name>.
  
  =back
  
  The following predicates are used for parameterized coercions, but are not
  fully documented because they may change in the near future:
  
  =over
  
  =item C<< has_coercion_generator >>
  
  =item C<< has_parameters >>
  
  =item C<< is_parameterizable >>
  
  =item C<< is_parameterized >>
  
  =back
  
  =head3 Coercion
  
  The following methods are used for coercing values to a type constraint:
  
  =over
  
  =item C<< coerce($value) >>
  
  Coerce the value to the target type.
  
  Returns the coerced value, or the original value if no coercion was
  possible.
  
  =item C<< assert_coerce($value) >>
  
  Coerce the value to the target type, and throw an exception if the result
  does not validate against the target type constraint.
  
  Returns the coerced value.
  
  =back
  
  =head3 Coercion code definition methods
  
  These methods all return C<< $self >> so are suitable for chaining.
  
  =over
  
  =item C<< add_type_coercions($type1, $code1, ...) >>
  
  Takes one or more pairs of L<Type::Tiny> constraints and coercion code,
  creating an ordered list of source types and coercion codes.
  
  Coercion codes can be expressed as either a string of Perl code (this
  includes objects which overload stringification), or a coderef (or object
  that overloads coderefification). In either case, the value to be coerced
  is C<< $_ >>.
  
  C<< add_type_coercions($coercion_object) >> also works, and can be used
  to copy coercions from another type constraint:
  
     $type->coercion->add_type_coercions($othertype->coercion)->freeze;
  
  =item C<< freeze >>
  
  Sets the C<frozen> attribute to true. Called automatically by L<Type::Tiny>
  sometimes.
  
  =item C<< i_really_want_to_unfreeze >>
  
  If you really want to unfreeze a coercion, call this method.
  
  Don't call this method. It will potentially lead to subtle bugs.
  
  This method is considered unstable; future versions of Type::Tiny may
  alter its behaviour (e.g. to throw an exception if it has been detected
  that unfreezing this particular coercion will cause bugs).
  
  =back
  
  =head3 Parameterization
  
  The following method is used for parameterized coercions, but is not
  fully documented because it may change in the near future:
  
  =over
  
  =item C<< parameterize(@params) >>
  
  =back
  
  =head3 Type coercion introspection methods
  
  These methods allow you to determine a coercion's relationship to type
  constraints:
  
  =over
  
  =item C<< has_coercion_for_type($source_type) >>
  
  Returns true iff this coercion has a coercion from the source type.
  
  Returns the special string C<< "0 but true" >> if no coercion should
  actually be necessary for this type. (For example, if a coercion coerces
  to a theoretical "Number" type, there is probably no coercion necessary
  for values that already conform to the "Integer" type.)
  
  =item C<< has_coercion_for_value($value) >>
  
  Returns true iff the value could be coerced by this coercion.
  
  Returns the special string C<< "0 but true" >> if no coercion would be
  actually be necessary for this value (due to it already meeting the target
  type constraint).
  
  =back
  
  The C<type_constraint> attribute provides a type constraint object for the
  target type constraint of the coercion. See L</"Attributes">.
  
  =head3 Inlining methods
  
  =for stopwords uated
  
  The following methods are used to generate strings of Perl code which
  may be pasted into stringy C<eval>uated subs to perform type coercions:
  
  =over
  
  =item C<< can_be_inlined >>
  
  Returns true iff the coercion can be inlined.
  
  =item C<< inline_coercion($varname) >>
  
  Much like C<inline_coerce> from L<Type::Tiny>.
  
  =back
  
  =head3 Other methods
  
  =over
  
  =item C<< qualified_name >>
  
  For non-anonymous coercions that have a library, returns a qualified
  C<< "MyLib::MyCoercion" >> sort of name. Otherwise, returns the same
  as C<name>.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeCoercion.
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_coercion >>
  
  =item C<< meta >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<coerce>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<has_coercion_for_value>.
  
  =back
  
  Previous versions of Type::Coercion would overload the C<< + >> operator
  to call C<add>. Support for this was dropped after 0.040.
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item B<< Attempt to add coercion code to a Type::Coercion which has been frozen >>
  
  Type::Tiny type constraints are designed as immutable objects. Once you've
  created a constraint, rather than modifying it you generally create child
  constraints to do what you need.
  
  Type::Coercion objects, on the other hand, are mutable. Coercion routines
  can be added at any time during the object's lifetime.
  
  Sometimes Type::Tiny needs to freeze a Type::Coercion object to prevent this.
  In L<Moose> and L<Mouse> code this is likely to happen as soon as you use a
  type constraint in an attribute.
  
  Workarounds:
  
  =over
  
  =item *
  
  Define as many of your coercions as possible within type libraries, not
  within the code that uses the type libraries. The type library will be
  evaluated relatively early, likely before there is any reason to freeze
  a coercion.
  
  =item *
  
  If you do need to add coercions to a type within application code outside
  the type library, instead create a subtype and add coercions to that. The
  C<plus_coercions> method provided by L<Type::Tiny> should make this simple.
  
  =back
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Types::Standard>.
  
  L<Type::Coercion::Union>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_COERCION

$fatpacked{"Type/Coercion/FromMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_FROMMOOSE';
  package Type::Coercion::FromMoose;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::FromMoose::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::FromMoose::VERSION   = '1.000005';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	my @from;
  	if ($self->type_constraint)
  	{
  		my $moose = $self->type_constraint->{moose_type};
  		@from = @{ $moose->coercion->type_coercion_map } if $moose && $moose->has_coercion;
  	}
  	else
  	{
  		_croak "The type constraint attached to this coercion has been garbage collected... PANIC";
  	}
  	
  	my @return;
  	while (@from)
  	{
  		my ($type, $code) = splice(@from, 0, 2);
  		$type = Moose::Util::TypeConstraints::find_type_constraint($type)
  			unless ref $type;
  		push @return, Types::TypeTiny::to_TypeTiny($type), $code;
  	}
  	
  	return \@return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::FromMoose not currently supported" if @_;
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	if ($self->type_constraint)
  	{
  		my $moose = $self->type_constraint->{moose_type};
  		return $moose->coercion if $moose && $moose->has_coercion;
  	}
  	
  	$self->SUPER::_build_moose_coercion(@_);
  }
  
  sub can_be_inlined
  {
  	0;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::FromMoose - a set of coercions borrowed from Moose
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  Moose.
  
  This is mostly for internal purposes.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_FROMMOOSE

$fatpacked{"Type/Coercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_UNION';
  package Type::Coercion::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::Union::VERSION   = '1.000005';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub _preserve_type_constraint
  {
  	my $self = shift;
  	$self->{_union_of} = $self->{type_constraint}->type_constraints
  		if $self->{type_constraint};
  }
  
  sub _maybe_restore_type_constraint
  {
  	my $self = shift;
  	if ( my $union = $self->{_union_of} )
  	{
  		return Type::Tiny::Union->new(type_constraints => $union);
  	}
  	return;
  }
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);
  	$type->isa('Type::Tiny::Union')
  		or _croak "Type::Coercion::Union must be used in conjunction with Type::Tiny::Union";
  	
  	my @c;
  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		push @c, @{$tc->coercion->type_coercion_map};
  	}
  	return \@c;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::Union not currently supported" if @_;
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	my %options = ();
  	$options{type_constraint} = $self->type_constraint if $self->has_type_constraint;
  	
  	require Moose::Meta::TypeCoercion::Union;
  	my $r = "Moose::Meta::TypeCoercion::Union"->new(%options);
  	
  	return $r;
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	
  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);
  	
  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		return !!0 unless $tc->coercion->can_be_inlined;
  	}
  	
  	!!1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::Union - a set of coercions to a union type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  the child constraints of the union type constraint.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion::Union>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_UNION

$fatpacked{"Type/Library.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_LIBRARY';
  package Type::Library;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Library::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Library::VERSION   = '1.000005';
  }
  
  use Eval::TypeTiny qw< eval_closure >;
  use Scalar::Util qw< blessed refaddr >;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny >;
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN { *NICE_PROTOTYPES = ($] >= 5.014) ? sub () { !!1 } : sub () { !!0 } };
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  {
  	my $got_subname;
  	my %already; # prevent renaming established functions
  	sub _subname ($$)
  	{
  		($got_subname or eval "require Sub::Name")
  			and ($got_subname = 1)
  			and !$already{refaddr($_[1])}++
  			and return(Sub::Name::subname(@_));
  		return $_[1];
  	}
  }
  
  sub _exporter_validate_opts
  {
  	my $class = shift;
  	
  	no strict "refs";
  	my $into  = $_[0]{into};
  	push @{"$into\::ISA"}, $class if $_[0]{base};
  	
  	return $class->SUPER::_exporter_validate_opts(@_);
  }
  
  sub _exporter_expand_tag
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	$name eq 'types'     and return map [ "$_"        => $value ], $class->type_names;
  	$name eq 'is'        and return map [ "is_$_"     => $value ], $class->type_names;
  	$name eq 'assert'    and return map [ "assert_$_" => $value ], $class->type_names;
  	$name eq 'to'        and return map [ "to_$_"     => $value ], $class->type_names;
  	$name eq 'coercions' and return map [ "$_"        => $value ], $class->coercion_names;
  	
  	if ($name eq 'all')
  	{
  		no strict "refs";
  		return (
  			map(
  				[ "+$_" => $value ],
  				$class->type_names,
  			),
  			map(
  				[ $_ => $value ],
  				$class->coercion_names,
  				@{"$class\::EXPORT"},
  				@{"$class\::EXPORT_OK"},
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_expand_tag(@_);
  }
  
  sub _mksub
  {
  	my $class = shift;
  	my ($type, $post_method) = @_;
  	$post_method ||= q();
  	
  	my $source = $type->is_parameterizable
  		? sprintf(
  			q{
  				sub (%s) {
  					return $_[0]->complete($type) if ref($_[0]) eq 'Type::Tiny::_HalfOp';
  					my $params; $params = shift if ref($_[0]) eq q(ARRAY);
  					my $t = $params ? $type->parameterize(@$params) : $type;
  					@_ && wantarray ? return($t%s, @_) : return $t%s;
  				}
  			},
  			NICE_PROTOTYPES ? q(;$) : q(;@),
  			$post_method,
  			$post_method,
  		)
  		: sprintf(
  			q{ sub () { $type%s if $] } },
  			$post_method,
  		);
  		
  	return _subname(
  		$type->qualified_name,
  		eval_closure(
  			source      => $source,
  			description => sprintf("exportable function '%s'", $type),
  			environment => {'$type' => \$type},
  		),
  	);
  }
  
  sub _exporter_permitted_regexp
  {
  	my $class = shift;
  	
  	my $inherited = $class->SUPER::_exporter_permitted_regexp(@_);
  	my $types = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->type_names;
  	my $coercions = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->coercion_names;
  	
  	qr{^(?:
  		$inherited
  		| (?: (?:is_|to_|assert_)? (?:$types) )
  		| (?:$coercions)
  	)$}xms;
  }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	if ($name =~ /^\+(.+)/ and $class->has_type($1))
  	{
  		my $type   = $1;
  		my $value2 = +{%{$value||{}}};
  		
  		return map $class->_exporter_expand_sub($_, $value2, $globals),
  			$type, "is_$type", "assert_$type", "to_$type";
  	}
  	
  	if (my $type = $class->get_type($name))
  	{
  		my $post_method = q();
  		$post_method = '->mouse_type' if $globals->{mouse};
  		$post_method = '->moose_type' if $globals->{moose};
  		return ($name => $class->_mksub($type, $post_method)) if $post_method;
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $package = $globals->{into};
  	
  	if (!ref $package and my $type = $class->get_type($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		my $as = $prefix . ($value->{-as} || $name) . $suffix;
  		
  		$INC{'Type/Registry.pm'}
  			? 'Type::Registry'->for_class($package)->add_type($type, $as)
  			: ($Type::Registry::DELAYED{$package}{$as} = $type);
  	}
  	
  	$class->SUPER::_exporter_install_sub(@_);
  }
  
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	my $into = $globals->{into}
  		or _croak("Parameter 'into' not supplied");
  	
  	if ($globals->{declare})
  	{
  		my $declared = sub (;$)
  		{
  			my $params; $params = shift if ref($_[0]) eq "ARRAY";
  			my $type = $into->get_type($name);
  			unless ($type)
  			{
  				_croak "Cannot parameterize a non-existant type" if $params;
  				$type = $name;
  			}
  			
  			my $t = $params ? $type->parameterize(@$params) : $type;
  			@_ && wantarray ? return($t, @_) : return $t;
  		};
  		
  		return(
  			$name,
  			_subname(
  				"$class\::$name",
  				NICE_PROTOTYPES ? sub (;$) { goto $declared } : sub (;@) { goto $declared },
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_fail(@_);
  }
  
  sub meta
  {
  	no strict "refs";
  	no warnings "once";
  	return $_[0] if blessed $_[0];
  	${"$_[0]\::META"} ||= bless {}, $_[0];
  }
  
  sub add_type
  {
  	my $meta  = shift->meta;
  	my $class = blessed($meta);
  	
  	my $type =
  		ref($_[0]) =~ /^Type::Tiny\b/  ? $_[0] :
  		blessed($_[0])                 ? to_TypeTiny($_[0]) :
  		ref($_[0]) eq q(HASH)          ? "Type::Tiny"->new(library => $class, %{$_[0]}) :
  		"Type::Tiny"->new(library => $class, @_);
  	my $name = $type->{name};
  	
  	$meta->{types} ||= {};
  	_croak 'Type %s already exists in this library', $name if $meta->has_type($name);
  	_croak 'Type %s conflicts with coercion of same name', $name if $meta->has_coercion($name);
  	_croak 'Cannot add anonymous type to a library' if $type->is_anon;
  	$meta->{types}{$name} = $type;
  	
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	my $to_type = $type->has_coercion && $type->coercion->frozen
  		? $type->coercion->compiled_coercion
  		: sub ($) { $type->coerce($_[0]) };
  	
  	*{"$class\::$name"}        = $class->_mksub($type);
  	*{"$class\::is_$name"}     = _subname "$class\::is_$name", $type->compiled_check;
  	*{"$class\::to_$name"}     = _subname "$class\::to_$name", $to_type;
  	*{"$class\::assert_$name"} = _subname "$class\::assert_$name", $type->_overload_coderef;
  	
  	return $type;
  }
  
  sub get_type
  {
  	my $meta = shift->meta;
  	$meta->{types}{$_[0]};
  }
  
  sub has_type
  {
  	my $meta = shift->meta;
  	exists $meta->{types}{$_[0]};
  }
  
  sub type_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{types} };
  }
  
  sub add_coercion
  {
  	require Type::Coercion;
  	my $meta = shift->meta;
  	my $c    = blessed($_[0]) ? $_[0] : "Type::Coercion"->new(@_);
  	my $name = $c->name;
  
  	$meta->{coercions} ||= {};
  	_croak 'Coercion %s already exists in this library', $name if $meta->has_coercion($name);
  	_croak 'Coercion %s conflicts with type of same name', $name if $meta->has_type($name);
  	_croak 'Cannot add anonymous type to a library' if $c->is_anon;
  	$meta->{coercions}{$name} = $c;
  
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	my $class = blessed($meta);
  	*{"$class\::$name"} = $class->_mksub($c);
  	
  	return $c;
  }
  
  sub get_coercion
  {
  	my $meta = shift->meta;
  	$meta->{coercions}{$_[0]};
  }
  
  sub has_coercion
  {
  	my $meta = shift->meta;
  	exists $meta->{coercions}{$_[0]};
  }
  
  sub coercion_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{coercions} };
  }
  
  sub make_immutable
  {
  	my $meta  = shift->meta;
  	my $class = ref($meta);
  	
  	for my $type (values %{$meta->{types}})
  	{
  		$type->coercion->freeze;
  		
  		no strict "refs";
  		no warnings "redefine", "prototype";
  		
  		my $to_type = $type->has_coercion && $type->coercion->frozen
  			? $type->coercion->compiled_coercion
  			: sub ($) { $type->coerce($_[0]) };
  		my $name = $type->name;
  		
  		*{"$class\::to_$name"} = _subname "$class\::to_$name", $to_type;
  	}
  	
  	1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX::Types-like
  
  =head1 NAME
  
  Type::Library - tiny, yet Moo(se)-compatible type libraries
  
  =head1 SYNOPSIS
  
  =for test_synopsis
  BEGIN { die "SKIP: crams multiple modules into single example" };
  
     package Types::Mine {
        use Scalar::Util qw(looks_like_number);
        use Type::Library -base;
        use Type::Tiny;
        
        my $NUM = "Type::Tiny"->new(
           name       => "Number",
           constraint => sub { looks_like_number($_) },
           message    => sub { "$_ ain't a number" },
        );
        
        __PACKAGE__->meta->add_type($NUM);
        
        __PACKAGE__->meta->make_immutable;
     }
        
     package Ermintrude {
        use Moo;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Bullwinkle {
        use Moose;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Maisy {
        use Mouse;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Library> is a tiny class for creating MooseX::Types-like type
  libraries which are compatible with Moo, Moose and Mouse.
  
  If you're reading this because you want to create a type library, then
  you're probably better off reading L<Type::Tiny::Manual::Libraries>.
  
  =head2 Methods
  
  A type library is a singleton class. Use the C<meta> method to get a blessed
  object which other methods can get called on. For example:
  
     Types::Mine->meta->add_type($foo);
  
  =begin trustme
  
  =item meta
  
  =end trustme
  
  =over
  
  =item C<< add_type($type) >> or C<< add_type(%opts) >>
  
  Add a type to the library. If C<< %opts >> is given, then this method calls
  C<< Type::Tiny->new(%opts) >> first, and adds the resultant type.
  
  Adding a type named "Foo" to the library will automatically define four
  functions in the library's namespace:
  
  =over
  
  =item C<< Foo >>
  
  Returns the Type::Tiny object.
  
  =item C<< is_Foo($value) >>
  
  Returns true iff $value passes the type constraint.
  
  =item C<< assert_Foo($value) >>
  
  Returns $value iff $value passes the type constraint. Dies otherwise.
  
  =item C<< to_Foo($value) >>
  
  Coerces the value to the type.
  
  =back
  
  =item C<< get_type($name) >>
  
  Gets the C<Type::Tiny> object corresponding to the name.
  
  =item C<< has_type($name) >>
  
  Boolean; returns true if the type exists in the library.
  
  =item C<< type_names >>
  
  List all types defined by the library.
  
  =item C<< add_coercion($c) >> or C<< add_coercion(%opts) >>
  
  Add a standalone coercion to the library. If C<< %opts >> is given, then
  this method calls C<< Type::Coercion->new(%opts) >> first, and adds the
  resultant coercion.
  
  Adding a coercion named "FooFromBar" to the library will automatically
  define a function in the library's namespace:
  
  =over
  
  =item C<< FooFromBar >>
  
  Returns the Type::Coercion object.
  
  =back
  
  =item C<< get_coercion($name) >>
  
  Gets the C<Type::Coercion> object corresponding to the name.
  
  =item C<< has_coercion($name) >>
  
  Boolean; returns true if the coercion exists in the library.
  
  =item C<< coercion_names >>
  
  List all standalone coercions defined by the library.
  
  =item C<< import(@args) >>
  
  Type::Library-based libraries are exporters.
  
  =item C<< make_immutable >>
  
  A shortcut for calling C<< $type->coercion->freeze >> on every
  type constraint in the library.
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< NICE_PROTOTYPES >>
  
  If this is true, then Type::Library will give parameterizable type constraints
  slightly the nicer prototype of C<< (;$) >> instead of the default C<< (;@) >>.
  This allows constructs like:
  
     ArrayRef[Int] | HashRef[Int]
  
  ... to "just work".
  
  =back
  
  =head2 Export
  
  Type libraries are exporters. For the purposes of the following examples,
  assume that the C<Types::Mine> library defines types C<Number> and C<String>.
  
     # Exports nothing.
     # 
     use Types::Mine;
     
     # Exports a function "String" which is a constant returning
     # the String type constraint.
     #
     use Types::Mine qw( String );
     
     # Exports both String and Number as above.
     #
     use Types::Mine qw( String Number );
     
     # Same.
     #
     use Types::Mine qw( :types );
     
     # Exports a sub "is_String" so that "is_String($foo)" is equivalent
     # to "String->check($foo)".
     #
     use Types::Mine qw( is_String );
     
     # Exports "is_String" and "is_Number".
     #
     use Types::Mine qw( :is );
     
     # Exports a sub "assert_String" so that "assert_String($foo)" is
     # equivalent to "String->assert_return($foo)".
     #
     use Types::Mine qw( assert_String );
     
     # Exports "assert_String" and "assert_Number".
     #
     use Types::Mine qw( :assert );
     
     # Exports a sub "to_String" so that "to_String($foo)" is equivalent
     # to "String->coerce($foo)".
     #
     use Types::Mine qw( to_String );
     
     # Exports "to_String" and "to_Number".
     #
     use Types::Mine qw( :to );
     
     # Exports "String", "is_String", "assert_String" and "coerce_String".
     #
     use Types::Mine qw( +String );
     
     # Exports everything.
     #
     use Types::Mine qw( :all );
  
  Type libraries automatically inherit from L<Exporter::Tiny>; see the
  documentation of that module for tips and tricks importing from libraries.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_LIBRARY

$fatpacked{"Type/Params.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARAMS';
  package Type::Params;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Params::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Params::VERSION   = '1.000005';
  }
  
  use B qw();
  use Eval::TypeTiny;
  use Scalar::Util qw(refaddr);
  use Error::TypeTiny;
  use Error::TypeTiny::Assertion;
  use Error::TypeTiny::WrongNumberOfParameters;
  use Type::Tiny::Union;
  use Types::Standard -types;
  use Types::TypeTiny qw(CodeLike ArrayLike to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  our @EXPORT = qw( compile );
  our @EXPORT_OK = qw( multisig validate Invocant );
  
  BEGIN {
  	my $Invocant = 'Type::Tiny::Union'->new(
  		name             => 'Invocant',
  		type_constraints => [Object, ClassName],
  	);
  	sub Invocant () { $Invocant };
  };
  
  sub _mkslurpy
  {
  	my ($name, $type, $tc, $i) = @_;
  	$name = 'local $_' if $name eq '$_';
  	
  	$type eq '@'
  		? sprintf(
  			'%s = [ @_[%d..$#_] ];',
  			$name,
  			$i,
  		)
  		: sprintf(
  			'%s = (($#_-%d)%%2)==0 ? "Error::TypeTiny::WrongNumberOfParameters"->throw(message => sprintf("Odd number of elements in %%s", %s)) : +{ @_[%d..$#_] };',
  			$name,
  			$i,
  			B::perlstring("$tc"),
  			$i,
  		);
  }
  
  sub compile
  {
  	my (@code, %env);
  	@code = 'my (@R, %tmp, $tmp);';
  	push @code, '#placeholder';   # $code[1]
  	
  	my %options    = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my $arg        = -1;
  	my $saw_slurpy = 0;
  	my $min_args   = 0;
  	my $max_args   = 0;
  	my $saw_opt    = 0;
  	
  	while (@_)
  	{
  		++$arg;
  		my $constraint = shift;
  		my $is_optional;
  		my $really_optional;
  		my $is_slurpy;
  		my $varname;
  		
  		if (Bool->check($constraint))
  		{
  			$constraint = $constraint ? Any : Optional[Any];
  		}
  		
  		if (HashRef->check($constraint))
  		{
  			$constraint = to_TypeTiny($constraint->{slurpy});
  			push @code,
  				$constraint->is_a_type_of(Dict)     ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Map)      ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Tuple)    ? _mkslurpy('$_', '@', $constraint => $arg) :
  				$constraint->is_a_type_of(HashRef)  ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(ArrayRef) ? _mkslurpy('$_', '@', $constraint => $arg) :
  				Error::TypeTiny::croak("Slurpy parameter not of type HashRef or ArrayRef");
  			$varname = '$_';
  			$is_slurpy++;
  			$saw_slurpy++;
  		}
  		else
  		{
  			Error::TypeTiny::croak("Parameter following slurpy parameter") if $saw_slurpy;
  			
  			$is_optional     = grep $_->{uniq} == Optional->{uniq}, $constraint->parents;
  			$really_optional = $is_optional && $constraint->parent->{uniq} eq Optional->{uniq} && $constraint->type_parameter;
  			
  			if ($is_optional)
  			{
  				push @code, sprintf 'return @R if $#_ < %d;', $arg;
  				$saw_opt++;
  				$max_args++;
  			}
  			else
  			{
  				Error::TypeTiny::croak("Non-Optional parameter following Optional parameter") if $saw_opt;
  				$min_args++;
  				$max_args++;
  			}
  			
  			$varname = sprintf '$_[%d]', $arg;
  		}
  		
  		if ($constraint->has_coercion and $constraint->coercion->can_be_inlined)
  		{
  			push @code, sprintf(
  				'$tmp%s = %s;',
  				($is_optional ? '{x}' : ''),
  				$constraint->coercion->inline_coercion($varname)
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		elsif ($constraint->has_coercion)
  		{
  			$env{'@coerce'}[$arg] = $constraint->coercion->compiled_coercion;
  			push @code, sprintf(
  				'$tmp%s = $coerce[%d]->(%s);',
  				($is_optional ? '{x}' : ''),
  				$arg,
  				$varname,
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		
  		if ($constraint->can_be_inlined)
  		{
  			push @code, sprintf(
  				'(%s) or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				$really_optional
  					? $constraint->type_parameter->inline_check($varname)
  					: $constraint->inline_check($varname),
  				$constraint->{uniq},
  				B::perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		else
  		{
  			$env{'@check'}[$arg] = $really_optional
  				? $constraint->type_parameter->compiled_check
  				: $constraint->compiled_check;
  			push @code, sprintf(
  				'%s or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				sprintf(sprintf '$check[%d]->(%s)', $arg, $varname),
  				$constraint->{uniq},
  				B::perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		
  		push @code, sprintf 'push @R, %s;', $varname;
  	}
  	
  	if ($min_args == $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ != %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  		);
  	}
  	elsif ($min_args < $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ < %d || @_ > %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  			$max_args,
  		);
  	}
  	elsif ($min_args and $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d) if @_ < %d;',
  			$min_args,
  			$min_args,
  		);
  	}
  	
  	push @code, '@R;';
  	
  	my $source  = "sub { no warnings; ".join("\n", @code)." };";
  	
  	return $source if $options{want_source};
  	
  	my $closure = eval_closure(
  		source      => $source,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => \%env,
  	);
  	
  	return {
  		min_args   => $min_args,
  		max_args   => $saw_slurpy ? undef : $max_args,
  		closure    => $closure,
  	} if $options{want_details};
  	
  	return $closure;
  }
  
  my %compiled;
  sub validate
  {
  	my $arr = shift;
  	my $sub = $compiled{ join ":", map($_->{uniq}||"\@$_->{slurpy}", @_) } ||= compile({ caller_level => 1 }, @_);
  	@_ = @$arr;
  	goto $sub;
  }
  
  sub multisig
  {
  	my %options = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my @multi = map {
  		CodeLike->check($_)  ? { closure => $_ } :
  		ArrayLike->check($_) ? compile({ want_details => 1 }, @$_) :
  		$_;
  	} @_;
  	
  	my @code = 'sub { my $r; ';
  	
  	for my $i (0 .. $#multi)
  	{
  		my $sig = $multi[$i];
  		my @cond;
  		push @cond, sprintf('@_ >= %s', $sig->{min_args}) if defined $sig->{min_args};
  		push @cond, sprintf('@_ <= %s', $sig->{max_args}) if defined $sig->{max_args};
  		push @code, sprintf('if (%s){', join(' and ', @cond)) if @cond;
  		push @code, sprintf('eval { $r = [ $multi[%d]{closure}->(@_) ] };', $i);
  		push @code, 'return(@$r) if $r;';
  		push @code, '}' if @cond;
  	}
  	
  	push @code, '"Error::TypeTiny"->throw(message => "Parameter validation failed");';
  	push @code, '}';
  	
  	eval_closure(
  		source      => \@code,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => { '@multi' => \@multi },
  	);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords evals
  
  =head1 NAME
  
  Type::Params - Params::Validate-like parameter validation using Type::Tiny type constraints and coercions
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Params qw( compile );
   use Types::Standard qw( slurpy Str ArrayRef Num );
     
   sub deposit_monies
   {
      state $check = compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      my $account = Local::BankAccount->new($sort_code, $account_number);
      $account->deposit($_) for @$monies;
   }
   
   deposit_monies("12-34-56", "11223344", 1.2, 3, 99.99);
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type::Params uses L<Type::Tiny> constraints to validate the parameters to a
  sub. It takes the slightly unorthodox approach of separating validation
  into two stages:
  
  =over
  
  =item 1.
  
  Compiling the parameter specification into a coderef; then
  
  =item 2.
  
  Using the coderef to validate parameters.
  
  =back
  
  The first stage is slow (it might take a couple of milliseconds), but you
  only need to do it the first time the sub is called. The second stage is
  fast; according to my benchmarks faster even than the XS version of
  L<Params::Validate>.
  
  If you're using a modern version of Perl, you can use the C<state> keyword
  which was a feature added to Perl in 5.10. If you're stuck on Perl 5.8, the
  example from the SYNOPSIS could be rewritten as:
  
   my $deposit_monies_check;
   sub deposit_monies
   {
      $deposit_monies_check ||= compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      ...;
   }
  
  Not quite as neat, but not awful either.
  
  There's a shortcut reducing it to one step:
  
   use Type::Params qw( validate );
   
   sub deposit_monies
   {
      my ($sort_code, $account_number, $monies) = 
         validate( \@_, Str, Str, slurpy ArrayRef[Num] );
      
      ...;
   }
  
  Type::Params has a few tricks up its sleeve to make sure performance doesn't
  suffer too much with the shortcut, but it's never going to be as fast as the
  two stage compile/execute.
  
  =begin trustme
  
  Dude, these functions are documented!
  
  =item compile
  
  =item validate
  
  =item Invocant
  
  =item multisig
  
  =end trustme
  
  =head1 COOKBOOK
  
  =head2 Positional Parameters
  
     sub nth_root
     {
        state $check = compile( Num, Num );
        my ($x, $n) = $check->(@_);
        
        return $x ** (1 / $n);
     }
  
  =head2 Method Calls
  
  Type::Params exports an additional keyword C<Invocant> on request. This is
  a type constraint accepting blessed objects and also class names.
  
     use Types::Standard qw( ClassName Object Str Int );
     use Type::Params qw( compile Invocant );
     
     # a class method
     sub new_from_json
     {
        state $check = compile( ClassName, Str );
        my ($class, $json) = $check->(@_);
        
        $class->new( from_json($json) );
     }
     
     # an object method
     sub dump
     {
        state $check = compile( Object, Int );
        my ($self, $limit) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     # can be called as either and object or class method
     sub run
     {
        state $check = compile( Invocant );
        my ($proto) = $check->(@_);
        
        my $self = ref($proto) ? $proto : $default_instance;
        $self->_run;
     }
  
  =head2 Optional Parameters
  
     use Types::Standard qw( Object Optional Int );
     
     sub dump
     {
        state $check = compile( Object, Optional[Int] );
        my ($self, $limit) = $check->(@_);
        $limit //= 0;
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     $obj->dump(1);      # ok
     $obj->dump();       # ok
     $obj->dump(undef);  # dies
  
  =head2 Slurpy Parameters
  
     use Types::Standard qw( slurpy ClassName HashRef );
     
     sub new
     {
        state $check = compile( ClassName, slurpy HashRef );
        my ($class, $ref) = $check->(@_);
        bless $ref => $class;
     }
     
     __PACKAGE__->new(foo => 1, bar => 2);
  
  The following types from L<Types::Standard> can be made slurpy:
  C<ArrayRef>, C<Tuple>, C<HashRef>, C<Map>, C<Dict>. Hash-like types
  will die if an odd number of elements are slurped in.
  
  A check may only have one slurpy parameter, and it must be the last
  parameter.
  
  =head2 Named Parameters
  
  Just use a slurpy C<Dict>:
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub dump
     {
        state $check = compile(
           slurpy Dict[
              var    => Ref,
              limit  => Optional[Int],
           ],
        );
        my ($arg) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $arg->{limit};
        print Data::Dumper::Dumper($arg->{var});
     }
     
     dump(var => $foo, limit => 1);   # ok
     dump(var => $foo);               # ok
     dump(limit => 1);                # dies
  
  =head2 Mixed Positional and Named Parameters
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub my_print
     {
        state $check = compile(
           Str,
           slurpy Dict[
              colour => Optional[Str],
              size   => Optional[Int],
           ],
        );
        my ($string, $arg) = $check->(@_);
     }
     
     my_print("Hello World", colour => "blue");
  
  =head2 Coercions
  
  Coercions will automatically be applied for I<all> type constraints that have
  a coercion associated.
  
     use Type::Utils;
     use Types::Standard qw( Int Num );
     
     my $RoundedInt = declare as Int;
     coerce $RoundedInt, from Num, q{ int($_) };
     
     sub set_age
     {
        state $check = compile( Object, $RoundedInt );
        my ($self, $age) = $check->(@_);
        
        $self->{age} = $age;
     }
     
     $obj->set_age(32.5);   # ok; coerced to "32".
  
  Coercions carry over into structured types such as C<ArrayRef> automatically:
  
     sub delete_articles
     {
        state $check = compile( Object, slurpy ArrayRef[$RoundedInt] );
        my ($db, $articles) = $check->(@_);
        
        $db->select_article($_)->delete for @$articles;
     }
     
     # delete articles 1, 2 and 3
     delete_articles($my_db, 1.1, 2.2, 3.3);
  
  If type C<Foo> has coercions from C<Str> and C<ArrayRef> and you want to
  B<prevent> coercion, then use:
  
     state $check = compile( Foo->no_coercions );
  
  Or if you just want to prevent coercion from C<Str>, use:
  
     state $check = compile( Foo->minus_coercions(Str) );
  
  Or maybe add an extra coercion:
  
     state $check = compile(
        Foo->plus_coercions(Int, q{ Foo->new_from_number($_) }),
     );
  
  Note that the coercion is specified as a string of Perl code. This is usually
  the fastest way to do it, but a coderef is also accepted. Either way, the
  value to be coerced is C<< $_ >>.
  
  =head2 Alternatives
  
  Type::Params can export a C<multisig> function that compiles multiple
  alternative signatures into one, and uses the first one that works:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        [ HashRef, Num ],
        [ CodeRef ],
     );
     
     my ($int, $arrayref) = $check->( 1, [] );
     my ($hashref, $num)  = $check->( {}, 1.1 );
     my ($code)           = $check->( sub { 1 } );
     
     $check->( sub { 1 }, 1.1 );  # throws an exception
  
  Coercions, slurpy parameters, etc still work.
  
  There's currently no indication of which of the multiple signatures
  succeeded.
  
  The present implementation involves compiling each signature independently,
  and trying them each (in their given order!) in an C<eval> block. The only
  slightly intelligent part is that it checks if C<< scalar(@_) >> fits into
  the signature properly (taking into account optional and slurpy parameters),
  and skips evals which couldn't possibly succeed.
  
  It's also possible to list coderefs as alternatives in C<multisig>:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        sub { ... },
        [ HashRef, Num ],
        [ CodeRef ],
     );
  
  The coderef is expected to die if that alternative should be abandoned (and
  the next alternative tried), or return the list of accepted parameters. Here's
  a full example:
  
     sub get_from {
        state $check = multisig(
           [ Int, ArrayRef ],
           [ Str, HashRef ],
           sub {
              my ($meth, $obj);
              die unless is_Object($obj);
              die unless $obj->can($meth);
              return ($meth, $obj);
           },
        );
        my ($needle, $haystack) = $check->(@_);
        
        is_HashRef($haystack)  ? $haystack->{$needle} :
        is_ArrayRef($haystack) ? $haystack->[$needle] :
        is_Object($haystack)   ? $haystack->$needle   :
        die;
     }
     
     get_from(0, \@array);      # returns $array[0]
     get_from('foo', \%hash);   # returns $hash{foo}
     get_from('foo', $obj);     # returns $obj->foo
  
  =head1 COMPARISON WITH PARAMS::VALIDATE
  
  L<Type::Params> is not really a drop-in replacement for L<Params::Validate>;
  the API differs far too much to claim that. Yet it performs a similar task,
  so it makes sense to compare them.
  
  =over
  
  =item *
  
  Type::Params will tend to be faster if you've got a sub which is called
  repeatedly, but may be a little slower than Params::Validate for subs that
  are only called a few times. This is because it does a bunch of work the
  first time your sub is called to make subsequent calls a lot faster.
  
  =item *
  
  Type::Params is mostly geared towards positional parameters, while
  Params::Validate seems to be primarily aimed at named parameters. (Though
  either works for either.) Params::Validate doesn't appear to have a
  particularly natural way of validating a mix of positional and named
  parameters.
  
  =item *
  
  Type::Utils allows you to coerce parameters. For example, if you expect
  a L<Path::Tiny> object, you could coerce it from a string.
  
  =item *
  
  Params::Validate allows you to supply defaults for missing parameters;
  Type::Params does not, but you may be able to use coercion from Undef.
  
  =item *
  
  If you are primarily writing object-oriented code, using Moose or similar,
  and you are using Type::Tiny type constraints for your attributes, then
  using Type::Params allows you to use the same constraints for method calls.
  
  =item *
  
  Type::Params comes bundled with Types::Standard, which provides a much
  richer vocabulary of types than the type validation constants that come
  with Params::Validate. For example, Types::Standard provides constraints
  like C<< ArrayRef[Int] >> (an arrayref of integers), while the closest from
  Params::Validate is C<< ARRAYREF >>, which you'd need to supplement with
  additional callbacks if you wanted to check that the arrayref contained
  integers.
  
  Whatsmore, Type::Params doesn't just work with Types::Standard, but also
  any other Type::Tiny type constraints.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>, L<Type::Coercion>, L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARAMS

$fatpacked{"Type/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARSER';
  package Type::Parser;
  
  use strict;
  use warnings;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';
  
  # Token types
  # 
  sub TYPE      () { "TYPE" };
  sub QUOTELIKE () { "QUOTELIKE" };
  sub STRING    () { "STRING" };
  sub CLASS     () { "CLASS" };
  sub L_BRACKET () { "L_BRACKET" };
  sub R_BRACKET () { "R_BRACKET" };
  sub COMMA     () { "COMMA" };
  sub SLURPY    () { "SLURPY" };
  sub UNION     () { "UNION" };
  sub INTERSECT () { "INTERSECT" };
  sub NOT       () { "NOT" };
  sub L_PAREN   () { "L_PAREN" };
  sub R_PAREN   () { "R_PAREN" };
  sub MYSTERY   () { "MYSTERY" };
  
  our @EXPORT_OK = qw( eval_type _std_eval parse extract_type );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  Evaluate: {
  	
  	sub parse
  	{
  		my $str = $_[0];
  		my $parser = "Type::Parser::AstBuilder"->new(input => $str);
  		$parser->build;
  		wantarray ? ($parser->ast, $parser->remainder) : $parser->ast;
  	}
  	
  	sub extract_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		wantarray ? (_eval_type($parsed, $reg), $tail) : _eval_type($parsed, $reg);
  	}
  	
  	sub eval_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		_croak("Unexpected tail on type expression: $tail") if $tail =~ /\S/sm;
  		return _eval_type($parsed, $reg);
  	}
  	
  	my $std;
  	sub _std_eval
  	{
  		require Type::Registry;
  		unless ($std)
  		{
  			$std = "Type::Registry"->new;
  			$std->add_types(-Standard);
  		}
  		eval_type($_[0], $std);
  	}
  	
  	sub _eval_type
  	{
  		my ($node, $reg) = @_;
  		
  		$node = _simplify_expression($node);
  		
  		if ($node->{type} eq "list")
  		{
  			return map _eval_type($_, $reg), @{$node->{list}};
  		}
  		
  		if ($node->{type} eq "union")
  		{
  			return $reg->make_union(
  				map _eval_type($_, $reg), @{$node->{union}}
  			);
  		}
  		
  		if ($node->{type} eq "intersect")
  		{
  			return $reg->make_intersection(
  				map _eval_type($_, $reg), @{$node->{intersect}}
  			);
  		}
  		
  		if ($node->{type} eq "slurpy")
  		{
  			return +{ slurpy => _eval_type($node->{of}, $reg) };
  		}
  		
  		if ($node->{type} eq "complement")
  		{
  			return _eval_type($node->{of}, $reg)->complementary_type;
  		}
  		
  		if ($node->{type} eq "parameterized")
  		{
  			my $base = _eval_type($node->{base}, $reg);
  			
  			return $base unless $base->is_parameterizable || $node->{params};
  			return $base->parameterize($node->{params} ? _eval_type($node->{params}, $reg) : ());
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq CLASS)
  		{
  			my $class = substr(
  				$node->{token}->spelling,
  				0,
  				length($node->{token}->spelling) - 2
  			);
  			return $reg->make_class_type($class);
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq QUOTELIKE)
  		{
  			return eval($node->{token}->spelling); #ARGH
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq STRING)
  		{
  			return $node->{token}->spelling;
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq TYPE)
  		{
  			my $t = $node->{token}->spelling;
  			my $r = ($t =~ /^(.+)::(\w+)$/)
  				? $reg->foreign_lookup($t, 1)
  				: $reg->simple_lookup($t, 1);
  			$r or _croak("%s is not a known type constraint", $node->{token}->spelling);
  			return $r;
  		}
  	}
  	
  	sub _simplify_expression
  	{
  		my $expr = shift;
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq COMMA)
  		{
  			return _simplify("list", COMMA, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq UNION)
  		{
  			return _simplify("union", UNION, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq INTERSECT)
  		{
  			return _simplify("intersect", INTERSECT, $expr);
  		}
  		
  		return $expr;
  	}
  	
  	sub _simplify
  	{
  		my $type = shift;
  		my $op   = shift;
  		
  		my @list;
  		for my $expr ($_[0]{lhs}, $_[0]{rhs})
  		{
  			if ($expr->{type} eq "expression" and $expr->{op}[0] eq $op)
  			{
  				my $simple = _simplify($type, $op, $expr);
  				push @list, @{ $simple->{$type} };
  			}
  			else
  			{
  				push @list, $expr;
  			}
  		}
  		
  		return { type => $type, $type => \@list };
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::AstBuilder;
  	
  	sub new
  	{
  		my $class = shift;
  		bless { @_ }, $class;
  	}
  	
  	our %precedence = (
  #		Type::Parser::COMMA()     , 1 ,
  		Type::Parser::UNION()     , 2 ,
  		Type::Parser::INTERSECT() , 3 ,
  		Type::Parser::NOT()       , 4 ,
  	);
  	
  	sub _parse_primary
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		$tokens->assert_not_empty;
  		
  		if ($tokens->peek(0)->type eq Type::Parser::NOT)
  		{
  			$tokens->eat(Type::Parser::NOT);
  			$tokens->assert_not_empty;
  			return {
  				type  => "complement",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::SLURPY)
  		{
  			$tokens->eat(Type::Parser::SLURPY);
  			$tokens->assert_not_empty;
  			return {
  				type  => "slurpy",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::L_PAREN)
  		{
  			$tokens->eat(Type::Parser::L_PAREN);
  			my $r = $self->_parse_expression;
  			$tokens->eat(Type::Parser::R_PAREN);
  			return $r;
  		}
  		
  		if ($tokens->peek(1)
  		and $tokens->peek(0)->type eq Type::Parser::TYPE
  		and $tokens->peek(1)->type eq Type::Parser::L_BRACKET)
  		{
  			my $base = { type  => "primary", token => $tokens->eat(Type::Parser::TYPE) };
  			$tokens->eat(Type::Parser::L_BRACKET);
  			$tokens->assert_not_empty;
  			
  			local $precedence{ Type::Parser::COMMA() } = 1;
  			
  			my $params = undef;
  			if ($tokens->peek(0)->type eq Type::Parser::R_BRACKET)
  			{
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			else
  			{
  				$params = $self->_parse_expression;
  				$params = { type => "list", list => [$params] } unless $params->{type} eq "list";
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			return {
  				type   => "parameterized",
  				base   => $base,
  				params => $params,
  			};
  		}
  		
  		my $type = $tokens->peek(0)->type;
  		if ($type eq Type::Parser::TYPE
  		or  $type eq Type::Parser::QUOTELIKE
  		or  $type eq Type::Parser::STRING
  		or  $type eq Type::Parser::CLASS)
  		{
  			return { type  => "primary", token => $tokens->eat };
  		}
  		
  		Type::Parser::_croak("Unexpected token in primary type expression; got '%s'", $tokens->peek(0)->spelling);
  	}
  	
  	sub _parse_expression_1
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		my ($lhs, $min_p) = @_;
  		while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} >= $min_p)
  		{
  			my $op  = $tokens->eat;
  			my $rhs = $self->_parse_primary;
  			
  			while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} > $precedence{$op->type})
  			{
  				my $lookahead = $tokens->peek(0);
  				$rhs = $self->_parse_expression_1($rhs, $precedence{$lookahead->type});
  			}
  			
  			$lhs = {
  				type => "expression",
  				op   => $op,
  				lhs  => $lhs,
  				rhs  => $rhs,
  			};
  		}
  		return $lhs;
  	}
  	
  	sub _parse_expression
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		return $self->_parse_expression_1($self->_parse_primary, 0);
  	}
  	
  	sub build
  	{
  		my $self = shift;
  		$self->{tokens} = "Type::Parser::TokenStream"->new(remaining => $self->{input});
  		$self->{ast}    = $self->_parse_expression;
  	}
  	
  	sub ast
  	{
  		$_[0]{ast};
  	}
  	
  	sub remainder
  	{
  		$_[0]{tokens}->remainder;
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::Token;
  	sub type     { $_[0][0] }
  	sub spelling { $_[0][1] }
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::TokenStream;
  	
  	use Scalar::Util qw(looks_like_number);
  	use Text::Balanced qw(extract_quotelike);
  	
  	sub new
  	{
  		my $class = shift;
  		bless { stack => [], done => [], @_ }, $class;
  	}
  	
  	sub peek
  	{
  		my $self  = shift;
  		my $ahead = $_[0];
  		
  		while ($self->_stack_size <= $ahead and length $self->{remaining})
  		{
  			$self->_stack_extend;
  		}
  		
  		my @tokens = grep ref, @{ $self->{stack} };
  		return $tokens[$ahead];
  	}
  	
  	sub empty
  	{
  		my $self = shift;
  		not $self->peek(0);
  	}
  	
  	sub eat
  	{
  		my $self = shift;
  		$self->_stack_extend unless $self->_stack_size;
  		my $r;
  		while (defined(my $item = shift @{$self->{stack}}))
  		{
  			push @{ $self->{done} }, $item;
  			if (ref $item)
  			{
  				$r = $item;
  				last;
  			}
  		}
  		
  		if (@_ and $_[0] ne $r->type)
  		{
  			unshift @{$self->{stack}}, pop @{$self->{done}};
  			Type::Parser::_croak("Expected $_[0]; got ".$r->type);
  		}
  		
  		return $r;
  	}
  	
  	sub assert_not_empty
  	{
  		my $self = shift;
  		Type::Parser::_croak("Expected token; got empty string") if $self->empty;
  	}
  	
  	sub _stack_size
  	{
  		my $self = shift;
  		scalar grep ref, @{ $self->{stack} };
  	}
  	
  	sub _stack_extend
  	{
  		my $self = shift;
  		push @{ $self->{stack} }, $self->_read_token;
  		my ($space) = ($self->{remaining} =~ m/^([\s\n\r]*)/sm);
  		return unless length $space;
  		push @{ $self->{stack} }, $space;
  		substr($self->{remaining}, 0, length $space) = "";
  	}
  	
  	sub remainder
  	{
  		my $self = shift;
  		return join "",
  			map { ref($_) ? $_->spelling : $_ }
  			(@{$self->{stack}}, $self->{remaining})
  	}
  	
  	my %punctuation = (
  		'['       => bless([ Type::Parser::L_BRACKET, "[" ], "Type::Parser::Token"),
  		']'       => bless([ Type::Parser::R_BRACKET, "]" ], "Type::Parser::Token"),
  		'('       => bless([ Type::Parser::L_PAREN,   "[" ], "Type::Parser::Token"),
  		')'       => bless([ Type::Parser::R_PAREN,   "]" ], "Type::Parser::Token"),
  		','       => bless([ Type::Parser::COMMA,     "," ], "Type::Parser::Token"),
  		'=>'      => bless([ Type::Parser::COMMA,     "=>" ], "Type::Parser::Token"),
  		'slurpy'  => bless([ Type::Parser::SLURPY,    "slurpy" ], "Type::Parser::Token"),
  		'|'       => bless([ Type::Parser::UNION,     "|" ], "Type::Parser::Token"),
  		'&'       => bless([ Type::Parser::INTERSECT, "&" ], "Type::Parser::Token"),
  		'~'       => bless([ Type::Parser::NOT,       "~" ], "Type::Parser::Token"),
  	);
  	
  	sub _read_token
  	{
  		my $self = shift;
  		
  		return if $self->{remaining} eq "";
  		
  		# Punctuation
  		# 
  		
  		if ($self->{remaining} =~ /^( => | [()\]\[|&~,] )/xsm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			return $punctuation{$spelling};
  		}
  		
  		if (my $quotelike = extract_quotelike $self->{remaining})
  		{
  			return bless([ Type::Parser::QUOTELIKE, $quotelike ], "Type::Parser::Token"),;
  		}
  		
  		if ($self->{remaining} =~ /^([+-]?[\w:.+]+)/sm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			
  			if ($spelling =~ /::$/sm)
  			{
  				return bless([ Type::Parser::CLASS, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif (looks_like_number($spelling))
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($self->{remaining} =~ /^\s*=>/sm) # peek ahead
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($spelling eq "slurpy")
  			{
  				return $punctuation{$spelling};
  			}
  			
  			return bless([ Type::Parser::TYPE, $spelling ], "Type::Parser::Token");
  		}
  		
  		my $rest = $self->{remaining};
  		$self->{remaining} = "";
  		return bless([ Type::Parser::MYSTERY, $rest ], "Type::Parser::Token");
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords non-whitespace
  
  =head1 NAME
  
  Type::Parser - parse type constraint strings
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Parser qw( eval_type );
   use Type::Registry;
   
   my $reg = Type::Registry->for_me;
   $reg->add_types("Types::Standard");
   
   my $type = eval_type("Int | ArrayRef[Int]", $reg);
   
   $type->check(10);        # true
   $type->check([1..4]);    # true
   $type->check({foo=>1});  # false
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Generally speaking, you probably don't want to be using this module directly.
  Instead use the C<< lookup >> method from L<Type::Registry> which wraps it.
  
  =head2 Functions
  
  =over
  
  =item C<< parse($string) >>
  
  Parse the type constraint string into something like an AST.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< extract_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< eval_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  Throws an error if the "tail" contains any non-whitespace character.
  
  =back
  
  =head2 Constants
  
  The following constants correspond to values returned by C<< $token->type >>.
  
  =over
  
  =item C<< TYPE >>
  
  =item C<< QUOTELIKE >>
  
  =item C<< STRING >>
  
  =item C<< CLASS >>
  
  =item C<< L_BRACKET >>
  
  =item C<< R_BRACKET >>
  
  =item C<< COMMA >>
  
  =item C<< SLURPY >>
  
  =item C<< UNION >>
  
  =item C<< INTERSECT >>
  
  =item C<< NOT >>
  
  =item C<< L_PAREN >>
  
  =item C<< R_PAREN >>
  
  =item C<< MYSTERY >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Registry>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARSER

$fatpacked{"Type/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_REGISTRY';
  package Type::Registry;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Registry::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Registry::VERSION   = '1.000005';
  }
  
  use Exporter::Tiny qw( mkopt );
  use Scalar::Util qw( refaddr );
  use Type::Parser qw( eval_type );
  use Types::TypeTiny qw( CodeLike ArrayLike to_TypeTiny );
  
  our @ISA = 'Exporter::Tiny';
  our @EXPORT_OK = qw(t);
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	
  	if ($name eq "t")
  	{
  		my $caller = $globals->{into};
  		my $reg = $class->for_class(
  			ref($caller) ? sprintf('HASH(0x%08X)', refaddr($caller)) : $caller
  		);
  		return t => sub (;$) { @_ ? $reg->lookup(@_) : $reg };
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  sub new
  {
  	my $class = shift;
  	ref($class) and _croak("Not an object method");
  	bless {}, $class;
  }
  
  {
  	my %registries;
  	
  	sub for_class
  	{
  		my $class = shift;
  		my ($for) = @_;
  		$registries{$for} ||= $class->new;
  	}
  	
  	sub for_me
  	{
  		my $class = shift;
  		my $for   = caller;
  		$registries{$for} ||= $class->new;
  	}
  }
  
  sub add_types
  {
  	my $self = shift;
  	my $opts = mkopt(\@_);
  	for my $opt (@$opts)
  	{
  		my ($lib, $types) = @_;
  		
  		$lib =~ s/^-/Types::/;
  		eval "require $lib";
  		
  		my %hash;
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$types ||= [qw/-types/];
  			ArrayLike->check($types)
  				or _croak("Expected arrayref following '%s'; got %s", $lib, $types);
  			
  			$lib->import({into => \%hash}, @$types);
  			$hash{$_} = &{$hash{$_}}() for keys %hash;
  		}
  		elsif ($lib->isa("MooseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MooseX::Types type constraint library. No import options currently supported", $lib);
  			
  			require Moose::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Moose::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		elsif ($lib->isa("MouseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MouseX::Types type constraint library. No import options currently supported", $lib);
  			
  			require Mouse::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Mouse::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		else
  		{
  			_croak("%s is not a type library", $lib);
  		}
  		
  		for my $key (sort keys %hash)
  		{
  			exists($self->{$key})
  				and $self->{$key}{uniq} != $hash{$key}{uniq}
  				and _croak("Duplicate type name: %s", $key);
  			$self->{$key} = $hash{$key};
  		}
  	}
  	$self;
  }
  
  sub add_type
  {
  	my $self = shift;
  	my ($type, $name) = @_;
  	$type = to_TypeTiny($type);
  	$name ||= do {
  		$type->is_anon
  			and _croak("Expected named type constraint; got anonymous type constraint");
  		$type->name;
  	};
  	
  	exists($self->{$name})
  		and $self->{$name}{uniq} != $type->{uniq}
  		and _croak("Duplicate type name: %s", $name);
  	
  	$self->{$name} = $type;
  	$self;
  }
  
  sub alias_type
  {
  	my $self = shift;
  	my ($old, @new) = @_;
  	my $lookup = eval { $self->lookup($old) }
  		or _croak("Expected existing type constraint name; got '$old'");
  	$self->{$_} = $lookup for @new;
  	$self;
  }
  
  sub simple_lookup
  {
  	my $self = shift;
  	
  	my ($tc) = @_;
  	$tc =~ s/(^\s+|\s+$)//g;
  	
  	if (exists $self->{$tc})
  	{
  		return $self->{$tc};
  	}
  	
  	return;
  }
  
  sub foreign_lookup
  {
  	my $self = shift;
  	
  	return $_[1] ? () : $self->simple_lookup($_[0], 1)
  		unless $_[0] =~ /^(.+)::(\w+)$/;
  	
  	my $library  = $1;
  	my $typename = $2;
  	
  	eval "require $library;";
  	
  	if ( $library->isa('MooseX::Types::Base') )
  	{
  		require Moose::Util::TypeConstraints;
  		my $type = Moose::Util::TypeConstraints::find_type_constraint(
  			$library->get_type($typename)
  		) or return;
  		return to_TypeTiny($type);
  	}
  	
  	if ( $library->isa('MouseX::Types::Base') )
  	{
  		require Mouse::Util::TypeConstraints;
  		my $sub  = $library->can($typename) or return;
  		my $type = Mouse::Util::TypeConstraints::find_type_constraint($sub->()) or return;
  		return to_TypeTiny($type);
  	}
  	
  	if ( $library->can("get_type") )
  	{
  		my $type = $library->get_type($typename);
  		return to_TypeTiny($type);
  	}
  	
  	return;
  }
  
  sub lookup
  {
  	my $self = shift;
  	
  	$self->simple_lookup(@_) or eval_type($_[0], $self);
  }
  
  sub make_union
  {
  	my $self = shift;
  	my (@types) = @_;
  	
  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@types);
  }
  
  sub make_intersection
  {
  	my $self = shift;
  	my (@types) = @_;
  	
  	require Type::Tiny::Intersection;
  	return "Type::Tiny::Intersection"->new(type_constraints => \@types);
  }
  
  sub make_class_type
  {
  	my $self = shift;
  	my ($class) = @_;
  	
  	require Type::Tiny::Class;
  	return "Type::Tiny::Class"->new(class => $class);
  }
  
  sub make_role_type
  {
  	my $self = shift;
  	my ($role) = @_;
  	
  	require Type::Tiny::Role;
  	return "Type::Tiny::Role"->new(role => $role);
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  	my $type = $self->simple_lookup($method);
  	return $type if $type;
  	_croak(q[Can't locate object method "%s" via package "%s"], $method, ref($self));
  }
  
  # Prevent AUTOLOAD being called for DESTROY!
  sub DESTROY
  {
  	return;
  }
  
  DELAYED: {
  	our %DELAYED;
  	for my $package (sort keys %DELAYED)
  	{
  		my $reg   = __PACKAGE__->for_class($package);
  		my $types = $DELAYED{$package};
  		
  		for my $name (sort keys %$types)
  		{
  			$reg->add_type($types->{$name}, $name);
  		}
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords optlist
  
  =head1 NAME
  
  Type::Registry - a glorified hashref for looking up type constraints
  
  =head1 SYNOPSIS
  
  =for test_synopsis no warnings qw(misc);
  
     package Foo::Bar;
     
     use Type::Registry;
     
     my $reg = "Type::Registry"->for_me;  # a registry for Foo::Bar
     
     # Register all types from Types::Standard
     $reg->add_types(-Standard);
     
     # Register just one type from Types::XSD
     $reg->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     $reg->add_types("MyApp::Types");
     
     # Create a type alias
     $reg->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = $reg->lookup("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  Alternatively:
  
     package Foo::Bar;
     
     use Type::Registry qw( t );
     
     # Register all types from Types::Standard
     t->add_types(-Standard);
     
     # Register just one type from Types::XSD
     t->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     t->add_types("MyApp::Types");
     
     # Create a type alias
     t->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = t("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A type registry is basically just a hashref mapping type names to type
  constraint objects.
  
  =head2 Constructors
  
  =over
  
  =item C<< new >>
  
  Create a new glorified hashref.
  
  =item C<< for_class($class) >>
  
  Create or return the existing glorified hashref associated with the given
  class.
  
  Note that any type constraint you have imported from Type::Library-based
  type libraries will be automatically available in your class' registry.
  
  =item C<< for_me >>
  
  Create or return the existing glorified hashref associated with the caller.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< add_types(@libraries) >>
  
  The libraries list is treated as an "optlist" (a la L<Data::OptList>).
  
  Strings are the names of type libraries; if the first character is a
  hyphen, it is expanded to the "Types::" prefix. If followed by an
  arrayref, this is the list of types to import from that library.
  Otherwise, imports all types from the library.
  
     use Type::Registry qw(t);
     
     t->add_types(-Standard);  # OR: t->add_types("Types::Standard");
     
     t->add_types(
        -TypeTiny => ['HashLike'],
        -Standard => ['HashRef' => { -as => 'RealHash' }],
     );
  
  L<MooseX::Types> (and experimentally, L<MouseX::Types>) libraries can
  also be added this way, but I<< cannot be followed by an arrayref of
  types to import >>.
  
  =item C<< add_type($type, $name) >>
  
  The long-awaited singular form of C<add_types>. Given a type constraint
  object, adds it to the registry with a given name. The name may be
  omitted, in which case C<< $type->name >> is called, and Type::Registry
  will throw an error if C<< $type >> is anonymous. If a name is explicitly
  given, Type::Registry cares not one wit whether the type constraint is
  anonymous.
  
  This method can even add L<MooseX::Types> and L<MouseX::Types> type
  constraints; indeed anything that can be handled by L<Types::TypeTiny>'s
  C<to_TypeTiny> function. (Bear in mind that to_TypeTiny I<always> results
  in an anonymous type constraint, so C<< $name >> will be required.)
  
  =item C<< alias_type($oldname, $newname) >>
  
  Create an alias for an existing type.
  
  =item C<< simple_lookup($name) >>
  
  Look up a type in the registry by name. 
  
  Returns undef if not found.
  
  =item C<< foreign_lookup($name) >>
  
  Like C<simple_lookup>, but if the type name contains "::", will attempt
  to load it from a type library. (And will attempt to load that module.)
  
  =item C<< lookup($name) >>
  
  Look up by name, with a DSL.
  
     t->lookup("Int|ArrayRef[Int]")
  
  The DSL can be summed up as:
  
     X               type from this registry
     My::Lib::X      type from a type library
     ~X              complementary type
     X | Y           union
     X & Y           intersection
     X[...]          parameterized type
     slurpy X        slurpy type
     Foo::Bar::      class type
  
  Croaks if not found.
  
  =item C<< make_union(@constraints) >>,
  C<< make_intersection(@constraints) >>,
  C<< make_class_type($class) >>,
  C<< make_role_type($role) >>
  
  Convenience methods for creating certain common type constraints.
  
  =item C<< AUTOLOAD >>
  
  Overloaded to call C<lookup>.
  
     $registry->Str;  # like $registry->lookup("Str")
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< t >>
  
  This class can export a function C<< t >> which acts like
  C<< "Type::Registry"->for_class($importing_class) >>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Library>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_REGISTRY

$fatpacked{"Type/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY';
  package Type::Tiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::AUTHORITY   = 'cpan:TOBYINK';
  	$Type::Tiny::VERSION     = '1.000005';
  	$Type::Tiny::XS_VERSION  = '0.010';
  }
  
  use Eval::TypeTiny ();
  use Scalar::Util qw( blessed weaken refaddr isweak );
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _swap { $_[2] ? @_[1,0] : @_[0,1] }
  
  BEGIN {
  	($] < 5.010001)
  		? eval q{ sub SUPPORT_SMARTMATCH () { !!0 } }
  		: eval q{ sub SUPPORT_SMARTMATCH () { !!1 } };
  	($] >= 5.014)
  		? eval q{ sub _FIXED_PRECEDENCE () { !!1 } }
  		: eval q{ sub _FIXED_PRECEDENCE () { !!0 } };
  };
  
  BEGIN {
  	my $try_xs =
  		exists($ENV{PERL_TYPE_TINY_XS}) ? !!$ENV{PERL_TYPE_TINY_XS} :
  		exists($ENV{PERL_ONLY})         ?  !$ENV{PERL_ONLY} :
  		1;
  	
  	my $use_xs = 0;
  	$try_xs and eval {
  		require Type::Tiny::XS;
  		'Type::Tiny::XS'->VERSION($Type::Tiny::XS_VERSION);
  		$use_xs++;
  	};
  	
  	*_USE_XS = $use_xs
  		? sub () { !!1 }
  		: sub () { !!0 };
  	
  	*_USE_MOUSE = $try_xs
  		? sub () { $INC{'Mouse/Util.pm'} and Mouse::Util::MOUSE_XS() }
  		: sub () { !!0 };
  };
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(|)       => sub {
  		my @tc = _swap @_;
  		if (!_FIXED_PRECEDENCE && !blessed $tc[0] && ref $tc[0] eq 'ARRAY') {
  			require Type::Tiny::_HalfOp;
  			return "Type::Tiny::_HalfOp"->new('|', @tc);
  		}
  		require Type::Tiny::Union;
  		"Type::Tiny::Union"->new(type_constraints => \@tc)
  	},
  	q(&)       => sub {
  		my @tc = _swap @_;
  		if (!_FIXED_PRECEDENCE && !blessed $tc[0] && ref $tc[0] eq 'ARRAY') {
  			require Type::Tiny::_HalfOp;
  			return "Type::Tiny::_HalfOp"->new('&', @tc);
  		}
  		require Type::Tiny::Intersection;
  		"Type::Tiny::Intersection"->new(type_constraints => \@tc)
  	},
  	q(~)       => sub { shift->complementary_type },
  	q(==)      => sub { $_[0]->equals($_[1]) },
  	q(<)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(_swap @_) },
  	q(>)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(reverse _swap @_) },
  	q(<=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(_swap @_) },
  	q(>=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(reverse _swap @_) },
  	q(eq)      => sub { "$_[0]" eq "$_[1]" },
  	q(cmp)     => sub { $_[2] ? ("$_[1]" cmp "$_[0]") : ("$_[0]" cmp "$_[1]") },
  	fallback   => 1,
  ;
  BEGIN {
  	overload->import(
  		q(~~)    => sub { $_[0]->check($_[1]) },
  		fallback => 1, # 5.10 loses the fallback otherwise
  	) if Type::Tiny::SUPPORT_SMARTMATCH;
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	$self->message unless exists $self->{message};
  	
  #	if ($self->has_parent && $self->_is_null_constraint)
  #	{
  #		$self->{_overload_coderef} ||= $self->parent->_overload_coderef;
  #	}
  #	els
  	if (!exists($self->{message}) && exists(&Sub::Quote::quote_sub) && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_assert('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->assert_return(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  our %ALL_TYPES;
  
  my $QFS;
  my $uniq = 1;
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	if (exists $params{parent})
  	{
  		$params{parent} = ref($params{parent}) =~ /^Type::Tiny\b/
  			? $params{parent}
  			: Types::TypeTiny::to_TypeTiny($params{parent});
  		
  		_croak "Parent must be an instance of %s", __PACKAGE__
  			unless blessed($params{parent}) && $params{parent}->isa(__PACKAGE__);
  	}
  	
  	$params{name} = "__ANON__" unless exists $params{name};
  	$params{uniq} = $uniq++;
  	
  	if ($params{name} ne "__ANON__")
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$params{name} =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid type name', $params{name};
  	}
  	
  	if (exists $params{coercion} and !ref $params{coercion} and $params{coercion})
  	{
  		$params{parent}->has_coercion
  			or _croak "coercion => 1 requires type to have a direct parent with a coercion";
  		
  		$params{coercion} = $params{parent}->coercion->type_coercion_map;
  	}
  	
  	if (!exists $params{inlined}
  	and exists $params{constraint}
  	and ( !exists $params{parent} or $params{parent}->can_be_inlined )
  	and $QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($params{constraint}) || [] };
  		
  		$params{inlined} = sub {
  			my ($self, $var) = @_;
  			my $code = Sub::Quote::inlinify(
  				$perlstring,
  				$var,
  				$var eq q($_) ? '' : "local \$_ = $var;",
  				1,
  			);
  			$code = sprintf('%s and %s', $self->parent->inline_check($var), $code) if $self->has_parent;
  			return $code;
  		} if $perlstring && !$captures;
  	}
  	
  	my $self = bless \%params, $class;
  	
  	unless ($params{tmp})
  	{
  		my $uniq = $self->{uniq};
  		
  		$ALL_TYPES{$uniq} = $self;
  		weaken( $ALL_TYPES{$uniq} );
  		
  		package # no index
  			Moo::HandleMoose;
  		my $tmp = $self;
  		Scalar::Util::weaken($tmp);
  		$Moo::HandleMoose::TYPE_MAP{$self} = sub { $tmp };
  	}
  	
  	if (ref($params{coercion}) eq q(CODE))
  	{
  		require Types::Standard;
  		my $code = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(Types::Standard::Any(), $code);
  	}
  	elsif (ref($params{coercion}) eq q(ARRAY))
  	{
  		my $arr = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(@$arr);
  	}
  	
  	if ($params{my_methods} and eval { require Sub::Name })
  	{
  		for my $key (keys %{$params{my_methods}})
  		{
  			Sub::Name::subname(
  				sprintf("%s::my_%s", $self->qualified_name, $key),
  				$params{my_methods}{$key},
  			);
  		}
  	}
  	
  	return $self;
  }
  
  sub DESTROY
  {
  	my $self = shift;
  	delete( $ALL_TYPES{$self->{uniq}} );
  	package # no index
  		Moo::HandleMoose;
  	delete( $Moo::HandleMoose::TYPE_MAP{$self} );
  	return;
  }
  
  sub _clone
  {
  	my $self = shift;
  	my %opts;
  	$opts{$_} = $self->{$_} for qw< name display_name message >;
  	$self->create_child_type(%opts);
  }
  
  our $DD;
  sub _dd
  {
  	@_ = $_ unless @_;
  	my ($value) = @_;
  	
  	goto $DD if ref($DD) eq q(CODE);
  	
  	require B;
  	
  	!defined $value ? 'Undef' :
  	!ref $value     ? sprintf('Value %s', B::perlstring($value)) :
  	do {
  		my $N = 0 + (defined($DD) ? $DD : 72);
  		require Data::Dumper;
  		local $Data::Dumper::Indent   = 0;
  		local $Data::Dumper::Useqq    = 1;
  		local $Data::Dumper::Terse    = 1;
  		local $Data::Dumper::Sortkeys = 1;
  		local $Data::Dumper::Maxdepth = 2;
  		my $str = Data::Dumper::Dumper($value);
  		$str = substr($str, 0, $N - 12).'...'.substr($str, -1, 1)
  			if length($str) >= $N;
  		"Reference $str";
  	}
  }
  
  sub _loose_to_TypeTiny
  {
  	map +(
  		ref($_)
  			? Types::TypeTiny::to_TypeTiny($_)
  			: do { require Type::Utils; Type::Utils::dwim_type($_) }
  	), @_;
  }
  
  sub name                     { $_[0]{name} }
  sub display_name             { $_[0]{display_name}   ||= $_[0]->_build_display_name }
  sub parent                   { $_[0]{parent} }
  sub constraint               { $_[0]{constraint}     ||= $_[0]->_build_constraint }
  sub compiled_check           { $_[0]{compiled_type_constraint} ||= $_[0]->_build_compiled_check }
  sub coercion                 { $_[0]{coercion}       ||= $_[0]->_build_coercion }
  sub message                  { $_[0]{message} }
  sub library                  { $_[0]{library} }
  sub inlined                  { $_[0]{inlined} }
  sub constraint_generator     { $_[0]{constraint_generator} }
  sub inline_generator         { $_[0]{inline_generator} }
  sub name_generator           { $_[0]{name_generator} ||= $_[0]->_build_name_generator }
  sub coercion_generator       { $_[0]{coercion_generator} }
  sub parameters               { $_[0]{parameters} }
  sub moose_type               { $_[0]{moose_type}     ||= $_[0]->_build_moose_type }
  sub mouse_type               { $_[0]{mouse_type}     ||= $_[0]->_build_mouse_type }
  sub deep_explanation         { $_[0]{deep_explanation} }
  sub my_methods               { $_[0]{my_methods}     ||= $_[0]->_build_my_methods }
  
  sub has_parent               { exists $_[0]{parent} }
  sub has_library              { exists $_[0]{library} }
  sub has_coercion             {        $_[0]{coercion} and !!@{ $_[0]{coercion}->type_coercion_map } }
  sub has_inlined              { exists $_[0]{inlined} }
  sub has_constraint_generator { exists $_[0]{constraint_generator} }
  sub has_inline_generator     { exists $_[0]{inline_generator} }
  sub has_coercion_generator   { exists $_[0]{coercion_generator} }
  sub has_parameters           { exists $_[0]{parameters} }
  sub has_message              { defined $_[0]{message} }
  sub has_deep_explanation     { exists $_[0]{deep_explanation} }
  
  sub _default_message         { $_[0]{_default_message} ||= $_[0]->_build_default_message }
  
  sub _assert_coercion
  {
  	my $self = shift;
  	_croak "No coercion for this type constraint"
  		unless $self->has_coercion && @{$self->coercion->type_coercion_map};
  	return $self->coercion;
  }
  
  my $null_constraint = sub { !!1 };
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub _build_constraint
  {
  	return $null_constraint;
  }
  
  sub _is_null_constraint
  {
  	shift->constraint == $null_constraint;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion;
  	my $self = shift;
  	my %opts = (type_constraint => $self);
  	$opts{display_name} = "to_$self" unless $self->is_anon;
  	return "Type::Coercion"->new(%opts);
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	return sub { sprintf '%s did not pass type constraint', _dd($_[0]) } if "$self" eq "__ANON__";
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s"', _dd($_[0]), $name };
  }
  
  sub _build_name_generator
  {
  	my $self = shift;
  	return sub {
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], @a);
  	};
  }
  
  sub _build_compiled_check
  {
  	my $self = shift;
  	
  	if ($self->_is_null_constraint and $self->has_parent)
  	{
  		return $self->parent->compiled_check;
  	}
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', $self->inline_check('$_[0]')),
  		description => sprintf("compiled check '%s'", $self),
  	) if $self->can_be_inlined;
  	
  	my @constraints;
  	push @constraints, $self->parent->compiled_check if $self->has_parent;
  	push @constraints, $self->constraint if !$self->_is_null_constraint;
  	return $null_constraint unless @constraints;
  	
  	return sub ($)
  	{
  		local $_ = $_[0];
  		for my $c (@constraints)
  		{
  			return unless $c->(@_);
  		}
  		return !!1;
  	};
  }
  
  sub equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if refaddr($self) == refaddr($other);
  	
  	return !!1 if $self->has_parent  && $self->_is_null_constraint  && $self->parent==$other;
  	return !!1 if $other->has_parent && $other->_is_null_constraint && $other->parent==$self;
  	
  	return !!1 if refaddr($self->compiled_check) == refaddr($other->compiled_check);
  	
  	return $self->qualified_name eq $other->qualified_name
  		if $self->has_library && !$self->is_anon && $other->has_library && !$other->is_anon;
  	
  	return $self->inline_check('$x') eq $other->inline_check('$x')
  		if $self->can_be_inlined && $other->can_be_inlined;
  	
  	return;
  }
  
  sub is_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->equals($other) or $self->parent->is_subtype_of($other);
  }
  
  sub is_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_subtype_of($self);
  }
  
  sub is_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->equals($other) or $self->is_subtype_of($other);
  }
  
  sub strictly_equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	$self->{uniq} == $other->{uniq};
  }
  
  sub is_strictly_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->strictly_equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->strictly_equals($other) or $self->parent->is_strictly_subtype_of($other);
  }
  
  sub is_strictly_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_strictly_subtype_of($self);
  }
  
  sub is_strictly_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->strictly_equals($other) or $self->is_strictly_subtype_of($other);
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	(exists $self->{library} and $self->name ne "__ANON__")
  		? "$self->{library}::$self->{name}"
  		: $self->{name};
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub parents
  {
  	my $self = shift;
  	return unless $self->has_parent;
  	return ($self->parent, $self->parent->parents);
  }
  
  sub find_parent
  {
  	my $self = shift;
  	my ($test) = @_;
  	
  	local ($_, $.);
  	my $type  = $self;
  	my $count = 0;
  	while ($type)
  	{
  		if ($test->($_=$type, $.=$count))
  		{
  			return wantarray ? ($type, $count) : $type;
  		}
  		else
  		{
  			$type = $type->parent;
  			$count++;
  		}
  	}
  	
  	return;
  }
  
  sub check
  {
  	my $self = shift;
  	($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  }
  
  sub _strict_check
  {
  	my $self = shift;
  	local $_ = $_[0];
  
  	my @constraints =
  		reverse
  		map  { $_->constraint }
  		grep { not $_->_is_null_constraint }
  		($self, $self->parents);
  	
  	for my $c (@constraints)
  	{
  		return unless $c->(@_);
  	}
  	
  	return !!1;
  }
  
  sub get_message
  {
  	my $self = shift;
  	local $_ = $_[0];
  	$self->has_message
  		? $self->message->(@_)
  		: $self->_default_message->(@_);
  }
  
  sub validate
  {
  	my $self = shift;
  	
  	return undef if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	return $self->get_message(@_);
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	if ($self->has_parent)
  	{
  		my $parent = $self->parent->validate_explain($value, $varname);
  		return [ sprintf('"%s" is a subtype of "%s"', $self, $self->parent), @$parent ] if $parent;
  	}
  	
  	my $message = sprintf(
  		'%s%s',
  		$self->get_message($value),
  		$varname eq q{$_} ? '' : sprintf(' (in %s)', $varname),
  	);
  	
  	if ($self->is_parameterized and $self->parent->has_deep_explanation)
  	{
  		my $deep = $self->parent->deep_explanation->($self, $value, $varname);
  		return [ $message, @$deep ] if $deep;
  	}
  	
  	return [ $message, sprintf('"%s" is defined as: %s', $self, $self->_perlcode) ];
  }
  
  my $b;
  sub _perlcode
  {
  	my $self = shift;
  	
  	return $self->inline_check('$_')
  		if $self->can_be_inlined;
  	
  	$b ||= do {
  		require B::Deparse;
  		my $tmp = "B::Deparse"->new;
  		$tmp->ambient_pragmas(strict => "all", warnings => "all") if $tmp->can('ambient_pragmas');
  		$tmp;
  	};
  	
  	my $code = $b->coderef2text($self->constraint);
  	$code =~ s/\s+/ /g;
  	return "sub $code";
  }
  
  sub assert_valid
  {
  	my $self = shift;
  	
  	return !!1 if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub assert_return
  {
  	my $self = shift;
  	
  	return $_[0] if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	return $self->parent->can_be_inlined
  		if $self->has_parent && $self->_is_null_constraint;
  	return !!1
  		if !$self->has_parent && $self->_is_null_constraint;
  	return $self->has_inlined;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	_croak 'Cannot inline type constraint check for "%s"', $self
  		unless $self->can_be_inlined;
  	
  	return $self->parent->inline_check(@_)
  		if $self->has_parent && $self->_is_null_constraint;
  	return '(!!1)'
  		if !$self->has_parent && $self->_is_null_constraint;
  	
  	local $_ = $_[0];
  	my @r = $self->inlined->($self, @_);
  	if (@r and not defined $r[0])
  	{
  		_croak 'Inlining type constraint check for "%s" returned undef!', $self
  			unless $self->has_parent;
  		$r[0] = $self->parent->inline_check(@_);
  	}
  	my $r = join " && " => map { /[;{}]/ ? "do { $_ }" : "($_)" } @r;
  	return @r==1 ? $r : "($r)";
  }
  
  sub inline_assert
  {
  	require B;
  	my $self = shift;
  	my $varname = $_[0];
  	my $code = sprintf(
  		q[do { no warnings "void"; %s ? %s : Type::Tiny::_failed_check(%d, %s, %s) };],
  		$self->inline_check(@_),
  		$varname,
  		$self->{uniq},
  		B::perlstring("$self"),
  		$varname,
  	);
  	return $code;
  }
  
  sub _failed_check
  {
  	require Error::TypeTiny::Assertion;
  	
  	my ($self, $name, $value, %attrs) = @_;
  	$self = $ALL_TYPES{$self} unless ref $self;
  	
  	my $exception_class = delete($attrs{exception_class}) || "Error::TypeTiny::Assertion";
  	
  	if ($self)
  	{
  		$exception_class->throw(
  			message => $self->get_message($value),
  			type    => $self,
  			value   => $value,
  			%attrs,
  		);
  	}
  	else
  	{
  		$exception_class->throw(
  			message => sprintf('%s did not pass type constraint "%s"', _dd($value), $name),
  			value   => $value,
  			%attrs,
  		);
  	}
  }
  
  sub coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->coerce(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->assert_coerce(@_);
  }
  
  sub is_parameterizable
  {
  	shift->has_constraint_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  my %param_cache;
  sub parameterize
  {
  	my $self = shift;
  	
  	$self->is_parameterizable
  		or @_ ? _croak("Type '%s' does not accept parameters", "$self") : return($self);
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  
  	# Generate a key for caching parameterized type constraints,
  	# but only if all the parameters are strings or type constraints.
  	my $key;
  	if ( not grep(ref($_) && !Types::TypeTiny::TypeTiny->check($_), @_) )
  	{
  		require B;
  		$key = join ":", map(Types::TypeTiny::TypeTiny->check($_) ? $_->{uniq} : B::perlstring($_), $self, @_);
  	}
  	
  	return $param_cache{$key} if defined $key && defined $param_cache{$key};
  	
  	local $Type::Tiny::parameterize_type = $self;
  	local $_ = $_[0];
  	my $P;
  	
  	my ($constraint, $compiled) = $self->constraint_generator->(@_);
  	
  	if (Types::TypeTiny::TypeTiny->check($constraint))
  	{
  		$P = $constraint;
  	}
  	else
  	{
  		my %options = (
  			constraint   => $constraint,
  			display_name => $self->name_generator->($self, @_),
  			parameters   => [@_],
  		);
  		$options{compiled_type_constraint} = $compiled
  			if $compiled;
  		$options{inlined} = $self->inline_generator->(@_)
  			if $self->has_inline_generator;
  		exists $options{$_} && !defined $options{$_} && delete $options{$_}
  			for keys %options;
  		
  		$P = $self->create_child_type(%options);
  		
  		my $coercion;
  		$coercion = $self->coercion_generator->($self, $P, @_)
  			if $self->has_coercion_generator;
  		$P->coercion->add_type_coercions( @{$coercion->type_coercion_map} )
  			if $coercion;
  	}
  	
  	if (defined $key)
  	{
  		$param_cache{$key} = $P;
  		weaken($param_cache{$key});
  	}
  	
  	$P->coercion->freeze;
  	
  	return $P;
  }
  
  sub child_type_class
  {
  	__PACKAGE__;
  }
  
  sub create_child_type
  {
  	my $self = shift;
  	return $self->child_type_class->new(parent => $self, @_);
  }
  
  sub complementary_type
  {
  	my $self = shift;
  	my $r    = ($self->{complementary_type} ||= $self->_build_complementary_type);
  	weaken($self->{complementary_type}) unless isweak($self->{complementary_type});
  	return $r;
  }
  
  sub _build_complementary_type
  {
  	my $self = shift;
  	my %opts = (
  		constraint   => sub { not $self->check($_) },
  		display_name => sprintf("~%s", $self),
  	);
  	$opts{display_name} =~ s/^\~{2}//;
  	$opts{inlined} = sub { shift; "not(".$self->inline_check(@_).")" }
  		if $self->can_be_inlined;
  	return "Type::Tiny"->new(%opts);
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	require Moose::Meta::TypeConstraint;
  	return "Moose::Meta::TypeConstraint"->new(%opts);
  }
  
  sub _build_moose_type
  {
  	my $self = shift;
  	
  	my $r;
  	if ($self->{_is_core})
  	{
  		require Moose::Util::TypeConstraints;
  		$r = Moose::Util::TypeConstraints::find_type_constraint($self->name);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		Scalar::Util::weaken($r->{"Types::TypeTiny::to_TypeTiny"});
  	}
  	else
  	{
  		my $wrapped_inlined = sub {
  			shift;
  			$self->inline_check(@_);
  		};
  		
  		my %opts;
  		$opts{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  		$opts{parent}     = $self->parent->moose_type if $self->has_parent;
  		$opts{constraint} = $self->constraint         unless $self->_is_null_constraint;
  		$opts{message}    = $self->message            if $self->has_message;
  		$opts{inlined}    = $wrapped_inlined          if $self->has_inlined;
  		
  		$r = $self->_instantiate_moose_type(%opts);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		$self->{moose_type} = $r;  # prevent recursion
  		$r->coercion($self->coercion->moose_coercion) if $self->has_coercion;
  	}
  		
  	return $r;
  }
  
  sub _build_mouse_type
  {
  	my $self = shift;
  	
  	my %options;
  	$options{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  	$options{parent}     = $self->parent->mouse_type if $self->has_parent;
  	$options{constraint} = $self->constraint         unless $self->_is_null_constraint;
  	$options{message}    = $self->message            if $self->has_message;
  		
  	require Mouse::Meta::TypeConstraint;
  	my $r = "Mouse::Meta::TypeConstraint"->new(%options);
  	
  	$self->{mouse_type} = $r;  # prevent recursion
  	$r->_add_type_coercions(
  		$self->coercion->freeze->_codelike_type_coercion_map('mouse_type')
  	) if $self->has_coercion;
  	
  	return $r;
  }
  
  sub _process_coercion_list
  {
  	my $self = shift;
  	
  	my @pairs;
  	while (@_)
  	{
  		my $next = shift;
  		if (blessed($next) and $next->isa('Type::Coercion') and $next->is_parameterized)
  		{
  			push @pairs => (
  				@{ $next->_reparameterize($self)->type_coercion_map }
  			);
  		}
  		elsif (blessed($next) and $next->can('type_coercion_map'))
  		{
  			push @pairs => (
  				@{ $next->type_coercion_map },
  			);
  		}
  		elsif (ref($next) eq q(ARRAY))
  		{
  			unshift @_, @$next;
  		}
  		else
  		{
  			push @pairs => (
  				Types::TypeTiny::to_TypeTiny($next),
  				shift,
  			);
  		}
  	}
  	
  	return @pairs;
  }
  
  sub plus_coercions
  {
  	my $self = shift;
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		$self->_process_coercion_list(@_),
  		@{$self->coercion->type_coercion_map},
  	);
  	$new->coercion->freeze;
  	return $new;
  }
  
  sub plus_fallback_coercions
  {
  	my $self = shift;
  	
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@{$self->coercion->type_coercion_map},
  		$self->_process_coercion_list(@_),
  	);
  	$new->coercion->freeze;
  	return $new;
  }
  
  sub minus_coercions
  {
  	my $self = shift;
  	
  	my $new = $self->_clone;
  	my @not = grep Types::TypeTiny::TypeTiny->check($_), $self->_process_coercion_list($new, @_);
  	
  	my @keep;
  	my $c = $self->coercion->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		my $keep_this = 1;
  		NOT: for my $n (@not)
  		{
  			if ($c->[$i] == $n)
  			{
  				$keep_this = 0;
  				last NOT;
  			}
  		}
  		
  		push @keep, $c->[$i], $c->[$i+1] if $keep_this;
  	}
  	
  	$new->coercion->add_type_coercions(@keep);
  	$new->coercion->freeze;
  	return $new;
  }
  
  sub no_coercions
  {
  	my $new = shift->_clone;
  	$new->coercion->freeze;
  	$new;
  }
  
  sub coercibles
  {
  	my $self = shift;
  	$self->has_coercion ? $self->coercion->_source_type_union : $self;
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and ref($self) and $_[0] =~ /^(?:Class::MOP|MooseX?::Meta)::(.+)$/)
  	{
  		my $meta = $1;
  		
  		return !!1                             if $meta eq 'TypeConstraint';
  		return $self->is_parameterized         if $meta eq 'TypeConstraint::Parameterized';
  		return $self->is_parameterizable       if $meta eq 'TypeConstraint::Parameterizable';
  		return $self->isa('Type::Tiny::Union') if $meta eq 'TypeConstraint::Union';
  		
  		my $inflate = $self->moose_type;
  		return $inflate->isa(@_);
  	}
  	
  	if ($INC{"Mouse.pm"} and ref($self) and $_[0] eq 'Mouse::Meta::TypeConstraint')
  	{
  		return !!1;
  	}
  	
  	$self->SUPER::isa(@_);
  }
  
  sub _build_my_methods
  {
  	return {};
  }
  
  sub _lookup_my_method
  {
  	my $self = shift;
  	my ($name) = @_;
  	
  	if ($self->my_methods->{$name})
  	{
  		return $self->my_methods->{$name};
  	}
  	
  	if ($self->has_parent)
  	{
  		return $self->parent->_lookup_my_method(@_);
  	}
  	
  	return;
  }
  
  sub can
  {
  	my $self = shift;
  	
  	return !!0 if $_[0] eq 'type_parameter' && blessed($_[0]) && $_[0]->has_parameters;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if (ref($self))
  	{
  		if ($INC{"Moose.pm"})
  		{
  			my $method = $self->moose_type->can(@_);
  			return sub { shift->moose_type->$method(@_) } if $method;
  		}
  		if ($_[0] =~ /\Amy_(.+)\z/)
  		{
  			my $method = $self->_lookup_my_method($1);
  			return $method if $method;
  		}
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if (ref($self))
  	{
  		if ($INC{"Moose.pm"})
  		{
  			my $method = $self->moose_type->can($m);
  			return $self->moose_type->$method(@_) if $method;
  		}
  		if ($m =~ /\Amy_(.+)\z/)
  		{
  			my $method = $self->_lookup_my_method($1);
  			return $self->$method(@_) if $method;
  		}
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  sub DOES
  {
  	my $self = shift;
  	
  	return !!1 if  ref($self) && $_[0] =~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;
  	return !!1 if !ref($self) && $_[0] eq 'Type::API::Constraint::Constructor';
  	
  	"UNIVERSAL"->can("DOES") ? $self->SUPER::DOES(@_) : $self->isa(@_);
  }
  
  sub _has_xsub
  {
  	require B;
  	!!B::svref_2object( shift->compiled_check )->XSUB;
  }
  
  sub of                         { shift->parameterize(@_) }
  sub where                      { shift->create_child_type(constraint => @_) }
  
  # fill out Moose-compatible API
  sub inline_environment         { +{} }
  sub _inline_check              { shift->inline_check(@_) }
  sub _compiled_type_constraint  { shift->compiled_check(@_) }
  sub meta                       { _croak("Not really a Moose::Meta::TypeConstraint. Sorry!") }
  sub compile_type_constraint    { shift->compiled_check }
  sub _actually_compile_type_constraint   { shift->_build_compiled_check }
  sub hand_optimized_type_constraint      { shift->{hand_optimized_type_constraint} }
  sub has_hand_optimized_type_constraint  { exists(shift->{hand_optimized_type_constraint}) }
  sub type_parameter             { (shift->parameters || [])->[0] }
  
  # some stuff for Mouse-compatible API
  sub __is_parameterized         { shift->is_parameterized(@_) }
  sub _add_type_coercions        { shift->coercion->add_type_coercions(@_) };
  sub _as_string                 { shift->qualified_name(@_) }
  sub _compiled_type_coercion    { shift->coercion->compiled_coercion(@_) };
  sub _identity                  { refaddr(shift) };
  sub _unite                     { require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@_) };
  
  # Hooks for Type::Tie
  sub TIESCALAR  { require Type::Tie; unshift @_, 'Type::Tie::SCALAR'; goto \&Type::Tie::SCALAR::TIESCALAR };
  sub TIEARRAY   { require Type::Tie; unshift @_, 'Type::Tie::ARRAY';  goto \&Type::Tie::ARRAY::TIEARRAY };
  sub TIEHASH    { require Type::Tie; unshift @_, 'Type::Tie::HASH';   goto \&Type::Tie::HASH::TIEHASH };
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX MouseX MooX Moose-compat invocant
  
  =head1 NAME
  
  Type::Tiny - tiny, yet Moo(se)-compatible type constraint
  
  =head1 SYNOPSIS
  
     use Scalar::Util qw(looks_like_number);
     use Type::Tiny;
     
     my $NUM = "Type::Tiny"->new(
        name       => "Number",
        constraint => sub { looks_like_number($_) },
        message    => sub { "$_ ain't a number" },
     );
     
     package Ermintrude {
        use Moo;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Bullwinkle {
        use Moose;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Maisy {
        use Mouse;
        has favourite_number => (is => "ro", isa => $NUM);
     }
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> is a tiny class for creating Moose-like type constraint
  objects which are compatible with Moo, Moose and Mouse.
  
  Maybe now we won't need to have separate MooseX, MouseX and MooX versions
  of everything? We can but hope...
  
  This documents the internals of L<Type::Tiny>. L<Type::Tiny::Manual> is
  a better starting place if you're new.
  
  =head2 Constructor
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =back
  
  =head2 Attributes
  
  Attributes are named values that may be passed to the constructor. For
  each attribute, there is a corresponding reader method. For example:
  
     my $type = Type::Tiny->new( name => "Foo" );
     print $type->name, "\n";   # says "Foo"
  
  =head3 Important attributes
  
  These are the attributes you are likely to be most interested in
  providing when creating your own type constraints, and most interested
  in reading when dealing with type constraint objects.
  
  =over
  
  =item C<< constraint >>
  
  Coderef to validate a value (C<< $_ >>) against the type constraint. The
  coderef will not be called unless the value is known to pass any parent
  type constraint (see C<parent> below).
  
  Defaults to C<< sub { 1 } >> - i.e. a coderef that passes all values.
  
  =item C<< parent >>
  
  Optional attribute; parent type constraint. For example, an "Integer"
  type constraint might have a parent "Number".
  
  If provided, must be a Type::Tiny object.
  
  =item C<< inlined >>
  
  A coderef which returns a string of Perl code suitable for inlining this
  type. Optional.
  
  If C<constraint> (above) is a coderef generated via L<Sub::Quote>, then
  Type::Tiny I<may> be able to automatically generate C<inlined> for you.
  
  =item C<< name >>
  
  The name of the type constraint. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous type constraint.
  
  =item C<< display_name >>
  
  A name to display for the type constraint when stringified. These don't
  have to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<< library >>
  
  The package name of the type library this type is associated with.
  Optional. Informational only: setting this attribute does not install
  the type into the package.
  
  =item C<< message >>
  
  Coderef that returns an error message when C<< $_ >> does not validate
  against the type constraint. Optional (there's a vaguely sensible default.)
  
  =item C<< coercion >>
  
  A L<Type::Coercion> object associated with this type.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built coercion object.
  
  You may pass C<< coercion => 1 >> to the constructor to inherit coercions
  from the constraint's parent. (This requires the parent constraint to have
  a coercion.)
  
  =item C<< my_methods >>
  
  Experimenal hashref of additional methods that can be called on the type
  constraint object.
  
  =back
  
  =head3 Attributes related to parameterizable and parameterized types
  
  The following additional attributes are used for parameterizable (e.g.
  C<ArrayRef>) and parameterized (e.g. C<< ArrayRef[Int] >>) type
  constraints. Unlike Moose, these aren't handled by separate subclasses.
  
  =over
  
  =item C<< constraint_generator >>
  
  Coderef that generates a new constraint coderef based on parameters.
  Alternatively, the constraint generator can return a fully-formed
  Type::Tiny object, in which case the C<name_generator>, C<inline_generator>,
  and C<coercion_generator> attributes documented below are ignored.
  
  Optional; providing a generator makes this type into a parameterizable
  type constraint.
  
  =item C<< name_generator >>
  
  A coderef which generates a new display_name based on parameters.
  Optional; the default is reasonable.
  
  =item C<< inline_generator >>
  
  A coderef which generates a new inlining coderef based on parameters.
  
  =item C<< coercion_generator >>
  
  A coderef which generates a new L<Type::Coercion> object based on parameters.
  
  =item C<< deep_explanation >>
  
  This API is not finalized. Coderef used by L<Error::TypeTiny::Assertion> to
  peek inside parameterized types and figure out why a value doesn't pass the
  constraint.
  
  =item C<< parameters >>
  
  In parameterized types, returns an arrayref of the parameters.
  
  =back
  
  =head3 Lazy generated attributes
  
  The following attributes should not be usually passed to the constructor;
  unless you're doing something especially unusual, you should rely on the
  default lazily-built return values.
  
  =over
  
  =item C<< compiled_check >>
  
  Coderef to validate a value (C<< $_[0] >>) against the type constraint.
  This coderef is expected to also handle all validation for the parent
  type constraints.
  
  =item C<< complementary_type >>
  
  A complementary type for this type. For example, the complementary type
  for an integer type would be all things that are not integers, including
  floating point numbers, but also alphabetic strings, arrayrefs, filehandles,
  etc.
  
  =item C<< moose_type >>, C<< mouse_type >>
  
  Objects equivalent to this type constraint, but as a
  L<Moose::Meta::TypeConstraint> or L<Mouse::Meta::TypeConstraint>.
  
  It should rarely be necessary to obtain a L<Moose::Meta::TypeConstraint>
  object from L<Type::Tiny> because the L<Type::Tiny> object itself should
  be usable pretty much anywhere a L<Moose::Meta::TypeConstraint> is expected.
  
  =back
  
  =head2 Methods
  
  =head3 Predicate methods
  
  These methods return booleans indicating information about the type
  constraint. They are each tightly associated with a particular attribute.
  (See L</"Attributes">.)
  
  =over
  
  =item C<has_parent>, C<has_library>, C<has_inlined>, C<has_constraint_generator>, C<has_inline_generator>, C<has_coercion_generator>, C<has_parameters>, C<has_message>, C<has_deep_explanation>
  
  Simple Moose-style predicate methods indicating the presence or
  absence of an attribute.
  
  =item C<has_coercion>
  
  Predicate method with a little extra DWIM. Returns false if the coercion is
  a no-op.
  
  =item C<< is_anon >>
  
  Returns true iff the type constraint does not have a C<name>.
  
  =item C<< is_parameterized >>, C<< is_parameterizable >>
  
  Indicates whether a type has been parameterized (e.g. C<< ArrayRef[Int] >>)
  or could potentially be (e.g. C<< ArrayRef >>).
  
  =back
  
  =head3 Validation and coercion
  
  The following methods are used for coercing and validating values
  against a type constraint:
  
  =over
  
  =item C<< check($value) >>
  
  Returns true iff the value passes the type constraint.
  
  =item C<< validate($value) >>
  
  Returns the error message for the value; returns an explicit undef if the
  value passes the type constraint.
  
  =item C<< assert_valid($value) >>
  
  Like C<< check($value) >> but dies if the value does not pass the type
  constraint.
  
  Yes, that's three very similar methods. Blame L<Moose::Meta::TypeConstraint>
  whose API I'm attempting to emulate. :-)
  
  =item C<< assert_return($value) >>
  
  Like C<< assert_valid($value) >> but returns the value if it passes the type
  constraint.
  
  This seems a more useful behaviour than C<< assert_valid($value) >>. I would
  have just changed C<< assert_valid($value) >> to do this, except that there
  are edge cases where it could break Moose compatibility.
  
  =item C<< get_message($value) >>
  
  Returns the error message for the value; even if the value passes the type
  constraint.
  
  =item C<< validate_explain($value, $varname) >>
  
  Like C<validate> but instead of a string error message, returns an arrayref
  of strings explaining the reasoning why the value does not meet the type
  constraint, examining parent types, etc.
  
  The C<< $varname >> is an optional string like C<< '$foo' >> indicating the
  name of the variable being checked.
  
  =item C<< coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type.
  
  =item C<< assert_coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type. Throws an exception if this is
  not possible.
  
  =back
  
  =head3 Child type constraint creation and parameterization
  
  These methods generate new type constraint objects that inherit from the
  constraint they are called upon:
  
  =over
  
  =item C<< create_child_type(%attributes) >>
  
  Construct a new Type::Tiny object with this object as its parent.
  
  =item C<< where($coderef) >>
  
  Shortcut for creating an anonymous child type constraint. Use it like
  C<< HashRef->where(sub { exists($_->{name}) }) >>. That said, you can
  get a similar result using overloaded C<< & >>:
  
     HashRef & sub { exists($_->{name}) }
  
  =item C<< child_type_class >>
  
  The class that create_child_type will construct by default.
  
  =item C<< parameterize(@parameters) >>
  
  Creates a new parameterized type; throws an exception if called on a
  non-parameterizable type.
  
  =item C<< of(@parameters) >>
  
  A cute alias for C<parameterize>. Use it like C<< ArrayRef->of(Int) >>.
  
  =item C<< plus_coercions($type1, $code1, ...) >>
  
  Shorthand for creating a new child type constraint with the same coercions
  as this one, but then adding some extra coercions (at a higher priority than
  the existing ones).
  
  =item C<< plus_fallback_coercions($type1, $code1, ...) >>
  
  Like C<plus_coercions>, but added at a lower priority.
  
  =item C<< minus_coercions($type1, ...) >>
  
  Shorthand for creating a new child type constraint with fewer type coercions.
  
  =item C<< no_coercions >>
  
  Shorthand for creating a new child type constraint with no coercions at all.
  
  =back
  
  =head3 Type relationship introspection methods
  
  These methods allow you to determine a type constraint's relationship to
  other type constraints in an organised hierarchy:
  
  =over
  
  =item C<< equals($other) >>, C<< is_subtype_of($other) >>, C<< is_supertype_of($other) >>, C<< is_a_type_of($other) >>
  
  Compare two types. See L<Moose::Meta::TypeConstraint> for what these all mean.
  (OK, Moose doesn't define C<is_supertype_of>, but you get the idea, right?)
  
  Note that these have a slightly DWIM side to them. If you create two
  L<Type::Tiny::Class> objects which test the same class, they're considered
  equal. And:
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_subtype_of( $subtype_of_Num );  # true
  
  =item C<< strictly_equals($other) >>, C<< is_strictly_subtype_of($other) >>, C<< is_strictly_supertype_of($other) >>, C<< is_strictly_a_type_of($other) >>
  
  Stricter versions of the type comparison functions. These only care about
  explicit inheritance via C<parent>.
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_strictly_subtype_of( $subtype_of_Num );  # false
  
  =item C<< parents >>
  
  Returns a list of all this type constraint's ancestor constraints. For
  example, if called on the C<Str> type constraint would return the list
  C<< (Value, Defined, Item, Any) >>.
  
  B<< Due to a historical misunderstanding, this differs from the Moose
  implementation of the C<parents> method. In Moose, C<parents> only returns the
  immediate parent type constraints, and because type constraints only have
  one immediate parent, this is effectively an alias for C<parent>. The
  extension module L<MooseX::Meta::TypeConstraint::Intersection> is the only
  place where multiple type constraints are returned; and they are returned
  as an arrayref in violation of the base class' documentation. I'm keeping
  my behaviour as it seems more useful. >>
  
  =item C<< find_parent($coderef) >>
  
  Loops through the parent type constraints I<< including the invocant
  itself >> and returns the nearest ancestor type constraint where the
  coderef evaluates to true. Within the coderef the ancestor currently
  being checked is C<< $_ >>. Returns undef if there is no match.
  
  In list context also returns the number of type constraints which had
  been looped through before the matching constraint was found.
  
  =item C<< coercibles >>
  
  Return a type constraint which is the union of type constraints that can be
  coerced to this one (including this one). If this type constraint has no
  coercions, returns itself.
  
  =item C<< type_parameter >>
  
  In parameterized type constraints, returns the first item on the list of
  parameters; otherwise returns undef. For example:
  
     ( ArrayRef[Int] )->type_parameter;    # returns Int
     ( ArrayRef[Int] )->parent;            # returns ArrayRef
  
  Note that parameterizable type constraints can perfectly legitimately take
  multiple parameters (several off the parameterizable type constraints in
  L<Types::Standard> do). This method only returns the first such parameter.
  L</"Attributes related to parameterizable and parameterized types">
  documents the C<parameters> attribute, which returns an arrayref of all
  the parameters.
  
  =back
  
  =head3 Inlining methods
  
  =for stopwords uated
  
  The following methods are used to generate strings of Perl code which
  may be pasted into stringy C<eval>uated subs to perform type checks:
  
  =over
  
  =item C<< can_be_inlined >>
  
  Returns boolean indicating if this type can be inlined.
  
  =item C<< inline_check($varname) >>
  
  Creates a type constraint check for a particular variable as a string of
  Perl code. For example:
  
     print( Types::Standard::Num->inline_check('$foo') );
  
  prints the following output:
  
     (!ref($foo) && Scalar::Util::looks_like_number($foo))
  
  For Moose-compat, there is an alias C<< _inline_check >> for this method.
  
  =item C<< inline_assert($varname) >>
  
  Much like C<inline_check> but outputs a statement of the form:
  
     die ... unless ...;
  
  Note that if this type has a custom error message, the inlined code will
  I<ignore> this custom message!!
  
  =back
  
  =head3 Other methods
  
  =over
  
  =item C<< qualified_name >>
  
  For non-anonymous type constraints that have a library, returns a qualified
  C<< "MyLib::MyType" >> sort of name. Otherwise, returns the same as C<name>.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeConstraint.
  
  If Mouse is loaded, then C<isa> mocks Mouse::Meta::TypeConstraint.
  
  =item C<< DOES($role) >>
  
  Overridden to advertise support for various roles.
  
  See also L<Type::API::Constraint>, etc.
  
  =item C<< TIESCALAR >>, C<< TIEARRAY >>, C<< TIEHASH >>
  
  These are provided as hooks that wrap L<Type::Tie>. (Type::Tie is distributed
  separately, and can be used with non-Type::Tiny type constraints too.) They
  allow the following to work:
  
     use Types::Standard qw(Int);
     tie my @list, Int;
     push @list, 123, 456;   # ok
     push @list, "Hello";    # dies
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_constraint >>
  
  =item C<< hand_optimized_type_constraint >>
  
  =item C<< has_hand_optimized_type_constraint >>
  
  =item C<< inline_environment >>
  
  =item C<< meta >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to return the qualified name.
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<assert_return>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<check>.
  
  =item *
  
  The C<< == >> operator is overloaded to call C<equals>.
  
  =item *
  
  The C<< < >> and C<< > >> operators are overloaded to call C<is_subtype_of>
  and C<is_supertype_of>.
  
  =item *
  
  The C<< ~ >> operator is overloaded to call C<complementary_type>.
  
  =item *
  
  The C<< | >> operator is overloaded to build a union of two type constraints.
  See L<Type::Tiny::Union>.
  
  =item *
  
  The C<< & >> operator is overloaded to build the intersection of two type
  constraints. See L<Type::Tiny::Intersection>.
  
  =back
  
  Previous versions of Type::Tiny would overload the C<< + >> operator to
  call C<plus_coercions> or C<plus_fallback_coercions> as appropriate.
  Support for this was dropped after 0.040.
  
  =head2 Constants
  
  =over
  
  =item C<< Type::Tiny::SUPPORT_SMARTMATCH >>
  
  Indicates whether the smart match overload is supported on your
  version of Perl.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< $Type::Tiny::DD >>
  
  This undef by default but may be set to a coderef that Type::Tiny
  and related modules will use to dump data structures in things like
  error messages.
  
  Otherwise Type::Tiny uses it's own routine to dump data structures.
  C<< $DD >> may then be set to a number to limit the lengths of the
  dumps. (Default limit is 72.)
  
  This is a package variable (rather than get/set class methods) to allow
  for easy localization.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>, L<Type::API>.
  
  L<Type::Library>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>, L<Type::Tiny::Intersection>.
  
  L<Moose::Meta::TypeConstraint>,
  L<Mouse::Meta::TypeConstraint>.
  
  L<Type::Params>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 THANKS
  
  Thanks to Matt S Trout for advice on L<Moo> integration.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY

$fatpacked{"Type/Tiny/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_CLASS';
  package Type::Tiny::Class;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::Class::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Class::VERSION   = '1.000005';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	return $proto->class->new(@_) if blessed $proto; # DWIM
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Class type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Class type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Class type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply class name" unless exists $opts{class};
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $xsub = Type::Tiny::XS::get_coderef_for("InstanceOf[".$opts{class}."]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}
  	elsif (Type::Tiny::_USE_MOUSE)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("generate_isa_predicate_for");
  		$opts{compiled_type_constraint} = $maker->($opts{class}) if $maker;
  	}
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub class       { $_[0]{class} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self  = shift;
  	my $class = $self->class;
  	return sub { blessed($_) and $_->isa($class) };
  }
  
  sub _build_inlined
  {
  	my $self  = shift;
  	my $class = $self->class;
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $xsub = Type::Tiny::XS::get_subname_for("InstanceOf[$class]");
  		return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  	}
  	
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and $var->isa(q[$class])};
  	};
  }
  
  sub _build_default_message
  {
  	no warnings 'uninitialized';
  	my $self = shift;
  	my $c = $self->class;
  	return sub { sprintf '%s did not pass type constraint (not isa %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not isa %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Class;
  	return "Moose::Meta::TypeConstraint::Class"->new(%opts, class => $self->class);
  }
  
  sub plus_constructors
  {
  	my $self = shift;
  	
  	unless (@_)
  	{
  		require Types::Standard;
  		push @_, Types::Standard::HashRef(), "new";
  	}
  	
  	require B;
  	require Types::TypeTiny;
  	
  	my $class = B::perlstring($self->class);
  	
  	my @r;
  	while (@_)
  	{
  		my $source = shift;
  		Types::TypeTiny::TypeTiny->check($source)
  			or _croak "Expected type constraint; got $source";
  		
  		my $constructor = shift;
  		Types::TypeTiny::StringLike->check($constructor)
  			or _croak "Expected string; got $constructor";
  		
  		push @r, $source, sprintf('%s->%s($_)', $class, $constructor);
  	}
  	
  	return $self->plus_coercions(\@r);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self  = shift;
  	my $class = $self->class;
  	
  	# Some classes (I'm looking at you, Math::BigFloat) include a class in
  	# their @ISA to inherit methods, but then override isa() to return false,
  	# so that they don't appear to be a subclass.
  	#
  	# In these cases, we don't want to list the parent class as a parent
  	# type constraint.
  	#
  	my @isa = grep $class->isa($_), do { no strict "refs"; no warnings; @{"$class\::ISA"} };
  	
  	if (@isa == 0)
  	{
  		require Types::Standard;
  		return Types::Standard::Object();
  	}
  	
  	if (@isa == 1)
  	{
  		return ref($self)->new(class => $isa[0])
  	}
  	
  	require Type::Tiny::Intersection;
  	"Type::Tiny::Intersection"->new(
  		type_constraints => [ map ref($self)->new(class => $_), @isa ],
  	);
  }
  
  *__get_linear_isa_dfs = eval { require mro }
  	? \&mro::get_linear_isa
  	: sub {
  		no strict 'refs';
  		
  		my $classname = shift;
  		my @lin = ($classname);
  		my %stored;
  		
  		foreach my $parent (@{"$classname\::ISA"})
  		{
  			my $plin = __get_linear_isa_dfs($parent);
  			foreach (@$plin) {
  				next if exists $stored{$_};
  				push(@lin, $_);
  				$stored{$_} = 1;
  			}
  		}
  		
  		return \@lin;
  	};
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	my @isa = @{ __get_linear_isa_dfs(ref $value) };
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	require Type::Utils;
  	return [
  		sprintf('"%s" requires that the reference isa %s', $self, $self->class),
  		sprintf('The reference%s isa %s', $display_var, Type::Utils::english_list(@isa)),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Class - type constraints based on the "isa" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->isa("Some::Class") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Constructor
  
  =over
  
  =item C<new>
  
  When the constructor is called on an I<instance> of Type::Tiny::Class, it
  passes the call through to the constructor of the class for the constraint.
  So for example:
  
     my $type = Type::Tiny::Class->new(class => "Foo::Bar");
     my $obj  = $type->new(hello => "World");
     say ref($obj);   # prints "Foo::Bar"
  
  This little bit of DWIM was borrowed from L<MooseX::Types::TypeDecorator>,
  but Type::Tiny doesn't take the idea quite as far.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<class>
  
  The class for the constraint.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is automatically calculated, and cannot be passed to the constructor.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< plus_constructors($source, $method_name) >>
  
  Much like C<plus_coercions> but adds coercions that go via a constructor.
  (In fact, this is implemented as a wrapper for C<plus_coercions>.)
  
  Example:
  
     package MyApp::Minion;
     
     use Moose; extends "MyApp::Person";
     
     use Types::Standard qw( HashRef Str );
     use Type::Utils qw( class_type );
     
     my $Person = class_type({ class => "MyApp::Person" });
     
     has boss => (
        is     => "ro",
        isa    => $Person->plus_constructors(
           HashRef,     "new",
           Str,         "_new_from_name",
        ),
        coerce => 1,
     );
     
     package main;
     
     MyApp::Minion->new(
        ...,
        boss => "Bob",  ## via MyApp::Person->_new_from_name
     );
     
     MyApp::Minion->new(
        ...,
        boss => { name => "Bob" },  ## via MyApp::Person->new
     );
  
  Because coercing C<HashRef> via constructor is a common desire, if
  you call C<plus_constructors> with no arguments at all, this is the
  default.
  
     $classtype->plus_constructors(Types::Standard::HashRef, "new")
     $classtype->plus_constructors()  ## identical to above
  
  This is handy for Moose/Mouse/Moo-based classes.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Class>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_CLASS

$fatpacked{"Type/Tiny/Duck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_DUCK';
  package Type::Tiny::Duck;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Duck::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Duck::VERSION   = '1.000005';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Duck type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Duck type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Duck type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of methods" unless exists $opts{methods};
  	
  	$opts{methods} = [$opts{methods}] unless ref $opts{methods};
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $methods = join ",", sort(@{$opts{methods}});
  		my $xsub    = Type::Tiny::XS::get_coderef_for("HasMethods[$methods]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}
  	elsif (Type::Tiny::_USE_MOUSE)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("generate_can_predicate_for");
  		$opts{compiled_type_constraint} = $maker->($opts{methods}) if $maker;
  	}
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub methods     { $_[0]{methods} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self    = shift;
  	my @methods = @{$self->methods};
  	return sub { blessed($_[0]) and not grep(!$_[0]->can($_), @methods) };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my @methods = @{$self->methods};
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $methods = join ",", sort(@{$self->methods});
  		my $xsub    = Type::Tiny::XS::get_subname_for("HasMethods[$methods]");
  		return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  	}
  	
  	sub {
  		my $var = $_[1];
  		local $" = q{ };
  		# If $var is $_ or $_->{foo} or $foo{$_} or somesuch, then we
  		# can't use it within the grep expression, so we need to save
  		# it into a temporary variable ($tmp).
  		($var =~ /\$_/)
  			? qq{ Scalar::Util::blessed($var) and not do { my \$tmp = $var; grep(!\$tmp->can(\$_), qw/@methods/) } }
  			: qq{ Scalar::Util::blessed($var) and not grep(!$var->can(\$_), qw/@methods/) };
  	};
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	require Moose::Meta::TypeConstraint::DuckType;
  	return "Moose::Meta::TypeConstraint::DuckType"->new(%opts, methods => $self->methods);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the reference can %s',
  			$self,
  			Type::Utils::english_list(map qq["$_"], @{$self->methods}),
  		),
  		map  sprintf('The reference cannot "%s"', $_),
  		grep !$value->can($_),
  		@{$self->methods}
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Duck - type constraints based on the "can" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->can("method") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<methods>
  
  An arrayref of method names.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::DuckType>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_DUCK

$fatpacked{"Type/Tiny/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ENUM';
  package Type::Tiny::Enum;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Enum::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Enum::VERSION   = '1.000005';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => 'values';
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new
  {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Enum type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Enum type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Enum type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of values" unless exists $opts{values};
  	
  	my %tmp =
  		map { $_ => 1 }
  		@{ ref $opts{values} eq "ARRAY" ? $opts{values} : [$opts{values}] };
  	$opts{values} = [sort keys %tmp];
  	
  	if (Type::Tiny::_USE_XS and not grep /[^-\w]/, @{$opts{values}})
  	{
  		my $enum = join ",", @{$opts{values}};
  		my $xsub = Type::Tiny::XS::get_coderef_for("Enum[$enum]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub values      { $_[0]{values} }
  sub constraint  { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	sprintf("Enum[%s]", join q[,], @$self);
  }
  
  sub _build_constraint
  {
  	my $self = shift;
  	
  	my $regexp = join "|", map quotemeta, @$self;
  	return sub { defined and m{\A(?:$regexp)\z} };
  }
  
  sub can_be_inlined
  {
  	!!1;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $enum = join ",", @{$self->values};
  		my $xsub = Type::Tiny::XS::get_subname_for("Enum[$enum]");
  		return "$xsub\($_[0]\)" if $xsub;
  	}
  	
  	my $regexp = join "|", map quotemeta, @$self;
  	$_[0] eq '$_'
  		? "(defined and !ref and m{\\A(?:$regexp)\\z})"
  		: "(defined($_[0]) and !ref($_[0]) and $_[0] =~ m{\\A(?:$regexp)\\z})";
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Enum;
  	return "Moose::Meta::TypeConstraint::Enum"->new(%opts, values => $self->values);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Str();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	!defined($value) ? [
  		sprintf(
  			'"%s" requires that the value is defined',
  			$self,
  		),
  	] :
  	@$self < 13 ? [
  		sprintf(
  			'"%s" requires that the value is equal to %s',
  			$self,
  			Type::Utils::english_list(\"or", map B::perlstring($_), @$self),
  		),
  	] :
  	[
  		sprintf(
  			'"%s" requires that the value is one of an enumerated list of strings',
  			$self,
  		),
  	];
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Enum - string enum type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Enum type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<values>
  
  Arrayref of allowable value strings. Non-string values (e.g. objects with
  overloading) will be stringified in the constructor.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Str, and cannot be passed to the
  constructor.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<values>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Enum>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ENUM

$fatpacked{"Type/Tiny/Intersection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_INTERSECTION';
  package Type::Tiny::Intersection;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Intersection::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Intersection::VERSION   = '1.000005';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Intersection type constraints cannot have a parent constraint" if exists $opts{parent};
  	_croak "Intersection type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Intersection type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my @constraints = @{$opts{type_constraints}};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "AllOf[%s]", join(',', @known)
  			);
  			$opts{compiled_type_constraint} = $xsub if $xsub;
  		}
  	}
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[&], @$self;
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) || return for @checks;
  		return !!1;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	
  	if (Type::Tiny::_USE_XS and !exists $self->{xs_sub})
  	{
  		$self->{xs_sub} = undef;
  		
  		my @constraints = @{$self->type_constraints};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			$self->{xs_sub} = Type::Tiny::XS::get_subname_for(
  				sprintf "AllOf[%s]", join(',', @known)
  			);
  		}
  	}
  	
  	if (Type::Tiny::_USE_XS and $self->{xs_sub}) {
  		return "$self->{xs_sub}\($_[0]\)";
  	}
  	
  	sprintf '(%s)', join " and ", map $_->inline_check($_[0]), @$self;
  }
  
  sub has_parent
  {
  	!!@{ $_[0]{type_constraints} };
  }
  
  sub parent
  {
  	$_[0]{type_constraints}[0];
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	for my $type (@$self)
  	{
  		my $deep = $type->validate_explain($value, $varname);
  		return [
  			sprintf(
  				'"%s" requires that the value pass %s',
  				$self,
  				Type::Utils::english_list(map qq["$_"], @$self),
  			),
  			@$deep,
  		] if $deep;
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Intersection - intersection type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Intersection type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the
  intersection is itself an intersection type constraint, this is "exploded"
  into the new intersection.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  (Technically any of the types in the intersection could be treated as a
  parent type; we choose the first arbitrarily.)
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<MooseX::Meta::TypeConstraint::Intersection>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_INTERSECTION

$fatpacked{"Type/Tiny/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ROLE';
  package Type::Tiny::Role;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Role::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Role::VERSION   = '1.000005';
  }
  
  use Scalar::Util qw< blessed weaken >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  my %cache;
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Role type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Role type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Role type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply role name" unless exists $opts{role};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub role        { $_[0]{role} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self = shift;
  	my $role = $self->role;
  	return sub { blessed($_) and do { my $method = $_->can('DOES')||$_->can('isa'); $_->$method($role) } };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my $role = $self->role;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and do { my \$method = $var->can('DOES')||$var->can('isa'); $var->\$method(q[$role]) }};
  	};
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	my $c = $self->role;
  	return sub { sprintf '%s did not pass type constraint (not DOES %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not DOES %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	return ["Reference provides no DOES method to check roles"] unless $value->can('DOES');
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	return [
  		sprintf('"%s" requires that the reference does %s', $self, $self->role),
  		sprintf("The reference%s doesn't %s", $display_var, $self->role),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Role - type constraints based on the "DOES" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->DOES("Some::Role") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<role>
  
  The role for the constraint.
  
  Note that this package doesn't subscribe to any particular flavour of roles
  (L<Moose::Role>, L<Mouse::Role>, L<Moo::Role>, L<Role::Tiny>, etc). It simply
  trusts the object's C<DOES> method (see L<UNIVERSAL>).
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Role>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ROLE

$fatpacked{"Type/Tiny/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_UNION';
  package Type::Tiny::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Union::VERSION   = '1.000005';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Union type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Union type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Union type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my @constraints = @{$opts{type_constraints}};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "AnyOf[%s]", join(',', @known)
  			);
  			$opts{compiled_type_constraint} = $xsub if $xsub;
  		}
  	}
  
  	my $self = $proto->SUPER::new(%opts);
  	$self->coercion if grep $_->has_coercion, @$self;
  	return $self;
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[|], @$self;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion::Union;
  	my $self = shift;
  	return "Type::Coercion::Union"->new(type_constraint => $self);
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) && return !!1 for @checks;
  		return;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	
  	if (Type::Tiny::_USE_XS and !exists $self->{xs_sub})
  	{
  		$self->{xs_sub} = undef;
  		
  		my @constraints = @{$self->type_constraints};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			$self->{xs_sub} = Type::Tiny::XS::get_subname_for(
  				sprintf "AnyOf[%s]", join(',', @known)
  			);
  		}
  	}
  	
  	if (Type::Tiny::_USE_XS and $self->{xs_sub}) {
  		return "$self->{xs_sub}\($_[0]\)";
  	}
  	
  	sprintf '(%s)', join " or ", map $_->inline_check($_[0]), @$self;
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	my @tc = map $_->moose_type, @{$self->type_constraints};
  	
  	require Moose::Meta::TypeConstraint::Union;
  	return "Moose::Meta::TypeConstraint::Union"->new(%opts, type_constraints => \@tc);
  }
  
  sub has_parent
  {
  	defined(shift->parent);
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self = shift;
  	my ($first, @rest) = @$self;
  	
  	for my $parent ($first, $first->parents)
  	{
  		return $parent unless grep !$_->is_a_type_of($parent), @rest;
  	}
  	
  	return;
  }
  
  sub find_type_for
  {
  	my @types = @{+shift};
  	for my $type (@types)
  	{
  		return $type if $type->check(@_);
  	}
  	return;
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the value pass %s',
  			$self,
  			Type::Utils::english_list(\"or", map qq["$_"], @$self),
  		),
  		map {
  			$_->get_message($value),
  			map("    $_", @{ $_->validate_explain($value) || []}),
  		} @$self
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Union - union type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Union type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the union
  is itself a union type constraint, this is "exploded" into the new union.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  =item C<coercion>
  
  You probably do not pass this to the constructor. (It's not currently
  disallowed, as there may be a use for it that I haven't thought of.)
  
  The auto-generated default will be a L<Type::Coercion::Union> object.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< find_type_for($value) >>
  
  Returns the first individual type constraint in the union which
  C<< $value >> passes.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_UNION

$fatpacked{"Type/Tiny/_HalfOp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY__HALFOP';
  package Type::Tiny::_HalfOp;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::_HalfOp::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::_HalfOp::VERSION   = '1.000005';
  }
  
  use overload ();
  
  sub new {
  	my ($class, $op, $param, $type) = @_;
  	bless {
  		op    => $op,
  		param => $param,
  		type  => $type,
  	}, $class;
  }
  
  sub complete {
  	my ($self, $type) = @_;
  	my $complete_type = $type->parameterize(@{$self->{param}});
  	my $method = overload::Method($complete_type, $self->{op});
  	$complete_type->$method($self->{type});
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Type::Tiny::_HalfOp - half-completed overloaded operation
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  It is a class representing a half-completed overloaded operation.
  
  =head2 Constructor
  
  =over
  
  =item C<< new($operation, $param, $type) >>
  
  =back
  
  =head2 Method
  
  =over
  
  =item C<< complete($type) >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Graham Knop E<lt>haarg@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014 by Graham Knop.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY__HALFOP

$fatpacked{"Type/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_UTILS';
  package Type::Utils;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Utils::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Utils::VERSION   = '1.000005';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Scalar::Util qw< blessed >;
  use Type::Library;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny HashLike StringLike CodeLike >;
  
  our @EXPORT = qw<
  	declare as where message inline_as
  	class_type role_type duck_type union intersection enum
  	coerce from via
  	declare_coercion to_type
  >;
  our @EXPORT_OK = (
  	@EXPORT,
  	qw<
  		extends type subtype
  		match_on_type compile_match_on_type
  		dwim_type english_list
  		classifier
  	>,
  );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  sub extends
  {
  	_croak "Not a type library" unless caller->isa("Type::Library");
  	my $caller = caller->meta;
  	
  	foreach my $lib (@_)
  	{
  		eval "use $lib; 1" or _croak "Could not load library '$lib': $@";
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$caller->add_type( $lib->get_type($_) )
  				for sort $lib->meta->type_names;
  			$caller->add_coercion( $lib->get_coercion($_) )
  				for sort $lib->meta->coercion_names;
  		}
  		elsif ($lib->isa('MooseX::Types::Base'))
  		{
  			require Moose::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $moose = Moose::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($moose);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $moose->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		elsif ($lib->isa('MouseX::Types::Base'))
  		{
  			require Mouse::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $mouse = Mouse::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($mouse);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $mouse->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		else
  		{
  			_croak("'$lib' is not a type constraint library");
  		}
  	}
  }
  
  sub declare
  {
  	my %opts;
  	if (@_ % 2 == 0)
  	{
  		%opts = @_;
  		if (@_==2 and $_[0]=~ /^_*[A-Z]/ and $_[1] =~ /^[0-9]+$/)
  		{
  			require Carp;
  			Carp::carp("Possible missing comma after 'declare $_[0]'");
  		}
  	}
  	else
  	{
  		(my($name), %opts) = @_;
  		_croak "Cannot provide two names for type" if exists $opts{name};
  		$opts{name} = $name;
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	if (defined $opts{parent})
  	{
  		$opts{parent} = to_TypeTiny($opts{parent});
  		
  		unless (TypeTiny->check($opts{parent}))
  		{
  			$caller->isa("Type::Library")
  				or _croak("Parent type cannot be a %s", ref($opts{parent})||'non-reference scalar');
  			$opts{parent} = $caller->meta->get_type($opts{parent})
  				or _croak("Could not find parent type");
  		}
  	}
  	
  	my $type;
  	if (defined $opts{parent})
  	{
  		$type = delete($opts{parent})->create_child_type(%opts);
  	}
  	else
  	{
  		my $bless = delete($opts{bless}) || "Type::Tiny";
  		eval "require $bless";
  		$type = $bless->new(%opts);
  	}
  	
  	if ($caller->isa("Type::Library"))
  	{
  		$caller->meta->add_type($type) unless $type->is_anon;
  	}
  	
  	return $type;
  }
  
  *subtype = \&declare;
  *type = \&declare;
  
  sub as (@)
  {
  	parent => @_;
  }
  
  sub where (&;@)
  {
  	constraint => @_;
  }
  
  sub message (&;@)
  {
  	message => @_;
  }
  
  sub inline_as (&;@)
  {
  	inlined => @_;
  }
  
  sub class_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ shift or {} };
  	
  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{class} = $name unless exists $opts{class};
  		
  		$opts{name} =~ s/:://g;
  	}
  	
  	$opts{bless} = "Type::Tiny::Class";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub role_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ shift or {} };
  	
  	if (defined $name)
  	{
  		$opts{name} = $name unless exists $opts{name};
  		$opts{role} = $name unless exists $opts{role};
  		
  		$opts{name} =~ s/:://g;
  	}
  	
  	$opts{bless} = "Type::Tiny::Role";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub duck_type
  {
  	my $name    = ref($_[0]) ? undef : shift;
  	my @methods = @{ shift or [] };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{methods} = \@methods;
  	
  	$opts{bless} = "Type::Tiny::Duck";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub enum
  {
  	my $name   = ref($_[0]) ? undef : shift;
  	my @values = @{ shift or [] };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{values} = \@values;
  	
  	$opts{bless} = "Type::Tiny::Enum";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub union
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ shift or [] };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Union";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub intersection
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ shift or [] };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Intersection";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub declare_coercion
  {
  	my %opts;
  	$opts{name} = shift if !ref($_[0]);
  	
  	while (HashLike->check($_[0]) and not TypeTiny->check($_[0]))
  	{
  		%opts = (%opts, %{+shift});
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	my $bless = delete($opts{bless}) || "Type::Coercion";
  	eval "require $bless";
  	my $c = $bless->new(%opts);
  	
  	my @C;
  	
  	if ($caller->isa("Type::Library"))
  	{
  		my $meta = $caller->meta;
  		$meta->add_coercion($c) unless $c->is_anon;
  		while (@_)
  		{
  			push @C, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @C, shift;
  		}
  	}
  	else
  	{
  		@C = @_;
  	}
  	
  	$c->add_type_coercions(@C);
  	
  	return $c->freeze;
  }
  
  sub coerce
  {
  	if ((scalar caller)->isa("Type::Library"))
  	{
  		my $meta = (scalar caller)->meta;
  		my ($type) = map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  		my @opts;
  		while (@_)
  		{
  			push @opts, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @opts, shift;
  		}
  		return $type->coercion->add_type_coercions(@opts);
  	}
  	
  	my ($type, @opts) = @_;
  	$type = to_TypeTiny($type);
  	return $type->coercion->add_type_coercions(@opts);
  }
  
  sub from (@)
  {
  	return @_;
  }
  
  sub to_type (@)
  {
  	my $type = shift;
  	unless (TypeTiny->check($type))
  	{
  		caller->isa("Type::Library")
  			or _croak "Target type cannot be a string";
  		$type = caller->meta->get_type($type)
  			or _croak "Could not find target type";
  	}
  	return +{ type_constraint => $type }, @_;
  }
  
  sub via (&;@)
  {
  	return @_;
  }
  
  sub match_on_type
  {
  	my $value = shift;
  	
  	while (@_)
  	{
  		my $code;
  		if (@_ == 1)
  		{
  			$code = shift;
  		}
  		else
  		{
  			(my($type), $code) = splice(@_, 0, 2);
  			TypeTiny->($type)->check($value) or next;
  		}
  		
  		if (StringLike->check($code))
  		{
  			local $_ = $value;
  			if (wantarray) {
  				my @r = eval "$code";
  				die $@ if $@;
  				return @r;
  			}
  			if (defined wantarray) {
  				my $r = eval "$code";
  				die $@ if $@;
  				return $r;
  			}
  			eval "$code";
  			die $@ if $@;
  			return;
  		}
  		else
  		{
  			CodeLike->($code);
  			local $_ = $value;
  			return $code->($value);
  		}
  	}
  	
  	_croak("No cases matched for %s", Type::Tiny::_dd($value));
  }
  
  sub compile_match_on_type
  {
  	my @code = 'sub { local $_ = $_[0]; ';
  	my @checks;
  	my @actions;
  	
  	my $els = '';
  	
  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}
  		
  		if ($type->can_be_inlined)
  		{
  			push @code, sprintf('%sif (%s)', $els, $type->inline_check('$_'));
  		}
  		else
  		{
  			push @checks, $type;
  			push @code, sprintf('%sif ($checks[%d]->check($_))', $els, $#checks);
  		}
  		
  		$els = 'els';
  		
  		if (StringLike->check($code))
  		{
  			push @code, sprintf('  { %s }', $code);
  		}
  		else
  		{
  			CodeLike->($code);
  			push @actions, $code;
  			push @code, sprintf('  { $actions[%d]->(@_) }', $#actions);
  		}
  	}
  	
  	push @code, 'else', '  { Type::Utils::_croak("No cases matched for %s", Type::Tiny::_dd($_[0])) }';
  	
  	push @code, '}';  # /sub
  	
  	require Eval::TypeTiny;
  	return Eval::TypeTiny::eval_closure(
  		source      => \@code,
  		environment => {
  			'@actions' => \@actions,
  			'@checks'  => \@checks,
  		},
  	);
  }
  
  sub classifier
  {
  	my $i;
  	compile_match_on_type(
  		+(
  			map {
  				my $type = $_->[0];
  				$type => sub { $type };
  			}
  			sort { $b->[1] <=> $a->[1] or $a->[2] <=> $b->[2] }
  			map [$_, scalar(my @parents = $_->parents), ++$i],
  			@_
  		),
  		q[ undef ],
  	);
  }
  
  {
  	package #hide
  	Type::Registry::DWIM;
  	
  	our @ISA = qw(Type::Registry);
  	
  	sub foreign_lookup
  	{
  		my $self = shift;
  		my $r = $self->SUPER::foreign_lookup(@_);
  		return $r if $r;
  		
  		if (defined($self->{"~~assume"})
  		and $_[0] =~ /[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/)
  		{
  			my $method = $self->{"~~assume"};
  			return $self->$method(@_);
  		}
  		
  		return;
  	}
  	
  	sub simple_lookup
  	{
  		my $self = shift;
  		my $r;
  		
  		# If the lookup is chained to a class, then the class' own
  		# type registry gets first refusal.
  		#
  		if (defined $self->{"~~chained"})
  		{
  			my $chained = "Type::Registry"->for_class($self->{"~~chained"});
  			$r = eval { $chained->simple_lookup(@_) } unless $self == $chained;
  			return $r if defined $r;
  		}
  		
  		# Fall back to types in Types::Standard.
  		require Types::Standard;
  		return 'Types::Standard'->get_type($_[0]) if 'Types::Standard'->has_type($_[0]);
  		
  		# Only continue any further if we've been called from Type::Parser.
  		return unless $_[1];
  		
  		my $moose_lookup = sub
  		{
  			if ($INC{'Moose.pm'})
  			{
  				require Moose::Util::TypeConstraints;
  				require Types::TypeTiny;
  				$r = Moose::Util::TypeConstraints::find_type_constraint($_[0]);
  				$r = Types::TypeTiny::to_TypeTiny($r) if defined $r;
  			}
  			defined $r;
  		};
  		
  		my $mouse_lookup = sub
  		{
  			if ($INC{'Mouse.pm'})
  			{
  				require Mouse::Util::TypeConstraints;
  				require Types::TypeTiny;
  				$r = Mouse::Util::TypeConstraints::find_type_constraint($_[0]);
  				$r = Types::TypeTiny::to_TypeTiny($r) if defined $r;
  			}
  			defined $r;
  		};
  		
  		my $meta;
  		if (defined $self->{"~~chained"})
  		{
  			$meta ||= Moose::Util::find_meta($self->{"~~chained"}) if $INC{'Moose.pm'};
  			$meta ||= Mouse::Util::find_meta($self->{"~~chained"}) if $INC{'Mouse.pm'};
  		}
  		
  		if ($meta and $meta->isa('Class::MOP::Module'))
  		{
  			$moose_lookup->(@_) and return $r;
  		}
  		elsif ($meta and $meta->isa('Mouse::Meta::Module'))
  		{
  			$mouse_lookup->(@_) and return $r;
  		}
  		else
  		{
  			$moose_lookup->(@_) and return $r;
  			$mouse_lookup->(@_) and return $r;
  		}
  		
  		return $self->foreign_lookup(@_);
  	}
  }
  
  our $dwimmer;
  sub dwim_type
  {
  	my ($string, %opts) = @_;
  	$opts{for} = caller unless defined $opts{for};
  	
  	$dwimmer ||= do {
  		require Type::Registry;
  		'Type::Registry::DWIM'->new;
  	};
  	
  	local $dwimmer->{'~~chained'} = $opts{for};
  	local $dwimmer->{'~~assume'}  = $opts{does} ? 'make_role_type' : 'make_class_type';
  	
  	$dwimmer->lookup($string);
  }
  
  sub english_list
  {
  	my $conjunction = ref($_[0]) eq 'SCALAR' ? ${+shift} : 'and';
  	my @items = sort @_;
  	
  	return $items[0] if @items == 1;
  	return "$items[0] $conjunction $items[1]" if @items == 2;
  	
  	my $tail = pop @items;
  	join(', ', @items, "$conjunction $tail");
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smush smushed
  
  =head1 NAME
  
  Type::Utils - utility functions to make defining and using type constraints a little easier
  
  =head1 SYNOPSIS
  
     package Types::Mine;
     
     use Type::Library -base;
     use Type::Utils -all;
     
     BEGIN { extends "Types::Standard" };
     
     declare "AllCaps",
        as "Str",
        where { uc($_) eq $_ },
        inline_as { my $varname = $_[1]; "uc($varname) eq $varname" };
     
     coerce "AllCaps",
        from "Str", via { uc($_) };
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This module provides utility functions to make defining and using type
  constraints a little easier. 
  
  =head2 Type declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< declare $name, %options >>
  
  =item C<< declare %options >>
  
  Declare a named or anonymous type constraint. Use C<as> and C<where> to
  specify the parent type (if any) and (possibly) refine its definition.
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
     my $EvenInt = declare as Int, where { $_ % 2 == 0 };
  
  B<< NOTE: >>
  If the caller package inherits from L<Type::Library> then any non-anonymous
  types declared in the package will be automatically installed into the
  library.
  
  Hidden gem: if you're inheriting from a type constraint that includes some
  coercions, you can include C<< coercion => 1 >> in the C<< %options >> hash
  to inherit the coercions.
  
  =item C<< subtype $name, %options >>
  
  =item C<< subtype %options >>
  
  Declare a named or anonymous type constraint which is descended from an
  existing type constraint. Use C<as> and C<where> to specify the parent
  type and refine its definition.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< type $name, %options >>
  
  =item C<< type %options >>
  
  Declare a named or anonymous type constraint which is not descended from
  an existing type constraint. Use C<where> to provide a coderef that
  constrains values.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< as $parent >>
  
  Used with C<declare> to specify a parent type constraint:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  =item C<< where { BLOCK } >>
  
  Used with C<declare> to provide the constraint coderef:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  The coderef operates on C<< $_ >>, which is the value being tested.
  
  =item C<< message { BLOCK } >>
  
  Generate a custom error message when a value fails validation.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        message {
           Int->validate($_) or "$_ is not divisible by two";
        };
  
  Without a custom message, the messages generated by Type::Tiny are along
  the lines of I<< Value "33" did not pass type constraint "EvenInt" >>,
  which is usually reasonable.
  
  =item C<< inline_as { BLOCK } >>
  
  Generate a string of Perl code that can be used to inline the type check into
  other functions. If your type check is being used within a L<Moose> or L<Moo>
  constructor or accessor methods, or used by L<Type::Params>, this can lead to
  significant performance improvements.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           my ($constraint, $varname) = @_;
           my $perlcode = 
              $constraint->parent->inline_check($varname)
              . "&& ($varname % 2 == 0)";
           return $perlcode;
        };
     
     warn EvenInt->inline_check('$xxx');  # demonstration
  
  B<Experimental:> your C<inline_as> block can return a list, in which case
  these will be smushed together with "&&". The first item on the list may
  be undef, in which case the undef will be replaced by the inlined parent
  type constraint. (And will throw an exception if there is no parent.)
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           return (undef, "($_ % 2 == 0)");
        };
  
  Returning a list like this is considered experimental, is not tested very
  much, and I offer no guarantees that it will necessarily work with
  Moose/Mouse/Moo.
  
  =item C<< class_type $name, { class => $package, %options } >>
  
  =item C<< class_type { class => $package, %options } >>
  
  =item C<< class_type $name >>
  
  Shortcut for declaring a L<Type::Tiny::Class> type constraint.
  
  If C<< $package >> is omitted, is assumed to be the same as C<< $name >>.
  If C<< $name >> contains "::" (which would be an invalid name as far as
  L<Type::Tiny> is concerned), this will be removed.
  
  So for example, C<< class_type("Foo::Bar") >> declares a L<Type::Tiny::Class>
  type constraint named "FooBar" which constrains values to objects blessed
  into the "Foo::Bar" package.
  
  =item C<< role_type $name, { role => $package, %options } >>
  
  =item C<< role_type { role => $package, %options } >>
  
  =item C<< role_type $name >>
  
  Shortcut for declaring a L<Type::Tiny::Role> type constraint.
  
  If C<< $package >> is omitted, is assumed to be the same as C<< $name >>.
  If C<< $name >> contains "::" (which would be an invalid name as far as
  L<Type::Tiny> is concerned), this will be removed.
  
  =item C<< duck_type $name, \@methods >>
  
  =item C<< duck_type \@methods >>
  
  Shortcut for declaring a L<Type::Tiny::Duck> type constraint.
  
  =item C<< union $name, \@constraints >>
  
  =item C<< union \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Union> type constraint.
  
  =item C<< enum $name, \@values >>
  
  =item C<< enum \@values >>
  
  Shortcut for declaring a L<Type::Tiny::Enum> type constraint.
  
  =item C<< intersection $name, \@constraints >>
  
  =item C<< intersection \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Intersection> type constraint.
  
  =back
  
  =head2 Coercion declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< coerce $target, @coercions >>
  
  Add coercions to the target type constraint. The list of coercions is a
  list of type constraint, conversion code pairs. Conversion code can be
  either a string of Perl code or a coderef; in either case the value to
  be converted is C<< $_ >>.
  
  =item C<< from $source >>
  
  Sugar to specify a type constraint in a list of coercions:
  
     coerce EvenInt, from Int, via { $_ * 2 };  # As a coderef...
     coerce EvenInt, from Int, q { $_ * 2 };    # or as a string!
  
  =item C<< via { BLOCK } >>
  
  Sugar to specify a coderef in a list of coercions.
  
  =item C<< declare_coercion $name, \%opts, $type1, $code1, ... >>
  
  =item C<< declare_coercion \%opts, $type1, $code1, ... >>
  
  Declares a coercion that is not explicitly attached to any type in the
  library. For example:
  
     declare_coercion "ArrayRefFromAny", from "Any", via { [$_] };
  
  This coercion will be exportable from the library as a L<Type::Coercion>
  object, but the ArrayRef type exported by the library won't automatically
  use it.
  
  Coercions declared this way are immutable (frozen).
  
  =item C<< to_type $type >>
  
  Used with C<declare_coercion> to declare the target type constraint for
  a coercion, but still without explicitly attaching the coercion to the
  type constraint:
  
     declare_coercion "ArrayRefFromAny",
        to_type "ArrayRef",
        from "Any", via { [$_] };
  
  You should pretty much always use this when declaring an unattached
  coercion because it's exceedingly useful for a type coercion to know what
  it will coerce to - this allows it to skip coercion when no coercion is
  needed (e.g. avoiding coercing C<< [] >> to C<< [ [] ] >>) and allows
  C<assert_coerce> to work properly.
  
  =back
  
  =head2 Type library management
  
  =over
  
  =item C<< extends @libraries >>
  
  Indicates that this type library extends other type libraries, importing
  their type constraints.
  
  Should usually be executed in a C<< BEGIN >> block.
  
  This is not exported by default because it's not fun to export it to Moo,
  Moose or Mouse classes! C<< use Type::Utils -all >> can be used to import
  it into your type library.
  
  =back
  
  =head2 Other
  
  =over
  
  =item C<< match_on_type $value => ($type => \&action, ..., \&default?) >>
  
  Something like a C<switch>/C<case> or C<given>/C<when> construct. Dispatches
  along different code paths depending on the type of the incoming value.
  Example blatantly stolen from the Moose documentation:
  
     sub to_json
     {
        my $value = shift;
        
        return match_on_type $value => (
           HashRef() => sub {
              my $hash = shift;
              '{ '
                 . (
                 join ", " =>
                 map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                 sort keys %$hash
              ) . ' }';
           },
           ArrayRef() => sub {
              my $array = shift;
              '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
           },
           Num()   => q {$_},
           Str()   => q { '"' . $_ . '"' },
           Undef() => q {'null'},
           => sub { die "$_ is not acceptable json type" },
        );
     }
  
  Note that unlike Moose, code can be specified as a string instead of a
  coderef. (e.g. for C<Num>, C<Str> and C<Undef> above.)
  
  For improved performance, try C<compile_match_on_type>.
  
  This function is not exported by default.
  
  =item C<< my $coderef = compile_match_on_type($type => \&action, ..., \&default?) >>
  
  Compile a C<match_on_type> block into a coderef. The following JSON
  converter is about two orders of magnitude faster than the previous
  example:
  
     sub to_json;
     *to_json = compile_match_on_type(
        HashRef() => sub {
           my $hash = shift;
           '{ '
              . (
              join ", " =>
              map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
              sort keys %$hash
           ) . ' }';
        },
        ArrayRef() => sub {
           my $array = shift;
           '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
        },
        Num()   => q {$_},
        Str()   => q { '"' . $_ . '"' },
        Undef() => q {'null'},
        => sub { die "$_ is not acceptable json type" },
     );
  
  Remember to store the coderef somewhere fairly permanent so that you
  don't compile it over and over. C<state> variables (in Perl >= 5.10)
  are good for this. (Same sort of idea as L<Type::Params>.)
  
  This function is not exported by default.
  
  =item C<< my $coderef = classifier(@types) >>
  
  Returns a coderef that can be used to classify values according to their
  type constraint. The coderef, when passed a value, returns a type
  constraint which the value satisfies.
  
     use feature qw( say );
     use Type::Utils qw( classifier );
     use Types::Standard qw( Int Num Str Any );
     
     my $classifier = classifier(Str, Int, Num, Any);
     
     say $classifier->( "42"  )->name;   # Int
     say $classifier->( "4.2" )->name;   # Num
     say $classifier->( []    )->name;   # Any
  
  Note that, for example, "42" satisfies Int, but it would satisfy the
  type constraints Num, Str, and Any as well. In this case, the
  classifier has picked the most specific type constraint that "42"
  satisfies.
  
  If no type constraint is satisfied by the value, then the classifier
  will return undef.
  
  =item C<< dwim_type($string, %options) >>
  
  Given a string like "ArrayRef[Int|CodeRef]", turns it into a type constraint
  object, hopefully doing what you mean.
  
  It uses the syntax of L<Type::Parser>. Firstly the L<Type::Registry>
  for the caller package is consulted; if that doesn't have a match,
  L<Types::Standard> is consulted for type constraint names; and if
  there's still no match, then if a type constraint looks like a class
  name, a new L<Type::Tiny::Class> object is created for it.
  
  Somewhere along the way, it also checks Moose/Mouse's type constraint
  registries if they are loaded.
  
  You can specify an alternative for the caller using the C<for> option.
  If you'd rather create a L<Type::Tiny::Role> object, set the C<does>
  option to true.
  
     # An arrayref of objects, each of which must do role Foo.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);
     
     Type::Registry->for_me->add_types("-Standard");
     Type::Registry->for_me->alias_type("Int" => "Foo");
     
     # An arrayref of integers.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);
  
  While it's probably better overall to use the proper L<Type::Registry>
  interface for resolving type constraint strings, this function often does
  what you want.
  
  It should never die if it fails to find a type constraint (but may die
  if the type constraint string is syntactically malformed), preferring to
  return undef.
  
  This function is not exported by default.
  
  =item C<< english_list(\$conjunction, @items) >>
  
  Joins the items with commas, placing a conjunction before the final item.
  The conjunction is optional, defaulting to "and".
  
     english_list(qw/foo bar baz/);       # "foo, bar, and baz"
     english_list(\"or", qw/quux quuux/); # "quux or quuux"
  
  This function is not exported by default.
  
  =back
  
  =head1 EXPORT
  
  By default, all of the functions documented above are exported, except
  C<subtype> and C<type> (prefer C<declare> instead), C<extends>, C<dwim_type>,
  C<match_on_type>/C<compile_match_on_type>, C<classifier>, and
  C<english_list>.
  
  This module uses L<Exporter::Tiny>; see the documentation of that module
  for tips and tricks importing from Type::Utils.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_UTILS

$fatpacked{"Types/Common/Numeric.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_NUMERIC';
  package Types::Common::Numeric;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::Numeric::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::Numeric::VERSION   = '1.000005';
  }
  
  use Type::Library -base, -declare => qw(
  	PositiveNum PositiveOrZeroNum
  	PositiveInt PositiveOrZeroInt
  	NegativeNum NegativeOrZeroNum
  	NegativeInt NegativeOrZeroInt
  	SingleDigit
  );
  
  use Type::Tiny ();
  use Types::Standard qw( Num Int );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => 'PositiveNum',
  	parent     => Num,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive number" },
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be a number greater than or equal to zero" },
  );
  
  my ($pos_int, $posz_int);
  if (Type::Tiny::_USE_XS) {
  	$pos_int  = Type::Tiny::XS::get_coderef_for('PositiveInt');
  	$posz_int = Type::Tiny::XS::get_coderef_for('PositiveOrZeroInt');
  }
  
  $meta->add_type(
  	name       => 'PositiveInt',
  	parent     => Int,
  	constraint => sub { $_ > 0 },
  	inlined    => sub {
  		if ($pos_int) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq($_ > 0);
  	},
  	message    => sub { "Must be a positive integer" },
  	$pos_int ? ( compiled_type_constraint => $pos_int ) : (),
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub {
  		if ($posz_int) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq($_ >= 0);
  	},
  	message    => sub { "Must be an integer greater than or equal to zero" },
  	$posz_int ? ( compiled_type_constraint => $posz_int ) : (),
  );
  
  $meta->add_type(
  	name       => 'NegativeNum',
  	parent     => Num,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative number" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be a number less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'NegativeInt',
  	parent     => Int,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative integer" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be an integer less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'SingleDigit',
  	parent     => Int,
  	constraint => sub { $_ >= -9 and $_ <= 9 },
  	inlined    => sub { undef, qq($_ >= -9), qq($_ <= 9) },
  	message    => sub { "Must be a single digit" },
  );
  
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::Numeric - drop-in replacement for MooseX::Types::Common::Numeric
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::Numeric>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::Numeric>.
  
  =over
  
  =item C<PositiveNum>
  
  =item C<PositiveOrZeroNum>
  
  =item C<PositiveInt>
  
  =item C<PositiveOrZeroInt>
  
  =item C<NegativeNum>
  
  =item C<NegativeOrZeroNum>
  
  =item C<NegativeInt>
  
  =item C<NegativeOrZeroInt>
  
  =item C<SingleDigit>
  
  =back
  
  C<SingleDigit> interestingly accepts the numbers -9 to -1; not
  just 0 to 9. 
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::String>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_NUMERIC

$fatpacked{"Types/Common/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_STRING';
  package Types::Common::String;
  
  use 5.006001;
  use strict;
  use warnings;
  use utf8;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::String::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::String::VERSION   = '1.000005';
  }
  
  use Type::Library -base, -declare => qw(
  	SimpleStr
  	NonEmptySimpleStr
  	NumericCode
  	LowerCaseSimpleStr
  	UpperCaseSimpleStr
  	Password
  	StrongPassword
  	NonEmptyStr
  	LowerCaseStr
  	UpperCaseStr
  );
  
  use Type::Tiny ();
  use Types::Standard qw( Str );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => SimpleStr,
  	parent     => Str,
  	constraint => sub { length($_) <= 255 and not /\n/ },
  	inlined    => sub { undef, qq(length($_) <= 255), qq($_ !~ /\\n/) },
  	message    => sub { "Must be a single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NonEmptySimpleStr,
  	parent     => SimpleStr,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must be a non-empty single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NumericCode,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { /^[0-9]+$/ },
  	inlined    => sub { SimpleStr->inline_check($_), qq($_ =~ m/^[0-9]+\$/) },
  	message    => sub {
  		'Must be a non-empty single line of no more than 255 chars that consists '
  			. 'of numeric characters only'
  	},
  );
  
  NumericCode->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ do { (my $code = $_) =~ s/[[:punct:]]//g; $code } ],
  );
  
  $meta->add_type(
  	name       => Password,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { length($_) > 3 },
  	inlined    => sub { SimpleStr->inline_check($_), qq(length($_) > 3) },
  	message    => sub { "Must be between 4 and 255 chars" },
  );
  
  $meta->add_type(
  	name       => StrongPassword,
  	parent     => Password,
  	constraint => sub { length($_) > 7 and /[^a-zA-Z]/ },
  	inlined    => sub { SimpleStr()->inline_check($_), qq(length($_) > 7), qq($_ =~ /[^a-zA-Z]/) },
  	message    => sub { "Must be between 8 and 255 chars, and contain a non-alpha char" },
  );
  
  my ($nestr);
  if (Type::Tiny::_USE_XS) {
  	$nestr = Type::Tiny::XS::get_coderef_for('NonEmptyStr');
  }
  
  $meta->add_type(
  	name       => NonEmptyStr,
  	parent     => Str,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub {
  		if ($nestr) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq(length($_) > 0);
  	},
  	message    => sub { "Must not be empty" },
  	$nestr ? ( compiled_type_constraint => $nestr ) : (),
  );
  
  $meta->add_type(
  	name       => LowerCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain upper case letters" },
  );
  
  LowerCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ uc($_) ],
  );
  
  $meta->add_type(
  	name       => LowerCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain pper case letters" },
  );
  
  LowerCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ uc($_) ],
  );
  
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::String - drop-in replacement for MooseX::Types::Common::String
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::String>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::String>.
  
  =over
  
  =item C<SimpleStr>
  
  =item C<NonEmptySimpleStr>
  
  =item C<NumericCode>
  
  =item C<LowerCaseSimpleStr>
  
  =item C<UpperCaseSimpleStr>
  
  =item C<Password>
  
  =item C<StrongPassword>
  
  =item C<NonEmptyStr>
  
  =item C<LowerCaseStr>
  
  =item C<UpperCaseStr>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::Numeric>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_STRING

$fatpacked{"Types/Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Types::Path::Tiny;
  # ABSTRACT: Path::Tiny types and coercions for Moose and Moo
  our $VERSION = '0.005'; # VERSION
  
  use Path::Tiny qw();
  use Type::Library 0.008 -base, -declare => qw( Path AbsPath File AbsFile Dir AbsDir );
  use Type::Utils;
  use Types::Standard qw( Str ArrayRef );
  use Types::TypeTiny 0.004 StringLike => { -as => "Stringable" };
  
  #<<<
  class_type Path, { class => "Path::Tiny" };
  
  declare AbsPath,
      as Path, where { $_->is_absolute },
      inline_as { $_[0]->parent->inline_check($_) . "&& ${_}->is_absolute" },
      message {
          is_Path($_) ? "Path '$_' is not absolute" : Path->get_message($_);
      };
  
  declare File,
      as Path, where { $_->is_file },
      inline_as { $_[0]->parent->inline_check($_) . "&& (-f $_)" },
      message {
          is_Path($_) ? "File '$_' does not exist" : Path->get_message($_);
      };
  
  declare Dir,
      as Path, where { $_->is_dir },
      inline_as { $_[0]->parent->inline_check($_) . "&& (-d $_)" },
      message {
          is_Path($_) ? "Directory '$_' does not exist" : Path->get_message($_);
      };
  
  declare AbsFile,
      as intersection([AbsPath, File]),
      message {
          is_AbsPath($_) ? File->get_message($_) : AbsPath->get_message($_);
      };
  
  declare AbsDir,
      as intersection([AbsPath, Dir]),
      message {
          is_AbsPath($_) ? Dir->get_message($_) : AbsPath->get_message($_);
      };
  #>>>
  
  for my $type ( Path, File, Dir ) {
      coerce(
          $type,
          from Str()        => q{ Path::Tiny::path($_) },
          from Stringable() => q{ Path::Tiny::path($_) },
          from ArrayRef()   => q{ Path::Tiny::path(@$_) },
      );
  }
  
  for my $type ( AbsPath, AbsFile, AbsDir ) {
      coerce(
          $type,
          from Path         => q{ $_->absolute },
          from Str()        => q{ Path::Tiny::path($_)->absolute },
          from Stringable() => q{ Path::Tiny::path($_)->absolute },
          from ArrayRef()   => q{ Path::Tiny::path(@$_)->absolute },
      );
  }
  
  ### optionally add Getopt option type (adapted from MooseX::Types:Path::Class
  ##eval { require MooseX::Getopt; };
  ##if ( !$@ ) {
  ##    MooseX::Getopt::OptionTypeMap->add_option_type_to_map( $_, '=s', )
  ##      for ( 'Path::Tiny', Path );
  ##}
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Path::Tiny - Path::Tiny types and coercions for Moose and Moo
  
  =head1 VERSION
  
  version 0.005
  
  =head1 SYNOPSIS
  
    ### specification of type constraint with coercion
  
    package Foo;
  
    use Moose;
    use Types::Path::Tiny qw/Path AbsPath/;
  
    has filename => (
      is => 'ro',
      isa => Path,
      coerce => 1,
    );
  
    has directory => (
      is => 'ro',
      isa => AbsPath,
      coerce => 1,
    );
  
    ### usage in code
  
    Foo->new( filename => 'foo.txt' ); # coerced to Path::Tiny
    Foo->new( directory => '.' ); # coerced to path('.')->absolute
  
  =head1 DESCRIPTION
  
  This module provides L<Path::Tiny> types for Moose, Moo, etc.
  
  It handles two important types of coercion:
  
  =over 4
  
  =item *
  
  coercing objects with overloaded stringification
  
  =item *
  
  coercing to absolute paths
  
  =back
  
  It also can check to ensure that files or directories exist.
  
  =for Pod::Coverage method_names_here
  
  =head1 SUBTYPES
  
  This module uses L<Type::Tiny> to define the following subtypes.
  
  =head2 Path
  
  C<Path> ensures an attribute is a L<Path::Tiny> object.  Strings and
  objects with overloaded stringification may be coerced.
  
  =head2 AbsPath
  
  C<AbsPath> is a subtype of C<Path> (above), but coerces to an absolute path.
  
  =head2 File, AbsFile
  
  These are just like C<Path> and C<AbsPath>, except they check C<-f> to ensure
  the file actually exists on the filesystem.
  
  =head2 Dir, AbsDir
  
  These are just like C<Path> and C<AbsPath>, except they check C<-d> to ensure
  the directory actually exists on the filesystem.
  
  =head1 CAVEATS
  
  =head2 Path vs File vs Dir
  
  C<Path> just ensures you have a L<Path::Tiny> object.
  
  C<File> and C<Dir> check the filesystem.  Don't use them unless that's really
  what you want.
  
  =head2 Usage with File::Temp
  
  Be careful if you pass in a File::Temp object. Because the argument is
  stringified during coercion into a Path::Tiny object, no reference to the
  original File::Temp argument is held.  Be sure to hold an external reference to
  it to avoid immediate cleanup of the temporary file or directory at the end of
  the enclosing scope.
  
  A better approach is to use Path::Tiny's own C<tempfile> or C<tempdir>
  constructors, which hold the reference for you.
  
      Foo->new( filename => Path::Tiny->tempfile );
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Path::Tiny>
  
  =item *
  
  L<Moose::Manual::Types>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/types-path-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/types-path-tiny>
  
    git clone git://github.com/dagolden/types-path-tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTOR
  
  Toby Inkster <tobyink@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
TYPES_PATH_TINY

$fatpacked{"Types/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD';
  package Types::Standard;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	eval { require re };
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  	if ($] < 5.010) { require Devel::TypeTiny::Perl58Compat };
  }
  
  BEGIN {
  	$Types::Standard::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::VERSION   = '1.000005';
  }
  
  use Type::Library -base;
  
  our @EXPORT_OK = qw( slurpy );
  
  use Scalar::Util qw( blessed looks_like_number );
  use Type::Tiny ();
  use Types::TypeTiny ();
  
  BEGIN {
  	*_is_class_loaded = Type::Tiny::_USE_XS
  		? \&Type::Tiny::XS::Util::is_class_loaded
  		: sub {
  			return !!0 if ref $_[0];
  			return !!0 if not $_[0];
  			my $stash = do { no strict 'refs'; \%{"$_[0]\::"} };
  			return !!1 if exists $stash->{'ISA'};
  			return !!1 if exists $stash->{'VERSION'};
  			foreach my $globref (values %$stash) {
  				return !!1 if *{$globref}{CODE};
  			}
  			return !!0;
  		};
  };
  
  my $add_core_type = sub {
  	my $meta = shift;
  	my ($typedef) = @_;
  	
  	my $name = $typedef->{name};
  	my ($xsub, $xsubname);
  	
  	# We want Map and Tuple to be XSified, even if they're not
  	# really core.
  	$typedef->{_is_core} = 1
  		unless $name eq 'Map' || $name eq 'Tuple';
  
  	if ( Type::Tiny::_USE_XS
  	and not ($name eq 'RegexpRef') ) {
  		$xsub     = Type::Tiny::XS::get_coderef_for($name);
  		$xsubname = Type::Tiny::XS::get_subname_for($name);
  	}
  		
  	elsif ( Type::Tiny::_USE_MOUSE
  	and not ($name eq 'RegexpRef' or $name eq 'Int' or $name eq 'Object') ) {
  		require Mouse::Util::TypeConstraints;
  		$xsub     = "Mouse::Util::TypeConstraints"->can($name);
  		$xsubname = "Mouse::Util::TypeConstraints::$name" if $xsub;
  	}
  	
  	$typedef->{compiled_type_constraint} = $xsub if $xsub;
  	
  	$typedef->{inlined} = sub { "$xsubname\($_[1])" }
  		if defined($xsubname) and (
  			# These should be faster than their normal inlined
  			# equivalents
  			$name eq 'Str' or
  			$name eq 'Bool' or
  			$name eq 'ClassName' or
  			$name eq 'RegexpRef' or
  			$name eq 'FileHandle'
  		);
  	
  	$meta->add_type($typedef);
  };
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = __PACKAGE__->meta;
  
  # Stringable and LazyLoad are optimizations that complicate
  # this module somewhat, but they have led to performance
  # improvements. If Types::Standard wasn't such a key type
  # library, I wouldn't use them. I strongly discourage anybody
  # from using them in their own code. If you're looking for
  # examples of how to write a type library sanely, you're
  # better off looking at the code for Types::Common::Numeric
  # and Types::Common::String.
  
  sub Stringable (&)
  {
  	package #private
  	Types::Standard::_Stringable;
  	use overload q[""] => sub { $_[0]{text} ||= $_[0]{code}->() }, fallback => 1;
  	bless +{ code => $_[0] };
  }
  
  sub LazyLoad ($$)
  {
  	package #private
  	Types::Standard::LazyLoad;
  	use overload fallback => 1, q[&{}] => sub {
  		my ($typename, $function) = @{$_[0]};
  		my $type  = $meta->get_type($typename);
  		my $class = "Types::Standard::$typename";
  		eval "require $class; 1" or die($@);
  		# Majorly break encapsulation for Type::Tiny :-O
  		for my $key (keys %$type)
  		{
  			next unless ref($type->{$key}) eq __PACKAGE__;
  			my $f = $type->{$key}[1];
  			$type->{$key} = $class->can("__$f");
  		}
  		return $class->can("__$function");
  	};
  	bless \@_;
  }
  
  no warnings;
  
  BEGIN { *STRICTNUM = $ENV{PERL_TYPES_STANDARD_STRICTNUM} ? sub(){!!1} : sub(){!!0} };
  
  my $_any = $meta->$add_core_type({
  	name       => "Any",
  	inlined    => sub { "!!1" },
  });
  
  my $_item = $meta->$add_core_type({
  	name       => "Item",
  	inlined    => sub { "!!1" },
  	parent     => $_any,
  });
  
  $meta->$add_core_type({
  	name       => "Bool",
  	parent     => $_item,
  	constraint => sub { !defined $_ or $_ eq q() or $_ eq '0' or $_ eq '1' },
  	inlined    => sub { "!defined $_[1] or $_[1] eq q() or $_[1] eq '0' or $_[1] eq '1'" },
  });
  
  my $_undef = $meta->$add_core_type({
  	name       => "Undef",
  	parent     => $_item,
  	constraint => sub { !defined $_ },
  	inlined    => sub { "!defined($_[1])" },
  });
  
  my $_def = $meta->$add_core_type({
  	name       => "Defined",
  	parent     => $_item,
  	constraint => sub { defined $_ },
  	inlined    => sub { "defined($_[1])" },
  });
  
  my $_val = $meta->$add_core_type({
  	name       => "Value",
  	parent     => $_def,
  	constraint => sub { not ref $_ },
  	inlined    => sub { "defined($_[1]) and not ref($_[1])" },
  });
  
  my $_str = $meta->$add_core_type({
  	name       => "Str",
  	parent     => $_val,
  	constraint => sub { ref(\$_) eq 'SCALAR' or ref(\(my $val = $_)) eq 'SCALAR' },
  	inlined    => sub {
  		"defined($_[1]) and do { ref(\\$_[1]) eq 'SCALAR' or ref(\\(my \$val = $_[1])) eq 'SCALAR' }"
  	},
  });
  
  my $_laxnum = $meta->add_type({
  	name       => "LaxNum",
  	parent     => $_str,
  	constraint => sub { looks_like_number $_ },
  	inlined    => sub { "defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1])" },
  });
  
  my $_strictnum = $meta->add_type({
  	name       => "StrictNum",
  	parent     => $_str,
  	constraint => sub {
  		my $val = $_;
  		($val =~ /\A[+-]?[0-9]+\z/) ||
  		( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
  		(?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
  		[0-9]*                                #matches 0-9 zero or more times
  		(?:\.[0-9]+)?                         #matches optional .89 or nothing
  		(?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
  		\z/x );
  	},
  	inlined    => sub {
  		'my $val = '.$_[1].';'.
  		Value()->inline_check('$val')
  		.' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
  		. '$val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
  			(?=[0-9]|\.[0-9])                 # matches previous +- only if there is something like 3 or .3
  			[0-9]*                            # matches 0-9 zero or more times
  			(?:\.[0-9]+)?                     # matches optional .89 or nothing
  			(?:[Ee](?:[+-]?[0-9]+))?          # matches E1 or e1 or e-1 or e+1 etc
  		\z/x ); '
  	},
  });
  
  my $_num = $meta->add_type({
  	name       => "Num",
  	parent     => (STRICTNUM ? $_strictnum : $_laxnum),
  });
  
  $meta->$add_core_type({
  	name       => "Int",
  	parent     => $_num,
  	constraint => sub { /\A-?[0-9]+\z/ },
  	inlined    => sub { "defined $_[1] and $_[1] =~ /\\A-?[0-9]+\\z/" },
  });
  
  my $_classn = $meta->add_type({
  	name       => "ClassName",
  	parent     => $_str,
  	constraint => \&_is_class_loaded,
  	inlined    => sub { "Types::Standard::_is_class_loaded(do { my \$tmp = $_[1] })" },
  });
  
  $meta->add_type({
  	name       => "RoleName",
  	parent     => $_classn,
  	constraint => sub { not $_->can("new") },
  	inlined    => sub { "Types::Standard::_is_class_loaded(do { my \$tmp = $_[1] }) and not $_[1]\->can('new')" },
  });
  
  my $_ref = $meta->$add_core_type({
  	name       => "Ref",
  	parent     => $_def,
  	constraint => sub { ref $_ },
  	inlined    => sub { "!!ref($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Ref') unless @_;
  		
  		my $reftype = shift;
  		Types::TypeTiny::StringLike->check($reftype)
  			or _croak("Parameter to Ref[`a] expected to be string; got $reftype");
  		
  		$reftype = "$reftype";
  		return sub {
  			ref($_[0]) and Scalar::Util::reftype($_[0]) eq $reftype;
  		}
  	},
  	inline_generator => sub
  	{
  		my $reftype = shift;
  		return sub {
  			my $v = $_[1];
  			"ref($v) and Scalar::Util::reftype($v) eq q($reftype)";
  		};
  	},
  	deep_explanation => sub {
  		require B;
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		return if $type->check($value);
  		my $reftype = Scalar::Util::reftype($value);
  		return [
  			sprintf('"%s" constrains reftype(%s) to be equal to %s', $type, $varname, B::perlstring($param)),
  			sprintf('reftype(%s) is %s', $varname, defined($reftype) ? B::perlstring($reftype) : "undef"),
  		];
  	},
  });
  
  $meta->$add_core_type({
  	name       => "CodeRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "CODE" },
  	inlined    => sub { "ref($_[1]) eq 'CODE'" },
  });
  
  $meta->$add_core_type({
  	name       => "RegexpRef",
  	parent     => $_ref,
  	constraint => sub { ref($_) && !!re::is_regexp($_) },
  	inlined    => sub { "ref($_[1]) && !!re::is_regexp($_[1])" },
  });
  
  $meta->$add_core_type({
  	name       => "GlobRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "GLOB" },
  	inlined    => sub { "ref($_[1]) eq 'GLOB'" },
  });
  
  $meta->$add_core_type({
  	name       => "FileHandle",
  	parent     => $_ref,
  	constraint => sub {
  		(ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
  		or (blessed($_) && $_->isa("IO::Handle"))
  	},
  	inlined    => sub {
  		"(ref($_[1]) eq \"GLOB\" && Scalar::Util::openhandle($_[1])) ".
  		"or (Scalar::Util::blessed($_[1]) && $_[1]\->isa(\"IO::Handle\"))"
  	},
  });
  
  my $_arr = $meta->$add_core_type({
  	name       => "ArrayRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "ARRAY" },
  	inlined    => sub { "ref($_[1]) eq 'ARRAY'" },
  	constraint_generator => LazyLoad(ArrayRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ArrayRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ArrayRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ArrayRef => 'coercion_generator'),
  });
  
  my $_hash = $meta->$add_core_type({
  	name       => "HashRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "HASH" },
  	inlined    => sub { "ref($_[1]) eq 'HASH'" },
  	constraint_generator => LazyLoad(HashRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(HashRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(HashRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(HashRef => 'coercion_generator'),
  	my_methods => {
  		hashref_allows_key => sub {
  			my $self = shift;
  			Str()->check($_[0]);
  		},
  		hashref_allows_value => sub {
  			my $self = shift;
  			my ($key, $value) = @_;
  			
  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==HashRef();
  			
  			my $href  = $self->find_parent(sub { $_->has_parent && $_->parent==HashRef() });
  			my $param = $href->type_parameter;
  			
  			Str()->check($key) and $param->check($value);
  		},
  	},
  });
  
  $meta->$add_core_type({
  	name       => "ScalarRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "SCALAR" or ref $_ eq "REF" },
  	inlined    => sub { "ref($_[1]) eq 'SCALAR' or ref($_[1]) eq 'REF'" },
  	constraint_generator => LazyLoad(ScalarRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ScalarRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ScalarRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ScalarRef => 'coercion_generator'),
  });
  
  my $_obj = $meta->$add_core_type({
  	name       => "Object",
  	parent     => $_ref,
  	constraint => sub { blessed $_ },
  	inlined    => sub { "Scalar::Util::blessed($_[1])" },
  });
  
  $meta->$add_core_type({
  	name       => "Maybe",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Maybe') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Maybe[`a] expected to be a type constraint; got $param");
  		
  		my $param_compiled_check = $param->compiled_check;
  		my @xsub;
  		if (Type::Tiny::_USE_XS)
  		{
  			my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  			push @xsub, Type::Tiny::XS::get_coderef_for("Maybe[$paramname]")
  				if $paramname;
  		}
  		elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  		{
  			require Mouse::Util::TypeConstraints;
  			my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_Maybe_for");
  			push @xsub, $maker->($param) if $maker;
  		}
  		
  		return(
  			sub
  			{
  				my $value = shift;
  				return !!1 unless defined $value;
  				return $param->check($value);
  			},
  			@xsub,
  		);
  	},
  	inline_generator => sub {
  		my $param = shift;
  		
  		my $param_compiled_check = $param->compiled_check;
  		if (Type::Tiny::_USE_XS)
  		{
  			my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  			my $xsubname  = Type::Tiny::XS::get_subname_for("Maybe[$paramname]");
  			return sub { "$xsubname\($_[1]\)" } if $xsubname;
  		}
  		
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!defined($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s is defined', Type::Tiny::_dd($value)),
  			sprintf('"%s" constrains the value with "%s" if it is defined', $type, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  my $_map = $meta->$add_core_type({
  	name       => "Map",
  	parent     => $_hash,
  	constraint_generator => LazyLoad(Map => 'constraint_generator'),
  	inline_generator     => LazyLoad(Map => 'inline_generator'),
  	deep_explanation     => LazyLoad(Map => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Map => 'coercion_generator'),
  	my_methods => {
  		hashref_allows_key => sub {
  			my $self = shift;
  			my ($key) = @_;
  			
  			return Str()->check($key) if $self==Map();
  			
  			my $map = $self->find_parent(sub { $_->has_parent && $_->parent==Map() });
  			my ($kcheck, $vcheck) = @{ $map->parameters };
  			
  			($kcheck or Any())->check($key);
  		},
  		hashref_allows_value => sub {
  			my $self = shift;
  			my ($key, $value) = @_;
  			
  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==Map();
  			
  			my $map = $self->find_parent(sub { $_->has_parent && $_->parent==Map() });
  			my ($kcheck, $vcheck) = @{ $map->parameters };
  			
  			($kcheck or Any())->check($key)
  				and ($vcheck or Any())->check($value);
  		},
  	},
  });
  
  my $_Optional = $meta->add_type({
  	name       => "Optional",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Optional') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Optional[`a] expected to be a type constraint; got $param");
  		
  		sub { $param->check($_[0]) }
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			$param->inline_check($v);
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s exists', $varname),
  			sprintf('"%s" constrains %s with "%s" if it exists', $type, $varname, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  sub slurpy {
  	my $t = shift;
  	wantarray ? (+{ slurpy => $t }, @_) : +{ slurpy => $t };
  }
  
  $meta->$add_core_type({
  	name       => "Tuple",
  	parent     => $_arr,
  	name_generator => sub
  	{
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], map { ref($_) eq "HASH" ? sprintf("slurpy %s", $_->{slurpy}) : $_ } @a);
  	},
  	constraint_generator => LazyLoad(Tuple => 'constraint_generator'),
  	inline_generator     => LazyLoad(Tuple => 'inline_generator'),
  	deep_explanation     => LazyLoad(Tuple => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Tuple => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "Dict",
  	parent     => $_hash,
  	name_generator => sub
  	{
  		my ($s, @p) = @_;
  		my $l = ref($p[-1]) eq q(HASH) ? pop(@p)->{slurpy} : undef;
  		my %a = @p;
  		sprintf('%s[%s%s]', $s, join(q[,], map sprintf("%s=>%s", $_, $a{$_}), sort keys %a), $l ? ",slurpy $l" : '');
  	},
  	constraint_generator => LazyLoad(Dict => 'constraint_generator'),
  	inline_generator     => LazyLoad(Dict => 'inline_generator'),
  	deep_explanation     => LazyLoad(Dict => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Dict => 'coercion_generator'),
  	my_methods => {
  		dict_is_slurpy => sub
  		{
  			my $self = shift;
  			
  			return !!0 if $self==Dict();
  			
  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			ref($dict->parameters->[-1]) eq q(HASH)
  				? $dict->parameters->[-1]{slurpy}
  				: !!0
  		},
  		hashref_allows_key => sub
  		{
  			my $self = shift;
  			my ($key) = @_;
  			
  			return Str()->check($key) if $self==Dict();
  			
  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			my %params;
  			my $slurpy = $dict->my_dict_is_slurpy;
  			if ($slurpy)
  			{
  				my @args = @{$dict->parameters};
  				pop @args;
  				%params = @args;
  			}
  			else
  			{
  				%params = @{ $dict->parameters }
  			}
  			
  			return !!1
  				if exists($params{$key});
  			return !!0
  				if !$slurpy;
  			return Str()->check($key)
  				if $slurpy==Any() || $slurpy==Item() || $slurpy==Defined() || $slurpy==Ref();
  			return $slurpy->my_hashref_allows_key($key)
  				if $slurpy->is_a_type_of(HashRef());
  			return !!0;
  		},
  		hashref_allows_value => sub
  		{
  			my $self = shift;
  			my ($key, $value) = @_;
  			
  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==Dict();
  			
  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			my %params;
  			my $slurpy = $dict->my_dict_is_slurpy;
  			if ($slurpy)
  			{
  				my @args = @{$dict->parameters};
  				pop @args;
  				%params = @args;
  			}
  			else
  			{
  				%params = @{ $dict->parameters }
  			}
  			
  			return !!1
  				if exists($params{$key}) && $params{$key}->check($value);
  			return !!0
  				if !$slurpy;
  			return !!1
  				if $slurpy==Any() || $slurpy==Item() || $slurpy==Defined() || $slurpy==Ref();
  			return $slurpy->my_hashref_allows_value($key, $value)
  				if $slurpy->is_a_type_of(HashRef());
  			return !!0;
  		},
  	},
  });
  
  use overload ();
  $meta->add_type({
  	name       => "Overload",
  	parent     => $_obj,
  	constraint => sub { overload::Overloaded($_) },
  	inlined    => sub { "Scalar::Util::blessed($_[1]) and overload::Overloaded($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Overload') unless @_;
  		
  		my @operations = map {
  			Types::TypeTiny::StringLike->check($_)
  				? "$_"
  				: _croak("Parameters to Overload[`a] expected to be a strings; got $_");
  		} @_;
  		
  		return sub {
  			my $value = shift;
  			for my $op (@operations) {
  				return unless overload::Method($value, $op);
  			}
  			return !!1;
  		}
  	},
  	inline_generator => sub {
  		my @operations = @_;
  		return sub {
  			my $v = $_[1];
  			join " and ",
  				"Scalar::Util::blessed($v)",
  				map "overload::Method($v, q[$_])", @operations;
  		};
  	},
  });
  
  our %_StrMatch;
  $meta->add_type({
  	name       => "StrMatch",
  	parent     => $_str,
  	constraint_generator => sub
  	{
  		return $meta->get_type('StrMatch') unless @_;
  		
  		my ($regexp, $checker) = @_;
  		
  		ref($regexp) eq 'Regexp'
  			or _croak("First parameter to StrMatch[`a] expected to be a Regexp; got $regexp");
  		
  		if (@_ > 1)
  		{
  			$checker = Types::TypeTiny::to_TypeTiny($checker);
  			Types::TypeTiny::TypeTiny->check($checker)
  				or _croak("Second parameter to StrMatch[`a] expected to be a type constraint; got $checker")
  		}
  		
  		$checker
  			? sub {
  				my $value = shift;
  				return if ref($value);
  				my @m = ($value =~ $regexp);
  				$checker->check(\@m);
  			}
  			: sub {
  				my $value = shift;
  				!ref($value) and $value =~ $regexp;
  			}
  		;
  	},
  	inline_generator => sub
  	{
  		require B;
  		my ($regexp, $checker) = @_;
  		my $regexp_string = "$regexp";
  		$_StrMatch{$regexp_string} = $regexp;
  		if ($checker)
  		{
  			return unless $checker->can_be_inlined;
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and do { my \$m = [$v =~ \$Types::Standard::_StrMatch{%s}]; %s }",
  					B::perlstring($regexp_string),
  					$checker->inline_check('$m'),
  				;
  			};
  		}
  		else
  		{
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and $v =~ \$Types::Standard::_StrMatch{%s}",
  					B::perlstring($regexp_string),
  				;
  			};
  		}
  	},
  });
  
  $meta->add_type({
  	name       => "OptList",
  	parent     => $_arr,
  	constraint => sub {
  		for my $inner (@$_) {
  			return unless ref($inner) eq q(ARRAY);
  			return unless @$inner == 2;
  			return unless is_Str($inner->[0]);
  		}
  		return !!1;
  	},
  	inlined     => sub {
  		my ($self, $var) = @_;
  		my $Str_check = Str()->inline_check('$inner->[0]');
  		my @code = 'do { my $ok = 1; ';
  		push @code,   sprintf('for my $inner (@{%s}) { no warnings; ', $var);
  		push @code,   sprintf('($ok=0) && last unless ref($inner) eq q(ARRAY) && @$inner == 2 && (%s); ', $Str_check);
  		push @code,   '} ';
  		push @code, '$ok }';
  		return (undef, join(q( ), @code));
  	},
  });
  
  $meta->add_type({
  	name       => "Tied",
  	parent     => $_ref,
  	constraint => sub {
  		!!tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_})
  	},
  	inlined    => sub {
  		my ($self, $var) = @_;
  		$self->parent->inline_check($var)
  		. " and !!tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var})"
  	},
  	name_generator => sub
  	{
  		my $self  = shift;
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require B;
  			return sprintf("%s[%s]", $self, B::perlstring($param));
  		}
  		return sprintf("%s[%s]", $self, $param);
  	},
  	constraint_generator => sub
  	{
  		return $meta->get_type('Tied') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		
  		my $check = $param->compiled_check;
  		return sub {
  			$check->(tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_}));
  		};
  	},
  	inline_generator => sub {
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		return unless $param->can_be_inlined;
  		
  		return sub {
  			require B;
  			my $var = $_[1];
  			sprintf(
  				"%s and do { my \$TIED = tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var}); %s }",
  				Ref()->inline_check($var),
  				$param->inline_check('$TIED')
  			);
  		};
  	},
  });
  
  $meta->add_type({
  	name       => "InstanceOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('InstanceOf') unless @_;
  		require Type::Tiny::Class;
  		my @classes = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Class"->new(class => $_, display_name => sprintf('InstanceOf[%s]', B::perlstring($_)))
  		} @_;
  		return $classes[0] if @classes == 1;
  		
  		require B;
  		require Type::Tiny::Union;
  		return "Type::Tiny::Union"->new(
  			type_constraints => \@classes,
  			display_name     => sprintf('InstanceOf[%s]', join q[,], map B::perlstring($_->class), @classes),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "ConsumerOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('ConsumerOf') unless @_;
  		require B;
  		require Type::Tiny::Role;
  		my @roles = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Role"->new(role => $_, display_name => sprintf('ConsumerOf[%s]', B::perlstring($_)))
  		} @_;
  		return $roles[0] if @roles == 1;
  		
  		require Type::Tiny::Intersection;
  		return "Type::Tiny::Intersection"->new(
  			type_constraints => \@roles,
  			display_name     => sprintf('ConsumerOf[%s]', join q[,], map B::perlstring($_->role), @roles),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "HasMethods",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('HasMethods') unless @_;
  		require B;
  		require Type::Tiny::Duck;
  		return "Type::Tiny::Duck"->new(
  			methods      => \@_,
  			display_name => sprintf('HasMethods[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "Enum",
  	parent     => $_str,
  	constraint_generator => sub {
  		return $meta->get_type('Enum') unless @_;
  		require B;
  		require Type::Tiny::Enum;
  		return "Type::Tiny::Enum"->new(
  			values       => \@_,
  			display_name => sprintf('Enum[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_coercion({
  	name               => "MkOpt",
  	type_constraint    => $meta->get_type("OptList"),
  	type_coercion_map  => [
  		$_arr,    q{ Exporter::Tiny::mkopt($_) },
  		$_hash,   q{ Exporter::Tiny::mkopt($_) },
  		$_undef,  q{ [] },
  	],
  });
  
  $meta->add_coercion({
  	name               => "Join",
  	type_constraint    => $_str,
  	coercion_generator => sub {
  		my ($self, $target, $sep) = @_;
  		Types::TypeTiny::StringLike->check($sep)
  			or _croak("Parameter to Join[`a] expected to be a string; got $sep");
  		require B;
  		$sep = B::perlstring($sep);
  		return (ArrayRef(), qq{ join($sep, \@\$_) });
  	},
  });
  
  $meta->add_coercion({
  	name               => "Split",
  	type_constraint    => $_arr,
  	coercion_generator => sub {
  		my ($self, $target, $re) = @_;
  		ref($re) eq q(Regexp)
  			or _croak("Parameter to Split[`a] expected to be a regular expresssion; got $re");
  		my $regexp_string = "$re";
  		$regexp_string =~ s/\\\//\\\\\//g; # toothpicks
  		return (Str(), qq{ [split /$regexp_string/, \$_] });
  	},
  });
  
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords booleans vstrings typeglobs
  
  =encoding utf-8
  
  =for stopwords datetimes
  
  =head1 NAME
  
  Types::Standard - bundled set of built-in types for Type::Tiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> bundles a few types which seem to be useful.
  
  =head2 Moose-like
  
  The following types are similar to those described in
  L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< Any >>
  
  Absolutely any value passes this type constraint (even undef).
  
  =item C<< Item >>
  
  Essentially the same as C<Any>. All other type constraints in this library
  inherit directly or indirectly from C<Item>.
  
  =item C<< Bool >>
  
  Values that are reasonable booleans. Accepts 1, 0, the empty string and
  undef.
  
  =item C<< Maybe[`a] >>
  
  Given another type constraint, also accepts undef. For example,
  C<< Maybe[Int] >> accepts all integers plus undef.
  
  =item C<< Undef >>
  
  Only undef passes this type constraint.
  
  =item C<< Defined >>
  
  Only undef fails this type constraint.
  
  =item C<< Value >>
  
  Any defined, non-reference value.
  
  =item C<< Str >>
  
  Any string.
  
  (The only difference between C<Value> and C<Str> is that the former accepts
  typeglobs and vstrings.)
  
  Other customers also bought: C<< StringLike >> from L<Types::TypeTiny>.
  
  =item C<< Num >>
  
  See C<LaxNum> and C<StrictNum> below.
  
  =item C<< Int >>
  
  An integer; that is a string of digits 0 to 9, optionally prefixed with a
  hyphen-minus character.
  
  =item C<< ClassName >>
  
  The name of a loaded package. The package must have C<< @ISA >> or
  C<< $VERSION >> defined, or must define at least one sub to be considered
  a loaded package.
  
  =item C<< RoleName >>
  
  Like C<< ClassName >>, but the package must I<not> define a method called
  C<new>. This is subtly different from Moose's type constraint of the same
  name; let me know if this causes you any problems. (I can't promise I'll
  change anything though.)
  
  =item C<< Ref[`a] >>
  
  Any defined reference value, including blessed objects.
  
  Unlike Moose, C<Ref> is a parameterized type, allowing Scalar::Util::reftype
  checks, a la
  
     Ref["HASH"]  # hashrefs, including blessed hashrefs
  
  =item C<< ScalarRef[`a] >>
  
  A value where C<< ref($value) eq "SCALAR" or ref($value) eq "REF" >>.
  
  If parameterized, the referred value must pass the additional constraint.
  For example, C<< ScalarRef[Int] >> must be a reference to a scalar which
  holds an integer value.
  
  =item C<< ArrayRef[`a] >>
  
  A value where C<< ref($value) eq "ARRAY" >>.
  
  If parameterized, the elements of the array must pass the additional
  constraint. For example, C<< ArrayRef[Num] >> must be a reference to an
  array of numbers.
  
  Other customers also bought: C<< ArrayLike >> from L<Types::TypeTiny>.
  
  =item C<< HashRef[`a] >>
  
  A value where C<< ref($value) eq "HASH" >>.
  
  If parameterized, the values of the hash must pass the additional
  constraint. For example, C<< HashRef[Num] >> must be a reference to an
  hash where the values are numbers. The hash keys are not constrained,
  but Perl limits them to strings; see C<Map> below if you need to further
  constrain the hash values.
  
  Other customers also bought: C<< HashLike >> from L<Types::TypeTiny>.
  
  =item C<< CodeRef >>
  
  A value where C<< ref($value) eq "CODE" >>.
  
  Other customers also bought: C<< CodeLike >> from L<Types::TypeTiny>.
  
  =item C<< RegexpRef >>
  
  A value where C<< ref($value) eq "Regexp" >>.
  
  =item C<< GlobRef >>
  
  A value where C<< ref($value) eq "GLOB" >>.
  
  =item C<< FileHandle >>
  
  A file handle.
  
  =item C<< Object >>
  
  A blessed object.
  
  (This also accepts regexp refs.)
  
  =back
  
  =head2 Structured
  
  OK, so I stole some ideas from L<MooseX::Types::Structured>.
  
  =over
  
  =item C<< Map[`k, `v] >>
  
  Similar to C<HashRef> but parameterized with type constraints for both the
  key and value. The constraint for keys would typically be a subtype of
  C<Str>.
  
  =item C<< Tuple[...] >>
  
  Subtype of C<ArrayRef>, accepting an list of type constraints for
  each slot in the array.
  
  C<< Tuple[Int, HashRef] >> would match C<< [1, {}] >> but not C<< [{}, 1] >>.
  
  =item C<< Dict[...] >>
  
  Subtype of C<HashRef>, accepting an list of type constraints for
  each slot in the hash.
  
  For example C<< Dict[name => Str, id => Int] >> allows
  C<< { name => "Bob", id => 42 } >>.
  
  =item C<< Optional[`a] >>
  
  Used in conjunction with C<Dict> and C<Tuple> to specify slots that are
  optional and may be omitted (but not necessarily set to an explicit undef).
  
  C<< Dict[name => Str, id => Optional[Int]] >> allows C<< { name => "Bob" } >>
  but not C<< { name => "Bob", id => "BOB" } >>.
  
  Note that any use of C<< Optional[`a] >> outside the context of
  parameterized C<Dict> and C<Tuple> type constraints makes little sense,
  and its behaviour is undefined. (An exception: it is used by
  L<Type::Params> for a similar purpose to how it's used in C<Tuple>.)
  
  =back
  
  This module also exports a C<slurpy> function, which can be used as
  follows.
  
  It can cause additional trailing values in a C<Tuple> to be slurped
  into a structure and validated. For example, slurping into an ArrayRef:
  
     my $type = Tuple[Str, slurpy ArrayRef[Int]];
     
     $type->( ["Hello"] );                # ok
     $type->( ["Hello", 1, 2, 3] );       # ok
     $type->( ["Hello", [1, 2, 3]] );     # not ok
  
  Or into a hashref:
  
     my $type2 = Tuple[Str, slurpy Map[Int, RegexpRef]];
     
     $type2->( ["Hello"] );                               # ok
     $type2->( ["Hello", 1, qr/one/i, 2, qr/two/] );      # ok
  
  It can cause additional values in a C<Dict> to be slurped into a
  hashref and validated:
  
     my $type3 = Dict[ values => ArrayRef, slurpy HashRef[Str] ];
     
     $type3->( { values => [] } );                        # ok
     $type3->( { values => [], name => "Foo" } );         # ok
     $type3->( { values => [], name => [] } );            # not ok
  
  In either C<Tuple> or C<Dict>, C<< slurpy Any >> can be used to indicate
  that additional values are acceptable, but should not be constrained in
  any way. (C<< slurpy Any >> is an optimized code path.)
  
  =begin trustme
  
  =item slurpy
  
  =end trustme
  
  =head2 Objects
  
  OK, so I stole some ideas from L<MooX::Types::MooseLike::Base>.
  
  =over
  
  =item C<< InstanceOf[`a] >>
  
  Shortcut for a union of L<Type::Tiny::Class> constraints.
  
  C<< InstanceOf["Foo", "Bar"] >> allows objects blessed into the C<Foo>
  or C<Bar> classes, or subclasses of those.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< ConsumerOf[`a] >>
  
  Shortcut for an intersection of L<Type::Tiny::Role> constraints.
  
  C<< ConsumerOf["Foo", "Bar"] >> allows objects where C<< $o->DOES("Foo") >>
  and C<< $o->DOES("Bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< HasMethods[`a] >>
  
  Shortcut for a L<Type::Tiny::Duck> constraint.
  
  C<< HasMethods["foo", "bar"] >> allows objects where C<< $o->can("foo") >>
  and C<< $o->can("bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =back
  
  =head2 More
  
  There are a few other types exported by this function:
  
  =over
  
  =item C<< Overload[`a] >>
  
  With no parameters, checks that the value is an overloaded object. Can
  be given one or more string parameters, which are specific operations
  to check are overloaded. For example, the following checks for objects
  which overload addition and subtraction.
  
     Overload["+", "-"]
  
  =item C<< Tied[`a] >>
  
  A reference to a tied scalar, array or hash.
  
  Can be parameterized with a type constraint which will be applied to
  the object returned by the C<< tied() >> function. As a convenience,
  can also be parameterized with a string, which will be inflated to a
  L<Type::Tiny::Class>.
  
     use Types::Standard qw(Tied);
     use Type::Utils qw(class_type);
     
     my $My_Package = class_type { class => "My::Package" };
     
     tie my %h, "My::Package";
     \%h ~~ Tied;                   # true
     \%h ~~ Tied[ $My_Package ];    # true
     \%h ~~ Tied["My::Package"];    # true
     
     tie my $s, "Other::Package";
     \$s ~~ Tied;                   # true
     $s  ~~ Tied;                   # false !!
  
  If you need to check that something is specifically a reference to
  a tied hash, use an intersection:
  
     use Types::Standard qw( Tied HashRef );
     
     my $TiedHash = (Tied) & (HashRef);
     
     tie my %h, "My::Package";
     tie my $s, "Other::Package";
     
     \%h ~~ $TiedHash;     # true
     \$s ~~ $TiedHash;     # false
  
  =item C<< StrMatch[`a] >>
  
  A string that matches a regular expression:
  
     declare "Distance",
        as StrMatch[ qr{^([0-9]+)\s*(mm|cm|m|km)$} ];
  
  You can optionally provide a type constraint for the array of subexpressions:
  
     declare "Distance",
        as StrMatch[
           qr{^([0-9]+)\s*(.+)$},
           Tuple[
              Int,
              enum(DistanceUnit => [qw/ mm cm m km /]),
           ],
        ];
  
  =item C<< Enum[`a] >>
  
  As per MooX::Types::MooseLike::Base:
  
     has size => (is => "ro", isa => Enum[qw( S M L XL XXL )]);
  
  =item C<< OptList >>
  
  An arrayref of arrayrefs in the style of L<Data::OptList> output.
  
  =item C<< LaxNum >>, C<< StrictNum >>
  
  In Moose 2.09, the C<Num> type constraint implementation was changed from
  being a wrapper around L<Scalar::Util>'s C<looks_like_number> function to
  a stricter regexp (which disallows things like "-Inf" and "Nan").
  
  Types::Standard provides I<both> implementations. C<LaxNum> is measurably
  faster.
  
  The C<Num> type constraint is currently an alias for C<LaxNum> unless you
  set the C<PERL_TYPES_STANDARD_STRICTNUM> environment variable to true before
  loading Types::Standard, in which case it becomes an alias for C<StrictNum>.
  The constant C<< Types::Standard::STRICTNUM >> can be used to check if
  C<Num> is being strict.
  
  Most people should probably use C<Num> or C<StrictNum>. Don't explicitly
  use C<LaxNum> unless you specifically need an attribute which will accept
  things like "Inf".
  
  =back
  
  =head2 Coercions
  
  None of the types in this type library have any coercions by default.
  However some standalone coercions may be exported. These can be combined
  with type constraints using the C<< plus_coercions >> method.
  
  =over
  
  =item C<< MkOpt >>
  
  A coercion from C<ArrayRef>, C<HashRef> or C<Undef> to C<OptList>. Example
  usage in a Moose attribute:
  
     use Types::Standard qw( OptList MkOpt );
     
     has options => (
        is     => "ro",
        isa    => OptList->plus_coercions( MkOpt ),
        coerce => 1,
     );
  
  =item C<< Split[`a] >>
  
  Split a string on a regexp.
  
     use Types::Standard qw( ArrayRef Str Split );
     
     has name => (
        is     => "ro",
        isa    => (ArrayRef[Str])->plus_coercions(Split[qr/\s/]),
        coerce => 1,
     );
  
  =item C<< Join[`a] >>
  
  Join an array of strings with a delimiter.
  
     use Types::Standard qw( Str Join );
     
     my $FileLines = Str->plus_coercions(Join["\n"]);
     
     has file_contents => (
        is     => "ro",
        isa    => $FileLines,
        coerce => 1,
     );
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< Types::Standard::STRICTNUM >>
  
  Indicates whether C<Num> is an alias for C<StrictNum>. (It is usually an
  alias for C<LaxNum>.)
  
  =back
  
  =begin private
  
  =item Stringable
  
  =item LazyLoad
  
  =end private
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>,
  L<MooseX::Types::Structured>.
  
  L<Types::XSD> provides some type constraints based on XML Schema's data
  types; this includes constraints for ISO8601-formatted datetimes, integer
  ranges (e.g. C<< PositiveInteger[maxInclusive=>10] >> and so on.
  
  L<Types::Encodings> provides C<Bytes> and C<Chars> type constraints that
  were formerly found in Types::Standard.
  
  L<Types::Common::Numeric> and L<Types::Common::String> provide replacements
  for L<MooseX::Types::Common>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD

$fatpacked{"Types/Standard/ArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_ARRAYREF';
  package Types::Standard::ArrayRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ArrayRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ArrayRef::VERSION   = '1.000005';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ArrayRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ArrayRef[`a] expected to be a type constraint; got $param");
  	
  	my $param_compiled_check = $param->compiled_check;
  	my $xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		$xsub = Type::Tiny::XS::get_coderef_for("ArrayRef[$paramname]")
  			if $paramname;
  	}
  	elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_ArrayRef_for");
  		$xsub = $maker->($param) if $maker;
  	}
  	
  	return (
  		sub
  		{
  			my $array = shift;
  			$param->check($_) || return for @$array;
  			return !!1;
  		},
  		$xsub,
  	);
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	
  	my $param_compiled_check = $param->compiled_check;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		my $xsubname  = Type::Tiny::XS::get_subname_for("ArrayRef[$paramname]");
  		return sub { "$xsubname\($_[1]\)" } if $xsubname;
  	}
  	
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'ARRAY' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (\@{$v}) { "
  		.    "(\$ok = 0, last) unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $i (0 .. $#$value)
  	{
  		my $item = $value->[$i];
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the array with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->[%d]', $varname, $i)) },
  		]
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @new) = ($_, 0);';
  			push @code,    'for (@$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('push @new, (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my @new;
  				for my $item (@$value)
  				{
  					return $value unless $coercable_item->check($item);
  					push @new, $param->coerce($item);
  				}
  				return \@new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ArrayRef - internals for the Types::Standard ArrayRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_ARRAYREF

$fatpacked{"Types/Standard/Dict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_DICT';
  package Types::Standard::Dict;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Dict::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Dict::VERSION   = '1.000005';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_optional = Types::Standard::Optional;
  my $_hash     = Types::Standard::HashRef;
  my $_map      = Types::Standard::Map;
  my $_any      = Types::Standard::Any;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my %constraints = @_;
  	my %is_optional;
  	
  	while (my ($k, $v) = each %constraints)
  	{
  		$constraints{$k} = Types::TypeTiny::to_TypeTiny($v);
  		$is_optional{$k} = !!$constraints{$k}->is_strictly_a_type_of($_optional);
  		Types::TypeTiny::TypeTiny->check($v)
  			or _croak("Parameter to Dict[`a] for key '$k' expected to be a type constraint; got $v");
  	}
  	
  	return sub
  	{
  		my $value = $_[0];
  		if ($slurpy)
  		{
  			my %tmp = map {
  				exists($constraints{$_}) ? () : ($_ => $value->{$_})
  			} keys %$value;
  			return unless $slurpy->check(\%tmp);
  		}
  		else
  		{
  			exists($constraints{$_}) || return for sort keys %$value;
  		}
  		for my $k (sort keys %constraints) {
  			exists($value->{$k}) or ($is_optional{$k} ? next : return);
  			$constraints{$k}->check($value->{$k}) or return;
  		}
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	# We can only inline a parameterized Dict if all the
  	# constraints inside can be inlined.
  	
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	return if $slurpy && !$slurpy->can_be_inlined;
  	
  	# Is slurpy a very loose type constraint?
  	# i.e. Any, Item, Defined, Ref, or HashRef
  	my $slurpy_is_any = $slurpy && $_hash->is_a_type_of( $slurpy );
  	
  	# Is slurpy a parameterized Map, or expressable as a parameterized Map?
  	my $slurpy_is_map = $slurpy
  		&& $slurpy->is_parameterized
  		&& ((
  			$slurpy->parent->strictly_equals($_map)
  			&& $slurpy->parameters
  		)||(
  			$slurpy->parent->strictly_equals($_hash)
  			&& [ $_any, $slurpy->parameters->[0] ]
  		));
  	
  	my %constraints = @_;
  	for my $c (values %constraints)
  	{
  		next if $c->can_be_inlined;
  		return;
  	}
  	
  	my $regexp = join "|", map quotemeta, sort keys %constraints;
  	return sub
  	{
  		require B;
  		my $h = $_[1];
  		join " and ",
  			"ref($h) eq 'HASH'",
  			( $slurpy_is_any ? ()
  			: $slurpy_is_map ? do {
  				'(not grep {'
  				."my \$v = ($h)->{\$_};"
  				.sprintf(
  					'not((/\\A(?:%s)\\z/) or ((%s) and (%s)))',
  					$regexp,
  					$slurpy_is_map->[0]->inline_check('$_'),
  					$slurpy_is_map->[1]->inline_check('$v'),
  				) ."} keys \%{$h})"
  			}
  			: $slurpy ? do {
  				'do {'
  				. "my \$slurpy_tmp = +{ map /\\A(?:$regexp)\\z/ ? () : (\$_ => ($h)->{\$_}), keys \%{$h} };"
  				. $slurpy->inline_check('$slurpy_tmp')
  				. '}'
  			}
  			: "not(grep !/\\A(?:$regexp)\\z/, keys \%{$h})" ),
  			( map {
  				my $k = B::perlstring($_);
  				$constraints{$_}->is_strictly_a_type_of( $_optional )
  					? sprintf('(!exists %s->{%s} or %s)', $h, $k, $constraints{$_}->inline_check("$h\->{$k}"))
  					: ( "exists($h\->{$k})", $constraints{$_}->inline_check("$h\->{$k}") )
  			} sort keys %constraints ),
  	}
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my @params = @{ $type->parameters };
  	
  	my $slurpy = ref($params[-1]) eq q(HASH) ? pop(@params)->{slurpy} : undef;
  	my %constraints = @params;
  			
  	for my $k (sort keys %constraints)
  	{
  		next if $constraints{$k}->parent == Types::Standard::Optional && !exists $value->{$k};
  		next if $constraints{$k}->check($value->{$k});
  		
  		return [
  			sprintf('"%s" requires key %s to appear in hash', $type, B::perlstring($k))
  		] unless exists $value->{$k};
  		
  		return [
  			sprintf('"%s" constrains value at key %s of hash with "%s"', $type, B::perlstring($k), $constraints{$k}),
  			@{ $constraints{$k}->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	if ($slurpy)
  	{
  		my %tmp = map {
  			exists($constraints{$_}) ? () : ($_ => $value->{$_})
  		} keys %$value;
  		
  		my $explain = $slurpy->validate_explain(\%tmp, '$slurpy');
  		return [
  			sprintf('"%s" requires the hashref of additional key/value pairs to conform to "%s"', $type, $slurpy),
  			@$explain,
  		] if $explain;
  	}
  	else
  	{
  		for my $k (sort keys %$value)
  		{
  			return [
  				sprintf('"%s" does not allow key %s to appear in hash', $type, B::perlstring($k))
  			] unless exists $constraints{$k};
  		}
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  my $label_counter = 0;
  our ($keycheck_counter, @KEYCHECK) = -1;
  sub __coercion_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my ($parent, $child, %dict) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $all_inlinable = 1;
  	for my $tc (values %dict)
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	$all_inlinable = 0 if $slurpy && !$slurpy->can_be_inlined;
  	$all_inlinable = 0 if $slurpy && $slurpy->has_coercion && !$slurpy->coercion->can_be_inlined;
  	
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			require B;
  			
  			my $keycheck = join "|", map quotemeta, sort { length($b) <=> length($a) or $a cmp $b } keys %dict;
  			$keycheck = $KEYCHECK[++$keycheck_counter] = qr{^($keycheck)$}ms; # regexp for legal keys
  			
  			my $label = sprintf("DICTLABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $tmp, %new) = ($_, 0);';
  			push @code,       "$label: {";
  			if ($slurpy)
  			{
  				push @code, sprintf('my $slurped = +{ map +($_=~$%s::KEYCHECK[%d])?():($_=>$orig->{$_}), keys %%$orig };', __PACKAGE__, $keycheck_counter);
  				if ($slurpy->has_coercion)
  				{
  					push @code, sprintf('my $coerced = %s;', $slurpy->coercion->inline_coercion('$slurped'));
  					push @code, sprintf('((%s)&&(%s))?(%%new=%%$coerced):(($return_orig = 1), last %s);', $_hash->inline_check('$coerced'), $slurpy->inline_check('$coerced'), $label);
  				}
  				else
  				{
  					push @code, sprintf('(%s)?(%%new=%%$slurped):(($return_orig = 1), last %s);', $slurpy->inline_check('$slurped'), $label);
  				}
  			}
  			else
  			{
  				push @code, sprintf('($_ =~ $%s::KEYCHECK[%d])||(($return_orig = 1), last %s) for sort keys %%$orig;', __PACKAGE__, $keycheck_counter, $label);
  			}
  			for my $k (keys %dict)
  			{
  				my $ct = $dict{$k};
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of($_optional);
  				my $K = B::perlstring($k);
  				
  				push @code, sprintf(
  					'if (exists $orig->{%s}) { $tmp = %s; (%s) ? ($new{%s}=$tmp) : ($return_orig=1 and last %s) }',
  					$K,
  					$ct_coerce
  						? $ct->coercion->inline_coercion("\$orig->{$K}")
  						: "\$orig->{$K}",
  					$ct->inline_check('$tmp'),
  					$K,
  					$label,
  				);
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			#warn "CODE:: @code";
  			"@code";
  		});
  	}
  	
  	else
  	{
  		my %is_optional = map {
  			; $_ => !!$dict{$_}->is_strictly_a_type_of($_optional)
  		} sort keys %dict;
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				
  				if ($slurpy)
  				{
  					my %slurped = map exists($dict{$_}) ? () : ($_ => $value->{$_}), keys %$value;
  					
  					if ($slurpy->check(\%slurped))
  					{
  						%new = %slurped;
  					}
  					elsif ($slurpy->has_coercion)
  					{
  						my $coerced = $slurpy->coerce(\%slurped);
  						$slurpy->check($coerced) ? (%new = %$coerced) : (return $value);
  					}
  					else
  					{
  						return $value;
  					}
  				}
  				else
  				{
  					for my $k (keys %$value)
  					{
  						return $value unless exists $dict{$k};
  					}
  				}
  
  				for my $k (keys %dict)
  				{
  					next if $is_optional{$k} and not exists $value->{$k};
  					
  					my $ct = $dict{$k};
  					my $x  = $ct->has_coercion ? $ct->coerce($value->{$k}) : $value->{$k};
  					
  					return $value unless $ct->check($x);
  					
  					$new{$k} = $x;
  				}
  				
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Dict - internals for the Types::Standard Dict type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_DICT

$fatpacked{"Types/Standard/HashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_HASHREF';
  package Types::Standard::HashRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::HashRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::HashRef::VERSION   = '1.000005';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::HashRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to HashRef[`a] expected to be a type constraint; got $param");
  	
  	my $param_compiled_check = $param->compiled_check;
  	my $xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		$xsub = Type::Tiny::XS::get_coderef_for("HashRef[$paramname]")
  			if $paramname;
  	}
  	elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_HashRef_for");
  		$xsub = $maker->($param) if $maker;
  	}
  	
  	return (
  		sub
  		{
  			my $hash = shift;
  			$param->check($_) || return for values %$hash;
  			return !!1;
  		},
  		$xsub,
  	);
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	
  	my $compiled = $param->compiled_check;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($compiled);
  		my $xsubname  = Type::Tiny::XS::get_subname_for("HashRef[$paramname]");
  		return sub { "$xsubname\($_[1]\)" } if $xsubname;
  	}
  	
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (values \%{$v}) { "
  		.    "(\$ok = 0, last) unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $k (sort keys %$value)
  	{
  		my $item = $value->{$k};
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the hash with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{$_} = (%s);', $param->coercion->inline_coercion('$orig->{$_}'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $coercable_item->check($value->{$k});
  					$new{$k} = $param->coerce($value->{$k});
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::HashRef - internals for the Types::Standard HashRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_HASHREF

$fatpacked{"Types/Standard/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_MAP';
  package Types::Standard::Map;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Map::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Map::VERSION   = '1.000005';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = Types::Standard->meta;
  
  no warnings;
  
  sub __constraint_generator
  {
  	return $meta->get_type('Map') unless @_;
  	
  	my ($keys, $values) = map Types::TypeTiny::to_TypeTiny($_), @_;
  	Types::TypeTiny::TypeTiny->check($keys)
  		or _croak("First parameter to Map[`k,`v] expected to be a type constraint; got $keys");
  	Types::TypeTiny::TypeTiny->check($values)
  		or _croak("Second parameter to Map[`k,`v] expected to be a type constraint; got $values");
  	
  	my @xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} ($keys, $values);
  		
  		if (@known == 2)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "Map[%s,%s]", @known
  			);
  			push @xsub, $xsub if $xsub;
  		}
  	}
  	
  	sub
  	{
  		my $hash = shift;
  		$keys->check($_)   || return for keys %$hash;
  		$values->check($_) || return for values %$hash;
  		return !!1;
  	}, @xsub;
  }
  
  sub __inline_generator
  {
  	my ($k, $v) = @_;
  	return unless $k->can_be_inlined && $v->can_be_inlined;
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} ($k, $v);
  		
  		if (@known == 2)
  		{
  			my $xsub = Type::Tiny::XS::get_subname_for(
  				sprintf "Map[%s,%s]", @known
  			);
  			return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  		}
  	}
  	
  	my $k_check = $k->inline_check('$k');
  	my $v_check = $v->inline_check('$v');
  	return sub {
  		my $h = $_[1];
  		"ref($h) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$v (values \%{$h}) { "
  		.    "(\$ok = 0, last) unless $v_check "
  		.  "}; "
  		.  "for my \$k (keys \%{$h}) { "
  		.    "(\$ok = 0, last) unless $k_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my ($kparam, $vparam) = @{ $type->parameters };
  	
  	for my $k (sort keys %$value)
  	{
  		unless ($kparam->check($k))
  		{
  			return [
  				sprintf('"%s" constrains each key in the hash with "%s"', $type, $kparam),
  				@{ $kparam->validate_explain($k, sprintf('key %s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  		
  		unless ($vparam->check($value->{$k}))
  		{
  			return [
  				sprintf('"%s" constrains each value in the hash with "%s"', $type, $vparam),
  				@{ $vparam->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $kparam, $vparam) = @_;
  	return unless $kparam->has_coercion || $vparam->has_coercion;
  	
  	my $kcoercable_item = $kparam->has_coercion ? $kparam->coercion->_source_type_union : $kparam;
  	my $vcoercable_item = $vparam->has_coercion ? $vparam->coercion->_source_type_union : $vparam;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ((!$kparam->has_coercion or $kparam->coercion->can_be_inlined)
  	and (!$vparam->has_coercion or $vparam->coercion->can_be_inlined)
  	and $kcoercable_item->can_be_inlined
  	and $vcoercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $kcoercable_item->inline_check('$_'));
  			push @code, sprintf('++$return_orig && last unless (%s);', $vcoercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{(%s)} = (%s);',
  				$kparam->has_coercion ? $kparam->coercion->inline_coercion('$_') : '$_',
  				$vparam->has_coercion ? $vparam->coercion->inline_coercion('$orig->{$_}') : '$orig->{$_}',
  			);
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $kcoercable_item->check($k) && $vcoercable_item->check($value->{$k});
  					$new{$kparam->has_coercion ? $kparam->coerce($k) : $k} =
  						$vparam->has_coercion ? $vparam->coerce($value->{$k}) : $value->{$k};
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Map - internals for the Types::Standard Map type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_MAP

$fatpacked{"Types/Standard/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_SCALARREF';
  package Types::Standard::ScalarRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ScalarRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ScalarRef::VERSION   = '1.000005';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ScalarRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ScalarRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $ref = shift;
  		$param->check($$ref) || return;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	return sub {
  		my $v = $_[1];
  		my $param_check = $param->inline_check("\${$v}");
  		"(ref($v) eq 'SCALAR' or ref($v) eq 'REF') and $param_check";
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $item ($$value)
  	{
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains the referenced scalar value with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('${%s}', $varname)) },
  		];
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $new) = ($_, 0);';
  			push @code,    'for ($$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('$new = (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\$new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my $new;
  				for my $item ($$value)
  				{
  					return $value unless $coercable_item->check($item);
  					$new = $param->coerce($item);
  				}
  				return \$new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ScalarRef - internals for the Types::Standard ScalarRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_SCALARREF

$fatpacked{"Types/Standard/Tuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_TUPLE';
  package Types::Standard::Tuple;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Tuple::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Tuple::VERSION   = '1.000005';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_Optional = Types::Standard::Optional;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  		Types::TypeTiny::TypeTiny->check($slurpy)
  			or _croak("Slurpy parameter to Tuple[...] expected to be a type constraint; got $slurpy");
  	}
  	
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	for (@constraints)
  	{
  		Types::TypeTiny::TypeTiny->check($_)
  			or _croak("Parameters to Tuple[...] expected to be type constraints; got $_");
  	}
  	
  	# By god, the Type::Tiny::XS API is currently horrible
  	my @xsub;
  	if (Type::Tiny::_USE_XS and !$slurpy)
  	{
  		my @known = map {
  			my $known;
  			$known = Type::Tiny::XS::is_known($_->compiled_check)
  				unless $_->is_strictly_a_type_of($_Optional);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "Tuple[%s]", join(',', @known)
  			);
  			push @xsub, $xsub if $xsub;
  		}
  	}
  	
  	my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @constraints;
  	my $slurp_hash  = $slurpy && $slurpy->is_a_type_of(Types::Standard::HashRef);
  	my $slurp_any   = $slurpy && $slurpy->equals(Types::Standard::Any);
  	
  	sub
  	{
  		my $value = $_[0];
  		if ($#constraints < $#$value)
  		{
  			return !!0 unless $slurpy;
  			my $tmp;
  			if ($slurp_hash)
  			{
  				($#$value - $#constraints+1) % 2 or return;
  				$tmp = +{@$value[$#constraints+1 .. $#$value]};
  				$slurpy->check($tmp) or return;
  			}
  			elsif (not $slurp_any)
  			{
  				$tmp = +[@$value[$#constraints+1 .. $#$value]];
  				$slurpy->check($tmp) or return;
  			}
  		}
  		for my $i (0 .. $#constraints)
  		{
  			($i > $#$value)
  				and return !!$is_optional[$i];
  			
  			$constraints[$i]->check($value->[$i])
  				or return !!0;
  		}
  		return !!1;
  	}, @xsub;
  }
  
  sub __inline_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = pop(@constraints)->{slurpy};
  	}
  	
  	return if grep { not $_->can_be_inlined } @constraints;
  	return if defined $slurpy && !$slurpy->can_be_inlined;
  	
  	if (Type::Tiny::_USE_XS and !$slurpy)
  	{
  		my @known = map {
  			my $known;
  			$known = Type::Tiny::XS::is_known($_->compiled_check)
  				unless $_->is_strictly_a_type_of($_Optional);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_subname_for(
  				sprintf "Tuple[%s]", join(',', @known)
  			);
  			return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  		}
  	}
  	
  	my $tmpl = "do { my \$tmp = +[\@{%s}[%d..\$#{%s}]]; %s }";
  	my $slurpy_any;
  	if (defined $slurpy)
  	{
  		$tmpl = 'do { my ($orig, $from, $to) = (%s, %d, $#{%s});'
  			.    '($to-$from % 2) and do { my $tmp = +{@{$orig}[$from..$to]}; %s }'
  			.    '}'
  			if $slurpy->is_a_type_of(Types::Standard::HashRef);
  		$slurpy_any = 1
  			if $slurpy->equals(Types::Standard::Any);
  	}
  	
  	my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @constraints;
  	my $min         = 0 + grep !$_, @is_optional;
  	
  	return sub
  	{
  		my $v = $_[1];
  		join " and ",
  			"ref($v) eq 'ARRAY'",
  			"scalar(\@{$v}) >= $min",
  			(
  				$slurpy_any
  					? ()
  					: (
  						$slurpy
  							? sprintf($tmpl, $v, $#constraints+1, $v, $slurpy->inline_check('$tmp'))
  							: sprintf("\@{$v} <= %d", scalar @constraints)
  					)
  			),
  			map {
  				my $inline = $constraints[$_]->inline_check("$v\->[$_]");
  				$is_optional[$_]
  					? sprintf('(@{%s} <= %d or %s)', $v, $_, $inline)
  					: $inline;
  			} 0 .. $#constraints;
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	
  	my @constraints = @{ $type->parameters };
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  	}
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	
  	if (@constraints < @$value and not $slurpy)
  	{
  		return [
  			sprintf('"%s" expects at most %d values in the array', $type, scalar(@constraints)),
  			sprintf('%d values found; too many', scalar(@$value)),
  		];
  	}
  	
  	for my $i (0 .. $#constraints)
  	{
  		next if $constraints[$i]->is_strictly_a_type_of( Types::Standard::Optional ) && $i > $#$value;
  		next if $constraints[$i]->check($value->[$i]);
  		
  		return [
  			sprintf('"%s" constrains value at index %d of array with "%s"', $type, $i, $constraints[$i]),
  			@{ $constraints[$i]->validate_explain($value->[$i], sprintf('%s->[%s]', $varname, $i)) },
  		];
  	}
  	
  	if (defined($slurpy))
  	{
  		my $tmp = $slurpy->is_a_type_of(Types::Standard::HashRef)
  			? +{@$value[$#constraints+1 .. $#$value]}
  			: +[@$value[$#constraints+1 .. $#$value]];
  		$slurpy->check($tmp) or return [
  			sprintf(
  				'Array elements from index %d are slurped into a %s which is constrained with "%s"',
  				$#constraints+1,
  				$slurpy->is_a_type_of(Types::Standard::HashRef) ? 'hashref' : 'arrayref',
  				$slurpy,
  			),
  			@{ $slurpy->validate_explain($tmp, '$SLURPY') },
  		];
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  my $label_counter = 0;
  sub __coercion_generator
  {
  	my ($parent, $child, @tuple) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $slurpy;
  	if (exists $tuple[-1] and ref $tuple[-1] eq "HASH")
  	{
  		$slurpy = pop(@tuple)->{slurpy};
  	}
  	
  	my $all_inlinable = 1;
  	for my $tc (@tuple, ($slurpy ? $slurpy : ()))
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my $label = sprintf("TUPLELABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $tmp, @new) = ($_, 0);';
  			push @code,       "$label: {";
  			push @code,       sprintf('(($return_orig = 1), last %s) if @$orig > %d;', $label, scalar @tuple) unless $slurpy;
  			for my $i (0 .. $#tuple)
  			{
  				my $ct = $tuple[$i];
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);
  				
  				push @code, sprintf(
  					'if (@$orig > %d) { $tmp = %s; (%s) ? ($new[%d]=$tmp) : ($return_orig=1 and last %s) }',
  					$i,
  					$ct_coerce
  						? $ct->coercion->inline_coercion("\$orig->[$i]")
  						: "\$orig->[$i]",
  					$ct->inline_check('$tmp'),
  					$i,
  					$label,
  				);
  			}
  			if ($slurpy)
  			{
  				my $size = @tuple;
  				push @code, sprintf('if (@$orig > %d) {', $size);
  				push @code, sprintf('my $tail = [ @{$orig}[%d .. $#$orig] ];', $size);
  				push @code, $slurpy->has_coercion
  					? sprintf('$tail = %s;', $slurpy->coercion->inline_coercion('$tail'))
  					: q();
  				push @code, sprintf(
  					'(%s) ? push(@new, @$tail) : ($return_orig++);',
  					$slurpy->inline_check('$tail'),
  				);
  				push @code, '}';
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	
  	else
  	{
  		my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @tuple;
  		
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				
  				if (!$slurpy and @$value > @tuple)
  				{
  					return $value;
  				}
  				
  				my @new;
  				for my $i (0 .. $#tuple)
  				{
  					return \@new if $i > $#$value and $is_optional[$i];
  					
  					my $ct = $tuple[$i];
  					my $x  = $ct->has_coercion ? $ct->coerce($value->[$i]) : $value->[$i];
  					
  					return $value unless $ct->check($x);
  					
  					$new[$i] = $x;
  				}
  				
  				if ($slurpy and @$value > @tuple)
  				{
  					my $tmp = $slurpy->has_coercion
  						? $slurpy->coerce([ @{$value}[@tuple .. $#$value] ])
  						: [ @{$value}[@tuple .. $#$value] ];
  					$slurpy->check($tmp) ? push(@new, @$tmp) : return($value);
  				}
  				
  				return \@new;
  			},
  		);
  	};
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Tuple - internals for the Types::Standard Tuple type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_TUPLE

$fatpacked{"Types/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_TYPETINY';
  package Types::TypeTiny;
  
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000005';
  
  use Scalar::Util qw< blessed refaddr weaken >;
  
  our @EXPORT_OK = ( __PACKAGE__->type_names, qw/to_TypeTiny/ );
  
  my %cache;
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  sub meta
  {
  	return $_[0];
  }
  
  sub type_names
  {
  	qw( CodeLike StringLike TypeTiny HashLike ArrayLike );
  }
  
  sub has_type
  {
  	my %has = map +($_ => 1), shift->type_names;
  	!!$has{ $_[0] };
  }
  
  sub get_type
  {
  	my $self = shift;
  	return unless $self->has_type(@_);
  	no strict qw(refs);
  	&{$_[0]}();
  }
  
  sub coercion_names
  {
  	qw();
  }
  
  sub has_coercion
  {
  	my %has = map +($_ => 1), shift->coercion_names;
  	!!$has{ $_[0] };
  }
  
  sub get_coercion
  {
  	my $self = shift;
  	return unless $self->has_coercion(@_);
  	no strict qw(refs);
  	&{$_[0]}();  # uncoverable statement
  }
  
  sub StringLike ()
  {
  	require Type::Tiny;
  	$cache{StringLike} ||= "Type::Tiny"->new(
  		name       => "StringLike",
  		constraint => sub {    defined($_   ) && !ref($_   ) or Scalar::Util::blessed($_   ) && overload::Method($_   , q[""])  },
  		inlined    => sub { qq/defined($_[1]) && !ref($_[1]) or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[""])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub HashLike ()
  {
  	require Type::Tiny;
  	$cache{HashLike} ||= "Type::Tiny"->new(
  		name       => "HashLike",
  		constraint => sub {    ref($_   ) eq q[HASH] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[%{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[HASH] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\%{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub ArrayLike ()
  {
  	require Type::Tiny;
  	$cache{ArrayLike} ||= "Type::Tiny"->new(
  		name       => "ArrayLike",
  		constraint => sub {    ref($_   ) eq q[ARRAY] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[@{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[ARRAY] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\@{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub CodeLike ()
  {
  	require Type::Tiny;
  	$cache{CodeLike} ||= "Type::Tiny"->new(
  		name       => "CodeLike",
  		constraint => sub {    ref($_   ) eq q[CODE] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[&{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[CODE] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\&{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub TypeTiny ()
  {
  	require Type::Tiny;
  	$cache{TypeTiny} ||= "Type::Tiny"->new(
  		name       => "TypeTiny",
  		constraint => sub {  Scalar::Util::blessed($_   ) && $_   ->isa(q[Type::Tiny])  },
  		inlined    => sub { my $var = $_[1]; "Scalar::Util::blessed($var) && $var\->isa(q[Type::Tiny])" },
  		library    => __PACKAGE__,
  	);
  }
  
  my %ttt_cache;
  
  sub to_TypeTiny
  {
  	my $t = $_[0];
  	
  	return $t unless (my $ref = ref $t);
  	return $t if $ref =~ /^Type::Tiny\b/;
  	
  	return $ttt_cache{ refaddr($t) } if $ttt_cache{ refaddr($t) };
  	
  	if (my $class = blessed $t)
  	{
  		return $t                               if $class->isa("Type::Tiny");
  		return _TypeTinyFromMoose($t)           if $class->isa("Moose::Meta::TypeConstraint");
  		return _TypeTinyFromMoose($t)           if $class->isa("MooseX::Types::TypeDecorator");
  		return _TypeTinyFromValidationClass($t) if $class->isa("Validation::Class::Simple");
  		return _TypeTinyFromValidationClass($t) if $class->isa("Validation::Class");
  		return _TypeTinyFromGeneric($t)         if $t->can("check") && $t->can("get_message"); # i.e. Type::API::Constraint
  	}
  	
  	return _TypeTinyFromCodeRef($t) if $ref eq q(CODE);
  	
  	$t;
  }
  
  sub _TypeTinyFromMoose
  {
  	my $t = $_[0];
  	
  	if (ref $t->{"Types::TypeTiny::to_TypeTiny"})
  	{
  		return $t->{"Types::TypeTiny::to_TypeTiny"};
  	}
  	
  	if ($t->name ne '__ANON__')
  	{
  		require Types::Standard;
  		my $ts = 'Types::Standard'->get_type($t->name);
  		return $ts if $ts->{_is_core};
  	}
  	
  	my %opts;
  	$opts{display_name} = $t->name;
  	$opts{constraint}   = $t->constraint;
  	$opts{parent}       = to_TypeTiny($t->parent)              if $t->has_parent;
  	$opts{inlined}      = sub { shift; $t->_inline_check(@_) } if $t->can_be_inlined;
  	$opts{message}      = sub { $t->get_message($_) }          if $t->has_message;
  	$opts{moose_type}   = $t;
  	
  	require Type::Tiny;
  	my $new = 'Type::Tiny'->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	
  	$new->{coercion} = do {
  		require Type::Coercion::FromMoose;
  		'Type::Coercion::FromMoose'->new(
  			type_constraint => $new,
  			moose_coercion  => $t->coercion,
  		);
  	} if $t->has_coercion;
  	
  	return $new;
  }
  
  sub _TypeTinyFromValidationClass
  {
  	my $t = $_[0];
  	
  	require Type::Tiny;
  	require Types::Standard;
  	
  	my %opts = (
  		parent            => Types::Standard::HashRef(),
  		_validation_class => $t,
  	);
  	
  	if ($t->VERSION >= "7.900048")
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = eval { $t->validate };
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = (eval { $t->validate } ? "OK" : $t->errors_to_string);
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  	}
  	else  # need to use hackish method
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate };
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate } ? "OK" : $t->errors_to_string;
  		};
  	}
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	
  	$new->coercion->add_type_coercions(
  		Types::Standard::HashRef() => sub {
  			my %params = %$_;
  			for my $k (keys %params)
  				{ delete $params{$_} unless $t->get_fields($k) };
  			$t->params->clear;
  			$t->params->add(%params);
  			eval { $t->validate };
  			$t->get_hash;
  		},
  	);
  	
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  sub _TypeTinyFromGeneric
  {
  	my $t = $_[0];
  	
  	# XXX - handle inlining??
  	
  	my %opts = (
  		constraint => sub { $t->check(@_ ? @_ : $_) },
  		message    => sub { $t->get_message(@_ ? @_ : $_) },
  	);
  	
  	$opts{display_name} = $t->name if $t->can("name");
  	
  	$opts{coercion} = sub { $t->coerce(@_ ? @_ : $_) }
  		if $t->can("has_coercion") && $t->has_coercion && $t->can("coerce");
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  my $QFS;
  sub _TypeTinyFromCodeRef
  {
  	my $t = $_[0];
  	
  	my %opts = (
  		constraint => sub {
  			return !!eval { $t->($_) };
  		},
  		message => sub {
  			local $@;
  			eval { $t->($_); 1 } or do { chomp $@; return $@ if $@ };
  			return sprintf('%s did not pass type constraint', Type::Tiny::_dd($_));
  		},
  	);
  	
  	if ($QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($t) || [] };
  		if ($perlstring)
  		{
  			$perlstring = "!!eval{ $perlstring }";
  			$opts{inlined} = sub
  			{
  				my $var = $_[1];
  				Sub::Quote::inlinify(
  					$perlstring,
  					$var,
  					$var eq q($_) ? '' : "local \$_ = $var;",
  					1,
  				);
  			} if $perlstring && !$captures;
  		}
  	}
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords arrayfication hashification
  
  =head1 NAME
  
  Types::TypeTiny - type constraints used internally by Type::Tiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Dogfooding.
  
  This isn't a real Type::Library-based type library; that would involve
  too much circularity. But it exports some type constraints which, while
  designed for use within Type::Tiny, may be more generally useful.
  
  =head2 Types
  
  =over
  
  =item C<< StringLike >>
  
  Accepts strings and objects overloading stringification.
  
  =item C<< HashLike >>
  
  Accepts hashrefs and objects overloading hashification.
  
  =item C<< ArrayLike >>
  
  Accepts arrayrefs and objects overloading arrayfication.
  
  =item C<< CodeLike >>
  
  Accepts coderefs and objects overloading codification.
  
  =item C<< TypeTiny >>
  
  Accepts blessed L<Type::Tiny> objects.
  
  =back
  
  =head2 Coercion Functions
  
  =over
  
  =item C<< to_TypeTiny($constraint) >>
  
  Promotes (or "demotes" if you prefer) a Moose::Meta::TypeConstraint object
  to a Type::Tiny object.
  
  Can also handle L<Validation::Class> objects. Type constraints built from 
  Validation::Class objects deliberately I<ignore> field filters when they
  do constraint checking (and go to great lengths to do so); using filters for
  coercion only. (The behaviour of C<coerce> if we don't do that is just too
  weird!)
  
  Can also handle any object providing C<check> and C<get_message> methods.
  (This includes L<Mouse::Meta::TypeConstraint> objects.) If the object also
  provides C<has_coercion> and C<coerce> methods, these will be used too.
  
  Can also handle coderefs (but not blessed coderefs or objects overloading
  C<< &{} >>). Coderefs are expected to return true iff C<< $_ >> passes the
  constraint. If C<< $_ >> fails the type constraint, they may either return
  false, or die with a helpful error message.
  
  =back
  
  =head2 Methods
  
  These are implemented so that C<< Types::TypeTiny->meta->get_type($foo) >>
  works, for rough compatibility with a real L<Type::Library> type library.
  
  =over
  
  =item C<< meta >>
  
  =item C<< type_names >>
  
  =item C<< get_type($name) >>
  
  =item C<< has_type($name) >>
  
  =item C<< coercion_names >>
  
  =item C<< get_coercion($name) >>
  
  =item C<< has_coercion($name) >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_TYPETINY

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  use 5.008001;
  package YAML;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  YAML - YAML Ain't Markup Language (tm)
  
  =head1 NOTE
  
  This module has been released to CPAN as YAML::Old, and soon YAML.pm
  will be changed to just be a frontend interface module for all the
  various Perl YAML implementation modules, including YAML::Old.
  
  If you want robust and fast YAML processing using the normal Dump/Load
  API, please consider switching to YAML::XS. It is by far the best Perl
  module for YAML at this time. It requires that you have a C compiler,
  since it is written in C.
  
  If you really need to use this version of YAML.pm it will always be
  available as YAML::Old.
  
  If you don't care which YAML module use, as long as it's the best one
  installed on your system, use YAML::Any.
  
  The rest of this documentation is left unchanged, until YAML.pm is
  switched over to the new UI-only version.
  
  =head1 SYNOPSIS
  
      use YAML;
      
      # Load a YAML stream of 3 YAML documents into Perl data structures.
      my ($hashref, $arrayref, $string) = Load(<<'...');
      ---
      name: ingy
      age: old
      weight: heavy
      # I should comment that I also like pink, but don't tell anybody.
      favorite colors:
          - red
          - green
          - blue
      ---
      - Clark Evans
      - Oren Ben-Kiki
      - Ingy döt Net
      --- >
      You probably think YAML stands for "Yet Another Markup Language". It
      ain't! YAML is really a data serialization language. But if you want
      to think of it as a markup, that's OK with me. A lot of people try
      to use XML as a serialization format.
      
      "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
      ...
      
      # Dump the Perl data structures back into YAML.
      print Dump($string, $arrayref, $hashref);
      
      # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
      use Data::Dumper;
      print Dumper($string, $arrayref, $hashref);
  
  =head1 DESCRIPTION
  
  The YAML.pm module implements a YAML Loader and Dumper based on the YAML
  1.0 specification. L<http://www.yaml.org/spec/>
  
  YAML is a generic data serialization language that is optimized for
  human readability. It can be used to express the data structures of most
  modern programming languages. (Including Perl!!!)
  
  For information on the YAML syntax, please refer to the YAML
  specification.
  
  =head1 WHY YAML IS COOL
  
  =over 4
  
  =item YAML is readable for people.
  
  It makes clear sense out of complex data structures. You should find
  that YAML is an exceptional data dumping tool. Structure is shown
  through indentation, YAML supports recursive data, and hash keys are
  sorted by default. In addition, YAML supports several styles of scalar
  formatting for different types of data.
  
  =item YAML is editable.
  
  YAML was designed from the ground up to be an excellent syntax for
  configuration files. Almost all programs need configuration files, so
  why invent a new syntax for each one? And why subject users to the
  complexities of XML or native Perl code?
  
  =item YAML is multilingual.
  
  Yes, YAML supports Unicode. But I'm actually referring to programming
  languages. YAML was designed to meet the serialization needs of Perl,
  Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
  interoperable between those languages. That means YAML serializations
  produced by Perl can be processed by Python.
  
  =item YAML is taint safe.
  
  Using modules like Data::Dumper for serialization is fine as long as you
  can be sure that nobody can tamper with your data files or
  transmissions. That's because you need to use Perl's C<eval()> built-in
  to deserialize the data. Somebody could add a snippet of Perl to erase
  your files.
  
  YAML's parser does not need to eval anything.
  
  =item YAML is full featured.
  
  YAML can accurately serialize all of the common Perl data structures and
  deserialize them again without losing data relationships. Although it is
  not 100% perfect (no serializer is or can be perfect), it fares as well
  as the popular current modules: Data::Dumper, Storable, XML::Dumper and
  Data::Denter.
  
  YAML.pm also has the ability to handle code (subroutine) references and
  typeglobs. (Still experimental) These features are not found in Perl's
  other serialization modules.
  
  =item YAML is extensible.
  
  The YAML language has been designed to be flexible enough to solve it's
  own problems. The markup itself has 3 basic construct which resemble
  Perl's hash, array and scalar. By default, these map to their Perl
  equivalents. But each YAML node also supports a tagging mechanism (type
  system) which can cause that node to be interpreted in a completely
  different manner. That's how YAML can support object serialization and
  oddball structures like Perl's typeglob.
  
  =back
  
  =head1 YAML IMPLEMENTATIONS IN PERL
  
  This module, YAML.pm, is really just the interface module for YAML
  modules written in Perl. The basic interface for YAML consists of two
  functions: C<Dump> and C<Load>. The real work is done by the modules
  YAML::Dumper and YAML::Loader.
  
  Different YAML module distributions can be created by subclassing
  YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple
  consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
  
  Why would there be more than one implementation of YAML? Well, despite
  YAML's offering of being a simple data format, YAML is actually very
  deep and complex. Implementing the entirety of the YAML specification is
  a daunting task.
  
  For this reason I am currently working on 3 different YAML implementations.
  
  =over
  
  =item YAML
  
  The main YAML distribution will keeping evolving to support the entire
  YAML specification in pure Perl. This may not be the fastest or most
  stable module though. Currently, YAML.pm has lots of known bugs. It is
  mostly a great tool for dumping Perl data structures to a readable form.
  
  =item YAML::Tiny
  
  The point of YAML::Tiny is to strip YAML down to the 90% that people
  use most and offer that in a small, fast, stable, pure Perl form.
  YAML::Tiny will simply die when it is asked to do something it can't.
  
  =item YAML::Syck
  
  C<libsyck> is the C based YAML processing library used by the Ruby
  programming language (and also Python, PHP and Pugs). YAML::Syck is the
  Perl binding to C<libsyck>. It should be very fast, but may have
  problems of its own. It will also require C compilation.
  
  NOTE: Audrey Tang has actually completed this module and it works great
        and is 10 times faster than YAML.pm.
  
  =back
  
  In the future, there will likely be even more YAML modules. Remember,
  people other than Ingy are allowed to write YAML modules!
  
  =head1 FUNCTIONAL USAGE
  
  YAML is completely OO under the hood. Still it exports a few useful top
  level functions so that it is dead simple to use. These functions just
  do the OO stuff for you. If you want direct access to the OO API see the
  documentation for YAML::Dumper and YAML::Loader.
  
  =head2 Exported Functions
  
  The following functions are exported by YAML.pm by default. The reason
  they are exported is so that YAML works much like Data::Dumper. If you
  don't want functions to be imported, just use YAML with an empty
  import list:
  
      use YAML ();
  
  =over 4
  
  =item Dump(list-of-Perl-data-structures)
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper(). It takes a list of Perl data strucures and
  dumps them into a serialized form. It returns a string containing the
  YAML stream. The structures can be references or plain scalars.
  
  =item Load(string-containing-a-YAML-stream)
  
  Turn YAML into Perl data. This is the opposite of Dump. Just like
  Storable's thaw() function or the eval() function in relation to
  Data::Dumper. It parses a string containing a valid YAML stream into a
  list of Perl data structures.
  
  =back
  
  =head2 Exportable Functions
  
  These functions are not exported by default but you can request them in
  an import list like this:
  
      use YAML qw'freeze thaw Bless';
  
  =over 4
  
  =item freeze() and thaw()
  
  Aliases to Dump() and Load() for Storable fans. This will also allow
  YAML.pm to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =item DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =item LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =item Bless(perl-node, [yaml-node | class-name])
  
  Associate a normal Perl node, with a yaml node. A yaml node is an object
  tied to the YAML::Node class. The second argument is either a yaml node
  that you've already created or a class (package) name that supports a
  yaml_dump() function. A yaml_dump() function should take a perl node and
  return a yaml node. If no second argument is provided, Bless will create
  a yaml node. This node is not returned, but can be retrieved with the
  Blessed() function.
  
  Here's an example of how to use Bless. Say you have a hash containing
  three keys, but you only want to dump two of them. Furthermore the keys
  must be dumped in a certain order. Here's how you do that:
  
      use YAML qw(Dump Bless);
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash)->keys(['banana', 'apple']);
      print Dump $hash;
  
  produces:
  
      ---
      apple: good
      banana: bad
      cauliflower: ugly
      ---
      banana: bad
      apple: good
  
  Bless returns the tied part of a yaml-node, so that you can call the
  YAML::Node methods. This is the same thing that YAML::Node::ynode()
  returns. So another way to do the above example is:
  
      use YAML qw(Dump Bless);
      use YAML::Node;
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash);
      $ynode = ynode(Blessed($hash));
      $ynode->keys(['banana', 'apple']);
      print Dump $hash;
  
  Note that Blessing a Perl data structure does not change it anyway. The
  extra information is stored separately and looked up by the Blessed
  node's memory address.
  
  =item Blessed(perl-node)
  
  Returns the yaml node that a particular perl node is associated with
  (see above). Returns undef if the node is not (YAML) Blessed.
  
  =back
  
  =head1 GLOBAL OPTIONS
  
  YAML options are set using a group of global variables in the YAML
  namespace. This is similar to how Data::Dumper works.
  
  For example, to change the indentation width, do something like:
  
      local $YAML::Indent = 3;
  
  The current options are:
  
  =over 4
  
  =item DumperClass
  
  You can override which module/class YAML uses for Dumping data.
  
  =item LoaderClass
  
  You can override which module/class YAML uses for Loading data.
  
  =item Indent
  
  This is the number of space characters to use for each indentation level
  when doing a Dump(). The default is 2.
  
  By the way, YAML can use any number of characters for indentation at any
  level. So if you are editing YAML by hand feel free to do it anyway that
  looks pleasing to you; just be consistent for a given level.
  
  =item SortKeys
  
  Default is 1. (true)
  
  Tells YAML.pm whether or not to sort hash keys when storing a document.
  
  YAML::Node objects can have their own sort order, which is usually what
  you want. To override the YAML::Node order and sort the keys anyway, set
  SortKeys to 2.
  
  =item Stringify
  
  Default is 0. (false)
  
  Objects with string overloading should honor the overloading and dump the
  stringification of themselves, rather than the actual object's guts.
  
  =item UseHeader
  
  Default is 1. (true)
  
  This tells YAML.pm whether to use a separator string for a Dump
  operation. This only applies to the first document in a stream.
  Subsequent documents must have a YAML header by definition.
  
  =item UseVersion
  
  Default is 0. (false)
  
  Tells YAML.pm whether to include the YAML version on the
  separator/header.
  
      --- %YAML:1.0
  
  =item AnchorPrefix
  
  Default is ''.
  
  Anchor names are normally numeric. YAML.pm simply starts with '1' and
  increases by one for each new anchor. This option allows you to specify a
  string to be prepended to each anchor number.
  
  =item UseCode
  
  Setting the UseCode option is a shortcut to set both the DumpCode and
  LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
  Perl code references as Perl (using B::Deparse) and to load them back
  into memory using eval(). The reason this has to be an option is that
  using eval() to parse untrusted code is, well, untrustworthy.
  
  =item DumpCode
  
  Determines if and how YAML.pm should serialize Perl code references. By
  default YAML.pm will dump code references as dummy placeholders (much
  like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
  references will be dumped as actual Perl code.
  
  DumpCode can also be set to a subroutine reference so that you can
  write your own serializing routine. YAML.pm passes you the code ref. You
  pass back the serialization (as a string) and a format indicator. The
  format indicator is a simple string like: 'deparse' or 'bytecode'.
  
  =item LoadCode
  
  LoadCode is the opposite of DumpCode. It tells YAML if and how to
  deserialize code references. When set to '1' or 'deparse' it will use
  C<eval()>. Since this is potentially risky, only use this option if you
  know where your YAML has been.
  
  LoadCode can also be set to a subroutine reference so that you can write
  your own deserializing routine. YAML.pm passes the serialization (as a
  string) and a format indicator. You pass back the code reference.
  
  =item UseBlock
  
  YAML.pm uses heuristics to guess which scalar style is best for a given
  node. Sometimes you'll want all multiline scalars to use the 'block'
  style. If so, set this option to 1.
  
  NOTE: YAML's block style is akin to Perl's here-document.
  
  =item UseFold
  
  If you want to force YAML to use the 'folded' style for all multiline
  scalars, then set $UseFold to 1.
  
  NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.
  
  =item UseAliases
  
  YAML has an alias mechanism such that any given structure in memory gets
  serialized once. Any other references to that structure are serialized
  only as alias markers. This is how YAML can serialize duplicate and
  recursive structures.
  
  Sometimes, when you KNOW that your data is nonrecursive in nature, you
  may want to serialize such that every node is expressed in full. (ie as
  a copy of the original). Setting $YAML::UseAliases to 0 will allow you
  to do this. This also may result in faster processing because the lookup
  overhead is by bypassed.
  
  THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option
  *will* cause Dump() to run in an endless loop, chewing up your computers
  memory. You have been warned.
  
  =item CompressSeries
  
  Default is 1.
  
  Compresses the formatting of arrays of hashes:
  
      -
        foo: bar
      - 
        bar: foo
  
  becomes:
  
      - foo: bar
      - bar: foo
  
  Since this output is usually more desirable, this option is turned on by
  default.
  
  =back
  
  =head1 YAML TERMINOLOGY
  
  YAML is a full featured data serialization language, and thus has its
  own terminology.
  
  It is important to remember that although YAML is heavily influenced by
  Perl and Python, it is a language in its own right, not merely just a
  representation of Perl structures.
  
  YAML has three constructs that are conspicuously similar to Perl's hash,
  array, and scalar. They are called mapping, sequence, and string
  respectively. By default, they do what you would expect. But each
  instance may have an explicit or implicit tag (type) that makes it
  behave differently. In this manner, YAML can be extended to represent
  Perl's Glob or Python's tuple, or Ruby's Bigint.
  
  =over 4
  
  =item stream
  
  A YAML stream is the full sequence of unicode characters that a YAML
  parser would read or a YAML emitter would write. A stream may contain
  one or more YAML documents separated by YAML headers.
  
      ---
      a: mapping
      foo: bar
      ---
      - a
      - sequence
  
  =item document
  
  A YAML document is an independent data structure representation within a
  stream. It is a top level node. Each document in a YAML stream must
  begin with a YAML header line. Actually the header is optional on the
  first document.
  
      ---
      This: top level mapping
      is:
          - a
          - YAML
          - document
  
  =item header
  
  A YAML header is a line that begins a YAML document. It consists of
  three dashes, possibly followed by more info. Another purpose of the
  header line is that it serves as a place to put top level tag and anchor
  information.
  
      --- !recursive-sequence &001
      - * 001
      - * 001
  
  =item node
  
  A YAML node is the representation of a particular data stucture. Nodes
  may contain other nodes. (In Perl terms, nodes are like scalars.
  Strings, arrayrefs and hashrefs. But this refers to the serialized
  format, not the in-memory structure.)
  
  =item tag
  
  This is similar to a type. It indicates how a particular YAML node
  serialization should be transferred into or out of memory. For instance
  a Foo::Bar object would use the tag 'perl/Foo::Bar':
  
      - !perl/Foo::Bar
          foo: 42
          bar: stool
  
  =item collection
  
  A collection is the generic term for a YAML data grouping. YAML has two
  types of collections: mappings and sequences. (Similar to hashes and arrays)
  
  =item mapping
  
  A mapping is a YAML collection defined by unordered key/value pairs with
  unique keys. By default YAML mappings are loaded into Perl hashes.
  
      a mapping:
          foo: bar
          two: times two is 4
  
  =item sequence
  
  A sequence is a YAML collection defined by an ordered list of elements. By
  default YAML sequences are loaded into Perl arrays.
  
      a sequence:
          - one bourbon
          - one scotch
          - one beer
  
  =item scalar
  
  A scalar is a YAML node that is a single value. By default YAML scalars
  are loaded into Perl scalars.
  
      a scalar key: a scalar value
  
  YAML has many styles for representing scalars. This is important because
  varying data will have varying formatting requirements to retain the
  optimum human readability.
  
  =item plain scalar
  
  A plain scalar is unquoted. All plain scalars are automatic candidates
  for "implicit tagging". This means that their tag may be determined
  automatically by examination. The typical uses for this are plain alpha
  strings, integers, real numbers, dates, times and currency.
  
      - a plain string
      - -42
      - 3.1415
      - 12:34
      - 123 this is an error
  
  =item single quoted scalar
  
  This is similar to Perl's use of single quotes. It means no escaping
  except for single quotes which are escaped by using two adjacent
  single quotes.
  
      - 'When I say ''\n'' I mean "backslash en"'
  
  =item double quoted scalar
  
  This is similar to Perl's use of double quotes. Character escaping can
  be used.
  
      - "This scalar\nhas two lines, and a bell -->\a"
  
  =item folded scalar
  
  This is a multiline scalar which begins on the next line. It is
  indicated by a single right angle bracket. It is unescaped like the
  single quoted scalar. Line folding is also performed.
  
      - > 
       This is a multiline scalar which begins on
       the next line. It is indicated by a single
       carat. It is unescaped like the single
       quoted scalar. Line folding is also
       performed.
  
  =item block scalar
  
  This final multiline form is akin to Perl's here-document except that
  (as in all YAML data) scope is indicated by indentation. Therefore, no
  ending marker is required. The data is verbatim. No line folding.
  
      - |
          QTY  DESC          PRICE  TOTAL
          ---  ----          -----  -----
            1  Foo Fighters  $19.95 $19.95
            2  Bar Belles    $29.95 $59.90
  
  =item parser
  
  A YAML processor has four stages: parse, load, dump, emit.
  
  A parser parses a YAML stream. YAML.pm's Load() function contains a
  parser.
  
  =item loader
  
  The other half of the Load() function is a loader. This takes the
  information from the parser and loads it into a Perl data structure.
  
  =item dumper
  
  The Dump() function consists of a dumper and an emitter. The dumper
  walks through each Perl data structure and gives info to the emitter.
  
  =item emitter
  
  The emitter takes info from the dumper and turns it into a YAML stream.
  
  NOTE:
  In YAML.pm the parser/loader and the dumper/emitter code are currently
  very closely tied together. In the future they may be broken into
  separate stages.
  
  =back
  
  For more information please refer to the immensely helpful YAML
  specification available at L<http://www.yaml.org/spec/>.
  
  =head1 ysh - The YAML Shell
  
  The YAML distribution ships with a script called 'ysh', the YAML shell.
  ysh provides a simple, interactive way to play with YAML. If you type in
  Perl code, it displays the result in YAML. If you type in YAML it turns
  it into Perl code.
  
  To run ysh, (assuming you installed it along with YAML.pm) simply type:
  
      ysh [options]
  
  Please read the C<ysh> documentation for the full details. There are
  lots of options.
  
  =head1 BUGS & DEFICIENCIES
  
  If you find a bug in YAML, please try to recreate it in the YAML Shell
  with logging turned on ('ysh -L'). When you have successfully reproduced
  the bug, please mail the LOG file to the author (ingy@cpan.org).
  
  WARNING: This is still *ALPHA* code. Well, most of this code has been
  around for years...
  
  BIGGER WARNING: YAML.pm has been slow in the making, but I am committed
  to having top notch YAML tools in the Perl world. The YAML team is close
  to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of
  a very old pre 1.0 spec. In actuality there isn't a ton of difference,
  and this YAML.pm is still fairly useful. Things will get much better in
  the future.
  
  =head1 RESOURCES
  
  L<http://lists.sourceforge.net/lists/listinfo/yaml-core> is the mailing
  list. This is where the language is discussed and designed.
  
  L<http://www.yaml.org> is the official YAML website.
  
  L<http://www.yaml.org/spec/> is the YAML 1.0 specification.
  
  L<http://yaml.kwiki.org> is the official YAML wiki.
  
  =head1 SEE ALSO
  
  See YAML::XS. Fast!
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  is resonsible for YAML.pm.
  
  The YAML serialization language is the result of years of collaboration
  between Oren Ben-Kiki, Clark Evans and Ingy döt Net. Several others
  have added help along the way.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005, 2006, 2008, 2011-2012. Ingy döt Net.
  
  Copyright (c) 2001, 2002, 2005. Brian Ingerson.
  
  Some parts copyright (c) 2009 - 2010 Adam Kennedy
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  package YAML::Any;
  
  our $VERSION = '0.84';
  
  use strict;
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::Croak(@_);
  }
  
  1;
  
  =head1 NAME
  
  YAML::Any - Pick a YAML implementation and use it.
  
  =head1 SYNOPSIS
  
      use YAML::Any;
      $YAML::Indent = 3;
      my $yaml = Dump(@objects);
  
  =head1 DESCRIPTION
  
  There are several YAML implementations that support the Dump/Load API.
  This module selects the best one available and uses it.
  
  =head1 ORDER
  
  Currently, YAML::Any will choose the first one of these YAML
  implementations that is installed on your system:
  
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  
  =head1 OPTIONS
  
  If you specify an option like:
  
      $YAML::Indent = 4;
  
  And YAML::Any is using YAML::XS, it will use the proper variable:
  $YAML::XS::Indent.
  
  =head1 SUBROUTINES
  
  Like all the YAML modules that YAML::Any uses, the following subroutines
  are exported by default:
  
      Dump
      Load
  
  and the following subroutines are exportable by request:
  
      DumpFile
      LoadFile
  
  =head1 METHODS
  
  YAML::Any provides the following class methods.
  
  =over
  
  =item YAML::Any->order;
  
  This method returns a list of the current possible implementations that
  YAML::Any will search for.
  
  =item YAML::Any->implementation;
  
  This method returns the implementation the YAML::Any will use. This
  result is obtained by finding the first member of YAML::Any->order that
  is either already loaded in C<%INC> or that can be loaded using
  C<require>. If no implementation is found, an error will be thrown.
  
  =back
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  our $VERSION = '0.84';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';    
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo); 
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and 
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {  
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0], 
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) = 
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} = 
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) = 
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash. 
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
          
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last 
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper - YAML class for dumping Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Dumper;
      my $dumper = YAML::Dumper->new;
      $dumper->indent_width(4);
      print $dumper->dump({foo => 'bar'});
  
  =head1 DESCRIPTION
  
  YAML::Dumper is the module that YAML.pm used to serialize Perl objects to
  YAML. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
      
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper::Base - Base class for YAML Dumper classes
  
  =head1 SYNOPSIS
  
      package YAML::Dumper::Something;
      use YAML::Dumper::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Dumper::Base is a base class for creating YAML dumper classes.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)} 
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION 
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR 
       YAML_PARSE_ERR_NO_ANCHOR 
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Error - Error formatting class for YAML modules
  
  =head1 SYNOPSIS
  
      $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias);
      $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
  
  =head1 DESCRIPTION
  
  This module provides a C<die> and a C<warn> facility.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  our $VERSION = '0.84';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';    
  my $LIT_CHAR_RX = "\\$LIT_CHAR";    
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS') 
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE') 
        if length($self->stream) and 
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) = 
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) = 
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) { 
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE'); 
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--; 
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR') 
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface); 
  }
  
  # Morph a node to it's explicit type  
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
          
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign) 
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
              
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) = 
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE') 
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^"((?:\\"|[^"])*)"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`\^]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately  
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/ or die;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and 
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or die;
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
          
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos; 
      
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and 
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION') 
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
     
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader - YAML class for loading Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Loader;
      my $loader = YAML::Loader->new;
      my $hash = $loader->load(<<'...');
      foo: bar
      ...
  
  =head1 DESCRIPTION
  
  YAML::Loader is the module that YAML.pm used to deserialize YAML to Perl
  objects. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader::Base - Base class for YAML Loader classes
  
  =head1 SYNOPSIS
  
      package YAML::Loader::Something;
      use YAML::Loader::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Loader::Base is a base class for creating YAML loader classes.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict;
  use warnings;
  package YAML::Marshall;
  
  our $VERSION = '0.84';
  
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Marshall - YAML marshalling class you can mixin to your classes
  
  =head1 SYNOPSIS
  
      package Bar;
      use Foo -base;
      use YAML::Marshall -mixin;
  
  =head1 DESCRIPTION
  
  For classes that want to handle their own YAML serialization.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo; $VERSION = '0.84';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict;
  use warnings;
  package YAML::Node;
  
  our $VERSION = '0.84';
  
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
  	$self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
  	$self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
  	$self = tied(*{$_[0]});
      }
      else {
  	$self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
  		    ($type eq 'HASH') ? 'mapping' :
  		    $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
  	yaml_scalar->new($self, $_[1]);
  	return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};    
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{TAG} = YAML::Tag->new($value);
  	return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{KEYS} = $value;
  	return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}}; 
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
  	return (grep {$_ eq $key} @{$self->{KEYS}}) 
  	       ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
  	$self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
  	$self->{HASH}{$key} = $value;
      }
      else {
  	if (not grep {$_ eq $key} @{$self->{KEYS}}) {
  	    push(@{$self->{KEYS}}, $key);
  	}
  	$self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
  	$return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
  	$return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
  	if ($self->{KEYS}[$i] eq $key) {
  	    splice(@{$self->{KEYS}}, $i, 1);
  	}
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Node - A generic data node that encapsulates YAML information
  
  =head1 SYNOPSIS
  
      use YAML;
      use YAML::Node;
      
      my $ynode = YAML::Node->new({}, 'ingerson.com/fruit');
      %$ynode = qw(orange orange apple red grape green);
      print Dump $ynode;
  
  yields:
  
      --- !ingerson.com/fruit
      orange: orange
      apple: red
      grape: green
  
  =head1 DESCRIPTION
  
  A generic node in YAML is similar to a plain hash, array, or scalar node
  in Perl except that it must also keep track of its type. The type is a
  URI called the YAML type tag.
  
  YAML::Node is a class for generating and manipulating these containers.
  A YAML node (or ynode) is a tied hash, array or scalar. In most ways it
  behaves just like the plain thing. But you can assign and retrieve and
  YAML type tag URI to it. For the hash flavor, you can also assign the
  order that the keys will be retrieved in. By default a ynode will offer
  its keys in the same order that they were assigned.
  
  YAML::Node has a class method call new() that will return a ynode. You
  pass it a regular node and an optional type tag. After that you can
  use it like a normal Perl node, but when you YAML::Dump it, the magical
  properties will be honored.
  
  This is how you can control the sort order of hash keys during a YAML
  serialization. By default, YAML sorts keys alphabetically. But notice
  in the above example that the keys were Dumped in the same order they
  were assigned.
  
  YAML::Node exports a function called ynode(). This function returns the tied object so that you can call special methods on it like ->keys().
  
  keys() works like this:
  
      use YAML;
      use YAML::Node;
      
      %$node = qw(orange orange apple red grape green);
      $ynode = YAML::Node->new($node);
      ynode($ynode)->keys(['grape', 'apple']);
      print Dump $ynode;
  
  produces:
  
      ---
      grape: green
      apple: red
  
  It tells the ynode which keys and what order to use.
  
  ynodes will play a very important role in how programs use YAML. They
  are the foundation of how a Perl class can marshall the Loading and
  Dumping of its objects.
  
  The upcoming versions of YAML.pm will have much more information on this.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  Copyright (c) 2002. Brian Ingerson. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict;
  use warnings;
  package YAML::Tag;
  
  our $VERSION = '0.84';
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Tag - Tag URI object class for YAML
  
  =head1 SYNOPSIS
  
      use YAML::Tag;
  
  =head1 DESCRIPTION
  
  Used by YAML::Node.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      my $ynode = YAML::Node->new({}, '!perl/glob:');
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value; 
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0; 
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }    
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Types - Marshall Perl internal data types to/from YAML
  
  =head1 SYNOPSIS
  
      $::foo = 42;
      print YAML::Dump(*::foo);
  
      print YAML::Dump(qr{match me});
  
  =head1 DESCRIPTION
  
  This module has the helper classes for transferring objects,
  subroutines, references, globs, regexps and file handles to and
  from YAML.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TYPES

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use Moo::_strictures;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  oo - syntactic sugar for Moo oneliners
  
  =head1 SYNOPSIS
  
    perl -Moo=Foo -e 'has bar => ( is => q[ro], default => q[baz] ); print Foo->new->bar'
  
    # loads an existing class and re-"opens" the package definition
    perl -Moo=+My::Class -e 'print __PACKAGE__->new->bar'
  
  =head1 DESCRIPTION
  
  oo.pm is a simple source filter that adds C<package $name; use Moo;> to the
  beginning of your script, intended for use on the command line via the -M
  option.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
OO

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.228';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              if ( $_ eq $inheritor ) {
                  warn "Class '$inheritor' tried to inherit from itself\n";
              };
  
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_;
      };
  };
  
  "All your base are belong to us"
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Class 'Foo' tried to inherit from itself
  
  Attempting to inherit from yourself generates a warning.
  
      package Foo;
      use parent 'Foo';
  
  =back
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafaël Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR';
  package Class::XSAccessor;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor::Heavy;
  use XSLoader;
  
  our $VERSION = '1.18';
  
  XSLoader::load('Class::XSAccessor', $VERSION);
  
  sub _make_hash {
    my $ref = shift;
  
    if (ref ($ref)) {
      if (ref($ref) eq 'ARRAY') {
        $ref = { map { $_ => $_ } @$ref }
      } 
    } else {
      $ref = { $ref, $ref };
    }
  
    return $ref;
  }
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    # TODO: Refactor. Move more duplicated code to ::Heavy
    my $read_subs      = _make_hash($opts{getters} || {});
    my $set_subs       = _make_hash($opts{setters} || {});
    my $acc_subs       = _make_hash($opts{accessors} || {});
    my $lvacc_subs     = _make_hash($opts{lvalue_accessors} || {});
    my $pred_subs      = _make_hash($opts{predicates} || {});
    my $ex_pred_subs   = _make_hash($opts{exists_predicates} || {});
    my $def_pred_subs  = _make_hash($opts{defined_predicates} || {});
    my $test_subs      = _make_hash($opts{__tests__} || {});
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["test", $test_subs],
                          ["ex_predicate", $ex_pred_subs],
                          ["def_predicate", $def_pred_subs],
                          ["def_predicate", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $hashkey = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $hashkey, \%opts, $subtype->[0]);
      }
    }
  
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $hashkey, $opts, $type) = @_;
  
    croak("Cannot use undef as a hash key for generating an XS $type accessor. (Sub: $subname)")
      if not defined $hashkey;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $hashkey);
    }
    elsif ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $hashkey);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $hashkey, $opts->{chained}||0);
    }
    elsif ($type eq 'def_predicate') {
      newxs_defined_predicate($subname, $hashkey);
    }
    elsif ($type eq 'ex_predicate') {
      newxs_exists_predicate($subname, $hashkey);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      newxs_boolean($subname, 0);
    }
    elsif ($type eq 'test') {
      newxs_test($subname, $hashkey);
    }
    else {
      newxs_accessor($subname, $hashkey, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Class::XSAccessor
      replace     => 1,   # Replace existing methods (if any)
      constructor => 'new',
      getters     => {
        get_foo => 'foo', # 'foo' is the hash key to access
        get_bar => 'bar',
      },
      setters => {
        set_foo => 'foo',
        set_bar => 'bar',
      },
      accessors => {
        foo => 'foo',
        bar => 'bar',
      },
      # "predicates" is an alias for "defined_predicates"
      defined_predicates => {
        defined_foo => 'foo',
        defined_bar => 'bar',
      },
      exists_predicates => {
        has_foo => 'foo',
        has_bar => 'bar',
      },
      lvalue_accessors => { # see below
        baz => 'baz', # ...
      },
      true  => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference, if preferred,
    # which can also help Perl::Tidy to format the statement correctly.
    use Class::XSAccessor {
       # If the name => key values are always identical,
       # the following shorthand can be used.
       accessors => [ 'foo', 'bar' ],
    };
  
  =head1 DESCRIPTION
  
  Class::XSAccessor implements fast read, write and read/write accessors in XS.
  Additionally, it can provide predicates such as C<has_foo()> for testing
  whether the attribute C<foo> exists in the object (which is different from
  "is defined within the object").
  It only works with objects that are implemented as ordinary hashes.
  L<Class::XSAccessor::Array> implements the same interface for objects
  that use arrays for their internal representation.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS). Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless { @_ }, ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Parameters to C<new()> are added to the
  object.
  
  The XS accessor methods are between 3 and 4 times faster than typical
  pure-Perl accessors in some simple benchmarking.
  The lower factor applies to the potentially slightly obscure
  C<sub set_foo_pp {$_[0]-E<gt>{foo} = $_[1]}>, so if you usually
  write clear code, a factor of 3.5 speed-up is a good estimate.
  If in doubt, do your own benchmarking!
  
  The method names may be fully qualified. The example in the synopsis could
  have been written as C<MyClass::get_foo> instead
  of C<get_foo>. This way, methods can be installed in classes other
  than the current class. See also: the C<class> option below.
  
  By default, the setters return the new value that was set,
  and the accessors (mutators) do the same. This behaviour can be changed
  with the C<chained> option - see below. The predicates return a boolean.
  
  Since version 1.01, C<Class::XSAccessor> can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then consider a large class hierarchy
  with interfaces such as L<PPI>. These methods are provided by the C<true>
  and C<false> options - see the synopsis.
  
  C<defined_predicates> check whether a given object attribute is defined.
  C<predicates> is an alias for C<defined_predicates> for compatibility with
  older versions of C<Class::XSAccessor>. C<exists_predicates> checks
  whether the given attribute exists in the object using C<exists>.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, additional options
  can be supplied which modify behaviour. The options are specified as key/value pairs
  in the same manner as the accessor declaration. For example:
  
    use Class::XSAccessor
      getters => {
        get_foo => 'foo',
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. The
  the C<class> option allows the target class to be specified.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 'zip' };
    
    package main;
    my $address = Address->new(zip => 2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably won't work for objects based on I<tied> hashes. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  that's only known at run-time. Note that compiling C code at run-time a la L<Inline::C|Inline::C>
  is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed>. Previously, a small amount of
  memory would leak if C<Class::XSAccessor>-based classes were loaded in a subthread without having
  been loaded in the "main" thread. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation, as of 1.00, the memory will still not be released, in the same situation,
  but it will be recycled when the same class, or a similar class, is loaded again in B<any> thread.
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<Class::XSAccessor::Array>
  
  =item * L<AutoXS>
  
  =back
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_ARRAY';
  package Class::XSAccessor::Array;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor;
  use Class::XSAccessor::Heavy;
  
  our $VERSION = '1.18';
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    my $read_subs      = $opts{getters} || {};
    my $set_subs       = $opts{setters} || {};
    my $acc_subs       = $opts{accessors} || {};
    my $lvacc_subs     = $opts{lvalue_accessors} || {};
    my $pred_subs      = $opts{predicates} || {};
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];  
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["pred_subs", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $array_index = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $array_index, \%opts, $subtype->[0]);
      }
    }
     
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $array_index, $opts, $type) = @_;
  
    croak("Cannot use undef as a array index for generating an XS $type accessor. (Sub: $subname)")
      if not defined $array_index;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $array_index);
    }
    if ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $array_index);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $array_index, $opts->{chained}||0);
    }
    elsif ($type eq 'predicate') {
      newxs_predicate($subname, $array_index);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      Class::XSAccessor::newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      Class::XSAccessor::newxs_boolean($subname, 0);
    }
    else {
      newxs_accessor($subname, $array_index, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Array - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
    
    package MyClassUsingArraysAsInternalStorage;
    use Class::XSAccessor::Array
      constructor => 'new',
      getters => {
        get_foo => 0, # 0 is the array index to access
        get_bar => 1,
      },
      setters => {
        set_foo => 0,
        set_bar => 1,
      },
      accessors => { # a mutator
        buz => 2,
      },
      predicates => { # test for definedness
        has_buz => 2,
      },
      lvalue_accessors => { # see below
        baz => 3,
      },
      true => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference if you prefer it,
    # which can also help PerlTidy to flow the statement correctly.
    use Class::XSAccessor {
      getters => {
        get_foo => 0,
        get_bar => 1,
      },
    };
  
  =head1 DESCRIPTION
  
  The module implements fast XS accessors both for getting at and
  setting an object attribute. Additionally, the module supports
  mutators and simple predicates (C<has_foo()> like tests for definedness
  of an attributes).
  The module works only with objects
  that are implemented as B<arrays>. Using it on hash-based objects is
  bound to make your life miserable. Refer to L<Class::XSAccessor> for
  an implementation that works with hash-based objects.
  
  A simple benchmark showed a significant performance
  advantage over writing accessors in Perl.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS) for you. Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless [], ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Note that any parameters to new() will be
  discarded! If there is a better idiom for array-based objects, let
  me know.
  
  While generally more obscure than hash-based objects,
  objects using blessed arrays as internal representation
  are a bit faster as its somewhat faster to access arrays than hashes.
  Accordingly, this module is slightly faster (~10-15%) than
  L<Class::XSAccessor>, which works on hash-based objects.
  
  The method names may be fully qualified. In the example of the
  synopsis, you could have written C<MyClass::get_foo> instead
  of C<get_foo>. This way, you can install methods in classes other
  than the current class. See also: The C<class> option below.
  
  Since version 1.01, you can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then think of a large class hierarchy
  with interfaces such as PPI. This is implemented as the C<true>
  and C<false> options, see synopsis.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, you can add options
  which modify behaviour. The options are specified as key/value pairs just as the
  accessor declaration. Example:
  
    use Class::XSAccessor::Array
      getters => {
        get_foo => 0,
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor::Array> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor::Array ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. Using
  the C<class> option, you can explicitly specify where the methods
  are to be generated.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 0 };
    
    package main;
    my $address = Address->new(2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably wouldn't work if your objects are I<tied>. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  or array index that's only known at run-time. Note that compiling C code at run-time
  a la Inline::C is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed> that would leak a small amount of
  memory if you loaded C<Class::XSAccessor>-based classes in a subthread that hadn't been loaded
  in the "main" thread before. If the subthread then terminated, a hash key and an int per
  associated method used ot be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation as of 1.00, the memory will not be released again either in the above
  situation. But it will be recycled when the same class or a similar class is loaded
  again in B<any> thread.
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  
  L<AutoXS>
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_ARRAY

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_HEAVY';
  package # hide from PAUSE
      Class::XSAccessor::Heavy;
  
  use 5.008;
  use strict;
  use warnings;
  use Carp;
  
  our $VERSION  = '1.18';
  our @CARP_NOT = qw(
          Class::XSAccessor
          Class::XSAccessor::Array
  );
  
  # TODO Move more duplicated code from XSA and XSA::Array here
  
  
  sub check_sub_existence {
    my $subname = shift;
  
    my $sub_package = $subname;
    $sub_package =~ s/([^:]+)$// or die;
    my $bare_subname = $1;
      
    my $sym;
    {
      no strict 'refs';
      $sym = \%{"$sub_package"};
    }
    no warnings;
    local *s = $sym->{$bare_subname};
    my $coderef = *s{CODE};
    if ($coderef) {
      $sub_package =~ s/::$//;
      Carp::croak("Cannot replace existing subroutine '$bare_subname' in package '$sub_package' with an XS implementation. If you wish to force a replacement, add the 'replace => 1' parameter to the arguments of 'use ".(caller())[0]."'.");
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Heavy - Guts you don't care about
  
  =head1 SYNOPSIS
    
    use Class::XSAccessor!
  
  =head1 DESCRIPTION
  
  Common guts for Class::XSAccessor and Class::XSAccessor::Array.
  No user-serviceable parts inside!
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  L<Class::XSAccessor::Array>
  
  =head1 AUTHOR
  
  Steffen Mueller, E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy, E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
  
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_HEAVY

$fatpacked{"x86_64-linux-thread-multi/JSON/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_JSON_SYCK';
  package JSON::Syck;
  use strict;
  use vars qw( $VERSION @EXPORT_OK @ISA );
  use Exporter;
  use YAML::Syck ();
  
  BEGIN {
      $VERSION   = '1.27';
      @EXPORT_OK = qw( Load Dump LoadFile DumpFile DumpInto );
      @ISA       = 'Exporter';
      *Load      = \&YAML::Syck::LoadJSON;
      *Dump      = \&YAML::Syck::DumpJSON;
  }
  
  sub DumpFile {
      my $file = shift;
      if ( YAML::Syck::_is_glob($file) ) {
          my $err = YAML::Syck::DumpJSONFile( $_[0], $file );
          if ($err) {
              $! = 0 + $err;
              die "Error writing to filehandle $file: $!\n";
          }
      }
      else {
          open( my $fh, '>', $file ) or die "Cannot write to $file: $!";
          my $err = YAML::Syck::DumpJSONFile( $_[0], $fh );
          if ($err) {
              $! = 0 + $err;
              die "Error writing to file $file: $!\n";
          }
          close $fh
            or die "Error writing to file $file: $!\n";
      }
      return 1;
  }
  
  sub LoadFile {
      my $file = shift;
      if ( YAML::Syck::_is_glob($file) ) {
          YAML::Syck::LoadJSON(
              do { local $/; <$file> }
          );
      }
      else {
          if ( !-e $file || -z $file ) {
              die("'$file' is non-existent or empty");
          }
          open( my $fh, '<', $file ) or die "Cannot read from $file: $!";
          YAML::Syck::LoadJSON(
              do { local $/; <$fh> }
          );
      }
  }
  
  sub DumpInto {
      my $bufref = shift;
      ( ref $bufref ) or die "DumpInto not given reference to output buffer\n";
      YAML::Syck::DumpJSONInto( $_[0], $bufref );
      1;
  }
  
  $JSON::Syck::ImplicitTyping  = 1;
  $JSON::Syck::MaxDepth        = 512;
  $JSON::Syck::Headless        = 1;
  $JSON::Syck::ImplicitUnicode = 0;
  $JSON::Syck::SingleQuote     = 0;
  
  1;
  
  __END__
  
  =head1 NAME
  
  JSON::Syck - JSON is YAML (but consider using L<JSON::XS> instead!)
  
  =head1 SYNOPSIS
  
      use JSON::Syck; # no exports by default 
  
      my $data = JSON::Syck::Load($json);
      my $json = JSON::Syck::Dump($data);
  
      # $file can be an IO object, or a filename
      my $data = JSON::Syck::LoadFile($file);
      JSON::Syck::DumpFile($file, $data);
  
      # Dump into a pre-existing buffer
      my $json;
      JSON::Syck::DumpInto(\$json, $data);
  
  =head1 DESCRIPTION
  
  JSON::Syck is a syck implementation of JSON parsing and generation. Because
  JSON is YAML (L<http://redhanded.hobix.com/inspect/yamlIsJson.html>), using
  syck gives you a fast and memory-efficient parser and dumper for JSON data
  representation.
  
  However, a newer module L<JSON::XS>, has since emerged.  It is more flexible,
  efficient and robust, so please consider using it instead of this module.
  
  =head1 DIFFERENCE WITH JSON
  
  You might want to know the difference between the I<JSON> module and
  this one.
  
  Since JSON is a pure-perl module and JSON::Syck is based on libsyck,
  JSON::Syck is supposed to be very fast and memory efficient. See
  chansen's benchmark table at
  L<http://idisk.mac.com/christian.hansen/Public/perl/serialize.pl>
  
  JSON.pm comes with dozens of ways to do the same thing and lots of
  options, while JSON::Syck doesn't. There's only C<Load> and C<Dump>.
  
  Oh, and JSON::Syck doesn't use camelCase method names :-)
  
  =head1 REFERENCES
  
  =head2 SCALAR REFERENCE
  
  For now, when you pass a scalar reference to JSON::Syck, it
  dereferences to get the actual scalar value.
  
  JSON::Syck raises an exception when you pass in circular references.
  
  If you want to serialize self refernecing stuff, you should use
  YAML which supports it.
  
  =head2 SUBROUTINE REFERENCE
  
  When you pass subroutine reference, JSON::Syck dumps it as null.
  
  =head1 UTF-8 FLAGS
  
  By default this module doesn't touch any of utf-8 flags set in
  strings, and assumes UTF-8 bytes to be passed and emit.
  
  However, when you set C<$JSON::Syck::ImplicitUnicode> to 1, this
  module properly decodes UTF-8 binaries and sets UTF-8 flag everywhere,
  as in:
  
    JSON (UTF-8 bytes)   => Perl (UTF-8 flagged)
    JSON (UTF-8 flagged) => Perl (UTF-8 flagged)
    Perl (UTF-8 bytes)   => JSON (UTF-8 flagged)
    Perl (UTF-8 flagged) => JSON (UTF-8 flagged)
  
  By default, JSON::Syck::Dump will only transverse up to 512 levels of
  a datastructure in order to avoid an infinite loop when it is
  presented with an circular reference.
  
  However, you set C<$JSON::Syck::MaxLevels> to a larger value if you
  have very complex structures.
  
  Unfortunately, there's no implicit way to dump Perl UTF-8 flagged data
  structure to utf-8 encoded JSON. To do this, simply use Encode module, e.g.:
  
    use Encode;
    use JSON::Syck qw(Dump);
  
    my $json = encode_utf8( Dump($data) );
  
  Alternatively you can use Encode::JavaScript::UCS to encode Unicode
  strings as in I<%uXXXX> form.
  
    use Encode;
    use Encode::JavaScript::UCS;
    use JSON::Syck qw(Dump);
  
    my $json_unicode_escaped = encode( 'JavaScript-UCS', Dump($data) );
  
  =head1 QUOTING
  
  According to the JSON specification, all JSON strings are to be double-quoted.
  However, when embedding JavaScript in HTML attributes, it may be more
  convenient to use single quotes.
  
  Set C<$JSON::Syck::SingleQuote> to 1 will make both C<Dump> and C<Load> expect
  single-quoted string literals.
  
  =head1 BUGS
  
  Dumping into tied (or other magic variables) with C<DumpInto> might not work
  properly in all cases.
  
  When dumping with C<DumpFile>, some spacing might be wrong and
  C<$JSON::Syck::SingleQuote> might be handled incorrectly.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<YAML::Syck>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  Tatsuhiko Miyagawa E<lt>miyagawa@gmail.comE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005-2009 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  The F<libsyck> code bundled with this library is released by
  "why the lucky stiff", under a BSD-style license.  See the F<COPYING>
  file for details.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
X86_64-LINUX-THREAD-MULTI_JSON_SYCK

$fatpacked{"x86_64-linux-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL';
  # List::Util.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # This module is normally only loaded if the XS module is not available
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(first min max minstr maxstr reduce sum sum0 shuffle pairmap pairgrep pairfirst pairs pairkeys pairvalues);
  our $VERSION    = "1.32";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub sum0
  {
     return 0 unless @_;
     goto &sum;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce BLOCK LIST
  
  Reduces LIST by calling BLOCK, in a scalar context, multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a>
  and C<$b> set to the first two elements of the list, subsequent
  calls will be done by setting C<$a> to the result of the previous
  call and C<$b> to the next element in the list.
  
  Returns the result of the last call to BLOCK. If LIST is empty then
  C<undef> is returned. If LIST only contains one element then that
  element is returned and BLOCK is not executed.
  
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
  If your algorithm requires that C<reduce> produce an identity value, then
  make sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this
  generic idea.
  
  =head2 first BLOCK LIST
  
  Similar to C<grep> in that it evaluates BLOCK setting C<$_> to each element
  of LIST in turn. C<first> returns the first element where the result from
  BLOCK is a true value. If BLOCK never returns true or LIST was empty then
  C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { defined($a) ? $a : wanted($b) ? $b : undef } undef, @list
  
  for example wanted() could be defined() which would return the first
  defined value in @list
  
  =head2 max LIST
  
  Returns the entry in the list with the highest numerical value. If the
  list is empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a > $b ? $a : $b } 1..10
  
  =head2 maxstr LIST
  
  Similar to C<max>, but treats all the entries in the list as strings
  and returns the highest string as defined by the C<gt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'
  
  =head2 min LIST
  
  Similar to C<max> but returns the entry in the list with the lowest
  numerical value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a < $b ? $a : $b } 1..10
  
  =head2 minstr LIST
  
  Similar to C<min>, but treats all the entries in the list as strings
  and returns the lowest string as defined by the C<lt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a lt $b ? $a : $b } 'A'..'Z'
  
  =head2 sum LIST
  
  Returns the sum of all the elements in LIST. If LIST is empty then
  C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a + $b } 1..10
  
  =head2 sum0 LIST
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume
  an even-sized list of pairs. The pairs may be key/value associations from a
  hash, or just a list of values. The functions will all preserve the original
  ordering of the pairs, and will not be confused by multiple pairs having the
  same "key" value - nor even do they require that the first of each pair be a
  plain string.
  
  =cut
  
  =head2 pairgrep BLOCK KVLIST
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns an even-sized list of those pairs for which the BLOCK returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size
  of the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  Similar to C<grep>, C<pairgrep> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairfirst BLOCK KVLIST
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns the first pair of values from the list for which the BLOCK returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  Similar to C<grep>, C<pairfirst> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairmap BLOCK KVLIST
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns the concatenation of all the values returned by the BLOCK in list
  context, or the count of the number of items that would have been returned
  in scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  Similar to C<map>, C<pairmap> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairs KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of ARRAY references, each containing two items from
  the given list. It is a more efficient version of
  
      pairmap { [ $a, $b ] } KVLIST
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 pairkeys KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of the the first values of each of the pairs in
  the given list. It is a more efficient version of
  
      pairmap { $a } KVLIST
  
  =head2 pairvalues KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of the the second values of each of the pairs in
  the given list. It is a more efficient version of
  
      pairmap { $b } KVLIST
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle LIST
  
  Returns the elements of LIST in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce
  will return an incorrect result. This will show up as test 7 of
  reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # One argument is true
  
    sub any { $_ && return 1 for @_; 0 }
  
    # All arguments are true
  
    sub all { $_ || return 0 for @_; 1 }
  
    # All arguments are false
  
    sub none { $_ && return 0 for @_; 1 }
  
    # One argument is false
  
    sub notall { $_ || return 1 for @_; 0 }
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.32";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Scalar::Util.pm
  #
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed
    dualvar
    isdual
    isvstring
    isweak
    looks_like_number
    openhandle
    readonly
    refaddr
    reftype
    set_prototype
    tainted
    weaken
  );
  our $VERSION    = "1.32";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines. The
  subroutines defined are
  
  =head2 blessed EXPR
  
  If EXPR evaluates to a blessed reference the name of the package
  that it is blessed into is returned. Otherwise C<undef> is returned.
  
     $scalar = "foo";
     $class  = blessed $scalar;           # undef
  
     $ref    = [];
     $class  = blessed $ref;              # undef
  
     $obj    = bless [], "Foo";
     $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet
  false.
  
  =head2 dualvar NUM, STRING
  
  Returns a scalar that has the value NUM in a numeric context and the
  value STRING in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual EXPR
  
  If EXPR is a scalar that is a dualvar, the result is true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content
  through numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is
  actually implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring EXPR
  
  If EXPR is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number EXPR
  
  Returns true if perl thinks EXPR is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle FH
  
  Returns FH if FH may be used as a filehandle and is open, or FH is a tied
  handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly SCALAR
  
  Returns true if SCALAR is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 refaddr EXPR
  
  If EXPR evaluates to a reference the internal memory address of
  the referenced value is returned. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype EXPR
  
  If EXPR evaluates to a reference the type of the variable referenced
  is returned. Otherwise C<undef> is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 set_prototype CODEREF, PROTOTYPE
  
  Sets the prototype of the given function, or deletes it if PROTOTYPE is
  undef. Returns the CODEREF.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted EXPR
  
  Return true if the result of EXPR is tainted
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head2 weaken REF
  
  REF will be turned into a weak reference. This means that it will not
  hold a reference count on the object it references. Also when the reference
  count on that object reaches zero, REF will be set to undef.
  
  This is useful for keeping copies of references , but you don't want to
  prevent the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference,
  the copy will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never
  be destroyed because there is now always a strong reference to them in the
  @object array.
  
  =head2 isweak EXPR
  
  If EXPR is a scalar which is a weak reference the result is true.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to use
  C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its functions
  so that those without access to a C compiler may still use it. However some of the functions
  are only available when a C compiler was available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-thread-multi/Storable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_STORABLE';
  #
  #  Copyright (c) 1995-2001, Raphael Manfredi
  #  Copyright (c) 2002-2013 by the Perl 5 Porters
  #  
  #  You may redistribute only under the same terms as Perl 5, as specified
  #  in the README file that comes with the distribution.
  #
  
  require XSLoader;
  require Exporter;
  package Storable; @ISA = qw(Exporter);
  
  @EXPORT = qw(store retrieve);
  @EXPORT_OK = qw(
  	nstore store_fd nstore_fd fd_retrieve
  	freeze nfreeze thaw
  	dclone
  	retrieve_fd
  	lock_store lock_nstore lock_retrieve
          file_magic read_magic
  );
  
  use vars qw($canonical $forgive_me $VERSION);
  
  $VERSION = '2.45';
  
  BEGIN {
      if (eval { local $SIG{__DIE__}; require Log::Agent; 1 }) {
          Log::Agent->import;
      }
      #
      # Use of Log::Agent is optional. If it hasn't imported these subs then
      # provide a fallback implementation.
      #
      unless ($Storable::{logcroak} && *{$Storable::{logcroak}}{CODE}) {
          require Carp;
          *logcroak = sub {
              Carp::croak(@_);
          };
      }
      unless ($Storable::{logcarp} && *{$Storable::{logcarp}}{CODE}) {
  	require Carp;
          *logcarp = sub {
            Carp::carp(@_);
          };
      }
  }
  
  #
  # They might miss :flock in Fcntl
  #
  
  BEGIN {
  	if (eval { require Fcntl; 1 } && exists $Fcntl::EXPORT_TAGS{'flock'}) {
  		Fcntl->import(':flock');
  	} else {
  		eval q{
  			sub LOCK_SH ()	{1}
  			sub LOCK_EX ()	{2}
  		};
  	}
  }
  
  sub CLONE {
      # clone context under threads
      Storable::init_perinterp();
  }
  
  # By default restricted hashes are downgraded on earlier perls.
  
  $Storable::downgrade_restricted = 1;
  $Storable::accept_future_minor = 1;
  
  XSLoader::load('Storable', $Storable::VERSION);
  
  #
  # Determine whether locking is possible, but only when needed.
  #
  
  sub CAN_FLOCK; my $CAN_FLOCK; sub CAN_FLOCK {
  	return $CAN_FLOCK if defined $CAN_FLOCK;
  	require Config; import Config;
  	return $CAN_FLOCK =
  		$Config{'d_flock'} ||
  		$Config{'d_fcntl_can_lock'} ||
  		$Config{'d_lockf'};
  }
  
  sub show_file_magic {
      print <<EOM;
  #
  # To recognize the data files of the Perl module Storable,
  # the following lines need to be added to the local magic(5) file,
  # usually either /usr/share/misc/magic or /etc/magic.
  #
  0	string	perl-store	perl Storable(v0.6) data
  >4	byte	>0	(net-order %d)
  >>4	byte	&01	(network-ordered)
  >>4	byte	=3	(major 1)
  >>4	byte	=2	(major 1)
  
  0	string	pst0	perl Storable(v0.7) data
  >4	byte	>0
  >>4	byte	&01	(network-ordered)
  >>4	byte	=5	(major 2)
  >>4	byte	=4	(major 2)
  >>5	byte	>0	(minor %d)
  EOM
  }
  
  sub file_magic {
      require IO::File;
  
      my $file = shift;
      my $fh = IO::File->new;
      open($fh, "<". $file) || die "Can't open '$file': $!";
      binmode($fh);
      defined(sysread($fh, my $buf, 32)) || die "Can't read from '$file': $!";
      close($fh);
  
      $file = "./$file" unless $file;  # ensure TRUE value
  
      return read_magic($buf, $file);
  }
  
  sub read_magic {
      my($buf, $file) = @_;
      my %info;
  
      my $buflen = length($buf);
      my $magic;
      if ($buf =~ s/^(pst0|perl-store)//) {
  	$magic = $1;
  	$info{file} = $file || 1;
      }
      else {
  	return undef if $file;
  	$magic = "";
      }
  
      return undef unless length($buf);
  
      my $net_order;
      if ($magic eq "perl-store" && ord(substr($buf, 0, 1)) > 1) {
  	$info{version} = -1;
  	$net_order = 0;
      }
      else {
  	$buf =~ s/(.)//s;
  	my $major = (ord $1) >> 1;
  	return undef if $major > 4; # sanity (assuming we never go that high)
  	$info{major} = $major;
  	$net_order = (ord $1) & 0x01;
  	if ($major > 1) {
  	    return undef unless $buf =~ s/(.)//s;
  	    my $minor = ord $1;
  	    $info{minor} = $minor;
  	    $info{version} = "$major.$minor";
  	    $info{version_nv} = sprintf "%d.%03d", $major, $minor;
  	}
  	else {
  	    $info{version} = $major;
  	}
      }
      $info{version_nv} ||= $info{version};
      $info{netorder} = $net_order;
  
      unless ($net_order) {
  	return undef unless $buf =~ s/(.)//s;
  	my $len = ord $1;
  	return undef unless length($buf) >= $len;
  	return undef unless $len == 4 || $len == 8;  # sanity
  	@info{qw(byteorder intsize longsize ptrsize)}
  	    = unpack "a${len}CCC", $buf;
  	(substr $buf, 0, $len + 3) = '';
  	if ($info{version_nv} >= 2.002) {
  	    return undef unless $buf =~ s/(.)//s;
  	    $info{nvsize} = ord $1;
  	}
      }
      $info{hdrsize} = $buflen - length($buf);
  
      return \%info;
  }
  
  sub BIN_VERSION_NV {
      sprintf "%d.%03d", BIN_MAJOR(), BIN_MINOR();
  }
  
  sub BIN_WRITE_VERSION_NV {
      sprintf "%d.%03d", BIN_MAJOR(), BIN_WRITE_MINOR();
  }
  
  #
  # store
  #
  # Store target object hierarchy, identified by a reference to its root.
  # The stored object tree may later be retrieved to memory via retrieve.
  # Returns undef if an I/O error occurred, in which case the file is
  # removed.
  #
  sub store {
  	return _store(\&pstore, @_, 0);
  }
  
  #
  # nstore
  #
  # Same as store, but in network order.
  #
  sub nstore {
  	return _store(\&net_pstore, @_, 0);
  }
  
  #
  # lock_store
  #
  # Same as store, but flock the file first (advisory locking).
  #
  sub lock_store {
  	return _store(\&pstore, @_, 1);
  }
  
  #
  # lock_nstore
  #
  # Same as nstore, but flock the file first (advisory locking).
  #
  sub lock_nstore {
  	return _store(\&net_pstore, @_, 1);
  }
  
  # Internal store to file routine
  sub _store {
  	my $xsptr = shift;
  	my $self = shift;
  	my ($file, $use_locking) = @_;
  	logcroak "not a reference" unless ref($self);
  	logcroak "wrong argument number" unless @_ == 2;	# No @foo in arglist
  	local *FILE;
  	if ($use_locking) {
  		open(FILE, ">>$file") || logcroak "can't write into $file: $!";
  		unless (&CAN_FLOCK) {
  			logcarp "Storable::lock_store: fcntl/flock emulation broken on $^O";
  			return undef;
  		}
  		flock(FILE, LOCK_EX) ||
  			logcroak "can't get exclusive lock on $file: $!";
  		truncate FILE, 0;
  		# Unlocking will happen when FILE is closed
  	} else {
  		open(FILE, ">$file") || logcroak "can't create $file: $!";
  	}
  	binmode FILE;				# Archaic systems...
  	my $da = $@;				# Don't mess if called from exception handler
  	my $ret;
  	# Call C routine nstore or pstore, depending on network order
  	eval { $ret = &$xsptr(*FILE, $self) };
  	# close will return true on success, so the or short-circuits, the ()
  	# expression is true, and for that case the block will only be entered
  	# if $@ is true (ie eval failed)
  	# if close fails, it returns false, $ret is altered, *that* is (also)
  	# false, so the () expression is false, !() is true, and the block is
  	# entered.
  	if (!(close(FILE) or undef $ret) || $@) {
  		unlink($file) or warn "Can't unlink $file: $!\n";
  	}
  	logcroak $@ if $@ =~ s/\.?\n$/,/;
  	$@ = $da;
  	return $ret;
  }
  
  #
  # store_fd
  #
  # Same as store, but perform on an already opened file descriptor instead.
  # Returns undef if an I/O error occurred.
  #
  sub store_fd {
  	return _store_fd(\&pstore, @_);
  }
  
  #
  # nstore_fd
  #
  # Same as store_fd, but in network order.
  #
  sub nstore_fd {
  	my ($self, $file) = @_;
  	return _store_fd(\&net_pstore, @_);
  }
  
  # Internal store routine on opened file descriptor
  sub _store_fd {
  	my $xsptr = shift;
  	my $self = shift;
  	my ($file) = @_;
  	logcroak "not a reference" unless ref($self);
  	logcroak "too many arguments" unless @_ == 1;	# No @foo in arglist
  	my $fd = fileno($file);
  	logcroak "not a valid file descriptor" unless defined $fd;
  	my $da = $@;				# Don't mess if called from exception handler
  	my $ret;
  	# Call C routine nstore or pstore, depending on network order
  	eval { $ret = &$xsptr($file, $self) };
  	logcroak $@ if $@ =~ s/\.?\n$/,/;
  	local $\; print $file '';	# Autoflush the file if wanted
  	$@ = $da;
  	return $ret;
  }
  
  #
  # freeze
  #
  # Store object and its hierarchy in memory and return a scalar
  # containing the result.
  #
  sub freeze {
  	_freeze(\&mstore, @_);
  }
  
  #
  # nfreeze
  #
  # Same as freeze but in network order.
  #
  sub nfreeze {
  	_freeze(\&net_mstore, @_);
  }
  
  # Internal freeze routine
  sub _freeze {
  	my $xsptr = shift;
  	my $self = shift;
  	logcroak "not a reference" unless ref($self);
  	logcroak "too many arguments" unless @_ == 0;	# No @foo in arglist
  	my $da = $@;				# Don't mess if called from exception handler
  	my $ret;
  	# Call C routine mstore or net_mstore, depending on network order
  	eval { $ret = &$xsptr($self) };
  	logcroak $@ if $@ =~ s/\.?\n$/,/;
  	$@ = $da;
  	return $ret ? $ret : undef;
  }
  
  #
  # retrieve
  #
  # Retrieve object hierarchy from disk, returning a reference to the root
  # object of that tree.
  #
  sub retrieve {
  	_retrieve($_[0], 0);
  }
  
  #
  # lock_retrieve
  #
  # Same as retrieve, but with advisory locking.
  #
  sub lock_retrieve {
  	_retrieve($_[0], 1);
  }
  
  # Internal retrieve routine
  sub _retrieve {
  	my ($file, $use_locking) = @_;
  	local *FILE;
  	open(FILE, $file) || logcroak "can't open $file: $!";
  	binmode FILE;							# Archaic systems...
  	my $self;
  	my $da = $@;							# Could be from exception handler
  	if ($use_locking) {
  		unless (&CAN_FLOCK) {
  			logcarp "Storable::lock_store: fcntl/flock emulation broken on $^O";
  			return undef;
  		}
  		flock(FILE, LOCK_SH) || logcroak "can't get shared lock on $file: $!";
  		# Unlocking will happen when FILE is closed
  	}
  	eval { $self = pretrieve(*FILE) };		# Call C routine
  	close(FILE);
  	logcroak $@ if $@ =~ s/\.?\n$/,/;
  	$@ = $da;
  	return $self;
  }
  
  #
  # fd_retrieve
  #
  # Same as retrieve, but perform from an already opened file descriptor instead.
  #
  sub fd_retrieve {
  	my ($file) = @_;
  	my $fd = fileno($file);
  	logcroak "not a valid file descriptor" unless defined $fd;
  	my $self;
  	my $da = $@;							# Could be from exception handler
  	eval { $self = pretrieve($file) };		# Call C routine
  	logcroak $@ if $@ =~ s/\.?\n$/,/;
  	$@ = $da;
  	return $self;
  }
  
  sub retrieve_fd { &fd_retrieve }		# Backward compatibility
  
  #
  # thaw
  #
  # Recreate objects in memory from an existing frozen image created
  # by freeze.  If the frozen image passed is undef, return undef.
  #
  sub thaw {
  	my ($frozen) = @_;
  	return undef unless defined $frozen;
  	my $self;
  	my $da = $@;							# Could be from exception handler
  	eval { $self = mretrieve($frozen) };	# Call C routine
  	logcroak $@ if $@ =~ s/\.?\n$/,/;
  	$@ = $da;
  	return $self;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Storable - persistence for Perl data structures
  
  =head1 SYNOPSIS
  
   use Storable;
   store \%table, 'file';
   $hashref = retrieve('file');
  
   use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);
  
   # Network order
   nstore \%table, 'file';
   $hashref = retrieve('file');	# There is NO nretrieve()
  
   # Storing to and retrieving from an already opened file
   store_fd \@array, \*STDOUT;
   nstore_fd \%table, \*STDOUT;
   $aryref = fd_retrieve(\*SOCKET);
   $hashref = fd_retrieve(\*SOCKET);
  
   # Serializing to memory
   $serialized = freeze \%table;
   %table_clone = %{ thaw($serialized) };
  
   # Deep (recursive) cloning
   $cloneref = dclone($ref);
  
   # Advisory locking
   use Storable qw(lock_store lock_nstore lock_retrieve)
   lock_store \%table, 'file';
   lock_nstore \%table, 'file';
   $hashref = lock_retrieve('file');
  
  =head1 DESCRIPTION
  
  The Storable package brings persistence to your Perl data structures
  containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be
  conveniently stored to disk and retrieved at a later time.
  
  It can be used in the regular procedural way by calling C<store> with
  a reference to the object to be stored, along with the file name where
  the image should be written.
  
  The routine returns C<undef> for I/O problems or other internal error,
  a true value otherwise. Serious errors are propagated as a C<die> exception.
  
  To retrieve data stored to disk, use C<retrieve> with a file name.
  The objects stored into that file are recreated into memory for you,
  and a I<reference> to the root object is returned. In case an I/O error
  occurs while reading, C<undef> is returned instead. Other serious
  errors are propagated via C<die>.
  
  Since storage is performed recursively, you might want to stuff references
  to objects that share a lot of common data into a single array or hash
  table, and then store that object. That way, when you retrieve back the
  whole thing, the objects will continue to share what they originally shared.
  
  At the cost of a slight header overhead, you may store to an already
  opened file descriptor using the C<store_fd> routine, and retrieve
  from a file via C<fd_retrieve>. Those names aren't imported by default,
  so you will have to do that explicitly if you need those routines.
  The file descriptor you supply must be already opened, for read
  if you're going to retrieve and for write if you wish to store.
  
  	store_fd(\%table, *STDOUT) || die "can't store to stdout\n";
  	$hashref = fd_retrieve(*STDIN);
  
  You can also store data in network order to allow easy sharing across
  multiple platforms, or when storing on a socket known to be remotely
  connected. The routines to call have an initial C<n> prefix for I<network>,
  as in C<nstore> and C<nstore_fd>. At retrieval time, your data will be
  correctly restored so you don't have to know whether you're restoring
  from native or network ordered data.  Double values are stored stringified
  to ensure portability as well, at the slight risk of loosing some precision
  in the last decimals.
  
  When using C<fd_retrieve>, objects are retrieved in sequence, one
  object (i.e. one recursive tree) per associated C<store_fd>.
  
  If you're more from the object-oriented camp, you can inherit from
  Storable and directly store your objects by invoking C<store> as
  a method. The fact that the root of the to-be-stored tree is a
  blessed reference (i.e. an object) is special-cased so that the
  retrieve does not provide a reference to that object but rather the
  blessed object reference itself. (Otherwise, you'd get a reference
  to that blessed object).
  
  =head1 MEMORY STORE
  
  The Storable engine can also store data into a Perl scalar instead, to
  later retrieve them. This is mainly used to freeze a complex structure in
  some safe compact memory place (where it can possibly be sent to another
  process via some IPC, since freezing the structure also serializes it in
  effect). Later on, and maybe somewhere else, you can thaw the Perl scalar
  out and recreate the original complex structure in memory.
  
  Surprisingly, the routines to be called are named C<freeze> and C<thaw>.
  If you wish to send out the frozen scalar to another machine, use
  C<nfreeze> instead to get a portable image.
  
  Note that freezing an object structure and immediately thawing it
  actually achieves a deep cloning of that structure:
  
      dclone(.) = thaw(freeze(.))
  
  Storable provides you with a C<dclone> interface which does not create
  that intermediary scalar but instead freezes the structure in some
  internal memory space and then immediately thaws it out.
  
  =head1 ADVISORY LOCKING
  
  The C<lock_store> and C<lock_nstore> routine are equivalent to
  C<store> and C<nstore>, except that they get an exclusive lock on
  the file before writing.  Likewise, C<lock_retrieve> does the same
  as C<retrieve>, but also gets a shared lock on the file before reading.
  
  As with any advisory locking scheme, the protection only works if you
  systematically use C<lock_store> and C<lock_retrieve>.  If one side of
  your application uses C<store> whilst the other uses C<lock_retrieve>,
  you will get no protection at all.
  
  The internal advisory locking is implemented using Perl's flock()
  routine.  If your system does not support any form of flock(), or if
  you share your files across NFS, you might wish to use other forms
  of locking by using modules such as LockFile::Simple which lock a
  file using a filesystem entry, instead of locking the file descriptor.
  
  =head1 SPEED
  
  The heart of Storable is written in C for decent speed. Extra low-level
  optimizations have been made when manipulating perl internals, to
  sacrifice encapsulation for the benefit of greater speed.
  
  =head1 CANONICAL REPRESENTATION
  
  Normally, Storable stores elements of hashes in the order they are
  stored internally by Perl, i.e. pseudo-randomly.  If you set
  C<$Storable::canonical> to some C<TRUE> value, Storable will store
  hashes with the elements sorted by their key.  This allows you to
  compare data structures by comparing their frozen representations (or
  even the compressed frozen representations), which can be useful for
  creating lookup tables for complicated queries.
  
  Canonical order does not imply network order; those are two orthogonal
  settings.
  
  =head1 CODE REFERENCES
  
  Since Storable version 2.05, CODE references may be serialized with
  the help of L<B::Deparse>. To enable this feature, set
  C<$Storable::Deparse> to a true value. To enable deserialization,
  C<$Storable::Eval> should be set to a true value. Be aware that
  deserialization is done through C<eval>, which is dangerous if the
  Storable file contains malicious data. You can set C<$Storable::Eval>
  to a subroutine reference which would be used instead of C<eval>. See
  below for an example using a L<Safe> compartment for deserialization
  of CODE references.
  
  If C<$Storable::Deparse> and/or C<$Storable::Eval> are set to false
  values, then the value of C<$Storable::forgive_me> (see below) is
  respected while serializing and deserializing.
  
  =head1 FORWARD COMPATIBILITY
  
  This release of Storable can be used on a newer version of Perl to
  serialize data which is not supported by earlier Perls.  By default,
  Storable will attempt to do the right thing, by C<croak()>ing if it
  encounters data that it cannot deserialize.  However, the defaults
  can be changed as follows:
  
  =over 4
  
  =item utf8 data
  
  Perl 5.6 added support for Unicode characters with code points > 255,
  and Perl 5.8 has full support for Unicode characters in hash keys.
  Perl internally encodes strings with these characters using utf8, and
  Storable serializes them as utf8.  By default, if an older version of
  Perl encounters a utf8 value it cannot represent, it will C<croak()>.
  To change this behaviour so that Storable deserializes utf8 encoded
  values as the string of bytes (effectively dropping the I<is_utf8> flag)
  set C<$Storable::drop_utf8> to some C<TRUE> value.  This is a form of
  data loss, because with C<$drop_utf8> true, it becomes impossible to tell
  whether the original data was the Unicode string, or a series of bytes
  that happen to be valid utf8.
  
  =item restricted hashes
  
  Perl 5.8 adds support for restricted hashes, which have keys
  restricted to a given set, and can have values locked to be read only.
  By default, when Storable encounters a restricted hash on a perl
  that doesn't support them, it will deserialize it as a normal hash,
  silently discarding any placeholder keys and leaving the keys and
  all values unlocked.  To make Storable C<croak()> instead, set
  C<$Storable::downgrade_restricted> to a C<FALSE> value.  To restore
  the default set it back to some C<TRUE> value.
  
  =item files from future versions of Storable
  
  Earlier versions of Storable would immediately croak if they encountered
  a file with a higher internal version number than the reading Storable
  knew about.  Internal version numbers are increased each time new data
  types (such as restricted hashes) are added to the vocabulary of the file
  format.  This meant that a newer Storable module had no way of writing a
  file readable by an older Storable, even if the writer didn't store newer
  data types.
  
  This version of Storable will defer croaking until it encounters a data
  type in the file that it does not recognize.  This means that it will
  continue to read files generated by newer Storable modules which are careful
  in what they write out, making it easier to upgrade Storable modules in a
  mixed environment.
  
  The old behaviour of immediate croaking can be re-instated by setting
  C<$Storable::accept_future_minor> to some C<FALSE> value.
  
  =back
  
  All these variables have no effect on a newer Perl which supports the
  relevant feature.
  
  =head1 ERROR REPORTING
  
  Storable uses the "exception" paradigm, in that it does not try to workaround
  failures: if something bad happens, an exception is generated from the
  caller's perspective (see L<Carp> and C<croak()>).  Use eval {} to trap
  those exceptions.
  
  When Storable croaks, it tries to report the error via the C<logcroak()>
  routine from the C<Log::Agent> package, if it is available.
  
  Normal errors are reported by having store() or retrieve() return C<undef>.
  Such errors are usually I/O errors (or truncated stream errors at retrieval).
  
  =head1 WIZARDS ONLY
  
  =head2 Hooks
  
  Any class may define hooks that will be called during the serialization
  and deserialization process on objects that are instances of that class.
  Those hooks can redefine the way serialization is performed (and therefore,
  how the symmetrical deserialization should be conducted).
  
  Since we said earlier:
  
      dclone(.) = thaw(freeze(.))
  
  everything we say about hooks should also hold for deep cloning. However,
  hooks get to know whether the operation is a mere serialization, or a cloning.
  
  Therefore, when serializing hooks are involved,
  
      dclone(.) <> thaw(freeze(.))
  
  Well, you could keep them in sync, but there's no guarantee it will always
  hold on classes somebody else wrote.  Besides, there is little to gain in
  doing so: a serializing hook could keep only one attribute of an object,
  which is probably not what should happen during a deep cloning of that
  same object.
  
  Here is the hooking interface:
  
  =over 4
  
  =item C<STORABLE_freeze> I<obj>, I<cloning>
  
  The serializing hook, called on the object during serialization.  It can be
  inherited, or defined in the class itself, like any other method.
  
  Arguments: I<obj> is the object to serialize, I<cloning> is a flag indicating
  whether we're in a dclone() or a regular serialization via store() or freeze().
  
  Returned value: A LIST C<($serialized, $ref1, $ref2, ...)> where $serialized
  is the serialized form to be used, and the optional $ref1, $ref2, etc... are
  extra references that you wish to let the Storable engine serialize.
  
  At deserialization time, you will be given back the same LIST, but all the
  extra references will be pointing into the deserialized structure.
  
  The B<first time> the hook is hit in a serialization flow, you may have it
  return an empty list.  That will signal the Storable engine to further
  discard that hook for this class and to therefore revert to the default
  serialization of the underlying Perl data.  The hook will again be normally
  processed in the next serialization.
  
  Unless you know better, serializing hook should always say:
  
      sub STORABLE_freeze {
          my ($self, $cloning) = @_;
          return if $cloning;         # Regular default serialization
          ....
      }
  
  in order to keep reasonable dclone() semantics.
  
  =item C<STORABLE_thaw> I<obj>, I<cloning>, I<serialized>, ...
  
  The deserializing hook called on the object during deserialization.
  But wait: if we're deserializing, there's no object yet... right?
  
  Wrong: the Storable engine creates an empty one for you.  If you know Eiffel,
  you can view C<STORABLE_thaw> as an alternate creation routine.
  
  This means the hook can be inherited like any other method, and that
  I<obj> is your blessed reference for this particular instance.
  
  The other arguments should look familiar if you know C<STORABLE_freeze>:
  I<cloning> is true when we're part of a deep clone operation, I<serialized>
  is the serialized string you returned to the engine in C<STORABLE_freeze>,
  and there may be an optional list of references, in the same order you gave
  them at serialization time, pointing to the deserialized objects (which
  have been processed courtesy of the Storable engine).
  
  When the Storable engine does not find any C<STORABLE_thaw> hook routine,
  it tries to load the class by requiring the package dynamically (using
  the blessed package name), and then re-attempts the lookup.  If at that
  time the hook cannot be located, the engine croaks.  Note that this mechanism
  will fail if you define several classes in the same file, but L<perlmod>
  warned you.
  
  It is up to you to use this information to populate I<obj> the way you want.
  
  Returned value: none.
  
  =item C<STORABLE_attach> I<class>, I<cloning>, I<serialized>
  
  While C<STORABLE_freeze> and C<STORABLE_thaw> are useful for classes where
  each instance is independent, this mechanism has difficulty (or is
  incompatible) with objects that exist as common process-level or
  system-level resources, such as singleton objects, database pools, caches
  or memoized objects.
  
  The alternative C<STORABLE_attach> method provides a solution for these
  shared objects. Instead of C<STORABLE_freeze> --E<gt> C<STORABLE_thaw>,
  you implement C<STORABLE_freeze> --E<gt> C<STORABLE_attach> instead.
  
  Arguments: I<class> is the class we are attaching to, I<cloning> is a flag
  indicating whether we're in a dclone() or a regular de-serialization via
  thaw(), and I<serialized> is the stored string for the resource object.
  
  Because these resource objects are considered to be owned by the entire
  process/system, and not the "property" of whatever is being serialized,
  no references underneath the object should be included in the serialized
  string. Thus, in any class that implements C<STORABLE_attach>, the
  C<STORABLE_freeze> method cannot return any references, and C<Storable>
  will throw an error if C<STORABLE_freeze> tries to return references.
  
  All information required to "attach" back to the shared resource object
  B<must> be contained B<only> in the C<STORABLE_freeze> return string.
  Otherwise, C<STORABLE_freeze> behaves as normal for C<STORABLE_attach>
  classes.
  
  Because C<STORABLE_attach> is passed the class (rather than an object),
  it also returns the object directly, rather than modifying the passed
  object.
  
  Returned value: object of type C<class>
  
  =back
  
  =head2 Predicates
  
  Predicates are not exportable.  They must be called by explicitly prefixing
  them with the Storable package name.
  
  =over 4
  
  =item C<Storable::last_op_in_netorder>
  
  The C<Storable::last_op_in_netorder()> predicate will tell you whether
  network order was used in the last store or retrieve operation.  If you
  don't know how to use this, just forget about it.
  
  =item C<Storable::is_storing>
  
  Returns true if within a store operation (via STORABLE_freeze hook).
  
  =item C<Storable::is_retrieving>
  
  Returns true if within a retrieve operation (via STORABLE_thaw hook).
  
  =back
  
  =head2 Recursion
  
  With hooks comes the ability to recurse back to the Storable engine.
  Indeed, hooks are regular Perl code, and Storable is convenient when
  it comes to serializing and deserializing things, so why not use it
  to handle the serialization string?
  
  There are a few things you need to know, however:
  
  =over 4
  
  =item *
  
  You can create endless loops if the things you serialize via freeze()
  (for instance) point back to the object we're trying to serialize in
  the hook.
  
  =item *
  
  Shared references among objects will not stay shared: if we're serializing
  the list of object [A, C] where both object A and C refer to the SAME object
  B, and if there is a serializing hook in A that says freeze(B), then when
  deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D,
  a deep clone of B'.  The topology was not preserved.
  
  =back
  
  That's why C<STORABLE_freeze> lets you provide a list of references
  to serialize.  The engine guarantees that those will be serialized in the
  same context as the other objects, and therefore that shared objects will
  stay shared.
  
  In the above [A, C] example, the C<STORABLE_freeze> hook could return:
  
  	("something", $self->{B})
  
  and the B part would be serialized by the engine.  In C<STORABLE_thaw>, you
  would get back the reference to the B' object, deserialized for you.
  
  Therefore, recursion should normally be avoided, but is nonetheless supported.
  
  =head2 Deep Cloning
  
  There is a Clone module available on CPAN which implements deep cloning
  natively, i.e. without freezing to memory and thawing the result.  It is
  aimed to replace Storable's dclone() some day.  However, it does not currently
  support Storable hooks to redefine the way deep cloning is performed.
  
  =head1 Storable magic
  
  Yes, there's a lot of that :-) But more precisely, in UNIX systems
  there's a utility called C<file>, which recognizes data files based on
  their contents (usually their first few bytes).  For this to work,
  a certain file called F<magic> needs to taught about the I<signature>
  of the data.  Where that configuration file lives depends on the UNIX
  flavour; often it's something like F</usr/share/misc/magic> or
  F</etc/magic>.  Your system administrator needs to do the updating of
  the F<magic> file.  The necessary signature information is output to
  STDOUT by invoking Storable::show_file_magic().  Note that the GNU
  implementation of the C<file> utility, version 3.38 or later,
  is expected to contain support for recognising Storable files
  out-of-the-box, in addition to other kinds of Perl files.
  
  You can also use the following functions to extract the file header
  information from Storable images:
  
  =over
  
  =item $info = Storable::file_magic( $filename )
  
  If the given file is a Storable image return a hash describing it.  If
  the file is readable, but not a Storable image return C<undef>.  If
  the file does not exist or is unreadable then croak.
  
  The hash returned has the following elements:
  
  =over
  
  =item C<version>
  
  This returns the file format version.  It is a string like "2.7".
  
  Note that this version number is not the same as the version number of
  the Storable module itself.  For instance Storable v0.7 create files
  in format v2.0 and Storable v2.15 create files in format v2.7.  The
  file format version number only increment when additional features
  that would confuse older versions of the module are added.
  
  Files older than v2.0 will have the one of the version numbers "-1",
  "0" or "1".  No minor number was used at that time.
  
  =item C<version_nv>
  
  This returns the file format version as number.  It is a string like
  "2.007".  This value is suitable for numeric comparisons.
  
  The constant function C<Storable::BIN_VERSION_NV> returns a comparable
  number that represents the highest file version number that this
  version of Storable fully supports (but see discussion of
  C<$Storable::accept_future_minor> above).  The constant
  C<Storable::BIN_WRITE_VERSION_NV> function returns what file version
  is written and might be less than C<Storable::BIN_VERSION_NV> in some
  configurations.
  
  =item C<major>, C<minor>
  
  This also returns the file format version.  If the version is "2.7"
  then major would be 2 and minor would be 7.  The minor element is
  missing for when major is less than 2.
  
  =item C<hdrsize>
  
  The is the number of bytes that the Storable header occupies.
  
  =item C<netorder>
  
  This is TRUE if the image store data in network order.  This means
  that it was created with nstore() or similar.
  
  =item C<byteorder>
  
  This is only present when C<netorder> is FALSE.  It is the
  $Config{byteorder} string of the perl that created this image.  It is
  a string like "1234" (32 bit little endian) or "87654321" (64 bit big
  endian).  This must match the current perl for the image to be
  readable by Storable.
  
  =item C<intsize>, C<longsize>, C<ptrsize>, C<nvsize>
  
  These are only present when C<netorder> is FALSE. These are the sizes of
  various C datatypes of the perl that created this image.  These must
  match the current perl for the image to be readable by Storable.
  
  The C<nvsize> element is only present for file format v2.2 and
  higher.
  
  =item C<file>
  
  The name of the file.
  
  =back
  
  =item $info = Storable::read_magic( $buffer )
  
  =item $info = Storable::read_magic( $buffer, $must_be_file )
  
  The $buffer should be a Storable image or the first few bytes of it.
  If $buffer starts with a Storable header, then a hash describing the
  image is returned, otherwise C<undef> is returned.
  
  The hash has the same structure as the one returned by
  Storable::file_magic().  The C<file> element is true if the image is a
  file image.
  
  If the $must_be_file argument is provided and is TRUE, then return
  C<undef> unless the image looks like it belongs to a file dump.
  
  The maximum size of a Storable header is currently 21 bytes.  If the
  provided $buffer is only the first part of a Storable image it should
  at least be this long to ensure that read_magic() will recognize it as
  such.
  
  =back
  
  =head1 EXAMPLES
  
  Here are some code samples showing a possible usage of Storable:
  
  	use Storable qw(store retrieve freeze thaw dclone);
  
  	%color = ('Blue' => 0.1, 'Red' => 0.8, 'Black' => 0, 'White' => 1);
  
  	store(\%color, 'mycolors') or die "Can't store %a in mycolors!\n";
  
  	$colref = retrieve('mycolors');
  	die "Unable to retrieve from mycolors!\n" unless defined $colref;
  	printf "Blue is still %lf\n", $colref->{'Blue'};
  
  	$colref2 = dclone(\%color);
  
  	$str = freeze(\%color);
  	printf "Serialization of %%color is %d bytes long.\n", length($str);
  	$colref3 = thaw($str);
  
  which prints (on my machine):
  
  	Blue is still 0.100000
  	Serialization of %color is 102 bytes long.
  
  Serialization of CODE references and deserialization in a safe
  compartment:
  
  =for example begin
  
  	use Storable qw(freeze thaw);
  	use Safe;
  	use strict;
  	my $safe = new Safe;
          # because of opcodes used in "use strict":
  	$safe->permit(qw(:default require));
  	local $Storable::Deparse = 1;
  	local $Storable::Eval = sub { $safe->reval($_[0]) };
  	my $serialized = freeze(sub { 42 });
  	my $code = thaw($serialized);
  	$code->() == 42;
  
  =for example end
  
  =for example_testing
          is( $code->(), 42 );
  
  =head1 SECURITY WARNING
  
  B<Do not accept Storable documents from untrusted sources!>
  
  Some features of Storable can lead to security vulnerabilities if you
  accept Storable documents from untrusted sources. Most obviously, the
  optional (off by default) CODE reference serialization feature allows
  transfer of code to the deserializing process. Furthermore, any
  serialized object will cause Storable to helpfully load the module
  corresponding to the class of the object in the deserializing module.
  For manipulated module names, this can load almost arbitrary code.
  Finally, the deserialized object's destructors will be invoked when
  the objects get destroyed in the deserializing process. Maliciously
  crafted Storable documents may put such objects in the value of
  a hash key that is overridden by another key/value pair in the
  same hash, thus causing immediate destructor execution.
  
  In a future version of Storable, we intend to provide options to disable
  loading modules for classes and to disable deserializing objects
  altogether. I<Nonetheless, Storable deserializing documents from
  untrusted sources is expected to have other, yet undiscovered,
  security concerns such as allowing an attacker to cause the deserializer
  to crash hard.>
  
  B<Therefore, let me repeat: Do not accept Storable documents from
  untrusted sources!>
  
  If your application requires accepting data from untrusted sources, you
  are best off with a less powerful and more-likely safe serialization format
  and implementation. If your data is sufficiently simple, JSON is a good
  choice and offers maximum interoperability.
  
  =head1 WARNING
  
  If you're using references as keys within your hash tables, you're bound
  to be disappointed when retrieving your data. Indeed, Perl stringifies
  references used as hash table keys. If you later wish to access the
  items via another reference stringification (i.e. using the same
  reference that was used for the key originally to record the value into
  the hash table), it will work because both references stringify to the
  same string.
  
  It won't work across a sequence of C<store> and C<retrieve> operations,
  however, because the addresses in the retrieved objects, which are
  part of the stringified references, will probably differ from the
  original addresses. The topology of your structure is preserved,
  but not hidden semantics like those.
  
  On platforms where it matters, be sure to call C<binmode()> on the
  descriptors that you pass to Storable functions.
  
  Storing data canonically that contains large hashes can be
  significantly slower than storing the same data normally, as
  temporary arrays to hold the keys for each hash have to be allocated,
  populated, sorted and freed.  Some tests have shown a halving of the
  speed of storing -- the exact penalty will depend on the complexity of
  your data.  There is no slowdown on retrieval.
  
  =head1 BUGS
  
  You can't store GLOB, FORMLINE, REGEXP, etc.... If you can define semantics
  for those operations, feel free to enhance Storable so that it can
  deal with them.
  
  The store functions will C<croak> if they run into such references
  unless you set C<$Storable::forgive_me> to some C<TRUE> value. In that
  case, the fatal message is turned in a warning and some
  meaningless string is stored instead.
  
  Setting C<$Storable::canonical> may not yield frozen strings that
  compare equal due to possible stringification of numbers. When the
  string version of a scalar exists, it is the form stored; therefore,
  if you happen to use your numbers as strings between two freezing
  operations on the same data structures, you will get different
  results.
  
  When storing doubles in network order, their value is stored as text.
  However, you should also not expect non-numeric floating-point values
  such as infinity and "not a number" to pass successfully through a
  nstore()/retrieve() pair.
  
  As Storable neither knows nor cares about character sets (although it
  does know that characters may be more than eight bits wide), any difference
  in the interpretation of character codes between a host and a target
  system is your problem.  In particular, if host and target use different
  code points to represent the characters used in the text representation
  of floating-point numbers, you will not be able be able to exchange
  floating-point data, even with nstore().
  
  C<Storable::drop_utf8> is a blunt tool.  There is no facility either to
  return B<all> strings as utf8 sequences, or to attempt to convert utf8
  data back to 8 bit and C<croak()> if the conversion fails.
  
  Prior to Storable 2.01, no distinction was made between signed and
  unsigned integers on storing.  By default Storable prefers to store a
  scalars string representation (if it has one) so this would only cause
  problems when storing large unsigned integers that had never been converted
  to string or floating point.  In other words values that had been generated
  by integer operations such as logic ops and then not used in any string or
  arithmetic context before storing.
  
  =head2 64 bit data in perl 5.6.0 and 5.6.1
  
  This section only applies to you if you have existing data written out
  by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which
  has been configured with 64 bit integer support (not the default)
  If you got a precompiled perl, rather than running Configure to build
  your own perl from source, then it almost certainly does not affect you,
  and you can stop reading now (unless you're curious). If you're using perl
  on Windows it does not affect you.
  
  Storable writes a file header which contains the sizes of various C
  language types for the C compiler that built Storable (when not writing in
  network order), and will refuse to load files written by a Storable not
  on the same (or compatible) architecture.  This check and a check on
  machine byteorder is needed because the size of various fields in the file
  are given by the sizes of the C language types, and so files written on
  different architectures are incompatible.  This is done for increased speed.
  (When writing in network order, all fields are written out as standard
  lengths, which allows full interworking, but takes longer to read and write)
  
  Perl 5.6.x introduced the ability to optional configure the perl interpreter
  to use C's C<long long> type to allow scalars to store 64 bit integers on 32
  bit systems.  However, due to the way the Perl configuration system
  generated the C configuration files on non-Windows platforms, and the way
  Storable generates its header, nothing in the Storable file header reflected
  whether the perl writing was using 32 or 64 bit integers, despite the fact
  that Storable was storing some data differently in the file.  Hence Storable
  running on perl with 64 bit integers will read the header from a file
  written by a 32 bit perl, not realise that the data is actually in a subtly
  incompatible format, and then go horribly wrong (possibly crashing) if it
  encountered a stored integer.  This is a design failure.
  
  Storable has now been changed to write out and read in a file header with
  information about the size of integers.  It's impossible to detect whether
  an old file being read in was written with 32 or 64 bit integers (they have
  the same header) so it's impossible to automatically switch to a correct
  backwards compatibility mode.  Hence this Storable defaults to the new,
  correct behaviour.
  
  What this means is that if you have data written by Storable 1.x running
  on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux
  then by default this Storable will refuse to read it, giving the error
  I<Byte order is not compatible>.  If you have such data then you
  should set C<$Storable::interwork_56_64bit> to a true value to make this
  Storable read and write files with the old header.  You should also
  migrate your data, or any older perl you are communicating with, to this
  current version of Storable.
  
  If you don't have data written with specific configuration of perl described
  above, then you do not and should not do anything.  Don't set the flag -
  not only will Storable on an identically configured perl refuse to load them,
  but Storable a differently configured perl will load them believing them
  to be correct for it, and then may well fail or crash part way through
  reading them.
  
  =head1 CREDITS
  
  Thank you to (in chronological order):
  
  	Jarkko Hietaniemi <jhi@iki.fi>
  	Ulrich Pfeifer <pfeifer@charly.informatik.uni-dortmund.de>
  	Benjamin A. Holzman <bholzman@earthlink.net>
  	Andrew Ford <A.Ford@ford-mason.co.uk>
  	Gisle Aas <gisle@aas.no>
  	Jeff Gresham <gresham_jeffrey@jpmorgan.com>
  	Murray Nesbitt <murray@activestate.com>
  	Marc Lehmann <pcg@opengroup.org>
  	Justin Banks <justinb@wamnet.com>
  	Jarkko Hietaniemi <jhi@iki.fi> (AGAIN, as perl 5.7.0 Pumpkin!)
  	Salvador Ortiz Garcia <sog@msg.com.mx>
  	Dominic Dunlop <domo@computer.org>
  	Erik Haugan <erik@solbors.no>
  	Benjamin A. Holzman <ben.holzman@grantstreet.com>
  	Reini Urban <rurban@cpanel.net>
  
  for their bug reports, suggestions and contributions.
  
  Benjamin Holzman contributed the tied variable support, Andrew Ford
  contributed the canonical order for hashes, and Gisle Aas fixed
  a few misunderstandings of mine regarding the perl internals,
  and optimized the emission of "tags" in the output streams by
  simply counting the objects instead of tagging them (leading to
  a binary incompatibility for the Storable image starting at version
  0.6--older images are, of course, still properly understood).
  Murray Nesbitt made Storable thread-safe.  Marc Lehmann added overloading
  and references to tied items support.  Benjamin Holzman added a performance
  improvement for overloaded classes; thanks to Grant Street Group for footing
  the bill.
  
  =head1 AUTHOR
  
  Storable was written by Raphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>
  Maintenance is now done by the perl5-porters F<E<lt>perl5-porters@perl.orgE<gt>>
  
  Please e-mail us with problems, bug fixes, comments and complaints,
  although if you have compliments you should send them to Raphael.
  Please don't e-mail Raphael with problems, as he no longer works on
  Storable, and your message will be delayed while he forwards it to us.
  
  =head1 SEE ALSO
  
  L<Clone>.
  
  =cut
X86_64-LINUX-THREAD-MULTI_STORABLE

$fatpacked{"x86_64-linux-thread-multi/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
X86_64-LINUX-THREAD-MULTI_SUB_NAME

$fatpacked{"x86_64-linux-thread-multi/Time/Piece.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TIME_PIECE';
  package Time::Piece;
  
  use strict;
  
  require Exporter;
  require DynaLoader;
  use Time::Seconds;
  use Carp;
  use Time::Local;
  
  our @ISA = qw(Exporter DynaLoader);
  
  our @EXPORT = qw(
      localtime
      gmtime
  );
  
  our %EXPORT_TAGS = (
      ':override' => 'internal',
      );
  
  our $VERSION = '1.23';
  
  bootstrap Time::Piece $VERSION;
  
  my $DATE_SEP = '-';
  my $TIME_SEP = ':';
  my @MON_LIST = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  my @FULLMON_LIST = qw(January February March April May June July
                        August September October November December);
  my @DAY_LIST = qw(Sun Mon Tue Wed Thu Fri Sat);
  my @FULLDAY_LIST = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
  
  use constant 'c_sec' => 0;
  use constant 'c_min' => 1;
  use constant 'c_hour' => 2;
  use constant 'c_mday' => 3;
  use constant 'c_mon' => 4;
  use constant 'c_year' => 5;
  use constant 'c_wday' => 6;
  use constant 'c_yday' => 7;
  use constant 'c_isdst' => 8;
  use constant 'c_epoch' => 9;
  use constant 'c_islocal' => 10;
  
  sub localtime {
      unshift @_, __PACKAGE__ unless eval { $_[0]->isa('Time::Piece') };
      my $class = shift;
      my $time  = shift;
      $time = time if (!defined $time);
      $class->_mktime($time, 1);
  }
  
  sub gmtime {
      unshift @_, __PACKAGE__ unless eval { $_[0]->isa('Time::Piece') };
      my $class = shift;
      my $time  = shift;
      $time = time if (!defined $time);
      $class->_mktime($time, 0);
  }
  
  sub new {
      my $class = shift;
      my ($time) = @_;
      
      my $self;
      
      if (defined($time)) {
          $self = $class->localtime($time);
      }
      elsif (ref($class) && $class->isa(__PACKAGE__)) {
          $self = $class->_mktime($class->epoch, $class->[c_islocal]);
      }
      else {
          $self = $class->localtime();
      }
      
      return bless $self, ref($class) || $class;
  }
  
  sub parse {
      my $proto = shift;
      my $class = ref($proto) || $proto;
      my @components;
      if (@_ > 1) {
          @components = @_;
      }
      else {
          @components = shift =~ /(\d+)$DATE_SEP(\d+)$DATE_SEP(\d+)(?:(?:T|\s+)(\d+)$TIME_SEP(\d+)(?:$TIME_SEP(\d+)))/;
          @components = reverse(@components[0..5]);
      }
      return $class->new(_strftime("%s", @components));
  }
  
  sub _mktime {
      my ($class, $time, $islocal) = @_;
      $class = eval { (ref $class) && (ref $class)->isa('Time::Piece') }
             ? ref $class
             : $class;
      if (ref($time)) {
          $time->[c_epoch] = undef;
          return wantarray ? @$time : bless [@$time[0..9], $islocal], $class;
      }
      _tzset();
      my @time = $islocal ?
              CORE::localtime($time)
                  :
              CORE::gmtime($time);
      wantarray ? @time : bless [@time, $time, $islocal], $class;
  }
  
  my %_special_exports = (
    localtime => sub { my $c = $_[0]; sub { $c->localtime(@_) } },
    gmtime    => sub { my $c = $_[0]; sub { $c->gmtime(@_)    } },
  );
  
  sub export {
    my ($class, $to, @methods) = @_;
    for my $method (@methods) {
      if (exists $_special_exports{$method}) {
        no strict 'refs';
        no warnings 'redefine';
        *{$to . "::$method"} = $_special_exports{$method}->($class);
      } else {
        $class->SUPER::export($to, $method);
      }
    }
  }
  
  sub import {
      # replace CORE::GLOBAL localtime and gmtime if required
      my $class = shift;
      my %params;
      map($params{$_}++,@_,@EXPORT);
      if (delete $params{':override'}) {
          $class->export('CORE::GLOBAL', keys %params);
      }
      else {
          $class->export((caller)[0], keys %params);
      }
  }
  
  ## Methods ##
  
  sub sec {
      my $time = shift;
      $time->[c_sec];
  }
  
  *second = \&sec;
  
  sub min {
      my $time = shift;
      $time->[c_min];
  }
  
  *minute = \&min;
  
  sub hour {
      my $time = shift;
      $time->[c_hour];
  }
  
  sub mday {
      my $time = shift;
      $time->[c_mday];
  }
  
  *day_of_month = \&mday;
  
  sub mon {
      my $time = shift;
      $time->[c_mon] + 1;
  }
  
  sub _mon {
      my $time = shift;
      $time->[c_mon];
  }
  
  sub month {
      my $time = shift;
      if (@_) {
          return $_[$time->[c_mon]];
      }
      elsif (@MON_LIST) {
          return $MON_LIST[$time->[c_mon]];
      }
      else {
          return $time->strftime('%b');
      }
  }
  
  *monname = \&month;
  
  sub fullmonth {
      my $time = shift;
      if (@_) {
          return $_[$time->[c_mon]];
      }
      elsif (@FULLMON_LIST) {
          return $FULLMON_LIST[$time->[c_mon]];
      }
      else {
          return $time->strftime('%B');
      }
  }
  
  sub year {
      my $time = shift;
      $time->[c_year] + 1900;
  }
  
  sub _year {
      my $time = shift;
      $time->[c_year];
  }
  
  sub yy {
      my $time = shift;
      my $res = $time->[c_year] % 100;
      return $res > 9 ? $res : "0$res";
  }
  
  sub wday {
      my $time = shift;
      $time->[c_wday] + 1;
  }
  
  sub _wday {
      my $time = shift;
      $time->[c_wday];
  }
  
  *day_of_week = \&_wday;
  
  sub wdayname {
      my $time = shift;
      if (@_) {
          return $_[$time->[c_wday]];
      }
      elsif (@DAY_LIST) {
          return $DAY_LIST[$time->[c_wday]];
      }
      else {
          return $time->strftime('%a');
      }
  }
  
  *day = \&wdayname;
  
  sub fullday {
      my $time = shift;
      if (@_) {
          return $_[$time->[c_wday]];
      }
      elsif (@FULLDAY_LIST) {
          return $FULLDAY_LIST[$time->[c_wday]];
      }
      else {
          return $time->strftime('%A');
      }
  }
  
  sub yday {
      my $time = shift;
      $time->[c_yday];
  }
  
  *day_of_year = \&yday;
  
  sub isdst {
      my $time = shift;
      $time->[c_isdst];
  }
  
  *daylight_savings = \&isdst;
  
  # Thanks to Tony Olekshy <olekshy@cs.ualberta.ca> for this algorithm
  sub tzoffset {
      my $time = shift;
      
      return Time::Seconds->new(0) unless $time->[c_islocal];
  
      my $epoch = $time->epoch;
  
      my $j = sub {
  
          my ($s,$n,$h,$d,$m,$y) = @_; $m += 1; $y += 1900;
  
          $time->_jd($y, $m, $d, $h, $n, $s);
  
      };
  
      # Compute floating offset in hours.
      #
      # Note use of crt methods so the tz is properly set...
      # See: http://perlmonks.org/?node_id=820347
      my $delta = 24 * ($j->(_crt_localtime($epoch)) - $j->(_crt_gmtime($epoch)));
  
      # Return value in seconds rounded to nearest minute.
      return Time::Seconds->new( int($delta * 60 + ($delta >= 0 ? 0.5 : -0.5)) * 60 );
  }
  
  sub epoch {
      my $time = shift;
      if (defined($time->[c_epoch])) {
          return $time->[c_epoch];
      }
      else {
          my $epoch = $time->[c_islocal] ?
            timelocal(@{$time}[c_sec .. c_mon], $time->[c_year]+1900)
            :
            timegm(@{$time}[c_sec .. c_mon], $time->[c_year]+1900);
          $time->[c_epoch] = $epoch;
          return $epoch;
      }
  }
  
  sub hms {
      my $time = shift;
      my $sep = @_ ? shift(@_) : $TIME_SEP;
      sprintf("%02d$sep%02d$sep%02d", $time->[c_hour], $time->[c_min], $time->[c_sec]);
  }
  
  *time = \&hms;
  
  sub ymd {
      my $time = shift;
      my $sep = @_ ? shift(@_) : $DATE_SEP;
      sprintf("%d$sep%02d$sep%02d", $time->year, $time->mon, $time->[c_mday]);
  }
  
  *date = \&ymd;
  
  sub mdy {
      my $time = shift;
      my $sep = @_ ? shift(@_) : $DATE_SEP;
      sprintf("%02d$sep%02d$sep%d", $time->mon, $time->[c_mday], $time->year);
  }
  
  sub dmy {
      my $time = shift;
      my $sep = @_ ? shift(@_) : $DATE_SEP;
      sprintf("%02d$sep%02d$sep%d", $time->[c_mday], $time->mon, $time->year);
  }
  
  sub datetime {
      my $time = shift;
      my %seps = (date => $DATE_SEP, T => 'T', time => $TIME_SEP, @_);
      return join($seps{T}, $time->date($seps{date}), $time->time($seps{time}));
  }
  
  
  
  # Julian Day is always calculated for UT regardless
  # of local time
  sub julian_day {
      my $time = shift;
      # Correct for localtime
      $time = $time->gmtime( $time->epoch ) if $time->[c_islocal];
  
      # Calculate the Julian day itself
      my $jd = $time->_jd( $time->year, $time->mon, $time->mday,
                          $time->hour, $time->min, $time->sec);
  
      return $jd;
  }
  
  # MJD is defined as JD - 2400000.5 days
  sub mjd {
      return shift->julian_day - 2_400_000.5;
  }
  
  # Internal calculation of Julian date. Needed here so that
  # both tzoffset and mjd/jd methods can share the code
  # Algorithm from Hatcher 1984 (QJRAS 25, 53-55), and
  #  Hughes et al, 1989, MNRAS, 238, 15
  # See: http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=1989MNRAS.238.1529H&db_key=AST
  # for more details
  
  sub _jd {
      my $self = shift;
      my ($y, $m, $d, $h, $n, $s) = @_;
  
      # Adjust input parameters according to the month
      $y = ( $m > 2 ? $y : $y - 1);
      $m = ( $m > 2 ? $m - 3 : $m + 9);
  
      # Calculate the Julian Date (assuming Julian calendar)
      my $J = int( 365.25 *( $y + 4712) )
        + int( (30.6 * $m) + 0.5)
          + 59
            + $d
              - 0.5;
  
      # Calculate the Gregorian Correction (since we have Gregorian dates)
      my $G = 38 - int( 0.75 * int(49+($y/100)));
  
      # Calculate the actual Julian Date
      my $JD = $J + $G;
  
      # Modify to include hours/mins/secs in floating portion.
      return $JD + ($h + ($n + $s / 60) / 60) / 24;
  }
  
  sub week {
      my $self = shift;
  
      my $J  = $self->julian_day;
      # Julian day is independent of time zone so add on tzoffset
      # if we are using local time here since we want the week day
      # to reflect the local time rather than UTC
      $J += ($self->tzoffset/(24*3600)) if $self->[c_islocal];
  
      # Now that we have the Julian day including fractions
      # convert it to an integer Julian Day Number using nearest
      # int (since the day changes at midday we convert all Julian
      # dates to following midnight).
      $J = int($J+0.5);
  
      use integer;
      my $d4 = ((($J + 31741 - ($J % 7)) % 146097) % 36524) % 1461;
      my $L  = $d4 / 1460;
      my $d1 = (($d4 - $L) % 365) + $L;
      return $d1 / 7 + 1;
  }
  
  sub _is_leap_year {
      my $year = shift;
      return (($year %4 == 0) && !($year % 100 == 0)) || ($year % 400 == 0)
                 ? 1 : 0;
  }
  
  sub is_leap_year {
      my $time = shift;
      my $year = $time->year;
      return _is_leap_year($year);
  }
  
  my @MON_LAST = qw(31 28 31 30 31 30 31 31 30 31 30 31);
  
  sub month_last_day {
      my $time = shift;
      my $year = $time->year;
      my $_mon = $time->_mon;
      return $MON_LAST[$_mon] + ($_mon == 1 ? _is_leap_year($year) : 0);
  }
  
  sub strftime {
      my $time = shift;
      my $tzname = $time->[c_islocal] ? '%Z' : 'UTC';
      my $format = @_ ? shift(@_) : "%a, %d %b %Y %H:%M:%S $tzname";
      if (!defined $time->[c_wday]) {
          if ($time->[c_islocal]) {
              return _strftime($format, CORE::localtime($time->epoch));
          }
          else {
              return _strftime($format, CORE::gmtime($time->epoch));
          }
      }
      return _strftime($format, (@$time)[c_sec..c_isdst]);
  }
  
  sub strptime {
      my $time = shift;
      my $string = shift;
      my $format = @_ ? shift(@_) : "%a, %d %b %Y %H:%M:%S %Z";
      my @vals = _strptime($string, $format);
  #    warn(sprintf("got vals: %d-%d-%d %d:%d:%d\n", reverse(@vals)));
      return scalar $time->_mktime(\@vals, (ref($time) ? $time->[c_islocal] : 0));
  }
  
  sub day_list {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__); # strip first if called as a method
      my @old = @DAY_LIST;
      if (@_) {
          @DAY_LIST = @_;
      }
      return @old;
  }
  
  sub mon_list {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__); # strip first if called as a method
      my @old = @MON_LIST;
      if (@_) {
          @MON_LIST = @_;
      }
      return @old;
  }
  
  sub time_separator {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
      my $old = $TIME_SEP;
      if (@_) {
          $TIME_SEP = $_[0];
      }
      return $old;
  }
  
  sub date_separator {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
      my $old = $DATE_SEP;
      if (@_) {
          $DATE_SEP = $_[0];
      }
      return $old;
  }
  
  use overload '""' => \&cdate,
               'cmp' => \&str_compare,
               'fallback' => undef;
  
  sub cdate {
      my $time = shift;
      if ($time->[c_islocal]) {
          return scalar(CORE::localtime($time->epoch));
      }
      else {
          return scalar(CORE::gmtime($time->epoch));
      }
  }
  
  sub str_compare {
      my ($lhs, $rhs, $reverse) = @_;
      if (UNIVERSAL::isa($rhs, 'Time::Piece')) {
          $rhs = "$rhs";
      }
      return $reverse ? $rhs cmp $lhs->cdate : $lhs->cdate cmp $rhs;
  }
  
  use overload
          '-' => \&subtract,
          '+' => \&add;
  
  sub subtract {
      my $time = shift;
      my $rhs = shift;
      if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
          $rhs = $rhs->seconds;
      }
  
      if (shift)
      {
  	# SWAPED is set (so someone tried an expression like NOTDATE - DATE).
  	# Imitate Perl's standard behavior and return the result as if the
  	# string $time resolves to was subtracted from NOTDATE.  This way,
  	# classes which override this one and which have a stringify function
  	# that resolves to something that looks more like a number don't need
  	# to override this function.
  	return $rhs - "$time";
      }
      
      if (UNIVERSAL::isa($rhs, 'Time::Piece')) {
          return Time::Seconds->new($time->epoch - $rhs->epoch);
      }
      else {
          # rhs is seconds.
          return $time->_mktime(($time->epoch - $rhs), $time->[c_islocal]);
      }
  }
  
  sub add {
      my $time = shift;
      my $rhs = shift;
      if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
          $rhs = $rhs->seconds;
      }
      croak "Invalid rhs of addition: $rhs" if ref($rhs);
  
      return $time->_mktime(($time->epoch + $rhs), $time->[c_islocal]);
  }
  
  use overload
          '<=>' => \&compare;
  
  sub get_epochs {
      my ($lhs, $rhs, $reverse) = @_;
      if (!UNIVERSAL::isa($rhs, 'Time::Piece')) {
          $rhs = $lhs->new($rhs);
      }
      if ($reverse) {
          return $rhs->epoch, $lhs->epoch;
      }
      return $lhs->epoch, $rhs->epoch;
  }
  
  sub compare {
      my ($lhs, $rhs) = get_epochs(@_);
      return $lhs <=> $rhs;
  }
  
  sub add_months {
      my ($time, $num_months) = @_;
      
      croak("add_months requires a number of months") unless defined($num_months);
      
      my $final_month = $time->_mon + $num_months;
      my $num_years = 0;
      if ($final_month > 11 || $final_month < 0) {
          # these two ops required because we have no POSIX::floor and don't
          # want to load POSIX.pm
          if ($final_month < 0 && $final_month % 12 == 0) {
              $num_years = int($final_month / 12) + 1;
          }
          else {
              $num_years = int($final_month / 12);
          }
          $num_years-- if ($final_month < 0);
          
          $final_month = $final_month % 12;
      }
      
      my @vals = _mini_mktime($time->sec, $time->min, $time->hour,
                              $time->mday, $final_month, $time->year - 1900 + $num_years);
      # warn(sprintf("got %d vals: %d-%d-%d %d:%d:%d [%d]\n", scalar(@vals), reverse(@vals), $time->[c_islocal]));
      return scalar $time->_mktime(\@vals, $time->[c_islocal]);
  }
  
  sub add_years {
      my ($time, $years) = @_;
      $time->add_months($years * 12);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Time::Piece - Object Oriented time objects
  
  =head1 SYNOPSIS
  
      use Time::Piece;
      
      my $t = localtime;
      print "Time is $t\n";
      print "Year is ", $t->year, "\n";
  
  =head1 DESCRIPTION
  
  This module replaces the standard C<localtime> and C<gmtime> functions with
  implementations that return objects. It does so in a backwards
  compatible manner, so that using localtime/gmtime in the way documented
  in perlfunc will still return what you expect.
  
  The module actually implements most of an interface described by
  Larry Wall on the perl5-porters mailing list here:
  http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html
  
  =head1 USAGE
  
  After importing this module, when you use localtime or gmtime in a scalar
  context, rather than getting an ordinary scalar string representing the
  date and time, you get a Time::Piece object, whose stringification happens
  to produce the same effect as the localtime and gmtime functions. There is 
  also a new() constructor provided, which is the same as localtime(), except
  when passed a Time::Piece object, in which case it's a copy constructor. The
  following methods are available on the object:
  
      $t->sec                 # also available as $t->second
      $t->min                 # also available as $t->minute
      $t->hour                # 24 hour
      $t->mday                # also available as $t->day_of_month
      $t->mon                 # 1 = January
      $t->_mon                # 0 = January
      $t->monname             # Feb
      $t->month               # same as $t->monname
      $t->fullmonth           # February
      $t->year                # based at 0 (year 0 AD is, of course 1 BC)
      $t->_year               # year minus 1900
      $t->yy                  # 2 digit year
      $t->wday                # 1 = Sunday
      $t->_wday               # 0 = Sunday
      $t->day_of_week         # 0 = Sunday
      $t->wdayname            # Tue
      $t->day                 # same as wdayname
      $t->fullday             # Tuesday
      $t->yday                # also available as $t->day_of_year, 0 = Jan 01
      $t->isdst               # also available as $t->daylight_savings
  
      $t->hms                 # 12:34:56
      $t->hms(".")            # 12.34.56
      $t->time                # same as $t->hms
  
      $t->ymd                 # 2000-02-29
      $t->date                # same as $t->ymd
      $t->mdy                 # 02-29-2000
      $t->mdy("/")            # 02/29/2000
      $t->dmy                 # 29-02-2000
      $t->dmy(".")            # 29.02.2000
      $t->datetime            # 2000-02-29T12:34:56 (ISO 8601)
      $t->cdate               # Tue Feb 29 12:34:56 2000
      "$t"                    # same as $t->cdate
  
      $t->epoch               # seconds since the epoch
      $t->tzoffset            # timezone offset in a Time::Seconds object
  
      $t->julian_day          # number of days since Julian period began
      $t->mjd                 # modified Julian date (JD-2400000.5 days)
  
      $t->week                # week number (ISO 8601)
  
      $t->is_leap_year        # true if it its
      $t->month_last_day      # 28-31
  
      $t->time_separator($s)  # set the default separator (default ":")
      $t->date_separator($s)  # set the default separator (default "-")
      $t->day_list(@days)     # set the default weekdays
      $t->mon_list(@days)     # set the default months
  
      $t->strftime(FORMAT)    # same as POSIX::strftime (without the overhead
                              # of the full POSIX extension)
      $t->strftime()          # "Tue, 29 Feb 2000 12:34:56 GMT"
      
      Time::Piece->strptime(STRING, FORMAT)
                              # see strptime man page. Creates a new
                              # Time::Piece object
  
  Note that C<localtime> and C<gmtime> are not listed above.  If called as
  methods on a Time::Piece object, they act as constructors, returning a new
  Time::Piece object for the current time.  In other words: they're not useful as
  methods.
  
  =head2 Local Locales
  
  Both wdayname (day) and monname (month) allow passing in a list to use
  to index the name of the days against. This can be useful if you need
  to implement some form of localisation without actually installing or
  using locales.
  
    my @days = qw( Dimanche Lundi Merdi Mercredi Jeudi Vendredi Samedi );
  
    my $french_day = localtime->day(@days);
  
  These settings can be overridden globally too:
  
    Time::Piece::day_list(@days);
  
  Or for months:
  
    Time::Piece::mon_list(@months);
  
  And locally for months:
  
    print localtime->month(@months);
  
  =head2 Date Calculations
  
  It's possible to use simple addition and subtraction of objects:
  
      use Time::Seconds;
      
      my $seconds = $t1 - $t2;
      $t1 += ONE_DAY; # add 1 day (constant from Time::Seconds)
  
  The following are valid ($t1 and $t2 are Time::Piece objects):
  
      $t1 - $t2; # returns Time::Seconds object
      $t1 - 42; # returns Time::Piece object
      $t1 + 533; # returns Time::Piece object
  
  However adding a Time::Piece object to another Time::Piece object
  will cause a runtime error.
  
  Note that the first of the above returns a Time::Seconds object, so
  while examining the object will print the number of seconds (because
  of the overloading), you can also get the number of minutes, hours,
  days, weeks and years in that delta, using the Time::Seconds API.
  
  In addition to adding seconds, there are two APIs for adding months and
  years:
  
      $t->add_months(6);
      $t->add_years(5);
  
  The months and years can be negative for subtractions. Note that there
  is some "strange" behaviour when adding and subtracting months at the
  ends of months. Generally when the resulting month is shorter than the
  starting month then the number of overlap days is added. For example
  subtracting a month from 2008-03-31 will not result in 2008-02-31 as this
  is an impossible date. Instead you will get 2008-03-02. This appears to
  be consistent with other date manipulation tools.
  
  =head2 Date Comparisons
  
  Date comparisons are also possible, using the full suite of "<", ">",
  "<=", ">=", "<=>", "==" and "!=".
  
  =head2 Date Parsing
  
  Time::Piece has a built-in strptime() function (from FreeBSD), allowing
  you incredibly flexible date parsing routines. For example:
  
    my $t = Time::Piece->strptime("Sunday 3rd Nov, 1943",
                                  "%A %drd %b, %Y");
    
    print $t->strftime("%a, %d %b %Y");
  
  Outputs:
  
    Wed, 03 Nov 1943
  
  (see, it's even smart enough to fix my obvious date bug)
  
  For more information see "man strptime", which should be on all unix
  systems.
  
  Alternatively look here: http://www.unix.com/man-page/FreeBSD/3/strftime/
  
  =head2 YYYY-MM-DDThh:mm:ss
  
  The ISO 8601 standard defines the date format to be YYYY-MM-DD, and
  the time format to be hh:mm:ss (24 hour clock), and if combined, they
  should be concatenated with date first and with a capital 'T' in front
  of the time.
  
  =head2 Week Number
  
  The I<week number> may be an unknown concept to some readers.  The ISO
  8601 standard defines that weeks begin on a Monday and week 1 of the
  year is the week that includes both January 4th and the first Thursday
  of the year.  In other words, if the first Monday of January is the
  2nd, 3rd, or 4th, the preceding days of the January are part of the
  last week of the preceding year.  Week numbers range from 1 to 53.
  
  =head2 Global Overriding
  
  Finally, it's possible to override localtime and gmtime everywhere, by
  including the ':override' tag in the import list:
  
      use Time::Piece ':override';
  
  =head1 CAVEATS
  
  =head2 Setting $ENV{TZ} in Threads on Win32
  
  Note that when using perl in the default build configuration on Win32
  (specifically, when perl is built with PERL_IMPLICIT_SYS), each perl
  interpreter maintains its own copy of the environment and only the main
  interpreter will update the process environment seen by strftime.
  
  Therefore, if you make changes to $ENV{TZ} from inside a thread other than
  the main thread then those changes will not be seen by strftime if you
  subsequently call that with the %Z formatting code. You must change $ENV{TZ}
  in the main thread to have the desired effect in this case (and you must
  also call _tzset() in the main thread to register the environment change).
  
  Furthermore, remember that this caveat also applies to fork(), which is
  emulated by threads on Win32.
  
  =head2 Use of epoch seconds
  
  This module internally uses the epoch seconds system that is provided via
  the perl C<time()> function and supported by C<gmtime()> and C<localtime()>.
  
  If your perl does not support times larger than C<2^31> seconds then this
  module is likely to fail at processing dates beyond the year 2038. There are
  moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none
  of those are options, use the L<DateTime> module which has support for years
  well into the future and past.
  
  =head1 AUTHOR
  
  Matt Sergeant, matt@sergeant.org
  Jarkko Hietaniemi, jhi@iki.fi (while creating Time::Piece for core perl)
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2001, Larry Wall.
  
  This module is free software, you may distribute it under the same terms
  as Perl.
  
  =head1 SEE ALSO
  
  The excellent Calendar FAQ at http://www.tondering.dk/claus/calendar.html
  
  =head1 BUGS
  
  The test harness leaves much to be desired. Patches welcome.
  
  =cut
X86_64-LINUX-THREAD-MULTI_TIME_PIECE

$fatpacked{"x86_64-linux-thread-multi/Time/Seconds.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TIME_SECONDS';
  package Time::Seconds;
  use strict;
  use vars qw/@EXPORT @EXPORT_OK/;
  
  our $VERSION = '1.23';
  
  use Exporter 5.57 'import';
  
  @EXPORT = qw(
      ONE_MINUTE 
      ONE_HOUR 
      ONE_DAY 
      ONE_WEEK 
      ONE_MONTH
      ONE_REAL_MONTH
      ONE_YEAR
      ONE_REAL_YEAR
      ONE_FINANCIAL_MONTH
      LEAP_YEAR 
      NON_LEAP_YEAR
  );
  
  @EXPORT_OK = qw(cs_sec cs_mon);
  
  use constant ONE_MINUTE => 60;
  use constant ONE_HOUR => 3_600;
  use constant ONE_DAY => 86_400;
  use constant ONE_WEEK => 604_800;
  use constant ONE_MONTH => 2_629_744; # ONE_YEAR / 12
  use constant ONE_REAL_MONTH => '1M';
  use constant ONE_YEAR => 31_556_930; # 365.24225 days
  use constant ONE_REAL_YEAR  => '1Y';
  use constant ONE_FINANCIAL_MONTH => 2_592_000; # 30 days
  use constant LEAP_YEAR => 31_622_400; # 366 * ONE_DAY
  use constant NON_LEAP_YEAR => 31_536_000; # 365 * ONE_DAY
  
  # hacks to make Time::Piece compile once again
  use constant cs_sec => 0;
  use constant cs_mon => 1;
  
  use overload 
                  'fallback' => 'undef',
                  '0+' => \&seconds,
                  '""' => \&seconds,
                  '<=>' => \&compare,
                  '+' => \&add,
                  '-' => \&subtract,
                  '-=' => \&subtract_from,
                  '+=' => \&add_to,
                  '=' => \&copy;
  
  sub new {
      my $class = shift;
      my ($val) = @_;
      $val = 0 unless defined $val;
      bless \$val, $class;
  }
  
  sub _get_ovlvals {
      my ($lhs, $rhs, $reverse) = @_;
      $lhs = $lhs->seconds;
  
      if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
          $rhs = $rhs->seconds;
      }
      elsif (ref($rhs)) {
          die "Can't use non Seconds object in operator overload";
      }
  
      if ($reverse) {
          return $rhs, $lhs;
      }
  
      return $lhs, $rhs;
  }
  
  sub compare {
      my ($lhs, $rhs) = _get_ovlvals(@_);
      return $lhs <=> $rhs;
  }
  
  sub add {
      my ($lhs, $rhs) = _get_ovlvals(@_);
      return Time::Seconds->new($lhs + $rhs);
  }
  
  sub add_to {
      my $lhs = shift;
      my $rhs = shift;
      $rhs = $rhs->seconds if UNIVERSAL::isa($rhs, 'Time::Seconds');
      $$lhs += $rhs;
      return $lhs;
  }
  
  sub subtract {
      my ($lhs, $rhs) = _get_ovlvals(@_);
      return Time::Seconds->new($lhs - $rhs);
  }
  
  sub subtract_from {
      my $lhs = shift;
      my $rhs = shift;
      $rhs = $rhs->seconds if UNIVERSAL::isa($rhs, 'Time::Seconds');
      $$lhs -= $rhs;
      return $lhs;
  }
  
  sub copy {
  	Time::Seconds->new(${$_[0]});
  }
  
  sub seconds {
      my $s = shift;
      return $$s;
  }
  
  sub minutes {
      my $s = shift;
      return $$s / 60;
  }
  
  sub hours {
      my $s = shift;
      $s->minutes / 60;
  }
  
  sub days {
      my $s = shift;
      $s->hours / 24;
  }
  
  sub weeks {
      my $s = shift;
      $s->days / 7;
  }
  
  sub months {
      my $s = shift;
      $s->days / 30.4368541;
  }
  
  sub financial_months {
      my $s = shift;
      $s->days / 30;
  }
  
  sub years {
      my $s = shift;
      $s->days / 365.24225;
  }
  
  sub pretty {
      my $s = shift;
      my $str = "";
      if ($s < 0) {
          $s = -$s;
          $str = "minus ";
      }
      if ($s >= ONE_MINUTE) {
          if ($s >= ONE_HOUR) {
              if ($s >= ONE_DAY) {
                  my $days = sprintf("%d", $s->days); # does a "floor"
                  $str = $days . " days, ";
                  $s -= ($days * ONE_DAY);
              }
              my $hours = sprintf("%d", $s->hours);
              $str .= $hours . " hours, ";
              $s -= ($hours * ONE_HOUR);
          }
          my $mins = sprintf("%d", $s->minutes);
          $str .= $mins . " minutes, ";
          $s -= ($mins * ONE_MINUTE);
      }
      $str .= $s->seconds . " seconds";
      return $str;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Time::Seconds - a simple API to convert seconds to other date values
  
  =head1 SYNOPSIS
  
      use Time::Piece;
      use Time::Seconds;
      
      my $t = localtime;
      $t += ONE_DAY;
      
      my $t2 = localtime;
      my $s = $t - $t2;
      
      print "Difference is: ", $s->days, "\n";
  
  =head1 DESCRIPTION
  
  This module is part of the Time::Piece distribution. It allows the user
  to find out the number of minutes, hours, days, weeks or years in a given
  number of seconds. It is returned by Time::Piece when you delta two
  Time::Piece objects.
  
  Time::Seconds also exports the following constants:
  
      ONE_DAY
      ONE_WEEK
      ONE_HOUR
      ONE_MINUTE
      ONE_MONTH
      ONE_YEAR
      ONE_FINANCIAL_MONTH
      LEAP_YEAR
      NON_LEAP_YEAR
  
  Since perl does not (yet?) support constant objects, these constants are in
  seconds only, so you cannot, for example, do this: C<print ONE_WEEK-E<gt>minutes;>
  
  =head1 METHODS
  
  The following methods are available:
  
      my $val = Time::Seconds->new(SECONDS)
      $val->seconds;
      $val->minutes;
      $val->hours;
      $val->days;
      $val->weeks;
  	$val->months;
  	$val->financial_months; # 30 days
      $val->years;
      $val->pretty; # gives English representation of the delta
  
  The usual arithmetic (+,-,+=,-=) is also available on the objects.
  
  The methods make the assumption that there are 24 hours in a day, 7 days in
  a week, 365.24225 days in a year and 12 months in a year.
  (from The Calendar FAQ at http://www.tondering.dk/claus/calendar.html)
  
  =head1 AUTHOR
  
  Matt Sergeant, matt@sergeant.org
  
  Tobias Brox, tobiasb@tobiasb.funcom.com
  
  Balázs Szabó (dLux), dlux@kapu.hu
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2001, Larry Wall.
  
  This module is free software, you may distribute it under the same terms
  as Perl.
  
  =head1 Bugs
  
  Currently the methods aren't as efficient as they could be, for reasons of
  clarity. This is probably a bad idea.
  
  =cut
X86_64-LINUX-THREAD-MULTI_TIME_SECONDS

$fatpacked{"x86_64-linux-thread-multi/YAML/Dumper/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_DUMPER_SYCK';
  package YAML::Dumper::Syck;
  use strict;
  
  sub new { $_[0] }
  sub dump { shift; YAML::Syck::Dump( $_[0] ) }
  
  1;
X86_64-LINUX-THREAD-MULTI_YAML_DUMPER_SYCK

$fatpacked{"x86_64-linux-thread-multi/YAML/Loader/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_LOADER_SYCK';
  package YAML::Loader::Syck;
  use strict;
  
  sub new { $_[0] }
  sub load { shift; YAML::Syck::Load( $_[0] ) }
  
  1;
X86_64-LINUX-THREAD-MULTI_YAML_LOADER_SYCK

$fatpacked{"x86_64-linux-thread-multi/YAML/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_SYCK';
  package YAML::Syck;
  
  # See documentation after the __END__ mark.
  
  use strict;
  use vars qw(
    @ISA @EXPORT @EXPORT_OK $VERSION
    $Headless $SortKeys $SingleQuote
    $ImplicitBinary $ImplicitTyping $ImplicitUnicode
    $UseCode $LoadCode $DumpCode
    $DeparseObject $LoadBlessed
  );
  use 5.006;
  use Exporter;
  
  BEGIN {
      $VERSION   = '1.27';
      @EXPORT    = qw( Dump Load DumpFile LoadFile );
      @EXPORT_OK = qw( DumpInto );
      @ISA       = qw( Exporter );
  
      $SortKeys    = 1;
      $LoadBlessed = 1;
  
      local $@;
      eval {
          require XSLoader;
          XSLoader::load( __PACKAGE__, $VERSION );
          1;
      } or do {
          require DynaLoader;
          push @ISA, 'DynaLoader';
          __PACKAGE__->bootstrap($VERSION);
      };
  
  }
  
  use constant QR_MAP => {
      ''   => sub { qr{$_[0]} },
      x    => sub { qr{$_[0]}x },
      i    => sub { qr{$_[0]}i },
      s    => sub { qr{$_[0]}s },
      m    => sub { qr{$_[0]}m },
      ix   => sub { qr{$_[0]}ix },
      sx   => sub { qr{$_[0]}sx },
      mx   => sub { qr{$_[0]}mx },
      si   => sub { qr{$_[0]}si },
      mi   => sub { qr{$_[0]}mi },
      ms   => sub { qr{$_[0]}sm },
      six  => sub { qr{$_[0]}six },
      mix  => sub { qr{$_[0]}mix },
      msx  => sub { qr{$_[0]}msx },
      msi  => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub __qr_helper {
      if ( $_[0] =~ /\A  \(\?  ([ixsm]*)  (?:-  (?:[ixsm]*))?  : (.*) \)  \z/x ) {
          my $sub = QR_MAP()->{$1} || QR_MAP()->{''};
          &$sub($2);
      }
      else {
          qr/$_[0]/;
      }
  }
  
  sub Dump {
      $#_
        ? join( '', map { YAML::Syck::DumpYAML($_) } @_ )
        : YAML::Syck::DumpYAML( $_[0] );
  }
  
  sub Load {
      if (wantarray) {
          my ($rv) = YAML::Syck::LoadYAML( $_[0] );
          @{$rv};
      }
      else {
          @_ = $_[0];
          goto &YAML::Syck::LoadYAML;
      }
  }
  
  sub _is_glob {
      my $h = shift;
  
      return 1 if ( ref($h) eq 'GLOB' );
      return 1 if ( ref( \$h ) eq 'GLOB' );
      return 1 if ( ref($h) =~ m/^IO::/ );
  
      return;
  }
  
  sub DumpFile {
      my $file = shift;
      if ( _is_glob($file) ) {
          for (@_) {
              my $err = YAML::Syck::DumpYAMLFile( $_, $file );
              if ($err) {
                  $! = 0 + $err;
                  die "Error writing to filehandle $file: $!\n";
              }
          }
      }
      else {
          open( my $fh, '>', $file ) or die "Cannot write to $file: $!";
          for (@_) {
              my $err = YAML::Syck::DumpYAMLFile( $_, $fh );
              if ($err) {
                  $! = 0 + $err;
                  die "Error writing to file $file: $!\n";
              }
          }
          close $fh
            or die "Error writing to file $file: $!\n";
      }
      return 1;
  }
  
  sub LoadFile {
      my $file = shift;
      if ( _is_glob($file) ) {
          Load(
              do { local $/; <$file> }
          );
      }
      else {
          if ( !-e $file || -z $file ) {
              die("'$file' is empty or non-existent");
          }
          open( my $fh, '<', $file ) or die "Cannot read from $file: $!";
          Load(
              do { local $/; <$fh> }
          );
      }
  }
  
  sub DumpInto {
      my $bufref = shift;
      ( ref $bufref ) or die "DumpInto not given reference to output buffer\n";
      YAML::Syck::DumpYAMLInto( $_, $bufref ) for @_;
      1;
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME 
  
  YAML::Syck - Fast, lightweight YAML loader and dumper
  
  =head1 SYNOPSIS
  
      use YAML::Syck;
  
      # Set this for interoperability with other YAML/Syck bindings:
      # e.g. Load('Yes') becomes 1 and Load('No') becomes ''.
      $YAML::Syck::ImplicitTyping = 1;
  
      $data = Load($yaml);
      $yaml = Dump($data);
  
      # $file can be an IO object, or a filename
      $data = LoadFile($file);
      DumpFile($file, $data);
  
      # A string with multiple YAML streams in it
      $yaml = Dump(@data);
      @data = Load($yaml);
  
      # Dumping into a pre-existing output buffer
      my $yaml;
      DumpInto(\$yaml, @data);
  
  =head1 DESCRIPTION
  
  This module provides a Perl interface to the B<libsyck> data serialization
  library.  It exports the C<Dump> and C<Load> functions for converting
  Perl data structures to YAML strings, and the other way around.
  
  B<NOTE>: If you are working with other language's YAML/Syck bindings
  (such as Ruby), please set C<$YAML::Syck::ImplicitTyping> to C<1> before
  calling the C<Load>/C<Dump> functions.  The default setting is for
  preserving backward-compatibility with C<YAML.pm>.
  
  =head1 Differences Between YAML::Syck and YAML
  
  =head2 Error handling
  
  Some calls are designed to die rather than returning YAML. You should wrap
  your calls in eval to assure you do not get unexpected results.
  
  =head1 FLAGS
  
  =head2 $YAML::Syck::Headless
  
  Defaults to false.  Setting this to a true value will make C<Dump> omit the
  leading C<---\n> marker.
  
  =head2 $YAML::Syck::SortKeys
  
  Defaults to false.  Setting this to a true value will make C<Dump> sort
  hash keys.
  
  =head2 $YAML::Syck::SingleQuote
  
  Defaults to false.  Setting this to a true value will make C<Dump> always emit
  single quotes instead of bare strings.
  
  =head2 $YAML::Syck::ImplicitTyping
  
  Defaults to false.  Setting this to a true value will make C<Load> recognize
  various implicit types in YAML, such as unquoted C<true>, C<false>, as well as
  integers and floating-point numbers.  Otherwise, only C<~> is recognized to
  be C<undef>.
  
  =head2 $YAML::Syck::ImplicitUnicode
  
  Defaults to false.  For Perl 5.8.0 or later, setting this to a true value will
  make C<Load> set Unicode flag on for every string that contains valid UTF8
  sequences, and make C<Dump> return a unicode string.
  
  Regardless of this flag, Unicode strings are dumped verbatim without escaping;
  byte strings with high-bit set will be dumped with backslash escaping.
  
  However, because YAML does not distinguish between these two kinds of strings,
  so this flag will affect loading of both variants of strings.
  
  If you want to use LoadFile or DumpFile with unicode, you are required to open
  your own file in order to assure it's UTF8 encoded:
  
    open(my $fh, ">:encoding(UTF-8)", "out.yml");
    DumpFile($fh, $hashref);
  
  =head2 $YAML::Syck::ImplicitBinary
  
  Defaults to false.  For Perl 5.8.0 or later, setting this to a true value will
  make C<Dump> generate Base64-encoded C<!!binary> data for all non-Unicode
  scalars containing high-bit bytes.
  
  =head2 $YAML::Syck::UseCode / $YAML::Syck::LoadCode / $YAML::Syck::DumpCode
  
  These flags control whether or not to try and eval/deparse perl source code;
  each of them defaults to false.
  
  Setting C<$YAML::Syck::UseCode> to a true value is equivalent to setting
  both C<$YAML::Syck::LoadCode> and C<$YAML::Syck::DumpCode> to true.
  
  =head2 $YAML::Syck::LoadBlessed
  
  Defaults to true. Setting to false will block YAML::Syck from doing ANY
  blessing. This is an interface change since 1.21. The variable name was
  misleading, implying that no blessing would happen when in fact it did.
  
  Prior to 1.22, setting this to a false value only prevented C<Load> from
  blessing tag names that did not begin with C<!!perl> or C<!perl>;.
  
  =head1 BUGS
  
  Dumping Glob/IO values do not work yet.
  
  Dumping of Tied variables is unsupported.
  
  Dumping into tied (or other magic variables) with C<DumpInto> might not work
  properly in all cases.
  
  =head1 CAVEATS
  
  This module implements the YAML 1.0 spec.  To deal with data in YAML 1.1, 
  please use the C<YAML::XS> module instead.
  
  The current implementation bundles libsyck source code; if your system has a
  site-wide shared libsyck, it will I<not> be used.
  
  Tag names such as C<!!perl/hash:Foo> is blessed into the package C<Foo>, but
  the C<!hs/foo> and C<!!hs/Foo> tags are blessed into C<hs::Foo>.  Note that
  this holds true even if the tag contains non-word characters; for example,
  C<!haskell.org/Foo> is blessed into C<haskell.org::Foo>.  Please use
  L<Class::Rebless> to cast it into other user-defined packages. You can also
  set the LoadBlessed flag false to disable all blessing.
  
  This module has L<a lot of known
  issues|https://rt.cpan.org/Public/Dist/Display.html?Name=YAML-Syck>
  and has only been semi-actively maintained since 2007. If you
  encounter an issue with it probably won't be fixed unless you L<offer
  up a patch|http://github.com/toddr/YAML-Syck> in Git that's ready for
  release.
  
  There are still good reasons to use this module, such as better
  interoperability with other syck wrappers (like Ruby's), or some edge
  case of YAML's syntax that it handles better. It'll probably work
  perfectly for you, but if it doesn't you may want to look at
  L<YAML::XS>, or perhaps at looking another serialization format like
  L<JSON>.
  
  =head1 SEE ALSO
  
  L<YAML>, L<JSON::Syck>
  
  L<http://www.yaml.org/>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005-2009 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  The F<libsyck> code bundled with this library is released by
  "why the lucky stiff", under a BSD-style license.  See the F<COPYING>
  file for details.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
X86_64-LINUX-THREAD-MULTI_YAML_SYCK

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use FindBin::libs;
use App::Rad qw(MoreHelp);
use App::Rad::Plugin::MoreHelp;

App::Rad->run();
use 5.014;
use strict;
use warnings;
use Data::Dumper;
use Sort::Naturally;
use Path::Tiny; # only need this for reconfigure-remove when done
use Moo;
use App::Pipeline::Lite4::Command::viewpipeline;
use App::Pipeline::Lite4::Command::viewgraph;
use App::Pipeline::Lite4::Command::viewsystemconfig;
use App::Pipeline::Lite4::Command::new;
use App::Pipeline::Lite4::Command::run;
use App::Pipeline::Lite4::Command::file;
use App::Pipeline::Lite4::Command::symlink;
use App::Pipeline::Lite4::Command::symlink2;

sub setup {
     my $c = shift;
     #$c->register( "setup", \&_setup, "setup pipelite" );
     $c->register_commands( {
         new => "create a new pipeline",          
         vp => "view pipeline",
         vg => "view pipeline graph",
         #vd => "view datasource",
         #vc => "view config",
         vsc => "view system config",
         #vl => "view log",
         #ve => "view error",
         run => "run pipeline",
         file => "get files",
         symlink => "symlink files",
         version => "version"
      #   symlink2 => "symlink files"
         } );
}

sub _setup {
     
}

sub new {
     my $c = shift;
     my $desc = 'new PIPELINE_DIR';
     my %options = (
         'output_dir|d=s' => 'Sets output directory location'
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv }  == 0;
     App::Pipeline::Lite4::Command::new->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show "new" : IMPLEMENT !!!# 
}

sub vp {
     my $c = shift;
     my $desc = 'vc (view pipeline) [OPTIONS] PIPELINE_DIR';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vp -e vim. Overrides config file setting if exists.'
     );

     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     App::Pipeline::Lite4::Command::viewpipeline->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show the config file : IMPLEMENT !!!#
}

sub vg {
     my $c = shift;
     my $desc = 'vg (view pipeline graph) [OPTIONS] PIPELINE_DIR';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vg -e vim. Overrides config file setting if exists.'
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     App::Pipeline::Lite4::Command::viewgraph->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      #!!! else show the config file : IMPLEMENT !!!#
}

#sub vc {
#     my $c = shift;
#     my $desc = 'vc (view config) [OPTIONS] PIPELINE_DIR';
#     my %options = (
#         'editor|e=s' => 'Sets the editor e.g. plite vc -e vim. Overrides config file setting if exists.'
#     );
#     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
#     return join ' ', "Argument: ", $c->argv->flatten;      # else show the config file
#}

sub vsc {
     my $c = shift;
     my $desc = 'vsc (view system config) [OPTIONS]';
     my %options = (
         'editor|e=s' => 'Sets the editor e.g. plite vc -e vim. Overrides config file setting if exists.',
         #'output_dir|o=s'         => "output file",
     );
     #return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
     $c->getopt( keys %options );
     #print Dumper $c->options;
     App::Pipeline::Lite4::Command::viewsystemconfig->new->execute($c->options, $c->argv);
     #return join ' ', "Argument: ", $c->argv->flatten;      # else show the config file
}

sub ve {
     
}

sub vd {
     
}

sub vl {
    
}

sub run {
     my $c = shift;
     my $desc = 'run (run pipeline) [OPTIONS] PIPELINE';
     my %options = (
         'datasource|d=s' => 'Provides a path name to a datasource.',
         'smoke_test|m'   => 'Runs pipeline with out dispatching jobs',
         'run_num|r=i'    => 'Run on this run number',
         'steps|s=s'      => 'Run only these steps',
         'jobs|j=s'       => "Only run these jobs. Corresponds to rows in datasource. e.g --jobs '1,5,7-21' . Starts from job 0"
         # IN ORDER OF USEFULNESS: 
         # 'jobs|j=s'  => 'Run only on these job numbers (corresponds to rows in the datasource)'
         # 'run|r=i'   => 'Run on this run number',
         # 'steps|s=s' => 'Run only these steps'
         # '' 'output_dir|o=s'         => "output file",
     );
     
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;       
     $c->getopt( keys %options );   
     App::Pipeline::Lite4::Command::run->new->execute($c->options, $c->argv);
}

sub file {
     my $c = shift;
     my $desc = 'file (get pipeline output files) [OPTIONS] PIPELINE';
     my %options = (
     'run_num|r=i'  => 'run_num',
     'stats|s'      => 'Show stats (size and mtime)',
     'step_name|t'     => 'Show step name in header',
     );
     return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;       
     $c->getopt( keys %options );   
     App::Pipeline::Lite4::Command::file->new->execute($c->options, $c->argv);
}

sub version {
     my $c = shift;
     my $desc = 'version';
     print "0.02\n";
     #my %options = (
     #'run_num|r=i'  => 'run_num',
     #'stats|s'      => 'Show stats (size and mtime)',
     #'step_name|t'     => 'Show step name in header',
     #);
     #return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;       
     #$c->getopt( keys %options );   
     #App::Pipeline::Lite4::Command::file->new->execute($c->options, $c->argv);
     return;
}


sub symlink {
    my $c = shift;
my $desc = "symlink (creates dir of symlinks) [OPTIONS] PIPELINE
 Create symlinks with identifiers based on a datasource column (specified by --id_field)\n";
    my %options = (
           #'datasource|d=s' => 'Provides a path name to a datasource.',
          'run_num|r=i'  => 'run_num',
          'id_field|f=s'   => 'Field in the datasource that will be the file prefix',
          'step_and_fname|s=s' => 'Step and filename in format STEP#FILENAME',
          #'path|p=s' => 'Path of symlink directory other than default, which will be created if it does not exist',
          'name|n=s' => 'Replaces filename with new name',
          'datasource|d=s' => 'Path to datasource file, if not given then datasource of the run_num will be used'
          );  
      $c->getopt( keys %options );
      return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
      App::Pipeline::Lite4::Command::symlink2->new->execute($c->options, $c->argv);
}

#sub symlink2 {
#      my $c = shift;
#    my $desc = 'symlink (creates dir of symlinks) [OPTIONS] PIPELINE';
#    my %options = (
#           #'datasource|d=s' => 'Provides a path name to a datasource.',
#          'run_num|r=i'  => 'run_num',
#          'id_field|f=s'   => 'Field in the datasource that will be the file prefix',
#          'step_and_fname|s=s' => 'Step and filename in format STEP#FILENAME (required)',
#          'path|p=s' => 'Path of symlink directory other than default, which will be created if it does not exist',
#          'name|n=s' => 'Replaces filename with new name',
#          'datasource|d=s' => 'Path to datasource file, if not given then datasource of the last run will be used'
#          );  
#      $c->getopt( keys %options );
#      return _usage ( $desc, \%options ) if scalar @{ $c->argv } == 0;
#      App::Pipeline::Lite4::Command::symlink2->new->execute($c->options, $c->argv);
#}


sub _options_str {
    my $options = shift;
    my $options_str;
    foreach my $key ( nsort keys %$options ){
       my ($longform,$shortform) = $key =~ /(.+)\|([a-z]+)/;
       $options_str .= "\t-$shortform --$longform\t" . $options->{$key} . "\n";  
    }
    return $options_str; 
}

sub _usage {
    my $cmd = shift;
    my $options_str = _options_str( shift);
    my $usage = <<USAGE
    
Usage: plite $cmd
     $options_str
USAGE
;
    return $usage;
}
